<?xml version="1.0" encoding="UTF-8"?>
<class name="PrimeFinder">
  <javadoc>
    <text>Not of interest for users; only for implementors of hashtables.
 * Used to keep hash table capacities prime numbers.
 * &lt;p&gt;Choosing prime numbers as hash table capacities is a good idea to keep them working fast,
 * particularly under hash table expansions.
 * &lt;p&gt;However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to keep capacities prime.
 * This class provides efficient means to choose prime capacities.
 * &lt;p&gt;Choosing a prime is &lt;tt&gt;O(log 300)&lt;/tt&gt; (binary search in a list of 300 int's).
 * Memory requirements: 1 KB static memory.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>The largest prime this class can generate; currently equal to &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="int" name="largestPrime" />
  <javadoc>
    <text>The prime number list consists of 11 chunks.
 * Each chunk contains prime numbers.
 * A chunk starts with a prime P1. The next element is a prime P2. P2 is the smallest prime for which holds: P2 &gt;= 2*P1.
 * The next element is P3, for which the same holds with respect to P2, and so on.
 * Chunks are chosen such that for any desired capacity &gt;= 1000 
 * the list includes a prime number &lt;= desired capacity * 1.11 (11%).
 * For any desired capacity &gt;= 200 
 * the list includes a prime number &lt;= desired capacity * 1.16 (16%).
 * For any desired capacity &gt;= 16
 * the list includes a prime number &lt;= desired capacity * 1.21 (21%).
 * Therefore, primes can be retrieved which are quite close to any desired capacity,
 * which in turn avoids wasting memory.
 * For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081.
 * So if you need a prime &gt;= 1040, you will find a prime &lt;= 1040*1.11=1154.
 * Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0;
 * If your hashtable has such a growthfactor then,  
 * after initially "rounding to a prime" upon hashtable construction, 
 * it will later expand to prime capacities such that there exist no better primes.
 * In total these are about 32*10=320 numbers -&gt; 1 KB of static memory needed.
 * If you are stingy, then delete every second or fourth chunk.</text>
  </javadoc>
  <declaration type="int[]" name="primeCapacities" />
  <scope />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="PrimeFinder" />
  <javadoc>
    <text>Tests correctness. Try 
 * from=1000, to=10000
 * from=200,  to=1000
 * from=16,   to=1000
 * from=1000, to=Integer.MAX_VALUE</text>
  </javadoc>
  <method type="void" name="main">
    <declaration type="int" name="from" />
    <declaration type="int" name="to" />
  </method>
  <javadoc>
    <text>Returns a prime number which is &lt;code&gt;&amp;gt;= desiredCapacity&lt;/code&gt; and very close to &lt;code&gt;desiredCapacity&lt;/code&gt; (within 11% if &lt;code&gt;desiredCapacity &amp;gt;= 1000&lt;/code&gt;).</text>
    <param>desiredCapacity the capacity desired by the user.</param>
    <return>the capacity which should be used for a hashtable.</return>
  </javadoc>
  <method type="int" name="nextPrime">
    <declaration type="int" name="i" />
    <scope />
    <comment>int i = new cern.colt.list.IntArrayList(primeCapacities).binarySearch(desiredCapacity);  for debug only TODO</comment>
    <comment>desired capacity not found, choose next prime greater than desired capacity</comment>
    <comment>remember the semantics of binarySearch...</comment>
  </method>
  <javadoc>
    <text>Tests correctness.</text>
  </javadoc>
  <method type="void" name="statistics">
    <scope />
    <declaration type="double" name="accDeviation" />
    <declaration type="double" name="maxDeviation" />
    <scope>
      <declaration type="int" name="primeCapacity" />
      <declaration type="double" name="deviation" />
      <scope />
    </scope>
    <declaration type="long" name="width" />
    <declaration type="double" name="meanDeviation" />
    <comment>check that primes contain no accidental errors</comment>
    <comment>System.out.println(primeCapacity);</comment>
  </method>
  <comment>yes, it is prime.</comment>
  <comment>chunk #0</comment>
  <comment>chunk #1</comment>
  <comment>chunk #2</comment>
  <comment>chunk #3</comment>
  <comment>chunk #4</comment>
  <comment>chunk #5</comment>
  <comment>chunk #6</comment>
  <comment>chunk #7</comment>
  <comment>chunk #8</comment>
  <comment>chunk #9</comment>
  <comment>chunk #10</comment>
  <comment>some more chunks for the low range [3..1000]
chunk #11
13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,
539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,
276172823,552345671,1104691373,

chunk #12
19,41,83,167,337,677,
1361,2729,5471,10949,21911,43853,87719,175447,350899,
701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,
359339171,718678369,1437356741,

chunk #13
53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,
234539,469099,938207,1876417,3752839,7505681,15011389,30022781,
60045577,120091177,240182359,480364727,960729461,1921458943</comment>
  <comment>initializer</comment>
  <comment>The above prime numbers are formatted for human readability.</comment>
  <comment>To find numbers fast, we sort them once and for all.</comment>
  <comment>new cern.colt.list.IntArrayList(primeCapacities).mergeSort();  for debug only, TODO</comment>
</class>
