<?xml version="1.0" encoding="UTF-8"?>
<class name="Statistic">
  <javadoc>
    <text>Basic statistics operations on matrices.
 * Computation of covariance, correlation, distance matrix.
 * Random sampling views.
 * Conversion to histograms with and without OLAP cube operators.
 * Conversion to bins with retrieval of statistical bin measures.
 * Also see {@link cern.jet.stat} and {@link hep.aida.bin}, in particular {@link hep.aida.bin.DynamicBin1D}.
 * &lt;p&gt;
 * Examples:
 * &lt;table border="1" cellspacing="0" dwcopytype="CopyTableRow"&gt;
 * &lt;tr valign="top" align="center"&gt; 
 * &lt;td&gt;&lt;tt&gt;A&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;covariance(A)&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;correlation(covariance(A))&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;distance(A,EUCLID)&lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="top"&gt; 
 * &lt;td&gt;&lt;tt&gt; 4&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
 * 1&amp;nbsp;&amp;nbsp;2&amp;nbsp;&amp;nbsp;&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;&amp;nbsp;4&amp;nbsp;&amp;nbsp;&amp;nbsp;6&lt;br&gt;
 * 3&amp;nbsp;&amp;nbsp;6&amp;nbsp;&amp;nbsp;&amp;nbsp;9&lt;br&gt;
 * 4&amp;nbsp;-8&amp;nbsp;-10 &lt;/tt&gt; &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 3&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
 * &amp;nbsp;1.25&amp;nbsp;-3.5&amp;nbsp;-4.5&lt;br&gt;
 * -3.5&amp;nbsp;&amp;nbsp;29&amp;nbsp;&amp;nbsp;&amp;nbsp;39&amp;nbsp;&amp;nbsp;&lt;br&gt;
 * -4.5&amp;nbsp;&amp;nbsp;39&amp;nbsp;&amp;nbsp;&amp;nbsp;52.5 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 3&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
 * &amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-0.581318&amp;nbsp;-0.555492&lt;br&gt;
 * -0.581318&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.999507&lt;br&gt;
 * -0.555492&amp;nbsp;&amp;nbsp;0.999507&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
 * &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 3&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
 * &amp;nbsp;0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;12.569805&amp;nbsp;15.874508&lt;br&gt;
 * 12.569805&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4.242641&lt;br&gt;
 * 15.874508&amp;nbsp;&amp;nbsp;4.242641&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
 * &lt;/tt&gt; &lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <declaration type="cern.jet.math.Functions" name="F" />
  <javadoc>
    <text>Euclidean distance function; &lt;tt&gt;Sqrt(Sum( (x[i]-y[i])^2 ))&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="VectorVectorFunction" name="EUCLID" />
  <javadoc>
    <text>Bray-Curtis distance function; &lt;tt&gt;Sum( abs(x[i]-y[i]) )  /  Sum( x[i]+y[i] )&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="VectorVectorFunction" name="BRAY_CURTIS" />
  <javadoc>
    <text>Canberra distance function; &lt;tt&gt;Sum( abs(x[i]-y[i]) / abs(x[i]+y[i]) )&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="fun" />
  <method type="double" name="apply" />
  <declaration type="VectorVectorFunction" name="CANBERRA" />
  <javadoc>
    <text>Maximum distance function; &lt;tt&gt;Max( abs(x[i]-y[i]) )&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="VectorVectorFunction" name="MAXIMUM" />
  <javadoc>
    <text>Manhattan distance function; &lt;tt&gt;Sum( abs(x[i]-y[i]) )&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="VectorVectorFunction" name="MANHATTAN" />
  <javadoc>
    <text>Interface that represents a function object: a function that takes 
 * two argument vectors and returns a single value.</text>
  </javadoc>
  <method name="apply" type="double" />
  <javadoc>
    <text>Applies a function to two argument vectors.</text>
    <param>x   the first argument vector passed to the function.</param>
    <param>y   the second argument vector passed to the function.</param>
    <return>the result of the function.</return>
  </javadoc>
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Statistic" />
  <javadoc>
    <text>Applies the given aggregation functions to each column and stores the results in a the result matrix.
 * If matrix has shape &lt;tt&gt;m x n&lt;/tt&gt;, then result must have shape &lt;tt&gt;aggr.length x n&lt;/tt&gt;.
 * Tip: To do aggregations on rows use dice views (transpositions), as in &lt;tt&gt;aggregate(matrix.viewDice(),aggr,result.viewDice())&lt;/tt&gt;.</text>
    <param>matrix any matrix; a column holds the values of a given variable.</param>
    <param>aggr the aggregation functions to be applied to each column.</param>
    <param>result the matrix to hold the aggregation results.</param>
    <return>&lt;tt&gt;result&lt;/tt&gt; (for convenience only).</return>
    <see>Formatter</see>
    <see>hep.aida.bin.BinFunction1D</see>
    <see>hep.aida.bin.BinFunctions1D</see>
  </javadoc>
  <method type="DoubleMatrix2D" name="aggregate">
    <declaration type="DynamicBin1D" name="bin" />
    <declaration type="double[]" name="elements" />
    <declaration type="cern.colt.list.DoubleArrayList" name="values" />
    <scope>
      <scope />
    </scope>
    <comment>copy column into values</comment>
  </method>
  <javadoc>
    <text>Fills all cell values of the given vector into a bin from which statistics measures can be retrieved efficiently.
 * Cells values are copied.
 * &lt;br&gt;
 * Tip: Use &lt;tt&gt;System.out.println(bin(vector))&lt;/tt&gt; to print most measures computed by the bin. Example:
 * &lt;table&gt;
 * &lt;td class="PRE"&gt; 
 * &lt;pre&gt;
 * Size: 20000
 * Sum: 299858.02350278624
 * SumOfSquares: 5399184.154095971
 * Min: 0.8639113139711261
 * Max: 59.75331890541892
 * Mean: 14.992901175139313
 * RMS: 16.43043540825375
 * Variance: 45.17438077634358
 * Standard deviation: 6.721188940681818
 * Standard error: 0.04752598277592142
 * Geometric mean: 13.516615397064466
 * Product: Infinity
 * Harmonic mean: 11.995174297952191
 * Sum of inversions: 1667.337172700724
 * Skew: 0.8922838940067878
 * Kurtosis: 1.1915828121825598
 * Sum of powers(3): 1.1345828465808412E8
 * Sum of powers(4): 2.7251055344494686E9
 * Sum of powers(5): 7.367125643433887E10
 * Sum of powers(6): 2.215370909100143E12
 * Moment(0,0): 1.0
 * Moment(1,0): 14.992901175139313
 * Moment(2,0): 269.95920770479853
 * Moment(3,0): 5672.914232904206
 * Moment(4,0): 136255.27672247344
 * Moment(5,0): 3683562.8217169433
 * Moment(6,0): 1.1076854545500715E8
 * Moment(0,mean()): 1.0
 * Moment(1,mean()): -2.0806734113421045E-14
 * Moment(2,mean()): 45.172122057305664
 * Moment(3,mean()): 270.92018671421
 * Moment(4,mean()): 8553.8664869067
 * Moment(5,mean()): 153357.41712233616
 * Moment(6,mean()): 4273757.570142922
 * 25%, 50% and 75% Quantiles: 10.030074811938091, 13.977982089912224,
 * 18.86124362967137
 * quantileInverse(mean): 0.559163335012079
 * Distinct elements &amp; frequencies not printed (too many).
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;/table&gt;</text>
    <param>vector the vector to analyze.</param>
    <return>a bin holding the statistics measures of the vector.</return>
  </javadoc>
  <method type="DynamicBin1D" name="bin">
    <declaration type="DynamicBin1D" name="bin" />
  </method>
  <javadoc>
    <text>Modifies the given covariance matrix to be a correlation matrix (in-place).
 * The correlation matrix is a square, symmetric matrix consisting of nothing but correlation coefficients.
 * The rows and the columns represent the variables, the cells represent correlation coefficients. 
 * The diagonal cells (i.e. the correlation between a variable and itself) will equal 1, for the simple reason that the correlation coefficient of a variable with itself equals 1. 
 * The correlation of two column vectors x and y is given by &lt;tt&gt;corr(x,y) = cov(x,y) / (stdDev(x)*stdDev(y))&lt;/tt&gt; (Pearson's correlation coefficient).
 * A correlation coefficient varies between -1 (for a perfect negative relationship) to +1 (for a perfect positive relationship). 
 * See the &lt;A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"&gt; math definition&lt;/A&gt;
 * and &lt;A HREF="http://www.stat.berkeley.edu/users/stark/SticiGui/Text/gloss.htm#correlation_coef"&gt; another def&lt;/A&gt;.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
    <param>covariance a covariance matrix, as, for example, returned by method {@link #covariance(DoubleMatrix2D)}.</param>
    <return>the modified covariance, now correlation matrix (for convenience only).</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="correlation">
    <scope>
      <scope>
        <declaration type="double" name="stdDev1" />
        <declaration type="double" name="stdDev2" />
        <declaration type="double" name="cov" />
        <declaration type="double" name="corr" />
      </scope>
    </scope>
    <comment>symmetric</comment>
  </method>
  <javadoc>
    <text>Constructs and returns the covariance matrix of the given matrix.
 * The covariance matrix is a square, symmetric matrix consisting of nothing but covariance coefficients. 
 * The rows and the columns represent the variables, the cells represent covariance coefficients. 
 * The diagonal cells (i.e. the covariance between a variable and itself) will equal the variances.
 * The covariance of two column vectors x and y is given by &lt;tt&gt;cov(x,y) = (1/n) * Sum((x[i]-mean(x)) * (y[i]-mean(y)))&lt;/tt&gt;.
 * See the &lt;A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"&gt; math definition&lt;/A&gt;.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
    <param>matrix any matrix; a column holds the values of a given variable.</param>
    <return>the covariance matrix (&lt;tt&gt;n x n, n=matrix.columns&lt;/tt&gt;).</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="covariance">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="DoubleMatrix2D" name="covariance" />
    <declaration type="double[]" name="sums" />
    <declaration type="DoubleMatrix1D[]" name="cols" />
    <scope />
    <scope>
      <scope>
        <declaration type="double" name="sumOfProducts" />
        <declaration type="double" name="cov" />
      </scope>
    </scope>
    <comment>symmetric</comment>
  </method>
  <javadoc>
    <text>2-d OLAP cube operator; Fills all cells of the given vectors into the given histogram.
 * If you use hep.aida.ref.Converter.toString(histo) on the result, the OLAP cube of x-"column" vs. y-"column" , summing the weights "column" will be printed.
 * For example, aggregate sales by product by region.
 * &lt;p&gt;
 * Computes the distinct values of x and y, yielding histogram axes that capture one distinct value per bin.
 * Then fills the histogram.
 * &lt;p&gt;
 * Example output:
 * &lt;table&gt;
 * &lt;td class="PRE"&gt; 
 * &lt;pre&gt;
 * Cube:
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;Entries=5000, ExtraEntries=0
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;MeanX=4.9838, RmsX=NaN
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;MeanY=2.5304, RmsY=NaN
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;xAxis: Min=0, Max=10, Bins=11
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;yAxis: Min=0, Max=5, Bins=6
 * Heights:
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;| X
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;| 0   1   2   3   4   5   6   7   8   9   10  | Sum 
 * ----------------------------------------------------------
 * Y 5   |  30  53  51  52  57  39  65  61  55  49  22 |  534
 * &amp;nbsp;&amp;nbsp;4   |  43 106 112  96  92  94 107  98  98 110  47 | 1003
 * &amp;nbsp;&amp;nbsp;3   |  39 134  87  93 102 103 110  90 114  98  51 | 1021
 * &amp;nbsp;&amp;nbsp;2   |  44  81 113  96 101  86 109  83 111  93  42 |  959
 * &amp;nbsp;&amp;nbsp;1   |  54  94 103  99 115  92  98  97 103  90  44 |  989
 * &amp;nbsp;&amp;nbsp;0   |  24  54  52  44  42  56  46  47  56  53  20 |  494
 * ----------------------------------------------------------
 * &amp;nbsp;&amp;nbsp;Sum | 234 522 518 480 509 470 535 476 537 493 226 |     
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;/table&gt;</text>
    <return>the histogram containing the cube.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size() || y.size() != weights.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="hep.aida.IHistogram2D" name="cube">
    <declaration type="double" name="epsilon" />
    <declaration type="cern.colt.list.DoubleArrayList" name="distinct" />
    <declaration type="double[]" name="vals" />
    <declaration type="cern.colt.list.DoubleArrayList" name="sorted" />
    <declaration type="hep.aida.IAxis" name="xaxis" />
    <declaration type="hep.aida.IAxis" name="yaxis" />
    <declaration type="hep.aida.IHistogram2D" name="histo" />
    <comment>compute distinct values of x</comment>
    <comment>copy x into vals</comment>
    <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
    <comment>compute distinct values of y</comment>
    <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
  </method>
  <javadoc>
    <text>3-d OLAP cube operator; Fills all cells of the given vectors into the given histogram.
 * If you use hep.aida.ref.Converter.toString(histo) on the result, the OLAP cube of x-"column" vs. y-"column" vs. z-"column", summing the weights "column" will be printed.
 * For example, aggregate sales by product by region by time.
 * &lt;p&gt;
 * Computes the distinct values of x and y and z, yielding histogram axes that capture one distinct value per bin.
 * Then fills the histogram.</text>
    <return>the histogram containing the cube.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size() || x.size() != z.size() || x.size() != weights.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="hep.aida.IHistogram3D" name="cube">
    <declaration type="double" name="epsilon" />
    <declaration type="cern.colt.list.DoubleArrayList" name="distinct" />
    <declaration type="double[]" name="vals" />
    <declaration type="cern.colt.list.DoubleArrayList" name="sorted" />
    <declaration type="hep.aida.IAxis" name="xaxis" />
    <declaration type="hep.aida.IAxis" name="yaxis" />
    <declaration type="hep.aida.IAxis" name="zaxis" />
    <declaration type="hep.aida.IHistogram3D" name="histo" />
    <comment>compute distinct values of x</comment>
    <comment>copy x into vals</comment>
    <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
    <comment>compute distinct values of y</comment>
    <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
    <comment>compute distinct values of z</comment>
    <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
  </method>
  <javadoc>
    <text>Demonstrates usage of this class.</text>
  </javadoc>
  <method type="void" name="demo1">
    <declaration type="double[][]" name="values" />
    <declaration type="DoubleFactory2D" name="factory" />
    <declaration type="DoubleMatrix2D" name="A" />
    <comment>System.out.println(correlation(covariance(A)));</comment>
    <comment>System.out.println(distance(A,EUCLID));</comment>
    <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(A.toString()));</comment>
    <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(covariance(A).toString()));</comment>
    <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(correlation(covariance(A)).toString()));</comment>
    <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(distance(A,EUCLID).toString()));</comment>
  </method>
  <javadoc>
    <text>Demonstrates usage of this class.</text>
  </javadoc>
  <method type="void" name="demo2">
    <declaration type="DoubleFactory2D" name="factory" />
    <declaration type="DoubleMatrix2D" name="A" />
    <declaration type="cern.colt.Timer" name="timer" />
    <declaration type="DoubleMatrix2D" name="corr" />
    <scope />
    <comment>double value = 1;</comment>
    <comment>DoubleMatrix2D A = factory.make(rows,columns);</comment>
    <comment>A.assign(value);</comment>
  </method>
  <javadoc>
    <text>Demonstrates usage of this class.</text>
  </javadoc>
  <method type="void" name="demo3">
    <declaration type="double[][]" name="values" />
    <declaration type="DoubleFactory2D" name="factory" />
    <declaration type="DoubleMatrix2D" name="A" />
  </method>
  <javadoc>
    <text>Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
    <param>matrix any matrix; a column holds the values of a given variable (vector).</param>
    <param>distanceFunction (EUCLID, CANBERRA, ..., or any user defined distance function operating on two vectors).</param>
    <return>the distance matrix (&lt;tt&gt;n x n, n=matrix.columns&lt;/tt&gt;).</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="distance">
    <declaration type="int" name="columns" />
    <declaration type="DoubleMatrix2D" name="distance" />
    <declaration type="DoubleMatrix1D[]" name="cols" />
    <scope />
    <scope>
      <scope>
        <declaration type="double" name="d" />
      </scope>
    </scope>
    <comment>cache views</comment>
    <comment>work out all permutations</comment>
    <comment>symmetric</comment>
  </method>
  <javadoc>
    <text>Fills all cells of the given vector into the given histogram.</text>
    <return>&lt;tt&gt;histo&lt;/tt&gt; (for convenience only).</return>
  </javadoc>
  <method type="hep.aida.IHistogram1D" name="histogram">
    <scope />
  </method>
  <javadoc>
    <text>Fills all cells of the given vectors into the given histogram.</text>
    <return>&lt;tt&gt;histo&lt;/tt&gt; (for convenience only).</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="hep.aida.IHistogram2D" name="histogram">
    <scope />
  </method>
  <javadoc>
    <text>Fills all cells of the given vectors into the given histogram.</text>
    <return>&lt;tt&gt;histo&lt;/tt&gt; (for convenience only).</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size() || y.size() != weights.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="hep.aida.IHistogram2D" name="histogram">
    <scope />
  </method>
  <javadoc>
    <text>Fills all cells of the given vectors into the given histogram.</text>
    <return>&lt;tt&gt;histo&lt;/tt&gt; (for convenience only).</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size() || x.size() != z.size() || x.size() != weights.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="hep.aida.IHistogram3D" name="histogram">
    <scope />
  </method>
  <javadoc>
    <text>Benchmarks covariance computation.</text>
  </javadoc>
  <method type="void" name="main">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="boolean" name="print" />
  </method>
  <javadoc>
    <text>Constructs and returns a sampling view with a size of &lt;tt&gt;round(matrix.size() * fraction)&lt;/tt&gt;.
 * Samples "without replacement" from the uniform distribution.</text>
    <param>matrix any matrix.</param>
    <param>rowFraction the percentage of rows to be included in the view.</param>
    <param>columnFraction the percentage of columns to be included in the view.</param>
    <param>randomGenerator a uniform random number generator; set this parameter to &lt;tt&gt;null&lt;/tt&gt; to use a default generator seeded with the current time.</param>
    <return>the sampling view.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;! (0 &lt;= rowFraction &lt;= 1 &amp;&amp; 0 &lt;= columnFraction &lt;= 1)&lt;/tt&gt;.</throws>
    <see>cern.jet.random.sampling.RandomSampler</see>
  </javadoc>
  <method type="DoubleMatrix1D" name="viewSample">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="ncols" />
    <declaration type="int" name="max" />
    <declaration type="long[]" name="selected" />
    <declaration type="int" name="n" />
    <declaration type="int" name="N" />
    <declaration type="int[]" name="selectedCols" />
    <comment>check preconditions and allow for a little tolerance</comment>
    <comment>random generator seeded with current time</comment>
    <comment>sampler works on long's, not int's</comment>
    <comment>sample</comment>
  </method>
  <javadoc>
    <text>Constructs and returns a sampling view with &lt;tt&gt;round(matrix.rows() * rowFraction)&lt;/tt&gt; rows and &lt;tt&gt;round(matrix.columns() * columnFraction)&lt;/tt&gt; columns.
 * Samples "without replacement".
 * Rows and columns are randomly chosen from the uniform distribution.
 * Examples: 
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr valign="top" align="center"&gt; 
 * &lt;td&gt; 
 * &lt;div align="left"&gt;&lt;tt&gt;matrix&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="left"&gt;&lt;tt&gt;rowFraction=0.2&lt;br&gt;
 * columnFraction=0.2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="left"&gt;&lt;tt&gt;rowFraction=0.2&lt;br&gt;
 * columnFraction=1.0 &lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="left"&gt;&lt;tt&gt;rowFraction=1.0&lt;br&gt;
 * columnFraction=0.2 &lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="top"&gt; 
 * &lt;td&gt;&lt;tt&gt; 10&amp;nbsp;x&amp;nbsp;10&amp;nbsp;matrix&lt;br&gt;
 * &amp;nbsp;1&amp;nbsp;&amp;nbsp;2&amp;nbsp;&amp;nbsp;3&amp;nbsp;&amp;nbsp;4&amp;nbsp;&amp;nbsp;5&amp;nbsp;&amp;nbsp;6&amp;nbsp;&amp;nbsp;7&amp;nbsp;&amp;nbsp;8&amp;nbsp;&amp;nbsp;9&amp;nbsp;&amp;nbsp;10&lt;br&gt;
 * 11&amp;nbsp;12&amp;nbsp;13&amp;nbsp;14&amp;nbsp;15&amp;nbsp;16&amp;nbsp;17&amp;nbsp;18&amp;nbsp;19&amp;nbsp;&amp;nbsp;20&lt;br&gt;
 * 21&amp;nbsp;22&amp;nbsp;23&amp;nbsp;24&amp;nbsp;25&amp;nbsp;26&amp;nbsp;27&amp;nbsp;28&amp;nbsp;29&amp;nbsp;&amp;nbsp;30&lt;br&gt;
 * 31&amp;nbsp;32&amp;nbsp;33&amp;nbsp;34&amp;nbsp;35&amp;nbsp;36&amp;nbsp;37&amp;nbsp;38&amp;nbsp;39&amp;nbsp;&amp;nbsp;40&lt;br&gt;
 * 41&amp;nbsp;42&amp;nbsp;43&amp;nbsp;44&amp;nbsp;45&amp;nbsp;46&amp;nbsp;47&amp;nbsp;48&amp;nbsp;49&amp;nbsp;&amp;nbsp;50&lt;br&gt;
 * 51&amp;nbsp;52&amp;nbsp;53&amp;nbsp;54&amp;nbsp;55&amp;nbsp;56&amp;nbsp;57&amp;nbsp;58&amp;nbsp;59&amp;nbsp;&amp;nbsp;60&lt;br&gt;
 * 61&amp;nbsp;62&amp;nbsp;63&amp;nbsp;64&amp;nbsp;65&amp;nbsp;66&amp;nbsp;67&amp;nbsp;68&amp;nbsp;69&amp;nbsp;&amp;nbsp;70&lt;br&gt;
 * 71&amp;nbsp;72&amp;nbsp;73&amp;nbsp;74&amp;nbsp;75&amp;nbsp;76&amp;nbsp;77&amp;nbsp;78&amp;nbsp;79&amp;nbsp;&amp;nbsp;80&lt;br&gt;
 * 81&amp;nbsp;82&amp;nbsp;83&amp;nbsp;84&amp;nbsp;85&amp;nbsp;86&amp;nbsp;87&amp;nbsp;88&amp;nbsp;89&amp;nbsp;&amp;nbsp;90&lt;br&gt;
 * 91&amp;nbsp;92&amp;nbsp;93&amp;nbsp;94&amp;nbsp;95&amp;nbsp;96&amp;nbsp;97&amp;nbsp;98&amp;nbsp;99&amp;nbsp;100 
 * &lt;/tt&gt; &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 2&amp;nbsp;x&amp;nbsp;2&amp;nbsp;matrix&lt;br&gt;
 * 43&amp;nbsp;50&lt;br&gt;
 * 53&amp;nbsp;60 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 2&amp;nbsp;x&amp;nbsp;10&amp;nbsp;matrix&lt;br&gt;
 * 41&amp;nbsp;42&amp;nbsp;43&amp;nbsp;44&amp;nbsp;45&amp;nbsp;46&amp;nbsp;47&amp;nbsp;48&amp;nbsp;49&amp;nbsp;&amp;nbsp;50&lt;br&gt;
 * 91&amp;nbsp;92&amp;nbsp;93&amp;nbsp;94&amp;nbsp;95&amp;nbsp;96&amp;nbsp;97&amp;nbsp;98&amp;nbsp;99&amp;nbsp;100 
 * &lt;/tt&gt; &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 10&amp;nbsp;x&amp;nbsp;2&amp;nbsp;matrix&lt;br&gt;
 * &amp;nbsp;4&amp;nbsp;&amp;nbsp;8&lt;br&gt;
 * 14&amp;nbsp;18&lt;br&gt;
 * 24&amp;nbsp;28&lt;br&gt;
 * 34&amp;nbsp;38&lt;br&gt;
 * 44&amp;nbsp;48&lt;br&gt;
 * 54&amp;nbsp;58&lt;br&gt;
 * 64&amp;nbsp;68&lt;br&gt;
 * 74&amp;nbsp;78&lt;br&gt;
 * 84&amp;nbsp;88&lt;br&gt;
 * 94&amp;nbsp;98 &lt;/tt&gt; &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>matrix any matrix.</param>
    <param>rowFraction the percentage of rows to be included in the view.</param>
    <param>columnFraction the percentage of columns to be included in the view.</param>
    <param>randomGenerator a uniform random number generator; set this parameter to &lt;tt&gt;null&lt;/tt&gt; to use a default generator seeded with the current time.</param>
    <return>the sampling view.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;! (0 &lt;= rowFraction &lt;= 1 &amp;&amp; 0 &lt;= columnFraction &lt;= 1)&lt;/tt&gt;.</throws>
    <see>cern.jet.random.sampling.RandomSampler</see>
  </javadoc>
  <method type="DoubleMatrix2D" name="viewSample">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="nrows" />
    <declaration type="int" name="ncols" />
    <declaration type="int" name="max" />
    <declaration type="long[]" name="selected" />
    <declaration type="int" name="n" />
    <declaration type="int" name="N" />
    <declaration type="int[]" name="selectedRows" />
    <declaration type="int[]" name="selectedCols" />
    <comment>check preconditions and allow for a little tolerance</comment>
    <comment>random generator seeded with current time</comment>
    <comment>sampler works on long's, not int's</comment>
    <comment>sample rows</comment>
    <comment>sample columns</comment>
  </method>
  <javadoc>
    <text>Constructs and returns a sampling view with &lt;tt&gt;round(matrix.slices() * sliceFraction)&lt;/tt&gt; slices and &lt;tt&gt;round(matrix.rows() * rowFraction)&lt;/tt&gt; rows and &lt;tt&gt;round(matrix.columns() * columnFraction)&lt;/tt&gt; columns.
 * Samples "without replacement".
 * Slices, rows and columns are randomly chosen from the uniform distribution.</text>
    <param>matrix any matrix.</param>
    <param>sliceFraction the percentage of slices to be included in the view.</param>
    <param>rowFraction the percentage of rows to be included in the view.</param>
    <param>columnFraction the percentage of columns to be included in the view.</param>
    <param>randomGenerator a uniform random number generator; set this parameter to &lt;tt&gt;null&lt;/tt&gt; to use a default generator seeded with the current time.</param>
    <return>the sampling view.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;! (0 &lt;= sliceFraction &lt;= 1 &amp;&amp; 0 &lt;= rowFraction &lt;= 1 &amp;&amp; 0 &lt;= columnFraction &lt;= 1)&lt;/tt&gt;.</throws>
    <see>cern.jet.random.sampling.RandomSampler</see>
  </javadoc>
  <method type="DoubleMatrix3D" name="viewSample">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="nslices" />
    <declaration type="int" name="nrows" />
    <declaration type="int" name="ncols" />
    <declaration type="int" name="max" />
    <declaration type="long[]" name="selected" />
    <declaration type="int" name="n" />
    <declaration type="int" name="N" />
    <declaration type="int[]" name="selectedSlices" />
    <declaration type="int[]" name="selectedRows" />
    <declaration type="int[]" name="selectedCols" />
    <comment>check preconditions and allow for a little tolerance</comment>
    <comment>random generator seeded with current time</comment>
    <comment>sampler works on long's, not int's</comment>
    <comment>sample slices</comment>
    <comment>sample rows</comment>
    <comment>sample columns</comment>
  </method>
  <javadoc>
    <text>Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
    <param>matrix any matrix; a column holds the values of a given variable (vector).</param>
    <param>norm the kind of norm to be used (EUCLID, CANBERRA, ...).</param>
    <return>the distance matrix (&lt;tt&gt;n x n, n=matrix.columns&lt;/tt&gt;).</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="xdistanceOld">
    <comment>int rows = matrix.rows();
int columns = matrix.columns();
DoubleMatrix2D distance = new cern.colt.matrix.impl.DenseDoubleMatrix2D(columns,columns);

 cache views
DoubleMatrix1D[] cols = new DoubleMatrix1D[columns];
for (int i=columns; --i &gt;= 0; ) {
cols[i] = matrix.viewColumn(i);
}

 setup distance function
cern.jet.math.Functions F = cern.jet.math.Functions.functions;
DoubleDoubleFunction function = null;
DoubleDoubleFunction function2 = null;
if (norm==EUCLID) function = F.chain(F.square,F.minus);
else if (norm==BRAY_CURTIS) function = F.chain(F.abs,F.minus);
else if (norm==CANBERRA) function = new DoubleDoubleFunction() {
public final double apply(double a, double b) {	return Math.abs(a-b)  Math.abs(a+b);}
};
else if (norm==MAXIMUM) function = F.chain(F.abs,F.minus);
else if (norm==MANHATTAN) function = F.chain(F.abs,F.minus);
else throw new IllegalArgumentException("Unknown norm");

 work out all permutations
for (int i=columns; --i &gt;= 0; ) {
for (int j=i; --j &gt;= 0; ) {
double d = 0;
if (norm==EUCLID) d = Math.sqrt(cols[i].aggregate(cols[j], F.plus, function));
else if (norm==BRAY_CURTIS) d = cols[i].aggregate(cols[j], F.plus, function)  cols[i].aggregate(cols[j], F.plus, F.plus);
else if (norm==CANBERRA) d = cols[i].aggregate(cols[j], F.plus, function);
else if (norm==MAXIMUM) d = cols[i].aggregate(cols[j], F.max, function);
else if (norm==MANHATTAN) d = cols[i].aggregate(cols[j], F.plus, function);
distance.setQuick(i,j,d);
distance.setQuick(j,i,d);  symmetric
}
}
return distance;</comment>
  </method>
  <javadoc>
    <text>Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
    <param>matrix any matrix; a column holds the values of a given variable (vector).</param>
    <param>norm the kind of norm to be used (EUCLID, CANBERRA, ...).</param>
    <return>the distance matrix (&lt;tt&gt;n x n, n=matrix.columns&lt;/tt&gt;).</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="xdistanceOld2">
    <comment>setup distance function
final cern.jet.math.Functions F = cern.jet.math.Functions.functions;
VectorVectorFunction function;
if (norm==EUCLID) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return Math.sqrt(a.aggregate(b, F.plus, F.chain(F.square,F.minus)));
}
};
else if (norm==BRAY_CURTIS) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.plus, F.chain(F.abs,F.minus))  a.aggregate(b, F.plus, F.plus);
}
};
else if (norm==CANBERRA) function = new VectorVectorFunction() {
DoubleDoubleFunction fun = new DoubleDoubleFunction() {
public final double apply(double a, double b) {
return Math.abs(a-b)  Math.abs(a+b);
}
};
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.plus, fun);
}
};
else if (norm==MAXIMUM) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.max, F.chain(F.abs,F.minus));
}
};
else if (norm==MANHATTAN) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.plus, F.chain(F.abs,F.minus));
}
};
else throw new IllegalArgumentException("Unknown norm");

return distance(matrix,function);</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
