<?xml version="1.0" encoding="UTF-8"?>
<class name="DoubleFactory2D">
  <javadoc>
    <text>Factory for convenient construction of 2-d matrices holding &lt;tt&gt;double&lt;/tt&gt; 
 * cells. Also provides convenient methods to compose (concatenate) and decompose 
 * (split) matrices from/to constituent blocks. &lt;/p&gt;
 * &lt;p&gt;&amp;nbsp; &lt;/p&gt;
 * &lt;table border="0" cellspacing="0"&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt;Construction&lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use idioms like &lt;tt&gt;DoubleFactory2D.dense.make(4,4)&lt;/tt&gt; to construct 
 * dense matrices, &lt;tt&gt;DoubleFactory2D.sparse.make(4,4)&lt;/tt&gt; to construct sparse 
 * matrices.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt; Construction with initial values &lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use other &lt;tt&gt;make&lt;/tt&gt; methods to construct matrices with given initial 
 * values. &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt; Appending rows and columns &lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use methods {@link #appendColumns(DoubleMatrix2D,DoubleMatrix2D) appendColumns}, {@link #appendColumns(DoubleMatrix2D,DoubleMatrix2D) appendRows} and {@link #repeat(DoubleMatrix2D,int,int) repeat} to append rows and columns. &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt; General block matrices &lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use methods {@link #compose(DoubleMatrix2D[][]) compose} and {@link #decompose(DoubleMatrix2D[][],DoubleMatrix2D) 
 * decompose} to work with general block matrices. &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt; Diagonal matrices &lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use methods {@link #diagonal(DoubleMatrix1D) diagonal(vector)}, {@link #diagonal(DoubleMatrix2D) diagonal(matrix)} and {@link #identity(int) identity} 
 * to work with diagonal matrices. &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt; Diagonal block matrices &lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use method {@link #composeDiagonal(DoubleMatrix2D,DoubleMatrix2D,DoubleMatrix2D) 
 * composeDiagonal} to work with diagonal block matrices. &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;i&gt;Random&lt;/i&gt;&lt;/td&gt;
 * &lt;td&gt;Use methods {@link #random(int,int) random} and {@link #sample(int,int,double,double) 
 * sample} to construct random matrices. &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
 * &lt;p&gt;If the factory is used frequently it might be useful to streamline the notation. 
 * For example by aliasing: &lt;/p&gt;
 * &lt;table&gt;
 * &lt;td class="PRE"&gt; 
 * &lt;pre&gt;
 * DoubleFactory2D F = DoubleFactory2D.dense;
 * F.make(4,4);
 * F.descending(10,20);
 * F.random(4,4);
 * ...
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;/table&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>A factory producing dense matrices.</text>
  </javadoc>
  <declaration type="DoubleFactory2D" name="dense" />
  <javadoc>
    <text>A factory producing sparse hash matrices.</text>
  </javadoc>
  <declaration type="DoubleFactory2D" name="sparse" />
  <javadoc>
    <text>A factory producing sparse row compressed matrices.</text>
  </javadoc>
  <declaration type="DoubleFactory2D" name="rowCompressed" />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="DoubleFactory2D" />
  <javadoc>
    <text>C = A||B; Constructs a new matrix which is the column-wise concatenation of two other matrices.
 * &lt;pre&gt;
 * 0 1 2
 * 3 4 5
 * appendColumns
 * 6 7
 * 8 9
 * --&gt;
 * 0 1 2 6 7 
 * 3 4 5 8 9
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="appendColumns">
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
    <declaration type="int" name="r" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <comment>force both to have maximal shared number of rows.</comment>
    <comment>concatenate</comment>
  </method>
  <javadoc>
    <text>C = A||B; Constructs a new matrix which is the row-wise concatenation of two other matrices.
 * &lt;pre&gt;
 * 0 1 
 * 2 3 
 * 4 5
 * appendRows
 * 6 7
 * 8 9
 * --&gt;
 * 0 1 
 * 2 3 
 * 4 5
 * 6 7
 * 8 9
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="appendRows">
    <declaration type="int" name="ar" />
    <declaration type="int" name="br" />
    <declaration type="int" name="c" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <comment>force both to have maximal shared number of columns.</comment>
    <comment>concatenate</comment>
  </method>
  <javadoc>
    <text>Constructs a matrix with cells having ascending values.
 * For debugging purposes.
 * Example:
 * &lt;pre&gt;
 * 0 1 2 
 * 3 4 5
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="ascending">
    <declaration type="cern.jet.math.Functions" name="F" />
  </method>
  <javadoc>
    <text>Checks whether the given array is rectangular, that is, whether all rows have the same number of columns.</text>
    <throws>IllegalArgumentException if the array is not rectangular.</throws>
  </javadoc>
  <method type="void" name="checkRectangularShape">
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Checks whether the given array is rectangular, that is, whether all rows have the same number of columns.</text>
    <throws>IllegalArgumentException if the array is not rectangular.</throws>
  </javadoc>
  <method type="void" name="checkRectangularShape">
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Constructs a block matrix made from the given parts.
 * The inverse to method {@link #decompose(DoubleMatrix2D[][],DoubleMatrix2D)}.
 * &lt;p&gt;
 * All matrices of a given column within &lt;tt&gt;parts&lt;/tt&gt; must have the same number of columns.
 * All matrices of a given row within &lt;tt&gt;parts&lt;/tt&gt; must have the same number of rows.
 * Otherwise an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; is thrown. 
 * Note that &lt;tt&gt;null&lt;/tt&gt;s within &lt;tt&gt;parts[row,col]&lt;/tt&gt; are an exception to this rule: they are ignored.
 * Cells are copied.
 * Example:
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;tt&gt;Code&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;Result&lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt; 
 * &lt;pre&gt;
 * DoubleMatrix2D[][] parts1 = 
 * {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ null,        make(2,2,1), null        },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ make(4,4,2), null,        make(4,3,3) },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ null,        make(2,2,4), null        }
 * };
 * System.out.println(compose(parts1));
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;8&amp;nbsp;x&amp;nbsp;9&amp;nbsp;matrix&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;4&amp;nbsp;4&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;4&amp;nbsp;4&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt; 
 * &lt;pre&gt;
 * DoubleMatrix2D[][] parts3 = 
 * {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ identity(3),               null,                        },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ null,                      identity(3).viewColumnFlip() },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ identity(3).viewRowFlip(), null                         }
 * };
 * System.out.println("\n"+make(parts3));
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;9&amp;nbsp;x&amp;nbsp;6&amp;nbsp;matrix&lt;br&gt;
 * 1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt; 
 * &lt;pre&gt;
 * DoubleMatrix2D A = ascending(2,2);
 * DoubleMatrix2D B = descending(2,2);
 * DoubleMatrix2D _ = null;
 * DoubleMatrix2D[][] parts4 = 
 * {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ A, _, A, _ },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ _, A, _, B }
 * };
 * System.out.println("\n"+make(parts4));
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;8&amp;nbsp;matrix&lt;br&gt;
 * 1&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 3&amp;nbsp;4&amp;nbsp;0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;4&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;2&amp;nbsp;0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;2&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;3&amp;nbsp;4&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt; 
 * &lt;pre&gt;
 * DoubleMatrix2D[][] parts2 = 
 * {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ null,        make(2,2,1), null        },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ make(4,4,2), null,        make(4,3,3) },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ null,        make(2,3,4), null        }
 * };
 * System.out.println("\n"+Factory2D.make(parts2));
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;IllegalArgumentException&lt;br&gt;
 * A[0,1].cols != A[2,1].cols&lt;br&gt;
 * (2 != 3)&lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <throws>IllegalArgumentException subject to the conditions outlined above.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="compose">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="DoubleMatrix2D" name="empty" />
    <declaration type="int[]" name="maxWidths" />
    <scope>
      <declaration type="int" name="maxWidth" />
      <scope>
        <declaration type="DoubleMatrix2D" name="part" />
        <scope>
          <declaration type="int" name="width" />
        </scope>
      </scope>
    </scope>
    <declaration type="int[]" name="maxHeights" />
    <scope>
      <declaration type="int" name="maxHeight" />
      <scope>
        <declaration type="DoubleMatrix2D" name="part" />
        <scope>
          <declaration type="int" name="height" />
        </scope>
      </scope>
    </scope>
    <declaration type="int" name="resultRows" />
    <declaration type="int" name="resultCols" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <declaration type="int" name="r" />
    <scope>
      <declaration type="int" name="c" />
      <scope>
        <declaration type="DoubleMatrix2D" name="part" />
        <scope />
      </scope>
    </scope>
    <comment>determine maximum column width of each column</comment>
    <comment>determine row height of each row</comment>
    <comment>shape of result</comment>
    <comment>copy</comment>
  </method>
  <javadoc>
    <text>Constructs a diagonal block matrix from the given parts (the &lt;i&gt;direct sum&lt;/i&gt; of two matrices).
 * That is the concatenation
 * &lt;pre&gt;
 * A 0
 * 0 B
 * &lt;/pre&gt;
 * (The direct sum has &lt;tt&gt;A.rows()+B.rows()&lt;/tt&gt; rows and &lt;tt&gt;A.columns()+B.columns()&lt;/tt&gt; columns).
 * Cells are copied.</text>
    <return>a new matrix which is the direct sum.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="composeDiagonal">
    <declaration type="int" name="ar" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="br" />
    <declaration type="int" name="bc" />
    <declaration type="DoubleMatrix2D" name="sum" />
  </method>
  <javadoc>
    <text>Constructs a diagonal block matrix from the given parts.
 * The concatenation has the form
 * &lt;pre&gt;
 * A 0 0
 * 0 B 0
 * 0 0 C
 * &lt;/pre&gt;
 * from the given parts.
 * Cells are copied.</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="composeDiagonal">
    <declaration type="DoubleMatrix2D" name="diag" />
  </method>
  <javadoc>
    <text>Splits a block matrix into its constituent blocks; Copies blocks of a matrix into the given parts.
 * The inverse to method {@link #compose(DoubleMatrix2D[][])}.
 * &lt;p&gt;
 * All matrices of a given column within &lt;tt&gt;parts&lt;/tt&gt; must have the same number of columns.
 * All matrices of a given row within &lt;tt&gt;parts&lt;/tt&gt; must have the same number of rows.
 * Otherwise an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; is thrown. 
 * Note that &lt;tt&gt;null&lt;/tt&gt;s within &lt;tt&gt;parts[row,col]&lt;/tt&gt; are an exception to this rule: they are ignored.
 * Cells are copied.
 * Example:
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt;&lt;tt&gt;Code&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;matrix&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;--&amp;gt; parts &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td&gt; 
 * &lt;pre&gt;
 * DoubleMatrix2D matrix = ... ;
 * DoubleMatrix2D _ = null;
 * DoubleMatrix2D A,B,C,D;
 * A = make(2,2); B = make (4,4);
 * C = make(4,3); D = make (2,2);
 * DoubleMatrix2D[][] parts = 
 * {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ _, A, _ },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ B, _, C },
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;{ _, D, _ }
 * };
 * decompose(parts,matrix);
 * System.out.println(&amp;quot;\nA = &amp;quot;+A);
 * System.out.println(&amp;quot;\nB = &amp;quot;+B);
 * System.out.println(&amp;quot;\nC = &amp;quot;+C);
 * System.out.println(&amp;quot;\nD = &amp;quot;+D);
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;8&amp;nbsp;x&amp;nbsp;9&amp;nbsp;matrix&lt;br&gt;
 * 9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;1&amp;nbsp;1&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&lt;br&gt;
 * 9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;1&amp;nbsp;1&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;9&amp;nbsp;9&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;9&amp;nbsp;9&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;9&amp;nbsp;9&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;9&amp;nbsp;9&amp;nbsp;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;4&amp;nbsp;4&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&lt;br&gt;
 * 9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&amp;nbsp;4&amp;nbsp;4&amp;nbsp;9&amp;nbsp;9&amp;nbsp;9&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;p&gt;&lt;tt&gt;A = 2&amp;nbsp;x&amp;nbsp;2&amp;nbsp;matrix&lt;br&gt;
 * 1&amp;nbsp;1&lt;br&gt;
 * 1&amp;nbsp;1&lt;/tt&gt;&lt;/p&gt;
 * &lt;p&gt;&lt;tt&gt;B = 4&amp;nbsp;x&amp;nbsp;4&amp;nbsp;matrix&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&lt;br&gt;
 * 2&amp;nbsp;2&amp;nbsp;2&amp;nbsp;2&lt;/tt&gt;&lt;/p&gt;
 * &lt;p&gt;&lt;tt&gt;C = 4&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
 * 3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * 3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * &lt;/tt&gt;&lt;tt&gt;3&amp;nbsp;3&amp;nbsp;3&lt;br&gt;
 * &lt;/tt&gt;&lt;tt&gt;3&amp;nbsp;3&amp;nbsp;3&lt;/tt&gt;&lt;/p&gt;
 * &lt;p&gt;&lt;tt&gt;D = 2&amp;nbsp;x&amp;nbsp;2&amp;nbsp;matrix&lt;br&gt;
 * 4&amp;nbsp;4&lt;br&gt;
 * 4&amp;nbsp;4&lt;/tt&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <throws>IllegalArgumentException subject to the conditions outlined above.</throws>
  </javadoc>
  <method type="void" name="decompose">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="int[]" name="maxWidths" />
    <scope>
      <declaration type="int" name="maxWidth" />
      <scope>
        <declaration type="DoubleMatrix2D" name="part" />
        <scope>
          <declaration type="int" name="width" />
        </scope>
      </scope>
    </scope>
    <declaration type="int[]" name="maxHeights" />
    <scope>
      <declaration type="int" name="maxHeight" />
      <scope>
        <declaration type="DoubleMatrix2D" name="part" />
        <scope>
          <declaration type="int" name="height" />
        </scope>
      </scope>
    </scope>
    <declaration type="int" name="resultRows" />
    <declaration type="int" name="resultCols" />
    <declaration type="int" name="r" />
    <scope>
      <declaration type="int" name="c" />
      <scope>
        <declaration type="DoubleMatrix2D" name="part" />
        <scope />
      </scope>
    </scope>
    <comment>determine maximum column width of each column</comment>
    <comment>determine row height of each row</comment>
    <comment>shape of result parts</comment>
    <comment>copy</comment>
  </method>
  <javadoc>
    <text>Demonstrates usage of this class.</text>
  </javadoc>
  <method type="void" name="demo1">
    <declaration type="DoubleMatrix2D[][]" name="parts1" />
    <declaration type="DoubleMatrix2D[][]" name="parts3" />
    <declaration type="DoubleMatrix2D" name="A" />
    <declaration type="DoubleMatrix2D" name="B" />
    <declaration type="DoubleMatrix2D" name="_" />
    <declaration type="DoubleMatrix2D[][]" name="parts4" />
    <comment>System.out.println("\n"+cern.colt.matrixpattern.Converting.toHTML(make(parts1).toString()));</comment>
    <comment>illegal 2 != 3
DoubleMatrix2D[][] parts2 =
{
{ null,        make(2,2,1), null        },
{ make(4,4,2), null,        make(4,3,3) },
{ null,        make(2,3,4), null        }
};
System.out.println("\n"+make(parts2));</comment>
    <comment>System.out.println("\n"+cern.colt.matrixpattern.Converting.toHTML(make(parts3).toString()));</comment>
    <comment>System.out.println("\n"+cern.colt.matrixpattern.Converting.toHTML(make(parts4).toString()));</comment>
  </method>
  <javadoc>
    <text>Demonstrates usage of this class.</text>
  </javadoc>
  <method type="void" name="demo2">
    <declaration type="DoubleMatrix2D" name="matrix" />
    <declaration type="DoubleMatrix2D" name="A" />
    <declaration type="DoubleMatrix2D" name="_" />
    <declaration type="DoubleMatrix2D[][]" name="parts1" />
    <comment>System.out.println("\n"+cern.colt.matrixpattern.Converting.toHTML(make(parts1).toString()));</comment>
    <comment>illegal 2 != 3
DoubleMatrix2D[][] parts2 =
{
{ null,        make(2,2,1), null        },
{ make(4,4,2), null,        make(4,3,3) },
{ null,        make(2,3,4), null        }
};
System.out.println("\n"+Factory2D.make(parts2));</comment>
    <comment>DoubleMatrix2D[][] parts3 =
{
{ identity(3),               null,                        },
{ null,                      identity(3).viewColumnFlip() },
{ identity(3).viewRowFlip(), null                         }
};
System.out.println("\n"+make(parts3));
System.out.println("\n"+cern.colt.matrixpattern.Converting.toHTML(make(parts3).toString()));

DoubleMatrix2D A = ascending(2,2);
DoubleMatrix2D B = descending(2,2);
DoubleMatrix2D _ = null;

DoubleMatrix2D[][] parts4 =
{
{ A, _, A, _ },
{ _, A, _, B }
};
System.out.println("\n"+make(parts4));
System.out.println("\n"+cern.colt.matrixpattern.Converting.toHTML(make(parts4).toString()));</comment>
  </method>
  <javadoc>
    <text>Constructs a matrix with cells having descending values.
 * For debugging purposes.
 * Example:
 * &lt;pre&gt;
 * 5 4 3 
 * 2 1 0
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="descending">
    <declaration type="DoubleMatrix2D" name="matrix" />
    <declaration type="int" name="v" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Constructs a new diagonal matrix whose diagonal elements are the elements of &lt;tt&gt;vector&lt;/tt&gt;.
 * Cells values are copied. The new matrix is not a view.
 * Example:
 * &lt;pre&gt;
 * 5 4 3 --&gt;
 * 5 0 0
 * 0 4 0
 * 0 0 3
 * &lt;/pre&gt;</text>
    <return>a new matrix.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="diagonal">
    <declaration type="int" name="size" />
    <declaration type="DoubleMatrix2D" name="diag" />
    <scope />
  </method>
  <javadoc>
    <text>Constructs a new vector consisting of the diagonal elements of &lt;tt&gt;A&lt;/tt&gt;.
 * Cells values are copied. The new vector is not a view.
 * Example:
 * &lt;pre&gt;
 * 5 0 0 9
 * 0 4 0 9
 * 0 0 3 9
 * --&gt; 5 4 3
 * &lt;/pre&gt;</text>
    <param>A the matrix, need not be square.</param>
    <return>a new vector.</return>
  </javadoc>
  <method type="DoubleMatrix1D" name="diagonal">
    <declaration type="int" name="min" />
    <declaration type="DoubleMatrix1D" name="diag" />
    <scope />
  </method>
  <javadoc>
    <text>Constructs an identity matrix (having ones on the diagonal and zeros elsewhere).</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="identity">
    <declaration type="DoubleMatrix2D" name="matrix" />
    <scope />
  </method>
  <javadoc>
    <text>Constructs a matrix with the given cell values.
 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
 * and have exactly the same number of columns in every row.
 * &lt;p&gt;
 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.</text>
    <param>values The values to be filled into the new matrix.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;for any 1 &amp;lt;= row &amp;lt; values.length: values[row].length != values[row-1].length&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="make" />
  <javadoc>
    <text>Construct a matrix from a one-dimensional column-major packed array, ala Fortran.
 * Has the form &lt;tt&gt;matrix.get(row,column) == values[row + column*rows]&lt;/tt&gt;.
 * The values are copied.</text>
    <param>values One-dimensional array of doubles, packed by columns (ala Fortran).</param>
    <param>rows  the number of rows.</param>
    <exception>IllegalArgumentException &lt;tt&gt;values.length&lt;/tt&gt; must be a multiple of &lt;tt&gt;rows&lt;/tt&gt;.</exception>
  </javadoc>
  <method type="DoubleMatrix2D" name="make">
    <declaration type="int" name="columns" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Constructs a matrix with the given shape, each cell initialized with zero.</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="make">
    <comment>if (this==rowCompressedModified) return new RCMDoubleMatrix2D(rows,columns);</comment>
  </method>
  <javadoc>
    <text>Constructs a matrix with the given shape, each cell initialized with the given value.</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="make" />
  <javadoc>
    <text>Constructs a 1d matrix of the right dynamic type.</text>
  </javadoc>
  <method type="DoubleMatrix1D" name="make1D" />
  <javadoc>
    <text>Constructs a matrix with uniformly distributed values in &lt;tt&gt;(0,1)&lt;/tt&gt; (exclusive).</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="random" />
  <javadoc>
    <text>C = A||A||..||A; Constructs a new matrix which is duplicated both along the row and column dimension.
 * Example:
 * &lt;pre&gt;
 * 0 1
 * 2 3
 * repeat(2,3) --&gt;
 * 0 1 0 1 0 1
 * 2 3 2 3 2 3
 * 0 1 0 1 0 1
 * 2 3 2 3 2 3
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="DoubleMatrix2D" name="repeat">
    <declaration type="int" name="r" />
    <declaration type="int" name="c" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Constructs a randomly sampled matrix with the given shape.
 * Randomly picks exactly &lt;tt&gt;Math.round(rows*columns*nonZeroFraction)&lt;/tt&gt; cells and initializes them to &lt;tt&gt;value&lt;/tt&gt;, all the rest will be initialized to zero.
 * Note that this is not the same as setting each cell with probability &lt;tt&gt;nonZeroFraction&lt;/tt&gt; to &lt;tt&gt;value&lt;/tt&gt;.
 * Note: The random seed is a constant.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;nonZeroFraction &lt; 0 || nonZeroFraction &gt; 1&lt;/tt&gt;.</throws>
    <see>cern.jet.random.sampling.RandomSampler</see>
  </javadoc>
  <method type="DoubleMatrix2D" name="sample">
    <declaration type="DoubleMatrix2D" name="matrix" />
  </method>
  <javadoc>
    <text>Modifies the given matrix to be a randomly sampled matrix.
 * Randomly picks exactly &lt;tt&gt;Math.round(rows*columns*nonZeroFraction)&lt;/tt&gt; cells and initializes them to &lt;tt&gt;value&lt;/tt&gt;, all the rest will be initialized to zero.
 * Note that this is not the same as setting each cell with probability &lt;tt&gt;nonZeroFraction&lt;/tt&gt; to &lt;tt&gt;value&lt;/tt&gt;.
 * Note: The random seed is a constant.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;nonZeroFraction &lt; 0 || nonZeroFraction &gt; 1&lt;/tt&gt;.</throws>
    <see>cern.jet.random.sampling.RandomSampler</see>
  </javadoc>
  <method type="DoubleMatrix2D" name="sample">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="size" />
    <declaration type="int" name="n" />
    <declaration type="cern.jet.random.sampling.RandomSamplingAssistant" name="sampler" />
    <scope>
      <scope>
        <declaration type="int" name="row" />
        <declaration type="int" name="column" />
      </scope>
    </scope>
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>A factory producing sparse row compressed modified matrices.</comment>
  <comment>public static final DoubleFactory2D rowCompressedModified = new DoubleFactory2D();</comment>
</class>
