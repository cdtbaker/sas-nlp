<?xml version="1.0" encoding="UTF-8"?>
<class name="Benchmark">
  <javadoc>
    <text>Benchmarks the performance of matrix algorithms.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Benchmark" />
  <javadoc>
    <text>Runs a bench on matrices holding double elements.</text>
  </javadoc>
  <method type="void" name="benchmark">
    <declaration type="cern.colt.Timer" name="timer1" />
    <declaration type="cern.colt.Timer" name="timer2" />
    <declaration type="cern.colt.Timer" name="timer3" />
    <declaration type="cern.colt.Timer" name="timer4" />
    <declaration type="cern.colt.Timer" name="timer5" />
    <declaration type="cern.colt.Timer" name="timer6" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <declaration type="double" name="value" />
    <declaration type="DoubleMatrix2D" name="tmp" />
    <declaration type="DoubleMatrix2D" name="dense" />
    <declaration type="DoubleMatrix2D" name="ADense" />
    <declaration type="DoubleMatrix2D" name="BDense" />
    <declaration type="DoubleMatrix2D" name="CDense" />
    <scope>
      <declaration type="DoubleMatrix2D" name="A" />
      <declaration type="DoubleMatrix2D" name="B" />
      <declaration type="DoubleMatrix2D" name="C" />
      <scope />
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="p" />
      <declaration type="int" name="reps" />
      <declaration type="double" name="mflops" />
    </scope>
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
    <comment>this involves primarly read-loops</comment>
    <comment>else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(size,size);</comment>
    <comment>Matrix AJ = new Matrix(columnwise,3);</comment>
    <comment>Basic.random(matrix, new cern.jet.random.Uniform(new cern.jet.random.engine.MersenneTwister()));</comment>
    <comment>long NN = matrix.size();
int nn = (int) (NNpercentNonZero);
long[] nonZeroIndexes = new long[nn];
cern.jet.random.sampling.RandomSampler sampler = new cern.jet.random.sampling.RandomSampler(nn,NN,0,new cern.jet.random.engine.MersenneTwister());
sampler.nextBlock(nn,nonZeroIndexes,0);
for (int i=nn; --i &gt;=0; ) {
int row = (int) (nonZeroIndexes[i]size);
int column = (int) (nonZeroIndexes[i]%size);
matrix.set(row,column, value);
}</comment>
    <comment>timer1.start();
for (int i=0; i&lt;runs; i++) {
LUDecomposition LU = new LUDecomposition(matrix);
}
timer1.stop();
timer1.display();

{
Jama.Matrix jmatrix = new Jama.Matrix(matrix.toArray());
timer2.start();
for (int i=0; i&lt;runs; i++) {
Jama.LUDecomposition LU = new Jama.LUDecomposition(jmatrix);
}
timer2.stop();
timer2.display();
}</comment>
    <comment>{
timer6.start();
double a = cubicLoop(runs,size);
timer6.stop();
timer6.display();
System.out.println(a);
}</comment>
    <comment>DoubleMatrix2D C = Basic.product(A,B);</comment>
    <comment>{
DoubleMatrix2D A = matrix.like().assign(value);
DoubleMatrix2D B = matrix.like().assign(value);
DoubleMatrix2D C = Basic.product(A,B);
timer5.start();
for (int i=0; i&lt;runs; i++) {
cern.colt.matrix.Blas.matrixMultiply(A,B,C);
}
timer5.stop();
timer5.display();
}</comment>
    <comment>{
Jama.Matrix A = new Jama.Matrix(size,size);
Jama.Matrix B = new Jama.Matrix(size,size);
Jama.Matrix C;
timer4.start();
for (int i=0; i&lt;runs; i++) {
C = A.times(B);
}
timer4.stop();
timer4.display();
}</comment>
  </method>
  <javadoc />
  <method type="double" name="cubicLoop">
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <scope>
      <scope>
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Benchmarks various matrix methods.</text>
  </javadoc>
  <method type="void" name="main">
    <declaration type="int" name="runs" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="String" name="kind" />
    <declaration type="int" name="initialCapacity" />
    <declaration type="double" name="minLoadFactor" />
    <declaration type="double" name="maxLoadFactor" />
    <declaration type="boolean" name="print" />
    <declaration type="double" name="initialValue" />
    <declaration type="int" name="size" />
    <comment>int size = Integer.parseInt(args[3]);</comment>
    <comment>boolean isSparse = args[4].equals("sparse");</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
