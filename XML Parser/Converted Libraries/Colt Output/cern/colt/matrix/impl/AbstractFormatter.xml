<?xml version="1.0" encoding="UTF-8"?>
<class name="AbstractFormatter">
  <javadoc>
    <text>Abstract base class for flexible, well human readable matrix print formatting.
 * Value type independent.
 * A single cell is formatted via a format string.
 * Columns can be aligned left, centered, right and by decimal point. 
 * &lt;p&gt;A column can be broader than specified by the parameter &lt;tt&gt;minColumnWidth&lt;/tt&gt; 
 * (because a cell may not fit into that width) but a column is never smaller than 
 * &lt;tt&gt;minColumnWidth&lt;/tt&gt;. Normally one does not need to specify &lt;tt&gt;minColumnWidth&lt;/tt&gt;.
 * Cells in a row are separated by a separator string, similar separators can be set for rows and slices.
 * For more info, see the concrete subclasses.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>The alignment string aligning the cells of a column to the left.</text>
  </javadoc>
  <declaration type="String" name="LEFT" />
  <javadoc>
    <text>The alignment string aligning the cells of a column to its center.</text>
  </javadoc>
  <declaration type="String" name="CENTER" />
  <javadoc>
    <text>The alignment string aligning the cells of a column to the right.</text>
  </javadoc>
  <declaration type="String" name="RIGHT" />
  <javadoc>
    <text>The alignment string aligning the cells of a column to the decimal point.</text>
  </javadoc>
  <declaration type="String" name="DECIMAL" />
  <javadoc>
    <text>The default minimum number of characters a column may have; currently &lt;tt&gt;1&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="int" name="DEFAULT_MIN_COLUMN_WIDTH" />
  <javadoc>
    <text>The default string separating any two columns from another; currently &lt;tt&gt;" "&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="DEFAULT_COLUMN_SEPARATOR" />
  <javadoc>
    <text>The default string separating any two rows from another; currently &lt;tt&gt;"\n"&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="DEFAULT_ROW_SEPARATOR" />
  <javadoc>
    <text>The default string separating any two slices from another; currently &lt;tt&gt;"\n\n"&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="DEFAULT_SLICE_SEPARATOR" />
  <javadoc>
    <text>The default format string for formatting a single cell value; currently &lt;tt&gt;"%G"&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="alignment" />
  <javadoc>
    <text>The default format string for formatting a single cell value; currently &lt;tt&gt;"%G"&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="format" />
  <javadoc>
    <text>The default minimum number of characters a column may have; currently &lt;tt&gt;1&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="int" name="minColumnWidth" />
  <javadoc>
    <text>The default string separating any two columns from another; currently &lt;tt&gt;" "&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="columnSeparator" />
  <javadoc>
    <text>The default string separating any two rows from another; currently &lt;tt&gt;"\n"&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="rowSeparator" />
  <javadoc>
    <text>The default string separating any two slices from another; currently &lt;tt&gt;"\n\n"&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="String" name="sliceSeparator" />
  <javadoc>
    <text>Tells whether String representations are to be preceded with summary of the shape; currently &lt;tt&gt;true&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="boolean" name="printShape" />
  <declaration type="String[]" name="blanksCache" />
  <declaration type="FormerFactory" name="factory" />
  <scope />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="AbstractFormatter" />
  <javadoc>
    <text>Modifies the strings in a column of the string matrix to be aligned (left,centered,right,decimal).</text>
  </javadoc>
  <method type="void" name="align">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="int[]" name="maxColWidth" />
    <declaration type="int[]" name="maxColLead" />
    <declaration type="boolean" name="isDecimal" />
    <scope>
      <declaration type="int" name="maxWidth" />
      <declaration type="int" name="maxLead" />
      <scope>
        <declaration type="String" name="s" />
      </scope>
    </scope>
    <scope />
    <comment>int[] maxColTrail = new int[columns];</comment>
    <comment>for each column, determine alignment parameters</comment>
    <comment>int maxTrail = Integer.MIN_VALUE;</comment>
    <comment>maxTrail = Math.max(maxTrail, trail(s));</comment>
    <comment>maxColTrail[column] = maxTrail;</comment>
    <comment>format each row according to alignment parameters</comment>
    <comment>StringBuffer total = new StringBuffer();</comment>
  </method>
  <javadoc>
    <text>Converts a row into a string.</text>
  </javadoc>
  <method type="int" name="alignmentCode">
    <comment>{-1,0,1,2} = {left,centered,right,decimal point}</comment>
  </method>
  <javadoc>
    <text>Modifies the strings the string matrix to be aligned (left,centered,right,decimal).</text>
  </javadoc>
  <method type="void" name="alignRow">
    <declaration type="int" name="align" />
    <declaration type="StringBuffer" name="s" />
    <declaration type="int" name="columns" />
    <scope>
      <declaration type="String" name="c" />
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>{-1,0,1,2} = {left,centered,right,decimal point}</comment>
    <comment>if (alignment==1) {</comment>
    <comment>else if (alignment==2) {</comment>
    <comment>else if (align==0) {</comment>
    <comment>else if (align&lt;0) {</comment>
  </method>
  <javadoc>
    <text>Returns a String with &lt;tt&gt;length&lt;/tt&gt; blanks.</text>
  </javadoc>
  <method type="String" name="blanks">
    <declaration type="StringBuffer" name="buf" />
    <scope />
  </method>
  <javadoc>
    <text>Demonstrates how to use this class.</text>
  </javadoc>
  <method type="void" name="demo1">
    <comment>parameters
Object[][] values = {
{3,     0,        -3.4, 0},
{5.1   ,0,        +3.0123456789, 0},
{16.37, 0.0,       2.5, 0},
{-16.3, 0,        -3.012345678E-4, -1},
{1236.3456789, 0,  7, -1.2}
};
String[] formats =         {"%G", "%1.10G", "%f", "%1.2f", "%0.2e", null};


 now the processing
int size = formats.length;
ObjectMatrix2D matrix = cern.colt.matrix.ObjectFactory2D.dense.make(values);
String[] strings = new String[size];
String[] sourceCodes = new String[size];
String[] htmlStrings = new String[size];
String[] htmlSourceCodes = new String[size];

for (int i=0; i&lt;size; i++) {
String format = formats[i];
strings[i] = toString(matrix,format);
sourceCodes[i] = toSourceCode(matrix,format);

 may not compile because of packages not included in the distribution
htmlStrings[i] = cern.colt.matrixpattern.Converting.toHTML(strings[i]);
htmlSourceCodes[i] = cern.colt.matrixpattern.Converting.toHTML(sourceCodes[i]);
}

System.out.println("original:\n"+toString(matrix));

 may not compile because of packages not included in the distribution
for (int i=0; i&lt;size; i++) {
System.out.println("\nhtmlString("+formats[i]+"):\n"+htmlStrings[i]);
System.out.println("\nhtmlSourceCode("+formats[i]+"):\n"+htmlSourceCodes[i]);
}

for (int i=0; i&lt;size; i++) {
System.out.println("\nstring("+formats[i]+"):\n"+strings[i]);
System.out.println("\nsourceCode("+formats[i]+"):\n"+sourceCodes[i]);
}</comment>
  </method>
  <javadoc>
    <text>Demonstrates how to use this class.</text>
  </javadoc>
  <method type="void" name="demo2">
    <comment>parameters
Object[] values = {
5, 0.0, -0.0, -Object.NaN, Object.NaN, 0.00.0, Object.NEGATIVE_INFINITY, Object.POSITIVE_INFINITY, Object.MIN_VALUE, Object.MAX_VALUE
5, 0.0, -0.0, -Object.NaN, Object.NaN, 0.00.0, Object.MIN_VALUE, Object.MAX_VALUE , Object.NEGATIVE_INFINITY, Object.POSITIVE_INFINITY
Object.MIN_VALUE, Object.MAX_VALUE , Object.NEGATIVE_INFINITY, Object.POSITIVE_INFINITY
};
String[] formats =         {"%G", "%1.10G", "%f", "%1.2f", "%0.2e"};
String[] formats =         {"%G", "%1.19G"};


 now the processing
int size = formats.length;
ObjectMatrix1D matrix = new DenseObjectMatrix1D(values);

String[] strings = new String[size];
String[] javaStrings = new String[size];

for (int i=0; i&lt;size; i++) {
String format = formats[i];
strings[i] = toString(matrix,format);
for (int j=0; j&lt;matrix.size(); j++) {
System.out.println(String.valueOf(matrix.get(j)));
}
}

System.out.println("original:\n"+toString(matrix));

for (int i=0; i&lt;size; i++) {
System.out.println("\nstring("+formats[i]+"):\n"+strings[i]);
}</comment>
  </method>
  <javadoc>
    <text>Demonstrates how to use this class.</text>
  </javadoc>
  <method type="void" name="demo3">
    <comment>cern.colt.Timer timer = new cern.colt.Timer();
String s;
StringBuffer buf;
ObjectMatrix2D matrix = cern.colt.matrix.ObjectFactory2D.dense.make(size,size, value);

timer.reset().start();
buf = new StringBuffer();
for (int i=size; --i &gt;= 0; ) {
for (int j=size; --j &gt;= 0; ) {
buf.append(matrix.getQuick(i,j));
}
}
buf = null;
timer.stop().display();

timer.reset().start();
corejava.Format format = new corejava.Format("%G");
buf = new StringBuffer();
for (int i=size; --i &gt;= 0; ) {
for (int j=size; --j &gt;= 0; ) {
buf.append(format.form(matrix.getQuick(i,j)));
}
}
buf = null;
timer.stop().display();

timer.reset().start();
s = Formatting.toString(matrix, null);
System.out.println(s);
s = null;
timer.stop().display();

timer.reset().start();
s = Formatting.toString(matrix, "%G");
System.out.println(s);
s = null;
timer.stop().display();</comment>
  </method>
  <method name="form" type="String" />
  <javadoc>
    <text>Converts a given cell to a String; no alignment considered.</text>
  </javadoc>
  <method name="format" type="String[][]" />
  <javadoc>
    <text>Returns a string representations of all cells; no alignment considered.</text>
  </javadoc>
  <javadoc>
    <text>Returns a string representations of all cells; no alignment considered.</text>
  </javadoc>
  <method type="String[]" name="formatRow">
    <declaration type="Former" name="formatter" />
    <declaration type="int" name="s" />
    <declaration type="String[]" name="strings" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the number of characters or the number of characters before the decimal point.</text>
  </javadoc>
  <method type="int" name="lead" />
  <javadoc>
    <text>Returns a String with the given character repeated &lt;tt&gt;length&lt;/tt&gt; times.</text>
  </javadoc>
  <method type="String" name="repeat">
    <declaration type="StringBuffer" name="buf" />
    <scope />
  </method>
  <javadoc>
    <text>Sets the column alignment (left,center,right,decimal).</text>
    <param>alignment the new alignment to be used; must be one of &lt;tt&gt;{LEFT,CENTER,RIGHT,DECIMAL}&lt;/tt&gt;.</param>
  </javadoc>
  <method type="void" name="setAlignment" />
  <javadoc>
    <text>Sets the string separating any two columns from another.</text>
    <param>columnSeparator the new columnSeparator to be used.</param>
  </javadoc>
  <method type="void" name="setColumnSeparator" />
  <javadoc>
    <text>Sets the way a &lt;i&gt;single&lt;/i&gt; cell value is to be formatted.</text>
    <param>format the new format to be used.</param>
  </javadoc>
  <method type="void" name="setFormat" />
  <javadoc>
    <text>Sets the minimum number of characters a column may have.</text>
    <param>minColumnWidth the new minColumnWidth to be used.</param>
  </javadoc>
  <method type="void" name="setMinColumnWidth" />
  <javadoc>
    <text>Specifies whether a string representation of a matrix is to be preceded with a summary of its shape.</text>
    <param>printShape &lt;tt&gt;true&lt;/tt&gt; shape summary is printed, otherwise not printed.</param>
  </javadoc>
  <method type="void" name="setPrintShape" />
  <javadoc>
    <text>Sets the string separating any two rows from another.</text>
    <param>rowSeparator the new rowSeparator to be used.</param>
  </javadoc>
  <method type="void" name="setRowSeparator" />
  <javadoc>
    <text>Sets the string separating any two slices from another.</text>
    <param>sliceSeparator the new sliceSeparator to be used.</param>
  </javadoc>
  <method type="void" name="setSliceSeparator" />
  <javadoc>
    <text>Cache for faster string processing.</text>
  </javadoc>
  <method type="void" name="setupBlanksCache">
    <declaration type="int" name="size" />
    <declaration type="StringBuffer" name="buf" />
    <declaration type="String" name="str" />
    <scope />
    <comment>Pre-fabricate 40 static strings with 0,1,2,..,39 blanks, for usage within method blanks(length).</comment>
    <comment>Now, we don't need to construct and fill them on demand, and garbage collect them again.</comment>
    <comment>All 40 strings share the identical char[] array, only with different offset and length --&gt; somewhat smaller static memory footprint</comment>
    <comment>System.out.println(i+"-"+blanksCache[i]+"-");</comment>
  </method>
  <javadoc>
    <text>Returns a short string representation describing the shape of the matrix.</text>
  </javadoc>
  <method type="String" name="shape">
    <comment>return "Matrix1D of size="+matrix.size();</comment>
    <comment>return matrix.size()+" element matrix";</comment>
    <comment>return "matrix("+matrix.size()+")";</comment>
  </method>
  <javadoc>
    <text>Returns a short string representation describing the shape of the matrix.</text>
  </javadoc>
  <method type="String" name="shape" />
  <javadoc>
    <text>Returns a short string representation describing the shape of the matrix.</text>
  </javadoc>
  <method type="String" name="shape" />
  <javadoc>
    <text>Returns a single string representation of the given string matrix.</text>
    <param>strings the matrix to be converted to a single string.</param>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="StringBuffer" name="total" />
    <declaration type="StringBuffer" name="s" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns a string representation of the given matrix.</text>
    <param>matrix the matrix to convert.</param>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="String[][]" name="strings" />
    <declaration type="StringBuffer" name="total" />
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>for efficient String manipulations</comment>
</class>
