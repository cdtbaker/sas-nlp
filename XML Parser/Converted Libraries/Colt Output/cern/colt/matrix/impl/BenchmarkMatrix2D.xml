<?xml version="1.0" encoding="UTF-8"?>
<class name="BenchmarkMatrix2D">
  <javadoc>
    <text>Benchmarks the performance of matrices. Here are the results of some encouraging 
 * measurements. Note that all benchmarks only measure the time spent in accessing 
 * a matrix element; they exclude the loop itself. 
 * &lt;p&gt; 
 * &lt;center&gt;
 * &lt;table border cellpadding="3" cellspacing="0" align="center"&gt;
 * &lt;tr valign="middle" bgcolor="#33CC66" nowrap align="center"&gt; 
 * &lt;td nowrap colspan="7"&gt; &lt;font size="+2"&gt;Iteration Performance [million method 
 * calls per second]&lt;/font&gt;&lt;br&gt;
 * &lt;font size="-1"&gt;Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic,&lt;br&gt;
 * 60 times repeating the same iteration &lt;/font&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#33CC66" nowrap align="center"&gt; 
 * &lt;td nowrap&gt; 
 * &lt;div align="left"&gt; Element type&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td nowrap colspan="6"&gt; Matrix2D type &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td nowrap bgcolor="#FF9966" rowspan="2"&gt; 
 * &lt;div align="left"&gt; .&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td bgcolor="#FF9966" colspan="2"&gt; 
 * &lt;p&gt;&lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt;&lt;br&gt;
 * 1000 x 1000 &lt;/p&gt;
 * &lt;/td&gt;
 * &lt;td bgcolor="#FF9966" colspan="2"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966" colspan="2"&gt; 
 * &lt;p&gt;&lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt;&lt;br&gt;
 * 100 x 1000,&lt;br&gt;
 * &lt;font size="-1"&gt; minLoadFactor=0.2, maxLoadFactor=0.5, initialCapacity 
 * = 0&lt;/font&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td bgcolor="#FF9966"&gt; getQuick&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt; setQuick&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt; getQuick&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt;setQuick&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td nowrap bgcolor="#FF9966"&gt;double&lt;/td&gt;
 * &lt;td nowrap&gt;5&lt;/td&gt;
 * &lt;td nowrap&gt;5&lt;/td&gt;
 * &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td nowrap&gt;1&lt;/td&gt;
 * &lt;td nowrap&gt;0.27&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td nowrap bgcolor="#FF9966"&gt; int&lt;/td&gt;
 * &lt;td nowrap&gt;5 &lt;/td&gt;
 * &lt;td nowrap&gt;5.5 &lt;/td&gt;
 * &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td nowrap&gt;1 &lt;/td&gt;
 * &lt;td nowrap&gt;0.3&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/center&gt;
 * &lt;p align="left"&gt; As can be seen, sparse matrices are certainly not quite as quick 
 * as dense ones, but not really slow either. Considering their minimal footprint 
 * they can be a real alternative. 
 * &lt;p&gt; Comparing the OO abstractions to zero-abstraction primitive Java arrays may 
 * or may not be useful. Still, the table below provides some interesting information. 
 * For example, access to &lt;tt&gt;Type_T_Matrix2D&lt;/tt&gt; is quicker than naive usage 
 * of &lt;tt&gt;Type_T_[]&lt;/tt&gt;. Primitive arrays should only be considered if the optimized 
 * form can be applied. Note again that all benchmarks only measure the time spent 
 * in accessing a matrix element; they exclude the loop itself. 
 * &lt;p&gt; 
 * &lt;center&gt;
 * &lt;table border cellpadding="3" cellspacing="0" align="center" width="617"&gt;
 * &lt;tr valign="middle" bgcolor="#33CC66" nowrap align="center"&gt; 
 * &lt;td height="30" nowrap colspan="7"&gt; &lt;font size="+2"&gt;Iteration Performance 
 * [million element accesses per second]&lt;/font&gt;&lt;br&gt;
 * &lt;font size="-1"&gt;Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic,&lt;br&gt;
 * 200 times repeating the same iteration &lt;/font&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#33CC66" nowrap align="center"&gt; 
 * &lt;td width="78" height="30" nowrap&gt; 
 * &lt;div align="left"&gt; Element type&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td height="30" nowrap colspan="6"&gt; 
 * &lt;div align="center"&gt;Matrix2D type = Java array &lt;tt&gt;double[][]&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td width="78" height="60" nowrap bgcolor="#FF9966" rowspan="2"&gt; 
 * &lt;div align="left"&gt; .&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td height="132" bgcolor="#FF9966" colspan="2"&gt; 
 * &lt;p&gt;Unoptimized Form&lt;br&gt;
 * 1000 x 1000&lt;br&gt;
 * &lt;div align="left"&gt; &lt;font size="-1"&gt; 
 * &lt;pre&gt;
 * for (int row=0; row &lt; rows; row++) { 
 * for (int col=0; col &lt; columns; ) { 
 * value = m[row][col++];
 * ...
 * }
 * }
 * &lt;/pre&gt;
 * &lt;/font&gt; &lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td height="132" bgcolor="#FF9966" colspan="4"&gt; Optimized Form&lt;br&gt;
 * 1000 x 1000 
 * &lt;div align="left"&gt; &lt;font size="-1"&gt; 
 * &lt;pre&gt;
 * for (int row=0; row &lt; rows; row++) { 
 * int[] r = matrix[row]; 
 * for (int col=0; col &lt; columns; ) { 
 * value = r[col++];
 * ...
 * }
 * }
 * &lt;/pre&gt;
 * &lt;/font&gt; &lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td width="152" height="30" bgcolor="#FF9966"&gt; getting&lt;/td&gt;
 * &lt;td width="144" height="30" bgcolor="#FF9966"&gt; setting&lt;/td&gt;
 * &lt;td width="150" height="30" bgcolor="#FF9966"&gt; getting&lt;/td&gt;
 * &lt;td width="138" height="30" bgcolor="#FF9966" colspan="3"&gt; setting&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td width="78" height="30" nowrap bgcolor="#FF9966"&gt;double&lt;/td&gt;
 * &lt;td width="152" height="30" nowrap&gt;1.6&lt;/td&gt;
 * &lt;td width="144" height="30" nowrap&gt;1.8&lt;/td&gt;
 * &lt;td width="150" height="30" nowrap&gt;18&lt;/td&gt;
 * &lt;td width="138" height="30" nowrap colspan="3"&gt;11&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td width="78" height="30" nowrap bgcolor="#FF9966"&gt; int&lt;/td&gt;
 * &lt;td width="152" height="30" nowrap&gt;1.5 &lt;/td&gt;
 * &lt;td width="144" height="30" nowrap&gt;1.8&lt;/td&gt;
 * &lt;td width="150" height="30" nowrap&gt;28&lt;/td&gt;
 * &lt;td width="138" height="30" nowrap colspan="3"&gt;26&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/center&gt;
 * &lt;left&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="BenchmarkMatrix2D" />
  <javadoc>
    <text>Runs a bench on matrices holding double elements.</text>
  </javadoc>
  <method type="void" name="doubleBenchmark">
    <declaration type="cern.colt.Timer" name="timer1" />
    <declaration type="cern.colt.Timer" name="timer2" />
    <declaration type="cern.colt.Timer" name="timer3" />
    <declaration type="cern.colt.Timer" name="timer4" />
    <declaration type="cern.colt.Timer" name="emptyLoop" />
    <declaration type="cern.colt.Timer" name="emptyLoop2" />
    <declaration type="int" name="dummy" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="double" name="dummy2" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="long" name="before" />
    <declaration type="long" name="size" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <scope>
      <declaration type="int" name="value" />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <declaration type="long" name="after" />
    <scope />
    <declaration type="double" name="element" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="DoubleMatrix2D" name="view" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
    <comment>this involves primarly read-loops</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(rows,columns);</comment>
    <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
    <comment>invite gc</comment>
    <comment>if (kind.equals("sparse")) {
int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--&gt; "+ ((double)hashCollisions  (rowscolumns)) +" hashCollisionselement on average.");
}</comment>
    <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
    <comment>if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseDoubleMatrix2D)matrix).elements.hashCollisions);</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseDoubleMatrix2D)view).elements.hashCollisions);</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
    <comment>initializing</comment>
    <comment>invite gc</comment>
    <comment>if (kind.equals("sparse")) System.out.println("hashCollisions"+((SparseDoubleMatrix2D)matrix).elements.hashCollisions);</comment>
  </method>
  <javadoc>
    <text>Runs a bench on matrices holding double elements.</text>
  </javadoc>
  <method type="void" name="doubleBenchmarkMult">
    <declaration type="cern.colt.Timer" name="timer1" />
    <declaration type="cern.colt.Timer" name="timer2" />
    <declaration type="long" name="size" />
    <declaration type="DoubleMatrix2D" name="matrix" />
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
    <comment>this involves primarly read-loops</comment>
    <comment>else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(rows,columns);</comment>
    <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
    <comment>if (kind.equals("sparse")) {
int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--&gt; "+ ((double)hashCollisions  (rowscolumns)) +" hashCollisionselement on average.");
}</comment>
    <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
    <comment>if (kind.equals("sparse")) {
int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--&gt; "+ ((double)hashCollisions  (rowscolumns)) +" hashCollisionselement on average.");
}</comment>
  </method>
  <javadoc>
    <text>Runs a bench on matrices holding double elements.</text>
  </javadoc>
  <method type="void" name="doubleBenchmarkPrimitive">
    <declaration type="cern.colt.Timer" name="timer1" />
    <declaration type="cern.colt.Timer" name="timer2" />
    <declaration type="cern.colt.Timer" name="timer3" />
    <declaration type="cern.colt.Timer" name="emptyLoop" />
    <declaration type="cern.colt.Timer" name="emptyLoop2" />
    <declaration type="int" name="dummy" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="double" name="dummy2" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="long" name="before" />
    <declaration type="long" name="size" />
    <declaration type="double[][]" name="matrix" />
    <scope>
      <declaration type="int" name="value" />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <declaration type="long" name="after" />
    <scope>
      <declaration type="DenseDoubleMatrix2D" name="m" />
    </scope>
    <declaration type="double" name="element" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="DenseDoubleMatrix2D" name="m" />
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <scope>
      <declaration type="DenseDoubleMatrix2D" name="m" />
    </scope>
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
    <comment>this involves primarly read-loops</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>invite gc</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>initializing
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
matrix.setQuick(row,column,1);
}
}</comment>
    <comment>invite gc</comment>
  </method>
  <javadoc>
    <text>Runs a bench on matrices holding double elements.</text>
  </javadoc>
  <method type="void" name="doubleBenchmarkPrimitiveOptimized">
    <declaration type="cern.colt.Timer" name="timer1" />
    <declaration type="cern.colt.Timer" name="timer2" />
    <declaration type="cern.colt.Timer" name="timer3" />
    <declaration type="cern.colt.Timer" name="emptyLoop" />
    <declaration type="cern.colt.Timer" name="emptyLoop2" />
    <declaration type="int" name="dummy" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="double" name="dummy2" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="long" name="before" />
    <declaration type="long" name="size" />
    <declaration type="double[][]" name="matrix" />
    <scope>
      <declaration type="int" name="value" />
      <scope>
        <declaration type="double[]" name="r" />
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <declaration type="long" name="after" />
    <scope>
      <declaration type="DenseDoubleMatrix2D" name="m" />
    </scope>
    <declaration type="double" name="element" />
    <scope>
      <scope>
        <declaration type="double[]" name="r" />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="DenseDoubleMatrix2D" name="m" />
    </scope>
    <scope>
      <scope>
        <declaration type="double[]" name="r" />
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <scope>
      <declaration type="DenseDoubleMatrix2D" name="m" />
    </scope>
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
    <comment>this involves primarly read-loops</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>matrix[row][column] = value++;</comment>
    <comment>invite gc</comment>
    <comment>element += matrix[row][column];</comment>
    <comment>!!! so that the jitter can't optimize away the whole loop</comment>
    <comment>matrix[row][column] = 0;</comment>
    <comment>invite gc</comment>
  </method>
  <javadoc>
    <text>Runs a bench on matrices holding int elements.</text>
  </javadoc>
  <method type="void" name="intBenchmark">
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.
 this involves primarly read-loops

cern.colt.Timer timer1 = new cern.colt.Timer();
cern.colt.Timer timer2 = new cern.colt.Timer();
cern.colt.Timer timer3 = new cern.colt.Timer();
cern.colt.Timer emptyLoop = new cern.colt.Timer();
cern.colt.Timer emptyLoop2 = new cern.colt.Timer();

emptyLoop.start();
int dummy = 0;
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
dummy++;
}
}
}
emptyLoop.stop();
System.out.println(dummy);  !!! so that the jitter can't optimize away the whole loop

emptyLoop2.start();
dummy = 3;
int dummy2 = 0;
for (int i=0; i&lt;runs; i++) {
for (int value = 0, column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
dummy2 += dummy;
}
}
}
emptyLoop2.stop();
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop

long before = Runtime.getRuntime().freeMemory();
long size = (((long)rows)columns)runs;

AbstractIntMatrix2D  matrix = null;
if (kind.equals("sparse")) matrix = new SparseIntMatrix2D(rows,columns,initialCapacity,minLoadFactor,maxLoadFactor);
else if (kind.equals("dense")) matrix = new DenseIntMatrix2D(rows,columns);
else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(rows,columns);
else throw new RuntimeException("unknown kind");

System.out.println("\nNow filling...");
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
for (int i=0; i&lt;runs; i++) {
matrix.assign(0);
matrix.ensureCapacity(initialCapacity);
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).ensureCapacity(initialCapacity);
timer1.start();
int value = 0;
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
matrix.setQuick(row,column,value++);
}
}
timer1.stop();
}
timer1.display();
timer1.minus(emptyLoop).display();
System.out.println(size  timer1.minus(emptyLoop).seconds() +" elements  sec");

Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
long after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)  1024);
System.out.println("bytes needed per non-zero="+(before-after)  (double)matrix.cardinality());
if (print) {
System.out.println(matrix);
if (kind.equals("sparse")) System.out.println("map="+((SparseIntMatrix2D)matrix).elements);
}
if (kind.equals("sparse")) {
int hashCollisions = ((SparseIntMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--&gt; "+ ((double)hashCollisions  (rowscolumns)) +" probeselement on average.");
}

System.out.println("\nNow reading...");
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
timer2.start();
int element=0;
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
element += matrix.getQuick(row,column);
}
}
}
timer2.stop().display();
timer2.minus(emptyLoop2).display();
System.out.println(size  timer2.minus(emptyLoop2).seconds() +" elements  sec");
if (print) System.out.println(matrix);
if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseIntMatrix2D)matrix).elements.hashCollisions);
System.out.println(element);  !!! so that the jitter can't optimize away the whole loop

System.out.println("\nNow removing...");
before = Runtime.getRuntime().freeMemory();
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
for (int i=0; i&lt;runs; i++) {
 initializing
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
matrix.setQuick(row,column,1);
}
}
timer3.start();
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
matrix.setQuick(row,column,0);
}
}
timer3.stop();
}
timer3.display();
timer3.minus(emptyLoop).display();
System.out.println(size  timer3.minus(emptyLoop).seconds() +" elements  sec");
Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)1024);
System.out.println("KB free="+(after1024));

if (print) System.out.println(matrix);
if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseIntMatrix2D)matrix).elements.hashCollisions);


System.out.println("bye bye.");</comment>
  </method>
  <javadoc>
    <text>Runs a bench on matrices holding int elements.</text>
  </javadoc>
  <method type="void" name="intBenchmarkPrimitive">
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.
 this involves primarly read-loops
cern.colt.Timer timer1 = new cern.colt.Timer();
cern.colt.Timer timer2 = new cern.colt.Timer();
cern.colt.Timer timer3 = new cern.colt.Timer();
cern.colt.Timer emptyLoop = new cern.colt.Timer();
cern.colt.Timer emptyLoop2 = new cern.colt.Timer();

emptyLoop.start();
int dummy = 0;
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
dummy++;
}
}
}
emptyLoop.stop();
System.out.println(dummy);  !!! so that the jitter can't optimize away the whole loop

emptyLoop2.start();
dummy = 3;
int dummy2 = 0;
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
dummy2 += dummy;
}
}
}
emptyLoop2.stop();
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop

long before = Runtime.getRuntime().freeMemory();
long size = (((long)rows)columns)runs;

int[][] matrix = new int[rows][columns];

System.out.println("\nNow filling...");
for (int i=0; i&lt;runs; i++) {
timer1.start();
int value = 0;
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
matrix[row][column] = value++;
}
}
timer1.stop();
}
timer1.display();
timer1.minus(emptyLoop).display();
System.out.println(size  timer1.minus(emptyLoop).seconds() +" elements  sec");

Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
long after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)  1024);
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("\nNow reading...");
timer2.start();
int element=0;
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
element += matrix[row][column];
}
}
}
timer2.stop().display();
timer2.minus(emptyLoop2).display();
System.out.println(size  timer2.minus(emptyLoop2).seconds() +" elements  sec");
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}
System.out.println(element);  !!! so that the jitter can't optimize away the whole loop

System.out.println("\nNow removing...");
before = Runtime.getRuntime().freeMemory();
for (int i=0; i&lt;runs; i++) {
timer3.start();
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
matrix[row][column] = 0;
}
}
timer3.stop();
}
timer3.display();
timer3.minus(emptyLoop).display();
System.out.println(size  timer3.minus(emptyLoop).seconds() +" elements  sec");
Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)1024);
System.out.println("KB free="+(after1024));

if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("bye bye.");</comment>
  </method>
  <javadoc>
    <text>Runs a bench on matrices holding int elements.</text>
  </javadoc>
  <method type="void" name="intBenchmarkPrimitiveOptimized">
    <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.
 this involves primarly read-loops
cern.colt.Timer timer1 = new cern.colt.Timer();
cern.colt.Timer timer2 = new cern.colt.Timer();
cern.colt.Timer timer3 = new cern.colt.Timer();
cern.colt.Timer emptyLoop = new cern.colt.Timer();
cern.colt.Timer emptyLoop2 = new cern.colt.Timer();

emptyLoop.start();
int dummy = 0;
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
dummy++;
}
}
}
emptyLoop.stop();
System.out.println(dummy);  !!! so that the jitter can't optimize away the whole loop

int[][] matrix = new int[rows][columns];
emptyLoop2.start();
dummy = 3;
int dummy2 = 7;
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop
for (int i=0; i&lt;runs; i++) {
for (int column=0; column &lt; columns; column++) {
for (int row=0; row &lt; rows; row++) {
dummy2 += dummy; matrix[row][column];
}
}
}
emptyLoop2.stop();
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop

long before = Runtime.getRuntime().freeMemory();
long size = (((long)rows)columns)runs;


System.out.println("\nNow filling...");
for (int i=0; i&lt;runs; i++) {
timer1.start();
int value = 0;
for (int row=0; row &lt; rows; row++) {
int[] r = matrix[row];
for (int column=0; column &lt; columns; column++) {
r[column] = value++;
matrix[row][column] = value++;
}
}
timer1.stop();
}
timer1.display();
timer1.minus(emptyLoop).display();
System.out.println(size  timer1.minus(emptyLoop).seconds() +" elements  sec");

Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
long after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)  1024);
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("\nNow reading...");
timer2.start();
int element=0;
for (int i=0; i&lt;runs; i++) {
for (int row=0; row &lt; rows; row++) {
int[] r = matrix[row];
for (int column=0; column &lt; columns; column++) {
element += r[column];
element += matrix[row][column];
}
}
}
timer2.stop().display();
timer2.minus(emptyLoop2).display();
System.out.println(size  timer2.minus(emptyLoop2).seconds() +" elements  sec");
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}
System.out.println(element);  !!! so that the jitter can't optimize away the whole loop

System.out.println("\nNow removing...");
before = Runtime.getRuntime().freeMemory();
for (int i=0; i&lt;runs; i++) {
timer3.start();
for (int row=0; row &lt; rows; row++) {
int[] r = matrix[row];
for (int column=0; column &lt; columns; column++) {
r[column] = 0;
matrix[row][column] = 0;
}
}
timer3.stop();
}
timer3.display();
timer3.minus(emptyLoop).display();
System.out.println(size  timer3.minus(emptyLoop).seconds() +" elements  sec");
Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)1024);
System.out.println("KB free="+(after1024));

if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("bye bye.");</comment>
  </method>
  <javadoc>
    <text>Benchmarks various methods of this class.</text>
  </javadoc>
  <method type="void" name="main">
    <declaration type="int" name="runs" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="String" name="kind" />
    <declaration type="int" name="initialCapacity" />
    <declaration type="double" name="minLoadFactor" />
    <declaration type="double" name="maxLoadFactor" />
    <declaration type="boolean" name="print" />
    <declaration type="String" name="type" />
    <declaration type="String" name="command" />
    <scope />
    <scope />
    <comment>int size = Integer.parseInt(args[3]);</comment>
    <comment>boolean isSparse = args[4].equals("sparse");</comment>
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
