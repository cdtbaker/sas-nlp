<?xml version="1.0" encoding="UTF-8"?>
<class name="Blas">
  <javadoc>
    <text>&lt;p&gt;
 * Subset of the &lt;A HREF="http://netlib2.cs.utk.edu/blas/faq.html"&gt;BLAS&lt;/A&gt; (Basic Linear Algebra System); 
 * High quality "building block" routines for performing basic vector and matrix operations. 
 * Because the BLAS are efficient, portable, and widely available, they're commonly used in the development
 * of high quality linear algebra software.
 * &lt;p&gt;
 * Mostly for compatibility with legacy notations. Most operations actually just delegate to the appropriate 
 * methods directly defined on matrices and vectors. &lt;/p&gt;
 * &lt;p&gt;
 * This class implements the BLAS functions for operations on matrices from the 
 * matrix package. It follows the spirit of the &lt;A HREF="http://math.nist.gov/javanumerics/blas.html"&gt;Draft Proposal for Java BLAS Interface&lt;/A&gt;, 
 * by Roldan Pozo of the National Institute of Standards and Technology. Interface 
 * definitions are also identical to the Ninja interface. Because the matrix package 
 * supports sections, the interface is actually simpler. &lt;/p&gt;
 * &lt;p&gt;Currently, the following operations are supported: &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;BLAS Level 1: Vector-Vector operations &lt;/li&gt;
 * &lt;ul&gt;
 * &lt;li&gt;ddot  : dot product of two vectors &lt;/li&gt;
 * &lt;li&gt;daxpy : scalar times a vector plus a vector &lt;/li&gt;
 * &lt;li&gt;drotg : construct a Givens plane rotation &lt;/li&gt;
 * &lt;li&gt;drot  : apply a plane rotation &lt;/li&gt;
 * &lt;li&gt;dcopy : copy vector X into vector Y &lt;/li&gt;
 * &lt;li&gt;dswap : interchange vectors X and Y &lt;/li&gt;
 * &lt;li&gt;dnrm2 : Euclidean norm of a vector &lt;/li&gt;
 * &lt;li&gt;dasum : sum of absolute values of vector components &lt;/li&gt;
 * &lt;li&gt;dscal : scale a vector by a scalar &lt;/li&gt;
 * &lt;li&gt;idamax: index of element with maximum absolute value &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;li&gt;2.BLAS Level 2: Matrix-Vector operations &lt;/li&gt;
 * &lt;ul&gt;
 * &lt;li&gt;dgemv : matrix-vector multiply with general matrix &lt;/li&gt;
 * &lt;li&gt;dger  : rank-1 update on general matrix &lt;/li&gt;
 * &lt;li&gt;dsymv : matrix-vector multiply with symmetric matrix &lt;/li&gt;
 * &lt;li&gt;dtrmv : matrix-vector multiply with triangular matrix &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;li&gt;3.BLAS Level 3: Matrix-Matrix operations 
 * &lt;ul&gt;
 * &lt;li&gt;dgemm : matrix-matrix multiply with general matrices &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;/ol&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>0.9, 16/04/2000</version>
  </javadoc>
  <method name="assign" type="void" />
  <javadoc>
    <text>Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col])&lt;/tt&gt;.</text>
    <param>A the matrix to modify.</param>
    <param>function a function object taking as argument the current cell's value.</param>
    <see>cern.jet.math.Functions</see>
  </javadoc>
  <method name="assign" type="void" />
  <javadoc>
    <text>Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col],y[row,col])&lt;/tt&gt;.</text>
    <param>x the matrix to modify.</param>
    <param>y the secondary matrix to operate on.</param>
    <param>function a function object taking as first argument the current cell's value of &lt;tt&gt;this&lt;/tt&gt;,
 * and as second argument the current cell's value of &lt;tt&gt;y&lt;/tt&gt;,</param>
    <return>&lt;tt&gt;this&lt;/tt&gt; (for convenience only).</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.columns() != y.columns() || x.rows() != y.rows()&lt;/tt&gt;</throws>
    <see>cern.jet.math.Functions</see>
  </javadoc>
  <method name="dasum" type="double" />
  <javadoc>
    <text>Returns the sum of absolute values; &lt;tt&gt;|x[0]| + |x[1]| + ... &lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;x.aggregate(cern.jet.math.Functions.plus, cern.jet.math.Functions.abs)&lt;/tt&gt;.</text>
    <param>x the first vector.</param>
  </javadoc>
  <method name="daxpy" type="void" />
  <javadoc>
    <text>Combined vector scaling; &lt;tt&gt;y = y + alpha*x&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;y.assign(x,cern.jet.math.Functions.plusMult(alpha))&lt;/tt&gt;.</text>
    <param>alpha a scale factor.</param>
    <param>x the first source vector.</param>
    <param>y the second source vector, this is also the vector where results are stored.</param>
    <throws>IllegalArgumentException &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;..</throws>
  </javadoc>
  <method name="daxpy" type="void" />
  <javadoc>
    <text>Combined matrix scaling; &lt;tt&gt;B = B + alpha*A&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;B.assign(A,cern.jet.math.Functions.plusMult(alpha))&lt;/tt&gt;.</text>
    <param>alpha a scale factor.</param>
    <param>A the first source matrix.</param>
    <param>B the second source matrix, this is also the matrix where results are stored.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;A.columns() != B.columns() || A.rows() != B.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="dcopy" type="void" />
  <javadoc>
    <text>Vector assignment (copying); &lt;tt&gt;y = x&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;y.assign(x)&lt;/tt&gt;.</text>
    <param>x the source vector.</param>
    <param>y the destination vector.</param>
    <throws>IllegalArgumentException &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="dcopy" type="void" />
  <javadoc>
    <text>Matrix assignment (copying); &lt;tt&gt;B = A&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;B.assign(A)&lt;/tt&gt;.</text>
    <param>A the source matrix.</param>
    <param>B the destination matrix.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;A.columns() != B.columns() || A.rows() != B.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="ddot" type="double" />
  <javadoc>
    <text>Returns the dot product of two vectors x and y, which is &lt;tt&gt;Sum(x[i]*y[i])&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;x.zDotProduct(y)&lt;/tt&gt;.</text>
    <param>x the first vector.</param>
    <param>y the second vector.</param>
    <return>the sum of products.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="dgemm" type="void" />
  <javadoc>
    <text>Generalized linear algebraic matrix-matrix multiply; &lt;tt&gt;C = alpha*A*B + beta*C&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;A.zMult(B,C,alpha,beta,transposeA,transposeB)&lt;/tt&gt;.
 * Note: Matrix shape conformance is checked &lt;i&gt;after&lt;/i&gt; potential transpositions.</text>
    <param>transposeA set this flag to indicate that the multiplication shall be performed on A'.</param>
    <param>transposeB set this flag to indicate that the multiplication shall be performed on B'.</param>
    <param>alpha a scale factor.</param>
    <param>A the first source matrix.</param>
    <param>B the second source matrix.</param>
    <param>beta a scale factor.</param>
    <param>C the third source matrix, this is also the matrix where results are stored.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;B.rows() != A.columns()&lt;/tt&gt;.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;C.rows() != A.rows() || C.columns() != B.columns()&lt;/tt&gt;.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;A == C || B == C&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="dgemv" type="void" />
  <javadoc>
    <text>Generalized linear algebraic matrix-vector multiply; &lt;tt&gt;y = alpha*A*x + beta*y&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;A.zMult(x,y,alpha,beta,transposeA)&lt;/tt&gt;.
 * Note: Matrix shape conformance is checked &lt;i&gt;after&lt;/i&gt; potential transpositions.</text>
    <param>transposeA set this flag to indicate that the multiplication shall be performed on A'.</param>
    <param>alpha a scale factor.</param>
    <param>A the source matrix.</param>
    <param>x the first source vector.</param>
    <param>beta a scale factor.</param>
    <param>y the second source vector, this is also the vector where results are stored.</param>
    <throws>IllegalArgumentException &lt;tt&gt;A.columns() != x.size() || A.rows() != y.size())&lt;/tt&gt;..</throws>
  </javadoc>
  <method name="dger" type="void" />
  <javadoc>
    <text>Performs a rank 1 update; &lt;tt&gt;A = A + alpha*x*y'&lt;/tt&gt;.
 * Example:
 * &lt;pre&gt;
 * A = { {6,5}, {7,6} }, x = {1,2}, y = {3,4}, alpha = 1 --&gt;
 * A = { {9,9}, {13,14} }
 * &lt;/pre&gt;</text>
    <param>alpha a scalar.</param>
    <param>x an m element vector.</param>
    <param>y an n element vector.</param>
    <param>A an m by n matrix.</param>
  </javadoc>
  <method name="dnrm2" type="double" />
  <javadoc>
    <text>Return the 2-norm; &lt;tt&gt;sqrt(x[0]^2 + x[1]^2 + ...)&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;Math.sqrt(Algebra.DEFAULT.norm2(x))&lt;/tt&gt;.</text>
    <param>x the vector.</param>
  </javadoc>
  <method name="drot" type="void" />
  <javadoc>
    <text>Applies a givens plane rotation to (x,y); &lt;tt&gt;x = c*x + s*y; y = c*y - s*x&lt;/tt&gt;.</text>
    <param>x the first vector.</param>
    <param>y the second vector.</param>
    <param>c the cosine of the angle of rotation.</param>
    <param>s the sine of the angle of rotation.</param>
  </javadoc>
  <method name="drotg" type="void" />
  <javadoc>
    <text>Constructs a Givens plane rotation for &lt;tt&gt;(a,b)&lt;/tt&gt;.
 * Taken from the LINPACK translation from FORTRAN to Java, interface slightly modified.
 * In the LINPACK listing DROTG is attributed to Jack Dongarra</text>
    <param>a  rotational elimination parameter a.</param>
    <param>b  rotational elimination parameter b.</param>
    <param>rotvec[]  Must be at least of length 4. On output contains the values &lt;tt&gt;{a,b,c,s}&lt;/tt&gt;.</param>
  </javadoc>
  <method name="dscal" type="void" />
  <javadoc>
    <text>Vector scaling; &lt;tt&gt;x = alpha*x&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;x.assign(cern.jet.math.Functions.mult(alpha))&lt;/tt&gt;.</text>
    <param>alpha a scale factor.</param>
    <param>x the first vector.</param>
  </javadoc>
  <method name="dscal" type="void" />
  <javadoc>
    <text>Matrix scaling; &lt;tt&gt;A = alpha*A&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;A.assign(cern.jet.math.Functions.mult(alpha))&lt;/tt&gt;.</text>
    <param>alpha a scale factor.</param>
    <param>A the matrix.</param>
  </javadoc>
  <method name="dswap" type="void" />
  <javadoc>
    <text>Swaps the elements of two vectors; &lt;tt&gt;y &lt;==&gt; x&lt;/tt&gt;.
 * In fact equivalent to &lt;tt&gt;y.swap(x)&lt;/tt&gt;.</text>
    <param>x the first vector.</param>
    <param>y the second vector.</param>
    <throws>IllegalArgumentException &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="dswap" type="void" />
  <javadoc>
    <text>Swaps the elements of two matrices; &lt;tt&gt;B &lt;==&gt; A&lt;/tt&gt;.</text>
    <param>A the first matrix.</param>
    <param>B the second matrix.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;A.columns() != B.columns() || A.rows() != B.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method name="dsymv" type="void" />
  <javadoc>
    <text>Symmetric matrix-vector multiplication; &lt;tt&gt;y = alpha*A*x + beta*y&lt;/tt&gt;.
 * Where alpha and beta are scalars, x and y are n element vectors and
 * A is an n by n symmetric matrix.
 * A can be in upper or lower triangular format.</text>
    <param>isUpperTriangular is A upper triangular or lower triangular part to be used?</param>
    <param>alpha scaling factor.</param>
    <param>A the source matrix.</param>
    <param>x the first source vector.</param>
    <param>beta scaling factor.</param>
    <param>y the second vector holding source and destination.</param>
  </javadoc>
  <method name="dtrmv" type="void" />
  <javadoc>
    <text>Triangular matrix-vector multiplication; &lt;tt&gt;x = A*x&lt;/tt&gt; or &lt;tt&gt;x = A'*x&lt;/tt&gt;.
 * Where x is an n element vector and A is an n by n unit, or non-unit,
 * upper or lower triangular matrix.</text>
    <param>isUpperTriangular is A upper triangular or lower triangular?</param>
    <param>transposeA set this flag to indicate that the multiplication shall be performed on A'.</param>
    <param>isUnitTriangular true --&gt; A is assumed to be unit triangular; false --&gt; A is not assumed to be unit triangular</param>
    <param>A the source matrix.</param>
    <param>x the vector holding source and destination.</param>
  </javadoc>
  <method name="idamax" type="int" />
  <javadoc>
    <text>Returns the index of largest absolute value; &lt;tt&gt;i such that |x[i]| == max(|x[0]|,|x[1]|,...).&lt;/tt&gt;.</text>
    <param>x the vector to search through.</param>
    <return>the index of largest absolute value (-1 if x is empty).</return>
  </javadoc>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
