<?xml version="1.0" encoding="UTF-8"?>
<class name="Property">
  <javadoc>
    <text>Tests matrices for linear algebraic properties (equality, tridiagonality, symmetry, singularity, etc).
 * &lt;p&gt;
 * Except where explicitly indicated, all methods involving equality tests (&lt;tt&gt;==&lt;/tt&gt;) allow for numerical instability, to a degree specified upon instance construction and returned by method {@link #tolerance()}.
 * The public static final variable &lt;tt&gt;DEFAULT&lt;/tt&gt; represents a default Property object with a tolerance of &lt;tt&gt;1.0E-9&lt;/tt&gt;.
 * The public static final variable &lt;tt&gt;ZERO&lt;/tt&gt; represents a Property object with a tolerance of &lt;tt&gt;0.0&lt;/tt&gt;.
 * The public static final variable &lt;tt&gt;TWELVE&lt;/tt&gt; represents a Property object with a tolerance of &lt;tt&gt;1.0E-12&lt;/tt&gt;.
 * As long as you are happy with these tolerances, there is no need to construct Property objects.
 * Simply use idioms like &lt;tt&gt;Property.DEFAULT.equals(A,B)&lt;/tt&gt;, &lt;tt&gt;Property.ZERO.equals(A,B)&lt;/tt&gt;, &lt;tt&gt;Property.TWELVE.equals(A,B)&lt;/tt&gt;.
 * &lt;p&gt;
 * To work with a different tolerance (e.g. &lt;tt&gt;1.0E-15&lt;/tt&gt; or &lt;tt&gt;1.0E-5&lt;/tt&gt;) use the constructor and/or method {@link #setTolerance(double)}.
 * Note that the public static final Property objects are immutable: Is is not possible to alter their tolerance. 
 * Any attempt to do so will throw an Exception.
 * &lt;p&gt;
 * Note that this implementation is not synchronized.
 * &lt;p&gt;
 * Example: &lt;tt&gt;equals(DoubleMatrix2D A, DoubleMatrix2D B)&lt;/tt&gt; is defined as follows
 * &lt;table&gt;
 * &lt;td class="PRE"&gt; 
 * &lt;pre&gt;
 * { some other tests not related to tolerance go here }
 * double epsilon = tolerance();
 * for (int row=rows; --row &gt;= 0;) {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;for (int column=columns; --column &gt;= 0;) {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//if (!(A.getQuick(row,column) == B.getQuick(row,column))) return false;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (Math.abs(A.getQuick(row,column) - B.getQuick(row,column)) &gt; epsilon) return false;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
 * }
 * return true;
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;/table&gt;
 * Here are some example properties
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td valign="middle" align="left"&gt;&lt;tt&gt;matrix&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; &lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&amp;nbsp;&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 1&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt;&lt;tt&gt; &lt;/tt&gt; &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt; &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;upperBandwidth&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;lowerBandwidth&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;semiBandwidth&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;description&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;zero&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;diagonal&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;tridiagonal&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;upper triangular&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;lower triangular&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;unstructured&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;unstructured&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.1, 28/May/2000 (fixed strange bugs involving NaN, -inf, inf)</version>
  </javadoc>
  <javadoc>
    <text>The default Property object; currently has &lt;tt&gt;tolerance()==1.0E-9&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="Property" name="DEFAULT" />
  <javadoc>
    <text>A Property object with &lt;tt&gt;tolerance()==0.0&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="Property" name="ZERO" />
  <javadoc>
    <text>A Property object with &lt;tt&gt;tolerance()==1.0E-12&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="Property" name="TWELVE" />
  <declaration type="double" name="tolerance" />
  <javadoc>
    <text>Not instantiable by no-arg constructor.</text>
  </javadoc>
  <method type="constructor" name="Property">
    <comment>just to be on the safe side</comment>
  </method>
  <javadoc>
    <text>Constructs an instance with a tolerance of &lt;tt&gt;Math.abs(newTolerance)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="constructor" name="Property" />
  <javadoc>
    <text>Returns a String with &lt;tt&gt;length&lt;/tt&gt; blanks.</text>
  </javadoc>
  <method type="String" name="blanks">
    <declaration type="StringBuffer" name="buf" />
    <scope />
  </method>
  <javadoc>
    <text>Checks whether the given matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;rectangular&lt;/i&gt;.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;A.rows() &lt; A.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="checkRectangular">
    <scope />
  </method>
  <javadoc>
    <text>Checks whether the given matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;square&lt;/i&gt;.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;A.rows() != A.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="checkSquare" />
  <javadoc>
    <text>Returns the matrix's fraction of non-zero cells; &lt;tt&gt;A.cardinality() / A.size()&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="density" />
  <javadoc>
    <text>Returns whether all cells of the given matrix &lt;tt&gt;A&lt;/tt&gt; are equal to the given value.
 * The result is &lt;tt&gt;true&lt;/tt&gt; if and only if &lt;tt&gt;A != null&lt;/tt&gt; and
 * &lt;tt&gt;! (Math.abs(value - A[i]) &gt; tolerance())&lt;/tt&gt; holds for all coordinates.</text>
    <param>A   the first matrix to compare.</param>
    <param>value   the value to compare against.</param>
    <return>&lt;tt&gt;true&lt;/tt&gt; if the matrix is equal to the value;
 * &lt;tt&gt;false&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="double" name="epsilon" />
    <scope>
      <declaration type="double" name="x" />
      <declaration type="double" name="diff" />
    </scope>
    <comment>if (!(A.getQuick(i) == value)) return false;</comment>
    <comment>if (Math.abs(value - A.getQuick(i)) &gt; epsilon) return false;</comment>
  </method>
  <javadoc>
    <text>Returns whether both given matrices &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; are equal.
 * The result is &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;A==B&lt;/tt&gt;. 
 * Otherwise, the result is &lt;tt&gt;true&lt;/tt&gt; if and only if both arguments are &lt;tt&gt;!= null&lt;/tt&gt;, 
 * have the same size and 
 * &lt;tt&gt;! (Math.abs(A[i] - B[i]) &gt; tolerance())&lt;/tt&gt; holds for all indexes.</text>
    <param>A   the first matrix to compare.</param>
    <param>B   the second matrix to compare.</param>
    <return>&lt;tt&gt;true&lt;/tt&gt; if both matrices are equal;
 * &lt;tt&gt;false&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="int" name="size" />
    <declaration type="double" name="epsilon" />
    <scope>
      <declaration type="double" name="x" />
      <declaration type="double" name="value" />
      <declaration type="double" name="diff" />
    </scope>
    <comment>if (!(getQuick(i) == B.getQuick(i))) return false;</comment>
    <comment>if (Math.abs(A.getQuick(i) - B.getQuick(i)) &gt; epsilon) return false;</comment>
  </method>
  <javadoc>
    <text>Returns whether all cells of the given matrix &lt;tt&gt;A&lt;/tt&gt; are equal to the given value.
 * The result is &lt;tt&gt;true&lt;/tt&gt; if and only if &lt;tt&gt;A != null&lt;/tt&gt; and
 * &lt;tt&gt;! (Math.abs(value - A[row,col]) &gt; tolerance())&lt;/tt&gt; holds for all coordinates.</text>
    <param>A   the first matrix to compare.</param>
    <param>value   the value to compare against.</param>
    <return>&lt;tt&gt;true&lt;/tt&gt; if the matrix is equal to the value;
 * &lt;tt&gt;false&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="double" name="epsilon" />
    <scope>
      <scope>
        <declaration type="double" name="x" />
        <declaration type="double" name="diff" />
      </scope>
    </scope>
    <comment>if (!(A.getQuick(row,column) == value)) return false;</comment>
    <comment>if (Math.abs(value - A.getQuick(row,column)) &gt; epsilon) return false;</comment>
  </method>
  <javadoc>
    <text>Returns whether both given matrices &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; are equal.
 * The result is &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;A==B&lt;/tt&gt;. 
 * Otherwise, the result is &lt;tt&gt;true&lt;/tt&gt; if and only if both arguments are &lt;tt&gt;!= null&lt;/tt&gt;, 
 * have the same number of columns and rows and 
 * &lt;tt&gt;! (Math.abs(A[row,col] - B[row,col]) &gt; tolerance())&lt;/tt&gt; holds for all coordinates.</text>
    <param>A   the first matrix to compare.</param>
    <param>B   the second matrix to compare.</param>
    <return>&lt;tt&gt;true&lt;/tt&gt; if both matrices are equal;
 * &lt;tt&gt;false&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="double" name="epsilon" />
    <scope>
      <scope>
        <declaration type="double" name="x" />
        <declaration type="double" name="value" />
        <declaration type="double" name="diff" />
      </scope>
    </scope>
    <comment>if (!(A.getQuick(row,column) == B.getQuick(row,column))) return false;</comment>
    <comment>if (Math.abs((A.getQuick(row,column) - B.getQuick(row,column)) &gt; epsilon) return false;</comment>
  </method>
  <javadoc>
    <text>Returns whether all cells of the given matrix &lt;tt&gt;A&lt;/tt&gt; are equal to the given value.
 * The result is &lt;tt&gt;true&lt;/tt&gt; if and only if &lt;tt&gt;A != null&lt;/tt&gt; and
 * &lt;tt&gt;! (Math.abs(value - A[slice,row,col]) &gt; tolerance())&lt;/tt&gt; holds for all coordinates.</text>
    <param>A   the first matrix to compare.</param>
    <param>value   the value to compare against.</param>
    <return>&lt;tt&gt;true&lt;/tt&gt; if the matrix is equal to the value;
 * &lt;tt&gt;false&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="double" name="epsilon" />
    <scope>
      <scope>
        <scope>
          <declaration type="double" name="x" />
          <declaration type="double" name="diff" />
        </scope>
      </scope>
    </scope>
    <comment>if (!(A.getQuick(slice,row,column) == value)) return false;</comment>
    <comment>if (Math.abs(value - A.getQuick(slice,row,column)) &gt; epsilon) return false;</comment>
  </method>
  <javadoc>
    <text>Returns whether both given matrices &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; are equal.
 * The result is &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;A==B&lt;/tt&gt;. 
 * Otherwise, the result is &lt;tt&gt;true&lt;/tt&gt; if and only if both arguments are &lt;tt&gt;!= null&lt;/tt&gt;, 
 * have the same number of columns, rows and slices, and
 * &lt;tt&gt;! (Math.abs(A[slice,row,col] - B[slice,row,col]) &gt; tolerance())&lt;/tt&gt; holds for all coordinates.</text>
    <param>A   the first matrix to compare.</param>
    <param>B   the second matrix to compare.</param>
    <return>&lt;tt&gt;true&lt;/tt&gt; if both matrices are equal;
 * &lt;tt&gt;false&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="int" name="slices" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="double" name="epsilon" />
    <scope>
      <scope>
        <scope>
          <declaration type="double" name="x" />
          <declaration type="double" name="value" />
          <declaration type="double" name="diff" />
        </scope>
      </scope>
    </scope>
    <comment>if (!(A.getQuick(slice,row,column) == B.getQuick(slice,row,column))) return false;</comment>
    <comment>if (Math.abs(A.getQuick(slice,row,column) - B.getQuick(slice,row,column)) &gt; epsilon) return false;</comment>
  </method>
  <javadoc>
    <text>Modifies the given matrix square matrix &lt;tt&gt;A&lt;/tt&gt; such that it is diagonally dominant by row and column, hence non-singular, hence invertible.
 * For testing purposes only.</text>
    <param>A the square matrix to modify.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="generateNonSingular">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="int" name="min" />
    <scope />
    <scope>
      <declaration type="double" name="rowSum" />
      <declaration type="double" name="colSum" />
    </scope>
  </method>
  <javadoc />
  <method type="String" name="get" />
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;diagonal&lt;/i&gt; if &lt;tt&gt;A[i,j] == 0&lt;/tt&gt; whenever &lt;tt&gt;i != j&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isDiagonal">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
    <comment>if (row!=column &amp;&amp; A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;diagonally dominant by column&lt;/i&gt; if the absolute value of each diagonal element is larger than the sum of the absolute values of the off-diagonal elements in the corresponding column.
 * &lt;tt&gt;returns true if for all i: abs(A[i,i]) &amp;gt; Sum(abs(A[j,i])); j != i.&lt;/tt&gt;
 * Matrix may but need not be square.
 * &lt;p&gt;
 * Note: Ignores tolerance.</text>
  </javadoc>
  <method type="boolean" name="isDiagonallyDominantByColumn">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="min" />
    <scope>
      <declaration type="double" name="diag" />
    </scope>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;diagonally dominant by row&lt;/i&gt; if the absolute value of each diagonal element is larger than the sum of the absolute values of the off-diagonal elements in the corresponding row.
 * &lt;tt&gt;returns true if for all i: abs(A[i,i]) &amp;gt; Sum(abs(A[i,j])); j != i.&lt;/tt&gt; 
 * Matrix may but need not be square.
 * &lt;p&gt;
 * Note: Ignores tolerance.</text>
  </javadoc>
  <method type="boolean" name="isDiagonallyDominantByRow">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="min" />
    <scope>
      <declaration type="double" name="diag" />
    </scope>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is an &lt;i&gt;identity&lt;/i&gt; matrix if &lt;tt&gt;A[i,i] == 1&lt;/tt&gt; and all other cells are zero.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isIdentity">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope>
        <declaration type="double" name="v" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;lower bidiagonal&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; unless &lt;tt&gt;i==j || i==j+1&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isLowerBidiagonal">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;lower triangular&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; whenever &lt;tt&gt;i &amp;lt; j&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isLowerTriangular">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;non-negative&lt;/i&gt; if &lt;tt&gt;A[i,j] &amp;gt;= 0&lt;/tt&gt; holds for all cells.
 * &lt;p&gt;
 * Note: Ignores tolerance.</text>
  </javadoc>
  <method type="boolean" name="isNonNegative">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>A square matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;orthogonal&lt;/i&gt; if &lt;tt&gt;A*transpose(A) = I&lt;/tt&gt;.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="boolean" name="isOrthogonal" />
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;positive&lt;/i&gt; if &lt;tt&gt;A[i,j] &amp;gt; 0&lt;/tt&gt; holds for all cells.
 * &lt;p&gt;
 * Note: Ignores tolerance.</text>
  </javadoc>
  <method type="boolean" name="isPositive">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;singular&lt;/i&gt; if it has no inverse, that is, iff &lt;tt&gt;det(A)==0&lt;/tt&gt;.</text>
  </javadoc>
  <method type="boolean" name="isSingular" />
  <javadoc>
    <text>A square matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;skew-symmetric&lt;/i&gt; if &lt;tt&gt;A = -transpose(A)&lt;/tt&gt;, that is &lt;tt&gt;A[i,j] == -A[j,i]&lt;/tt&gt;.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="boolean" name="isSkewSymmetric">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
    <comment>if (A.getQuick(row,column) != -A.getQuick(column,row)) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;square&lt;/i&gt; if it has the same number of rows and columns.</text>
  </javadoc>
  <method type="boolean" name="isSquare" />
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;strictly lower triangular&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; whenever &lt;tt&gt;i &amp;lt;= j&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isStrictlyLowerTriangular">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;strictly triangular&lt;/i&gt; if it is triangular and its diagonal elements all equal 0.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isStrictlyTriangular">
    <declaration type="double" name="epsilon" />
    <scope />
    <comment>if (A.getQuick(i,i) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;strictly upper triangular&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; whenever &lt;tt&gt;i &amp;gt;= j&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isStrictlyUpperTriangular">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;symmetric&lt;/i&gt; if &lt;tt&gt;A = tranpose(A)&lt;/tt&gt;, that is &lt;tt&gt;A[i,j] == A[j,i]&lt;/tt&gt;.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="boolean" name="isSymmetric" />
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;triangular&lt;/i&gt; iff it is either upper or lower triangular.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isTriangular" />
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;tridiagonal&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; whenever &lt;tt&gt;Math.abs(i-j) &gt; 1&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isTridiagonal">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;unit triangular&lt;/i&gt; if it is triangular and its diagonal elements all equal 1.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isUnitTriangular">
    <declaration type="double" name="epsilon" />
    <scope />
    <comment>if (A.getQuick(i,i) != 1) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;upper bidiagonal&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; unless &lt;tt&gt;i==j || i==j-1&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isUpperBidiagonal">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;upper triangular&lt;/i&gt; if &lt;tt&gt;A[i,j]==0&lt;/tt&gt; whenever &lt;tt&gt;i &amp;gt; j&lt;/tt&gt;.
 * Matrix may but need not be square.</text>
  </javadoc>
  <method type="boolean" name="isUpperTriangular">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
    <comment>if (A.getQuick(row,column) != 0) return false;</comment>
  </method>
  <javadoc>
    <text>A matrix &lt;tt&gt;A&lt;/tt&gt; is &lt;i&gt;zero&lt;/i&gt; if all its cells are zero.</text>
  </javadoc>
  <method type="boolean" name="isZero" />
  <javadoc>
    <text>The &lt;i&gt;lower bandwidth&lt;/i&gt; of a square matrix &lt;tt&gt;A&lt;/tt&gt; is the maximum &lt;tt&gt;i-j&lt;/tt&gt; for which &lt;tt&gt;A[i,j]&lt;/tt&gt; is nonzero and &lt;tt&gt;i &amp;gt; j&lt;/tt&gt;.
 * A &lt;i&gt;banded&lt;/i&gt; matrix has a "band" about the diagonal.
 * Diagonal, tridiagonal and triangular matrices are special cases.</text>
    <param>A the square matrix to analyze.</param>
    <return>the lower bandwith.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
    <see>#semiBandwidth(DoubleMatrix2D)</see>
    <see>#upperBandwidth(DoubleMatrix2D)</see>
  </javadoc>
  <method type="int" name="lowerBandwidth">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <scope>
      <scope>
        <declaration type="int" name="j" />
      </scope>
    </scope>
    <comment>if (A.getQuick(j,i) != 0) return k;</comment>
  </method>
  <javadoc>
    <text>Returns the &lt;i&gt;semi-bandwidth&lt;/i&gt; of the given square matrix &lt;tt&gt;A&lt;/tt&gt;.
 * A &lt;i&gt;banded&lt;/i&gt; matrix has a "band" about the diagonal.
 * It is a matrix with all cells equal to zero, 
 * with the possible exception of the cells along the diagonal line,
 * the &lt;tt&gt;k&lt;/tt&gt; diagonal lines above the diagonal, and the &lt;tt&gt;k&lt;/tt&gt; diagonal lines below the diagonal.
 * The &lt;i&gt;semi-bandwith l&lt;/i&gt; is the number &lt;tt&gt;k+1&lt;/tt&gt;.
 * The &lt;i&gt;bandwidth p&lt;/i&gt; is the number &lt;tt&gt;2*k + 1&lt;/tt&gt;.
 * For example, a tridiagonal matrix corresponds to &lt;tt&gt;k=1, l=2, p=3&lt;/tt&gt;, 
 * a diagonal or zero matrix corresponds to &lt;tt&gt;k=0, l=1, p=1&lt;/tt&gt;, 
 * &lt;p&gt;
 * The &lt;i&gt;upper bandwidth&lt;/i&gt; is the maximum &lt;tt&gt;j-i&lt;/tt&gt; for which &lt;tt&gt;A[i,j]&lt;/tt&gt; is nonzero and &lt;tt&gt;j &amp;gt; i&lt;/tt&gt;.
 * The &lt;i&gt;lower bandwidth&lt;/i&gt; is the maximum &lt;tt&gt;i-j&lt;/tt&gt; for which &lt;tt&gt;A[i,j]&lt;/tt&gt; is nonzero and &lt;tt&gt;i &amp;gt; j&lt;/tt&gt;. 
 * Diagonal, tridiagonal and triangular matrices are special cases.
 * &lt;p&gt;
 * Examples:
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr align="left" valign="top"&gt; 
 * &lt;td valign="middle" align="left"&gt;&lt;tt&gt;matrix&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; &lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&amp;nbsp;&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt; 4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 1&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt;&lt;tt&gt; &lt;/tt&gt; &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&amp;nbsp;x&amp;nbsp;4&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;1&amp;nbsp;0&lt;br&gt;
 * 0&amp;nbsp;1&amp;nbsp;0&amp;nbsp;0&lt;br&gt;
 * 1&amp;nbsp;1&amp;nbsp;0&amp;nbsp;1&lt;br&gt;
 * 0&amp;nbsp;0&amp;nbsp;1&amp;nbsp;1 &lt;/tt&gt; &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;upperBandwidth&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;lowerBandwidth&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;semiBandwidth&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align="center" valign="middle"&gt; 
 * &lt;td&gt;&lt;tt&gt;description&lt;/tt&gt;&lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;zero&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;diagonal&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;tridiagonal&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td&gt;&lt;tt&gt;upper triangular&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt;&lt;tt&gt;lower triangular&lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;unstructured&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;td align="center" valign="middle"&gt; 
 * &lt;div align="center"&gt;&lt;tt&gt;unstructured&lt;/tt&gt;&lt;/div&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>A the square matrix to analyze.</param>
    <return>the semi-bandwith &lt;tt&gt;l&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
    <see>#lowerBandwidth(DoubleMatrix2D)</see>
    <see>#upperBandwidth(DoubleMatrix2D)</see>
  </javadoc>
  <method type="int" name="semiBandwidth">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <scope>
      <scope>
        <declaration type="int" name="j" />
      </scope>
    </scope>
    <comment>if (A.getQuick(j,i) != 0) return k+1;</comment>
    <comment>if (A.getQuick(i,j) != 0) return k+1;</comment>
  </method>
  <javadoc>
    <text>Sets the tolerance to &lt;tt&gt;Math.abs(newTolerance)&lt;/tt&gt;.</text>
    <throws>UnsupportedOperationException if &lt;tt&gt;this==DEFAULT || this==ZERO || this==TWELVE&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="setTolerance">
    <scope />
    <comment>throw new UnsupportedOperationException("Attempted to modify object.");  since JDK1.2</comment>
  </method>
  <javadoc>
    <text>Returns the current tolerance.</text>
  </javadoc>
  <method type="double" name="tolerance" />
  <javadoc>
    <text>Returns summary information about the given matrix &lt;tt&gt;A&lt;/tt&gt;.
 * That is a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture of a matrix.
 * For example,
 * &lt;pre&gt;
 * density                      : 0.9
 * isDiagonal                   : false
 * isDiagonallyDominantByRow    : false
 * isDiagonallyDominantByColumn : false
 * isIdentity                   : false
 * isLowerBidiagonal            : false
 * isLowerTriangular            : false
 * isNonNegative                : true
 * isOrthogonal                 : Illegal operation or error: Matrix must be square.
 * isPositive                   : true
 * isSingular                   : Illegal operation or error: Matrix must be square.
 * isSkewSymmetric              : Illegal operation or error: Matrix must be square.
 * isSquare                     : false
 * isStrictlyLowerTriangular    : false
 * isStrictlyTriangular         : false
 * isStrictlyUpperTriangular    : false
 * isSymmetric                  : Illegal operation or error: Matrix must be square.
 * isTriangular                 : false
 * isTridiagonal                : false
 * isUnitTriangular             : false
 * isUpperBidiagonal            : false
 * isUpperTriangular            : false
 * isZero                       : false
 * lowerBandwidth               : Illegal operation or error: Matrix must be square.
 * semiBandwidth                : Illegal operation or error: Matrix must be square.
 * upperBandwidth               : Illegal operation or error: Matrix must be square.
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="cern.colt.list.ObjectArrayList" name="names" />
    <declaration type="cern.colt.list.ObjectArrayList" name="values" />
    <declaration type="String" name="unknown" />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <declaration type="cern.colt.function.IntComparator" name="comp" />
    <method type="int" name="compare" />
    <declaration type="cern.colt.Swapper" name="swapper" />
    <method type="void" name="swap">
      <declaration type="Object" name="tmp" />
    </method>
    <declaration type="int" name="maxLength" />
    <scope>
      <declaration type="int" name="length" />
    </scope>
    <declaration type="StringBuffer" name="buf" />
    <scope>
      <declaration type="String" name="name" />
    </scope>
    <comment>determine properties</comment>
    <comment>determine properties</comment>
    <comment>determine properties</comment>
    <comment>determine properties</comment>
    <comment>sort ascending by property name</comment>
    <comment>determine padding for nice formatting</comment>
    <comment>finally, format properties</comment>
  </method>
  <javadoc>
    <text>The &lt;i&gt;upper bandwidth&lt;/i&gt; of a square matrix &lt;tt&gt;A&lt;/tt&gt; is the 
 * maximum &lt;tt&gt;j-i&lt;/tt&gt; for which &lt;tt&gt;A[i,j]&lt;/tt&gt; is nonzero and &lt;tt&gt;j &amp;gt; i&lt;/tt&gt;.
 * A &lt;i&gt;banded&lt;/i&gt; matrix has a "band" about the diagonal. 
 * Diagonal, tridiagonal and triangular matrices are special cases.</text>
    <param>A the square matrix to analyze.</param>
    <return>the upper bandwith.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;!isSquare(A)&lt;/tt&gt;.</throws>
    <see>#semiBandwidth(DoubleMatrix2D)</see>
    <see>#lowerBandwidth(DoubleMatrix2D)</see>
  </javadoc>
  <method type="int" name="upperBandwidth">
    <declaration type="double" name="epsilon" />
    <declaration type="int" name="rows" />
    <scope>
      <scope>
        <declaration type="int" name="j" />
      </scope>
    </scope>
    <comment>if (A.getQuick(i,j) != 0) return k;</comment>
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
