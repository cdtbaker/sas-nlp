<?xml version="1.0" encoding="UTF-8"?>
<class name="SingularValueDecomposition">
  <javadoc>
    <text>For an &lt;tt&gt;m x n&lt;/tt&gt; matrix &lt;tt&gt;A&lt;/tt&gt; with &lt;tt&gt;m &gt;= n&lt;/tt&gt;, the singular value decomposition is
 * an &lt;tt&gt;m x n&lt;/tt&gt; orthogonal matrix &lt;tt&gt;U&lt;/tt&gt;, an &lt;tt&gt;n x n&lt;/tt&gt; diagonal matrix &lt;tt&gt;S&lt;/tt&gt;, and
 * an &lt;tt&gt;n x n&lt;/tt&gt; orthogonal matrix &lt;tt&gt;V&lt;/tt&gt; so that &lt;tt&gt;A = U*S*V'&lt;/tt&gt;.
 * &lt;P&gt;
 * The singular values, &lt;tt&gt;sigma[k] = S[k][k]&lt;/tt&gt;, are ordered so that
 * &lt;tt&gt;sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]&lt;/tt&gt;.
 * &lt;P&gt;
 * The singular value decomposition always exists, so the constructor will
 * never fail.  The matrix condition number and the effective numerical
 * rank can be computed from this decomposition.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Arrays for internal storage of U and V.</text>
    <serial>internal storage of U.</serial>
    <serial>internal storage of V.</serial>
  </javadoc>
  <declaration type="double[][]" name="U" />
  <javadoc>
    <text>Array for internal storage of singular values.</text>
    <serial>internal storage of singular values.</serial>
  </javadoc>
  <declaration type="double[]" name="s" />
  <javadoc>
    <text>Row and column dimensions.</text>
    <serial>row dimension.</serial>
    <serial>column dimension.</serial>
  </javadoc>
  <declaration type="int" name="m" />
  <javadoc>
    <text>Constructs and returns a new singular value decomposition object; 
 * The decomposed matrices can be retrieved via instance methods of the returned decomposition object.</text>
    <param>A    A rectangular matrix.</param>
    <return>A decomposition object to access &lt;tt&gt;U&lt;/tt&gt;, &lt;tt&gt;S&lt;/tt&gt; and &lt;tt&gt;V&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;A.rows() &lt; A.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="constructor" name="SingularValueDecomposition">
    <declaration type="double[][]" name="A" />
    <declaration type="int" name="nu" />
    <declaration type="double[]" name="e" />
    <declaration type="double[]" name="work" />
    <declaration type="boolean" name="wantu" />
    <declaration type="boolean" name="wantv" />
    <declaration type="int" name="nct" />
    <declaration type="int" name="nrt" />
    <scope>
      <scope>
        <scope />
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="t" />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
          <scope>
            <scope />
          </scope>
          <scope>
            <declaration type="double" name="t" />
            <scope />
          </scope>
        </scope>
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <declaration type="int" name="p" />
    <scope />
    <scope />
    <scope />
    <scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope>
          <scope>
            <declaration type="double" name="t" />
            <scope />
            <scope />
          </scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <scope>
      <scope>
        <scope>
          <scope>
            <declaration type="double" name="t" />
            <scope />
            <scope />
          </scope>
        </scope>
        <scope />
      </scope>
    </scope>
    <declaration type="int" name="pp" />
    <declaration type="int" name="iter" />
    <declaration type="double" name="eps" />
    <scope>
      <declaration type="int" name="k" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
      <scope>
        <declaration type="int" name="ks" />
        <scope>
          <scope />
          <declaration type="double" name="t" />
          <scope />
        </scope>
        <scope />
        <scope />
        <scope />
      </scope>
      <scope>
        <declaration type="double" name="f" />
        <scope>
          <declaration type="double" name="t" />
          <declaration type="double" name="cs" />
          <declaration type="double" name="sn" />
          <scope />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
      <scope>
        <declaration type="double" name="f" />
        <scope>
          <declaration type="double" name="t" />
          <declaration type="double" name="cs" />
          <declaration type="double" name="sn" />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
      <scope>
        <declaration type="double" name="scale" />
        <declaration type="double" name="sp" />
        <declaration type="double" name="spm1" />
        <declaration type="double" name="epm1" />
        <declaration type="double" name="sk" />
        <declaration type="double" name="ek" />
        <declaration type="double" name="b" />
        <declaration type="double" name="c" />
        <declaration type="double" name="shift" />
        <scope>
          <scope />
        </scope>
        <declaration type="double" name="f" />
        <declaration type="double" name="g" />
        <scope>
          <declaration type="double" name="t" />
          <declaration type="double" name="cs" />
          <declaration type="double" name="sn" />
          <scope />
          <scope>
            <scope />
          </scope>
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
      <scope>
        <scope>
          <scope>
            <scope />
          </scope>
        </scope>
        <scope>
          <scope />
          <declaration type="double" name="t" />
          <scope>
            <scope />
          </scope>
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>Derived from LINPACK code.</comment>
    <comment>Initialize.</comment>
    <comment>Reduce A to bidiagonal form, storing the diagonal elements</comment>
    <comment>in s and the super-diagonal elements in e.</comment>
    <comment>Compute the transformation for the k-th column and</comment>
    <comment>place the k-th diagonal in s[k].</comment>
    <comment>Compute 2-norm of k-th column without under/overflow.</comment>
    <comment>Apply the transformation.</comment>
    <comment>Place the k-th row of A into e for the</comment>
    <comment>subsequent calculation of the row transformation.</comment>
    <comment>Place the transformation in U for subsequent back</comment>
    <comment>multiplication.</comment>
    <comment>Compute the k-th row transformation and place the</comment>
    <comment>k-th super-diagonal in e[k].</comment>
    <comment>Compute 2-norm without under/overflow.</comment>
    <comment>Apply the transformation.</comment>
    <comment>Place the transformation in V for subsequent</comment>
    <comment>back multiplication.</comment>
    <comment>Set up the final bidiagonal matrix or order p.</comment>
    <comment>If required, generate U.</comment>
    <comment>If required, generate V.</comment>
    <comment>Main iteration loop for the singular values.</comment>
    <comment>Here is where a test for too many iterations would go.</comment>
    <comment>This section of the program inspects for</comment>
    <comment>negligible elements in the s and e arrays.  On</comment>
    <comment>completion the variables kase and k are set as follows.</comment>
    <comment>kase = 1     if s(p) and e[k-1] are negligible and k&lt;p</comment>
    <comment>kase = 2     if s(k) is negligible and k&lt;p</comment>
    <comment>kase = 3     if e[k-1] is negligible, k&lt;p, and</comment>
    <comment>s(k), ..., s(p) are not negligible (qr step).</comment>
    <comment>kase = 4     if e(p-1) is negligible (convergence).</comment>
    <comment>Perform the task indicated by kase.</comment>
    <comment>Deflate negligible s(p).</comment>
    <comment>Split at negligible s(k).</comment>
    <comment>Perform one qr step.</comment>
    <comment>Calculate the shift.</comment>
    <comment>Chase zeros.</comment>
    <comment>Convergence.</comment>
    <comment>Make the singular values positive.</comment>
    <comment>Order the singular values.</comment>
  </method>
  <javadoc>
    <text>Returns the two norm condition number, which is &lt;tt&gt;max(S) / min(S)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="cond" />
  <javadoc>
    <text>Returns the diagonal matrix of singular values.</text>
    <return>S</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getS">
    <declaration type="double[][]" name="S" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the diagonal of &lt;tt&gt;S&lt;/tt&gt;, which is a one-dimensional array of singular values</text>
    <return>diagonal of &lt;tt&gt;S&lt;/tt&gt;.</return>
  </javadoc>
  <method type="double[]" name="getSingularValues" />
  <javadoc>
    <text>Returns the left singular vectors &lt;tt&gt;U&lt;/tt&gt;.</text>
    <return>&lt;tt&gt;U&lt;/tt&gt;</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getU">
    <comment>return new DoubleMatrix2D(U,m,Math.min(m+1,n));</comment>
  </method>
  <javadoc>
    <text>Returns the right singular vectors &lt;tt&gt;V&lt;/tt&gt;.</text>
    <return>&lt;tt&gt;V&lt;/tt&gt;</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getV" />
  <javadoc>
    <text>Returns the two norm, which is &lt;tt&gt;max(S)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="norm2" />
  <javadoc>
    <text>Returns the effective numerical matrix rank, which is the number of nonnegligible singular values.</text>
  </javadoc>
  <method type="int" name="rank">
    <declaration type="double" name="eps" />
    <declaration type="double" name="tol" />
    <declaration type="int" name="r" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * &lt;pre&gt;
 * rank          : 3
 * trace         : 0
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="StringBuffer" name="buf" />
    <declaration type="String" name="unknown" />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
