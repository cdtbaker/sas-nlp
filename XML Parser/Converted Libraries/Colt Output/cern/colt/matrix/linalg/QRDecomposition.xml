<?xml version="1.0" encoding="UTF-8"?>
<class name="QRDecomposition">
  <javadoc>
    <text>For an &lt;tt&gt;m x n&lt;/tt&gt; matrix &lt;tt&gt;A&lt;/tt&gt; with &lt;tt&gt;m &gt;= n&lt;/tt&gt;, the QR decomposition is an &lt;tt&gt;m x n&lt;/tt&gt;
 * orthogonal matrix &lt;tt&gt;Q&lt;/tt&gt; and an &lt;tt&gt;n x n&lt;/tt&gt; upper triangular matrix &lt;tt&gt;R&lt;/tt&gt; so that
 * &lt;tt&gt;A = Q*R&lt;/tt&gt;.
 * &lt;P&gt;
 * The QR decompostion always exists, even if the matrix does not have
 * full rank, so the constructor will never fail.  The primary use of the
 * QR decomposition is in the least squares solution of nonsquare systems
 * of simultaneous linear equations.  This will fail if &lt;tt&gt;isFullRank()&lt;/tt&gt;
 * returns &lt;tt&gt;false&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Array for internal storage of decomposition.</text>
    <serial>internal array storage.</serial>
  </javadoc>
  <declaration type="DoubleMatrix2D" name="QR" />
  <javadoc>
    <text>Row and column dimensions.</text>
    <serial>column dimension.</serial>
    <serial>row dimension.</serial>
  </javadoc>
  <declaration type="int" name="m" />
  <javadoc>
    <text>Array for internal storage of diagonal of R.</text>
    <serial>diagonal of R.</serial>
  </javadoc>
  <declaration type="DoubleMatrix1D" name="Rdiag" />
  <javadoc>
    <text>Constructs and returns a new QR decomposition object;  computed by Householder reflections;
 * The decomposed matrices can be retrieved via instance methods of the returned decomposition object.</text>
    <param>A    A rectangular matrix.</param>
    <return>a decomposition object to access &lt;tt&gt;R&lt;/tt&gt; and the Householder vectors &lt;tt&gt;H&lt;/tt&gt;, and to compute &lt;tt&gt;Q&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;A.rows() &lt; A.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="constructor" name="QRDecomposition">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="cern.colt.function.DoubleDoubleFunction" name="hypot" />
    <declaration type="DoubleMatrix1D[]" name="QRcolumns" />
    <declaration type="DoubleMatrix1D[]" name="QRcolumnsPart" />
    <scope />
    <scope>
      <declaration type="double" name="nrm" />
      <scope />
      <scope>
        <scope>
          <declaration type="DoubleMatrix1D" name="QRcolj" />
          <declaration type="double" name="s" />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>Initialize.</comment>
    <comment>Rdiag = new double[n];</comment>
    <comment>precompute and cache some views to avoid regenerating them time and again</comment>
    <comment>Main loop.</comment>
    <comment>DoubleMatrix1D QRcolk = QR.viewColumn(k).viewPart(k,m-k);</comment>
    <comment>Compute 2-norm of k-th column without under/overflow.</comment>
    <comment>if (k&lt;m) nrm = QRcolumnsPart[k].aggregate(hypot,F.identity);</comment>
    <comment>fixes bug reported by hong.44@osu.edu</comment>
    <comment>Form k-th Householder vector.</comment>
    <comment>for (int i = k; i &lt; m; i++) {
QR[i][k] = nrm;
}</comment>
    <comment>Apply transformation to remaining columns.</comment>
    <comment>fixes bug reported by John Chambers
DoubleMatrix1D QRcolj = QR.viewColumn(j).viewPart(k,m-k);
double s = QRcolumnsPart[k].zDotProduct(QRcolumns[j]);
double s = 0.0;
for (int i = k; i &lt; m; i++) {
s += QR[i][k]QR[i][j];
}</comment>
    <comment>QRcolumnsPart[j].assign(QRcolumns[k], F.plusMult(s));</comment>
  </method>
  <javadoc>
    <text>Returns the Householder vectors &lt;tt&gt;H&lt;/tt&gt;.</text>
    <return>A lower trapezoidal matrix whose columns define the householder reflections.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getH" />
  <javadoc>
    <text>Generates and returns the (economy-sized) orthogonal factor &lt;tt&gt;Q&lt;/tt&gt;.</text>
    <return>&lt;tt&gt;Q&lt;/tt&gt;</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getQ">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="DoubleMatrix2D" name="Q" />
    <scope>
      <declaration type="DoubleMatrix1D" name="QRcolk" />
      <scope>
        <scope>
          <declaration type="DoubleMatrix1D" name="Qcolj" />
          <declaration type="double" name="s" />
        </scope>
      </scope>
    </scope>
    <comment>double[][] Q = X.getArray();</comment>
  </method>
  <javadoc>
    <text>Returns the upper triangular factor, &lt;tt&gt;R&lt;/tt&gt;.</text>
    <return>&lt;tt&gt;R&lt;/tt&gt;</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getR">
    <declaration type="DoubleMatrix2D" name="R" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns whether the matrix &lt;tt&gt;A&lt;/tt&gt; has full rank.</text>
    <return>true if &lt;tt&gt;R&lt;/tt&gt;, and hence &lt;tt&gt;A&lt;/tt&gt;, has full rank.</return>
  </javadoc>
  <method type="boolean" name="hasFullRank">
    <scope />
  </method>
  <javadoc>
    <text>Least squares solution of &lt;tt&gt;A*X = B&lt;/tt&gt;; &lt;tt&gt;returns X&lt;/tt&gt;.</text>
    <param>B    A matrix with as many rows as &lt;tt&gt;A&lt;/tt&gt; and any number of columns.</param>
    <return>&lt;tt&gt;X&lt;/tt&gt; that minimizes the two norm of &lt;tt&gt;Q*R*X - B&lt;/tt&gt;.</return>
    <exception>IllegalArgumentException  if &lt;tt&gt;B.rows() != A.rows()&lt;/tt&gt;.</exception>
    <exception>IllegalArgumentException  if &lt;tt&gt;!this.hasFullRank()&lt;/tt&gt; (&lt;tt&gt;A&lt;/tt&gt; is rank deficient).</exception>
  </javadoc>
  <method type="DoubleMatrix2D" name="solve">
    <declaration type="cern.jet.math.Functions" name="F" />
    <scope />
    <scope />
    <declaration type="int" name="nx" />
    <declaration type="DoubleMatrix2D" name="X" />
    <scope>
      <scope>
        <declaration type="double" name="s" />
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Copy right hand side</comment>
    <comment>Compute Y = transpose(Q)*B</comment>
    <comment>Solve R*X = Y;</comment>
  </method>
  <javadoc>
    <text>Returns a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * &lt;pre&gt;
 * rank          : 3
 * trace         : 0
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="StringBuffer" name="buf" />
    <declaration type="String" name="unknown" />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>private double[][] QR;</comment>
</class>
