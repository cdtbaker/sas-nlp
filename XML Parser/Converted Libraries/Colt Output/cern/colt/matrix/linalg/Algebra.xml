<?xml version="1.0" encoding="UTF-8"?>
<class name="Algebra">
  <javadoc>
    <text>Linear algebraic matrix operations operating on {@link DoubleMatrix2D}; concentrates most functionality of this package.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>A default Algebra object; has {@link Property#DEFAULT} attached for tolerance. 
 * Allows ommiting to construct an Algebra object time and again.
 * Note that this Algebra object is immutable.
 * Any attempt to assign a new Property object to it (via method &lt;tt&gt;setProperty&lt;/tt&gt;), or to alter the tolerance of its property object (via &lt;tt&gt;property().setTolerance(...)&lt;/tt&gt;) will throw an exception.</text>
  </javadoc>
  <declaration type="Algebra" name="DEFAULT" />
  <javadoc>
    <text>A default Algebra object; has {@link Property#ZERO} attached for tolerance. 
 * Allows ommiting to construct an Algebra object time and again.
 * Note that this Algebra object is immutable.
 * Any attempt to assign a new Property object to it (via method &lt;tt&gt;setProperty&lt;/tt&gt;), or to alter the tolerance of its property object (via &lt;tt&gt;property().setTolerance(...)&lt;/tt&gt;) will throw an exception.</text>
  </javadoc>
  <declaration type="Algebra" name="ZERO" />
  <javadoc>
    <text>The property object attached to this instance.</text>
  </javadoc>
  <declaration type="Property" name="property" />
  <scope />
  <javadoc>
    <text>Constructs a new instance with an equality tolerance given by &lt;tt&gt;Property.DEFAULT.tolerance()&lt;/tt&gt;.</text>
  </javadoc>
  <method type="constructor" name="Algebra" />
  <javadoc>
    <text>Constructs a new instance with the given equality tolerance.</text>
    <param>tolerance the tolerance to be used for equality operations.</param>
  </javadoc>
  <method type="constructor" name="Algebra" />
  <javadoc>
    <text>Constructs and returns the cholesky-decomposition of the given matrix.</text>
  </javadoc>
  <method type="CholeskyDecomposition" name="chol" />
  <javadoc>
    <text>Returns a copy of the receiver.
 * The attached property object is also copied. Hence, the property object of the copy is mutable.</text>
    <return>a copy of the receiver.</return>
  </javadoc>
  <method type="Object" name="clone" />
  <javadoc>
    <text>Returns the condition of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the ratio of largest to smallest singular value.</text>
  </javadoc>
  <method type="double" name="cond" />
  <javadoc>
    <text>Returns the determinant of matrix &lt;tt&gt;A&lt;/tt&gt;.</text>
    <return>the determinant.</return>
  </javadoc>
  <method type="double" name="det" />
  <javadoc>
    <text>Constructs and returns the Eigenvalue-decomposition of the given matrix.</text>
  </javadoc>
  <method type="EigenvalueDecomposition" name="eig" />
  <javadoc>
    <text>Returns sqrt(a^2 + b^2) without under/overflow.</text>
  </javadoc>
  <method type="double" name="hypot">
    <declaration type="double" name="r" />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns sqrt(a^2 + b^2) without under/overflow.</text>
  </javadoc>
  <method type="cern.colt.function.DoubleDoubleFunction" name="hypotFunction">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Returns the inverse or pseudo-inverse of matrix &lt;tt&gt;A&lt;/tt&gt;.</text>
    <return>a new independent matrix; inverse(matrix) if the matrix is square, pseudoinverse otherwise.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="inverse">
    <scope>
      <declaration type="DoubleMatrix2D" name="inv" />
      <declaration type="boolean" name="isNonSingular" />
    </scope>
  </method>
  <javadoc>
    <text>Constructs and returns the LU-decomposition of the given matrix.</text>
  </javadoc>
  <method type="LUDecomposition" name="lu" />
  <javadoc>
    <text>Inner product of two vectors; &lt;tt&gt;Sum(x[i] * y[i])&lt;/tt&gt;.
 * Also known as dot product.
 * &lt;br&gt;
 * Equivalent to &lt;tt&gt;x.zDotProduct(y)&lt;/tt&gt;.</text>
    <param>x the first source vector.</param>
    <param>y the second source matrix.</param>
    <return>the inner product.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="double" name="mult" />
  <javadoc>
    <text>Linear algebraic matrix-vector multiplication; &lt;tt&gt;z = A * y&lt;/tt&gt;.
 * &lt;tt&gt;z[i] = Sum(A[i,j] * y[j]), i=0..A.rows()-1, j=0..y.size()-1&lt;/tt&gt;.</text>
    <param>A the source matrix.</param>
    <param>y the source vector.</param>
    <return>&lt;tt&gt;z&lt;/tt&gt;; a new vector with &lt;tt&gt;z.size()==A.rows()&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;A.columns() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix1D" name="mult" />
  <javadoc>
    <text>Linear algebraic matrix-matrix multiplication; &lt;tt&gt;C = A x B&lt;/tt&gt;.
 * &lt;tt&gt;C[i,j] = Sum(A[i,k] * B[k,j]), k=0..n-1&lt;/tt&gt;.
 * &lt;br&gt;
 * Matrix shapes: &lt;tt&gt;A(m x n), B(n x p), C(m x p)&lt;/tt&gt;.</text>
    <param>A the first source matrix.</param>
    <param>B the second source matrix.</param>
    <return>&lt;tt&gt;C&lt;/tt&gt;; a new matrix holding the results, with &lt;tt&gt;C.rows()=A.rows(), C.columns()==B.columns()&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;B.rows() != A.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="mult" />
  <javadoc>
    <text>Outer product of two vectors; Sets &lt;tt&gt;A[i,j] = x[i] * y[j]&lt;/tt&gt;.</text>
    <param>x the first source vector.</param>
    <param>y the second source vector.</param>
    <param>A the matrix to hold the results. Set this parameter to &lt;tt&gt;null&lt;/tt&gt; to indicate that a new result matrix shall be constructed.</param>
    <return>A (for convenience only).</return>
    <throws>IllegalArgumentException	if &lt;tt&gt;A.rows() != x.size() || A.columns() != y.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="multOuter">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
  </method>
  <javadoc>
    <text>Returns the one-norm of vector &lt;tt&gt;x&lt;/tt&gt;, which is &lt;tt&gt;Sum(abs(x[i]))&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="norm1" />
  <javadoc>
    <text>Returns the one-norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum absolute column sum.</text>
  </javadoc>
  <method type="double" name="norm1">
    <declaration type="double" name="max" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the two-norm (aka &lt;i&gt;euclidean norm&lt;/i&gt;) of vector &lt;tt&gt;x&lt;/tt&gt;; equivalent to &lt;tt&gt;mult(x,x)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="norm2" />
  <javadoc>
    <text>Returns the two-norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum singular value; obtained from SVD.</text>
  </javadoc>
  <method type="double" name="norm2" />
  <javadoc>
    <text>Returns the Frobenius norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is &lt;tt&gt;Sqrt(Sum(A[i,j]&lt;sup&gt;2&lt;/sup&gt;))&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="normF" />
  <javadoc>
    <text>Returns the infinity norm of vector &lt;tt&gt;x&lt;/tt&gt;, which is &lt;tt&gt;Max(abs(x[i]))&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="normInfinity">
    <comment>fix for bug reported by T.J.Hunt@open.ac.uk</comment>
    <comment>if (x.size()==0) return 0;</comment>
    <comment>return x.aggregate(cern.jet.math.Functions.plus,cern.jet.math.Functions.abs);</comment>
    <comment>double max = 0;</comment>
    <comment>for (int i = x.size(); --i &gt;= 0; ) {</comment>
    <comment>max = Math.max(max, x.getQuick(i));</comment>
    <comment>}</comment>
    <comment>return max;</comment>
  </method>
  <javadoc>
    <text>Returns the infinity norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum absolute row sum.</text>
  </javadoc>
  <method type="double" name="normInfinity">
    <declaration type="double" name="max" />
    <scope />
    <comment>max = Math.max(max, normInfinity(A.viewRow(row)));</comment>
  </method>
  <javadoc>
    <text>Modifies the given vector &lt;tt&gt;A&lt;/tt&gt; such that it is permuted as specified; Useful for pivoting.
 * Cell &lt;tt&gt;A[i]&lt;/tt&gt; will go into cell &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt;
 * &lt;pre&gt;
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
 * [A,E,C,D,B]
 * In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[2], A[3]&lt;--A[3], A[4]&lt;--A[1].
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
 * [A,E,B,C,D]
 * In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[1], A[3]&lt;--A[2], A[4]&lt;--A[3].
 * &lt;/pre&gt;</text>
    <param>A   the vector to permute.</param>
    <param>indexes the permutation indexes, must satisfy &lt;tt&gt;indexes.length==A.size() &amp;&amp; indexes[i] &gt;= 0 &amp;&amp; indexes[i] &lt; A.size()&lt;/tt&gt;;</param>
    <param>work the working storage, must satisfy &lt;tt&gt;work.length &gt;= A.size()&lt;/tt&gt;; set &lt;tt&gt;work==null&lt;/tt&gt; if you don't care about performance.</param>
    <return>the modified &lt;tt&gt;A&lt;/tt&gt; (for convenience only).</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;indexes.length != A.size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix1D" name="permute">
    <declaration type="int" name="size" />
    <scope />
    <scope />
    <comment>check validity</comment>
    <comment>int i=size;
int a;
while (--i &gt;= 0 &amp;&amp; (a=indexes[i])==i) if (a &lt; 0 || a &gt;= size) throw new IndexOutOfBoundsException("invalid permutation");
if (i&lt;0) return;  nothing to permute</comment>
  </method>
  <javadoc>
    <text>Constructs and returns a new row and column permuted &lt;i&gt;selection view&lt;/i&gt; of matrix &lt;tt&gt;A&lt;/tt&gt;; equivalent to {@link DoubleMatrix2D#viewSelection(int[],int[])}.
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
 * Use idioms like &lt;tt&gt;result = permute(...).copy()&lt;/tt&gt; to generate an independent sub matrix.</text>
    <return>the new permuted selection view.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="permute" />
  <javadoc>
    <text>Modifies the given matrix &lt;tt&gt;A&lt;/tt&gt; such that it's columns are permuted as specified; Useful for pivoting.
 * Column &lt;tt&gt;A[i]&lt;/tt&gt; will go into column &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
 * Equivalent to &lt;tt&gt;permuteRows(transpose(A), indexes, work)&lt;/tt&gt;.</text>
    <param>A   the matrix to permute.</param>
    <param>indexes the permutation indexes, must satisfy &lt;tt&gt;indexes.length==A.columns() &amp;&amp; indexes[i] &gt;= 0 &amp;&amp; indexes[i] &lt; A.columns()&lt;/tt&gt;;</param>
    <param>work the working storage, must satisfy &lt;tt&gt;work.length &gt;= A.columns()&lt;/tt&gt;; set &lt;tt&gt;work==null&lt;/tt&gt; if you don't care about performance.</param>
    <return>the modified &lt;tt&gt;A&lt;/tt&gt; (for convenience only).</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;indexes.length != A.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="permuteColumns" />
  <javadoc>
    <text>Modifies the given matrix &lt;tt&gt;A&lt;/tt&gt; such that it's rows are permuted as specified; Useful for pivoting.
 * Row &lt;tt&gt;A[i]&lt;/tt&gt; will go into row &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt;
 * &lt;pre&gt;
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
 * [A,E,C,D,B]
 * In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[2], A[3]&lt;--A[3], A[4]&lt;--A[1].
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
 * [A,E,B,C,D]
 * In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[1], A[3]&lt;--A[2], A[4]&lt;--A[3].
 * &lt;/pre&gt;</text>
    <param>A   the matrix to permute.</param>
    <param>indexes the permutation indexes, must satisfy &lt;tt&gt;indexes.length==A.rows() &amp;&amp; indexes[i] &gt;= 0 &amp;&amp; indexes[i] &lt; A.rows()&lt;/tt&gt;;</param>
    <param>work the working storage, must satisfy &lt;tt&gt;work.length &gt;= A.rows()&lt;/tt&gt;; set &lt;tt&gt;work==null&lt;/tt&gt; if you don't care about performance.</param>
    <return>the modified &lt;tt&gt;A&lt;/tt&gt; (for convenience only).</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;indexes.length != A.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="permuteRows">
    <declaration type="int" name="size" />
    <declaration type="int" name="columns" />
    <scope>
      <declaration type="double[]" name="doubleWork" />
    </scope>
    <declaration type="cern.colt.Swapper" name="swapper" />
    <method type="void" name="swap" />
    <comment>check validity</comment>
    <comment>int i=size;
int a;
while (--i &gt;= 0 &amp;&amp; (a=indexes[i])==i) if (a &lt; 0 || a &gt;= size) throw new IndexOutOfBoundsException("invalid permutation");
if (i&lt;0) return;  nothing to permute</comment>
    <comment>quicker</comment>
  </method>
  <javadoc>
    <text>Linear algebraic matrix power; &lt;tt&gt;B = A&lt;sup&gt;k&lt;/sup&gt; &lt;==&gt; B = A*A*...*A&lt;/tt&gt;.
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;p &amp;gt;= 1: B = A*A*...*A&lt;/tt&gt;.&lt;/li&gt;
 * &lt;li&gt;&lt;tt&gt;p == 0: B = identity matrix&lt;/tt&gt;.&lt;/li&gt;
 * &lt;li&gt;&lt;tt&gt;p &amp;lt;  0: B = pow(inverse(A),-p)&lt;/tt&gt;.&lt;/li&gt;
 * &lt;/ul&gt;
 * Implementation: Based on logarithms of 2, memory usage minimized.</text>
    <param>A the source matrix; must be square; stays unaffected by this operation.</param>
    <param>p the exponent, can be any number.</param>
    <return>&lt;tt&gt;B&lt;/tt&gt;, a newly constructed result matrix; storage-independent of &lt;tt&gt;A&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;!property().isSquare(A)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="pow">
    <declaration type="Blas" name="blas" />
    <scope />
    <declaration type="DoubleMatrix2D" name="T" />
    <scope />
    <declaration type="int" name="k" />
    <declaration type="int" name="i" />
    <scope>
      <declaration type="DoubleMatrix2D" name="swap" />
    </scope>
    <declaration type="DoubleMatrix2D" name="B" />
    <scope>
      <declaration type="DoubleMatrix2D" name="swap" />
      <scope />
    </scope>
    <comment>matrix multiplication based on log2 method: A*A*....*A is slow, ((A * A)^2)^2 * ... is faster</comment>
    <comment>allocates two auxiliary matrices as work space</comment>
    <comment>for parallel matrix mult; if not initialized defaults to sequential blas</comment>
    <comment>temporary</comment>
    <comment>safes one auxiliary matrix allocation</comment>
    <comment>mult(A,A);  safes one auxiliary matrix allocation</comment>
    <comment>index of highest bit in state "true"</comment>
    <comment>this is the naive version:
DoubleMatrix2D B = A.copy();
for (int i=0; i&lt;p-1; i++) {
B = mult(B,A);
}
return B;</comment>
    <comment>here comes the optimized version:</comment>
    <comment>cern.colt.Timer timer = new cern.colt.Timer().start();</comment>
    <comment>while (bit i of p == false)</comment>
    <comment>A = mult(A,A); would allocate a lot of temporary memory</comment>
    <comment>A.zMult(A,T);</comment>
    <comment>swap A with T</comment>
    <comment>A = mult(A,A); would allocate a lot of temporary memory</comment>
    <comment>A.zMult(A,T);</comment>
    <comment>swap A with T</comment>
    <comment>if (bit i of p == true)</comment>
    <comment>B = mult(B,A); would allocate a lot of temporary memory</comment>
    <comment>B.zMult(A,T);</comment>
    <comment>swap B with T</comment>
    <comment>timer.stop().display();</comment>
  </method>
  <javadoc>
    <text>Returns the property object attached to this Algebra, defining tolerance.</text>
    <return>the Property object.</return>
    <see>#setProperty(Property)</see>
  </javadoc>
  <method type="Property" name="property" />
  <javadoc>
    <text>Constructs and returns the QR-decomposition of the given matrix.</text>
  </javadoc>
  <method type="QRDecomposition" name="qr" />
  <javadoc>
    <text>Returns the effective numerical rank of matrix &lt;tt&gt;A&lt;/tt&gt;, obtained from Singular Value Decomposition.</text>
  </javadoc>
  <method type="int" name="rank" />
  <javadoc>
    <text>Attaches the given property object to this Algebra, defining tolerance.</text>
    <param>the Property object to be attached.</param>
    <throws>UnsupportedOperationException if &lt;tt&gt;this==DEFAULT &amp;&amp; property!=this.property()&lt;/tt&gt; - The DEFAULT Algebra object is immutable.</throws>
    <throws>UnsupportedOperationException if &lt;tt&gt;this==ZERO &amp;&amp; property!=this.property()&lt;/tt&gt; - The ZERO Algebra object is immutable.</throws>
    <see>#property</see>
  </javadoc>
  <method type="void" name="setProperty" />
  <javadoc>
    <text>Solves A*X = B.</text>
    <return>X; a new independent matrix; solution if A is square, least squares solution otherwise.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="solve" />
  <javadoc>
    <text>Solves X*A = B, which is also A'*X' = B'.</text>
    <return>X; a new independent matrix; solution if A is square, least squares solution otherwise.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="solveTranspose" />
  <javadoc>
    <text>Copies the columns of the indicated rows into a new sub matrix.
 * &lt;tt&gt;sub[0..rowIndexes.length-1,0..columnTo-columnFrom] = A[rowIndexes(:),columnFrom..columnTo]&lt;/tt&gt;;
 * The returned matrix is &lt;i&gt;not backed&lt;/i&gt; by this matrix, so changes in the returned matrix are &lt;i&gt;not reflected&lt;/i&gt; in this matrix, and vice-versa.</text>
    <param>A   the source matrix to copy from.</param>
    <param>rowIndexes the indexes of the rows to copy. May be unsorted.</param>
    <param>columnFrom the index of the first column to copy (inclusive).</param>
    <param>columnTo the index of the last column to copy (inclusive).</param>
    <return>a new sub matrix; with &lt;tt&gt;sub.rows()==rowIndexes.length; sub.columns()==columnTo-columnFrom+1&lt;/tt&gt;.</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;columnFrom&lt;0 || columnTo-columnFrom+1&lt;0 || columnTo+1&gt;matrix.columns() || for any row=rowIndexes[i]: row &lt; 0 || row &gt;= matrix.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="subMatrix">
    <declaration type="int" name="width" />
    <declaration type="int" name="rows" />
    <declaration type="DoubleMatrix2D" name="sub" />
    <scope>
      <declaration type="int" name="row" />
    </scope>
  </method>
  <javadoc>
    <text>Copies the rows of the indicated columns into a new sub matrix.
 * &lt;tt&gt;sub[0..rowTo-rowFrom,0..columnIndexes.length-1] = A[rowFrom..rowTo,columnIndexes(:)]&lt;/tt&gt;;
 * The returned matrix is &lt;i&gt;not backed&lt;/i&gt; by this matrix, so changes in the returned matrix are &lt;i&gt;not reflected&lt;/i&gt; in this matrix, and vice-versa.</text>
    <param>A   the source matrix to copy from.</param>
    <param>rowFrom the index of the first row to copy (inclusive).</param>
    <param>rowTo the index of the last row to copy (inclusive).</param>
    <param>columnIndexes the indexes of the columns to copy. May be unsorted.</param>
    <return>a new sub matrix; with &lt;tt&gt;sub.rows()==rowTo-rowFrom+1; sub.columns()==columnIndexes.length&lt;/tt&gt;.</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;rowFrom&lt;0 || rowTo-rowFrom+1&lt;0 || rowTo+1&gt;matrix.rows() || for any col=columnIndexes[i]: col &lt; 0 || col &gt;= matrix.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="subMatrix">
    <declaration type="int" name="height" />
    <declaration type="int" name="columns" />
    <declaration type="DoubleMatrix2D" name="sub" />
    <scope>
      <declaration type="int" name="column" />
    </scope>
  </method>
  <javadoc>
    <text>Constructs and returns a new &lt;i&gt;sub-range view&lt;/i&gt; which is the sub matrix &lt;tt&gt;A[fromRow..toRow,fromColumn..toColumn]&lt;/tt&gt;.
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
 * Use idioms like &lt;tt&gt;result = subMatrix(...).copy()&lt;/tt&gt; to generate an independent sub matrix.</text>
    <param>A the source matrix.</param>
    <param>fromRow   The index of the first row (inclusive).</param>
    <param>toRow   The index of the last row (inclusive).</param>
    <param>fromColumn   The index of the first column (inclusive).</param>
    <param>toColumn   The index of the last column (inclusive).</param>
    <return>a new sub-range view.</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;fromColumn&lt;0 || toColumn-fromColumn+1&lt;0 || toColumn&gt;=A.columns() || fromRow&lt;0 || toRow-fromRow+1&lt;0 || toRow&gt;=A.rows()&lt;/tt&gt;</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="subMatrix" />
  <javadoc>
    <text>Constructs and returns the SingularValue-decomposition of the given matrix.</text>
  </javadoc>
  <method type="SingularValueDecomposition" name="svd" />
  <javadoc>
    <text>Returns a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * &lt;pre&gt;
 * cond          : 14.073264490042144
 * det           : Illegal operation or error: Matrix must be square.
 * norm1         : 0.9620244354009628
 * norm2         : 3.0
 * normF         : 1.304841791648992
 * normInfinity  : 1.5406551198102534
 * rank          : 3
 * trace         : 0
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="cern.colt.list.ObjectArrayList" name="names" />
    <declaration type="cern.colt.list.ObjectArrayList" name="values" />
    <declaration type="String" name="unknown" />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <declaration type="cern.colt.function.IntComparator" name="comp" />
    <method type="int" name="compare" />
    <declaration type="cern.colt.Swapper" name="swapper" />
    <method type="void" name="swap">
      <declaration type="Object" name="tmp" />
    </method>
    <declaration type="int" name="maxLength" />
    <scope>
      <declaration type="int" name="length" />
    </scope>
    <declaration type="StringBuffer" name="buf" />
    <scope>
      <declaration type="String" name="name" />
    </scope>
    <comment>determine properties</comment>
    <comment>sort ascending by property name</comment>
    <comment>determine padding for nice formatting</comment>
    <comment>finally, format properties</comment>
  </method>
  <javadoc>
    <text>Returns the results of &lt;tt&gt;toString(A)&lt;/tt&gt; and additionally the results of all sorts of decompositions applied to the given matrix.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * &lt;pre&gt;
 * A = 3 x 3 matrix
 * 249  66  68
 * 104 214 108
 * 144 146 293
 * cond         : 3.931600417472078
 * det          : 9638870.0
 * norm1        : 497.0
 * norm2        : 473.34508217011404
 * normF        : 516.873292016525
 * normInfinity : 583.0
 * rank         : 3
 * trace        : 756.0
 * density                      : 1.0
 * isDiagonal                   : false
 * isDiagonallyDominantByColumn : true
 * isDiagonallyDominantByRow    : true
 * isIdentity                   : false
 * isLowerBidiagonal            : false
 * isLowerTriangular            : false
 * isNonNegative                : true
 * isOrthogonal                 : false
 * isPositive                   : true
 * isSingular                   : false
 * isSkewSymmetric              : false
 * isSquare                     : true
 * isStrictlyLowerTriangular    : false
 * isStrictlyTriangular         : false
 * isStrictlyUpperTriangular    : false
 * isSymmetric                  : false
 * isTriangular                 : false
 * isTridiagonal                : false
 * isUnitTriangular             : false
 * isUpperBidiagonal            : false
 * isUpperTriangular            : false
 * isZero                       : false
 * lowerBandwidth               : 2
 * semiBandwidth                : 3
 * upperBandwidth               : 2
 * -----------------------------------------------------------------------------
 * LUDecompositionQuick(A) --&gt; isNonSingular(A), det(A), pivot, L, U, inverse(A)
 * -----------------------------------------------------------------------------
 * isNonSingular = true
 * det = 9638870.0
 * pivot = [0, 1, 2]
 * L = 3 x 3 matrix
 * 1        0       0
 * 0.417671 1       0
 * 0.578313 0.57839 1
 * U = 3 x 3 matrix
 * 249  66         68       
 * 0 186.433735  79.598394
 * 0   0        207.635819
 * inverse(A) = 3 x 3 matrix
 * 0.004869 -0.000976 -0.00077 
 * -0.001548  0.006553 -0.002056
 * -0.001622 -0.002786  0.004816
 * -----------------------------------------------------------------
 * QRDecomposition(A) --&gt; hasFullRank(A), H, Q, R, pseudo inverse(A)
 * -----------------------------------------------------------------
 * hasFullRank = true
 * H = 3 x 3 matrix
 * 1.814086 0        0
 * 0.34002  1.903675 0
 * 0.470797 0.428218 2
 * Q = 3 x 3 matrix
 * -0.814086  0.508871  0.279845
 * -0.34002  -0.808296  0.48067 
 * -0.470797 -0.296154 -0.831049
 * R = 3 x 3 matrix
 * -305.864349 -195.230337 -230.023539
 * 0        -182.628353  467.703164
 * 0           0        -309.13388 
 * pseudo inverse(A) = 3 x 3 matrix
 * 0.006601  0.001998 -0.005912
 * -0.005105  0.000444  0.008506
 * -0.000905 -0.001555  0.002688
 * --------------------------------------------------------------------------
 * CholeskyDecomposition(A) --&gt; isSymmetricPositiveDefinite(A), L, inverse(A)
 * --------------------------------------------------------------------------
 * isSymmetricPositiveDefinite = false
 * L = 3 x 3 matrix
 * 15.779734  0         0       
 * 6.590732 13.059948  0       
 * 9.125629  6.573948 12.903724
 * inverse(A) = Illegal operation or error: Matrix is not symmetric positive definite.
 * ---------------------------------------------------------------------
 * EigenvalueDecomposition(A) --&gt; D, V, realEigenvalues, imagEigenvalues
 * ---------------------------------------------------------------------
 * realEigenvalues = 1 x 3 matrix
 * 462.796507 172.382058 120.821435
 * imagEigenvalues = 1 x 3 matrix
 * 0 0 0
 * D = 3 x 3 matrix
 * 462.796507   0          0       
 * 0        172.382058   0       
 * 0          0        120.821435
 * V = 3 x 3 matrix
 * -0.398877 -0.778282  0.094294
 * -0.500327  0.217793 -0.806319
 * -0.768485  0.66553   0.604862
 * ---------------------------------------------------------------------
 * SingularValueDecomposition(A) --&gt; cond(A), rank(A), norm2(A), U, S, V
 * ---------------------------------------------------------------------
 * cond = 3.931600417472078
 * rank = 3
 * norm2 = 473.34508217011404
 * U = 3 x 3 matrix
 * 0.46657  -0.877519  0.110777
 * 0.50486   0.161382 -0.847982
 * 0.726243  0.45157   0.51832 
 * S = 3 x 3 matrix
 * 473.345082   0          0       
 * 0        169.137441   0       
 * 0          0        120.395013
 * V = 3 x 3 matrix
 * 0.577296 -0.808174  0.116546
 * 0.517308  0.251562 -0.817991
 * 0.631761  0.532513  0.563301
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="String" name="toVerboseString">
    <declaration type="String" name="constructionException" />
    <declaration type="StringBuffer" name="buf" />
    <declaration type="LUDecomposition" name="lu" />
    <scope />
    <scope />
    <declaration type="QRDecomposition" name="qr" />
    <scope />
    <scope />
    <declaration type="CholeskyDecomposition" name="chol" />
    <scope />
    <scope />
    <declaration type="EigenvalueDecomposition" name="eig" />
    <scope />
    <scope />
    <declaration type="SingularValueDecomposition" name="svd" />
    <scope />
    <scope />
    <comment>StringBuffer buf = new StringBuffer();
String unknown = "Illegal operation or error: ";
String constructionException = "Illegal operation or error upon construction: ";

buf.append("------------------------------------------------------------------\n");
buf.append("LUDecomposition(A) --&gt; isNonSingular, det, pivot, L, U, inverse(A)\n");
buf.append("------------------------------------------------------------------\n");</comment>
  </method>
  <javadoc>
    <text>Returns the sum of the diagonal elements of matrix &lt;tt&gt;A&lt;/tt&gt;; &lt;tt&gt;Sum(A[i,i])&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="trace">
    <declaration type="double" name="sum" />
    <scope />
  </method>
  <javadoc>
    <text>Constructs and returns a new view which is the transposition of the given matrix &lt;tt&gt;A&lt;/tt&gt;.
 * Equivalent to {@link DoubleMatrix2D#viewDice A.viewDice()}.
 * This is a zero-copy transposition, taking O(1), i.e. constant time.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
 * Use idioms like &lt;tt&gt;result = transpose(A).copy()&lt;/tt&gt; to generate an independent matrix.
 * &lt;p&gt; 
 * &lt;b&gt;Example:&lt;/b&gt; 
 * &lt;table border="0"&gt;
 * &lt;tr nowrap&gt; 
 * &lt;td valign="top"&gt;2 x 3 matrix: &lt;br&gt;
 * 1, 2, 3&lt;br&gt;
 * 4, 5, 6 &lt;/td&gt;
 * &lt;td&gt;transpose ==&gt;&lt;/td&gt;
 * &lt;td valign="top"&gt;3 x 2 matrix:&lt;br&gt;
 * 1, 4 &lt;br&gt;
 * 2, 5 &lt;br&gt;
 * 3, 6&lt;/td&gt;
 * &lt;td&gt;transpose ==&gt;&lt;/td&gt;
 * &lt;td valign="top"&gt;2 x 3 matrix: &lt;br&gt;
 * 1, 2, 3&lt;br&gt;
 * 4, 5, 6 &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <return>a new transposed view.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="transpose" />
  <javadoc>
    <text>Modifies the matrix to be a lower trapezoidal matrix.</text>
    <return>&lt;tt&gt;A&lt;/tt&gt; (for convenience only).</return>
    <see>#triangulateLower(DoubleMatrix2D)</see>
  </javadoc>
  <method type="DoubleMatrix2D" name="trapezoidalLower">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Outer product of two vectors; Returns a matrix with &lt;tt&gt;A[i,j] = x[i] * y[j]&lt;/tt&gt;.</text>
    <param>x the first source vector.</param>
    <param>y the second source vector.</param>
    <return>the outer product &lt;/tt&gt;A&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="xmultOuter">
    <declaration type="DoubleMatrix2D" name="A" />
  </method>
  <javadoc>
    <text>Linear algebraic matrix power; &lt;tt&gt;B = A&lt;sup&gt;k&lt;/sup&gt; &lt;==&gt; B = A*A*...*A&lt;/tt&gt;.</text>
    <param>A the source matrix; must be square.</param>
    <param>k the exponent, can be any number.</param>
    <return>a new result matrix.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;!Testing.isSquare(A)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="DoubleMatrix2D" name="xpowSlow">
    <declaration type="DoubleMatrix2D" name="result" />
    <scope />
    <comment>cern.colt.Timer timer = new cern.colt.Timer().start();</comment>
    <comment>timer.stop().display();</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>don't use new Algebra(Property.DEFAULT.tolerance()), because then property object would be mutable.</comment>
  <comment>immutable property object</comment>
  <comment>immutable property object</comment>
</class>
