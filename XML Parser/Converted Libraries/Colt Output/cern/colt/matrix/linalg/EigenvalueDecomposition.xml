<?xml version="1.0" encoding="UTF-8"?>
<class name="EigenvalueDecomposition">
  <javadoc>
    <text>Eigenvalues and eigenvectors of a real matrix &lt;tt&gt;A&lt;/tt&gt;. 
 * &lt;P&gt;
 * If &lt;tt&gt;A&lt;/tt&gt; is symmetric, then &lt;tt&gt;A = V*D*V'&lt;/tt&gt; where the eigenvalue matrix &lt;tt&gt;D&lt;/tt&gt; is
 * diagonal and the eigenvector matrix &lt;tt&gt;V&lt;/tt&gt; is orthogonal.
 * I.e. &lt;tt&gt;A = V.mult(D.mult(transpose(V)))&lt;/tt&gt; and 
 * &lt;tt&gt;V.mult(transpose(V))&lt;/tt&gt; equals the identity matrix.
 * &lt;P&gt;
 * If &lt;tt&gt;A&lt;/tt&gt; is not symmetric, then the eigenvalue matrix &lt;tt&gt;D&lt;/tt&gt; is block diagonal
 * with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
 * &lt;tt&gt;lambda + i*mu&lt;/tt&gt;, in 2-by-2 blocks, &lt;tt&gt;[lambda, mu; -mu, lambda]&lt;/tt&gt;. 
 * The columns of &lt;tt&gt;V&lt;/tt&gt; represent the eigenvectors in the sense that &lt;tt&gt;A*V = V*D&lt;/tt&gt;,
 * i.e. &lt;tt&gt;A.mult(V) equals V.mult(D)&lt;/tt&gt;.  The matrix &lt;tt&gt;V&lt;/tt&gt; may be badly
 * conditioned, or even singular, so the validity of the equation
 * &lt;tt&gt;A = V*D*inverse(V)&lt;/tt&gt; depends upon &lt;tt&gt;Algebra.cond(V)&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Row and column dimension (square matrix).</text>
    <serial>matrix dimension.</serial>
  </javadoc>
  <declaration type="int" name="n" />
  <javadoc>
    <text>Symmetry flag.</text>
    <serial>internal symmetry flag.</serial>
  </javadoc>
  <declaration type="boolean" name="issymmetric" />
  <javadoc>
    <text>Arrays for internal storage of eigenvalues.</text>
    <serial>internal storage of eigenvalues.</serial>
  </javadoc>
  <declaration type="double[]" name="d" />
  <javadoc>
    <text>Array for internal storage of eigenvectors.</text>
    <serial>internal storage of eigenvectors.</serial>
  </javadoc>
  <declaration type="double[][]" name="V" />
  <javadoc>
    <text>Array for internal storage of nonsymmetric Hessenberg form.</text>
    <serial>internal storage of nonsymmetric Hessenberg form.</serial>
  </javadoc>
  <declaration type="double[][]" name="H" />
  <javadoc>
    <text>Working storage for nonsymmetric algorithm.</text>
    <serial>working storage for nonsymmetric algorithm.</serial>
  </javadoc>
  <declaration type="double[]" name="ort" />
  <declaration type="double" name="cdivr" />
  <javadoc>
    <text>Constructs and returns a new eigenvalue decomposition object; 
 * The decomposed matrices can be retrieved via instance methods of the returned decomposition object.
 * Checks for symmetry, then constructs the eigenvalue decomposition.</text>
    <param>A    A square matrix.</param>
    <return>A decomposition object to access &lt;tt&gt;D&lt;/tt&gt; and &lt;tt&gt;V&lt;/tt&gt;.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;A&lt;/tt&gt; is not square.</throws>
  </javadoc>
  <method type="constructor" name="EigenvalueDecomposition">
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Tridiagonalize.</comment>
    <comment>Diagonalize.</comment>
    <comment>Reduce to Hessenberg form.</comment>
    <comment>Reduce Hessenberg to real Schur form.</comment>
  </method>
  <method type="void" name="cdiv">
    <declaration type="double" name="r" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns the block diagonal eigenvalue matrix, &lt;tt&gt;D&lt;/tt&gt;.</text>
    <return>&lt;tt&gt;D&lt;/tt&gt;</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getD">
    <declaration type="double[][]" name="D" />
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the imaginary parts of the eigenvalues.</text>
    <return>imag(diag(D))</return>
  </javadoc>
  <method type="DoubleMatrix1D" name="getImagEigenvalues" />
  <javadoc>
    <text>Returns the real parts of the eigenvalues.</text>
    <return>real(diag(D))</return>
  </javadoc>
  <method type="DoubleMatrix1D" name="getRealEigenvalues" />
  <javadoc>
    <text>Returns the eigenvector matrix, &lt;tt&gt;V&lt;/tt&gt;</text>
    <return>&lt;tt&gt;V&lt;/tt&gt;</return>
  </javadoc>
  <method type="DoubleMatrix2D" name="getV" />
  <javadoc>
    <text>Nonsymmetric reduction from Hessenberg to real Schur form.</text>
  </javadoc>
  <method type="void" name="hqr2">
    <declaration type="int" name="nn" />
    <declaration type="int" name="n" />
    <declaration type="int" name="low" />
    <declaration type="int" name="high" />
    <declaration type="double" name="eps" />
    <declaration type="double" name="exshift" />
    <declaration type="double" name="p" />
    <declaration type="double" name="norm" />
    <scope>
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="iter" />
    <scope>
      <declaration type="int" name="l" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
      <scope>
        <scope>
          <scope />
          <scope />
          <scope />
          <scope />
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
      <scope>
        <scope />
        <scope>
          <scope />
        </scope>
        <scope>
          <scope>
            <scope />
            <scope />
          </scope>
        </scope>
        <declaration type="int" name="m" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
        <scope>
          <declaration type="boolean" name="notlast" />
          <scope>
            <scope />
          </scope>
          <scope />
          <scope />
          <scope>
            <scope />
            <scope />
            <scope>
              <scope />
            </scope>
            <scope>
              <scope />
            </scope>
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope />
    <scope>
      <scope>
        <declaration type="int" name="l" />
        <scope>
          <scope />
          <scope />
          <scope>
            <scope>
              <scope />
              <scope />
            </scope>
            <scope>
              <scope />
              <scope />
            </scope>
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
      <scope>
        <declaration type="int" name="l" />
        <scope />
        <scope />
        <scope>
          <declaration type="double" name="ra" />
          <scope />
          <scope />
          <scope>
            <scope />
            <scope>
              <scope />
              <scope />
              <scope />
            </scope>
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>This is derived from the Algol procedure hqr2,</comment>
    <comment>by Martin and Wilkinson, Handbook for Auto. Comp.,</comment>
    <comment>Vol.ii-Linear Algebra, and the corresponding</comment>
    <comment>Fortran subroutine in EISPACK.</comment>
    <comment>Initialize</comment>
    <comment>Store roots isolated by balanc and compute matrix norm</comment>
    <comment>Outer loop over eigenvalue index</comment>
    <comment>Look for single small sub-diagonal element</comment>
    <comment>Check for convergence</comment>
    <comment>One root found</comment>
    <comment>Two roots found</comment>
    <comment>Real pair</comment>
    <comment>Row modification</comment>
    <comment>Column modification</comment>
    <comment>Accumulate transformations</comment>
    <comment>Complex pair</comment>
    <comment>No convergence yet</comment>
    <comment>Form shift</comment>
    <comment>Wilkinson's original ad hoc shift</comment>
    <comment>MATLAB's new ad hoc shift</comment>
    <comment>(Could check iteration count here.)</comment>
    <comment>Look for two consecutive small sub-diagonal elements</comment>
    <comment>Double QR step involving rows l:n and columns m:n</comment>
    <comment>Row modification</comment>
    <comment>Column modification</comment>
    <comment>Accumulate transformations</comment>
    <comment>(s != 0)</comment>
    <comment>k loop</comment>
    <comment>check convergence</comment>
    <comment>while (n &gt;= low)</comment>
    <comment>Backsubstitute to find vectors of upper triangular form</comment>
    <comment>Real vector</comment>
    <comment>Solve real equations</comment>
    <comment>Overflow control</comment>
    <comment>Complex vector</comment>
    <comment>Last vector component imaginary so matrix is triangular</comment>
    <comment>Solve complex equations</comment>
    <comment>Overflow control</comment>
    <comment>Vectors of isolated roots</comment>
    <comment>Back transformation to get eigenvectors of original matrix</comment>
  </method>
  <javadoc>
    <text>Nonsymmetric reduction to Hessenberg form.</text>
  </javadoc>
  <method type="void" name="orthes">
    <declaration type="int" name="low" />
    <declaration type="int" name="high" />
    <scope>
      <declaration type="double" name="scale" />
      <scope />
      <scope>
        <declaration type="double" name="h" />
        <scope />
        <declaration type="double" name="g" />
        <scope />
        <scope>
          <declaration type="double" name="f" />
          <scope />
          <scope />
        </scope>
        <scope>
          <declaration type="double" name="f" />
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
    <scope>
      <scope>
        <scope />
        <scope>
          <declaration type="double" name="g" />
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>This is derived from the Algol procedures orthes and ortran,</comment>
    <comment>by Martin and Wilkinson, Handbook for Auto. Comp.,</comment>
    <comment>Vol.ii-Linear Algebra, and the corresponding</comment>
    <comment>Fortran subroutines in EISPACK.</comment>
    <comment>Scale column.</comment>
    <comment>Compute Householder transformation.</comment>
    <comment>Apply Householder similarity transformation</comment>
    <comment>H = (I-u*u'/h)*H*(I-u*u')/h)</comment>
    <comment>Accumulate transformations (Algol's ortran).</comment>
    <comment>Double division avoids possible underflow</comment>
  </method>
  <javadoc>
    <text>Returns a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * &lt;pre&gt;
 * rank          : 3
 * trace         : 0
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="StringBuffer" name="buf" />
    <declaration type="String" name="unknown" />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Symmetric tridiagonal QL algorithm.</text>
  </javadoc>
  <method type="void" name="tql2">
    <scope />
    <declaration type="double" name="f" />
    <declaration type="double" name="tst1" />
    <declaration type="double" name="eps" />
    <scope>
      <declaration type="int" name="m" />
      <scope>
        <scope />
      </scope>
      <scope>
        <declaration type="int" name="iter" />
        <scope>
          <declaration type="double" name="g" />
          <declaration type="double" name="p" />
          <declaration type="double" name="r" />
          <scope />
          <declaration type="double" name="dl1" />
          <declaration type="double" name="h" />
          <scope />
          <declaration type="double" name="c" />
          <declaration type="double" name="c2" />
          <declaration type="double" name="c3" />
          <declaration type="double" name="el1" />
          <declaration type="double" name="s" />
          <declaration type="double" name="s2" />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope>
      <declaration type="int" name="k" />
      <declaration type="double" name="p" />
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>This is derived from the Algol procedures tql2, by</comment>
    <comment>Bowdler, Martin, Reinsch, and Wilkinson, Handbook for</comment>
    <comment>Auto. Comp., Vol.ii-Linear Algebra, and the corresponding</comment>
    <comment>Fortran subroutine in EISPACK.</comment>
    <comment>Find small subdiagonal element</comment>
    <comment>If m == l, d[l] is an eigenvalue,</comment>
    <comment>otherwise, iterate.</comment>
    <comment>(Could check iteration count here.)</comment>
    <comment>Compute implicit shift</comment>
    <comment>Implicit QL transformation.</comment>
    <comment>Accumulate transformation.</comment>
    <comment>Check for convergence.</comment>
    <comment>Sort eigenvalues and corresponding vectors.</comment>
  </method>
  <javadoc>
    <text>Symmetric Householder reduction to tridiagonal form.</text>
  </javadoc>
  <method type="void" name="tred2">
    <scope />
    <scope>
      <declaration type="double" name="scale" />
      <declaration type="double" name="h" />
      <scope />
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
        <declaration type="double" name="f" />
        <declaration type="double" name="g" />
        <scope />
        <scope />
        <scope>
          <scope />
        </scope>
        <scope />
        <declaration type="double" name="hh" />
        <scope />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <scope>
      <declaration type="double" name="h" />
      <scope>
        <scope />
        <scope>
          <declaration type="double" name="g" />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope />
    </scope>
    <scope />
    <comment>This is derived from the Algol procedures tred2 by</comment>
    <comment>Bowdler, Martin, Reinsch, and Wilkinson, Handbook for</comment>
    <comment>Auto. Comp., Vol.ii-Linear Algebra, and the corresponding</comment>
    <comment>Fortran subroutine in EISPACK.</comment>
    <comment>Householder reduction to tridiagonal form.</comment>
    <comment>Scale to avoid under/overflow.</comment>
    <comment>Generate Householder vector.</comment>
    <comment>Apply similarity transformation to remaining columns.</comment>
    <comment>Accumulate transformations.</comment>
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>Complex scalar division.</comment>
</class>
