<?xml version="1.0" encoding="UTF-8"?>
<class name="Sorting">
  <javadoc>
    <text>Matrix quicksorts and mergesorts.
 * Use idioms like &lt;tt&gt;Sorting.quickSort.sort(...)&lt;/tt&gt; and &lt;tt&gt;Sorting.mergeSort.sort(...)&lt;/tt&gt;.
 * &lt;p&gt;
 * This is another case demonstrating one primary goal of this library: Delivering easy to use, yet very efficient APIs.
 * The sorts return convenient &lt;i&gt;sort views&lt;/i&gt;.
 * This enables the usage of algorithms which scale well with the problem size:
 * For example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix.
 * This is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices.
 * The original matrix is left unaffected.
 * &lt;p&gt;
 * The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in turn, based on Bentley's and McIlroy's fine work).
 * The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
 * Mergesort is &lt;i&gt;stable&lt;/i&gt; (by definition), while quicksort is not.
 * A stable sort is, for example, helpful, if matrices are sorted successively 
 * by multiple columns. It preserves the relative position of equal elements.</text>
    <see>cern.colt.GenericSorting</see>
    <see>cern.colt.Sorting</see>
    <see>java.util.Arrays</see>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.1, 25/May/2000</version>
  </javadoc>
  <javadoc>
    <text>A prefabricated quicksort.</text>
  </javadoc>
  <declaration type="Sorting" name="quickSort" />
  <javadoc>
    <text>A prefabricated mergesort.</text>
  </javadoc>
  <method type="void" name="runSort">
    <comment>override quicksort with mergesort</comment>
  </method>
  <method type="void" name="runSort" />
  <declaration type="Sorting" name="mergeSort" />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Sorting" />
  <method type="void" name="runSort" />
  <method type="void" name="runSort" />
  <javadoc>
    <text>Sorts the vector into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt;.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt; 
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr nowrap&gt; 
 * &lt;td valign="top"&gt;&lt;tt&gt; 7, 1, 3, 1&lt;br&gt;
 * &lt;/tt&gt;&lt;/td&gt;
 * &lt;td valign="top"&gt; 
 * &lt;p&gt;&lt;tt&gt; ==&amp;gt; 1, 1, 3, 7&lt;br&gt;
 * The vector IS NOT SORTED.&lt;br&gt;
 * The new VIEW IS SORTED.&lt;/tt&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>vector the vector to be sorted.</param>
    <return>a new sorted vector (matrix) view. 
 * &lt;b&gt;Note that the original matrix is left unaffected.&lt;/b&gt;</return>
  </javadoc>
  <method type="ObjectMatrix1D" name="sort">
    <declaration type="int[]" name="indexes" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare">
      <declaration type="Comparable" name="av" />
      <declaration type="Comparable" name="bv" />
      <declaration type="int" name="r" />
    </method>
    <comment>row indexes to reorder instead of matrix itself</comment>
  </method>
  <javadoc>
    <text>Sorts the vector into ascending order, according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt;
 * &lt;pre&gt;
 * // sort by sinus of cells
 * ObjectComparator comp = new ObjectComparator() {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(Object a, Object b) {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object as = Math.sin(a); Object bs = Math.sin(b);
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
 * };
 * sorted = quickSort(vector,comp);
 * &lt;/pre&gt;</text>
    <param>vector the vector to be sorted.</param>
    <param>c the comparator to determine the order.</param>
    <return>a new matrix view sorted as specified.
 * &lt;b&gt;Note that the original vector (matrix) is left unaffected.&lt;/b&gt;</return>
  </javadoc>
  <method type="ObjectMatrix1D" name="sort">
    <declaration type="int[]" name="indexes" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare" />
    <comment>row indexes to reorder instead of matrix itself</comment>
  </method>
  <javadoc>
    <text>Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt; 
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr nowrap&gt; 
 * &lt;td valign="top"&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
 * 7, 6&lt;br&gt;
 * 5, 4&lt;br&gt;
 * 3, 2&lt;br&gt;
 * 1, 0 &lt;br&gt;
 * &lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="left" valign="top"&gt; 
 * &lt;p&gt;&lt;tt&gt;column = 0;&lt;br&gt;
 * view = quickSort(matrix,column);&lt;br&gt;
 * System.out.println(view); &lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
 * ==&gt; &lt;/tt&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;td valign="top"&gt; 
 * &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
 * 1, 0&lt;br&gt;
 * 3, 2&lt;br&gt;
 * 5, 4&lt;br&gt;
 * 7, 6&lt;/tt&gt;&lt;br&gt;
 * The matrix IS NOT SORTED.&lt;br&gt;
 * The new VIEW IS SORTED.&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>matrix the matrix to be sorted.</param>
    <param>column the index of the column inducing the order.</param>
    <return>a new matrix view having rows sorted by the given column.
 * &lt;b&gt;Note that the original matrix is left unaffected.&lt;/b&gt;</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;column &lt; 0 || column &gt;= matrix.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="ObjectMatrix2D" name="sort">
    <declaration type="int[]" name="rowIndexes" />
    <declaration type="ObjectMatrix1D" name="col" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare">
      <declaration type="Comparable" name="av" />
      <declaration type="Comparable" name="bv" />
      <declaration type="int" name="r" />
    </method>
    <comment>row indexes to reorder instead of matrix itself</comment>
    <comment>view the matrix according to the reordered row indexes</comment>
    <comment>take all columns in the original order</comment>
  </method>
  <javadoc>
    <text>Sorts the matrix rows according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt;
 * &lt;pre&gt;
 * // sort by sum of values in a row
 * ObjectMatrix1DComparator comp = new ObjectMatrix1DComparator() {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(ObjectMatrix1D a, ObjectMatrix1D b) {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object as = a.zSum(); Object bs = b.zSum();
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
 * };
 * sorted = quickSort(matrix,comp);
 * &lt;/pre&gt;</text>
    <param>matrix the matrix to be sorted.</param>
    <param>c the comparator to determine the order.</param>
    <return>a new matrix view having rows sorted as specified.
 * &lt;b&gt;Note that the original matrix is left unaffected.&lt;/b&gt;</return>
  </javadoc>
  <method type="ObjectMatrix2D" name="sort">
    <declaration type="int[]" name="rowIndexes" />
    <declaration type="ObjectMatrix1D[]" name="views" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare" />
    <comment>row indexes to reorder instead of matrix itself</comment>
    <comment>precompute views for speed</comment>
    <comment>return c.compare(matrix.viewRow(a), matrix.viewRow(b));</comment>
    <comment>view the matrix according to the reordered row indexes</comment>
    <comment>take all columns in the original order</comment>
  </method>
  <javadoc>
    <text>Sorts the matrix slices into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given &lt;tt&gt;[row,column]&lt;/tt&gt; position.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
 * &lt;p&gt;
 * The algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other.
 * Comparison is based on the cell &lt;tt&gt;[row,column]&lt;/tt&gt; within a slice.
 * Let &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; be two 2-d slices. Then we have the following rules
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;A &amp;lt;  B  iff A.get(row,column) &amp;lt;  B.get(row,column)&lt;/tt&gt;
 * &lt;li&gt;&lt;tt&gt;A == B iff A.get(row,column) == B.get(row,column)&lt;/tt&gt;
 * &lt;li&gt;&lt;tt&gt;A &amp;gt;  B  iff A.get(row,column) &amp;gt;  B.get(row,column)&lt;/tt&gt;
 * &lt;/ul&gt;</text>
    <param>matrix the matrix to be sorted.</param>
    <param>row the index of the row inducing the order.</param>
    <param>column the index of the column inducing the order.</param>
    <return>a new matrix view having slices sorted by the values of the slice view &lt;tt&gt;matrix.viewRow(row).viewColumn(column)&lt;/tt&gt;.
 * &lt;b&gt;Note that the original matrix is left unaffected.&lt;/b&gt;</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;row &lt; 0 || row &gt;= matrix.rows() || column &lt; 0 || column &gt;= matrix.columns()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="ObjectMatrix3D" name="sort">
    <declaration type="int[]" name="sliceIndexes" />
    <declaration type="ObjectMatrix1D" name="sliceView" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare">
      <declaration type="Comparable" name="av" />
      <declaration type="Comparable" name="bv" />
      <declaration type="int" name="r" />
    </method>
    <comment>indexes to reorder instead of matrix itself</comment>
    <comment>view the matrix according to the reordered slice indexes</comment>
    <comment>take all rows and columns in the original order</comment>
  </method>
  <javadoc>
    <text>Sorts the matrix slices according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt;
 * &lt;pre&gt;
 * // sort by sum of values in a slice
 * ObjectMatrix2DComparator comp = new ObjectMatrix2DComparator() {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(ObjectMatrix2D a, ObjectMatrix2D b) {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object as = a.zSum(); Object bs = b.zSum();
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
 * };
 * sorted = quickSort(matrix,comp);
 * &lt;/pre&gt;</text>
    <param>matrix the matrix to be sorted.</param>
    <param>c the comparator to determine the order.</param>
    <return>a new matrix view having slices sorted as specified.
 * &lt;b&gt;Note that the original matrix is left unaffected.&lt;/b&gt;</return>
  </javadoc>
  <method type="ObjectMatrix3D" name="sort">
    <declaration type="int[]" name="sliceIndexes" />
    <declaration type="ObjectMatrix2D[]" name="views" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare" />
    <comment>indexes to reorder instead of matrix itself</comment>
    <comment>precompute views for speed</comment>
    <comment>return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));</comment>
    <comment>view the matrix according to the reordered slice indexes</comment>
    <comment>take all rows and columns in the original order</comment>
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>already has quicksort implemented</comment>
</class>
