<?xml version="1.0" encoding="UTF-8"?>
<class name="Partitioning">
  <javadoc>
    <text>Given some interval boundaries, partitions matrices such that cell values falling into an interval are placed next to each other.
 * &lt;p&gt;
 * &lt;b&gt;Performance&lt;/b&gt;
 * &lt;p&gt;
 * Partitioning into two intervals is &lt;tt&gt;O( N )&lt;/tt&gt;.
 * Partitioning into k intervals is &lt;tt&gt;O( N * log(k))&lt;/tt&gt;.
 * Constants factors are minimized.</text>
    <see>cern.colt.Partitioning "Partitioning arrays (provides more documentation)"</see>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Partitioning" />
  <javadoc>
    <text>Same as {@link cern.colt.Partitioning#partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
 * This is essentially the same as partitioning a list of composite objects by some instance variable;
 * In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Let's say, a "row" is an "object" (tuple, d-dimensional point).
 * A "column" is the list of "object" values of a given variable (field, dimension).
 * A "matrix" is a list of "objects" (tuples, points).
 * &lt;p&gt;
 * Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
 * Two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Note that arguments are not checked for validity.
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt; 
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr nowrap&gt; 
 * &lt;td valign="top"&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
 * 23, 22, 21&lt;br&gt;
 * 20, 19, 18&lt;br&gt;
 * 17, 16, 15&lt;br&gt;
 * 14, 13, 12&lt;br&gt;
 * 11, 10, 9&lt;br&gt;
 * 8,  7,  6&lt;br&gt;
 * 5,  4,  3&lt;br&gt;
 * 2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="left" valign="top"&gt; 
 * &lt;p&gt;&lt;tt&gt;column = 0;&lt;br&gt;
 * rowIndexes = {0,1,2,..,matrix.rows()-1};
 * rowFrom = 0;&lt;br&gt;
 * rowTo = matrix.rows()-1;&lt;br&gt;
 * splitters = {5,10,12}&lt;br&gt;
 * c = 0; &lt;br&gt;
 * d = splitters.length-1;&lt;br&gt;
 * partition(matrix,rowIndexes,rowFrom,rowTo,column,splitters,c,d,splitIndexes);&lt;br&gt;
 * ==&gt;&lt;br&gt;
 * splitIndexes == {0, 2, 3}&lt;br&gt;
 * rowIndexes == {7, 6, 5, 4, 0, 1, 2, 3}&lt;/tt&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;td valign="top"&gt;
 * The matrix IS NOT REORDERED.&lt;br&gt;
 * Here is how it would look&lt;br&gt;
 * like, if it would be reordered&lt;br&gt;
 * accoring to &lt;tt&gt;rowIndexes&lt;/tt&gt;.&lt;br&gt;
 * &lt;tt&gt;8 x 3 matrix:&lt;br&gt;
 * 2,  1,  0&lt;br&gt;
 * 5,  4,  3&lt;br&gt;
 * 8,  7,  6&lt;br&gt;
 * 11, 10, 9&lt;br&gt;
 * 23, 22, 21&lt;br&gt;
 * 20, 19, 18&lt;br&gt;
 * 17, 16, 15&lt;br&gt;
 * 14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>matrix the matrix to be partitioned.</param>
    <param>rowIndexes the index of the i-th row; is modified by this method to reflect partitioned indexes.</param>
    <param>rowFrom the index of the first row (inclusive).</param>
    <param>rowTo the index of the last row (inclusive).</param>
    <param>column the index of the column to partition on.</param>
    <param>splitters the values at which the rows shall be split into intervals.
 * Must be sorted ascending and must not contain multiple identical values.
 * These preconditions are not checked; be sure that they are met.</param>
    <param>splitFrom the index of the first splitter element to be considered.</param>
    <param>splitTo the index of the last splitter element to be considered.
 * The method considers the splitter elements &lt;tt&gt;splitters[splitFrom] .. splitters[splitTo]&lt;/tt&gt;.</param>
    <param>splitIndexes a list into which this method fills the indexes of rows delimiting intervals.
 * Upon return &lt;tt&gt;splitIndexes[splitFrom..splitTo]&lt;/tt&gt; will be set accordingly.
 * Therefore, must satisfy &lt;tt&gt;splitIndexes.length &gt;= splitters.length&lt;/tt&gt;.</param>
  </javadoc>
  <method type="void" name="partition">
    <declaration type="int[]" name="g" />
    <declaration type="Swapper" name="swapper" />
    <method type="void" name="swap">
      <declaration type="int" name="tmp" />
    </method>
    <declaration type="ObjectMatrix1D" name="columnView" />
    <declaration type="IntComparator" name="comp" />
    <method type="int" name="compare">
      <declaration type="Comparable" name="av" />
      <declaration type="Comparable" name="bv" />
      <declaration type="int" name="r" />
    </method>
    <declaration type="IntComparator" name="comp2" />
    <method type="int" name="compare">
      <declaration type="Comparable" name="av" />
      <declaration type="Comparable" name="bv" />
      <declaration type="int" name="r" />
    </method>
    <declaration type="IntComparator" name="comp3" />
    <method type="int" name="compare">
      <declaration type="Comparable" name="av" />
      <declaration type="Comparable" name="bv" />
      <declaration type="int" name="r" />
    </method>
    <comment>this one knows how to swap two row indexes (a,b)</comment>
    <comment>compare splitter[a] with columnView[rowIndexes[b]]</comment>
    <comment>compare columnView[rowIndexes[a]] with columnView[rowIndexes[b]]</comment>
    <comment>compare splitter[a] with splitter[b]</comment>
    <comment>generic partitioning does the main work of reordering row indexes</comment>
  </method>
  <javadoc>
    <text>Same as {@link cern.colt.Partitioning#partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
 * This is essentially the same as partitioning a list of composite objects by some instance variable;
 * In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Let's say, a "row" is an "object" (tuple, d-dimensional point).
 * A "column" is the list of "object" values of a given variable (field, dimension).
 * A "matrix" is a list of "objects" (tuples, points).
 * &lt;p&gt;
 * Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
 * Two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Note that arguments are not checked for validity.
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt; 
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr nowrap&gt; 
 * &lt;td valign="top"&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
 * 23, 22, 21&lt;br&gt;
 * 20, 19, 18&lt;br&gt;
 * 17, 16, 15&lt;br&gt;
 * 14, 13, 12&lt;br&gt;
 * 11, 10, 9&lt;br&gt;
 * 8,  7,  6&lt;br&gt;
 * 5,  4,  3&lt;br&gt;
 * 2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="left" valign="top"&gt; 
 * &lt;tt&gt;column = 0;&lt;br&gt;
 * splitters = {5,10,12}&lt;br&gt;
 * partition(matrix,column,splitters,splitIndexes);&lt;br&gt;
 * ==&gt;&lt;br&gt;
 * splitIndexes == {0, 2, 3}&lt;/tt&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;td valign="top"&gt;
 * The matrix IS NOT REORDERED.&lt;br&gt;
 * The new VIEW IS REORDERED:&lt;br&gt;
 * &lt;tt&gt;8 x 3 matrix:&lt;br&gt;
 * 2,  1,  0&lt;br&gt;
 * 5,  4,  3&lt;br&gt;
 * 8,  7,  6&lt;br&gt;
 * 11, 10, 9&lt;br&gt;
 * 23, 22, 21&lt;br&gt;
 * 20, 19, 18&lt;br&gt;
 * 17, 16, 15&lt;br&gt;
 * 14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>matrix the matrix to be partitioned.</param>
    <param>column the index of the column to partition on.</param>
    <param>splitters the values at which the rows shall be split into intervals.
 * Must be sorted ascending and must not contain multiple identical values.
 * These preconditions are not checked; be sure that they are met.</param>
    <param>splitIndexes a list into which this method fills the indexes of rows delimiting intervals.
 * Therefore, must satisfy &lt;tt&gt;splitIndexes.length &gt;= splitters.length&lt;/tt&gt;.</param>
    <return>a new matrix view having rows partitioned by the given column and splitters.</return>
  </javadoc>
  <method type="ObjectMatrix2D" name="partition">
    <declaration type="int" name="rowFrom" />
    <declaration type="int" name="rowTo" />
    <declaration type="int" name="splitFrom" />
    <declaration type="int" name="splitTo" />
    <declaration type="int[]" name="rowIndexes" />
    <declaration type="int[]" name="columnIndexes" />
    <comment>row indexes to reorder instead of matrix itself</comment>
    <comment>take all columns in the original order</comment>
    <comment>view the matrix according to the reordered row indexes</comment>
  </method>
  <javadoc>
    <text>Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
 * This is essentially the same as partitioning a list of composite objects by some instance variable;
 * In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Let's say, a "row" is an "object" (tuple, d-dimensional point).
 * A "column" is the list of "object" values of a given variable (field, dimension).
 * A "matrix" is a list of "objects" (tuples, points).
 * &lt;p&gt;
 * Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
 * Two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Of course, the column must not be a column of a different matrix.
 * More formally, there must hold: &lt;br&gt;
 * There exists an &lt;tt&gt;i&lt;/tt&gt; such that &lt;tt&gt;matrix.viewColumn(i)==column&lt;/tt&gt;.
 * &lt;p&gt;
 * Note that arguments are not checked for validity.
 * &lt;p&gt;
 * &lt;b&gt;Example:&lt;/b&gt; 
 * &lt;table border="1" cellspacing="0"&gt;
 * &lt;tr nowrap&gt; 
 * &lt;td valign="top"&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
 * 23, 22, 21&lt;br&gt;
 * 20, 19, 18&lt;br&gt;
 * 17, 16, 15&lt;br&gt;
 * 14, 13, 12&lt;br&gt;
 * 11, 10, 9&lt;br&gt;
 * 8,  7,  6&lt;br&gt;
 * 5,  4,  3&lt;br&gt;
 * 2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
 * &lt;td align="left"&gt; 
 * &lt;p&gt;&lt;tt&gt;column = matrix.viewColumn(0);&lt;br&gt;
 * a = 0;&lt;br&gt;
 * b = column.size()-1;&lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
 * splitters={5,10,12}&lt;br&gt;
 * c=0; &lt;br&gt;
 * d=splitters.length-1;&lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
 * partition(matrix,column,a,b,splitters,c,d,splitIndexes);&lt;br&gt;
 * ==&gt;&lt;br&gt;
 * splitIndexes == {0, 2, 3}&lt;/tt&gt;&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;td valign="top"&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
 * 2,  1,  0&lt;br&gt;
 * 5,  4,  3&lt;br&gt;
 * 8,  7,  6&lt;br&gt;
 * 11, 10, 9&lt;br&gt;
 * 23, 22, 21&lt;br&gt;
 * 20, 19, 18&lt;br&gt;
 * 17, 16, 15&lt;br&gt;
 * 14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;</text>
  </javadoc>
  <method type="void" name="xPartitionOld">
    <comment>Object splitter;  int, Object --&gt; template type dependent

if (splitFrom&gt;splitTo) return;  nothing to do
if (from&gt;to) {  all bins are empty
from--;
for (int i = splitFrom; i&lt;=splitTo; ) splitIndexes[i++] = from;
return;
}

 Choose a partition (pivot) index, m
 Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.
 However, computing the median is expensive, so we use an approximation.
int medianIndex;
if (splitFrom==splitTo) {  we don't really have a choice
medianIndex = splitFrom;
}
else {  we do have a choice
int m = (from+to)  2;        Small arrays, middle element
int len = to-from+1;
if (len &gt; SMALL) {
int l = from;
int n = to;
if (len &gt; MEDIUM) {         Big arrays, pseudomedian of 9
int s = len8;
l = med3(column, l,     l+s, l+2s);
m = med3(column, m-s,   m,   m+s);
n = med3(column, n-2s, n-s, n);
}
m = med3(column, l, m, n);  Mid-size, pseudomedian of 3
}

 Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.
medianIndex = cern.colt.Sorting.binarySearchFromTo(splitters,column.getQuick(m),splitFrom,splitTo);
if (medianIndex &lt; 0) medianIndex = -medianIndex - 1;  not found
if (medianIndex &gt; splitTo) medianIndex = splitTo;  not found, one past the end

}
splitter = splitters[medianIndex];

 Partition the list according to the splitter, i.e.
 Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to
int	splitIndex = xPartitionOld(matrix,column,from,to,splitter);
splitIndexes[medianIndex] = splitIndex;

 Optimization: Handle special cases to cut down recursions.
if (splitIndex &lt; from) {  no element falls into this bin
 all bins with splitters[i] &lt;= splitter are empty
int i = medianIndex-1;
while (i&gt;=splitFrom &amp;&amp; (!(splitter &lt; splitters[i]))) splitIndexes[i--] = splitIndex;
splitFrom = medianIndex+1;
}
else if (splitIndex &gt;= to) {  all elements fall into this bin
 all bins with splitters[i] &gt;= splitter are empty
int i = medianIndex+1;
while (i&lt;=splitTo &amp;&amp; (!(splitter &gt; splitters[i]))) splitIndexes[i++] = splitIndex;
splitTo = medianIndex-1;
}

 recursively partition left half
if (splitFrom &lt;= medianIndex-1) {
xPartitionOld(matrix, column, from,         splitIndex, splitters, splitFrom, medianIndex-1,  splitIndexes);
}

 recursively partition right half
if (medianIndex+1 &lt;= splitTo) {
xPartitionOld(matrix, column, splitIndex+1, to,         splitters, medianIndex+1,  splitTo,   splitIndexes);
}</comment>
  </method>
  <javadoc>
    <text>Same as {@link #partition(int[],int,int,int)} 
 * except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
 * This is essentially the same as partitioning a list of composite objects by some instance variable;
 * In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Let's say, a "row" is an "object" (tuple, d-dimensional point).
 * A "column" is the list of "object" values of a given variable (field, dimension).
 * A "matrix" is a list of "objects" (tuples, points).
 * &lt;p&gt;
 * Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
 * Two entire rows of the matrix are swapped, whenever two column values indicate so.
 * &lt;p&gt;
 * Of course, the column must not be a column of a different matrix.
 * More formally, there must hold: &lt;br&gt;
 * There exists an &lt;tt&gt;i&lt;/tt&gt; such that &lt;tt&gt;matrix.viewColumn(i)==column&lt;/tt&gt;.
 * Note that arguments are not checked for validity.</text>
  </javadoc>
  <method type="int" name="xPartitionOld">
    <comment>Object element;   int, Object --&gt; template type dependent
for (int i=from-1; ++i&lt;=to; ) {
element = column.getQuick(i);
if (element &lt; splitter) {
 swap x[i] with x[from]
matrix.swapRows(i,from);
from++;
}
}
return from-1;</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
