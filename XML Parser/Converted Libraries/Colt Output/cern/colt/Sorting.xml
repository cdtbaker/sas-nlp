<?xml version="1.0" encoding="UTF-8"?>
<class name="Sorting">
  <javadoc>
    <text>Quicksorts, mergesorts and binary searches; complements &lt;tt&gt;java.util.Arrays&lt;/tt&gt;.
 * Contains, for example, the quicksort on Comparators and Comparables, which are still missing in &lt;tt&gt;java.util.Arrays&lt;/tt&gt; of JDK 1.2.
 * Also provides mergesorts for types not supported in &lt;tt&gt;java.util.Arrays&lt;/tt&gt;, as well as a couple of other methods for primitive arrays.
 * The quicksorts and mergesorts are the JDK 1.2 V1.26 algorithms, modified as necessary.</text>
    <see>cern.colt.GenericSorting</see>
    <see>cern.colt.matrix.doublealgo.Sorting</see>
    <see>java.util.Arrays</see>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 03-Jul-99</version>
  </javadoc>
  <declaration type="int" name="SMALL" />
  <declaration type="int" name="MEDIUM" />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Sorting" />
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="byte" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="char" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="double" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="float" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="int" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
    <comment>even for very short lists (0,1,2,3 elems) this is only 10% faster
while (from&lt;=to &amp;&amp; list[from++] &lt; key) ;
if (from&lt;=to) {
if (list[--from] == key) return from;
}
return -(from + 1);</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="long" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm. The list must be sorted into ascending order
 * according to the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * If the list is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which instance
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <param>comparator the comparator by which the list is sorted.</param>
    <throws>ClassCastException if the list contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
    <see>java.util.Comparator</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="Object" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
      <declaration type="int" name="cmp" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="short" name="midVal" />
    <scope>
      <declaration type="int" name="mid" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Generically searches the list for the specified value using
 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
    <param>list the list to be searched.</param>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the list;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="int" name="dummy" />
    <scope>
      <declaration type="int" name="mid" />
      <declaration type="int" name="comparison" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <method type="int" name="lower_bound">
    <declaration type="int" name="len" />
    <scope>
      <declaration type="int" name="half" />
      <declaration type="int" name="middle" />
      <scope />
    </scope>
  </method>
  <method type="int" name="upper_bound">
    <declaration type="int" name="len" />
    <scope>
      <declaration type="int" name="half" />
      <declaration type="int" name="middle" />
      <scope />
    </scope>
  </method>
  <method type="void" name="inplace_merge">
    <scope>
      <scope>
        <declaration type="int" name="tmp" />
      </scope>
    </scope>
    <declaration type="int" name="firstCut" />
    <declaration type="int" name="secondCut" />
    <scope />
    <scope />
    <declaration type="int" name="first2" />
    <declaration type="int" name="middle2" />
    <declaration type="int" name="last2" />
    <scope>
      <declaration type="int" name="first1" />
      <declaration type="int" name="last1" />
      <declaration type="int" name="tmp" />
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>rotate(array, firstCut, middle, secondCut);</comment>
    <comment>is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are "static private")</comment>
    <comment>speedup = 1.7</comment>
    <comment>begin inline</comment>
    <comment>end inline</comment>
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Returns the index of the median of the three indexed chars.</text>
  </javadoc>
  <method type="int" name="med3">
    <declaration type="int" name="ab" />
    <declaration type="int" name="ac" />
    <declaration type="int" name="bc" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="byte[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="byte[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="char[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="char[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="double[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="float[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="int[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="int[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="long[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="long[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="short[]" name="aux" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="mergeSort">
    <declaration type="short[]" name="aux" />
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort1">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="mid" />
    <scope />
    <scope />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves of dest into src</comment>
    <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves (now in src) into dest</comment>
  </method>
  <method type="void" name="mergeSort2">
    <declaration type="long" name="NEG_ZERO_BITS" />
    <declaration type="int" name="numNegZeros" />
    <declaration type="int" name="i" />
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="double[]" name="aux" />
    <scope>
      <declaration type="int" name="j" />
      <scope />
    </scope>
    <comment>The sort is done in three phases to avoid the expense of using
 NaN and -0.0 aware comparisons during the main sort.</comment>
    <comment>Preprocessing phase:  Move any NaN's to end of array, count the
 number of -0.0's, and turn them into 0.0's.</comment>
    <comment>Main sort phase: mergesort everything but the NaN's</comment>
    <comment>Postprocessing phase: change 0.0's to -0.0's as required</comment>
    <comment>posn of ANY zero</comment>
    <comment>j is now one less than the index of the FIRST zero</comment>
  </method>
  <method type="void" name="mergeSort2">
    <declaration type="int" name="NEG_ZERO_BITS" />
    <declaration type="int" name="numNegZeros" />
    <declaration type="int" name="i" />
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="float[]" name="aux" />
    <scope>
      <declaration type="int" name="j" />
      <scope />
    </scope>
    <comment>The sort is done in three phases to avoid the expense of using
 NaN and -0.0 aware comparisons during the main sort.</comment>
    <comment>Preprocessing phase:  Move any NaN's to end of array, count the
 number of -0.0's, and turn them into 0.0's.</comment>
    <comment>Main sort phase: mergesort everything but the NaN's</comment>
    <comment>Postprocessing phase: change 0.0's to -0.0's as required</comment>
    <comment>posn of ANY zero</comment>
    <comment>j is now one less than the index of the FIRST zero</comment>
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements.
 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="mergeSortInPlace">
    <declaration type="int" name="length" />
    <scope>
      <scope>
        <scope>
          <declaration type="int" name="tmp" />
        </scope>
      </scope>
    </scope>
    <declaration type="int" name="mid" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Recursively sort halves</comment>
    <comment>If list is already sorted, nothing left to do.  This is an</comment>
    <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
    <comment>Merge sorted halves</comment>
    <comment>jal.INT.Sorting.inplace_merge(a, fromIndex, mid, toIndex);</comment>
  </method>
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the receiver into
 * ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of its
 * elements.  All elements in this range must implement the
 * &lt;tt&gt;Comparable&lt;/tt&gt; interface.  Furthermore, all elements in this range
 * must be &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt;
 * must not throw a &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements
 * &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in the array).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort, adapted from Jon
 * L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function",
 * Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November
 * 1993).  This algorithm offers n*log(n) performance on many data sets
 * that cause other quicksorts to degrade to quadratic performance.</text>
    <param>a the array to be sorted.</param>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the receiver into
 * ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of its
 * elements.  All elements in this range must implement the
 * &lt;tt&gt;Comparable&lt;/tt&gt; interface.  Furthermore, all elements in this range
 * must be &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt;
 * must not throw a &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements
 * &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in the array).&lt;p&gt;</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the receiver.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified array according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>a the array to be sorted.</param>
    <param>c the comparator to determine the order of the receiver.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>a the array to be sorted.</param>
    <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
    <param>toIndex the index of the last element (exclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the array.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
  </javadoc>
  <method type="void" name="quickSort" />
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="byte" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="char" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="double" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="float" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="int" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="long" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="Comparable" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="Object" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Sorts the specified sub-array of chars into ascending order.</text>
  </javadoc>
  <method type="void" name="quickSort1">
    <scope />
    <declaration type="int" name="m" />
    <scope>
      <declaration type="int" name="l" />
      <declaration type="int" name="n" />
      <scope>
        <declaration type="int" name="s" />
      </scope>
    </scope>
    <declaration type="short" name="v" />
    <declaration type="int" name="a" />
    <scope>
      <declaration type="int" name="comparison" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="s" />
    <comment>Insertion sort on smallest arrays</comment>
    <comment>Choose a partition element, v</comment>
    <comment>Small arrays, middle element</comment>
    <comment>Big arrays, pseudomedian of 9</comment>
    <comment>Mid-size, med of 3</comment>
    <comment>Establish Invariant: v* (&lt;v)* (&gt;v)* v*</comment>
    <comment>Swap partition elements back to middle</comment>
    <comment>Recursively sort non-partition-elements</comment>
  </method>
  <javadoc>
    <text>Check that fromIndex and toIndex are in range, and throw an
 * appropriate exception if they aren't.</text>
  </javadoc>
  <method type="void" name="rangeCheck" />
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="byte" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="char" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="double" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="float" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="int" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="long" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="Object" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a] with x[b].</text>
  </javadoc>
  <method type="void" name="swap">
    <declaration type="short" name="t" />
  </method>
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <javadoc>
    <text>Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
  </javadoc>
  <method type="void" name="vecswap" />
  <comment>Copyright  1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
