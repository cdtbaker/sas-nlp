<?xml version="1.0" encoding="UTF-8"?>
<class name="QuickBitVector">
  <javadoc>
    <text>Implements quick non polymorphic non bounds checking low level bitvector operations.
 * Includes some operations that interpret sub-bitstrings as long integers.
 * &lt;p&gt;
 * &lt;b&gt;WARNING: Methods of this class do not check preconditions.&lt;/b&gt;
 * Provided with invalid parameters these method may return (or set) invalid values without throwing any exception.
 * &lt;b&gt;You should only use this class when performance is critical and you are absolutely sure that indexes are within bounds.&lt;/b&gt;
 * &lt;p&gt;	 
 * A bitvector is modelled as a long array, i.e. &lt;tt&gt;long[] bits&lt;/tt&gt; holds bits of a bitvector.
 * Each long value holds 64 bits.
 * The i-th bit is stored in bits[i/64] at
 * bit position i % 64 (where bit position 0 refers to the least
 * significant bit and 63 refers to the most significant bit).</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
    <see>BitVector</see>
    <see>BitMatrix</see>
    <see>java.util.BitSet</see>
  </javadoc>
  <declaration type="int" name="ADDRESS_BITS_PER_UNIT" />
  <declaration type="int" name="BITS_PER_UNIT" />
  <declaration type="int" name="BIT_INDEX_MASK" />
  <declaration type="long[]" name="pows" />
  <javadoc>
    <text>Makes this class non instantiable, but still inheritable.</text>
  </javadoc>
  <method type="constructor" name="QuickBitVector" />
  <javadoc>
    <text>Returns a bit mask with bits in the specified range set to 1, all the rest set to 0.
 * In other words, returns a bit mask having 0,1,2,3,...,64 bits set.
 * If &lt;tt&gt;to-from+1==0&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).
 * Precondition (not checked): &lt;tt&gt;to-from+1 &amp;gt;= 0 &amp;&amp; to-from+1 &amp;lt;= 64&lt;/tt&gt;.</text>
    <param>from index of start bit (inclusive)</param>
    <param>to index of end bit (inclusive).</param>
    <return>the bit mask having all bits between &lt;tt&gt;from&lt;/tt&gt; and &lt;tt&gt;to&lt;/tt&gt; set to 1.</return>
  </javadoc>
  <method type="long" name="bitMaskWithBitsSetFromTo">
    <comment>This turned out to be slower:</comment>
    <comment>0xffffffffffffffffL == ~0L == -1L == all 64 bits set.</comment>
    <comment>int width;</comment>
    <comment>return (width=to-from+1) == 0 ? 0L : (0xffffffffffffffffL &gt;&gt;&gt; (BITS_PER_UNIT-width)) &lt;&lt; from;</comment>
  </method>
  <javadoc>
    <text>Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the "clear" (&lt;tt&gt;false&lt;/tt&gt;) state.</text>
    <param>bits   the bitvector.</param>
    <param>bitIndex   the index of the bit to be cleared.</param>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Returns from the bitvector the value of the bit with the specified index.
 * The value is &lt;tt&gt;true&lt;/tt&gt; if the bit with the index &lt;tt&gt;bitIndex&lt;/tt&gt; 
 * is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.</text>
    <param>bits   the bitvector.</param>
    <param>bitIndex   the bit index.</param>
    <return>the value of the bit with the specified index.</return>
  </javadoc>
  <method type="boolean" name="get" />
  <javadoc>
    <text>Returns a long value representing bits of a bitvector from index &lt;tt&gt;from&lt;/tt&gt; to index &lt;tt&gt;to&lt;/tt&gt;.
 * Bits are returned as a long value with the return value having bit 0 set to bit &lt;code&gt;from&lt;/code&gt;, ..., bit &lt;code&gt;to-from&lt;/code&gt; set to bit &lt;code&gt;to&lt;/code&gt;.
 * All other bits of return value are set to 0.
 * If &lt;tt&gt;from &amp;gt; to&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).
 * Precondition (not checked): &lt;tt&gt;to-from+1 &amp;lt;= 64&lt;/tt&gt;.</text>
    <param>bits the bitvector.</param>
    <param>from index of start bit (inclusive).</param>
    <param>to index of end bit (inclusive).</param>
    <return>the specified bits as long value.</return>
  </javadoc>
  <method type="long" name="getLongFromTo">
    <declaration type="int" name="fromIndex" />
    <declaration type="int" name="toIndex" />
    <declaration type="int" name="fromOffset" />
    <declaration type="int" name="toOffset" />
    <declaration type="long" name="mask" />
    <scope />
    <declaration type="long" name="x1" />
    <declaration type="long" name="x2" />
    <comment>equivalent to from/64</comment>
    <comment>equivalent to from%64</comment>
    <comment>this is equivalent to the above, but slower:</comment>
    <comment>final int fromIndex=from/BITS_PER_UNIT;</comment>
    <comment>final int toIndex=to/BITS_PER_UNIT;</comment>
    <comment>final int fromOffset=from%BITS_PER_UNIT;</comment>
    <comment>final int toOffset=to%BITS_PER_UNIT;</comment>
    <comment>range does not cross unit boundaries; value to retrieve is contained in one single long value.</comment>
    <comment>range crosses unit boundaries; value to retrieve is spread over two long values.</comment>
    <comment>get part from first long value</comment>
    <comment>get part from second long value</comment>
    <comment>combine</comment>
  </method>
  <javadoc>
    <text>Returns the index of the least significant bit in state "true".
 * Returns 32 if no bit is in state "true".
 * Examples: 
 * &lt;pre&gt;
 * 0x80000000 --&gt; 31
 * 0x7fffffff --&gt; 0
 * 0x00000001 --&gt; 0
 * 0x00000000 --&gt; 32
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="int" name="leastSignificantBit">
    <declaration type="int" name="i" />
  </method>
  <javadoc>
    <text>Constructs a low level bitvector that holds &lt;tt&gt;size&lt;/tt&gt; elements, with each element taking &lt;tt&gt;bitsPerElement&lt;/tt&gt; bits.</text>
    <param>size   the number of elements to be stored in the bitvector (must be &amp;gt;= 0).</param>
    <param>bitsPerElement   the number of bits one single element takes.</param>
    <return>a low level bitvector.</return>
  </javadoc>
  <method type="long[]" name="makeBitVector">
    <declaration type="int" name="nBits" />
    <declaration type="int" name="unitIndex" />
    <declaration type="long[]" name="bitVector" />
  </method>
  <javadoc>
    <text>Returns the index of the most significant bit in state "true".
 * Returns -1 if no bit is in state "true".
 * Examples: 
 * &lt;pre&gt;
 * 0x80000000 --&gt; 31
 * 0x7fffffff --&gt; 30
 * 0x00000001 --&gt; 0
 * 0x00000000 --&gt; -1
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="int" name="mostSignificantBit">
    <declaration type="int" name="i" />
  </method>
  <javadoc>
    <text>Returns the index within the unit that contains the given bitIndex.</text>
  </javadoc>
  <method type="int" name="offset">
    <comment>equivalent to bitIndex%64</comment>
  </method>
  <javadoc>
    <text>Initializes a table with numbers having 1,2,3,...,64 bits set.
 * pows[i] has bits [0..i-1] set.
 * pows[64] == -1L == ~0L == has all 64 bits set --&gt; correct.
 * to speedup calculations in subsequent methods.</text>
  </javadoc>
  <method type="long[]" name="precomputePows">
    <declaration type="long[]" name="pows" />
    <declaration type="long" name="value" />
    <scope />
    <comment>System.out.println((i)+":"+pows[i]);</comment>
    <comment>System.out.println((0)+":"+pows[0]);</comment>
    <comment>OLD STUFF</comment>
    <comment>for (int i=BITS_PER_UNIT+1; --i &gt;= 0; ) {
pows[i]=value;
value = value &gt;&gt;&gt; 1;
System.out.println((i)+":"+pows[i]);
}</comment>
    <comment>long[] pows=new long[BITS_PER_UNIT];
for (int i=0; i&lt;BITS_PER_UNIT-1; i++) {
pows[i]=Math.round(Math.pow(2.0,i+1))-1;
System.out.println((i)+":"+pows[i]);
}
pows[BITS_PER_UNIT-1] = ~0L;
System.out.println((BITS_PER_UNIT-1)+":"+pows[BITS_PER_UNIT-1]);
return pows;</comment>
  </method>
  <javadoc>
    <text>Sets the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the state specified by &lt;tt&gt;value&lt;/tt&gt;.</text>
    <param>bits   the bitvector.</param>
    <param>bitIndex   the index of the bit to be changed.</param>
    <param>value   the value to be stored in the bit.</param>
  </javadoc>
  <method type="void" name="put" />
  <javadoc>
    <text>Sets bits of a bitvector from index &lt;code&gt;from&lt;/code&gt; to index &lt;code&gt;to&lt;/code&gt; to the bits of &lt;code&gt;value&lt;/code&gt;.
 * Bit &lt;code&gt;from&lt;/code&gt; is set to bit 0 of &lt;code&gt;value&lt;/code&gt;, ..., bit &lt;code&gt;to&lt;/code&gt; is set to bit &lt;code&gt;to-from&lt;/code&gt; of &lt;code&gt;value&lt;/code&gt;.
 * All other bits stay unaffected.
 * If &lt;tt&gt;from &amp;gt; to&lt;/tt&gt; then does nothing.
 * Precondition (not checked): &lt;tt&gt;to-from+1 &amp;lt;= 64&lt;/tt&gt;.</text>
    <param>bits the bitvector.</param>
    <param>value the value to be copied into the bitvector.</param>
    <param>from index of start bit (inclusive).</param>
    <param>to index of end bit (inclusive).</param>
  </javadoc>
  <method type="void" name="putLongFromTo">
    <declaration type="int" name="fromIndex" />
    <declaration type="int" name="toIndex" />
    <declaration type="int" name="fromOffset" />
    <declaration type="int" name="toOffset" />
    <declaration type="long" name="mask" />
    <declaration type="long" name="cleanValue" />
    <declaration type="long" name="shiftedValue" />
    <scope />
    <comment>equivalent to from/64</comment>
    <comment>equivalent to from%64</comment>
    <comment>this is equivalent to the above, but slower:
int fromIndex=fromBITS_PER_UNIT;
int toIndex=toBITS_PER_UNIT;
int fromOffset=from%BITS_PER_UNIT;
int toOffset=to%BITS_PER_UNIT;</comment>
    <comment>make sure all unused bits to the left are cleared.</comment>
    <comment>range does not cross unit boundaries; should go into one single long value.</comment>
    <comment>range crosses unit boundaries; value should go into two long values.</comment>
    <comment>copy into first long value.</comment>
    <comment>copy into second long value.</comment>
  </method>
  <javadoc>
    <text>Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the "set" (&lt;tt&gt;true&lt;/tt&gt;) state.</text>
    <param>bits   the bitvector.</param>
    <param>bitIndex   the index of the bit to be set.</param>
  </javadoc>
  <method type="void" name="set" />
  <javadoc>
    <text>Returns the index of the unit that contains the given bitIndex.</text>
  </javadoc>
  <method type="int" name="unit">
    <comment>equivalent to bitIndex/64</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>64=2^6</comment>
  <comment>= 1 &lt;&lt; ADDRESS_BITS_PER_UNIT</comment>
  <comment>= BITS_PER_UNIT - 1;</comment>
  <comment>precompute bitmasks for speed</comment>
</class>
