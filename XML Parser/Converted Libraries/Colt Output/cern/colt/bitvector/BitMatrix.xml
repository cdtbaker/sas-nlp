<?xml version="1.0" encoding="UTF-8"?>
<class name="BitMatrix">
  <javadoc>
    <text>Fixed sized (non resizable) n*m bit matrix.
 * A bit matrix has a number of columns and rows, which are assigned upon instance construction - The matrix's size is then &lt;tt&gt;columns()*rows()&lt;/tt&gt;.
 * Bits are accessed via &lt;tt&gt;(column,row)&lt;/tt&gt; coordinates.
 * &lt;p&gt;
 * Individual bits can be examined, set, or cleared.
 * Rectangular parts (boxes) can quickly be extracted, copied and replaced.
 * Quick iteration over boxes is provided by optimized internal iterators (&lt;tt&gt;forEach()&lt;/tt&gt; methods).
 * One &lt;code&gt;BitMatrix&lt;/code&gt; may be used to modify the contents of another 
 * &lt;code&gt;BitMatrix&lt;/code&gt; through logical AND, OR, XOR and other similar operations.
 * &lt;p&gt;
 * Legal coordinates range from &lt;tt&gt;[0,0]&lt;/tt&gt; to &lt;tt&gt;[columns()-1,rows()-1]&lt;/tt&gt;.
 * Any attempt to access a bit at a coordinate &lt;tt&gt;column&amp;lt;0 || column&amp;gt;=columns() || row&amp;lt;0 || row&amp;gt;=rows()&lt;/tt&gt; will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.
 * Operations involving two bit matrices (like AND, OR, XOR, etc.) will throw an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; if both bit matrices do not have the same number of columns and rows.
 * &lt;p&gt;
 * If you need extremely quick access to individual bits: Although getting and setting individual bits with methods &lt;tt&gt;get(...)&lt;/tt&gt; and &lt;tt&gt;put(...)&lt;/tt&gt; is quick, it is even quicker (&lt;b&gt;but not safe&lt;/b&gt;) to use &lt;tt&gt;getQuick(...)&lt;/tt&gt; and &lt;tt&gt;putQuick(...)&lt;/tt&gt;.
 * &lt;p&gt;
 * &lt;b&gt;Note&lt;/b&gt; that this implementation is not synchronized.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
    <see>BitVector</see>
    <see>QuickBitVector</see>
    <see>java.util.BitSet</see>
  </javadoc>
  <declaration type="int" name="columns" />
  <declaration type="int" name="rows" />
  <declaration type="long" name="bits" />
  <javadoc>
    <text>Constructs a bit matrix with a given number of columns and rows. All bits are initially &lt;tt&gt;false&lt;/tt&gt;.</text>
    <param>columns the number of columns the matrix shall have.</param>
    <param>rows the number of rows the matrix shall have.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;columns &amp;lt; 0 || rows &amp;lt; 0&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="constructor" name="BitMatrix" />
  <javadoc>
    <text>Performs a logical &lt;b&gt;AND&lt;/b&gt; of the receiver with another bit matrix.
 * The receiver is modified so that a bit in it has the
 * value &lt;code&gt;true&lt;/code&gt; if and only if it already had the 
 * value &lt;code&gt;true&lt;/code&gt; and the corresponding bit in the other bit matrix
 * argument has the value &lt;code&gt;true&lt;/code&gt;.</text>
    <param>other   a bit matrix.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;columns() != other.columns() || rows() != other.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="and" />
  <javadoc>
    <text>Clears all of the bits in receiver whose corresponding
 * bit is set in the other bit matrix.
 * In other words, determines the difference (A\B) between two bit matrices.</text>
    <param>other   a bit matrix with which to mask the receiver.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;columns() != other.columns() || rows() != other.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="andNot" />
  <javadoc>
    <text>Returns the number of bits currently in the &lt;tt&gt;true&lt;/tt&gt; state.
 * Optimized for speed. Particularly quick if the receiver is either sparse or dense.</text>
  </javadoc>
  <method type="int" name="cardinality" />
  <javadoc>
    <text>Sanity check for operations requiring matrices with the same number of columns and rows.</text>
  </javadoc>
  <method type="void" name="checkDimensionCompatibility" />
  <javadoc>
    <text>Clears all bits of the receiver.</text>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Cloning this &lt;code&gt;BitMatrix&lt;/code&gt; produces a new &lt;code&gt;BitMatrix&lt;/code&gt; 
 * that is equal to it.
 * The clone of the bit matrix is another bit matrix that has exactly the 
 * same bits set to &lt;code&gt;true&lt;/code&gt; as this bit matrix and the same 
 * number of columns and rows.</text>
    <return>a clone of this bit matrix.</return>
  </javadoc>
  <method type="Object" name="clone">
    <declaration type="BitMatrix" name="clone" />
  </method>
  <javadoc>
    <text>Returns the number of columns of the receiver.</text>
  </javadoc>
  <method type="int" name="columns" />
  <javadoc>
    <text>Checks whether the receiver contains the given box.</text>
  </javadoc>
  <method type="void" name="containsBox" />
  <javadoc>
    <text>Returns a shallow clone of the receiver; calls &lt;code&gt;clone()&lt;/code&gt; and casts the result.</text>
    <return>a shallow clone of the receiver.</return>
  </javadoc>
  <method type="BitMatrix" name="copy" />
  <method type="long[]" name="elements" />
  <javadoc>
    <text>You normally need not use this method. Use this method only if performance is critical. 
 * Sets the bit matrix's backing bits, columns and rows.
 * &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
 * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.</text>
    <throws>IllegalArgumentException if &lt;tt&gt;columns &amp;lt; 0 || rows &amp;lt; 0 || columns*rows &amp;gt; bits.length*64&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="elements" />
  <javadoc>
    <text>Compares this object against the specified object.
 * The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is 
 * not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;BitMatrix&lt;/code&gt; object
 * that has the same number of columns and rows as the receiver and 
 * that has exactly the same bits set to &lt;code&gt;true&lt;/code&gt; as the receiver.</text>
    <param>obj   the object to compare with.</param>
    <return>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
 * &lt;code&gt;false&lt;/code&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="BitMatrix" name="other" />
  </method>
  <javadoc>
    <text>Applies a procedure to each coordinate that holds a bit in the given state.
 * Iterates rowwise downwards from [columns()-1,rows()-1] to [0,0].
 * Useful, for example, if you want to copy bits into an image or somewhere else.
 * Optimized for speed. Particularly quick if one of the following conditions holds
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;state==true&lt;/tt&gt; and the receiver is sparse (&lt;tt&gt;cardinality()&lt;/tt&gt; is small compared to &lt;tt&gt;size()&lt;/tt&gt;).
 * &lt;li&gt;&lt;tt&gt;state==false&lt;/tt&gt; and the receiver is dense (&lt;tt&gt;cardinality()&lt;/tt&gt; is large compared to &lt;tt&gt;size()&lt;/tt&gt;).
 * &lt;/ul&gt;</text>
    <param>state element to search for.</param>
    <param>procedure a procedure object taking as first argument the current column and as second argument the current row. Stops iteration if the procedure returns &lt;tt&gt;false&lt;/tt&gt;, otherwise continues.</param>
    <return>&lt;tt&gt;false&lt;/tt&gt; if the procedure stopped before all elements where iterated over, &lt;tt&gt;true&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="forEachCoordinateInState">
    <declaration type="BitVector" name="vector" />
    <declaration type="long[]" name="theBits" />
    <declaration type="int" name="column" />
    <declaration type="int" name="row" />
    <declaration type="long" name="val" />
    <scope>
      <declaration type="long" name="mask" />
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="bitsPerUnit" />
    <declaration type="long" name="comparator" />
    <scope>
      <scope>
        <scope>
          <scope>
            <scope />
            <scope />
          </scope>
        </scope>
        <scope>
          <scope>
            <scope />
            <scope />
          </scope>
        </scope>
      </scope>
      <scope>
        <scope>
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>this is equivalent to the low level version below, apart from that it iterates in the reverse oder and is slower.
if (size()==0) return true;
BitVector vector = toBitVector();
return vector.forEachIndexFromToInState(0,size()-1,state,
new cern.colt.function.IntFunction() {
public boolean apply(int index) {
return function.apply(index%columns, indexcolumns);
}
}
);</comment>
    <comment>low level implementation for speed.</comment>
    <comment>for each coordinate of bits of partial unit</comment>
    <comment>for each coordinate of bits of full units</comment>
    <comment>all 64 bits set</comment>
    <comment>at least one element within current unit matches.</comment>
    <comment>iterate over all bits within current unit.</comment>
    <comment>unrolled comparison for speed.</comment>
    <comment>no element within current unit matches --&gt; skip unit</comment>
    <comment>avoid implementation with *, /, %</comment>
  </method>
  <javadoc>
    <text>Returns from the receiver the value of the bit at the specified coordinate.
 * The value is &lt;tt&gt;true&lt;/tt&gt; if this bit is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <return>the value of the bit at the specified coordinate.</return>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;column&amp;lt;0 || column&amp;gt;=columns() || row&amp;lt;0 || row&amp;gt;=rows()&lt;/tt&gt;</throws>
  </javadoc>
  <method type="boolean" name="get" />
  <javadoc>
    <text>Returns from the receiver the value of the bit at the specified coordinate; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions.
 * The value is &lt;tt&gt;true&lt;/tt&gt; if this bit is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.
 * &lt;p&gt;Provided with invalid parameters this method may return invalid values without throwing any exception.
 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
 * Precondition (unchecked): &lt;tt&gt;column&amp;gt;=0 &amp;&amp; column&amp;lt;columns() &amp;&amp; row&amp;gt;=0 &amp;&amp; row&amp;lt;rows()&lt;/tt&gt;.</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <return>the value of the bit at the specified coordinate.</return>
  </javadoc>
  <method type="boolean" name="getQuick" />
  <javadoc>
    <text>Returns a hash code value for the receiver.</text>
  </javadoc>
  <method type="int" name="hashCode" />
  <javadoc>
    <text>Performs a logical &lt;b&gt;NOT&lt;/b&gt; on the bits of the receiver.</text>
  </javadoc>
  <method type="void" name="not" />
  <javadoc>
    <text>Performs a logical &lt;b&gt;OR&lt;/b&gt; of the receiver with another bit matrix.
 * The receiver is modified so that a bit in it has the
 * value &lt;code&gt;true&lt;/code&gt; if and only if it either already had the 
 * value &lt;code&gt;true&lt;/code&gt; or the corresponding bit in the other bit matrix
 * argument has the value &lt;code&gt;true&lt;/code&gt;.</text>
    <param>other   a bit matrix.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;columns() != other.columns() || rows() != other.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="or" />
  <javadoc>
    <text>Constructs and returns a new matrix with &lt;tt&gt;width&lt;/tt&gt; columns and &lt;tt&gt;height&lt;/tt&gt; rows which is a copy of the contents of the given box.
 * The box ranges from &lt;tt&gt;[column,row]&lt;/tt&gt; to &lt;tt&gt;[column+width-1,row+height-1]&lt;/tt&gt;, all inclusive.</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <param>width   the width of the box.</param>
    <param>height   the height of the box.</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;column&amp;lt;0 || column+width&amp;gt;columns() || row&amp;lt;0 || row+height&amp;gt;rows()&lt;/tt&gt;</throws>
  </javadoc>
  <method type="BitMatrix" name="part">
    <declaration type="BitMatrix" name="subMatrix" />
  </method>
  <javadoc>
    <text>Sets the bit at the specified coordinate to the state specified by &lt;tt&gt;value&lt;/tt&gt;.</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <param>value the value of the bit to be copied into the specified coordinate.</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;column&amp;lt;0 || column&amp;gt;=columns() || row&amp;lt;0 || row&amp;gt;=rows()&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="put" />
  <javadoc>
    <text>Sets the bit at the specified coordinate to the state specified by &lt;tt&gt;value&lt;/tt&gt;; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions.
 * &lt;p&gt;Provided with invalid parameters this method may return invalid values without throwing any exception.
 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
 * Precondition (unchecked): &lt;tt&gt;column&amp;gt;=0 &amp;&amp; column&amp;lt;columns() &amp;&amp; row&amp;gt;=0 &amp;&amp; row&amp;lt;rows()&lt;/tt&gt;.</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <param>value the value of the bit to be copied into the specified coordinate.</param>
  </javadoc>
  <method type="void" name="putQuick" />
  <javadoc>
    <text>Replaces a box of the receiver with the contents of another matrix's box.
 * The source box ranges from &lt;tt&gt;[sourceColumn,sourceRow]&lt;/tt&gt; to &lt;tt&gt;[sourceColumn+width-1,sourceRow+height-1]&lt;/tt&gt;, all inclusive.
 * The destination box ranges from &lt;tt&gt;[column,row]&lt;/tt&gt; to &lt;tt&gt;[column+width-1,row+height-1]&lt;/tt&gt;, all inclusive.
 * Does nothing if &lt;tt&gt;width &amp;lt;= 0 || height &amp;lt;= 0&lt;/tt&gt;.
 * If &lt;tt&gt;source==this&lt;/tt&gt; and the source and destination box intersect in an ambiguous way, then replaces as if using an intermediate auxiliary copy of the receiver.</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <param>width   the width of the box.</param>
    <param>height   the height of the box.</param>
    <param>source   the source matrix to copy from(may be identical to the receiver).</param>
    <param>sourceColumn   the index of the source column-coordinate.</param>
    <param>sourceRow   the index of the source row-coordinate.</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;column&amp;lt;0 || column+width&amp;gt;columns() || row&amp;lt;0 || row+height&amp;gt;rows()&lt;/tt&gt;</throws>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;sourceColumn&amp;lt;0 || sourceColumn+width&amp;gt;source.columns() || sourceRow&amp;lt;0 || sourceRow+height&amp;gt;source.rows()&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="replaceBoxWith">
    <scope>
      <declaration type="Rectangle" name="destRect" />
      <declaration type="Rectangle" name="sourceRect" />
      <scope />
    </scope>
    <declaration type="BitVector" name="sourceVector" />
    <declaration type="BitVector" name="destVector" />
    <declaration type="int" name="sourceColumns" />
    <scope>
      <declaration type="int" name="offset" />
      <declaration type="int" name="sourceOffset" />
    </scope>
    <comment>dangerous intersection</comment>
  </method>
  <javadoc>
    <text>Sets the bits in the given box to the state specified by &lt;tt&gt;value&lt;/tt&gt;.
 * The box ranges from &lt;tt&gt;[column,row]&lt;/tt&gt; to &lt;tt&gt;[column+width-1,row+height-1]&lt;/tt&gt;, all inclusive.
 * (Does nothing if &lt;tt&gt;width &amp;lt;= 0 || height &amp;lt;= 0&lt;/tt&gt;).</text>
    <param>column   the index of the column-coordinate.</param>
    <param>row   the index of the row-coordinate.</param>
    <param>width   the width of the box.</param>
    <param>height   the height of the box.</param>
    <param>value the value of the bit to be copied into the bits of the specified box.</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;column&amp;lt;0 || column+width&amp;gt;columns() || row&amp;lt;0 || row+height&amp;gt;rows()&lt;/tt&gt;</throws>
  </javadoc>
  <method type="void" name="replaceBoxWith">
    <declaration type="BitVector" name="destVector" />
    <scope>
      <declaration type="int" name="offset" />
    </scope>
  </method>
  <javadoc>
    <text>Returns the number of rows of the receiver.</text>
  </javadoc>
  <method type="int" name="rows" />
  <javadoc>
    <text>Returns the size of the receiver which is &lt;tt&gt;columns()*rows()&lt;/tt&gt;.</text>
  </javadoc>
  <method type="int" name="size" />
  <javadoc>
    <text>Converts the receiver to a bitvector. 
 * In many cases this method only makes sense on one-dimensional matrices.
 * &lt;b&gt;WARNING:&lt;/b&gt; The returned bitvector and the receiver share the &lt;b&gt;same&lt;/b&gt; backing bits.
 * Modifying either of them will affect the other.
 * If this behaviour is not what you want, you should first use &lt;tt&gt;copy()&lt;/tt&gt; to make sure both objects use separate internal storage.</text>
  </javadoc>
  <method type="BitVector" name="toBitVector" />
  <javadoc>
    <text>Returns a (very crude) string representation of the receiver.</text>
  </javadoc>
  <method type="String" name="toString" />
  <javadoc>
    <text>Performs a logical &lt;b&gt;XOR&lt;/b&gt; of the receiver with another bit matrix.
 * The receiver is modified so that a bit in it has the
 * value &lt;code&gt;true&lt;/code&gt; if and only if one of the following statements holds:
 * &lt;ul&gt;
 * &lt;li&gt;The bit initially has the value &lt;code&gt;true&lt;/code&gt;, and the 
 * corresponding bit in the argument has the value &lt;code&gt;false&lt;/code&gt;.
 * &lt;li&gt;The bit initially has the value &lt;code&gt;false&lt;/code&gt;, and the 
 * corresponding bit in the argument has the value &lt;code&gt;true&lt;/code&gt;. 
 * &lt;/ul&gt;</text>
    <param>other   a bit matrix.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;columns() != other.columns() || rows() != other.rows()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="xor" />
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>The bits of this matrix.
 bits are stored in row major, i.e.
 bitIndex==rowcolumns + column
 columnOf(bitIndex)==bitIndex%columns
 rowOf(bitIndex)==bitIndexcolumns</comment>
</class>
