<?xml version="1.0" encoding="UTF-8"?>
<class name="AbstractFloatList">
  <javadoc>
    <text>Abstract base class for resizable lists holding &lt;code&gt;float&lt;/code&gt; elements; abstract.
 * First see the &lt;a href="package-summary.html"&gt;package summary&lt;/a&gt; and javadoc &lt;a href="package-tree.html"&gt;tree view&lt;/a&gt; to get the broad picture.</text>
  </javadoc>
  <javadoc>
    <text>The size of the list.
 * This is a READ_ONLY variable for all methods but setSizeRaw(int newSize) !!!
 * If you violate this principle in subclasses, you should exactly know what you are doing.</text>
    <serial />
  </javadoc>
  <declaration type="int" name="size" />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="AbstractFloatList" />
  <javadoc>
    <text>Appends the specified element to the end of this list.</text>
    <param>element element to be appended to this list.</param>
  </javadoc>
  <method type="void" name="add" />
  <javadoc>
    <text>Appends the part of the specified list between &lt;code&gt;from&lt;/code&gt; (inclusive) and &lt;code&gt;to&lt;/code&gt; (inclusive) to the receiver.</text>
    <param>other the list to be added to the receiver.</param>
    <param>from the index of the first element to be appended (inclusive).</param>
    <param>to the index of the last element to be appended (inclusive).</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;other.size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=other.size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="addAllOfFromTo" />
  <javadoc>
    <text>Inserts the specified element before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.</text>
    <param>index index before which the specified element is to be inserted (must be in [0,size]).</param>
    <param>element element to be inserted.</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;index &amp;lt; 0 || index &amp;gt; size()&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="beforeInsert" />
  <javadoc>
    <text>Inserts the part of the specified list between &lt;code&gt;otherFrom&lt;/code&gt; (inclusive) and &lt;code&gt;otherTo&lt;/code&gt; (inclusive) before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.</text>
    <param>index index before which to insert first element from the specified list (must be in [0,size])..</param>
    <param>other list of which a part is to be inserted into the receiver.</param>
    <param>from the index of the first element to be inserted (inclusive).</param>
    <param>to the index of the last element to be inserted (inclusive).</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;other.size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=other.size())&lt;/tt&gt;).</exception>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;index &amp;lt; 0 || index &amp;gt; size()&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="beforeInsertAllOfFromTo">
    <declaration type="int" name="length" />
  </method>
  <javadoc>
    <text>Inserts &lt;tt&gt;length&lt;/tt&gt; dummy elements before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.
 * &lt;b&gt;This method must set the new size to be &lt;tt&gt;size()+length&lt;/tt&gt;.</text>
    <param>index index before which to insert dummy elements (must be in [0,size])..</param>
    <param>length number of dummy elements to be inserted.</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;index &amp;lt; 0 || index &amp;gt; size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="beforeInsertDummies">
    <scope />
  </method>
  <javadoc>
    <text>Searches the receiver for the specified value using
 * the binary search algorithm.  The receiver must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the receiver contains multiple elements
 * equal to the specified object, there is no guarantee which instance
 * will be found.</text>
    <param>key the value to be searched for.</param>
    <return>index of the search key, if it is contained in the receiver;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the receiver: the index of the first
 * element greater than the key, or &lt;tt&gt;receiver.size()&lt;/tt&gt;, if all
 * elements in the receiver are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearch" />
  <javadoc>
    <text>Searches the receiver for the specified value using
 * the binary search algorithm.  The receiver must &lt;strong&gt;must&lt;/strong&gt; be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the receiver contains multiple elements
 * equal to the specified object, there is no guarantee which instance
 * will be found.</text>
    <param>key the value to be searched for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>index of the search key, if it is contained in the receiver;
 * otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
 * point&lt;/i&gt; is defined as the the point at which the value would
 * be inserted into the receiver: the index of the first
 * element greater than the key, or &lt;tt&gt;receiver.size()&lt;/tt&gt;, if all
 * elements in the receiver are less than the specified key.  Note
 * that this guarantees that the return value will be &amp;gt;= 0 if
 * and only if the key is found.</return>
    <see>java.util.Arrays</see>
  </javadoc>
  <method type="int" name="binarySearchFromTo">
    <declaration type="int" name="low" />
    <declaration type="int" name="high" />
    <scope>
      <declaration type="int" name="mid" />
      <declaration type="float" name="midVal" />
    </scope>
    <comment>key found</comment>
    <comment>key not found.</comment>
  </method>
  <javadoc>
    <text>Returns a deep copy of the receiver.</text>
    <return>a deep copy of the receiver.</return>
  </javadoc>
  <method type="Object" name="clone" />
  <javadoc>
    <text>Returns true if the receiver contains the specified element.</text>
    <param>element element whose presence in the receiver is to be tested.</param>
  </javadoc>
  <method type="boolean" name="contains" />
  <javadoc>
    <text>Deletes the first element from the receiver that is identical to the specified element.
 * Does nothing, if no such matching element is contained.</text>
    <param>element the element to be deleted.</param>
  </javadoc>
  <method type="void" name="delete">
    <declaration type="int" name="index" />
  </method>
  <javadoc>
    <text>Returns the elements currently stored, possibly including invalid elements between size and capacity.
 * &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, this method may decide &lt;b&gt;not to copy the array&lt;/b&gt;.
 * So if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.</text>
    <return>the elements currently stored.</return>
  </javadoc>
  <method type="float[]" name="elements">
    <declaration type="float[]" name="myElements" />
  </method>
  <javadoc>
    <text>Sets the receiver's elements to be the specified array.
 * The size and capacity of the list is the length of the array.
 * &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, this method may decide &lt;b&gt;not to copy the array&lt;/b&gt;.
 * So if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.</text>
    <param>elements the new elements to be stored.</param>
    <return>the receiver itself.</return>
  </javadoc>
  <method type="AbstractFloatList" name="elements" />
  <method name="ensureCapacity" type="void" />
  <javadoc>
    <text>Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.</text>
    <param>minCapacity   the desired minimum capacity.</param>
  </javadoc>
  <javadoc>
    <text>Compares the specified Object with the receiver.  
 * Returns true if and only if the specified Object is also an ArrayList of the same type, both Lists have the
 * same size, and all corresponding pairs of elements in the two Lists are identical.
 * In other words, two Lists are defined to be equal if they contain the
 * same elements in the same order.</text>
    <param>otherObj the Object to be compared for equality with the receiver.</param>
    <return>true if the specified Object is equal to the receiver.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <declaration type="AbstractFloatList" name="other" />
    <scope />
    <comment>delta</comment>
  </method>
  <javadoc>
    <text>Sets the specified range of elements in the specified array to the specified value.</text>
    <param>from the index of the first element (inclusive) to be filled with the specified value.</param>
    <param>to the index of the last element (inclusive) to be filled with the specified value.</param>
    <param>val the value to be stored in the specified elements of the receiver.</param>
  </javadoc>
  <method type="void" name="fillFromToWith" />
  <javadoc>
    <text>Applies a procedure to each element of the receiver, if any.
 * Starts at index 0, moving rightwards.</text>
    <param>procedure    the procedure to be applied. Stops iteration if the procedure returns &lt;tt&gt;false&lt;/tt&gt;, otherwise continues.</param>
    <return>&lt;tt&gt;false&lt;/tt&gt; if the procedure stopped before all elements where iterated over, &lt;tt&gt;true&lt;/tt&gt; otherwise.</return>
  </javadoc>
  <method type="boolean" name="forEach" />
  <javadoc>
    <text>Returns the element at the specified position in the receiver.</text>
    <param>index index of element to return.</param>
    <exception>IndexOutOfBoundsException index is out of range (index
 * &amp;lt; 0 || index &amp;gt;= size()).</exception>
  </javadoc>
  <method type="float" name="get" />
  <method name="getQuick" type="float" />
  <javadoc>
    <text>Returns the element at the specified position in the receiver; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions. 
 * Provided with invalid parameters this method may return invalid elements without throwing any exception!
 * &lt;b&gt;You should only use this method when you are absolutely sure that the index is within bounds.&lt;/b&gt;
 * Precondition (unchecked): &lt;tt&gt;index &amp;gt;= 0 &amp;&amp; index &amp;lt; size()&lt;/tt&gt;.
 * This method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop.
 * However, when desperately, you can give this method &lt;tt&gt;public&lt;/tt&gt; visibility in subclasses.</text>
    <param>index index of element to return.</param>
  </javadoc>
  <javadoc>
    <text>Returns the index of the first occurrence of the specified
 * element. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this element.</text>
    <param>element   the element to be searched for.</param>
    <return>the index of the first occurrence of the element in the receiver; returns &lt;code&gt;-1&lt;/code&gt; if the element is not found.</return>
  </javadoc>
  <method type="int" name="indexOf">
    <comment>delta</comment>
  </method>
  <javadoc>
    <text>Returns the index of the first occurrence of the specified
 * element. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this element.
 * Searches between &lt;code&gt;from&lt;/code&gt;, inclusive and &lt;code&gt;to&lt;/code&gt;, inclusive.
 * Tests for identity.</text>
    <param>element element to search for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>the index of the first occurrence of the element in the receiver; returns &lt;code&gt;-1&lt;/code&gt; if the element is not found.</return>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="int" name="indexOfFromTo">
    <scope />
    <comment>found</comment>
    <comment>not found</comment>
  </method>
  <javadoc>
    <text>Returns the index of the last occurrence of the specified
 * element. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this element.</text>
    <param>element   the element to be searched for.</param>
    <return>the index of the last occurrence of the element in the receiver; returns &lt;code&gt;-1&lt;/code&gt; if the element is not found.</return>
  </javadoc>
  <method type="int" name="lastIndexOf" />
  <javadoc>
    <text>Returns the index of the last occurrence of the specified
 * element. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this element.
 * Searches beginning at &lt;code&gt;to&lt;/code&gt;, inclusive until &lt;code&gt;from&lt;/code&gt;, inclusive.
 * Tests for identity.</text>
    <param>element element to search for.</param>
    <param>from the leftmost search position, inclusive.</param>
    <param>to the rightmost search position, inclusive.</param>
    <return>the index of the last occurrence of the element in the receiver; returns &lt;code&gt;-1&lt;/code&gt; if the element is not found.</return>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="int" name="lastIndexOfFromTo">
    <scope />
    <comment>found</comment>
    <comment>not found</comment>
  </method>
  <javadoc>
    <text>Sorts the specified range of the receiver into ascending order. 
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.
 * &lt;p&gt;&lt;b&gt;You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.&lt;/b&gt;
 * It is generally better to call &lt;tt&gt;sort()&lt;/tt&gt; or &lt;tt&gt;sortFromTo(...)&lt;/tt&gt; instead, because those methods automatically choose the best sorting algorithm.</text>
    <param>from the index of the first element (inclusive) to be sorted.</param>
    <param>to the index of the last element (inclusive) to be sorted.</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="mergeSortFromTo">
    <declaration type="int" name="mySize" />
    <declaration type="float[]" name="myElements" />
  </method>
  <javadoc>
    <text>Sorts the receiver according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 * not be reordered as a result of the sort.&lt;p&gt;
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
    <param>from the index of the first element (inclusive) to be
 * sorted.</param>
    <param>to the index of the last element (inclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the receiver.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="mergeSortFromTo">
    <declaration type="int" name="mySize" />
    <declaration type="float[]" name="myElements" />
  </method>
  <javadoc>
    <text>Returns a new list of the part of the receiver between &lt;code&gt;from&lt;/code&gt;, inclusive, and &lt;code&gt;to&lt;/code&gt;, inclusive.</text>
    <param>from the index of the first element (inclusive).</param>
    <param>to the index of the last element (inclusive).</param>
    <return>a new list</return>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="AbstractFloatList" name="partFromTo">
    <declaration type="int" name="length" />
    <declaration type="FloatArrayList" name="part" />
  </method>
  <javadoc>
    <text>Sorts the specified range of the receiver into
 * ascending numerical order.  The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.
 * &lt;p&gt;&lt;b&gt;You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.&lt;/b&gt;
 * It is generally better to call &lt;tt&gt;sort()&lt;/tt&gt; or &lt;tt&gt;sortFromTo(...)&lt;/tt&gt; instead, because those methods automatically choose the best sorting algorithm.</text>
    <param>from the index of the first element (inclusive) to be sorted.</param>
    <param>to the index of the last element (inclusive) to be sorted.</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="quickSortFromTo">
    <declaration type="int" name="mySize" />
    <declaration type="float[]" name="myElements" />
  </method>
  <javadoc>
    <text>Sorts the receiver according
 * to the order induced by the specified comparator.  All elements in the
 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
    <param>from the index of the first element (inclusive) to be
 * sorted.</param>
    <param>to the index of the last element (inclusive) to be sorted.</param>
    <param>c the comparator to determine the order of the receiver.</param>
    <throws>ClassCastException if the array contains elements that are not
 * &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.</throws>
    <throws>IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;</throws>
    <throws>ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
 * &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;</throws>
    <see>Comparator</see>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="quickSortFromTo">
    <declaration type="int" name="mySize" />
    <declaration type="float[]" name="myElements" />
  </method>
  <javadoc>
    <text>Removes from the receiver all elements that are contained in the specified list.
 * Tests for identity.</text>
    <param>other the other list.</param>
    <return>&lt;code&gt;true&lt;/code&gt; if the receiver changed as a result of the call.</return>
  </javadoc>
  <method type="boolean" name="removeAll">
    <declaration type="int" name="limit" />
    <declaration type="int" name="j" />
    <scope />
    <declaration type="boolean" name="modified" />
    <comment>nothing to do</comment>
  </method>
  <javadoc>
    <text>Removes from the receiver all elements whose index is between
 * &lt;code&gt;from&lt;/code&gt;, inclusive and &lt;code&gt;to&lt;/code&gt;, inclusive.  Shifts any succeeding
 * elements to the left (reduces their index).
 * This call shortens the list by &lt;tt&gt;(to - from + 1)&lt;/tt&gt; elements.</text>
    <param>from index of first element to be removed.</param>
    <param>to index of last element to be removed.</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="removeFromTo">
    <declaration type="int" name="numMoved" />
    <scope />
    <declaration type="int" name="width" />
    <comment>fillFromToWith(from+numMoved, size-1, 0.0f); delta</comment>
  </method>
  <javadoc>
    <text>Replaces a number of elements in the receiver with the same number of elements of another list.
 * Replaces elements in the receiver, between &lt;code&gt;from&lt;/code&gt; (inclusive) and &lt;code&gt;to&lt;/code&gt; (inclusive),
 * with elements of &lt;code&gt;other&lt;/code&gt;, starting from &lt;code&gt;otherFrom&lt;/code&gt; (inclusive).</text>
    <param>from the position of the first element to be replaced in the receiver</param>
    <param>to the position of the last element to be replaced in the receiver</param>
    <param>other list holding elements to be copied into the receiver.</param>
    <param>otherFrom position of first element within other list to be copied.</param>
  </javadoc>
  <method type="void" name="replaceFromToWithFrom">
    <declaration type="int" name="length" />
    <scope>
      <scope />
      <scope>
        <declaration type="int" name="otherTo" />
      </scope>
    </scope>
    <comment>unambiguous copy (it may hold other==this)</comment>
  </method>
  <javadoc>
    <text>Replaces the part between &lt;code&gt;from&lt;/code&gt; (inclusive) and &lt;code&gt;to&lt;/code&gt; (inclusive) with the other list's
 * part between &lt;code&gt;otherFrom&lt;/code&gt; and &lt;code&gt;otherTo&lt;/code&gt;. 
 * Powerful (and tricky) method!
 * Both parts need not be of the same size (part A can both be smaller or larger than part B).
 * Parts may overlap.
 * Receiver and other list may (but most not) be identical.
 * If &lt;code&gt;from &amp;gt; to&lt;/code&gt;, then inserts other part before &lt;code&gt;from&lt;/code&gt;.</text>
    <param>from the first element of the receiver (inclusive)</param>
    <param>to the last element of the receiver (inclusive)</param>
    <param>other the other list (may be identical with receiver)</param>
    <param>otherFrom the first element of the other list (inclusive)</param>
    <param>otherTo the last element of the other list (inclusive)
 * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;pre&gt;
 * a=[0, 1, 2, 3, 4, 5, 6, 7]
 * b=[50, 60, 70, 80, 90]
 * a.R(...)=a.replaceFromToWithFromTo(...)
 * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
 * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
 * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
 * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
 * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
 * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
 * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
 * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
 * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
 * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
 * Extreme cases:
 * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
 * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
 * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
 * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
 * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
 * &lt;/pre&gt;</param>
  </javadoc>
  <method type="void" name="replaceFromToWithFromTo">
    <scope />
    <scope />
    <declaration type="int" name="length" />
    <declaration type="int" name="diff" />
    <declaration type="int" name="theLast" />
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>avoid stumbling over my own feet</comment>
  </method>
  <javadoc>
    <text>Replaces the part of the receiver starting at &lt;code&gt;from&lt;/code&gt; (inclusive) with all the elements of the specified collection.
 * Does not alter the size of the receiver.
 * Replaces exactly &lt;tt&gt;Math.max(0,Math.min(size()-from, other.size()))&lt;/tt&gt; elements.</text>
    <param>from the index at which to copy the first element from the specified collection.</param>
    <param>other Collection to replace part of the receiver</param>
    <exception>IndexOutOfBoundsException index is out of range (index &amp;lt; 0 || index &amp;gt;= size()).</exception>
  </javadoc>
  <method type="void" name="replaceFromWith">
    <declaration type="java.util.Iterator" name="e" />
    <declaration type="int" name="index" />
    <declaration type="int" name="limit" />
    <comment>delta</comment>
  </method>
  <javadoc>
    <text>Retains (keeps) only the elements in the receiver that are contained in the specified other list.
 * In other words, removes from the receiver all of its elements that are not contained in the
 * specified other list.</text>
    <param>other the other list to test against.</param>
    <return>&lt;code&gt;true&lt;/code&gt; if the receiver changed as a result of the call.</return>
  </javadoc>
  <method type="boolean" name="retainAll">
    <scope />
    <declaration type="int" name="limit" />
    <declaration type="int" name="j" />
    <scope />
    <declaration type="boolean" name="modified" />
  </method>
  <javadoc>
    <text>Reverses the elements of the receiver.
 * Last becomes first, second last becomes second first, and so on.</text>
  </javadoc>
  <method type="void" name="reverse">
    <declaration type="float" name="tmp" />
    <declaration type="int" name="limit" />
    <declaration type="int" name="j" />
    <scope />
    <comment>swap</comment>
  </method>
  <javadoc>
    <text>Replaces the element at the specified position in the receiver with the specified element.</text>
    <param>index index of element to replace.</param>
    <param>element element to be stored at the specified position.</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="set" />
  <method name="setQuick" type="void" />
  <javadoc>
    <text>Replaces the element at the specified position in the receiver with the specified element; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions.
 * Provided with invalid parameters this method may access invalid indexes without throwing any exception!
 * &lt;b&gt;You should only use this method when you are absolutely sure that the index is within bounds.&lt;/b&gt;
 * Precondition (unchecked): &lt;tt&gt;index &amp;gt;= 0 &amp;&amp; index &amp;lt; size()&lt;/tt&gt;.
 * This method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop.
 * However, when desperately, you can give this method &lt;tt&gt;public&lt;/tt&gt; visibility in subclasses.</text>
    <param>index index of element to replace.</param>
    <param>element element to be stored at the specified position.</param>
  </javadoc>
  <javadoc>
    <text>Sets the size of the receiver without modifying it otherwise.
 * This method should not release or allocate new memory but simply set some instance variable like &lt;tt&gt;size&lt;/tt&gt;.
 * If your subclass overrides and delegates size changing methods to some other object,
 * you must make sure that those overriding methods not only update the size of the delegate but also of this class.
 * For example:
 * public DatabaseList extends AbstractFloatList {
 * ...
 * public void removeFromTo(int from,int to) {
 * myDatabase.removeFromTo(from,to);
 * this.setSizeRaw(size-(to-from+1));
 * }
 * }</text>
  </javadoc>
  <method type="void" name="setSizeRaw" />
  <javadoc>
    <text>Randomly permutes the part of the receiver between &lt;code&gt;from&lt;/code&gt; (inclusive) and &lt;code&gt;to&lt;/code&gt; (inclusive).</text>
    <param>from the index of the first element (inclusive) to be permuted.</param>
    <param>to the index of the last element (inclusive) to be permuted.</param>
    <exception>IndexOutOfBoundsException index is out of range (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).</exception>
  </javadoc>
  <method type="void" name="shuffleFromTo">
    <declaration type="cern.jet.random.Uniform" name="gen" />
    <scope>
      <declaration type="int" name="random" />
      <declaration type="float" name="tmpElement" />
    </scope>
    <comment>swap(i, random)</comment>
  </method>
  <javadoc>
    <text>Returns the number of elements contained in the receiver.</text>
    <returns>the number of elements contained in the receiver.</returns>
  </javadoc>
  <method type="int" name="size" />
  <javadoc>
    <text>Returns a list which is a concatenation of &lt;code&gt;times&lt;/code&gt; times the receiver.</text>
    <param>times the number of times the receiver shall be copied.</param>
  </javadoc>
  <method type="AbstractFloatList" name="times">
    <declaration type="AbstractFloatList" name="newList" />
    <scope />
  </method>
  <javadoc>
    <text>Returns a &lt;code&gt;java.util.ArrayList&lt;/code&gt; containing all the elements in the receiver.</text>
  </javadoc>
  <method type="java.util.ArrayList" name="toList">
    <declaration type="int" name="mySize" />
    <declaration type="java.util.ArrayList" name="list" />
  </method>
  <javadoc>
    <text>Returns a string representation of the receiver, containing
 * the String representation of each element.</text>
  </javadoc>
  <method type="String" name="toString" />
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
