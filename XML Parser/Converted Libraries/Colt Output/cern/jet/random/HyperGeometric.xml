<?xml version="1.0" encoding="UTF-8"?>
<class name="HyperGeometric">
  <javadoc>
    <text>HyperGeometric distribution; See the &lt;A HREF="http://library.advanced.org/10030/6atpdvah.htm"&gt; math definition&lt;/A&gt;
 * The hypergeometric distribution with parameters &lt;tt&gt;N&lt;/tt&gt;, &lt;tt&gt;n&lt;/tt&gt; and &lt;tt&gt;s&lt;/tt&gt; is the probability distribution of the random variable X, 
 * whose value is the number of successes in a sample of &lt;tt&gt;n&lt;/tt&gt; items from a population of size &lt;tt&gt;N&lt;/tt&gt; that has &lt;tt&gt;s&lt;/tt&gt; 'success' items and &lt;tt&gt;N - s&lt;/tt&gt; 'failure' items.
 * &lt;p&gt;            
 * &lt;tt&gt;p(k) = C(s,k) * C(N-s,n-k) / C(N,n)&lt;/tt&gt; where &lt;tt&gt;C(a,b) = a! / (b! * (a-b)!)&lt;/tt&gt;.
 * &lt;p&gt;
 * valid for N &gt;= 2, s,n &lt;= N. 
 * &lt;p&gt;
 * Instance methods operate on a user supplied uniform random number generator; they are unsynchronized.
 * &lt;dt&gt;
 * Static methods operate on a default uniform random number generator; they are synchronized.
 * &lt;p&gt;
 * &lt;b&gt;Implementation:&lt;/b&gt; High performance implementation.
 * Patchwork Rejection/Inversion method.
 * &lt;dt&gt;This is a port of &lt;tt&gt;hprsc.c&lt;/tt&gt; from the &lt;A HREF="http://www.cis.tu-graz.ac.at/stat/stadl/random.html"&gt;C-RAND / WIN-RAND&lt;/A&gt; library.
 * C-RAND's implementation, in turn, is based upon
 * &lt;p&gt;
 * H. Zechner (1994): Efficient sampling from continuous and discrete unimodal distributions,
 * Doctoral Dissertation, 156 pp., Technical University Graz, Austria.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <declaration type="int" name="my_N" />
  <declaration type="int" name="my_s" />
  <declaration type="int" name="my_n" />
  <declaration type="int" name="N_last" />
  <declaration type="int" name="N_Mn" />
  <declaration type="int" name="mp" />
  <declaration type="double" name="Mp" />
  <declaration type="int" name="k2" />
  <declaration type="double" name="dl" />
  <declaration type="HyperGeometric" name="shared" />
  <javadoc>
    <text>Constructs a HyperGeometric distribution.</text>
  </javadoc>
  <method type="constructor" name="HyperGeometric" />
  <method type="double" name="fc_lnpk" />
  <javadoc>
    <text>Returns a random number from the distribution.</text>
  </javadoc>
  <method type="int" name="hmdu">
    <declaration type="int" name="I" />
    <declaration type="double" name="p" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>set-up           */</comment>
    <comment>nu = np  p;                              mode, real</comment>
    <comment>if ((m = (int) nu) == nu &amp;&amp; p == 0.5) {      mode, integer</comment>
    <comment>mp = m + 1;                            mp = m + 1</comment>
    <comment>mode probability, using the external function flogfak(k) = ln(k!)</comment>
    <comment>safety bound  -  guarantees at least 17 significant decimal digits</comment>
    <comment>b = min(n, (long int)(nu + kc'))</comment>
    <comment>down- and upward search from the mode</comment>
    <comment>K  = mp - I;                                    downward search</comment>
    <comment>K  = m + I;                                     upward search</comment>
    <comment>upward search from K = 2m + 1 to K = b</comment>
  </method>
  <javadoc>
    <text>Returns a random number from the distribution.</text>
  </javadoc>
  <method type="int" name="hprs">
    <declaration type="int" name="Dk" />
    <declaration type="double" name="Mp" />
    <scope />
    <scope>
      <scope>
        <scope />
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope />
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>double Mp, np, p, nu, U, Y, W;        (X, Y) &lt;-&gt; (V, W)</comment>
    <comment>if (N != N_last || M != M_last || n != n_last) {   set-up</comment>
    <comment>main parameters</comment>
    <comment>approximate deviation of reflection points k2, k4 from nu - 1/2</comment>
    <comment>mode m, reflection points k2 and k4, and points k1 and k5, which</comment>
    <comment>delimit the centre region of h(x)</comment>
    <comment>k2 = ceil (nu - 1/2 - U),    k1 = 2*k2 - (m - 1 + delta_ml)</comment>
    <comment>k4 = floor(nu - 1/2 + U),    k5 = 2*k4 - (m + 1 - delta_mr)</comment>
    <comment>delta_ml = 0</comment>
    <comment>delta_mr = 1</comment>
    <comment>range width of the critical left and right centre region</comment>
    <comment>recurrence constants r(k) = p(k)/p(k-1) at k = k1, k2, k4+1, k5+1</comment>
    <comment>reciprocal values of the scale parameters of expon. tail envelopes</comment>
    <comment>expon. tail left</comment>
    <comment>expon. tail right</comment>
    <comment>hypergeom. constant, necessary for computing function values f(k)</comment>
    <comment>function values f(k) = p(k)/p(m)  at  k = k2, k4, k1, k5</comment>
    <comment>area of the two centre and the two exponential tail regions</comment>
    <comment>area of the two immediate acceptance regions between k2, k4</comment>
    <comment>immed. left</comment>
    <comment>centre left</comment>
    <comment>immed. right</comment>
    <comment>centre right</comment>
    <comment>expon. tail left</comment>
    <comment>expon. tail right</comment>
    <comment>generate uniform number U -- U(0, p6)</comment>
    <comment>case distinction corresponding to U</comment>
    <comment>centre left</comment>
    <comment>immediate acceptance region R2 = [k2, m) *[0, f2),  X = k2, ... m -1</comment>
    <comment>immediate acceptance region R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1</comment>
    <comment>computation of candidate X &lt; k2, and its counterpart V &gt; k2</comment>
    <comment>either squeeze-acceptance of X or acceptance-rejection of V</comment>
    <comment>quick accept of</comment>
    <comment>X = k2 - Dk</comment>
    <comment>quick reject of V</comment>
    <comment>quick accept of</comment>
    <comment>V = k2 + Dk</comment>
    <comment>final accept of V</comment>
    <comment>centre right</comment>
    <comment>immediate acceptance region R3 = [m, k4+1)*[0, f4), X = m, ... k4</comment>
    <comment>immediate acceptance region R4 = [k4+1, k5+1)*[0, f5)</comment>
    <comment>computation of candidate X &gt; k4, and its counterpart V &lt; k4</comment>
    <comment>either squeeze-acceptance of X or acceptance-rejection of V</comment>
    <comment>quick accept of</comment>
    <comment>X = k4 + Dk</comment>
    <comment>quick reject of V</comment>
    <comment>quick accept of</comment>
    <comment>V = k4 - Dk</comment>
    <comment>final accept of V</comment>
    <comment>expon. tail left</comment>
    <comment>0 &lt;= X &lt;= k1 - 1</comment>
    <comment>Y -- U(0, h(x))</comment>
    <comment>quick accept of X</comment>
    <comment>expon. tail right</comment>
    <comment>k5 + 1 &lt;= X &lt;= n</comment>
    <comment>Y -- U(0, h(x))   /</comment>
    <comment>quick accept of X</comment>
    <comment>acceptance-rejection test of candidate X from the original area</comment>
    <comment>test, whether  Y &lt;= f(X),    with  Y = U*h(x)  and  U -- U(0, 1)</comment>
    <comment>log f(X) = log( m! (M - m)! (n - m)! (N - M - n + m)! )</comment>
    <comment>- log( X! (M - X)! (n - X)! (N - M - n + X)! )</comment>
    <comment>by using an external function for log k!</comment>
  </method>
  <javadoc>
    <text>Returns a random number from the distribution.</text>
  </javadoc>
  <method type="int" name="nextInt" />
  <javadoc>
    <text>Returns a random number from the distribution; bypasses the internal state.</text>
  </javadoc>
  <method type="int" name="nextInt" />
  <javadoc>
    <text>Returns a random number from the distribution; bypasses the internal state.</text>
  </javadoc>
  <method type="int" name="nextInt">
    <declaration type="int" name="Nhalf" />
    <scope />
    <scope />
    <scope />
    <scope />
    <javadoc>
      <text>*
 * Hypergeometric Distribution - Patchwork Rejection/Inversion    
 * *
 * *
 * The basic algorithms work for parameters 1 &lt;= n &lt;= M &lt;= N/2.   
 * Otherwise parameters are re-defined in the set-up step and the 
 * random number K is adapted before delivering.                  
 * For l = m-max(0,n-N+M) &lt; 10  Inversion method hmdu is applied: 
 * The random numbers are generated via modal down-up search,     
 * starting at the mode m. The cumulative probabilities           
 * are avoided by using the technique of chop-down.               
 * For l &gt;= 10  the Patchwork Rejection method  hprs is employed: 
 * The area below the histogram function f(x) in its              
 * body is rearranged by certain point reflections. Within a      
 * large center interval variates are sampled efficiently by      
 * rejection from uniform hats. Rectangular immediate acceptance  
 * regions speed up the generation. The remaining tails are       
 * covered by exponential functions.                              
 * *
 * *
 * FUNCTION :   - hprsc samples a random number from the          
 * Hypergeometric distribution with parameters     
 * N (number of red and black balls), M (number    
 * of red balls) and n (number of trials)          
 * valid for N &gt;= 2, M,n &lt;= N.                     
 * REFERENCE :  - H. Zechner (1994): Efficient sampling from      
 * continuous and discrete unimodal distributions, 
 * Doctoral Dissertation, 156 pp., Technical       
 * University Graz, Austria.                       
 * SUBPROGRAMS: - flogfak(k)  ... log(k!) with long integer k     
 * - drand(seed) ... (0,1)-Uniform generator with    
 * unsigned long integer *seed.                    
 * - hmdu(seed,N,M,n) ... Hypergeometric generator   
 * for l&lt;10                                        
 * - hprs(seed,N,M,n) ... Hypergeometric generator   
 * for l&gt;=10 with unsigned long integer *seed,     
 * long integer  N , M , n.                        
 * *</text>
    </javadoc>
  </method>
  <javadoc>
    <text>Returns the probability distribution function.</text>
  </javadoc>
  <method type="double" name="pdf" />
  <javadoc>
    <text>Sets the parameters.</text>
  </javadoc>
  <method type="void" name="setState" />
  <javadoc>
    <text>Returns a random number from the distribution.</text>
  </javadoc>
  <method type="double" name="staticNextInt">
    <scope />
  </method>
  <javadoc>
    <text>Returns a String representation of the receiver.</text>
  </javadoc>
  <method type="String" name="toString" />
  <javadoc>
    <text>Sets the uniform random number generated shared by all &lt;b&gt;static&lt;/b&gt; methods.</text>
    <param>randomGenerator the new uniform random number generator to be shared.</param>
  </javadoc>
  <method type="void" name="xstaticSetRandomGenerator">
    <scope />
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>cached vars shared by hmdu(...) and hprs(...)</comment>
  <comment>cached vars for hmdu(...)</comment>
  <comment>cached vars for hprs(...)</comment>
  <comment>The uniform random number generated shared by all &lt;b&gt;static&lt;/b&gt; methods.</comment>
</class>
