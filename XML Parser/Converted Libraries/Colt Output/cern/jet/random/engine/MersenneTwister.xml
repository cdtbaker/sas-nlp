<?xml version="1.0" encoding="UTF-8"?>
<class name="MersenneTwister">
  <javadoc>
    <text>MersenneTwister (MT19937) is one of the strongest uniform pseudo-random number generators known so far; at the same time it is quick.
 * Produces uniformly distributed &lt;tt&gt;int&lt;/tt&gt;'s and &lt;tt&gt;long&lt;/tt&gt;'s in the closed intervals &lt;tt&gt;[Integer.MIN_VALUE,Integer.MAX_VALUE]&lt;/tt&gt; and &lt;tt&gt;[Long.MIN_VALUE,Long.MAX_VALUE]&lt;/tt&gt;, respectively, 
 * as well as &lt;tt&gt;float&lt;/tt&gt;'s and &lt;tt&gt;double&lt;/tt&gt;'s in the open unit intervals &lt;tt&gt;(0.0f,1.0f)&lt;/tt&gt; and &lt;tt&gt;(0.0,1.0)&lt;/tt&gt;, respectively.
 * The seed can be any 32-bit integer except &lt;tt&gt;0&lt;/tt&gt;. Shawn J. Cokus commented that perhaps the seed should preferably be odd.
 * &lt;p&gt;
 * &lt;b&gt;Quality:&lt;/b&gt; MersenneTwister is designed to pass the k-distribution test. It has an astronomically large period of 2&lt;sup&gt;19937&lt;/sup&gt;-1 (=10&lt;sup&gt;6001&lt;/sup&gt;) and 623-dimensional equidistribution up to 32-bit accuracy.
 * It passes many stringent statistical tests, including the &lt;A HREF="http://stat.fsu.edu/~geo/diehard.html"&gt;diehard&lt;/A&gt; test of G. Marsaglia and the load test of P. Hellekalek and S. Wegenkittl.
 * &lt;p&gt;
 * &lt;b&gt;Performance:&lt;/b&gt; Its speed is comparable to other modern generators (in particular, as fast as &lt;tt&gt;java.util.Random.nextFloat()&lt;/tt&gt;).
 * 2.5 million calls to &lt;tt&gt;raw()&lt;/tt&gt; per second (Pentium Pro 200 Mhz, JDK 1.2, NT).
 * Be aware, however, that there is a non-negligible amount of overhead required to initialize the data
 * structures used by a MersenneTwister. Code like
 * &lt;pre&gt;
 * double sum = 0.0;
 * for (int i=0; i&lt;100000; ++i) {
 * RandomElement twister = new MersenneTwister(new java.util.Date());
 * sum += twister.raw();
 * }
 * &lt;/pre&gt;
 * will be wildly inefficient. Consider using
 * &lt;pre&gt;
 * double sum = 0.0;
 * RandomElement twister = new MersenneTwister(new java.util.Date());
 * for (int i=0; i&lt;100000; ++i) {
 * sum += twister.raw();
 * }
 * &lt;/pre&gt;
 * instead.  This allows the cost of constructing the MersenneTwister object
 * to be borne only once, rather than once for each iteration in the loop.
 * &lt;p&gt;
 * &lt;b&gt;Implementation:&lt;/b&gt; After M. Matsumoto and T. Nishimura,                                  
 * "Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator",                                
 * ACM Transactions on Modeling and Computer Simulation,           
 * Vol. 8, No. 1, January 1998, pp 3--30.
 * &lt;dt&gt;More info on &lt;A HREF="http://www.math.keio.ac.jp/~matumoto/eindex.html"&gt; Masumoto's homepage&lt;/A&gt;.
 * &lt;dt&gt;More info on &lt;A HREF="http://www.ncsa.uiuc.edu/Apps/CMP/RNG/www-rng.html"&gt; Pseudo-random number generators is on the Web&lt;/A&gt;.
 * &lt;dt&gt;Yet &lt;A HREF="http://nhse.npac.syr.edu/random"&gt; some more info&lt;/A&gt;.
 * &lt;p&gt;
 * The correctness of this implementation has been verified against the published output sequence 
 * &lt;a href="http://www.math.keio.ac.jp/~nisimura/random/real2/mt19937-2.out"&gt;mt19937-2.out&lt;/a&gt; of the C-implementation
 * &lt;a href="http://www.math.keio.ac.jp/~nisimura/random/real2/mt19937-2.c"&gt;mt19937-2.c&lt;/a&gt;.
 * (Call &lt;tt&gt;test(1000)&lt;/tt&gt; to print the sequence).
 * &lt;dt&gt;
 * Note that this implementation is &lt;b&gt;not synchronized&lt;/b&gt;.                                  
 * &lt;p&gt;
 * &lt;b&gt;Details:&lt;/b&gt; MersenneTwister is designed with consideration of the flaws of various existing generators in mind.
 * It is an improved version of TT800, a very successful generator.
 * MersenneTwister is based on linear recurrences modulo 2.
 * Such generators are very fast, have extremely long periods, and appear quite robust. 
 * MersenneTwister produces 32-bit numbers, and every &lt;tt&gt;k&lt;/tt&gt;-dimensional vector of such numbers appears the same number of times as &lt;tt&gt;k&lt;/tt&gt; successive values over the
 * period length, for each &lt;tt&gt;k &amp;lt;= 623&lt;/tt&gt; (except for the zero vector, which appears one time less).
 * If one looks at only the first &lt;tt&gt;n &amp;lt;= 16&lt;/tt&gt; bits of each number, then the property holds for even larger &lt;tt&gt;k&lt;/tt&gt;, as shown in the following table (taken from the publication cited above):
 * &lt;div align="center"&gt;
 * &lt;table width="75%" border="1" cellspacing="0" cellpadding="0"&gt;
 * &lt;tr&gt; 
 * &lt;td width="2%"&gt; &lt;div align="center"&gt;n&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="6%"&gt; &lt;div align="center"&gt;1&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;2&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;3&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;4&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;5&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;6&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;7&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;8&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;9&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;10&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;11&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="10%"&gt; &lt;div align="center"&gt;12 .. 16&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="10%"&gt; &lt;div align="center"&gt;17 .. 32&lt;/div&gt; &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt; 
 * &lt;td width="2%"&gt; &lt;div align="center"&gt;k&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="6%"&gt; &lt;div align="center"&gt;19937&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;9968&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;6240&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;4984&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;3738&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;3115&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;2493&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;2492&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;1869&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;1869&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="5%"&gt; &lt;div align="center"&gt;1248&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="10%"&gt; &lt;div align="center"&gt;1246&lt;/div&gt; &lt;/td&gt;
 * &lt;td width="10%"&gt; &lt;div align="center"&gt;623&lt;/div&gt; &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/div&gt;
 * &lt;p&gt;
 * MersenneTwister generates random numbers in batches of 624 numbers at a time, so the caching and pipelining of modern systems is exploited.
 * The generator is implemented to generate the output by using the fastest arithmetic operations only: 32-bit additions and bit operations (no division, no multiplication, no mod).
 * These operations generate sequences of 32 random bits (&lt;tt&gt;int&lt;/tt&gt;'s).
 * &lt;tt&gt;long&lt;/tt&gt;'s are formed by concatenating two 32 bit &lt;tt&gt;int&lt;/tt&gt;'s.
 * &lt;tt&gt;float&lt;/tt&gt;'s are formed by dividing the interval &lt;tt&gt;[0.0,1.0]&lt;/tt&gt; into 2&lt;sup&gt;32&lt;/sup&gt; sub intervals, then randomly choosing one subinterval.
 * &lt;tt&gt;double&lt;/tt&gt;'s are formed by dividing the interval &lt;tt&gt;[0.0,1.0]&lt;/tt&gt; into 2&lt;sup&gt;64&lt;/sup&gt; sub intervals, then randomly choosing one subinterval.
 * &lt;p&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
    <see>java.util.Random</see>
  </javadoc>
  <declaration type="int" name="mti" />
  <declaration type="int[]" name="mt" />
  <declaration type="int" name="N" />
  <declaration type="int" name="M" />
  <declaration type="int" name="MATRIX_A" />
  <declaration type="int" name="UPPER_MASK" />
  <declaration type="int" name="LOWER_MASK" />
  <declaration type="int" name="TEMPERING_MASK_B" />
  <declaration type="int" name="TEMPERING_MASK_C" />
  <declaration type="int" name="mag0" />
  <declaration type="int" name="mag1" />
  <declaration type="int" name="DEFAULT_SEED" />
  <javadoc>
    <text>Constructs and returns a random number generator with a default seed, which is a &lt;b&gt;constant&lt;/b&gt;.
 * Thus using this constructor will yield generators that always produce exactly the same sequence.
 * This method is mainly intended to ease testing and debugging.</text>
  </javadoc>
  <method type="constructor" name="MersenneTwister" />
  <javadoc>
    <text>Constructs and returns a random number generator with the given seed.</text>
  </javadoc>
  <method type="constructor" name="MersenneTwister" />
  <javadoc>
    <text>Constructs and returns a random number generator seeded with the given date.</text>
    <param>d typically &lt;tt&gt;new java.util.Date()&lt;/tt&gt;</param>
  </javadoc>
  <method type="constructor" name="MersenneTwister" />
  <javadoc>
    <text>Returns a copy of the receiver; the copy will produce identical sequences.
 * After this call has returned, the copy and the receiver have equal but separate state.</text>
    <return>a copy of the receiver.</return>
  </javadoc>
  <method type="Object" name="clone">
    <declaration type="MersenneTwister" name="clone" />
  </method>
  <javadoc>
    <text>Generates N words at one time.</text>
  </javadoc>
  <method type="void" name="nextBlock">
    <declaration type="int" name="y" />
    <declaration type="int" name="kk" />
    <scope />
    <scope />
    <comment>OPTIMIZED 
 only 5-10% faster ?
int y;

int kk;
int[] cache = mt;  cached for speed
int kkM;
int limit = N-M;
for (kk=0,kkM=kk+M; kk&lt;limit; kk++,kkM++) {
y = (cache[kk]&amp;UPPER_MASK)|(cache[kk+1]&amp;LOWER_MASK);
cache[kk] = cache[kkM] ^ (y &gt;&gt;&gt; 1) ^ ((y &amp; 0x1) == 0 ? mag0 : mag1);
}
limit = N-1;
for (kkM=kk+(M-N); kk&lt;limit; kk++,kkM++) {
y = (cache[kk]&amp;UPPER_MASK)|(cache[kk+1]&amp;LOWER_MASK);
cache[kk] = cache[kkM] ^ (y &gt;&gt;&gt; 1) ^ ((y &amp; 0x1) == 0 ? mag0 : mag1);
}
y = (cache[N-1]&amp;UPPER_MASK)|(cache[0]&amp;LOWER_MASK);
cache[N-1] = cache[M-1] ^ (y &gt;&gt;&gt; 1) ^ ((y &amp; 0x1) == 0 ? mag0 : mag1);

this.mt = cache;
this.mti = 0;</comment>
    <comment>******************** UNOPTIMIZED **********************</comment>
  </method>
  <javadoc>
    <text>Returns a 32 bit uniformly distributed random number in the closed interval &lt;tt&gt;[Integer.MIN_VALUE,Integer.MAX_VALUE]&lt;/tt&gt; (including &lt;tt&gt;Integer.MIN_VALUE&lt;/tt&gt; and &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;).</text>
  </javadoc>
  <method type="int" name="nextInt">
    <declaration type="int" name="y" />
    <comment>Each single bit including the sign bit will be random</comment>
    <comment>generate N ints at one time</comment>
    <comment>y ^= TEMPERING_SHIFT_U(y );</comment>
    <comment>y ^= TEMPERING_SHIFT_S(y) &amp; TEMPERING_MASK_B;</comment>
    <comment>y ^= TEMPERING_SHIFT_T(y) &amp; TEMPERING_MASK_C;</comment>
    <comment>y &amp;= 0xffffffff; you may delete this line if word size = 32</comment>
    <comment>y ^= TEMPERING_SHIFT_L(y);</comment>
  </method>
  <javadoc>
    <text>Sets the receiver's seed. 
 * This method resets the receiver's entire internal state.</text>
  </javadoc>
  <method type="void" name="setSeed">
    <scope />
    <comment>See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.</comment>
    <comment>In the previous versions, MSBs of the seed affect</comment>
    <comment>only MSBs of the array mt[].</comment>
    <comment>20020109 modified by Makoto Matsumoto</comment>
    <comment>for &gt;32 bit machines</comment>
    <comment>System.out.println("init done");</comment>
    <comment>old version was:
for (int i = 0; i &lt; N; i++) {
mt[i] = seed &amp; 0xffff0000;
seed = 69069  seed + 1;
mt[i] |= (seed &amp; 0xffff0000) &gt;&gt;&gt; 16;
seed = 69069  seed + 1;
}
System.out.println("init done");
mti = N;</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>private int[] mt = new int[N];  set initial seeds: N = 624 words</comment>
  <comment>Period parameters</comment>
  <comment>private static final int MATRIX_A=0x9908b0df;    constant vector a</comment>
  <comment>private static final int UPPER_MASK=0x80000000;  most significant w-r bits</comment>
  <comment>private static final int LOWER_MASK=0x7fffffff;  least significant r bits</comment>
  <comment>for tempering</comment>
  <comment>private static final int[] mag01=new int[] {0x0, MATRIX_A};</comment>
  <comment>mag01[x] = x  MATRIX_A  for x=0,1</comment>
</class>
