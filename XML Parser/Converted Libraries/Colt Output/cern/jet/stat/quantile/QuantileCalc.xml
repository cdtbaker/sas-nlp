<?xml version="1.0" encoding="UTF-8"?>
<class name="QuantileCalc">
  <javadoc>
    <text>Computes b and k vor various parameters.</text>
  </javadoc>
  <javadoc>
    <text>Efficiently computes the binomial coefficient, often also referred to as "n over k" or "n choose k".
 * The binomial coefficient is defined as n!/((n-k)!*k!).
 * Tries to avoid numeric overflows.</text>
    <return>the binomial coefficient.</return>
  </javadoc>
  <method type="double" name="binomial">
    <scope />
    <declaration type="double" name="binomial" />
    <declaration type="long" name="N" />
    <scope />
    <comment>since binomial(n,k)==binomial(n,n-k), we can enforce the faster variant,</comment>
    <comment>which is also the variant minimizing number overflows.</comment>
  </method>
  <javadoc>
    <text>Returns the smallest &lt;code&gt;long &amp;gt;= value&lt;/code&gt;.
 * &lt;dt&gt;Examples: &lt;code&gt;1.0 -&gt; 1, 1.2 -&gt; 2, 1.9 -&gt; 2&lt;/code&gt;.
 * This method is safer than using (long) Math.ceil(value), because of possible rounding error.</text>
  </javadoc>
  <method type="long" name="ceiling" />
  <javadoc>
    <text>Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * Assumes that quantiles are to be computed over N values.
 * The required sampling rate is computed and stored in the first element of the provided &lt;tt&gt;returnSamplingRate&lt;/tt&gt; array, which, therefore must be at least of length 1.</text>
    <param>N the number of values over which quantiles shall be computed (e.g &lt;tt&gt;10^6&lt;/tt&gt;).</param>
    <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. &lt;tt&gt;0.001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= epsilon &amp;lt;= 1&lt;/tt&gt;). To get exact result, set &lt;tt&gt;epsilon=0.0&lt;/tt&gt;;</param>
    <param>delta the probability that the approximation error is more than than epsilon (e.g. &lt;tt&gt;0.0001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= delta &amp;lt;= 1&lt;/tt&gt;). To avoid probabilistic answers, set &lt;tt&gt;delta=0.0&lt;/tt&gt;.</param>
    <param>quantiles the number of quantiles to be computed (e.g. &lt;tt&gt;100&lt;/tt&gt;) (&lt;tt&gt;quantiles &amp;gt;= 1&lt;/tt&gt;). If unknown in advance, set this number large, e.g. &lt;tt&gt;quantiles &amp;gt;= 10000&lt;/tt&gt;.</param>
    <param>samplingRate a &lt;tt&gt;double[1]&lt;/tt&gt; where the sampling rate is to be filled in.</param>
    <return>&lt;tt&gt;long[2]&lt;/tt&gt; - &lt;tt&gt;long[0]&lt;/tt&gt;=the number of buffers, &lt;tt&gt;long[1]&lt;/tt&gt;=the number of elements per buffer, &lt;tt&gt;returnSamplingRate[0]&lt;/tt&gt;=the required sampling rate.</return>
  </javadoc>
  <method type="long[]" name="known_N_compute_B_and_K">
    <scope />
  </method>
  <javadoc>
    <text>Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with a &lt;b&gt;guaranteed&lt;/b&gt; approximation error no more than epsilon.
 * Assumes that quantiles are to be computed over N values.</text>
    <return>&lt;tt&gt;long[2]&lt;/tt&gt; - &lt;tt&gt;long[0]&lt;/tt&gt;=the number of buffers, &lt;tt&gt;long[1]&lt;/tt&gt;=the number of elements per buffer.</return>
    <param>N the anticipated number of values over which quantiles shall be determined.</param>
    <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. &lt;tt&gt;0.001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= epsilon &amp;lt;= 1&lt;/tt&gt;). To get exact result, set &lt;tt&gt;epsilon=0.0&lt;/tt&gt;;</param>
  </javadoc>
  <method type="long[]" name="known_N_compute_B_and_K_quick">
    <scope>
      <declaration type="long[]" name="result" />
    </scope>
    <declaration type="int" name="maxBuffers" />
    <declaration type="int" name="maxHeight" />
    <declaration type="double" name="N_double" />
    <declaration type="double" name="c" />
    <declaration type="int[]" name="heightMaximums" />
    <scope>
      <declaration type="int" name="h" />
      <scope />
      <scope />
      <declaration type="int" name="hMax" />
      <scope />
      <scope />
    </scope>
    <declaration type="long[]" name="kMinimums" />
    <scope>
      <declaration type="int" name="h" />
      <declaration type="long" name="kMin" />
      <scope>
        <declaration type="double" name="value" />
        <declaration type="long" name="tmpK" />
        <scope />
      </scope>
    </scope>
    <declaration type="long" name="multMin" />
    <declaration type="int" name="minB" />
    <scope>
      <scope>
        <declaration type="long" name="mult" />
        <scope />
      </scope>
    </scope>
    <declaration type="long" name="b" />
    <scope />
    <scope />
    <declaration type="long[]" name="result" />
    <comment>no way around exact quantile search</comment>
    <comment>for each b, determine maximum height, i.e. the height for which x&lt;=0 and x is a maximum</comment>
    <comment>with x = binomial(b+h-2, h-1) - binomial(b+h-3, h-3) + binomial(b+h-3, h-2) - N * epsilon * 2.0</comment>
    <comment>skip heights until x&lt;=0</comment>
    <comment>from now on x is monotonically growing...</comment>
    <comment>skip heights until x&gt;0</comment>
    <comment>go back to last height</comment>
    <comment>was x&gt;0 or did we loop without finding anything?</comment>
    <comment>safe some space</comment>
    <comment>end for</comment>
    <comment>for each b, determine the smallest k satisfying the constraints, i.e.</comment>
    <comment>for each b, determine kMin, with kMin = N/binomial(b+hMax-2,hMax-1)</comment>
    <comment>from all b's, determine b that minimizes b*kMin</comment>
    <comment>epsilon large enough?</comment>
    <comment>epsilon is very small or zero.</comment>
    <comment>the only possible solution without violating the</comment>
    <comment>approximation guarantees is exact quantile search.</comment>
  </method>
  <javadoc>
    <text>Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * Assumes that quantiles are to be computed over N values.
 * The required sampling rate is computed and stored in the first element of the provided &lt;tt&gt;returnSamplingRate&lt;/tt&gt; array, which, therefore must be at least of length 1.</text>
    <param>N the anticipated number of values over which quantiles shall be computed (e.g 10^6).</param>
    <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. &lt;tt&gt;0.001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= epsilon &amp;lt;= 1&lt;/tt&gt;). To get exact result, set &lt;tt&gt;epsilon=0.0&lt;/tt&gt;;</param>
    <param>delta the probability that the approximation error is more than than epsilon (e.g. &lt;tt&gt;0.0001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= delta &amp;lt;= 1&lt;/tt&gt;). To avoid probabilistic answers, set &lt;tt&gt;delta=0.0&lt;/tt&gt;.</param>
    <param>quantiles the number of quantiles to be computed (e.g. &lt;tt&gt;100&lt;/tt&gt;) (&lt;tt&gt;quantiles &amp;gt;= 1&lt;/tt&gt;). If unknown in advance, set this number large, e.g. &lt;tt&gt;quantiles &amp;gt;= 10000&lt;/tt&gt;.</param>
    <param>samplingRate a &lt;tt&gt;double[1]&lt;/tt&gt; where the sampling rate is to be filled in.</param>
    <return>&lt;tt&gt;long[2]&lt;/tt&gt; - &lt;tt&gt;long[0]&lt;/tt&gt;=the number of buffers, &lt;tt&gt;long[1]&lt;/tt&gt;=the number of elements per buffer, &lt;tt&gt;returnSamplingRate[0]&lt;/tt&gt;=the required sampling rate.</return>
  </javadoc>
  <method type="long[]" name="known_N_compute_B_and_K_slow">
    <scope>
      <declaration type="long[]" name="result" />
    </scope>
    <declaration type="int" name="maxBuffers" />
    <declaration type="int" name="maxHeight" />
    <declaration type="double" name="N_double" />
    <declaration type="long" name="ret_b" />
    <declaration type="long" name="ret_k" />
    <declaration type="double" name="sampling_rate" />
    <declaration type="long" name="memory" />
    <declaration type="double" name="logarithm" />
    <declaration type="double" name="c" />
    <scope>
      <declaration type="double" name="binomial" />
      <declaration type="long" name="tmp" />
      <scope />
      <scope>
        <declaration type="double" name="t" />
        <declaration type="double" name="u" />
        <declaration type="double" name="v" />
        <declaration type="double" name="w" />
        <declaration type="double" name="x" />
        <declaration type="long" name="k" />
        <scope />
      </scope>
    </scope>
    <declaration type="long[]" name="result" />
    <comment>delta can be set to zero, i.e., all quantiles should be approximate with probability 1</comment>
    <comment>no way around exact quantile search</comment>
    <comment>One possibility is to use one buffer of size N</comment>
    <comment />
    <comment>Otherwise, there are at least two buffers (b &gt;= 2)</comment>
    <comment>and the height of the tree is at least three (h &gt;= 3)</comment>
    <comment />
    <comment>We restrict the search for b and h to MAX_BINOM, a large enough value for</comment>
    <comment>practical values of    epsilon &gt;= 0.001   and    delta &gt;= 0.00001</comment>
    <comment />
    <comment>From our SIGMOD 98 paper, we have two equantions to satisfy:</comment>
    <comment>t  &lt;= u * alpha/(1-alpha)^2</comment>
    <comment>kv &gt;= w/(1-alpha)^2</comment>
    <comment />
    <comment>Denoting 1/(1-alpha)    by x,</comment>
    <comment>we see that the first inequality is equivalent to</comment>
    <comment>t/u &lt;= x^2 - x</comment>
    <comment>which is satisfied by x &gt;= 0.5 + 0.5 * sqrt (1 + 4t/u)</comment>
    <comment>Plugging in this value into second equation yields</comment>
    <comment>k &gt;= wx^2/v</comment>
  </method>
  <method type="void" name="main" />
  <javadoc>
    <text>Computes b and k for different parameters.</text>
  </javadoc>
  <method type="void" name="test_B_and_K_Calculation">
    <declaration type="boolean" name="known_N" />
    <declaration type="int[]" name="quantiles" />
    <declaration type="long[]" name="sizes" />
    <declaration type="double[]" name="deltas" />
    <declaration type="double[]" name="epsilons" />
    <scope>
      <declaration type="int" name="p" />
      <scope>
        <declaration type="long" name="N" />
        <scope>
          <declaration type="double" name="delta" />
          <scope>
            <declaration type="double" name="epsilon" />
            <declaration type="double[]" name="returnSamplingRate" />
            <declaration type="long[]" name="result" />
            <scope />
            <scope />
            <declaration type="long" name="b" />
            <declaration type="long" name="k" />
          </scope>
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.</text>
    <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. &lt;tt&gt;0.001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= epsilon &amp;lt;= 1&lt;/tt&gt;). To get exact results, set &lt;tt&gt;epsilon=0.0&lt;/tt&gt;;</param>
    <param>delta the probability that the approximation error is more than than epsilon (e.g. &lt;tt&gt;0.0001&lt;/tt&gt;) (&lt;tt&gt;0 &amp;lt;= delta &amp;lt;= 1&lt;/tt&gt;). To get exact results, set &lt;tt&gt;delta=0.0&lt;/tt&gt;.</param>
    <param>quantiles the number of quantiles to be computed (e.g. &lt;tt&gt;100&lt;/tt&gt;) (&lt;tt&gt;quantiles &amp;gt;= 1&lt;/tt&gt;). If unknown in advance, set this number large, e.g. &lt;tt&gt;quantiles &amp;gt;= 10000&lt;/tt&gt;.</param>
    <return>&lt;tt&gt;long[3]&lt;/tt&gt; - &lt;tt&gt;long[0]&lt;/tt&gt;=the number of buffers, &lt;tt&gt;long[1]&lt;/tt&gt;=the number of elements per buffer, &lt;tt&gt;long[2]&lt;/tt&gt;=the tree height where sampling shall start.</return>
  </javadoc>
  <method type="long[]" name="unknown_N_compute_B_and_K">
    <scope>
      <declaration type="long[]" name="result" />
    </scope>
    <declaration type="int" name="max_b" />
    <declaration type="int" name="max_h" />
    <declaration type="int" name="max_H" />
    <declaration type="int" name="max_Iterations" />
    <declaration type="long" name="best_b" />
    <declaration type="long" name="best_k" />
    <declaration type="long" name="best_h" />
    <declaration type="long" name="best_memory" />
    <declaration type="double" name="pow" />
    <declaration type="double" name="logDelta" />
    <scope>
      <scope>
        <scope>
          <declaration type="double" name="Ld" />
          <declaration type="double" name="Ls" />
          <declaration type="double" name="c" />
          <declaration type="double" name="beta" />
          <declaration type="double" name="cc" />
          <declaration type="double" name="d" />
          <declaration type="double" name="f" />
          <declaration type="double" name="root" />
          <declaration type="double" name="alpha_one" />
          <declaration type="double" name="alpha_two" />
          <declaration type="boolean" name="alpha_one_OK" />
          <declaration type="boolean" name="alpha_two_OK" />
          <scope>
            <declaration type="double" name="alpha" />
            <scope />
            <scope />
            <declaration type="long" name="k" />
            <scope>
              <declaration type="long" name="memory" />
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
      <scope />
    </scope>
    <declaration type="long[]" name="result" />
    <scope />
    <scope />
    <comment>delta can be set to zero, i.e., all quantiles should be approximate with probability 1</comment>
    <comment>no way around exact quantile search</comment>
    <comment>double logDelta =  Math.log(2.0/(quantiles*delta)) / (2.0*epsilon*epsilon);</comment>
    <comment>until we find a solution</comment>
    <comment>identify that combination of b and h that minimizes b*k.</comment>
    <comment>exhaustive search.</comment>
    <comment>now we have k&gt;=c*(1-alpha)^-2.</comment>
    <comment>let's compute c.</comment>
    <comment>double c = Math.log(2.0/(delta/quantiles)) / (2.0*epsilon*epsilon*Math.min(Ld, 8.0*Ls/3.0));</comment>
    <comment>now we have k&gt;=d/alpha.</comment>
    <comment>let's compute d.</comment>
    <comment>double d = (Ld(h+max_H-1.0)  +  Ls((h+1)pow - 2.0(h+max_H)))      (Ld + Ls(pow-2.0));
d = (d + 2.0)  (2.0epsilon);</comment>
    <comment>now we have c*(1-alpha)^-2 == d/alpha.</comment>
    <comment>we solve this equation for alpha yielding two solutions</comment>
    <comment>alpha_1,2 = (c + 2*d  +-  Sqrt(c*c + 4*c*d))/(2*d)</comment>
    <comment>non real solution to equation</comment>
    <comment>any alpha must satisfy 0&lt;alpha&lt;1 to yield valid solutions</comment>
    <comment>take the alpha that minimizes d/alpha</comment>
    <comment>now we have k=Ceiling(Max(d/alpha, (h+1)/(2*epsilon)))</comment>
    <comment>valid solution?</comment>
    <comment>found a solution requiring less memory</comment>
    <comment>end for h</comment>
    <comment>end for b</comment>
    <comment>no solution found so far. very unlikely. Anyway, try again.</comment>
    <comment>end while</comment>
    <comment>no solution found.</comment>
    <comment>no way around exact quantile search.</comment>
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
</class>
