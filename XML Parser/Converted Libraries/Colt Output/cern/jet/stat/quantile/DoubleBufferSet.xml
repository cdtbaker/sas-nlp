<?xml version="1.0" encoding="UTF-8"?>
<class name="DoubleBufferSet">
  <javadoc>
    <text>A set of buffers holding &lt;tt&gt;double&lt;/tt&gt; elements; internally used for computing approximate quantiles.</text>
  </javadoc>
  <declaration type="DoubleBuffer[]" name="buffers" />
  <declaration type="boolean" name="nextTriggerCalculationState" />
  <javadoc>
    <text>Constructs a buffer set with b buffers, each having k elements</text>
    <param>b the number of buffers</param>
    <param>k the number of elements per buffer</param>
  </javadoc>
  <method type="constructor" name="DoubleBufferSet" />
  <javadoc>
    <text>Returns an empty buffer if at least one exists.
 * Preferably returns a buffer which has already been used,
 * i.e. a buffer which has already been allocated.</text>
  </javadoc>
  <method type="DoubleBuffer" name="_getFirstEmptyBuffer">
    <declaration type="DoubleBuffer" name="emptyBuffer" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns all full or partial buffers.</text>
  </javadoc>
  <method type="DoubleBuffer[]" name="_getFullOrPartialBuffers">
    <declaration type="int" name="count" />
    <scope />
    <declaration type="DoubleBuffer[]" name="collectedBuffers" />
    <declaration type="int" name="j" />
    <scope>
      <scope />
    </scope>
    <comment>count buffers</comment>
    <comment>collect buffers</comment>
  </method>
  <javadoc>
    <text>Determines all full buffers having the specified level.</text>
    <return>all full buffers having the specified level</return>
  </javadoc>
  <method type="DoubleBuffer[]" name="_getFullOrPartialBuffersWithLevel">
    <declaration type="int" name="count" />
    <scope />
    <declaration type="DoubleBuffer[]" name="collectedBuffers" />
    <declaration type="int" name="j" />
    <scope>
      <scope />
    </scope>
    <comment>count buffers</comment>
    <comment>collect buffers</comment>
  </method>
  <javadoc>
    <return>The minimum level of all buffers which are full.</return>
  </javadoc>
  <method type="int" name="_getMinLevelOfFullOrPartialBuffers">
    <declaration type="int" name="b" />
    <declaration type="int" name="minLevel" />
    <declaration type="DoubleBuffer" name="buffer" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the number of empty buffers.</text>
  </javadoc>
  <method type="int" name="_getNumberOfEmptyBuffers">
    <declaration type="int" name="count" />
    <scope />
  </method>
  <javadoc>
    <text>Returns all empty buffers.</text>
  </javadoc>
  <method type="DoubleBuffer" name="_getPartialBuffer">
    <scope />
  </method>
  <javadoc>
    <return>the number of buffers</return>
  </javadoc>
  <method type="int" name="b" />
  <javadoc>
    <text>Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, and its memory requirements will be close to zero.</text>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, and its memory requirements will be close to zero.</text>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Returns a deep copy of the receiver.</text>
    <return>a deep copy of the receiver.</return>
  </javadoc>
  <method type="Object" name="clone">
    <declaration type="DoubleBufferSet" name="copy" />
    <scope />
  </method>
  <javadoc>
    <text>Collapses the specified full buffers (must not include partial buffer).</text>
    <return>a full buffer containing the collapsed values. The buffer has accumulated weight.</return>
    <param>buffers the buffers to be collapsed (all of them must be full or partially full)</param>
  </javadoc>
  <method type="DoubleBuffer" name="collapse">
    <declaration type="int" name="W" />
    <scope />
    <declaration type="int" name="k" />
    <declaration type="long[]" name="triggerPositions" />
    <scope />
    <declaration type="double[]" name="outputValues" />
    <declaration type="DoubleBuffer" name="outputBuffer" />
    <comment>determine W</comment>
    <comment>sum of all weights</comment>
    <comment>determine outputTriggerPositions</comment>
    <comment>do the main work: determine values at given positions in sorted sequence</comment>
    <comment>mark all full buffers as empty, except the first, which will contain the output</comment>
  </method>
  <javadoc>
    <text>Returns whether the specified element is contained in the receiver.</text>
  </javadoc>
  <method type="boolean" name="contains">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Applies a procedure to each element of the receiver, if any.
 * Iterates over the receiver in no particular order.</text>
    <param>procedure    the procedure to be applied. Stops iteration if the procedure returns &lt;tt&gt;false&lt;/tt&gt;, otherwise continues.</param>
  </javadoc>
  <method type="boolean" name="forEach">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Determines all values of the specified buffers positioned at the specified triggerPositions within the sorted sequence and fills them into outputValues.</text>
    <param>buffers the buffers to be searched (all must be full or partial)</param>
    <param>triggerPositions the positions of elements within the sorted sequence to be retrieved</param>
    <return>outputValues a list filled with the values at triggerPositions</return>
  </javadoc>
  <method type="double[]" name="getValuesAtPositions">
    <scope />
    <declaration type="int[]" name="bufferSizes" />
    <declaration type="double[][][]" name="bufferValues" />
    <declaration type="int" name="totalBuffersSize" />
    <scope />
    <declaration type="int" name="buffersSize" />
    <declaration type="int" name="triggerPositionsLength" />
    <declaration type="int" name="j" />
    <declaration type="int[]" name="cursors" />
    <declaration type="long" name="counter" />
    <declaration type="long" name="nextHit" />
    <declaration type="double[]" name="outputValues" />
    <scope>
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="minValue" />
      <declaration type="int" name="minBufferIndex" />
      <scope>
        <scope>
          <declaration type="double" name="value" />
          <scope />
        </scope>
      </scope>
      <declaration type="DoubleBuffer" name="minBuffer" />
      <scope />
    </scope>
    <comment>if (buffers.length==0)</comment>
    <comment>{</comment>
    <comment>throw new IllegalArgumentException("Oops! buffer.length==0.");</comment>
    <comment>}</comment>
    <comment>System.out.println("triggers="+cern.it.util.Arrays.toString(positions));</comment>
    <comment>new DoubleArrayList(outputValues).fillFromToWith(0, outputValues.length-1, 0.0f);</comment>
    <comment>delte the above line, it is only for testing</comment>
    <comment>cern.it.util.Log.println("\nEntering getValuesAtPositions...");</comment>
    <comment>cern.it.util.Log.println("hitPositions="+cern.it.util.Arrays.toString(positions));</comment>
    <comment>sort buffers.</comment>
    <comment>collect some infos into fast cache; for tuning purposes only.</comment>
    <comment>cern.it.util.Log.println("buffer["+i+"]="+buffers[i].values);</comment>
    <comment>prepare merge of equi-distant elements within buffers into output values</comment>
    <comment>first collect some infos into fast cache; for tuning purposes only.</comment>
    <comment>now prepare the important things.</comment>
    <comment>current position in collapsed values</comment>
    <comment>current position in each buffer; init with zeroes</comment>
    <comment>current position in sorted sequence</comment>
    <comment>next position in sorted sequence to trigger output population</comment>
    <comment>nothing to output, because no elements have been filled (we are empty).</comment>
    <comment>return meaningless values</comment>
    <comment>fill all output values with equi-distant elements.</comment>
    <comment>System.out.println("\nj="+j);</comment>
    <comment>System.out.println("counter="+counter);</comment>
    <comment>System.out.println("nextHit="+nextHit);</comment>
    <comment>determine buffer with smallest value at cursor position.</comment>
    <comment>DoubleBuffer buffer = buffers[b];</comment>
    <comment>if (cursors[b] &lt; buffer.length) {</comment>
    <comment>/double value = buffer.values[cursors[b]];</comment>
    <comment>trigger copies into output sequence, if necessary.</comment>
    <comment>System.out.println("adding to output="+minValue);</comment>
    <comment>that element has now been treated, move further.</comment>
    <comment>System.out.println("cursors="+cern.it.util.Arrays.toString(cursors));</comment>
    <comment>end while (j&lt;k)</comment>
    <comment>cern.it.util.Log.println("returning output="+cern.it.util.Arrays.toString(outputValues));</comment>
  </method>
  <javadoc>
    <return>the number of elements within a buffer.</return>
  </javadoc>
  <method type="int" name="k" />
  <javadoc>
    <text>Returns the number of elements currently needed to store all contained elements.</text>
  </javadoc>
  <method type="long" name="memory">
    <declaration type="long" name="memory" />
    <scope />
  </method>
  <javadoc>
    <text>Computes the next triggerPosition for collapse</text>
    <return>the next triggerPosition for collapse</return>
    <param>j specifies that the j-th trigger position is to be computed</param>
    <param>W the accumulated weights</param>
  </javadoc>
  <method type="long" name="nextTriggerPosition">
    <declaration type="long" name="nextTriggerPosition" />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>is W odd?</comment>
    <comment>W is even</comment>
    <comment>alternate between both possible next hit positions upon successive invocations</comment>
  </method>
  <javadoc>
    <text>Returns how many percent of the elements contained in the receiver are &lt;tt&gt;&amp;lt;= element&lt;/tt&gt;.
 * Does linear interpolation if the element is not contained but lies in between two contained elements.</text>
    <param>the element to search for.</param>
    <return>the percentage &lt;tt&gt;p&lt;/tt&gt; of elements &lt;tt&gt;&amp;lt;= element&lt;/tt&gt; (&lt;tt&gt;0.0 &amp;lt;= p &amp;lt;=1.0)&lt;/tt&gt;.</return>
  </javadoc>
  <method type="double" name="phi">
    <declaration type="double" name="elementsLessThanOrEqualToElement" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <return>a String representation of the receiver</return>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="StringBuffer" name="buf" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the number of elements in all buffers.</text>
  </javadoc>
  <method type="long" name="totalSize">
    <declaration type="DoubleBuffer[]" name="fullBuffers" />
    <declaration type="long" name="totalSize" />
    <scope />
  </method>
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>tmp var only</comment>
</class>
