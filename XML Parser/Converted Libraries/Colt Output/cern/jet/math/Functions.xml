<?xml version="1.0" encoding="UTF-8"?>
<class name="Functions">
  <javadoc>
    <text>Function objects to be passed to generic methods. Contains the functions of {@link java.lang.Math} as function objects, as 
 * well as a few more basic functions.
 * &lt;p&gt;Function objects conveniently allow to express arbitrary functions in a generic 
 * manner. Essentially, a function object is an object that can perform a function 
 * on some arguments. It has a minimal interface: a method &lt;tt&gt;apply&lt;/tt&gt; that 
 * takes the arguments, computes something and returns some result value. Function 
 * objects are comparable to function pointers in C used for call-backs.
 * &lt;p&gt;Unary functions are of type {@link cern.colt.function.DoubleFunction}, binary functions 
 * of type {@link cern.colt.function.DoubleDoubleFunction}. All can be retrieved via &lt;tt&gt;public 
 * static final&lt;/tt&gt; variables named after the function. 
 * Unary predicates are of type {@link cern.colt.function.DoubleProcedure}, binary predicates 
 * of type {@link cern.colt.function.DoubleDoubleProcedure}. All can be retrieved via &lt;tt&gt;public 
 * static final&lt;/tt&gt; variables named &lt;tt&gt;isXXX&lt;/tt&gt;. 
 * &lt;p&gt; Binary functions and predicates also exist as unary functions with the second argument being 
 * fixed to a constant. These are generated and retrieved via factory methods (again 
 * with the same name as the function). Example: 
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;Functions.pow&lt;/tt&gt; gives the function &lt;tt&gt;a&lt;sup&gt;b&lt;/sup&gt;&lt;/tt&gt;.
 * &lt;li&gt;&lt;tt&gt;Functions.pow.apply(2,3)==8&lt;/tt&gt;.
 * &lt;li&gt;&lt;tt&gt;Functions.pow(3)&lt;/tt&gt; gives the function &lt;tt&gt;a&lt;sup&gt;3&lt;/sup&gt;&lt;/tt&gt;.
 * &lt;li&gt;&lt;tt&gt;Functions.pow(3).apply(2)==8&lt;/tt&gt;.
 * &lt;/ul&gt;
 * More general, any binary function can be made an unary functions by fixing either 
 * the first or the second argument. See methods {@link #bindArg1(DoubleDoubleFunction,double)} 
 * and {@link #bindArg2(DoubleDoubleFunction,double)}. The order of arguments 
 * can be swapped so that the first argument becomes the second and vice-versa. See 
 * method {@link #swapArgs(DoubleDoubleFunction)}. Example: 
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;Functions.pow&lt;/tt&gt; gives the function &lt;tt&gt;a&lt;sup&gt;b&lt;/sup&gt;&lt;/tt&gt;.
 * &lt;li&gt;&lt;tt&gt;Functions.bindArg2(Functions.pow,3)&lt;/tt&gt; gives the function &lt;tt&gt;x&lt;sup&gt;3&lt;/sup&gt;&lt;/tt&gt;.
 * &lt;li&gt;&lt;tt&gt;Functions.bindArg1(Functions.pow,3)&lt;/tt&gt; gives the function &lt;tt&gt;3&lt;sup&gt;x&lt;/sup&gt;&lt;/tt&gt;.
 * &lt;li&gt;&lt;tt&gt;Functions.swapArgs(Functions.pow)&lt;/tt&gt; gives the function &lt;tt&gt;b&lt;sup&gt;a&lt;/sup&gt;&lt;/tt&gt;.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Even more general, functions can be chained (composed, assembled). Assume we have two unary 
 * functions &lt;tt&gt;g&lt;/tt&gt; and &lt;tt&gt;h&lt;/tt&gt;. The unary function &lt;tt&gt;g(h(a))&lt;/tt&gt; applying 
 * both in sequence can be generated via {@link #chain(DoubleFunction,DoubleFunction)}:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;Functions.chain(g,h);&lt;/tt&gt;
 * &lt;/ul&gt; 
 * Assume further we have a binary function &lt;tt&gt;f&lt;/tt&gt;. The binary function &lt;tt&gt;g(f(a,b))&lt;/tt&gt; 
 * can be generated via {@link #chain(DoubleFunction,DoubleDoubleFunction)}:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;Functions.chain(g,f);&lt;/tt&gt;
 * &lt;/ul&gt;
 * The binary function &lt;tt&gt;f(g(a),h(b))&lt;/tt&gt; 
 * can be generated via {@link #chain(DoubleDoubleFunction,DoubleFunction,DoubleFunction)}:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;Functions.chain(f,g,h);&lt;/tt&gt;
 * &lt;/ul&gt;
 * Arbitrarily complex functions can be composed from these building blocks. For example
 * &lt;tt&gt;sin(a) + cos&lt;sup&gt;2&lt;/sup&gt;(b)&lt;/tt&gt; can be specified as follows:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;chain(plus,sin,chain(square,cos));&lt;/tt&gt;
 * &lt;/ul&gt; 
 * or, of course, as 
 * &lt;pre&gt;
 * new DoubleDoubleFunction() {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public final double apply(double a, double b) { return Math.sin(a) + Math.pow(Math.cos(b),2); }
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For aliasing see {@link #functions}.
 * Try this
 * &lt;table&gt;
 * &lt;td class="PRE"&gt; 
 * &lt;pre&gt;
 * // should yield 1.4399560356056456 in all cases
 * double a = 0.5; 
 * double b = 0.2;
 * double v = Math.sin(a) + Math.pow(Math.cos(b),2);
 * System.out.println(v);
 * Functions F = Functions.functions;
 * DoubleDoubleFunction f = F.chain(F.plus,F.sin,F.chain(F.square,F.cos));
 * System.out.println(f.apply(a,b));
 * DoubleDoubleFunction g = new DoubleDoubleFunction() {
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public double apply(double a, double b) { return Math.sin(a) + Math.pow(Math.cos(b),2); }
 * };
 * System.out.println(g.apply(a,b));
 * &lt;/pre&gt;
 * &lt;/td&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * &lt;H3&gt;Performance&lt;/H3&gt;
 * Surprise. Using modern non-adaptive JITs such as SunJDK 1.2.2 (java -classic) 
 * there seems to be no or only moderate performance penalty in using function 
 * objects in a loop over traditional code in a loop. For complex nested function 
 * objects (e.g. &lt;tt&gt;F.chain(F.abs,F.chain(F.plus,F.sin,F.chain(F.square,F.cos)))&lt;/tt&gt;) 
 * the penalty is zero, for trivial functions (e.g. &lt;tt&gt;F.plus&lt;/tt&gt;) the penalty 
 * is often acceptable.
 * &lt;center&gt;
 * &lt;table border cellpadding="3" cellspacing="0" align="center"&gt;
 * &lt;tr valign="middle" bgcolor="#33CC66" nowrap align="center"&gt; 
 * &lt;td nowrap colspan="7"&gt; &lt;font size="+2"&gt;Iteration Performance [million function 
 * evaluations per second]&lt;/font&gt;&lt;br&gt;
 * &lt;font size="-1"&gt;Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic, 
 * &lt;/font&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td nowrap bgcolor="#FF9966" rowspan="2"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966" colspan="2"&gt; 
 * &lt;p&gt; 30000000 iterations&lt;/p&gt;
 * &lt;/td&gt;
 * &lt;td bgcolor="#FF9966" colspan="2"&gt; 3000000 iterations (10 times less)&lt;/td&gt;
 * &lt;td bgcolor="#FF9966" colspan="2"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td bgcolor="#FF9966"&gt; &lt;tt&gt;F.plus&lt;/tt&gt;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt;&lt;tt&gt;a+b&lt;/tt&gt;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt; &lt;tt&gt;F.chain(F.abs,F.chain(F.plus,F.sin,F.chain(F.square,F.cos)))&lt;/tt&gt;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt; &lt;tt&gt;Math.abs(Math.sin(a) + Math.pow(Math.cos(b),2))&lt;/tt&gt;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td bgcolor="#FF9966"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr valign="middle" bgcolor="#66CCFF" nowrap align="center"&gt; 
 * &lt;td nowrap bgcolor="#FF9966"&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td nowrap&gt;10.8&lt;/td&gt;
 * &lt;td nowrap&gt;29.6&lt;/td&gt;
 * &lt;td nowrap&gt;0.43&lt;/td&gt;
 * &lt;td nowrap&gt;0.35&lt;/td&gt;
 * &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;&lt;/center&gt;</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>1.0, 09/24/99</version>
  </javadoc>
  <javadoc>
    <text>Little trick to allow for "aliasing", that is, renaming this class.
 * Writing code like
 * &lt;p&gt;
 * &lt;tt&gt;Functions.chain(Functions.plus,Functions.sin,Functions.chain(Functions.square,Functions.cos));&lt;/tt&gt;
 * &lt;p&gt;
 * is a bit awkward, to say the least.
 * Using the aliasing you can instead write
 * &lt;p&gt;
 * &lt;tt&gt;Functions F = Functions.functions; &lt;br&gt;
 * F.chain(F.plus,F.sin,F.chain(F.square,F.cos));&lt;/tt&gt;</text>
  </javadoc>
  <declaration type="Functions" name="functions" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.abs(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="abs" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.acos(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="acos" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.asin(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="asin" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.atan(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="atan" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.ceil(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="ceil" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.cos(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="cos" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.exp(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="exp" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.floor(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="floor" />
  <javadoc>
    <text>Function that returns its argument.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="identity" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;1.0 / a&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="inv" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.log(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="log" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.log(a) / Math.log(2)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply">
    <comment>1.0 / Math.log(2) == 1.4426950408889634</comment>
  </method>
  <declaration type="DoubleFunction" name="log2" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;-a&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="neg" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.rint(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="rint" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a &lt; 0 ? -1 : a &gt; 0 ? 1 : 0&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="sign" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.sin(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="sin" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.sqrt(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="sqrt" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a * a&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="square" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.tan(a)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleFunction" name="tan" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.atan2(a,b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="atan2" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a &lt; b ? -1 : a &gt; b ? 1 : 0&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="compare" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a / b&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="div" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a == b ? 1 : 0&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="equals" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a &gt; b ? 1 : 0&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="greater" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.IEEEremainder(a,b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="IEEEremainder" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a == b&lt;/tt&gt;.</text>
  </javadoc>
  <method type="boolean" name="apply" />
  <declaration type="DoubleDoubleProcedure" name="isEqual" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a &lt; b&lt;/tt&gt;.</text>
  </javadoc>
  <method type="boolean" name="apply" />
  <declaration type="DoubleDoubleProcedure" name="isLess" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a &gt; b&lt;/tt&gt;.</text>
  </javadoc>
  <method type="boolean" name="apply" />
  <declaration type="DoubleDoubleProcedure" name="isGreater" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a &lt; b ? 1 : 0&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="less" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.log(a) / Math.log(b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="lg" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.max(a,b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="max" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.min(a,b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="min" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a - b&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="DoubleDoubleFunction" name="minus" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a % b&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="mod" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a * b&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="mult" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;a + b&lt;/tt&gt;.</text>
  </javadoc>
  <declaration type="DoubleDoubleFunction" name="plus" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.abs(a) + Math.abs(b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="plusAbs" />
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.pow(a,b)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="apply" />
  <declaration type="DoubleDoubleFunction" name="pow" />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Functions" />
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;(from&lt;=a &amp;&amp; a&lt;=to) ? 1 : 0&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;from&lt;/tt&gt; and &lt;tt&gt;to&lt;/tt&gt; are fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="between">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a unary function from a binary function with the first operand (argument) fixed to the given constant &lt;tt&gt;c&lt;/tt&gt;.
 * The second operand is variable (free).</text>
    <param>function a binary function taking operands in the form &lt;tt&gt;function.apply(c,var)&lt;/tt&gt;.</param>
    <return>the unary function &lt;tt&gt;function(c,var)&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleFunction" name="bindArg1">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a unary function from a binary function with the second operand (argument) fixed to the given constant &lt;tt&gt;c&lt;/tt&gt;.
 * The first operand is variable (free).</text>
    <param>function a binary function taking operands in the form &lt;tt&gt;function.apply(var,c)&lt;/tt&gt;.</param>
    <return>the unary function &lt;tt&gt;function(var,c)&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleFunction" name="bindArg2">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs the function &lt;tt&gt;f( g(a), h(b) )&lt;/tt&gt;.</text>
    <param>f a binary function.</param>
    <param>g a unary function.</param>
    <param>h a unary function.</param>
    <return>the binary function &lt;tt&gt;f( g(a), h(b) )&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleDoubleFunction" name="chain">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs the function &lt;tt&gt;g( h(a,b) )&lt;/tt&gt;.</text>
    <param>g a unary function.</param>
    <param>h a binary function.</param>
    <return>the unary function &lt;tt&gt;g( h(a,b) )&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleDoubleFunction" name="chain">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs the function &lt;tt&gt;g( h(a) )&lt;/tt&gt;.</text>
    <param>g a unary function.</param>
    <param>h a unary function.</param>
    <return>the unary function &lt;tt&gt;g( h(a) )&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleFunction" name="chain">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a &lt; b ? -1 : a &gt; b ? 1 : 0&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="compare">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns the constant &lt;tt&gt;c&lt;/tt&gt;.</text>
  </javadoc>
  <method type="DoubleFunction" name="constant">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Demonstrates usage of this class.</text>
  </javadoc>
  <method type="void" name="demo1">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <declaration type="double" name="v" />
    <declaration type="DoubleDoubleFunction" name="f" />
    <declaration type="DoubleDoubleFunction" name="g" />
    <method type="double" name="apply" />
    <declaration type="DoubleFunction" name="m" />
    <declaration type="DoubleFunction" name="n" />
    <comment>DoubleDoubleFunction f = F.chain(plus,sin,F.chain(square,cos));</comment>
  </method>
  <javadoc>
    <text>Benchmarks and demonstrates usage of trivial and complex functions.</text>
  </javadoc>
  <method type="void" name="demo2">
    <declaration type="cern.jet.math.Functions" name="F" />
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <declaration type="double" name="v" />
    <declaration type="DoubleDoubleFunction" name="f" />
    <declaration type="DoubleDoubleFunction" name="g" />
    <method type="double" name="apply" />
    <declaration type="cern.colt.Timer" name="emptyLoop" />
    <declaration type="double" name="sum" />
    <scope />
    <declaration type="cern.colt.Timer" name="timer" />
    <scope />
    <scope />
    <scope />
    <comment>double v = Math.sin(a) + Math.pow(Math.cos(b),2);</comment>
    <comment>double v = a + b;</comment>
    <comment>DoubleDoubleFunction f = F.chain(F.plus,F.identity,F.identity);</comment>
    <comment>DoubleDoubleFunction f = F.chain(F.plus,F.sin,F.chain(F.square,F.cos));</comment>
    <comment>DoubleDoubleFunction f = F.plus;</comment>
    <comment>public final double apply(double x, double y) { return x+y; }</comment>
    <comment>emptyLoop</comment>
    <comment>sum += a + b;</comment>
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a / b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="div" />
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a == b ? 1 : 0&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="equals">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a &gt; b ? 1 : 0&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="greater">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;Math.IEEEremainder(a,b)&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="IEEEremainder">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;from&lt;=a &amp;&amp; a&lt;=to&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;from&lt;/tt&gt; and &lt;tt&gt;to&lt;/tt&gt; are fixed.</text>
  </javadoc>
  <method type="DoubleProcedure" name="isBetween">
    <method type="boolean" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a == b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleProcedure" name="isEqual">
    <method type="boolean" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a &gt; b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleProcedure" name="isGreater">
    <method type="boolean" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a &lt; b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleProcedure" name="isLess">
    <method type="boolean" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a &lt; b ? 1 : 0&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="less">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;&lt;tt&gt;Math.log(a) / Math.log(b)&lt;/tt&gt;&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="lg">
    <declaration type="double" name="logInv" />
    <method type="double" name="apply" />
    <comment>cached for speed</comment>
  </method>
  <javadoc>
    <text>Tests various methods of this class.</text>
  </javadoc>
  <method type="void" name="main">
    <declaration type="int" name="size" />
    <comment>demo1();</comment>
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;Math.max(a,b)&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="max">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;Math.min(a,b)&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="min">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a - b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="minus" />
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a - b*constant&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; are variables, &lt;tt&gt;constant&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleDoubleFunction" name="minusMult" />
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a % b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="mod">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a * b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="mult">
    <comment>return new DoubleFunction() {
public final double apply(double a) { return a  b; }
};</comment>
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a + b&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="plus">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;a + b*constant&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; are variables, &lt;tt&gt;constant&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleDoubleFunction" name="plusMult">
    <comment>return new DoubleDoubleFunction() {
public final double apply(double a, double b) { return a + bconstant; }
};</comment>
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;Math.pow(a,b)&lt;/tt&gt;.
 * &lt;tt&gt;a&lt;/tt&gt; is a variable, &lt;tt&gt;b&lt;/tt&gt; is fixed.</text>
  </javadoc>
  <method type="DoubleFunction" name="pow">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns a new uniform random number in the open unit interval &lt;code&gt;(0.0,1.0)&lt;/code&gt; (excluding 0.0 and 1.0).
 * Currently the engine is {@link cern.jet.random.engine.MersenneTwister}and is seeded with the current time.
 * &lt;p&gt;
 * Note that any random engine derived from {@link cern.jet.random.engine.RandomEngine} and any random distribution derived from {@link cern.jet.random.AbstractDistribution} are function objects, because they implement the proper interfaces.
 * Thus, if you are not happy with the default, just pass your favourite random generator to function evaluating methods.</text>
  </javadoc>
  <method type="DoubleFunction" name="random" />
  <javadoc>
    <text>Constructs a function that returns the number rounded to the given precision; &lt;tt&gt;Math.rint(a/precision)*precision&lt;/tt&gt;.
 * Examples:
 * &lt;pre&gt;
 * precision = 0.01 rounds 0.012 --&gt; 0.01, 0.018 --&gt; 0.02
 * precision = 10   rounds 123   --&gt; 120 , 127   --&gt; 130
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="DoubleFunction" name="round">
    <method type="double" name="apply" />
  </method>
  <javadoc>
    <text>Constructs a function that returns &lt;tt&gt;function.apply(b,a)&lt;/tt&gt;, i.e. applies the function with the first operand as second operand and the second operand as first operand.</text>
    <param>function a function taking operands in the form &lt;tt&gt;function.apply(a,b)&lt;/tt&gt;.</param>
    <return>the binary function &lt;tt&gt;function(b,a)&lt;/tt&gt;.</return>
  </javadoc>
  <method type="DoubleDoubleFunction" name="swapArgs">
    <method type="double" name="apply" />
  </method>
  <comment>Copyright � 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>import com.imsl.math.Sfun;</comment>
  <javadoc>
    <text>&lt;H3&gt;Unary functions&lt;/H3&gt;</text>
  </javadoc>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.acosh(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction acosh = new DoubleFunction() {
public final double apply(double a) { return Sfun.acosh(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.asinh(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction asinh = new DoubleFunction() {
public final double apply(double a) { return Sfun.asinh(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.atanh(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction atanh = new DoubleFunction() {
public final double apply(double a) { return Sfun.atanh(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.cosh(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction cosh = new DoubleFunction() {
public final double apply(double a) { return Sfun.cosh(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.cot(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction cot = new DoubleFunction() {
public final double apply(double a) { return Sfun.cot(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.erf(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction erf = new DoubleFunction() {
public final double apply(double a) { return Sfun.erf(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.erfc(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction erfc = new DoubleFunction() {
public final double apply(double a) { return Sfun.erfc(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.gamma(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction gamma = new DoubleFunction() {
public final double apply(double a) { return Sfun.gamma(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.log10(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction log10 = new DoubleFunction() {
public final double apply(double a) { return Sfun.log10(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.logGamma(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction logGamma = new DoubleFunction() {
public final double apply(double a) { return Sfun.logGamma(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.sinh(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction sinh = new DoubleFunction() {
public final double apply(double a) { return Sfun.sinh(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.tanh(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction tanh = new DoubleFunction() {
public final double apply(double a) { return Sfun.tanh(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.toDegrees(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction toDegrees = new DoubleFunction() {
public final double apply(double a) { return Math.toDegrees(a); }
};</comment>
  <javadoc>
    <text>Function that returns &lt;tt&gt;Math.toRadians(a)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleFunction toRadians = new DoubleFunction() {
public final double apply(double a) { return Math.toRadians(a); }
};</comment>
  <javadoc>
    <text>&lt;H3&gt;Binary functions&lt;/H3&gt;</text>
  </javadoc>
  <javadoc>
    <text>Function that returns &lt;tt&gt;com.imsl.math.Sfun.logBeta(a,b)&lt;/tt&gt;.</text>
  </javadoc>
  <comment>public static final DoubleDoubleFunction logBeta = new DoubleDoubleFunction() {
public final double apply(double a, double b) { return Sfun.logBeta(a,b); }
};</comment>
  <comment>new DoubleDoubleFunction() {
public final double apply(double a, double b) { return a - b; }
};</comment>
  <comment>new DoubleDoubleFunction() {
public final double apply(double a, double b) { return a + b; }
};</comment>
</class>
