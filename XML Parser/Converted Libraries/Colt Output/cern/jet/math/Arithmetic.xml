<?xml version="1.0" encoding="UTF-8"?>
<class name="Arithmetic">
  <javadoc>
    <text>Arithmetic functions.</text>
  </javadoc>
  <declaration type="double[]" name="stirlingCorrection" />
  <declaration type="double[]" name="logFactorials" />
  <declaration type="long[]" name="longFactorials" />
  <declaration type="double[]" name="doubleFactorials" />
  <javadoc>
    <text>Makes this class non instantiable, but still let's others inherit from it.</text>
  </javadoc>
  <method type="constructor" name="Arithmetic" />
  <javadoc>
    <text>Efficiently returns the binomial coefficient, often also referred to as "n over k" or "n choose k".
 * The binomial coefficient is defined as &lt;tt&gt;(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )&lt;/tt&gt;.
 * &lt;ul&gt;
 * &lt;li&gt;k&lt;0&lt;tt&gt;: &lt;tt&gt;0&lt;/tt&gt;.
 * &lt;li&gt;k==0&lt;tt&gt;: &lt;tt&gt;1&lt;/tt&gt;.
 * &lt;li&gt;k==1&lt;tt&gt;: &lt;tt&gt;n&lt;/tt&gt;.
 * &lt;li&gt;else: &lt;tt&gt;(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )&lt;/tt&gt;.
 * &lt;/ul&gt;</text>
    <return>the binomial coefficient.</return>
  </javadoc>
  <method type="double" name="binomial">
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <declaration type="double" name="binomial" />
    <scope />
    <comment>binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</comment>
  </method>
  <javadoc>
    <text>Efficiently returns the binomial coefficient, often also referred to as "n over k" or "n choose k".
 * The binomial coefficient is defined as
 * &lt;ul&gt;
 * &lt;li&gt;k&lt;0&lt;tt&gt;: &lt;tt&gt;0&lt;/tt&gt;.
 * &lt;li&gt;k==0 || k==n&lt;tt&gt;: &lt;tt&gt;1&lt;/tt&gt;.
 * &lt;li&gt;k==1 || k==n-1&lt;tt&gt;: &lt;tt&gt;n&lt;/tt&gt;.
 * &lt;li&gt;else: &lt;tt&gt;(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )&lt;/tt&gt;.
 * &lt;/ul&gt;</text>
    <return>the binomial coefficient.</return>
  </javadoc>
  <method type="double" name="binomial">
    <scope>
      <declaration type="int" name="max" />
      <scope>
        <declaration type="double" name="n_fac" />
        <declaration type="double" name="k_fac" />
        <declaration type="double" name="n_minus_k_fac" />
        <declaration type="double" name="nk" />
        <scope />
      </scope>
    </scope>
    <declaration type="long" name="a" />
    <declaration type="long" name="b" />
    <declaration type="double" name="binomial" />
    <scope />
    <comment>try quick version and see whether we get numeric overflows.</comment>
    <comment>factorial(..) is O(1); requires no loop; only a table lookup.</comment>
    <comment>if (n! &lt; inf &amp;&amp; k! &lt; inf)</comment>
    <comment>no numeric overflow?</comment>
    <comment>now this is completely safe and accurate</comment>
    <comment>quicker</comment>
    <comment>binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</comment>
  </method>
  <javadoc>
    <text>Returns the smallest &lt;code&gt;long &amp;gt;= value&lt;/code&gt;.
 * &lt;dt&gt;Examples: &lt;code&gt;1.0 -&gt; 1, 1.2 -&gt; 2, 1.9 -&gt; 2&lt;/code&gt;.
 * This method is safer than using (long) Math.ceil(value), because of possible rounding error.</text>
  </javadoc>
  <method type="long" name="ceil" />
  <javadoc>
    <text>Evaluates the series of Chebyshev polynomials Ti at argument x/2.
 * The series is given by
 * &lt;pre&gt;
 * N-1
 * - '
 * y  =   &gt;   coef[i] T (x/2)
 * -            i
 * i=0
 * &lt;/pre&gt;
 * Coefficients are stored in reverse order, i.e. the zero
 * order term is last in the array.  Note N is the number of
 * coefficients, not the order.
 * &lt;p&gt;
 * If coefficients are for the interval a to b, x must
 * have been transformed to x -&gt; 2(2x - b - a)/(b-a) before
 * entering the routine.  This maps x from (a, b) to (-1, 1),
 * over which the Chebyshev polynomials are defined.
 * &lt;p&gt;
 * If the coefficients are for the inverted interval, in
 * which (a, b) is mapped to (1/b, 1/a), the transformation
 * required is x -&gt; 2(2ab/x - b - a)/(b-a).  If b is infinity,
 * this becomes x -&gt; 4a/x - 1.
 * &lt;p&gt;
 * SPEED:
 * &lt;p&gt;
 * Taking advantage of the recurrence properties of the
 * Chebyshev polynomials, the routine requires one more
 * addition per loop than evaluating a nested polynomial of
 * the same degree.</text>
    <param>x argument to the polynomial.</param>
    <param>coef the coefficients of the polynomial.</param>
    <param>N the number of coefficients.</param>
  </javadoc>
  <method type="double" name="chbevl">
    <declaration type="double" name="b0" />
    <declaration type="int" name="p" />
    <declaration type="int" name="i" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the factorial of the argument.</text>
  </javadoc>
  <method type="long" name="fac1">
    <declaration type="long" name="i" />
    <declaration type="long" name="d" />
  </method>
  <javadoc>
    <text>Returns the factorial of the argument.</text>
  </javadoc>
  <method type="double" name="fac2">
    <declaration type="long" name="i" />
    <declaration type="double" name="d" />
  </method>
  <javadoc>
    <text>Instantly returns the factorial &lt;tt&gt;k!&lt;/tt&gt;.</text>
    <param>k must hold &lt;tt&gt;k &amp;gt;= 0&lt;/tt&gt;.</param>
  </javadoc>
  <method type="double" name="factorial">
    <declaration type="int" name="length1" />
    <declaration type="int" name="length2" />
  </method>
  <javadoc>
    <text>Returns the largest &lt;code&gt;long &amp;lt;= value&lt;/code&gt;.
 * &lt;dt&gt;Examples: &lt;code&gt;
 * 1.0 -&gt; 1, 1.2 -&gt; 1, 1.9 -&gt; 1 &lt;dt&gt;
 * 2.0 -&gt; 2, 2.2 -&gt; 2, 2.9 -&gt; 2 &lt;/code&gt;&lt;dt&gt;
 * This method is safer than using (long) Math.floor(value), because of possible rounding error.</text>
  </javadoc>
  <method type="long" name="floor" />
  <javadoc>
    <text>Returns &lt;tt&gt;log&lt;sub&gt;base&lt;/sub&gt;value&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="log" />
  <javadoc>
    <text>Returns &lt;tt&gt;log&lt;sub&gt;10&lt;/sub&gt;value&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="log10">
    <comment>1.0 / Math.log(10) == 0.43429448190325176</comment>
  </method>
  <javadoc>
    <text>Returns &lt;tt&gt;log&lt;sub&gt;2&lt;/sub&gt;value&lt;/tt&gt;.</text>
  </javadoc>
  <method type="double" name="log2">
    <comment>1.0 / Math.log(2) == 1.4426950408889634</comment>
  </method>
  <javadoc>
    <text>Returns &lt;tt&gt;log(k!)&lt;/tt&gt;.
 * Tries to avoid overflows.
 * For &lt;tt&gt;k&lt;30&lt;/tt&gt; simply looks up a table in O(1).
 * For &lt;tt&gt;k&gt;=30&lt;/tt&gt; uses stirlings approximation.</text>
    <param>k must hold &lt;tt&gt;k &amp;gt;= 0&lt;/tt&gt;.</param>
  </javadoc>
  <method type="double" name="logFactorial">
    <scope>
      <declaration type="double" name="r" />
      <declaration type="double" name="C0" />
      <declaration type="double" name="C1" />
      <declaration type="double" name="C3" />
      <declaration type="double" name="C5" />
      <declaration type="double" name="C7" />
    </scope>
  </method>
  <javadoc>
    <text>Instantly returns the factorial &lt;tt&gt;k!&lt;/tt&gt;.</text>
    <param>k must hold &lt;tt&gt;k &amp;gt;= 0 &amp;&amp; k &amp;lt; 21&lt;/tt&gt;.</param>
  </javadoc>
  <method type="long" name="longFactorial" />
  <javadoc>
    <text>Returns the StirlingCorrection.                 
 * &lt;p&gt;                                                                      
 * Correction term of the Stirling approximation for &lt;tt&gt;log(k!)&lt;/tt&gt;
 * (series in 1/k, or table values for small k)                         
 * with int parameter k.                                            
 * &lt;p&gt;                                                                                                                              
 * &lt;tt&gt;
 * log k! = (k + 1/2)log(k + 1) - (k + 1) + (1/2)log(2Pi) +
 * stirlingCorrection(k + 1)                                    
 * &lt;p&gt;                                                                      
 * log k! = (k + 1/2)log(k)     -  k      + (1/2)log(2Pi) +              
 * stirlingCorrection(k)
 * &lt;/tt&gt;</text>
  </javadoc>
  <method type="double" name="stirlingCorrection">
    <declaration type="double" name="C1" />
    <declaration type="double" name="C3" />
    <declaration type="double" name="C5" />
    <declaration type="double" name="C7" />
    <declaration type="double" name="r" />
    <scope />
    <comment>+1/12</comment>
    <comment>-1/360</comment>
    <comment>+1/1260</comment>
    <comment>-1/1680</comment>
  </method>
  <javadoc>
    <text>Equivalent to &lt;tt&gt;Math.round(binomial(n,k))&lt;/tt&gt;.</text>
  </javadoc>
  <method type="long" name="xlongBinomial" />
  <comment>Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose
is hereby granted without fee, provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in supporting documentation.
CERN makes no representations about the suitability of this software for any purpose.
It is provided "as is" without expressed or implied warranty.</comment>
  <comment>for method stirlingCorrection(...)</comment>
  <comment>for method logFactorial(...)</comment>
  <comment>log(k!) for k = 0, ..., 29</comment>
  <comment>k! for k = 0, ..., 20</comment>
  <comment>k! for k = 21, ..., 170</comment>
</class>
