<?xml version="1.0" encoding="UTF-8"?>
<class name="MightyStaticBin1D">
  <javadoc>
    <text>Static and the same as its superclass, except that it can do more: Additionally computes moments of arbitrary integer order, harmonic mean, geometric mean, etc.
 * Constructors need to be told what functionality is required for the given use case.
 * Only maintains aggregate measures (incrementally) - the added elements themselves are not kept.</text>
    <author>wolfgang.hoschek@cern.ch</author>
    <version>0.9, 03-Jul-99</version>
  </javadoc>
  <declaration type="boolean" name="hasSumOfLogarithms" />
  <declaration type="double" name="sumOfLogarithms" />
  <declaration type="boolean" name="hasSumOfInversions" />
  <declaration type="double" name="sumOfInversions" />
  <declaration type="double[]" name="sumOfPowers" />
  <javadoc>
    <text>Constructs and returns an empty bin with limited functionality but good performance; equivalent to &lt;tt&gt;MightyStaticBin1D(false,false,4)&lt;/tt&gt;.</text>
  </javadoc>
  <method type="constructor" name="MightyStaticBin1D" />
  <javadoc>
    <text>Constructs and returns an empty bin with the given capabilities.</text>
    <param>hasSumOfLogarithms  Tells whether {@link #sumOfLogarithms()} can return meaningful results.
 * Set this parameter to &lt;tt&gt;false&lt;/tt&gt; if measures of sum of logarithms, geometric mean and product are not required.
 * &lt;p&gt;</param>
    <param>hasSumOfInversions  Tells whether {@link #sumOfInversions()} can return meaningful results.
 * Set this parameter to &lt;tt&gt;false&lt;/tt&gt; if measures of sum of inversions, harmonic mean and sumOfPowers(-1) are not required.
 * &lt;p&gt;</param>
    <param>maxOrderForSumOfPowers  The maximum order &lt;tt&gt;k&lt;/tt&gt; for which {@link #sumOfPowers(int)} can return meaningful results.
 * Set this parameter to at least 3 if the skew is required, to at least 4 if the kurtosis is required.
 * In general, if moments are required set this parameter at least as large as the largest required moment.
 * This method always substitutes &lt;tt&gt;Math.max(2,maxOrderForSumOfPowers)&lt;/tt&gt; for the parameter passed in.
 * Thus, &lt;tt&gt;sumOfPowers(0..2)&lt;/tt&gt; always returns meaningful results.</param>
    <see>#hasSumOfPowers(int)</see>
    <see>#moment(int,double)</see>
  </javadoc>
  <method type="constructor" name="MightyStaticBin1D" />
  <javadoc>
    <text>Adds the part of the specified list between indexes &lt;tt&gt;from&lt;/tt&gt; (inclusive) and &lt;tt&gt;to&lt;/tt&gt; (inclusive) to the receiver.</text>
    <param>list the list of which elements shall be added.</param>
    <param>from the index of the first element to be added (inclusive).</param>
    <param>to the index of the last element to be added (inclusive).</param>
    <throws>IndexOutOfBoundsException if &lt;tt&gt;list.size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=list.size())&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="addAllOfFromTo">
    <scope />
    <scope />
    <scope />
    <comment>int max_k = this.min_k + this.sumOfPowers.length-1;</comment>
  </method>
  <javadoc>
    <text>Resets the values of all measures.</text>
  </javadoc>
  <method type="void" name="clearAllMeasures">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns a deep copy of the receiver.</text>
    <return>a deep copy of the receiver.</return>
  </javadoc>
  <method type="Object" name="clone">
    <declaration type="MightyStaticBin1D" name="clone" />
  </method>
  <javadoc>
    <text>Computes the deviations from the receiver's measures to another bin's measures.</text>
    <param>other the other bin to compare with</param>
    <return>a summary of the deviations.</return>
  </javadoc>
  <method type="String" name="compareWith">
    <declaration type="StringBuffer" name="buf" />
    <scope>
      <declaration type="MightyStaticBin1D" name="m" />
    </scope>
  </method>
  <javadoc>
    <text>Returns the geometric mean, which is &lt;tt&gt;Product( x[i] )&lt;sup&gt;1.0/size()&lt;/sup&gt;&lt;/tt&gt;.
 * This method tries to avoid overflows at the expense of an equivalent but somewhat inefficient definition:
 * &lt;tt&gt;geoMean = exp( Sum( Log(x[i]) ) / size())&lt;/tt&gt;.
 * Note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.</text>
    <return>the geometric mean; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfLogarithms()&lt;/tt&gt;.</return>
  </javadoc>
  <method type="double" name="geometricMean" />
  <javadoc>
    <text>Returns the maximum order &lt;tt&gt;k&lt;/tt&gt; for which sums of powers are retrievable, as specified upon instance construction.</text>
    <see>#hasSumOfPowers(int)</see>
    <see>#sumOfPowers(int)</see>
  </javadoc>
  <method type="int" name="getMaxOrderForSumOfPowers">
    <comment>order 0..2 is always recorded.
order 0 is size()
order 1 is sum()
order 2 is sum_xx()</comment>
  </method>
  <javadoc>
    <text>Returns the minimum order &lt;tt&gt;k&lt;/tt&gt; for which sums of powers are retrievable, as specified upon instance construction.</text>
    <see>#hasSumOfPowers(int)</see>
    <see>#sumOfPowers(int)</see>
  </javadoc>
  <method type="int" name="getMinOrderForSumOfPowers">
    <declaration type="int" name="minOrder" />
  </method>
  <javadoc>
    <text>Returns the harmonic mean, which is &lt;tt&gt;size() / Sum( 1/x[i] )&lt;/tt&gt;.
 * Remember: If the receiver contains at least one element of &lt;tt&gt;0.0&lt;/tt&gt;, the harmonic mean is &lt;tt&gt;0.0&lt;/tt&gt;.</text>
    <return>the harmonic mean; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfInversions()&lt;/tt&gt;.</return>
    <see>#hasSumOfInversions()</see>
  </javadoc>
  <method type="double" name="harmonicMean" />
  <javadoc>
    <text>Returns whether &lt;tt&gt;sumOfInversions()&lt;/tt&gt; can return meaningful results.</text>
    <return>&lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.
 * See the constructors for proper parametrization.</return>
  </javadoc>
  <method type="boolean" name="hasSumOfInversions" />
  <javadoc>
    <text>Tells whether &lt;tt&gt;sumOfLogarithms()&lt;/tt&gt; can return meaningful results.</text>
    <return>&lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.
 * See the constructors for proper parametrization.</return>
  </javadoc>
  <method type="boolean" name="hasSumOfLogarithms" />
  <javadoc>
    <text>Tells whether &lt;tt&gt;sumOfPowers(k)&lt;/tt&gt; can return meaningful results.
 * Defined as &lt;tt&gt;hasSumOfPowers(k) &lt;==&gt; getMinOrderForSumOfPowers() &lt;= k &amp;&amp; k &lt;= getMaxOrderForSumOfPowers()&lt;/tt&gt;.
 * A return value of &lt;tt&gt;true&lt;/tt&gt; implies that &lt;tt&gt;hasSumOfPowers(k-1) .. hasSumOfPowers(0)&lt;/tt&gt; will also return &lt;tt&gt;true&lt;/tt&gt;.
 * See the constructors for proper parametrization.
 * &lt;p&gt;
 * &lt;b&gt;Details&lt;/b&gt;: 
 * &lt;tt&gt;hasSumOfPowers(0..2)&lt;/tt&gt; will always yield &lt;tt&gt;true&lt;/tt&gt;.
 * &lt;tt&gt;hasSumOfPowers(-1) &lt;==&gt; hasSumOfInversions()&lt;/tt&gt;.</text>
    <return>&lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.</return>
    <see>#getMinOrderForSumOfPowers()</see>
    <see>#getMaxOrderForSumOfPowers()</see>
  </javadoc>
  <method type="boolean" name="hasSumOfPowers" />
  <javadoc>
    <text>Returns the kurtosis (aka excess), which is &lt;tt&gt;-3 + moment(4,mean()) / standardDeviation()&lt;sup&gt;4&lt;/sup&gt;&lt;/tt&gt;.</text>
    <return>the kurtosis; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPowers(4)&lt;/tt&gt;.</return>
    <see>#hasSumOfPowers(int)</see>
  </javadoc>
  <method type="double" name="kurtosis" />
  <javadoc>
    <text>Returns the moment of &lt;tt&gt;k&lt;/tt&gt;-th order with value &lt;tt&gt;c&lt;/tt&gt;,
 * which is &lt;tt&gt;Sum( (x[i]-c)&lt;sup&gt;k&lt;/sup&gt; ) / size()&lt;/tt&gt;.</text>
    <param>k the order; must be greater than or equal to zero.</param>
    <param>c any number.</param>
    <throws>IllegalArgumentException if &lt;tt&gt;k &lt; 0&lt;/tt&gt;.</throws>
    <return>&lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPower(k)&lt;/tt&gt;.</return>
  </javadoc>
  <method type="double" name="moment">
    <declaration type="int" name="maxOrder" />
    <declaration type="DoubleArrayList" name="sumOfPows" />
    <comment>checkOrder(k);</comment>
  </method>
  <javadoc>
    <text>Returns the product, which is &lt;tt&gt;Prod( x[i] )&lt;/tt&gt;.
 * In other words: &lt;tt&gt;x[0]*x[1]*...*x[size()-1]&lt;/tt&gt;.</text>
    <return>the product; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfLogarithms()&lt;/tt&gt;.</return>
    <see>#hasSumOfLogarithms()</see>
  </javadoc>
  <method type="double" name="product" />
  <javadoc>
    <text>Sets the range of orders in which sums of powers are to be computed.
 * In other words, &lt;tt&gt;sumOfPower(k)&lt;/tt&gt; will return &lt;tt&gt;Sum( x[i]^k )&lt;/tt&gt; if &lt;tt&gt;min_k &lt;= k &lt;= max_k || 0 &lt;= k &lt;= 2&lt;/tt&gt;
 * and throw an exception otherwise.</text>
    <see>#isLegalOrder(int)</see>
    <see>#sumOfPowers(int)</see>
    <see>#getRangeForSumOfPowers()</see>
  </javadoc>
  <method type="void" name="setMaxOrderForSumOfPowers">
    <scope />
    <scope />
    <comment>if (max_k &lt; ) throw new IllegalArgumentException();</comment>
  </method>
  <javadoc>
    <text>Returns the skew, which is &lt;tt&gt;moment(3,mean()) / standardDeviation()&lt;sup&gt;3&lt;/sup&gt;&lt;/tt&gt;.</text>
    <return>the skew; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPowers(3)&lt;/tt&gt;.</return>
    <see>#hasSumOfPowers(int)</see>
  </javadoc>
  <method type="double" name="skew" />
  <javadoc>
    <text>Returns the sum of inversions, which is &lt;tt&gt;Sum( 1 / x[i] )&lt;/tt&gt;.</text>
    <return>the sum of inversions; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfInversions()&lt;/tt&gt;.</return>
    <see>#hasSumOfInversions()</see>
  </javadoc>
  <method type="double" name="sumOfInversions">
    <comment>if (! this.hasSumOfInversions) throw new IllegalOperationException("You must specify upon instance construction that the sum of inversions shall be computed.");</comment>
  </method>
  <javadoc>
    <text>Returns the sum of logarithms, which is &lt;tt&gt;Sum( Log(x[i]) )&lt;/tt&gt;.</text>
    <return>the sum of logarithms; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfLogarithms()&lt;/tt&gt;.</return>
    <see>#hasSumOfLogarithms()</see>
  </javadoc>
  <method type="double" name="sumOfLogarithms">
    <comment>if (! this.hasSumOfLogarithms) throw new IllegalOperationException("You must specify upon instance construction that the sum of logarithms shall be computed.");</comment>
  </method>
  <javadoc>
    <text>Returns the &lt;tt&gt;k-th&lt;/tt&gt; order sum of powers, which is &lt;tt&gt;Sum( x[i]&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt;.</text>
    <param>k the order of the powers.</param>
    <return>the sum of powers; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPowers(k)&lt;/tt&gt;.</return>
    <see>#hasSumOfPowers(int)</see>
  </javadoc>
  <method type="double" name="sumOfPowers">
    <comment>checkOrder(k);</comment>
  </method>
  <javadoc>
    <text>Returns a String representation of the receiver.</text>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="StringBuffer" name="buf" />
    <scope />
    <scope />
    <declaration type="int" name="maxOrder" />
    <declaration type="int" name="maxPrintOrder" />
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>don't print tons of measures</comment>
  </method>
  <javadoc>
    <throws>IllegalOperationException if &lt;tt&gt;! isLegalOrder(k)&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="void" name="xcheckOrder">
    <comment>if (! isLegalOrder(k)) return Double.NaN;</comment>
    <comment>if (! xisLegalOrder(k)) throw new IllegalOperationException("Illegal order of sum of powers: k="+k+". Upon instance construction legal range was fixed to be "+getMinOrderForSumOfPowers()+" &lt;= k &lt;= "+getMaxOrderForSumOfPowers());</comment>
  </method>
  <javadoc>
    <text>Returns whether two bins are equal; 
 * They are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum, sumOfSquares, sumOfInversions and sumOfLogarithms.</text>
  </javadoc>
  <method type="boolean" name="xequals">
    <declaration type="MightyStaticBin1D" name="other" />
  </method>
  <javadoc>
    <text>Tells whether &lt;tt&gt;sumOfPowers(fromK) .. sumOfPowers(toK)&lt;/tt&gt; can return meaningful results.</text>
    <return>&lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.
 * See the constructors for proper parametrization.</return>
    <throws>IllegalArgumentException if &lt;tt&gt;fromK &gt; toK&lt;/tt&gt;.</throws>
  </javadoc>
  <method type="boolean" name="xhasSumOfPowers" />
  <javadoc>
    <text>Returns &lt;tt&gt;getMinOrderForSumOfPowers() &lt;= k &amp;&amp; k &lt;= getMaxOrderForSumOfPowers()&lt;/tt&gt;.</text>
  </javadoc>
  <method type="boolean" name="xisLegalOrder" />
  <comment>Sum( Log(x[i]) )</comment>
  <comment>Sum( 1/x[i] )</comment>
  <comment>Sum( x[i]^3 ) .. Sum( x[i]^max_k )</comment>
</class>
