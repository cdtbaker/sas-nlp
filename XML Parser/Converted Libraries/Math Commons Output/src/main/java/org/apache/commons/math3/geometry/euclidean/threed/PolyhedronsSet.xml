<?xml version="1.0" encoding="UTF-8"?>
<class name="PolyhedronsSet">
  <javadoc>
    <text>This class represents a 3D region: a set of polyhedrons.</text>
    <version>$Id: PolyhedronsSet.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Build a polyhedrons set representing the whole real line.</text>
  </javadoc>
  <method type="constructor" name="PolyhedronsSet" />
  <javadoc>
    <text>Build a polyhedrons set from a BSP tree.
 * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;</text>
    <param>tree inside/outside BSP tree representing the region</param>
  </javadoc>
  <method type="constructor" name="PolyhedronsSet" />
  <javadoc>
    <text>Build a polyhedrons set from a Boundary REPresentation (B-rep).
 * &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.&lt;/p&gt;
 * &lt;p&gt;The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polyhedrons with holes
 * or a set of disjoint polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link Region#checkPoint(Vector) checkPoint} method will
 * not be meaningful anymore.&lt;/p&gt;
 * &lt;p&gt;If the boundary is empty, the region will represent the whole
 * space.&lt;/p&gt;</text>
    <param>boundary collection of boundary elements, as a
 * collection of {@link SubHyperplane SubHyperplane} objects</param>
  </javadoc>
  <method type="constructor" name="PolyhedronsSet" />
  <javadoc>
    <text>Build a parallellepipedic box.</text>
    <param>xMin low bound along the x direction</param>
    <param>xMax high bound along the x direction</param>
    <param>yMin low bound along the y direction</param>
    <param>yMax high bound along the y direction</param>
    <param>zMin low bound along the z direction</param>
    <param>zMax high bound along the z direction</param>
  </javadoc>
  <method type="constructor" name="PolyhedronsSet" />
  <javadoc>
    <text>Build a parallellepipedic box boundary.</text>
    <param>xMin low bound along the x direction</param>
    <param>xMax high bound along the x direction</param>
    <param>yMin low bound along the y direction</param>
    <param>yMax high bound along the y direction</param>
    <param>zMin low bound along the z direction</param>
    <param>zMax high bound along the z direction</param>
    <return>boundary tree</return>
  </javadoc>
  <method type="BSPTree&lt;Euclidean3D&gt;" name="buildBoundary">
    <declaration type="Plane" name="pxMin" />
    <declaration type="Plane" name="pxMax" />
    <declaration type="Plane" name="pyMin" />
    <declaration type="Plane" name="pyMax" />
    <declaration type="Plane" name="pzMin" />
    <declaration type="Plane" name="pzMax" />
    <declaration type="Region&lt;Euclidean3D&gt;" name="boundary" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PolyhedronsSet" name="buildNew" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="computeGeometricalProperties">
    <scope />
    <scope />
    <comment>compute the contribution of all boundary facets</comment>
    <comment>the polyhedrons set as a finite outside</comment>
    <comment>surrounded by an infinite inside</comment>
    <comment>the polyhedrons set is finite, apply the remaining scaling factors</comment>
  </method>
  <javadoc>
    <text>Visitor computing geometrical properties.</text>
  </javadoc>
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="FacetsContributionVisitor" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Order" name="visitOrder" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitInternalNode">
    <declaration type="BoundaryAttribute&lt;Euclidean3D&gt;" name="attribute" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitLeafNode" />
  <javadoc>
    <text>Add he contribution of a boundary facet.</text>
    <param>facet boundary facet</param>
    <param>reversed if true, the facet has the inside on its plus side</param>
  </javadoc>
  <method type="void" name="addContribution">
    <declaration type="Region&lt;Euclidean2D&gt;" name="polygon" />
    <declaration type="double" name="area" />
    <scope />
    <scope>
      <declaration type="Plane" name="plane" />
      <declaration type="Vector3D" name="facetB" />
      <declaration type="double" name="scaled" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the first sub-hyperplane crossed by a semi-infinite line.</text>
    <param>point start point of the part of the line considered</param>
    <param>line line to consider (contains point)</param>
    <return>the first sub-hyperplaned crossed by the line after the
 * given point, or null if the line does not intersect any
 * sub-hyperplaned</return>
  </javadoc>
  <method type="SubHyperplane&lt;Euclidean3D&gt;" name="firstIntersection" />
  <javadoc>
    <text>Get the first sub-hyperplane crossed by a semi-infinite line.</text>
    <param>node current node</param>
    <param>point start point of the part of the line considered</param>
    <param>line line to consider (contains point)</param>
    <return>the first sub-hyperplaned crossed by the line after the
 * given point, or null if the line does not intersect any
 * sub-hyperplaned</return>
  </javadoc>
  <method type="SubHyperplane&lt;Euclidean3D&gt;" name="recurseFirstIntersection">
    <declaration type="SubHyperplane&lt;Euclidean3D&gt;" name="cut" />
    <scope />
    <declaration type="BSPTree&lt;Euclidean3D&gt;" name="minus" />
    <declaration type="BSPTree&lt;Euclidean3D&gt;" name="plus" />
    <declaration type="Plane" name="plane" />
    <declaration type="double" name="offset" />
    <declaration type="boolean" name="in" />
    <declaration type="BSPTree&lt;Euclidean3D&gt;" name="near" />
    <declaration type="BSPTree&lt;Euclidean3D&gt;" name="far" />
    <scope />
    <scope />
    <scope>
      <declaration type="SubHyperplane&lt;Euclidean3D&gt;" name="facet" />
      <scope />
    </scope>
    <declaration type="SubHyperplane&lt;Euclidean3D&gt;" name="crossed" />
    <scope />
    <scope>
      <declaration type="Vector3D" name="hit3D" />
      <scope>
        <declaration type="SubHyperplane&lt;Euclidean3D&gt;" name="facet" />
        <scope />
      </scope>
    </scope>
    <comment>establish search order</comment>
    <comment>search in the cut hyperplane</comment>
    <comment>search in the near branch</comment>
    <comment>search in the cut hyperplane</comment>
    <comment>search in the far branch</comment>
  </method>
  <javadoc>
    <text>Check if a point belongs to the boundary part of a node.</text>
    <param>point point to check</param>
    <param>node node containing the boundary facet to check</param>
    <return>the boundary facet this points belongs to (or null if it
 * does not belong to any boundary facet)</return>
  </javadoc>
  <method type="SubHyperplane&lt;Euclidean3D&gt;" name="boundaryFacet">
    <declaration type="Vector2D" name="point2D" />
    <declaration type="BoundaryAttribute&lt;Euclidean3D&gt;" name="attribute" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Rotate the region around the specified point.
 * &lt;p&gt;The instance is not modified, a new instance is created.&lt;/p&gt;</text>
    <param>center rotation center</param>
    <param>rotation vectorial rotation operator</param>
    <return>a new instance representing the rotated region</return>
  </javadoc>
  <method type="PolyhedronsSet" name="rotate" />
  <javadoc>
    <text>3D rotation as a Transform.</text>
  </javadoc>
  <javadoc>
    <text>Center point of the rotation.</text>
  </javadoc>
  <declaration type="Vector3D" name="center" />
  <javadoc>
    <text>Vectorial rotation.</text>
  </javadoc>
  <declaration type="Rotation" name="rotation" />
  <javadoc>
    <text>Cached original hyperplane.</text>
  </javadoc>
  <declaration type="Plane" name="cachedOriginal" />
  <javadoc>
    <text>Cached 2D transform valid inside the cached original hyperplane.</text>
  </javadoc>
  <declaration type="Transform&lt;Euclidean2D,Euclidean1D&gt;" name="cachedTransform" />
  <javadoc>
    <text>Build a rotation transform.</text>
    <param>center center point of the rotation</param>
    <param>rotation vectorial rotation</param>
  </javadoc>
  <method type="constructor" name="RotationTransform" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="apply">
    <declaration type="Vector3D" name="delta" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Plane" name="apply" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="SubHyperplane&lt;Euclidean2D&gt;" name="apply">
    <scope>
      <declaration type="Plane" name="oPlane" />
      <declaration type="Plane" name="tPlane" />
      <declaration type="Vector3D" name="p00" />
      <declaration type="Vector3D" name="p10" />
      <declaration type="Vector3D" name="p01" />
      <declaration type="Vector2D" name="tP00" />
      <declaration type="Vector2D" name="tP10" />
      <declaration type="Vector2D" name="tP01" />
      <declaration type="AffineTransform" name="at" />
    </scope>
    <comment>we have changed hyperplane, reset the in-hyperplane transform</comment>
  </method>
  <javadoc>
    <text>Translate the region by the specified amount.
 * &lt;p&gt;The instance is not modified, a new instance is created.&lt;/p&gt;</text>
    <param>translation translation to apply</param>
    <return>a new instance representing the translated region</return>
  </javadoc>
  <method type="PolyhedronsSet" name="translate" />
  <javadoc>
    <text>3D translation as a transform.</text>
  </javadoc>
  <javadoc>
    <text>Translation vector.</text>
  </javadoc>
  <declaration type="Vector3D" name="translation" />
  <javadoc>
    <text>Cached original hyperplane.</text>
  </javadoc>
  <declaration type="Plane" name="cachedOriginal" />
  <javadoc>
    <text>Cached 2D transform valid inside the cached original hyperplane.</text>
  </javadoc>
  <declaration type="Transform&lt;Euclidean2D,Euclidean1D&gt;" name="cachedTransform" />
  <javadoc>
    <text>Build a translation transform.</text>
    <param>translation translation vector</param>
  </javadoc>
  <method type="constructor" name="TranslationTransform" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="apply" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Plane" name="apply" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="SubHyperplane&lt;Euclidean2D&gt;" name="apply">
    <scope>
      <declaration type="Plane" name="oPlane" />
      <declaration type="Plane" name="tPlane" />
      <declaration type="Vector2D" name="shift" />
      <declaration type="AffineTransform" name="at" />
    </scope>
    <comment>we have changed hyperplane, reset the in-hyperplane transform</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
