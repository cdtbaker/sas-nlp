<?xml version="1.0" encoding="UTF-8"?>
<class name="NonLinearConjugateGradientOptimizer">
  <javadoc>
    <text>Non-linear conjugate gradient optimizer.
 * &lt;br/&gt;
 * This class supports both the Fletcher-Reeves and the Polak-Ribière
 * update formulas for the conjugate search directions.
 * It also supports optional preconditioning.
 * &lt;br/&gt;
 * Constraints are not supported: the call to{@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.</text>
    <version>$Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Update formula for the beta parameter.</text>
  </javadoc>
  <declaration type="Formula" name="updateFormula" />
  <javadoc>
    <text>Preconditioner (may be null).</text>
  </javadoc>
  <declaration type="Preconditioner" name="preconditioner" />
  <javadoc>
    <text>solver to use in the line search (may be null).</text>
  </javadoc>
  <declaration type="UnivariateSolver" name="solver" />
  <javadoc>
    <text>Initial step used to bracket the optimum in line search.</text>
  </javadoc>
  <declaration type="double" name="initialStep" />
  <javadoc>
    <text>Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.</text>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.</param>
    <param>checker Convergence checker.</param>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <text>Available choices of update formulas for the updating the parameter
 * that is used to compute the successive conjugate search directions.
 * For non-linear conjugate gradients, there are
 * two formulas:
 * &lt;ul&gt;
 * &lt;li&gt;Fletcher-Reeves formula&lt;/li&gt;
 * &lt;li&gt;Polak-Ribière formula&lt;/li&gt;
 * &lt;/ul&gt;
 * On the one hand, the Fletcher-Reeves formula is guaranteed to converge
 * if the start point is close enough of the optimum whether the
 * Polak-Ribière formula may not converge in rare cases. On the
 * other hand, the Polak-Ribière formula is often faster when it
 * does converge. Polak-Ribière is often used.</text>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Fletcher-Reeves formula.</text>
  </javadoc>
  <javadoc>
    <text>Polak-Ribière formula.</text>
  </javadoc>
  <javadoc>
    <text>The initial step is a factor with respect to the search direction
 * (which itself is roughly related to the gradient of the function).
 * &lt;br/&gt;
 * It is used to find an interval that brackets the optimum in line
 * search.</text>
    <since>3.1</since>
  </javadoc>
  <javadoc>
    <text>Initial step.</text>
  </javadoc>
  <declaration type="double" name="initialStep" />
  <javadoc>
    <param>step Initial step for the bracket search.</param>
  </javadoc>
  <method type="constructor" name="BracketingStep" />
  <javadoc>
    <text>Gets the initial step.</text>
    <return>the initial step.</return>
  </javadoc>
  <method type="double" name="getBracketingStep" />
  <javadoc>
    <text>Constructor with default {@link IdentityPreconditioner preconditioner}.</text>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.</param>
    <param>checker Convergence checker.</param>
    <param>lineSearchSolver Solver to use during line search.</param>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.</param>
    <param>checker Convergence checker.</param>
    <param>lineSearchSolver Solver to use during line search.</param>
    <param>preconditioner Preconditioner.</param>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>optData Optimization data. In addition to those documented in{@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])GradientMultivariateOptimizer}, this method will register the following data:
 * &lt;ul&gt;
 * &lt;li&gt;{@link BracketingStep}&lt;/li&gt;
 * &lt;/ul&gt;</param>
    <return>{@inheritDoc}</return>
    <throws>TooManyEvaluationsException if the maximal number of
 * evaluations (of the objective function) is exceeded.</throws>
  </javadoc>
  <method type="PointValuePair" name="optimize">
    <comment>Set up base class and perform computation.</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PointValuePair" name="doOptimize">
    <declaration type="ConvergenceChecker&lt;PointValuePair&gt;" name="checker" />
    <declaration type="double[]" name="point" />
    <declaration type="GoalType" name="goal" />
    <declaration type="int" name="n" />
    <declaration type="double[]" name="r" />
    <scope>
      <scope />
    </scope>
    <declaration type="double[]" name="steepestDescent" />
    <declaration type="double[]" name="searchDirection" />
    <declaration type="double" name="delta" />
    <scope />
    <declaration type="PointValuePair" name="current" />
    <declaration type="int" name="maxEval" />
    <scope>
      <declaration type="double" name="objective" />
      <declaration type="PointValuePair" name="previous" />
      <scope />
      <declaration type="UnivariateFunction" name="lsf" />
      <declaration type="double" name="uB" />
      <declaration type="double" name="step" />
      <scope />
      <scope>
        <scope />
      </scope>
      <declaration type="double" name="deltaOld" />
      <declaration type="double[]" name="newSteepestDescent" />
      <scope />
      <declaration type="double" name="beta" />
      <declaration type="double" name="deltaMid" />
      <scope />
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Initial search direction.</comment>
    <comment>We have found an optimum.</comment>
    <comment>Find the optimal step in the search direction.</comment>
    <comment>XXX Last parameters is set to a value close to zero in order to</comment>
    <comment>work around the divergence problem in the "testCircleFitting"</comment>
    <comment>unit test (see MATH-439).</comment>
    <comment>Subtract used up evaluations.</comment>
    <comment>Validate new point.</comment>
    <comment>Compute beta.</comment>
    <comment>Should never happen.</comment>
    <comment>Compute conjugate search direction.</comment>
    <comment>Break conjugation: reset search direction.</comment>
    <comment>Compute new conjugate search direction.</comment>
  </method>
  <javadoc>
    <text>Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
    <param>optData Optimization data.
 * The following data will be looked for:
 * &lt;ul&gt;
 * &lt;li&gt;{@link BracketingStep}&lt;/li&gt;
 * &lt;/ul&gt;</param>
  </javadoc>
  <method type="void" name="parseOptimizationData">
    <scope>
      <scope />
    </scope>
    <comment>Allow base class to register its own data.</comment>
    <comment>The existing values (as set by the previous call) are reused if</comment>
    <comment>not provided in the argument list.</comment>
    <comment>If more data must be parsed, this statement _must_ be</comment>
    <comment>changed to "continue".</comment>
  </method>
  <javadoc>
    <text>Finds the upper bound b ensuring bracketing of a root between a and b.</text>
    <param>f function whose root must be bracketed.</param>
    <param>a lower bound of the interval.</param>
    <param>h initial step to try.</param>
    <return>b such that f(a) and f(b) have opposite signs.</return>
    <throws>MathIllegalStateException if no bracket can be found.</throws>
  </javadoc>
  <method type="double" name="findUpperBound">
    <declaration type="double" name="yA" />
    <declaration type="double" name="yB" />
    <scope>
      <declaration type="double" name="b" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Default identity preconditioner.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double[]" name="precondition" />
  <javadoc>
    <text>Internal class for line search.
 * &lt;p&gt;
 * The function represented by this class is the dot product of
 * the objective function gradient and the search direction. Its
 * value is zero when the gradient is orthogonal to the search
 * direction, i.e. when the objective function value is a local
 * extremum along the search direction.
 * &lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>Current point.</text>
  </javadoc>
  <declaration type="double[]" name="currentPoint" />
  <javadoc>
    <text>Search direction.</text>
  </javadoc>
  <declaration type="double[]" name="searchDirection" />
  <javadoc>
    <param>point Current point.</param>
    <param>direction Search direction.</param>
  </javadoc>
  <method type="constructor" name="LineSearchFunction" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="value">
    <declaration type="double[]" name="shiftedPoint" />
    <scope />
    <declaration type="double[]" name="gradient" />
    <declaration type="double" name="dotProduct" />
    <scope />
    <comment>current point in the search direction</comment>
    <comment>gradient of the objective function</comment>
    <comment>dot product with the search direction</comment>
  </method>
  <javadoc>
    <throws>MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.</throws>
  </javadoc>
  <method type="void" name="checkParameters">
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
