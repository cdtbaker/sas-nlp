<?xml version="1.0" encoding="UTF-8"?>
<class name="FieldVector">
  <javadoc>
    <text>Interface defining a field-valued vector with basic algebraic operations.
 * &lt;p&gt;
 * vector element indexing is 0-based -- e.g., &lt;code&gt;getEntry(0)&lt;/code&gt;
 * returns the first element of the vector.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The various &lt;code&gt;mapXxx&lt;/code&gt; and &lt;code&gt;mapXxxToSelf&lt;/code&gt; methods operate
 * on vectors element-wise, i.e. they perform the same operation (adding a scalar,
 * applying a function ...) on each element in turn. The &lt;code&gt;mapXxx&lt;/code&gt;
 * versions create a new vector to hold the result and do not change the instance.
 * The &lt;code&gt;mapXxxToSelf&lt;/code&gt; versions use the instance itself to store the
 * results, so the instance is changed by these methods. In both cases, the result
 * vector is returned by the methods, this allows to use the &lt;i&gt;fluent API&lt;/i&gt;
 * style, like this:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Note that as almost all operations on {@link FieldElement} throw {@link NullArgumentException} when operating on a null element, it is the responsibility
 * of &lt;code&gt;FieldVector&lt;/code&gt; implementations to make sure no null elements
 * are inserted into the vector. This must be done in all constructors and
 * all setters.
 * &lt;p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <version>$Id: FieldVector.java 1455233 2013-03-11 17:00:41Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <method name="getField" type="Field&lt;T&gt;" />
  <javadoc>
    <text>Get the type of field elements of the vector.</text>
    <return>type of field elements of the vector</return>
  </javadoc>
  <method name="copy" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Returns a (deep) copy of this.</text>
    <return>vector copy</return>
  </javadoc>
  <method name="add" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Compute the sum of {@code this} and {@code v}.</text>
    <param>v vector to be added</param>
    <return>{@code this + v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as {@code this}</throws>
  </javadoc>
  <method name="subtract" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Compute {@code this} minus {@code v}.</text>
    <param>v vector to be subtracted</param>
    <return>{@code this - v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as {@code this}</throws>
  </javadoc>
  <method name="mapAdd" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map an addition operation to each entry.</text>
    <param>d value to be added to each entry</param>
    <return>{@code this + d}</return>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
  </javadoc>
  <method name="mapAddToSelf" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map an addition operation to each entry.
 * &lt;p&gt;The instance &lt;strong&gt;is&lt;/strong&gt; changed by this method.&lt;/p&gt;</text>
    <param>d value to be added to each entry</param>
    <return>for convenience, return {@code this}</return>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
  </javadoc>
  <method name="mapSubtract" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map a subtraction operation to each entry.</text>
    <param>d value to be subtracted to each entry</param>
    <return>{@code this - d}</return>
    <throws>NullArgumentException if {@code d} is {@code null}</throws>
  </javadoc>
  <method name="mapSubtractToSelf" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map a subtraction operation to each entry.
 * &lt;p&gt;The instance &lt;strong&gt;is&lt;/strong&gt; changed by this method.&lt;/p&gt;</text>
    <param>d value to be subtracted to each entry</param>
    <return>for convenience, return {@code this}</return>
    <throws>NullArgumentException if {@code d} is {@code null}</throws>
  </javadoc>
  <method name="mapMultiply" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map a multiplication operation to each entry.</text>
    <param>d value to multiply all entries by</param>
    <return>{@code this * d}</return>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
  </javadoc>
  <method name="mapMultiplyToSelf" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map a multiplication operation to each entry.
 * &lt;p&gt;The instance &lt;strong&gt;is&lt;/strong&gt; changed by this method.&lt;/p&gt;</text>
    <param>d value to multiply all entries by</param>
    <return>for convenience, return {@code this}</return>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
  </javadoc>
  <method name="mapDivide" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map a division operation to each entry.</text>
    <param>d value to divide all entries by</param>
    <return>{@code this / d}</return>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <throws>MathArithmeticException if {@code d} is zero.</throws>
  </javadoc>
  <method name="mapDivideToSelf" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map a division operation to each entry.
 * &lt;p&gt;The instance &lt;strong&gt;is&lt;/strong&gt; changed by this method.&lt;/p&gt;</text>
    <param>d value to divide all entries by</param>
    <return>for convenience, return {@code this}</return>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <throws>MathArithmeticException if {@code d} is zero.</throws>
  </javadoc>
  <method name="mapInv" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map the 1/x function to each entry.</text>
    <return>a vector containing the result of applying the function to each entry.</return>
    <throws>MathArithmeticException if one of the entries is zero.</throws>
  </javadoc>
  <method name="mapInvToSelf" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Map the 1/x function to each entry.
 * &lt;p&gt;The instance &lt;strong&gt;is&lt;/strong&gt; changed by this method.&lt;/p&gt;</text>
    <return>for convenience, return {@code this}</return>
    <throws>MathArithmeticException if one of the entries is zero.</throws>
  </javadoc>
  <method name="ebeMultiply" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Element-by-element multiplication.</text>
    <param>v vector by which instance elements must be multiplied</param>
    <return>a vector containing {@code this[i] * v[i]} for all {@code i}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as {@code this}</throws>
  </javadoc>
  <method name="ebeDivide" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Element-by-element division.</text>
    <param>v vector by which instance elements must be divided</param>
    <return>a vector containing {@code this[i] / v[i]} for all {@code i}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as {@code this}</throws>
    <throws>MathArithmeticException if one entry of {@code v} is zero.</throws>
  </javadoc>
  <method name="getData" type="T[]" />
  <javadoc>
    <text>Returns vector entries as a T array.</text>
    <return>T array of entries</return>
    <deprecated>as of 3.1, to be removed in 4.0. Please use the {@link #toArray()} method instead.</deprecated>
  </javadoc>
  <method name="dotProduct" type="T" />
  <javadoc>
    <text>Compute the dot product.</text>
    <param>v vector with which dot product should be computed</param>
    <return>the scalar dot product of {@code this} and {@code v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as {@code this}</throws>
  </javadoc>
  <method name="projection" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Find the orthogonal projection of this vector onto another vector.</text>
    <param>v vector onto which {@code this} must be projected</param>
    <return>projection of {@code this} onto {@code v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as {@code this}</throws>
    <throws>MathArithmeticException if {@code v} is the null vector.</throws>
  </javadoc>
  <method name="outerProduct" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Compute the outer product.</text>
    <param>v vector with which outer product should be computed</param>
    <return>the matrix outer product between instance and v</return>
  </javadoc>
  <method name="getEntry" type="T" />
  <javadoc>
    <text>Returns the entry in the specified index.</text>
    <param>index Index location of entry to be fetched.</param>
    <return>the vector entry at {@code index}.</return>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <see>#setEntry(int,FieldElement)</see>
  </javadoc>
  <method name="setEntry" type="void" />
  <javadoc>
    <text>Set a single element.</text>
    <param>index element index.</param>
    <param>value new value for the element.</param>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <see>#getEntry(int)</see>
  </javadoc>
  <method name="getDimension" type="int" />
  <javadoc>
    <text>Returns the size of the vector.</text>
    <return>size</return>
  </javadoc>
  <method name="append" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Construct a vector by appending a vector to this vector.</text>
    <param>v vector to append to this one.</param>
    <return>a new vector</return>
  </javadoc>
  <method name="append" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Construct a vector by appending a T to this vector.</text>
    <param>d T to append.</param>
    <return>a new vector</return>
  </javadoc>
  <method name="getSubVector" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Get a subvector from consecutive elements.</text>
    <param>index index of first element.</param>
    <param>n number of elements to be retrieved.</param>
    <return>a vector containing n elements.</return>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <throws>NotPositiveException if the number of elements if not positive.</throws>
  </javadoc>
  <method name="setSubVector" type="void" />
  <javadoc>
    <text>Set a set of consecutive elements.</text>
    <param>index index of first element to be set.</param>
    <param>v vector containing the values to set.</param>
    <throws>OutOfRangeException if the index is not valid.</throws>
  </javadoc>
  <method name="set" type="void" />
  <javadoc>
    <text>Set all elements to a single value.</text>
    <param>value single value to set for all elements</param>
  </javadoc>
  <method name="toArray" type="T[]" />
  <javadoc>
    <text>Convert the vector to a T array.
 * &lt;p&gt;The array is independent from vector data, it's elements
 * are copied.&lt;/p&gt;</text>
    <return>array containing a copy of vector elements</return>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
