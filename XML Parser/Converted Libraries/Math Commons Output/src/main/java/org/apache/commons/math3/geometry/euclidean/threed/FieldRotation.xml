<?xml version="1.0" encoding="UTF-8"?>
<class name="FieldRotation">
  <javadoc>
    <text>This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.
 * &lt;p&gt;Instance of this class are guaranteed to be immutable.&lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <version>$Id: FieldRotation.java 1454903 2013-03-10 19:44:31Z luc $</version>
    <see>FieldVector3D</see>
    <see>RotationOrder</see>
    <since>3.2</since>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Scalar coordinate of the quaternion.</text>
  </javadoc>
  <declaration type="T" name="q0" />
  <javadoc>
    <text>First coordinate of the vectorial part of the quaternion.</text>
  </javadoc>
  <declaration type="T" name="q1" />
  <javadoc>
    <text>Second coordinate of the vectorial part of the quaternion.</text>
  </javadoc>
  <declaration type="T" name="q2" />
  <javadoc>
    <text>Third coordinate of the vectorial part of the quaternion.</text>
  </javadoc>
  <declaration type="T" name="q3" />
  <javadoc>
    <text>Build a rotation from the quaternion coordinates.
 * &lt;p&gt;A rotation can be built from a &lt;em&gt;normalized&lt;/em&gt; quaternion,
 * i.e. a quaternion for which q&lt;sub&gt;0&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
 * q&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; + q&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
 * q&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. If the quaternion is not normalized,
 * the constructor can normalize it in a preprocessing step.&lt;/p&gt;
 * &lt;p&gt;Note that some conventions put the scalar part of the quaternion
 * as the 4&lt;sup&gt;th&lt;/sup&gt; component and the vector part as the first three
 * components. This is &lt;em&gt;not&lt;/em&gt; our convention. We put the scalar part
 * as the first component.&lt;/p&gt;</text>
    <param>q0 scalar part of the quaternion</param>
    <param>q1 first coordinate of the vectorial part of the quaternion</param>
    <param>q2 second coordinate of the vectorial part of the quaternion</param>
    <param>q3 third coordinate of the vectorial part of the quaternion</param>
    <param>needsNormalization if true, the coordinates are considered
 * not to be normalized, a normalization preprocessing step is performed
 * before using them</param>
  </javadoc>
  <method type="constructor" name="FieldRotation">
    <scope>
      <declaration type="T" name="inv" />
    </scope>
    <scope />
    <comment>normalization preprocessing</comment>
  </method>
  <javadoc>
    <text>Build a rotation from an axis and an angle.
 * &lt;p&gt;We use the convention that angles are oriented according to
 * the effect of the rotation on vectors around the axis. That means
 * that if (i, j, k) is a direct frame and if we first provide +k as
 * the axis and &amp;pi;/2 as the angle to this constructor, and then{@link #applyTo(FieldVector3D) apply} the instance to +i, we will get
 * +j.&lt;/p&gt;
 * &lt;p&gt;Another way to represent our convention is to say that a rotation
 * of angle &amp;theta; about the unit vector (x, y, z) is the same as the
 * rotation build from quaternion components { cos(-&amp;theta;/2),
 * x * sin(-&amp;theta;/2), y * sin(-&amp;theta;/2), z * sin(-&amp;theta;/2) }.
 * Note the minus sign on the angle!&lt;/p&gt;
 * &lt;p&gt;On the one hand this convention is consistent with a vectorial
 * perspective (moving vectors in fixed frames), on the other hand it
 * is different from conventions with a frame perspective (fixed vectors
 * viewed from different frames) like the ones used for example in spacecraft
 * attitude community or in the graphics community.&lt;/p&gt;</text>
    <param>axis axis around which to rotate</param>
    <param>angle rotation angle.</param>
    <exception>MathIllegalArgumentException if the axis norm is zero</exception>
  </javadoc>
  <method type="constructor" name="FieldRotation">
    <declaration type="T" name="norm" />
    <scope />
    <declaration type="T" name="halfAngle" />
    <declaration type="T" name="coeff" />
  </method>
  <javadoc>
    <text>Build a rotation from a 3X3 matrix.
 * &lt;p&gt;Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m&lt;sup&gt;T&lt;/sup&gt; = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.&lt;/p&gt;
 * &lt;p&gt;When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.&lt;p&gt;</text>
    <param>m rotation matrix</param>
    <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
    <exception>NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative</exception>
  </javadoc>
  <method type="constructor" name="FieldRotation">
    <scope />
    <declaration type="T[][]" name="ort" />
    <declaration type="T" name="d0" />
    <declaration type="T" name="d1" />
    <declaration type="T" name="d2" />
    <declaration type="T" name="det" />
    <scope />
    <declaration type="T[]" name="quat" />
    <comment>dimension check</comment>
    <comment>compute a "close" orthogonal matrix</comment>
    <comment>check the sign of the determinant</comment>
  </method>
  <javadoc>
    <text>Build the rotation that transforms a pair of vector into another pair.
 * &lt;p&gt;Except for possible scale factors, if the instance were applied to
 * the pair (u&lt;sub&gt;1&lt;/sub&gt;, u&lt;sub&gt;2&lt;/sub&gt;) it will produce the pair
 * (v&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;).&lt;/p&gt;
 * &lt;p&gt;If the angular separation between u&lt;sub&gt;1&lt;/sub&gt; and u&lt;sub&gt;2&lt;/sub&gt; is
 * not the same as the angular separation between v&lt;sub&gt;1&lt;/sub&gt; and
 * v&lt;sub&gt;2&lt;/sub&gt;, then a corrected v'&lt;sub&gt;2&lt;/sub&gt; will be used rather than
 * v&lt;sub&gt;2&lt;/sub&gt;, the corrected vector will be in the (v&lt;sub&gt;1&lt;/sub&gt;,
 * v&lt;sub&gt;2&lt;/sub&gt;) plane.&lt;/p&gt;</text>
    <param>u1 first vector of the origin pair</param>
    <param>u2 second vector of the origin pair</param>
    <param>v1 desired image of u1 by the rotation</param>
    <param>v2 desired image of u2 by the rotation</param>
    <exception>MathArithmeticException if the norm of one of the vectors is zero,
 * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)</exception>
  </javadoc>
  <method type="constructor" name="FieldRotation">
    <declaration type="FieldVector3D&lt;T&gt;" name="u3" />
    <declaration type="FieldVector3D&lt;T&gt;" name="v3" />
    <declaration type="T[][]" name="array" />
    <declaration type="T[]" name="quat" />
    <comment>build orthonormalized base from u1, u2</comment>
    <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
    <comment>build an orthonormalized base from v1, v2</comment>
    <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
    <comment>buid a matrix transforming the first base into the second one</comment>
  </method>
  <javadoc>
    <text>Build one of the rotations that transform one vector into another one.
 * &lt;p&gt;Except for a possible scale factor, if the instance were
 * applied to the vector u it will produce the vector v. There is an
 * infinite number of such rotations, this constructor choose the
 * one with the smallest associated angle (i.e. the one whose axis
 * is orthogonal to the (u, v) plane). If u and v are colinear, an
 * arbitrary rotation axis is chosen.&lt;/p&gt;</text>
    <param>u origin vector</param>
    <param>v desired image of u by the rotation</param>
    <exception>MathArithmeticException if the norm of one of the vectors is zero</exception>
  </javadoc>
  <method type="constructor" name="FieldRotation">
    <declaration type="T" name="normProduct" />
    <scope />
    <declaration type="T" name="dot" />
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="w" />
    </scope>
    <scope>
      <declaration type="T" name="coeff" />
      <declaration type="FieldVector3D&lt;T&gt;" name="q" />
    </scope>
    <comment>special case u = -v: we select a PI angle rotation around</comment>
    <comment>an arbitrary vector orthogonal to u</comment>
    <comment>general case: (u, v) defines a plane, we select</comment>
    <comment>the shortest possible rotation: axis orthogonal to this plane</comment>
  </method>
  <javadoc>
    <text>Build a rotation from three Cardan or Euler elementary rotations.
 * &lt;p&gt;Cardan rotations are three successive rotations around the
 * canonical axes X, Y and Z, each axis being used once. There are
 * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
 * rotations are three successive rotations around the canonical
 * axes X, Y and Z, the first and last rotations being around the
 * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
 * YZY, ZXZ and ZYZ), the most popular one being ZXZ.&lt;/p&gt;
 * &lt;p&gt;Beware that many people routinely use the term Euler angles even
 * for what really are Cardan angles (this confusion is especially
 * widespread in the aerospace business where Roll, Pitch and Yaw angles
 * are often wrongly tagged as Euler angles).&lt;/p&gt;</text>
    <param>order order of rotations to use</param>
    <param>alpha1 angle of the first elementary rotation</param>
    <param>alpha2 angle of the second elementary rotation</param>
    <param>alpha3 angle of the third elementary rotation</param>
  </javadoc>
  <method type="constructor" name="FieldRotation">
    <declaration type="T" name="one" />
    <declaration type="FieldRotation&lt;T&gt;" name="r1" />
    <declaration type="FieldRotation&lt;T&gt;" name="r2" />
    <declaration type="FieldRotation&lt;T&gt;" name="r3" />
    <declaration type="FieldRotation&lt;T&gt;" name="composed" />
  </method>
  <javadoc>
    <text>Convert an orthogonal rotation matrix to a quaternion.</text>
    <param>ort orthogonal rotation matrix</param>
    <return>quaternion corresponding to the matrix</return>
  </javadoc>
  <method type="T[]" name="mat2quat">
    <declaration type="T[]" name="quat" />
    <declaration type="T" name="s" />
    <scope>
      <declaration type="T" name="inv" />
    </scope>
    <scope>
      <scope>
        <declaration type="T" name="inv" />
      </scope>
      <scope>
        <scope>
          <declaration type="T" name="inv" />
        </scope>
        <scope>
          <declaration type="T" name="inv" />
        </scope>
      </scope>
    </scope>
    <comment>There are different ways to compute the quaternions elements</comment>
    <comment>from the matrix. They all involve computing one element from</comment>
    <comment>the diagonal of the matrix, and computing the three other ones</comment>
    <comment>using a formula involving a division by the first element,</comment>
    <comment>which unfortunately can be zero. Since the norm of the</comment>
    <comment>quaternion is 1, we know at least one element has an absolute</comment>
    <comment>value greater or equal to 0.5, so it is always possible to</comment>
    <comment>select the right formula and avoid division by zero and even</comment>
    <comment>numerical inaccuracy. Checking the elements in turn and using</comment>
    <comment>the first one greater than 0.45 is safe (this leads to a simple</comment>
    <comment>test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)</comment>
    <comment>compute q0 and deduce q1, q2 and q3</comment>
    <comment>compute q1 and deduce q0, q2 and q3</comment>
    <comment>compute q2 and deduce q0, q1 and q3</comment>
    <comment>compute q3 and deduce q0, q1 and q2</comment>
  </method>
  <javadoc>
    <text>Revert a rotation.
 * Build a rotation which reverse the effect of another
 * rotation. This means that if r(u) = v, then r.revert(v) = u. The
 * instance is not changed.</text>
    <return>a new rotation whose effect is the reverse of the effect
 * of the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="revert" />
  <javadoc>
    <text>Get the scalar coordinate of the quaternion.</text>
    <return>scalar coordinate of the quaternion</return>
  </javadoc>
  <method type="T" name="getQ0" />
  <javadoc>
    <text>Get the first coordinate of the vectorial part of the quaternion.</text>
    <return>first coordinate of the vectorial part of the quaternion</return>
  </javadoc>
  <method type="T" name="getQ1" />
  <javadoc>
    <text>Get the second coordinate of the vectorial part of the quaternion.</text>
    <return>second coordinate of the vectorial part of the quaternion</return>
  </javadoc>
  <method type="T" name="getQ2" />
  <javadoc>
    <text>Get the third coordinate of the vectorial part of the quaternion.</text>
    <return>third coordinate of the vectorial part of the quaternion</return>
  </javadoc>
  <method type="T" name="getQ3" />
  <javadoc>
    <text>Get the normalized axis of the rotation.</text>
    <return>normalized axis of the rotation</return>
    <see>#FieldRotation(FieldVector3D,RealFieldElement)</see>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="getAxis">
    <declaration type="T" name="squaredSine" />
    <scope>
      <declaration type="Field&lt;T&gt;" name="field" />
    </scope>
    <scope>
      <declaration type="T" name="inverse" />
    </scope>
    <declaration type="T" name="inverse" />
  </method>
  <javadoc>
    <text>Get the angle of the rotation.</text>
    <return>angle of the rotation (between 0 and &amp;pi;)</return>
    <see>#FieldRotation(FieldVector3D,RealFieldElement)</see>
  </javadoc>
  <method type="T" name="getAngle">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Get the Cardan or Euler angles corresponding to the instance.
 * &lt;p&gt;The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt; and a&lt;sub&gt;3&lt;/sub&gt; is the same as
 * the rotation defined by the angles &amp;pi; + a&lt;sub&gt;1&lt;/sub&gt;, &amp;pi;
 * - a&lt;sub&gt;2&lt;/sub&gt; and &amp;pi; + a&lt;sub&gt;3&lt;/sub&gt;. This method implements
 * the following arbitrary choices:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;for Cardan angles, the chosen set is the one for which the
 * second angle is between -&amp;pi;/2 and &amp;pi;/2 (i.e its cosine is
 * positive),&lt;/li&gt;
 * &lt;li&gt;for Euler angles, the chosen set is the one for which the
 * second angle is between 0 and &amp;pi; (i.e its sine is positive).&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * &lt;em&gt;nothing&lt;/em&gt; to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&amp;pi;/2 or +&amp;pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &amp;pi;, this implies that the identity
 * rotation is always singular for Euler angles!&lt;/p&gt;</text>
    <param>order rotation order to use</param>
    <return>an array of three angles, in the order specified by the set</return>
    <exception>CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified</exception>
  </javadoc>
  <method type="T[]" name="getAngles">
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="FieldVector3D&lt;T&gt;" name="v1" />
      <declaration type="FieldVector3D&lt;T&gt;" name="v2" />
      <scope />
    </scope>
    <comment>r (+K) coordinates are :</comment>
    <comment>sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)</comment>
    <comment>(-r) (+I) coordinates are :</comment>
    <comment>cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)</comment>
    <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (+J) coordinates are :</comment>
    <comment>-sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)</comment>
    <comment>(-r) (+I) coordinates are :</comment>
    <comment>cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)</comment>
    <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (+K) coordinates are :</comment>
    <comment>cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)</comment>
    <comment>(-r) (+J) coordinates are :</comment>
    <comment>sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)</comment>
    <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (+I) coordinates are :</comment>
    <comment>cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)</comment>
    <comment>(-r) (+J) coordinates are :</comment>
    <comment>sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)</comment>
    <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (+J) coordinates are :</comment>
    <comment>-cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)</comment>
    <comment>(-r) (+K) coordinates are :</comment>
    <comment>-sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)</comment>
    <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (+I) coordinates are :</comment>
    <comment>cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)</comment>
    <comment>(-r) (+K) coordinates are :</comment>
    <comment>-sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)</comment>
    <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (+I) coordinates are :</comment>
    <comment>cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)</comment>
    <comment>(-r) (+I) coordinates are :</comment>
    <comment>cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)</comment>
    <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
    <comment>r (+I) coordinates are :</comment>
    <comment>cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)</comment>
    <comment>(-r) (+I) coordinates are :</comment>
    <comment>cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)</comment>
    <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
    <comment>r (+J) coordinates are :</comment>
    <comment>sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)</comment>
    <comment>(-r) (+J) coordinates are :</comment>
    <comment>sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)</comment>
    <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
    <comment>r (+J) coordinates are :</comment>
    <comment>-cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)</comment>
    <comment>(-r) (+J) coordinates are :</comment>
    <comment>sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)</comment>
    <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
    <comment>r (+K) coordinates are :</comment>
    <comment>sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)</comment>
    <comment>(-r) (+K) coordinates are :</comment>
    <comment>sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)</comment>
    <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
    <comment>last possibility is ZYZ</comment>
    <comment>r (+K) coordinates are :</comment>
    <comment>cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)</comment>
    <comment>(-r) (+K) coordinates are :</comment>
    <comment>-sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)</comment>
    <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
  </method>
  <javadoc>
    <text>Create a dimension 3 array.</text>
    <param>a0 first array element</param>
    <param>a1 second array element</param>
    <param>a2 third array element</param>
    <return>new array</return>
  </javadoc>
  <method type="T[]" name="buildArray">
    <declaration type="T[]" name="array" />
  </method>
  <javadoc>
    <text>Create a constant vector.</text>
    <param>x abscissa</param>
    <param>y ordinate</param>
    <param>z height</param>
    <return>a constant vector</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="vector">
    <declaration type="T" name="zero" />
  </method>
  <javadoc>
    <text>Get the 3X3 matrix corresponding to the instance</text>
    <return>the matrix corresponding to the instance</return>
  </javadoc>
  <method type="T[][]" name="getMatrix">
    <declaration type="T" name="q0q0" />
    <declaration type="T" name="q0q1" />
    <declaration type="T" name="q0q2" />
    <declaration type="T" name="q0q3" />
    <declaration type="T" name="q1q1" />
    <declaration type="T" name="q1q2" />
    <declaration type="T" name="q1q3" />
    <declaration type="T" name="q2q2" />
    <declaration type="T" name="q2q3" />
    <declaration type="T" name="q3q3" />
    <declaration type="T[][]" name="m" />
    <comment>products</comment>
    <comment>create the matrix</comment>
  </method>
  <javadoc>
    <text>Convert to a constant vector without derivatives.</text>
    <return>a constant vector</return>
  </javadoc>
  <method type="Rotation" name="toRotation" />
  <javadoc>
    <text>Apply the rotation to a vector.</text>
    <param>u vector to apply the rotation to</param>
    <return>a new vector which is the image of u by the rotation</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="applyTo">
    <declaration type="T" name="x" />
    <declaration type="T" name="y" />
    <declaration type="T" name="z" />
    <declaration type="T" name="s" />
  </method>
  <javadoc>
    <text>Apply the rotation to a vector.</text>
    <param>u vector to apply the rotation to</param>
    <return>a new vector which is the image of u by the rotation</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="applyTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="T" name="s" />
  </method>
  <javadoc>
    <text>Apply the rotation to a vector stored in an array.</text>
    <param>in an array with three items which stores vector to rotate</param>
    <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
  </javadoc>
  <method type="void" name="applyTo">
    <declaration type="T" name="x" />
    <declaration type="T" name="y" />
    <declaration type="T" name="z" />
    <declaration type="T" name="s" />
  </method>
  <javadoc>
    <text>Apply the rotation to a vector stored in an array.</text>
    <param>in an array with three items which stores vector to rotate</param>
    <param>out an array with three items to put result to</param>
  </javadoc>
  <method type="void" name="applyTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="T" name="s" />
  </method>
  <javadoc>
    <text>Apply a rotation to a vector.</text>
    <param>r rotation to apply</param>
    <param>u vector to apply the rotation to</param>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <return>a new vector which is the image of u by the rotation</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="applyTo">
    <declaration type="T" name="x" />
    <declaration type="T" name="y" />
    <declaration type="T" name="z" />
    <declaration type="T" name="s" />
  </method>
  <javadoc>
    <text>Apply the inverse of the rotation to a vector.</text>
    <param>u vector to apply the inverse of the rotation to</param>
    <return>a new vector which such that u is its image by the rotation</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="applyInverseTo">
    <declaration type="T" name="x" />
    <declaration type="T" name="y" />
    <declaration type="T" name="z" />
    <declaration type="T" name="s" />
    <declaration type="T" name="m0" />
  </method>
  <javadoc>
    <text>Apply the inverse of the rotation to a vector.</text>
    <param>u vector to apply the inverse of the rotation to</param>
    <return>a new vector which such that u is its image by the rotation</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="applyInverseTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="T" name="s" />
    <declaration type="T" name="m0" />
  </method>
  <javadoc>
    <text>Apply the inverse of the rotation to a vector stored in an array.</text>
    <param>in an array with three items which stores vector to rotate</param>
    <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
  </javadoc>
  <method type="void" name="applyInverseTo">
    <declaration type="T" name="x" />
    <declaration type="T" name="y" />
    <declaration type="T" name="z" />
    <declaration type="T" name="s" />
    <declaration type="T" name="m0" />
  </method>
  <javadoc>
    <text>Apply the inverse of the rotation to a vector stored in an array.</text>
    <param>in an array with three items which stores vector to rotate</param>
    <param>out an array with three items to put result to</param>
  </javadoc>
  <method type="void" name="applyInverseTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="T" name="s" />
    <declaration type="T" name="m0" />
  </method>
  <javadoc>
    <text>Apply the inverse of a rotation to a vector.</text>
    <param>r rotation to apply</param>
    <param>u vector to apply the inverse of the rotation to</param>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <return>a new vector which such that u is its image by the rotation</return>
  </javadoc>
  <method type="FieldVector3D&lt;T&gt;" name="applyInverseTo">
    <declaration type="T" name="x" />
    <declaration type="T" name="y" />
    <declaration type="T" name="z" />
    <declaration type="T" name="s" />
    <declaration type="double" name="m0" />
  </method>
  <javadoc>
    <text>Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).</text>
    <param>r rotation to apply the rotation to</param>
    <return>a new rotation which is the composition of r by the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="applyTo" />
  <javadoc>
    <text>Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).</text>
    <param>r rotation to apply the rotation to</param>
    <return>a new rotation which is the composition of r by the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="applyTo" />
  <javadoc>
    <text>Apply a rotation to another rotation.
 * Applying a rotation to another rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image
 * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(rOuter, rInner).</text>
    <param>r1 rotation to apply</param>
    <param>rInner rotation to apply the rotation to</param>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <return>a new rotation which is the composition of r by the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="applyTo" />
  <javadoc>
    <text>Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).</text>
    <param>r rotation to apply the rotation to</param>
    <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="applyInverseTo" />
  <javadoc>
    <text>Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).</text>
    <param>r rotation to apply the rotation to</param>
    <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="applyInverseTo" />
  <javadoc>
    <text>Apply the inverse of a rotation to another rotation.
 * Applying the inverse of a rotation to another rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),
 * let w be the inverse image of v by rOuter
 * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(rOuter, rInner).</text>
    <param>rOuter rotation to apply the rotation to</param>
    <param>rInner rotation to apply the rotation to</param>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
  </javadoc>
  <method type="FieldRotation&lt;T&gt;" name="applyInverseTo" />
  <javadoc>
    <text>Perfect orthogonality on a 3X3 matrix.</text>
    <param>m initial matrix (not exactly orthogonal)</param>
    <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
    <return>an orthogonal matrix close to m</return>
    <exception>NotARotationMatrixException if the matrix cannot be
 * orthogonalized with the given threshold after 10 iterations</exception>
  </javadoc>
  <method type="T[][]" name="orthogonalizeMatrix">
    <declaration type="T" name="x00" />
    <declaration type="T" name="x01" />
    <declaration type="T" name="x02" />
    <declaration type="T" name="x10" />
    <declaration type="T" name="x11" />
    <declaration type="T" name="x12" />
    <declaration type="T" name="x20" />
    <declaration type="T" name="x21" />
    <declaration type="T" name="x22" />
    <declaration type="double" name="fn" />
    <declaration type="double" name="fn1" />
    <declaration type="T[][]" name="o" />
    <declaration type="int" name="i" />
    <scope>
      <declaration type="T" name="mx00" />
      <declaration type="T" name="mx10" />
      <declaration type="T" name="mx20" />
      <declaration type="T" name="mx01" />
      <declaration type="T" name="mx11" />
      <declaration type="T" name="mx21" />
      <declaration type="T" name="mx02" />
      <declaration type="T" name="mx12" />
      <declaration type="T" name="mx22" />
      <declaration type="double" name="corr00" />
      <declaration type="double" name="corr01" />
      <declaration type="double" name="corr02" />
      <declaration type="double" name="corr10" />
      <declaration type="double" name="corr11" />
      <declaration type="double" name="corr12" />
      <declaration type="double" name="corr20" />
      <declaration type="double" name="corr21" />
      <declaration type="double" name="corr22" />
      <scope />
    </scope>
    <comment>iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)</comment>
    <comment>Mt.Xn</comment>
    <comment>Xn+1</comment>
    <comment>correction on each elements</comment>
    <comment>Frobenius norm of the correction</comment>
    <comment>convergence test</comment>
    <comment>prepare next iteration</comment>
    <comment>the algorithm did not converge after 10 iterations</comment>
  </method>
  <javadoc>
    <text>Compute the &lt;i&gt;distance&lt;/i&gt; between two rotations.
 * &lt;p&gt;The &lt;i&gt;distance&lt;/i&gt; is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:&lt;/p&gt;
 * &lt;pre&gt;
 * r&lt;sub&gt;1&lt;/sub&gt;(r) = r&lt;sub&gt;2&lt;/sub&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;This distance is an angle between 0 and &amp;pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r&lt;sub&gt;1&lt;/sub&gt;(v)
 * and r&lt;sub&gt;2&lt;/sub&gt;(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.&lt;/p&gt;
 * &lt;p&gt;Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).&lt;/p&gt;</text>
    <param>r1 first rotation</param>
    <param>r2 second rotation</param>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <return>&lt;i&gt;distance&lt;/i&gt; between r1 and r2</return>
  </javadoc>
  <method type="T" name="distance" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
