<?xml version="1.0" encoding="UTF-8"?>
<class name="ArrayFieldVector">
  <javadoc>
    <text>This class implements the {@link FieldVector} interface with a {@link FieldElement} array.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <version>$Id: ArrayFieldVector.java 1462423 2013-03-29 07:25:18Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Entries of the vector.</text>
  </javadoc>
  <declaration type="T[]" name="data" />
  <javadoc>
    <text>Field to which the elements belong.</text>
  </javadoc>
  <declaration type="Field&lt;T&gt;" name="field" />
  <javadoc>
    <text>Build a 0-length vector.
 * Zero-length vectors may be used to initialize construction of vectors
 * by data gathering. We start with zero-length and use either the {@link #ArrayFieldVector(ArrayFieldVector,ArrayFieldVector)} constructor
 * or one of the {@code append} methods ({@link #add(FieldVector)} or{@link #append(ArrayFieldVector)}) to gather data into this vector.</text>
    <param>field field to which the elements belong</param>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector of zeroes.</text>
    <param>field Field to which the elements belong.</param>
    <param>size Size of the vector.</param>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector with preset values.</text>
    <param>size Size of the vector.</param>
    <param>preset All entries will be set with this value.</param>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector from an array, copying the input array.
 * This constructor needs a non-empty {@code d} array to retrieve
 * the field from its first element. This implies it cannot build
 * 0 length vectors. To build vectors from any size, one should
 * use the {@link #ArrayFieldVector(Field,FieldElement[])} constructor.</text>
    <param>d Array.</param>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <throws>ZeroException if {@code d} is empty.</throws>
    <see>#ArrayFieldVector(Field,FieldElement[])</see>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Construct a vector from an array, copying the input array.</text>
    <param>field Field to which the elements belong.</param>
    <param>d Array.</param>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <see>#ArrayFieldVector(FieldElement[])</see>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Create a new ArrayFieldVector using the input array as the underlying
 * data array.
 * If an array is built specially in order to be embedded in a
 * ArrayFieldVector and not used directly, the {@code copyArray} may be
 * set to {@code false}. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.
 * This constructor needs a non-empty {@code d} array to retrieve
 * the field from its first element. This implies it cannot build
 * 0 length vectors. To build vectors from any size, one should
 * use the {@link #ArrayFieldVector(Field,FieldElement[],boolean)}constructor.</text>
    <param>d Data for the new vector.</param>
    <param>copyArray If {@code true}, the input array will be copied,
 * otherwise it will be referenced.</param>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <throws>ZeroException if {@code d} is empty.</throws>
    <see>#ArrayFieldVector(FieldElement[])</see>
    <see>#ArrayFieldVector(Field,FieldElement[],boolean)</see>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
  </method>
  <javadoc>
    <text>Create a new ArrayFieldVector using the input array as the underlying
 * data array.
 * If an array is built specially in order to be embedded in a
 * ArrayFieldVector and not used directly, the {@code copyArray} may be
 * set to {@code false}. This will prevent the copying and improve
 * performance as no new array will be built and no data will be copied.</text>
    <param>field Field to which the elements belong.</param>
    <param>d Data for the new vector.</param>
    <param>copyArray If {@code true}, the input array will be copied,
 * otherwise it will be referenced.</param>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <see>#ArrayFieldVector(FieldElement[],boolean)</see>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector from part of a array.</text>
    <param>d Array.</param>
    <param>pos Position of the first entry.</param>
    <param>size Number of entries to copy.</param>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <throws>NumberIsTooLargeException if the size of {@code d} is less
 * than {@code pos + size}.</throws>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
  </method>
  <javadoc>
    <text>Construct a vector from part of a array.</text>
    <param>field Field to which the elements belong.</param>
    <param>d Array.</param>
    <param>pos Position of the first entry.</param>
    <param>size Number of entries to copy.</param>
    <throws>NullArgumentException if {@code d} is {@code null}.</throws>
    <throws>NumberIsTooLargeException if the size of {@code d} is less
 * than {@code pos + size}.</throws>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
  </method>
  <javadoc>
    <text>Construct a vector from another vector, using a deep copy.</text>
    <param>v Vector to copy.</param>
    <throws>NullArgumentException if {@code v} is {@code null}.</throws>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
  </method>
  <javadoc>
    <text>Construct a vector from another vector, using a deep copy.</text>
    <param>v Vector to copy.</param>
    <throws>NullArgumentException if {@code v} is {@code null}.</throws>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector from another vector.</text>
    <param>v Vector to copy.</param>
    <param>deep If {@code true} perform a deep copy, otherwise perform
 * a shallow copy</param>
    <throws>NullArgumentException if {@code v} is {@code null}.</throws>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <deprecated>as of 3.2, replaced by {@link #ArrayFieldVector(FieldVector,FieldVector)}</deprecated>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <since>3.2</since>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <declaration type="T[]" name="v1Data" />
    <declaration type="T[]" name="v2Data" />
  </method>
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <deprecated>as of 3.2, replaced by {@link #ArrayFieldVector(FieldVector,FieldElement[])}</deprecated>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <since>3.2</since>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <declaration type="T[]" name="v1Data" />
  </method>
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <deprecated>as of 3.2, replaced by {@link #ArrayFieldVector(FieldElement[],FieldVector)}</deprecated>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector" />
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <since>3.2</since>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <declaration type="T[]" name="v2Data" />
  </method>
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.
 * This constructor needs at least one non-empty array to retrieve
 * the field from its first element. This implies it cannot build
 * 0 length vectors. To build vectors from any size, one should
 * use the {@link #ArrayFieldVector(Field,FieldElement[],FieldElement[])}constructor.</text>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <throws>ZeroException if both arrays are empty.</throws>
    <see>#ArrayFieldVector(Field,FieldElement[],FieldElement[])</see>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
  </method>
  <javadoc>
    <text>Construct a vector by appending one vector to another vector.</text>
    <param>field Field to which the elements belong.</param>
    <param>v1 First vector (will be put in front of the new vector).</param>
    <param>v2 Second vector (will be put at back of the new vector).</param>
    <throws>NullArgumentException if {@code v1} or {@code v2} is{@code null}.</throws>
    <throws>ZeroException if both arrays are empty.</throws>
    <see>#ArrayFieldVector(FieldElement[],FieldElement[])</see>
  </javadoc>
  <method type="constructor" name="ArrayFieldVector">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Field&lt;T&gt;" name="getField" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="copy" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="add">
    <scope />
    <scope>
      <declaration type="T[]" name="out" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compute the sum of {@code this} and {@code v}.</text>
    <param>v vector to be added</param>
    <return>{@code this + v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this}</throws>
  </javadoc>
  <method type="ArrayFieldVector&lt;T&gt;" name="add">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="subtract">
    <scope />
    <scope>
      <declaration type="T[]" name="out" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compute {@code this} minus {@code v}.</text>
    <param>v vector to be subtracted</param>
    <return>{@code this - v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this}</throws>
  </javadoc>
  <method type="ArrayFieldVector&lt;T&gt;" name="subtract">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapAdd">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapAddToSelf">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapSubtract">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapSubtractToSelf">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapMultiply">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapMultiplyToSelf">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapDivide">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapDivideToSelf">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapInv">
    <declaration type="T[]" name="out" />
    <declaration type="T" name="one" />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="mapInvToSelf">
    <declaration type="T" name="one" />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="ebeMultiply">
    <scope />
    <scope>
      <declaration type="T[]" name="out" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Element-by-element multiplication.</text>
    <param>v vector by which instance elements must be multiplied</param>
    <return>a vector containing {@code this[i] * v[i]} for all {@code i}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this}</throws>
  </javadoc>
  <method type="ArrayFieldVector&lt;T&gt;" name="ebeMultiply">
    <declaration type="T[]" name="out" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="ebeDivide">
    <scope />
    <scope>
      <declaration type="T[]" name="out" />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Element-by-element division.</text>
    <param>v vector by which instance elements must be divided</param>
    <return>a vector containing {@code this[i] / v[i]} for all {@code i}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this}</throws>
    <throws>MathArithmeticException if one entry of {@code v} is zero.</throws>
  </javadoc>
  <method type="ArrayFieldVector&lt;T&gt;" name="ebeDivide">
    <declaration type="T[]" name="out" />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[]" name="getData" />
  <javadoc>
    <text>Returns a reference to the underlying data array.
 * &lt;p&gt;Does not make a fresh copy of the underlying data.&lt;/p&gt;</text>
    <return>array of entries</return>
  </javadoc>
  <method type="T[]" name="getDataRef" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="dotProduct">
    <scope />
    <scope>
      <declaration type="T" name="dot" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compute the dot product.</text>
    <param>v vector with which dot product should be computed</param>
    <return>the scalar dot product of {@code this} and {@code v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this}</throws>
  </javadoc>
  <method type="T" name="dotProduct">
    <declaration type="T" name="dot" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="projection" />
  <javadoc>
    <text>Find the orthogonal projection of this vector onto another vector.</text>
    <param>v vector onto which {@code this} must be projected</param>
    <return>projection of {@code this} onto {@code v}</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this}</throws>
    <throws>MathArithmeticException if {@code v} is the null vector.</throws>
  </javadoc>
  <method type="ArrayFieldVector&lt;T&gt;" name="projection" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="outerProduct">
    <scope />
    <scope>
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="FieldMatrix&lt;T&gt;" name="out" />
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Compute the outer product.</text>
    <param>v vector with which outer product should be computed</param>
    <return>the matrix outer product between instance and v</return>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="outerProduct">
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
    <declaration type="FieldMatrix&lt;T&gt;" name="out" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="getEntry" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="getDimension" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="append">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Construct a vector by appending a vector to this vector.</text>
    <param>v vector to append to this one.</param>
    <return>a new vector</return>
  </javadoc>
  <method type="ArrayFieldVector&lt;T&gt;" name="append" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="append">
    <declaration type="T[]" name="out" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="getSubVector">
    <scope />
    <declaration type="ArrayFieldVector&lt;T&gt;" name="out" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setEntry">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setSubVector">
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>Set a set of consecutive elements.</text>
    <param>index index of first element to be set.</param>
    <param>v vector containing the values to set.</param>
    <throws>OutOfRangeException if the index is invalid.</throws>
  </javadoc>
  <method type="void" name="set">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="set" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[]" name="toArray" />
  <javadoc>
    <text>Check if instance and specified vectors have the same dimension.</text>
    <param>v vector to compare instance with</param>
    <exception>DimensionMismatchException if the vectors do not
 * have the same dimensions</exception>
  </javadoc>
  <method type="void" name="checkVectorDimensions" />
  <javadoc>
    <text>Check if instance dimension is equal to some expected value.</text>
    <param>n Expected dimension.</param>
    <throws>DimensionMismatchException if the dimension is not equal to the
 * size of {@code this} vector.</throws>
  </javadoc>
  <method type="void" name="checkVectorDimensions">
    <scope />
  </method>
  <javadoc>
    <text>Test for the equality of two vectors.</text>
    <param>other Object to test for equality.</param>
    <return>{@code true} if two vector objects are equal, {@code false}otherwise.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <scope>
      <declaration type="FieldVector&lt;T&gt;" name="rhs" />
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>May fail, but we ignore ClassCastException</comment>
    <comment>ignore exception</comment>
  </method>
  <javadoc>
    <text>Get a hashCode for the real vector.
 * &lt;p&gt;All NaN values have the same hash code.&lt;/p&gt;</text>
    <return>a hash code value for this object</return>
  </javadoc>
  <method type="int" name="hashCode">
    <declaration type="int" name="h" />
    <scope />
  </method>
  <javadoc>
    <text>Check if an index is valid.</text>
    <param>index Index to check.</param>
    <exception>OutOfRangeException if the index is not valid.</exception>
  </javadoc>
  <method type="void" name="checkIndex">
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
