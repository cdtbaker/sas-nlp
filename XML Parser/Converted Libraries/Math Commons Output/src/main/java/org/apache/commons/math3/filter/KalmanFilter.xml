<?xml version="1.0" encoding="UTF-8"?>
<class name="KalmanFilter">
  <javadoc>
    <text>Implementation of a Kalman filter to estimate the state &lt;i&gt;x&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt;
 * of a discrete-time controlled process that is governed by the linear
 * stochastic difference equation:
 * &lt;pre&gt;
 * &lt;i&gt;x&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; = &lt;b&gt;A&lt;/b&gt;&lt;i&gt;x&lt;sub&gt;k-1&lt;/sub&gt;&lt;/i&gt; + &lt;b&gt;B&lt;/b&gt;&lt;i&gt;u&lt;sub&gt;k-1&lt;/sub&gt;&lt;/i&gt; + &lt;i&gt;w&lt;sub&gt;k-1&lt;/sub&gt;&lt;/i&gt;
 * &lt;/pre&gt;
 * with a measurement &lt;i&gt;x&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; that is
 * &lt;pre&gt;
 * &lt;i&gt;z&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; = &lt;b&gt;H&lt;/b&gt;&lt;i&gt;x&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; + &lt;i&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt;.
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The random variables &lt;i&gt;w&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; and &lt;i&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; represent
 * the process and measurement noise and are assumed to be independent of each
 * other and distributed with normal probability (white noise).
 * &lt;p&gt;
 * The Kalman filter cycle involves the following steps:
 * &lt;ol&gt;
 * &lt;li&gt;predict: project the current state estimate ahead in time&lt;/li&gt;
 * &lt;li&gt;correct: adjust the projected estimate by an actual measurement&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * The Kalman filter is initialized with a {@link ProcessModel} and a{@link MeasurementModel}, which contain the corresponding transformation and
 * noise covariance matrices. The parameter names used in the respective models
 * correspond to the following names commonly used in the mathematical
 * literature:
 * &lt;ul&gt;
 * &lt;li&gt;A - state transition matrix&lt;/li&gt;
 * &lt;li&gt;B - control input matrix&lt;/li&gt;
 * &lt;li&gt;H - measurement matrix&lt;/li&gt;
 * &lt;li&gt;Q - process noise covariance matrix&lt;/li&gt;
 * &lt;li&gt;R - measurement noise covariance matrix&lt;/li&gt;
 * &lt;li&gt;P - error covariance matrix&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <see>&lt;a href="http://www.cs.unc.edu/~welch/kalman/"&gt;Kalman filter
 *      resources&lt;/a&gt;</see>
    <see>&lt;a href="http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf"&gt;An
 *      introduction to the Kalman filter by Greg Welch and Gary Bishop&lt;/a&gt;</see>
    <see>&lt;a href="http://academic.csuohio.edu/simond/courses/eec644/kalman.pdf"&gt;
 *      Kalman filter example by Dan Simon&lt;/a&gt;</see>
    <see>ProcessModel</see>
    <see>MeasurementModel</see>
    <since>3.0</since>
    <version>$Id: KalmanFilter.java 1416643 2012-12-03 19:37:14Z tn $</version>
  </javadoc>
  <javadoc>
    <text>The process model used by this filter instance.</text>
  </javadoc>
  <declaration type="ProcessModel" name="processModel" />
  <javadoc>
    <text>The measurement model used by this filter instance.</text>
  </javadoc>
  <declaration type="MeasurementModel" name="measurementModel" />
  <javadoc>
    <text>The transition matrix, equivalent to A.</text>
  </javadoc>
  <declaration type="RealMatrix" name="transitionMatrix" />
  <javadoc>
    <text>The transposed transition matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="transitionMatrixT" />
  <javadoc>
    <text>The control matrix, equivalent to B.</text>
  </javadoc>
  <declaration type="RealMatrix" name="controlMatrix" />
  <javadoc>
    <text>The measurement matrix, equivalent to H.</text>
  </javadoc>
  <declaration type="RealMatrix" name="measurementMatrix" />
  <javadoc>
    <text>The transposed measurement matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="measurementMatrixT" />
  <javadoc>
    <text>The internal state estimation vector, equivalent to x hat.</text>
  </javadoc>
  <declaration type="RealVector" name="stateEstimation" />
  <javadoc>
    <text>The error covariance matrix, equivalent to P.</text>
  </javadoc>
  <declaration type="RealMatrix" name="errorCovariance" />
  <javadoc>
    <text>Creates a new Kalman filter with the given process and measurement models.</text>
    <param>processthe model defining the underlying process dynamics</param>
    <param>measurementthe model defining the given measurement characteristics</param>
    <throws>NullArgumentExceptionif any of the given inputs is null (except for the control matrix)</throws>
    <throws>NonSquareMatrixExceptionif the transition matrix is non square</throws>
    <throws>DimensionMismatchExceptionif the column dimension of the transition matrix does not match the dimension of the
 * initial state estimation vector</throws>
    <throws>MatrixDimensionMismatchExceptionif the matrix dimensions do not fit together</throws>
  </javadoc>
  <method type="constructor" name="KalmanFilter">
    <scope />
    <scope />
    <declaration type="RealMatrix" name="processNoise" />
    <declaration type="RealMatrix" name="measNoise" />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>create an empty matrix if no control matrix was given</comment>
    <comment>check that the process and measurement noise matrices are not null</comment>
    <comment>they will be directly accessed from the model as they may change</comment>
    <comment>over time</comment>
    <comment>set the initial state estimate to a zero vector if it is not</comment>
    <comment>available from the process model</comment>
    <comment>initialize the error covariance to the process noise if it is not</comment>
    <comment>available from the process model</comment>
    <comment>sanity checks, the control matrix B may be null</comment>
    <comment>A must be a square matrix</comment>
    <comment>row dimension of B must be equal to A</comment>
    <comment>Q must be equal to A</comment>
    <comment>column dimension of H must be equal to row dimension of A</comment>
    <comment>row dimension of R must be equal to row dimension of H</comment>
  </method>
  <javadoc>
    <text>Returns the dimension of the state estimation vector.</text>
    <return>the state dimension</return>
  </javadoc>
  <method type="int" name="getStateDimension" />
  <javadoc>
    <text>Returns the dimension of the measurement vector.</text>
    <return>the measurement vector dimension</return>
  </javadoc>
  <method type="int" name="getMeasurementDimension" />
  <javadoc>
    <text>Returns the current state estimation vector.</text>
    <return>the state estimation vector</return>
  </javadoc>
  <method type="double[]" name="getStateEstimation" />
  <javadoc>
    <text>Returns a copy of the current state estimation vector.</text>
    <return>the state estimation vector</return>
  </javadoc>
  <method type="RealVector" name="getStateEstimationVector" />
  <javadoc>
    <text>Returns the current error covariance matrix.</text>
    <return>the error covariance matrix</return>
  </javadoc>
  <method type="double[][]" name="getErrorCovariance" />
  <javadoc>
    <text>Returns a copy of the current error covariance matrix.</text>
    <return>the error covariance matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getErrorCovarianceMatrix" />
  <javadoc>
    <text>Predict the internal state estimation one time step ahead.</text>
  </javadoc>
  <method type="void" name="predict" />
  <javadoc>
    <text>Predict the internal state estimation one time step ahead.</text>
    <param>uthe control vector</param>
    <throws>DimensionMismatchExceptionif the dimension of the control vector does not fit</throws>
  </javadoc>
  <method type="void" name="predict" />
  <javadoc>
    <text>Predict the internal state estimation one time step ahead.</text>
    <param>uthe control vector</param>
    <throws>DimensionMismatchExceptionif the dimension of the control vector does not match</throws>
  </javadoc>
  <method type="void" name="predict">
    <scope />
    <scope />
    <comment>sanity checks</comment>
    <comment>project the state estimation ahead (a priori state)</comment>
    <comment>xHat(k)- = A * xHat(k-1) + B * u(k-1)</comment>
    <comment>add control input if it is available</comment>
    <comment>project the error covariance ahead</comment>
    <comment>P(k)- = A * P(k-1) * A' + Q</comment>
  </method>
  <javadoc>
    <text>Correct the current state estimate with an actual measurement.</text>
    <param>zthe measurement vector</param>
    <throws>NullArgumentExceptionif the measurement vector is {@code null}</throws>
    <throws>DimensionMismatchExceptionif the dimension of the measurement vector does not fit</throws>
    <throws>SingularMatrixExceptionif the covariance matrix could not be inverted</throws>
  </javadoc>
  <method type="void" name="correct" />
  <javadoc>
    <text>Correct the current state estimate with an actual measurement.</text>
    <param>zthe measurement vector</param>
    <throws>NullArgumentExceptionif the measurement vector is {@code null}</throws>
    <throws>DimensionMismatchExceptionif the dimension of the measurement vector does not fit</throws>
    <throws>SingularMatrixExceptionif the covariance matrix could not be inverted</throws>
  </javadoc>
  <method type="void" name="correct">
    <scope />
    <declaration type="RealMatrix" name="s" />
    <declaration type="DecompositionSolver" name="solver" />
    <declaration type="RealMatrix" name="invertedS" />
    <declaration type="RealVector" name="innovation" />
    <declaration type="RealMatrix" name="kalmanGain" />
    <declaration type="RealMatrix" name="identity" />
    <comment>sanity checks</comment>
    <comment>S = H * P(k) - * H' + R</comment>
    <comment>invert S</comment>
    <comment>as the error covariance matrix is a symmetric positive</comment>
    <comment>semi-definite matrix, we can use the cholesky decomposition</comment>
    <comment>Inn = z(k) - H * xHat(k)-</comment>
    <comment>calculate gain matrix</comment>
    <comment>K(k) = P(k)- * H' * (H * P(k)- * H' + R)^-1</comment>
    <comment>K(k) = P(k)- * H' * S^-1</comment>
    <comment>update estimate with measurement z(k)</comment>
    <comment>xHat(k) = xHat(k)- + K * Inn</comment>
    <comment>update covariance of prediction error</comment>
    <comment>P(k) = (I - K * H) * P(k)-</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
