<?xml version="1.0" encoding="UTF-8"?>
<class name="MatrixUtils">
  <javadoc>
    <text>A collection of static methods that operate on or return matrices.</text>
    <version>$Id: MatrixUtils.java 1449528 2013-02-24 19:06:20Z luc $</version>
  </javadoc>
  <javadoc>
    <text>The default format for {@link RealMatrix} objects.</text>
    <since>3.1</since>
  </javadoc>
  <declaration type="RealMatrixFormat" name="DEFAULT_FORMAT" />
  <javadoc>
    <text>A format for {@link RealMatrix} objects compatible with octave.</text>
    <since>3.1</since>
  </javadoc>
  <declaration type="RealMatrixFormat" name="OCTAVE_FORMAT" />
  <javadoc>
    <text>Private constructor.</text>
  </javadoc>
  <method type="constructor" name="MatrixUtils" />
  <javadoc>
    <text>Returns a {@link RealMatrix} with specified dimensions.
 * &lt;p&gt;The type of matrix returned depends on the dimension. Below
 * 2&lt;sup&gt;12&lt;/sup&gt; elements (i.e. 4096 elements or 64&amp;times;64 for a
 * square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.&lt;/p&gt;
 * &lt;p&gt;The matrix elements are all set to 0.0.&lt;/p&gt;</text>
    <param>rows number of rows of the matrix</param>
    <param>columns number of columns of the matrix</param>
    <return>RealMatrix with specified dimensions</return>
    <see>#createRealMatrix(double[][])</see>
  </javadoc>
  <method type="RealMatrix" name="createRealMatrix" />
  <javadoc>
    <text>Returns a {@link FieldMatrix} with specified dimensions.
 * &lt;p&gt;The type of matrix returned depends on the dimension. Below
 * 2&lt;sup&gt;12&lt;/sup&gt; elements (i.e. 4096 elements or 64&amp;times;64 for a
 * square matrix), a {@link FieldMatrix} instance is built. Above
 * this threshold a {@link BlockFieldMatrix} instance is built.&lt;/p&gt;
 * &lt;p&gt;The matrix elements are all set to field.getZero().&lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>field field to which the matrix elements belong</param>
    <param>rows number of rows of the matrix</param>
    <param>columns number of columns of the matrix</param>
    <return>FieldMatrix with specified dimensions</return>
    <see>#createFieldMatrix(FieldElement[][])</see>
    <since>2.0</since>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createFieldMatrix" />
  <javadoc>
    <text>Returns a {@link RealMatrix} whose entries are the the values in the
 * the input array.
 * &lt;p&gt;The type of matrix returned depends on the dimension. Below
 * 2&lt;sup&gt;12&lt;/sup&gt; elements (i.e. 4096 elements or 64&amp;times;64 for a
 * square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.&lt;/p&gt;
 * &lt;p&gt;The input array is copied, not referenced.&lt;/p&gt;</text>
    <param>data input array</param>
    <return>RealMatrix containing the values of the array</return>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif {@code data} is not rectangular (not all rows have the same length).</throws>
    <throws>NoDataException if a row or column is empty.</throws>
    <throws>NullArgumentException if either {@code data} or {@code data[0]}is {@code null}.</throws>
    <throws>DimensionMismatchException if {@code data} is not rectangular.</throws>
    <see>#createRealMatrix(int,int)</see>
  </javadoc>
  <method type="RealMatrix" name="createRealMatrix">
    <scope />
  </method>
  <javadoc>
    <text>Returns a {@link FieldMatrix} whose entries are the the values in the
 * the input array.
 * &lt;p&gt;The type of matrix returned depends on the dimension. Below
 * 2&lt;sup&gt;12&lt;/sup&gt; elements (i.e. 4096 elements or 64&amp;times;64 for a
 * square matrix), a {@link FieldMatrix} instance is built. Above
 * this threshold a {@link BlockFieldMatrix} instance is built.&lt;/p&gt;
 * &lt;p&gt;The input array is copied, not referenced.&lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>data input array</param>
    <return>a matrix containing the values of the array.</return>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif {@code data} is not rectangular (not all rows have the same length).</throws>
    <throws>NoDataException if a row or column is empty.</throws>
    <throws>NullArgumentException if either {@code data} or {@code data[0]}is {@code null}.</throws>
    <see>#createFieldMatrix(Field,int,int)</see>
    <since>2.0</since>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createFieldMatrix">
    <scope />
  </method>
  <javadoc>
    <text>Returns &lt;code&gt;dimension x dimension&lt;/code&gt; identity matrix.</text>
    <param>dimension dimension of identity matrix to generate</param>
    <return>identity matrix</return>
    <throws>IllegalArgumentException if dimension is not positive</throws>
    <since>1.1</since>
  </javadoc>
  <method type="RealMatrix" name="createRealIdentityMatrix">
    <declaration type="RealMatrix" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Returns &lt;code&gt;dimension x dimension&lt;/code&gt; identity matrix.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>field field to which the elements belong</param>
    <param>dimension dimension of identity matrix to generate</param>
    <return>identity matrix</return>
    <throws>IllegalArgumentException if dimension is not positive</throws>
    <since>2.0</since>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createFieldIdentityMatrix">
    <declaration type="T" name="zero" />
    <declaration type="T" name="one" />
    <declaration type="T[][]" name="d" />
    <scope>
      <declaration type="T[]" name="dRow" />
    </scope>
  </method>
  <javadoc>
    <text>Returns a diagonal matrix with specified elements.</text>
    <param>diagonal diagonal elements of the matrix (the array elements
 * will be copied)</param>
    <return>diagonal matrix</return>
    <since>2.0</since>
  </javadoc>
  <method type="RealMatrix" name="createRealDiagonalMatrix">
    <declaration type="RealMatrix" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Returns a diagonal matrix with specified elements.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>diagonal diagonal elements of the matrix (the array elements
 * will be copied)</param>
    <return>diagonal matrix</return>
    <since>2.0</since>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createFieldDiagonalMatrix">
    <declaration type="FieldMatrix&lt;T&gt;" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Creates a {@link RealVector} using the data from the input array.</text>
    <param>data the input data</param>
    <return>a data.length RealVector</return>
    <throws>NoDataException if {@code data} is empty.</throws>
    <throws>NullArgumentException if {@code data} is {@code null}.</throws>
  </javadoc>
  <method type="RealVector" name="createRealVector">
    <scope />
  </method>
  <javadoc>
    <text>Creates a {@link FieldVector} using the data from the input array.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>data the input data</param>
    <return>a data.length FieldVector</return>
    <throws>NoDataException if {@code data} is empty.</throws>
    <throws>NullArgumentException if {@code data} is {@code null}.</throws>
    <throws>ZeroException if {@code data} has 0 elements</throws>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="createFieldVector">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Create a row {@link RealMatrix} using the data from the input
 * array.</text>
    <param>rowData the input row data</param>
    <return>a 1 x rowData.length RealMatrix</return>
    <throws>NoDataException if {@code rowData} is empty.</throws>
    <throws>NullArgumentException if {@code rowData} is {@code null}.</throws>
  </javadoc>
  <method type="RealMatrix" name="createRowRealMatrix">
    <scope />
    <declaration type="int" name="nCols" />
    <declaration type="RealMatrix" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Create a row {@link FieldMatrix} using the data from the input
 * array.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>rowData the input row data</param>
    <return>a 1 x rowData.length FieldMatrix</return>
    <throws>NoDataException if {@code rowData} is empty.</throws>
    <throws>NullArgumentException if {@code rowData} is {@code null}.</throws>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createRowFieldMatrix">
    <scope />
    <declaration type="int" name="nCols" />
    <scope />
    <declaration type="FieldMatrix&lt;T&gt;" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Creates a column {@link RealMatrix} using the data from the input
 * array.</text>
    <param>columnData  the input column data</param>
    <return>a columnData x 1 RealMatrix</return>
    <throws>NoDataException if {@code columnData} is empty.</throws>
    <throws>NullArgumentException if {@code columnData} is {@code null}.</throws>
  </javadoc>
  <method type="RealMatrix" name="createColumnRealMatrix">
    <scope />
    <declaration type="int" name="nRows" />
    <declaration type="RealMatrix" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Creates a column {@link FieldMatrix} using the data from the input
 * array.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>columnData  the input column data</param>
    <return>a columnData x 1 FieldMatrix</return>
    <throws>NoDataException if {@code data} is empty.</throws>
    <throws>NullArgumentException if {@code columnData} is {@code null}.</throws>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createColumnFieldMatrix">
    <scope />
    <declaration type="int" name="nRows" />
    <scope />
    <declaration type="FieldMatrix&lt;T&gt;" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Checks whether a matrix is symmetric, within a given relative tolerance.</text>
    <param>matrix Matrix to check.</param>
    <param>relativeTolerance Tolerance of the symmetry check.</param>
    <param>raiseException If {@code true}, an exception will be raised if
 * the matrix is not symmetric.</param>
    <return>{@code true} if {@code matrix} is symmetric.</return>
    <throws>NonSquareMatrixException if the matrix is not square.</throws>
    <throws>NonSymmetricMatrixException if the matrix is not symmetric.</throws>
  </javadoc>
  <method type="boolean" name="isSymmetricInternal">
    <declaration type="int" name="rows" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope>
        <declaration type="double" name="mij" />
        <declaration type="double" name="mji" />
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Checks whether a matrix is symmetric.</text>
    <param>matrix Matrix to check.</param>
    <param>eps Relative tolerance.</param>
    <throws>NonSquareMatrixException if the matrix is not square.</throws>
    <throws>NonSymmetricMatrixException if the matrix is not symmetric.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkSymmetric" />
  <javadoc>
    <text>Checks whether a matrix is symmetric.</text>
    <param>matrix Matrix to check.</param>
    <param>eps Relative tolerance.</param>
    <return>{@code true} if {@code matrix} is symmetric.</return>
    <since>3.1</since>
  </javadoc>
  <method type="boolean" name="isSymmetric" />
  <javadoc>
    <text>Check if matrix indices are valid.</text>
    <param>m Matrix.</param>
    <param>row Row index to check.</param>
    <param>column Column index to check.</param>
    <throws>OutOfRangeException if {@code row} or {@code column} is not
 * a valid index.</throws>
  </javadoc>
  <method type="void" name="checkMatrixIndex" />
  <javadoc>
    <text>Check if a row index is valid.</text>
    <param>m Matrix.</param>
    <param>row Row index to check.</param>
    <throws>OutOfRangeException if {@code row} is not a valid index.</throws>
  </javadoc>
  <method type="void" name="checkRowIndex">
    <scope />
  </method>
  <javadoc>
    <text>Check if a column index is valid.</text>
    <param>m Matrix.</param>
    <param>column Column index to check.</param>
    <throws>OutOfRangeException if {@code column} is not a valid index.</throws>
  </javadoc>
  <method type="void" name="checkColumnIndex">
    <scope />
  </method>
  <javadoc>
    <text>Check if submatrix ranges indices are valid.
 * Rows and columns are indicated counting from 0 to {@code n - 1}.</text>
    <param>m Matrix.</param>
    <param>startRow Initial row index.</param>
    <param>endRow Final row index.</param>
    <param>startColumn Initial column index.</param>
    <param>endColumn Final column index.</param>
    <throws>OutOfRangeException if the indices are invalid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
  </javadoc>
  <method type="void" name="checkSubMatrixIndex">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Check if submatrix ranges indices are valid.
 * Rows and columns are indicated counting from 0 to n-1.</text>
    <param>m Matrix.</param>
    <param>selectedRows Array of row indices.</param>
    <param>selectedColumns Array of column indices.</param>
    <throws>NullArgumentException if {@code selectedRows} or{@code selectedColumns} are {@code null}.</throws>
    <throws>NoDataException if the row or column selections are empty (zero
 * length).</throws>
    <throws>OutOfRangeException if row or column selections are not valid.</throws>
  </javadoc>
  <method type="void" name="checkSubMatrixIndex">
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Check if matrices are addition compatible.</text>
    <param>left Left hand side matrix.</param>
    <param>right Right hand side matrix.</param>
    <throws>MatrixDimensionMismatchException if the matrices are not addition
 * compatible.</throws>
  </javadoc>
  <method type="void" name="checkAdditionCompatible">
    <scope />
  </method>
  <javadoc>
    <text>Check if matrices are subtraction compatible</text>
    <param>left Left hand side matrix.</param>
    <param>right Right hand side matrix.</param>
    <throws>MatrixDimensionMismatchException if the matrices are not addition
 * compatible.</throws>
  </javadoc>
  <method type="void" name="checkSubtractionCompatible">
    <scope />
  </method>
  <javadoc>
    <text>Check if matrices are multiplication compatible</text>
    <param>left Left hand side matrix.</param>
    <param>right Right hand side matrix.</param>
    <throws>DimensionMismatchException if matrices are not multiplication
 * compatible.</throws>
  </javadoc>
  <method type="void" name="checkMultiplicationCompatible">
    <scope />
  </method>
  <javadoc>
    <text>Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.</text>
    <param>m Matrix to convert.</param>
    <return>the converted matrix.</return>
  </javadoc>
  <method type="Array2DRowRealMatrix" name="fractionMatrixToRealMatrix">
    <declaration type="FractionMatrixConverter" name="converter" />
  </method>
  <javadoc>
    <text>Converter for {@link FieldMatrix}/{@link Fraction}.</text>
  </javadoc>
  <javadoc>
    <text>Converted array.</text>
  </javadoc>
  <declaration type="double[][]" name="data" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="FractionMatrixConverter" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="start" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visit" />
  <javadoc>
    <text>Get the converted matrix.</text>
    <return>the converted matrix.</return>
  </javadoc>
  <method type="Array2DRowRealMatrix" name="getConvertedMatrix" />
  <javadoc>
    <text>Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.</text>
    <param>m Matrix to convert.</param>
    <return>the converted matrix.</return>
  </javadoc>
  <method type="Array2DRowRealMatrix" name="bigFractionMatrixToRealMatrix">
    <declaration type="BigFractionMatrixConverter" name="converter" />
  </method>
  <javadoc>
    <text>Converter for {@link FieldMatrix}/{@link BigFraction}.</text>
  </javadoc>
  <javadoc>
    <text>Converted array.</text>
  </javadoc>
  <declaration type="double[][]" name="data" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="BigFractionMatrixConverter" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="start" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visit" />
  <javadoc>
    <text>Get the converted matrix.</text>
    <return>the converted matrix.</return>
  </javadoc>
  <method type="Array2DRowRealMatrix" name="getConvertedMatrix" />
  <javadoc>
    <text>Serialize a {@link RealVector}.
 * &lt;p&gt;
 * This method is intended to be called from within a private
 * &lt;code&gt;writeObject&lt;/code&gt; method (after a call to
 * &lt;code&gt;oos.defaultWriteObject()&lt;/code&gt;) in a class that has a{@link RealVector} field, which should be declared &lt;code&gt;transient&lt;/code&gt;.
 * This way, the default handling does not serialize the vector (the {@link RealVector} interface is not serializable by default) but this method does
 * serialize it specifically.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The following example shows how a simple class with a name and a real vector
 * should be written:
 * &lt;pre&gt;&lt;code&gt;
 * public class NamedVector implements Serializable {
 * private final String name;
 * private final transient RealVector coefficients;
 * // omitted constructors, getters ...
 * private void writeObject(ObjectOutputStream oos) throws IOException {
 * oos.defaultWriteObject();  // takes care of name field
 * MatrixUtils.serializeRealVector(coefficients, oos);
 * }
 * private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
 * ois.defaultReadObject();  // takes care of name field
 * MatrixUtils.deserializeRealVector(this, "coefficients", ois);
 * }
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;/p&gt;</text>
    <param>vector real vector to serialize</param>
    <param>oos stream where the real vector should be written</param>
    <exception>IOException if object cannot be written to stream</exception>
    <see>#deserializeRealVector(Object,String,ObjectInputStream)</see>
  </javadoc>
  <method type="void" name="serializeRealVector">
    <declaration type="int" name="n" />
    <scope />
  </method>
  <javadoc>
    <text>Deserialize  a {@link RealVector} field in a class.
 * &lt;p&gt;
 * This method is intended to be called from within a private
 * &lt;code&gt;readObject&lt;/code&gt; method (after a call to
 * &lt;code&gt;ois.defaultReadObject()&lt;/code&gt;) in a class that has a{@link RealVector} field, which should be declared &lt;code&gt;transient&lt;/code&gt;.
 * This way, the default handling does not deserialize the vector (the {@link RealVector} interface is not serializable by default) but this method does
 * deserialize it specifically.
 * &lt;/p&gt;</text>
    <param>instance instance in which the field must be set up</param>
    <param>fieldName name of the field within the class (may be private and final)</param>
    <param>ois stream from which the real vector should be read</param>
    <exception>ClassNotFoundException if a class in the stream cannot be found</exception>
    <exception>IOException if object cannot be read from the stream</exception>
    <see>#serializeRealVector(RealVector,ObjectOutputStream)</see>
  </javadoc>
  <method type="void" name="deserializeRealVector">
    <scope>
      <declaration type="int" name="n" />
      <declaration type="double[]" name="data" />
      <scope />
      <declaration type="RealVector" name="vector" />
      <declaration type="java.lang.reflect.Field" name="f" />
    </scope>
    <scope>
      <declaration type="IOException" name="ioe" />
    </scope>
    <scope>
      <declaration type="IOException" name="ioe" />
    </scope>
    <comment>read the vector data</comment>
    <comment>create the instance</comment>
    <comment>set up the field</comment>
  </method>
  <javadoc>
    <text>Serialize a {@link RealMatrix}.
 * &lt;p&gt;
 * This method is intended to be called from within a private
 * &lt;code&gt;writeObject&lt;/code&gt; method (after a call to
 * &lt;code&gt;oos.defaultWriteObject()&lt;/code&gt;) in a class that has a{@link RealMatrix} field, which should be declared &lt;code&gt;transient&lt;/code&gt;.
 * This way, the default handling does not serialize the matrix (the {@link RealMatrix} interface is not serializable by default) but this method does
 * serialize it specifically.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The following example shows how a simple class with a name and a real matrix
 * should be written:
 * &lt;pre&gt;&lt;code&gt;
 * public class NamedMatrix implements Serializable {
 * private final String name;
 * private final transient RealMatrix coefficients;
 * // omitted constructors, getters ...
 * private void writeObject(ObjectOutputStream oos) throws IOException {
 * oos.defaultWriteObject();  // takes care of name field
 * MatrixUtils.serializeRealMatrix(coefficients, oos);
 * }
 * private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
 * ois.defaultReadObject();  // takes care of name field
 * MatrixUtils.deserializeRealMatrix(this, "coefficients", ois);
 * }
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;/p&gt;</text>
    <param>matrix real matrix to serialize</param>
    <param>oos stream where the real matrix should be written</param>
    <exception>IOException if object cannot be written to stream</exception>
    <see>#deserializeRealMatrix(Object,String,ObjectInputStream)</see>
  </javadoc>
  <method type="void" name="serializeRealMatrix">
    <declaration type="int" name="n" />
    <declaration type="int" name="m" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Deserialize  a {@link RealMatrix} field in a class.
 * &lt;p&gt;
 * This method is intended to be called from within a private
 * &lt;code&gt;readObject&lt;/code&gt; method (after a call to
 * &lt;code&gt;ois.defaultReadObject()&lt;/code&gt;) in a class that has a{@link RealMatrix} field, which should be declared &lt;code&gt;transient&lt;/code&gt;.
 * This way, the default handling does not deserialize the matrix (the {@link RealMatrix} interface is not serializable by default) but this method does
 * deserialize it specifically.
 * &lt;/p&gt;</text>
    <param>instance instance in which the field must be set up</param>
    <param>fieldName name of the field within the class (may be private and final)</param>
    <param>ois stream from which the real matrix should be read</param>
    <exception>ClassNotFoundException if a class in the stream cannot be found</exception>
    <exception>IOException if object cannot be read from the stream</exception>
    <see>#serializeRealMatrix(RealMatrix,ObjectOutputStream)</see>
  </javadoc>
  <method type="void" name="deserializeRealMatrix">
    <scope>
      <declaration type="int" name="n" />
      <declaration type="int" name="m" />
      <declaration type="double[][]" name="data" />
      <scope>
        <declaration type="double[]" name="dataI" />
        <scope />
      </scope>
      <declaration type="RealMatrix" name="matrix" />
      <declaration type="java.lang.reflect.Field" name="f" />
    </scope>
    <scope>
      <declaration type="IOException" name="ioe" />
    </scope>
    <scope>
      <declaration type="IOException" name="ioe" />
    </scope>
    <comment>read the matrix data</comment>
    <comment>create the instance</comment>
    <comment>set up the field</comment>
  </method>
  <javadoc>
    <text>Solve  a  system of composed of a Lower Triangular Matrix{@link RealMatrix}.
 * &lt;p&gt;
 * This method is called to solve systems of equations which are
 * of the lower triangular form. The matrix {@link RealMatrix}is assumed, though not checked, to be in lower triangular form.
 * The vector {@link RealVector} is overwritten with the solution.
 * The matrix is checked that it is square and its dimensions match
 * the length of the vector.
 * &lt;/p&gt;</text>
    <param>rm RealMatrix which is lower triangular</param>
    <param>b  RealVector this is overwritten</param>
    <throws>DimensionMismatchException if the matrix and vector are not
 * conformable</throws>
    <throws>NonSquareMatrixException if the matrix {@code rm} is not square</throws>
    <throws>MathArithmeticException if the absolute value of one of the diagonal
 * coefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}</throws>
  </javadoc>
  <method type="void" name="solveLowerTriangularSystem">
    <scope />
    <scope />
    <declaration type="int" name="rows" />
    <scope>
      <declaration type="double" name="diag" />
      <scope />
      <declaration type="double" name="bi" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Solver a  system composed  of an Upper Triangular Matrix{@link RealMatrix}.
 * &lt;p&gt;
 * This method is called to solve systems of equations which are
 * of the lower triangular form. The matrix {@link RealMatrix}is assumed, though not checked, to be in upper triangular form.
 * The vector {@link RealVector} is overwritten with the solution.
 * The matrix is checked that it is square and its dimensions match
 * the length of the vector.
 * &lt;/p&gt;</text>
    <param>rm RealMatrix which is upper triangular</param>
    <param>b  RealVector this is overwritten</param>
    <throws>DimensionMismatchException if the matrix and vector are not
 * conformable</throws>
    <throws>NonSquareMatrixException if the matrix {@code rm} is not
 * square</throws>
    <throws>MathArithmeticException if the absolute value of one of the diagonal
 * coefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}</throws>
  </javadoc>
  <method type="void" name="solveUpperTriangularSystem">
    <scope />
    <scope />
    <declaration type="int" name="rows" />
    <scope>
      <declaration type="double" name="diag" />
      <scope />
      <declaration type="double" name="bi" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Computes the inverse of the given matrix by splitting it into
 * 4 sub-matrices.</text>
    <param>m Matrix whose inverse must be computed.</param>
    <param>splitIndex Index that determines the "split" line and
 * column.
 * The element corresponding to this index will part of the
 * upper-left sub-matrix.</param>
    <return>the inverse of {@code m}.</return>
    <throws>NonSquareMatrixException if {@code m} is not square.</throws>
  </javadoc>
  <method type="RealMatrix" name="blockInverse">
    <declaration type="int" name="n" />
    <scope />
    <declaration type="int" name="splitIndex1" />
    <declaration type="RealMatrix" name="a" />
    <declaration type="RealMatrix" name="b" />
    <declaration type="RealMatrix" name="c" />
    <declaration type="RealMatrix" name="d" />
    <declaration type="SingularValueDecomposition" name="aDec" />
    <declaration type="RealMatrix" name="aInv" />
    <declaration type="SingularValueDecomposition" name="dDec" />
    <declaration type="RealMatrix" name="dInv" />
    <declaration type="RealMatrix" name="tmp1" />
    <declaration type="SingularValueDecomposition" name="tmp1Dec" />
    <declaration type="RealMatrix" name="result00" />
    <declaration type="RealMatrix" name="tmp2" />
    <declaration type="SingularValueDecomposition" name="tmp2Dec" />
    <declaration type="RealMatrix" name="result11" />
    <declaration type="RealMatrix" name="result01" />
    <declaration type="RealMatrix" name="result10" />
    <declaration type="RealMatrix" name="result" />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
