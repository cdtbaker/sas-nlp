<?xml version="1.0" encoding="UTF-8"?>
<class name="GaussianFitter">
  <javadoc>
    <text>Fits points to a {@link org.apache.commons.math3.analysis.function.Gaussian.Parametric Gaussian} function.
 * &lt;p&gt;
 * Usage example:
 * &lt;pre&gt;
 * GaussianFitter fitter = new GaussianFitter(
 * new LevenbergMarquardtOptimizer());
 * fitter.addObservedPoint(4.0254623,  531026.0);
 * fitter.addObservedPoint(4.03128248, 984167.0);
 * fitter.addObservedPoint(4.03839603, 1887233.0);
 * fitter.addObservedPoint(4.04421621, 2687152.0);
 * fitter.addObservedPoint(4.05132976, 3461228.0);
 * fitter.addObservedPoint(4.05326982, 3580526.0);
 * fitter.addObservedPoint(4.05779662, 3439750.0);
 * fitter.addObservedPoint(4.0636168,  2877648.0);
 * fitter.addObservedPoint(4.06943698, 2175960.0);
 * fitter.addObservedPoint(4.07525716, 1447024.0);
 * fitter.addObservedPoint(4.08237071, 717104.0);
 * fitter.addObservedPoint(4.08366408, 620014.0);
 * double[] parameters = fitter.fit();
 * &lt;/pre&gt;</text>
    <since>2.2</since>
    <version>$Id: GaussianFitter.java 1422230 2012-12-15 12:11:13Z erans $</version>
    <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
  </javadoc>
  <javadoc>
    <text>Constructs an instance using the specified optimizer.</text>
    <param>optimizer Optimizer to use for the fitting.</param>
  </javadoc>
  <method type="constructor" name="GaussianFitter" />
  <javadoc>
    <text>Fits a Gaussian function to the observed points.</text>
    <param>initialGuess First guess values in the following order:
 * &lt;ul&gt;
 * &lt;li&gt;Norm&lt;/li&gt;
 * &lt;li&gt;Mean&lt;/li&gt;
 * &lt;li&gt;Sigma&lt;/li&gt;
 * &lt;/ul&gt;</param>
    <return>the parameters of the Gaussian function that best fits the
 * observed points (in the same order as above).</return>
    <since>3.0</since>
  </javadoc>
  <method type="double[]" name="fit">
    <declaration type="Gaussian.Parametric[]" name="f" />
    <method type="double" name="value">
      <declaration type="double" name="v" />
      <scope />
      <scope />
    </method>
    <method type="double[]" name="gradient">
      <declaration type="double[]" name="v" />
      <scope />
      <scope />
    </method>
    <comment>NOPMD</comment>
    <comment>Do nothing.</comment>
    <comment>NOPMD</comment>
    <comment>Do nothing.</comment>
  </method>
  <javadoc>
    <text>Fits a Gaussian function to the observed points.</text>
    <return>the parameters of the Gaussian function that best fits the
 * observed points (in the same order as above).</return>
  </javadoc>
  <method type="double[]" name="fit">
    <declaration type="double[]" name="guess" />
  </method>
  <javadoc>
    <text>Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}of a {@link org.apache.commons.math3.analysis.function.Gaussian.Parametric}based on the specified observed points.</text>
  </javadoc>
  <javadoc>
    <text>Normalization factor.</text>
  </javadoc>
  <declaration type="double" name="norm" />
  <javadoc>
    <text>Mean.</text>
  </javadoc>
  <declaration type="double" name="mean" />
  <javadoc>
    <text>Standard deviation.</text>
  </javadoc>
  <declaration type="double" name="sigma" />
  <javadoc>
    <text>Constructs instance with the specified observed points.</text>
    <param>observations Observed points from which to guess the
 * parameters of the Gaussian.</param>
    <throws>NullArgumentException if {@code observations} is{@code null}.</throws>
    <throws>NumberIsTooSmallException if there are less than 3
 * observations.</throws>
  </javadoc>
  <method type="constructor" name="ParameterGuesser">
    <scope />
    <scope />
    <declaration type="WeightedObservedPoint[]" name="sorted" />
    <declaration type="double[]" name="params" />
  </method>
  <javadoc>
    <text>Gets an estimation of the parameters.</text>
    <return>the guessed parameters, in the following order:
 * &lt;ul&gt;
 * &lt;li&gt;Normalization factor&lt;/li&gt;
 * &lt;li&gt;Mean&lt;/li&gt;
 * &lt;li&gt;Standard deviation&lt;/li&gt;
 * &lt;/ul&gt;</return>
  </javadoc>
  <method type="double[]" name="guess" />
  <javadoc>
    <text>Sort the observations.</text>
    <param>unsorted Input observations.</param>
    <return>the input observations, sorted.</return>
  </javadoc>
  <method type="WeightedObservedPoint[]" name="sortObservations">
    <declaration type="WeightedObservedPoint[]" name="observations" />
    <declaration type="Comparator&lt;WeightedObservedPoint&gt;" name="cmp" />
    <method type="int" name="compare">
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
    </method>
  </method>
  <javadoc>
    <text>Guesses the parameters based on the specified observed points.</text>
    <param>points Observed points, sorted.</param>
    <return>the guessed parameters (normalization factor, mean and
 * sigma).</return>
  </javadoc>
  <method type="double[]" name="basicGuess">
    <declaration type="int" name="maxYIdx" />
    <declaration type="double" name="n" />
    <declaration type="double" name="m" />
    <declaration type="double" name="fwhmApprox" />
    <scope>
      <declaration type="double" name="halfY" />
      <declaration type="double" name="fwhmX1" />
      <declaration type="double" name="fwhmX2" />
    </scope>
    <scope />
    <declaration type="double" name="s" />
    <comment>TODO: Exceptions should not be used for flow control.</comment>
  </method>
  <javadoc>
    <text>Finds index of point in specified points with the largest Y.</text>
    <param>points Points to search.</param>
    <return>the index in specified points array.</return>
  </javadoc>
  <method type="int" name="findMaxY">
    <declaration type="int" name="maxYIdx" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Interpolates using the specified points to determine X at the
 * specified Y.</text>
    <param>points Points to use for interpolation.</param>
    <param>startIdx Index within points from which to start the search for
 * interpolation bounds points.</param>
    <param>idxStep Index step for searching interpolation bounds points.</param>
    <param>y Y value for which X should be determined.</param>
    <return>the value of X for the specified Y.</return>
    <throws>ZeroException if {@code idxStep} is 0.</throws>
    <throws>OutOfRangeException if specified {@code y} is not within the
 * range of the specified {@code points}.</throws>
  </javadoc>
  <method type="double" name="interpolateXAtY">
    <scope />
    <declaration type="WeightedObservedPoint[]" name="twoPoints" />
    <declaration type="WeightedObservedPoint" name="p1" />
    <declaration type="WeightedObservedPoint" name="p2" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Gets the two bounding interpolation points from the specified points
 * suitable for determining X at the specified Y.</text>
    <param>points Points to use for interpolation.</param>
    <param>startIdx Index within points from which to start search for
 * interpolation bounds points.</param>
    <param>idxStep Index step for search for interpolation bounds points.</param>
    <param>y Y value for which X should be determined.</param>
    <return>the array containing two points suitable for determining X at
 * the specified Y.</return>
    <throws>ZeroException if {@code idxStep} is 0.</throws>
    <throws>OutOfRangeException if specified {@code y} is not within the
 * range of the specified {@code points}.</throws>
  </javadoc>
  <method type="WeightedObservedPoint[]" name="getInterpolationPointsForY">
    <scope />
    <scope>
      <declaration type="WeightedObservedPoint" name="p1" />
      <declaration type="WeightedObservedPoint" name="p2" />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>Boundaries are replaced by dummy values because the raised</comment>
    <comment>exception is caught and the message never displayed.</comment>
    <comment>TODO: Exceptions should not be used for flow control.</comment>
  </method>
  <javadoc>
    <text>Determines whether a value is between two other values.</text>
    <param>value Value to test whether it is between {@code boundary1}and {@code boundary2}.</param>
    <param>boundary1 One end of the range.</param>
    <param>boundary2 Other end of the range.</param>
    <return>{@code true} if {@code value} is between {@code boundary1} and{@code boundary2} (inclusive), {@code false} otherwise.</return>
  </javadoc>
  <method type="boolean" name="isBetween" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
