<?xml version="1.0" encoding="UTF-8"?>
<class name="PolynomialFunctionLagrangeForm">
  <javadoc>
    <text>Implements the representation of a real polynomial function in
 * &lt;a href="http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html"&gt;
 * Lagrange Form&lt;/a&gt;. For reference, see &lt;b&gt;Introduction to Numerical
 * Analysis&lt;/b&gt;, ISBN 038795452X, chapter 2.
 * &lt;p&gt;
 * The approximated function should be smooth enough for Lagrange polynomial
 * to work well. Otherwise, consider using splines instead.&lt;/p&gt;</text>
    <version>$Id: PolynomialFunctionLagrangeForm.java 1455194 2013-03-11 15:45:54Z luc $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>The coefficients of the polynomial, ordered by degree -- i.e.
 * coefficients[0] is the constant term and coefficients[n] is the
 * coefficient of x^n where n is the degree of the polynomial.</text>
  </javadoc>
  <declaration type="double" name="coefficients" />
  <javadoc>
    <text>Interpolating points (abscissas).</text>
  </javadoc>
  <declaration type="double" name="x" />
  <javadoc>
    <text>Function values at interpolating points.</text>
  </javadoc>
  <declaration type="double" name="y" />
  <javadoc>
    <text>Whether the polynomial coefficients are available.</text>
  </javadoc>
  <declaration type="boolean" name="coefficientsComputed" />
  <javadoc>
    <text>Construct a Lagrange polynomial with the given abscissas and function
 * values. The order of interpolating points are not important.
 * &lt;p&gt;
 * The constructor makes copy of the input arrays and assigns them.&lt;/p&gt;</text>
    <param>x interpolating points</param>
    <param>y function values at interpolating points</param>
    <throws>DimensionMismatchException if the array lengths are different.</throws>
    <throws>NumberIsTooSmallException if the number of points is less than 2.</throws>
    <throws>NonMonotonicSequenceExceptionif two abscissae have the same value.</throws>
  </javadoc>
  <method type="constructor" name="PolynomialFunctionLagrangeForm">
    <scope />
    <comment>Second check in case some abscissa is duplicated.</comment>
  </method>
  <javadoc>
    <text>Calculate the function value at the given point.</text>
    <param>z Point at which the function value is to be computed.</param>
    <return>the function value.</return>
    <throws>DimensionMismatchException if {@code x} and {@code y} have
 * different lengths.</throws>
    <throws>org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif {@code x} is not sorted in strictly increasing order.</throws>
    <throws>NumberIsTooSmallException if the size of {@code x} is less
 * than 2.</throws>
  </javadoc>
  <method type="double" name="value" />
  <javadoc>
    <text>Returns the degree of the polynomial.</text>
    <return>the degree of the polynomial</return>
  </javadoc>
  <method type="int" name="degree" />
  <javadoc>
    <text>Returns a copy of the interpolating points array.
 * &lt;p&gt;
 * Changes made to the returned copy will not affect the polynomial.&lt;/p&gt;</text>
    <return>a fresh copy of the interpolating points array</return>
  </javadoc>
  <method type="double[]" name="getInterpolatingPoints">
    <declaration type="double[]" name="out" />
  </method>
  <javadoc>
    <text>Returns a copy of the interpolating values array.
 * &lt;p&gt;
 * Changes made to the returned copy will not affect the polynomial.&lt;/p&gt;</text>
    <return>a fresh copy of the interpolating values array</return>
  </javadoc>
  <method type="double[]" name="getInterpolatingValues">
    <declaration type="double[]" name="out" />
  </method>
  <javadoc>
    <text>Returns a copy of the coefficients array.
 * &lt;p&gt;
 * Changes made to the returned copy will not affect the polynomial.&lt;/p&gt;
 * &lt;p&gt;
 * Note that coefficients computation can be ill-conditioned. Use with caution
 * and only when it is necessary.&lt;/p&gt;</text>
    <return>a fresh copy of the coefficients array</return>
  </javadoc>
  <method type="double[]" name="getCoefficients">
    <scope />
    <declaration type="double[]" name="out" />
  </method>
  <javadoc>
    <text>Evaluate the Lagrange polynomial using
 * &lt;a href="http://mathworld.wolfram.com/NevillesAlgorithm.html"&gt;
 * Neville's Algorithm&lt;/a&gt;. It takes O(n^2) time.</text>
    <param>x Interpolating points array.</param>
    <param>y Interpolating values array.</param>
    <param>z Point at which the function value is to be computed.</param>
    <return>the function value.</return>
    <throws>DimensionMismatchException if {@code x} and {@code y} have
 * different lengths.</throws>
    <throws>NonMonotonicSequenceExceptionif {@code x} is not sorted in strictly increasing order.</throws>
    <throws>NumberIsTooSmallException if the size of {@code x} is less
 * than 2.</throws>
  </javadoc>
  <method type="double" name="evaluate">
    <scope />
    <declaration type="double[]" name="xNew" />
    <declaration type="double[]" name="yNew" />
    <comment>Array is not sorted.</comment>
    <comment>Second check in case some abscissa is duplicated.</comment>
  </method>
  <javadoc>
    <text>Evaluate the Lagrange polynomial using
 * &lt;a href="http://mathworld.wolfram.com/NevillesAlgorithm.html"&gt;
 * Neville's Algorithm&lt;/a&gt;. It takes O(n^2) time.</text>
    <param>x Interpolating points array.</param>
    <param>y Interpolating values array.</param>
    <param>z Point at which the function value is to be computed.</param>
    <return>the function value.</return>
    <throws>DimensionMismatchException if {@code x} and {@code y} have
 * different lengths.</throws>
    <throws>org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif {@code x} is not sorted in strictly increasing order.</throws>
    <throws>NumberIsTooSmallException if the size of {@code x} is less
 * than 2.</throws>
  </javadoc>
  <method type="double" name="evaluateInternal">
    <declaration type="int" name="nearest" />
    <declaration type="int" name="n" />
    <declaration type="double[]" name="c" />
    <declaration type="double[]" name="d" />
    <declaration type="double" name="min_dist" />
    <scope>
      <declaration type="double" name="dist" />
      <scope />
    </scope>
    <declaration type="double" name="value" />
    <scope>
      <scope>
        <declaration type="double" name="tc" />
        <declaration type="double" name="td" />
        <declaration type="double" name="divider" />
        <declaration type="double" name="w" />
      </scope>
      <scope />
      <scope />
    </scope>
    <comment>initialize the difference arrays</comment>
    <comment>find out the abscissa closest to z</comment>
    <comment>initial approximation to the function value at z</comment>
    <comment>update the difference arrays</comment>
    <comment>sum up the difference terms to get the final value</comment>
    <comment>fork down</comment>
    <comment>fork up</comment>
  </method>
  <javadoc>
    <text>Calculate the coefficients of Lagrange polynomial from the
 * interpolation data. It takes O(n^2) time.
 * Note that this computation can be ill-conditioned: Use with caution
 * and only when it is necessary.</text>
  </javadoc>
  <method type="void" name="computeCoefficients">
    <declaration type="int" name="n" />
    <scope />
    <declaration type="double[]" name="c" />
    <scope>
      <scope />
    </scope>
    <declaration type="double[]" name="tc" />
    <scope>
      <declaration type="double" name="d" />
      <scope>
        <scope />
      </scope>
      <declaration type="double" name="t" />
      <scope />
    </scope>
    <comment>c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])</comment>
    <comment>d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])</comment>
    <comment>Lagrange polynomial is the sum of n terms, each of which is a</comment>
    <comment>polynomial of degree n-1. tc[] are the coefficients of the i-th</comment>
    <comment>numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).</comment>
    <comment>actually c[n] = 1</comment>
  </method>
  <javadoc>
    <text>Check that the interpolation arrays are valid.
 * The arrays features checked by this method are that both arrays have the
 * same length and this length is at least 2.</text>
    <param>x Interpolating points array.</param>
    <param>y Interpolating values array.</param>
    <param>abort Whether to throw an exception if {@code x} is not sorted.</param>
    <throws>DimensionMismatchException if the array lengths are different.</throws>
    <throws>NumberIsTooSmallException if the number of points is less than 2.</throws>
    <throws>org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif {@code x} is not sorted in strictly increasing order and {@code abort}is {@code true}.</throws>
    <return>{@code false} if the {@code x} is not sorted in increasing order,{@code true} otherwise.</return>
    <see>#evaluate(double[],double[],double)</see>
    <see>#computeCoefficients()</see>
  </javadoc>
  <method type="boolean" name="verifyInterpolationArray">
    <scope />
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
