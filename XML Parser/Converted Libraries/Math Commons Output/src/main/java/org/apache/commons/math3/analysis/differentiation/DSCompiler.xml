<?xml version="1.0" encoding="UTF-8"?>
<class name="DSCompiler">
  <javadoc>
    <text>Class holding "compiled" computation rules for derivative structures.
 * &lt;p&gt;This class implements the computation rules described in Dan Kalman's paper &lt;a
 * href="http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"&gt;Doubly
 * Recursive Multivariate Automatic Differentiation&lt;/a&gt;, Mathematics Magazine, vol. 75,
 * no. 3, June 2002. However, in order to avoid performances bottlenecks, the recursive
 * rules are "compiled" once in an unfold form. This class does this recursion unrolling
 * and stores the computation rules as simple loops with pre-computed indirection arrays.&lt;/p&gt;
 * &lt;p&gt;
 * This class maps all derivative computation into single dimension arrays that hold the
 * value and partial derivatives. The class does not hold these arrays, which remains under
 * the responsibility of the caller. For each combination of number of free parameters and
 * derivation order, only one compiler is necessary, and this compiler will be used to
 * perform computations on all arrays provided to it, which can represent hundreds or
 * thousands of different parameters kept together with all theur partial derivatives.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The arrays on which compilers operate contain only the partial derivatives together
 * with the 0&lt;sup&gt;th&lt;/sup&gt; derivative, i.e. the value. The partial derivatives are stored in
 * a compiler-specific order, which can be retrieved using methods {@link #getPartialDerivativeIndex(int...) getPartialDerivativeIndex} and {@link #getPartialDerivativeOrders(int)}. The value is guaranteed to be stored as the first element
 * (i.e. the {@link #getPartialDerivativeIndex(int...) getPartialDerivativeIndex} method returns
 * 0 when called with 0 for all derivation orders and {@link #getPartialDerivativeOrders(int)getPartialDerivativeOrders} returns an array filled with 0 when called with 0 as the index).
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note that the ordering changes with number of parameters and derivation order. For example
 * given 2 parameters x and y, df/dy is stored at index 2 when derivation order is set to 1 (in
 * this case the array has three elements: f, df/dx and df/dy). If derivation order is set to
 * 2, then df/dy will be stored at index 3 (in this case the array has six elements: f, df/dx,
 * df/dxdx, df/dy, df/dxdy and df/dydy).
 * &lt;/p&gt;
 * &lt;p&gt;
 * Given this structure, users can perform some simple operations like adding, subtracting
 * or multiplying constants and negating the elements by themselves, knowing if they want to
 * mutate their array or create a new array. These simple operations are not provided by
 * the compiler. The compiler provides only the more complex operations between several arrays.
 * &lt;/p&gt;
 * &lt;p&gt;This class is mainly used as the engine for scalar variable {@link DerivativeStructure}.
 * It can also be used directly to hold several variables in arrays for more complex data
 * structures. User can for example store a vector of n variables depending on three x, y
 * and z free parameters in one array as follows:
 * &lt;pre&gt;
 * // parameter 0 is x, parameter 1 is y, parameter 2 is z
 * int parameters = 3;
 * DSCompiler compiler = DSCompiler.getCompiler(parameters, order);
 * int size = compiler.getSize();
 * // pack all elements in a single array
 * double[] array = new double[n * size];
 * for (int i = 0; i &lt; n; ++i) {
 * // we know value is guaranteed to be the first element
 * array[i * size] = v[i];
 * // we don't know where first derivatives are stored, so we ask the compiler
 * array[i * size + compiler.getPartialDerivativeIndex(1, 0, 0) = dvOnDx[i][0];
 * array[i * size + compiler.getPartialDerivativeIndex(0, 1, 0) = dvOnDy[i][0];
 * array[i * size + compiler.getPartialDerivativeIndex(0, 0, 1) = dvOnDz[i][0];
 * // we let all higher order derivatives set to 0
 * }
 * &lt;/pre&gt;
 * Then in another function, user can perform some operations on all elements stored
 * in the single array, such as a simple product of all variables:
 * &lt;pre&gt;
 * // compute the product of all elements
 * double[] product = new double[size];
 * prod[0] = 1.0;
 * for (int i = 0; i &lt; n; ++i) {
 * double[] tmp = product.clone();
 * compiler.multiply(tmp, 0, array, i * size, product, 0);
 * }
 * // value
 * double p = product[0];
 * // first derivatives
 * double dPdX = product[compiler.getPartialDerivativeIndex(1, 0, 0)];
 * double dPdY = product[compiler.getPartialDerivativeIndex(0, 1, 0)];
 * double dPdZ = product[compiler.getPartialDerivativeIndex(0, 0, 1)];
 * // cross derivatives (assuming order was at least 2)
 * double dPdXdX = product[compiler.getPartialDerivativeIndex(2, 0, 0)];
 * double dPdXdY = product[compiler.getPartialDerivativeIndex(1, 1, 0)];
 * double dPdXdZ = product[compiler.getPartialDerivativeIndex(1, 0, 1)];
 * double dPdYdY = product[compiler.getPartialDerivativeIndex(0, 2, 0)];
 * double dPdYdZ = product[compiler.getPartialDerivativeIndex(0, 1, 1)];
 * double dPdZdZ = product[compiler.getPartialDerivativeIndex(0, 0, 2)];
 * &lt;/p&gt;</text>
    <see>DerivativeStructure</see>
    <version>$Id: DSCompiler.java 1462503 2013-03-29 15:48:27Z luc $</version>
    <since>3.1</since>
  </javadoc>
  <javadoc>
    <text>Array of all compilers created so far.</text>
  </javadoc>
  <declaration type="AtomicReference&lt;DSCompiler[][]&gt;" name="compilers" />
  <javadoc>
    <text>Number of free parameters.</text>
  </javadoc>
  <declaration type="int" name="parameters" />
  <javadoc>
    <text>Derivation order.</text>
  </javadoc>
  <declaration type="int" name="order" />
  <javadoc>
    <text>Number of partial derivatives (including the single 0 order derivative element).</text>
  </javadoc>
  <declaration type="int[][]" name="sizes" />
  <javadoc>
    <text>Indirection array for partial derivatives.</text>
  </javadoc>
  <declaration type="int[][]" name="derivativesIndirection" />
  <javadoc>
    <text>Indirection array of the lower derivative elements.</text>
  </javadoc>
  <declaration type="int[]" name="lowerIndirection" />
  <javadoc>
    <text>Indirection arrays for multiplication.</text>
  </javadoc>
  <declaration type="int[][][]" name="multIndirection" />
  <javadoc>
    <text>Indirection arrays for function composition.</text>
  </javadoc>
  <declaration type="int[][][]" name="compIndirection" />
  <javadoc>
    <text>Private constructor, reserved for the factory method {@link #getCompiler(int,int)}.</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>valueCompiler compiler for the value part</param>
    <param>derivativeCompiler compiler for the derivative part</param>
    <throws>NumberIsTooLargeException if order is too large</throws>
  </javadoc>
  <method type="constructor" name="DSCompiler" />
  <javadoc>
    <text>Get the compiler for number of free parameters and order.</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <return>cached rules set</return>
    <throws>NumberIsTooLargeException if order is too large</throws>
  </javadoc>
  <method type="DSCompiler" name="getCompiler">
    <declaration type="DSCompiler[][]" name="cache" />
    <scope />
    <declaration type="int" name="maxParameters" />
    <declaration type="int" name="maxOrder" />
    <declaration type="DSCompiler[][]" name="newCache" />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope>
        <declaration type="int" name="p" />
        <scope>
          <declaration type="DSCompiler" name="valueCompiler" />
          <declaration type="DSCompiler" name="derivativeCompiler" />
        </scope>
      </scope>
    </scope>
    <comment>get the cached compilers</comment>
    <comment>the compiler has already been created</comment>
    <comment>we need to create more compilers</comment>
    <comment>preserve the already created compilers</comment>
    <comment>create the array in increasing diagonal order</comment>
    <comment>atomically reset the cached compilers array</comment>
  </method>
  <javadoc>
    <text>Compile the sizes array.</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>valueCompiler compiler for the value part</param>
    <return>sizes array</return>
  </javadoc>
  <method type="int[][]" name="compileSizes">
    <declaration type="int[][]" name="sizes" />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compile the derivatives indirection array.</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>valueCompiler compiler for the value part</param>
    <param>derivativeCompiler compiler for the derivative part</param>
    <return>derivatives indirection array</return>
  </javadoc>
  <method type="int[][]" name="compileDerivativesIndirection">
    <scope />
    <declaration type="int" name="vSize" />
    <declaration type="int" name="dSize" />
    <declaration type="int[][]" name="derivativesIndirection" />
    <scope />
    <scope />
    <comment>set up the indices for the value part</comment>
    <comment>copy the first indices, the last one remaining set to 0</comment>
    <comment>set up the indices for the derivative part</comment>
    <comment>copy the indices</comment>
    <comment>increment the derivation order for the last parameter</comment>
  </method>
  <javadoc>
    <text>Compile the lower derivatives indirection array.
 * &lt;p&gt;
 * This indirection array contains the indices of all elements
 * except derivatives for last derivation order.
 * &lt;/p&gt;</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>valueCompiler compiler for the value part</param>
    <param>derivativeCompiler compiler for the derivative part</param>
    <return>lower derivatives indirection array</return>
  </javadoc>
  <method type="int[]" name="compileLowerIndirection">
    <scope />
    <declaration type="int" name="vSize" />
    <declaration type="int" name="dSize" />
    <declaration type="int[]" name="lowerIndirection" />
    <scope />
    <comment>this is an implementation of definition 6 in Dan Kalman's paper.</comment>
  </method>
  <javadoc>
    <text>Compile the multiplication indirection array.
 * &lt;p&gt;
 * This indirection array contains the indices of all pairs of elements
 * involved when computing a multiplication. This allows a straightforward
 * loop-based multiplication (see {@link #multiply(double[],int,double[],int,double[],int)}).
 * &lt;/p&gt;</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>valueCompiler compiler for the value part</param>
    <param>derivativeCompiler compiler for the derivative part</param>
    <param>lowerIndirection lower derivatives indirection array</param>
    <return>multiplication indirection array</return>
  </javadoc>
  <method type="int[][][]" name="compileMultiplicationIndirection">
    <scope />
    <declaration type="int" name="vSize" />
    <declaration type="int" name="dSize" />
    <declaration type="int[][][][]" name="multIndirection" />
    <scope>
      <declaration type="int[][]" name="dRow" />
      <declaration type="List&lt;int[]&gt;[]" name="row" />
      <scope />
      <declaration type="List&lt;int[]&gt;[]" name="combined" />
      <scope>
        <declaration type="int[]" name="termJ" />
        <scope>
          <scope>
            <declaration type="int[]" name="termK" />
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>this is an implementation of definition 3 in Dan Kalman's paper.</comment>
    <comment>combine terms with similar derivation orders</comment>
    <comment>combine termJ and termK</comment>
    <comment>make sure we will skip termK later on in the outer loop</comment>
  </method>
  <javadoc>
    <text>Compile the function composition indirection array.
 * &lt;p&gt;
 * This indirection array contains the indices of all sets of elements
 * involved when computing a composition. This allows a straightforward
 * loop-based composition (see {@link #compose(double[],int,double[],double[],int)}).
 * &lt;/p&gt;</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>valueCompiler compiler for the value part</param>
    <param>derivativeCompiler compiler for the derivative part</param>
    <param>sizes sizes array</param>
    <param>derivativesIndirection derivatives indirection array</param>
    <return>multiplication indirection array</return>
    <throws>NumberIsTooLargeException if order is too large</throws>
  </javadoc>
  <method type="int[][][]" name="compileCompositionIndirection">
    <scope />
    <declaration type="int" name="vSize" />
    <declaration type="int" name="dSize" />
    <declaration type="int[][][][]" name="compIndirection" />
    <scope>
      <declaration type="List&lt;int[]&gt;[]" name="row" />
      <scope>
        <declaration type="int[]" name="derivedTermF" />
        <declaration type="int[]" name="orders" />
        <scope />
        <scope>
          <declaration type="int[]" name="derivedTermG" />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
      <declaration type="List&lt;int[]&gt;[]" name="combined" />
      <scope>
        <declaration type="int[]" name="termJ" />
        <scope>
          <scope>
            <declaration type="int[]" name="termK" />
            <declaration type="boolean" name="equals" />
            <scope />
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>the composition rules from the value part can be reused as is</comment>
    <comment>the composition rules for the derivative part are deduced by</comment>
    <comment>differentiation the rules from the underlying compiler once</comment>
    <comment>with respect to the parameter this compiler handles and the</comment>
    <comment>underlying one did not handle</comment>
    <comment>handle term p * f_k(g(x)) * g_l1(x) * g_l2(x) * ... * g_lp(x)</comment>
    <comment>derive the first factor in the term: f_k with respect to new parameter</comment>
    <comment>p</comment>
    <comment>f_(k+1)</comment>
    <comment>g_1</comment>
    <comment>convert the indices as the mapping for the current order</comment>
    <comment>is different from the mapping with one less order</comment>
    <comment>derive the various g_l</comment>
    <comment>convert the indices as the mapping for the current order</comment>
    <comment>is different from the mapping with one less order</comment>
    <comment>derive this term</comment>
    <comment>combine terms with similar derivation orders</comment>
    <comment>combine termJ and termK</comment>
    <comment>make sure we will skip termK later on in the outer loop</comment>
  </method>
  <javadoc>
    <text>Get the index of a partial derivative in the array.
 * &lt;p&gt;
 * If all orders are set to 0, then the 0&lt;sup&gt;th&lt;/sup&gt; order derivative
 * is returned, which is the value of the function.
 * &lt;/p&gt;
 * &lt;p&gt;The indices of derivatives are between 0 and {@link #getSize() getSize()} - 1.
 * Their specific order is fixed for a given compiler, but otherwise not
 * publicly specified. There are however some simple cases which have guaranteed
 * indices:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;the index of 0&lt;sup&gt;th&lt;/sup&gt; order derivative is always 0&lt;/li&gt;
 * &lt;li&gt;if there is only 1 {@link #getFreeParameters() free parameter}, then the
 * derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp
 * at index 1, d&lt;sup&gt;2&lt;/sup&gt;f/dp&lt;sup&gt;2&lt;/sup&gt; at index 2 ...
 * d&lt;sup&gt;k&lt;/sup&gt;f/dp&lt;sup&gt;k&lt;/sup&gt; at index k),&lt;/li&gt;
 * &lt;li&gt;if the {@link #getOrder() derivation order} is 1, then the derivatives
 * are sorted in increasing free parameter order (i.e. f at index 0, df/dx&lt;sub&gt;1&lt;/sub&gt;
 * at index 1, df/dx&lt;sub&gt;2&lt;/sub&gt; at index 2 ... df/dx&lt;sub&gt;k&lt;/sub&gt; at index k),&lt;/li&gt;
 * &lt;li&gt;all other cases are not publicly specified&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * This method is the inverse of method {@link #getPartialDerivativeOrders(int)}&lt;/p&gt;</text>
    <param>orders derivation orders with respect to each parameter</param>
    <return>index of the partial derivative</return>
    <exception>DimensionMismatchException if the numbers of parameters does not
 * match the instance</exception>
    <exception>NumberIsTooLargeException if sum of derivation orders is larger
 * than the instance limits</exception>
    <see>#getPartialDerivativeOrders(int)</see>
  </javadoc>
  <method type="int" name="getPartialDerivativeIndex">
    <scope />
    <comment>safety check</comment>
  </method>
  <javadoc>
    <text>Get the index of a partial derivative in an array.</text>
    <param>parameters number of free parameters</param>
    <param>order derivation order</param>
    <param>sizes sizes array</param>
    <param>orders derivation orders with respect to each parameter
 * (the lenght of this array must match the number of parameters)</param>
    <return>index of the partial derivative</return>
    <exception>NumberIsTooLargeException if sum of derivation orders is larger
 * than the instance limits</exception>
  </javadoc>
  <method type="int" name="getPartialDerivativeIndex">
    <declaration type="int" name="index" />
    <declaration type="int" name="m" />
    <declaration type="int" name="ordersSum" />
    <scope>
      <declaration type="int" name="derivativeOrder" />
      <scope />
      <scope />
    </scope>
    <comment>the value is obtained by diving into the recursive Dan Kalman's structure</comment>
    <comment>this is theorem 2 of his paper, with recursion replaced by iteration</comment>
    <comment>derivative order for current free parameter</comment>
    <comment>safety check</comment>
    <comment>as long as we differentiate according to current free parameter,</comment>
    <comment>we have to skip the value part and dive into the derivative part</comment>
    <comment>so we add the size of the value part to the base index</comment>
  </method>
  <javadoc>
    <text>Convert an index from one (parameters, order) structure to another.</text>
    <param>index index of a partial derivative in source derivative structure</param>
    <param>srcP number of free parameters in source derivative structure</param>
    <param>srcDerivativesIndirection derivatives indirection array for the source
 * derivative structure</param>
    <param>destP number of free parameters in destination derivative structure</param>
    <param>destO derivation order in destination derivative structure</param>
    <param>destSizes sizes array for the destination derivative structure</param>
    <return>index of the partial derivative with the &lt;em&gt;same&lt;/em&gt; characteristics
 * in destination derivative structure</return>
    <throws>NumberIsTooLargeException if order is too large</throws>
  </javadoc>
  <method type="int" name="convertIndex">
    <declaration type="int[]" name="orders" />
  </method>
  <javadoc>
    <text>Get the derivation orders for a specific index in the array.
 * &lt;p&gt;
 * This method is the inverse of {@link #getPartialDerivativeIndex(int...)}.
 * &lt;/p&gt;</text>
    <param>index of the partial derivative</param>
    <return>orders derivation orders with respect to each parameter</return>
    <see>#getPartialDerivativeIndex(int...)</see>
  </javadoc>
  <method type="int[]" name="getPartialDerivativeOrders" />
  <javadoc>
    <text>Get the number of free parameters.</text>
    <return>number of free parameters</return>
  </javadoc>
  <method type="int" name="getFreeParameters" />
  <javadoc>
    <text>Get the derivation order.</text>
    <return>derivation order</return>
  </javadoc>
  <method type="int" name="getOrder" />
  <javadoc>
    <text>Get the array size required for holding partial derivatives data.
 * &lt;p&gt;
 * This number includes the single 0 order derivative element, which is
 * guaranteed to be stored in the first element of the array.
 * &lt;/p&gt;</text>
    <return>array size required for holding partial derivatives data</return>
  </javadoc>
  <method type="int" name="getSize" />
  <javadoc>
    <text>Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2</text>
    <param>a1 first scale factor</param>
    <param>c1 first base (unscaled) component</param>
    <param>offset1 offset of first operand in its array</param>
    <param>a2 second scale factor</param>
    <param>c2 second base (unscaled) component</param>
    <param>offset2 offset of second operand in its array</param>
    <param>result array where result must be stored (it may be
 * one of the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="linearCombination">
    <scope />
  </method>
  <javadoc>
    <text>Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4</text>
    <param>a1 first scale factor</param>
    <param>c1 first base (unscaled) component</param>
    <param>offset1 offset of first operand in its array</param>
    <param>a2 second scale factor</param>
    <param>c2 second base (unscaled) component</param>
    <param>offset2 offset of second operand in its array</param>
    <param>a3 third scale factor</param>
    <param>c3 third base (unscaled) component</param>
    <param>offset3 offset of third operand in its array</param>
    <param>result array where result must be stored (it may be
 * one of the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="linearCombination">
    <scope />
  </method>
  <javadoc>
    <text>Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4</text>
    <param>a1 first scale factor</param>
    <param>c1 first base (unscaled) component</param>
    <param>offset1 offset of first operand in its array</param>
    <param>a2 second scale factor</param>
    <param>c2 second base (unscaled) component</param>
    <param>offset2 offset of second operand in its array</param>
    <param>a3 third scale factor</param>
    <param>c3 third base (unscaled) component</param>
    <param>offset3 offset of third operand in its array</param>
    <param>a4 fourth scale factor</param>
    <param>c4 fourth base (unscaled) component</param>
    <param>offset4 offset of fourth operand in its array</param>
    <param>result array where result must be stored (it may be
 * one of the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="linearCombination">
    <scope />
  </method>
  <javadoc>
    <text>Perform addition of two derivative structures.</text>
    <param>lhs array holding left hand side of addition</param>
    <param>lhsOffset offset of the left hand side in its array</param>
    <param>rhs array right hand side of addition</param>
    <param>rhsOffset offset of the right hand side in its array</param>
    <param>result array where result must be stored (it may be
 * one of the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="add">
    <scope />
  </method>
  <javadoc>
    <text>Perform subtraction of two derivative structures.</text>
    <param>lhs array holding left hand side of subtraction</param>
    <param>lhsOffset offset of the left hand side in its array</param>
    <param>rhs array right hand side of subtraction</param>
    <param>rhsOffset offset of the right hand side in its array</param>
    <param>result array where result must be stored (it may be
 * one of the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="subtract">
    <scope />
  </method>
  <javadoc>
    <text>Perform multiplication of two derivative structures.</text>
    <param>lhs array holding left hand side of multiplication</param>
    <param>lhsOffset offset of the left hand side in its array</param>
    <param>rhs array right hand side of multiplication</param>
    <param>rhsOffset offset of the right hand side in its array</param>
    <param>result array where result must be stored (for
 * multiplication the result array &lt;em&gt;cannot&lt;/em&gt; be one of
 * the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="multiply">
    <scope>
      <declaration type="int[][]" name="mappingI" />
      <declaration type="double" name="r" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Perform division of two derivative structures.</text>
    <param>lhs array holding left hand side of division</param>
    <param>lhsOffset offset of the left hand side in its array</param>
    <param>rhs array right hand side of division</param>
    <param>rhsOffset offset of the right hand side in its array</param>
    <param>result array where result must be stored (for
 * division the result array &lt;em&gt;cannot&lt;/em&gt; be one of
 * the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="divide">
    <declaration type="double[]" name="reciprocal" />
  </method>
  <javadoc>
    <text>Perform remainder of two derivative structures.</text>
    <param>lhs array holding left hand side of remainder</param>
    <param>lhsOffset offset of the left hand side in its array</param>
    <param>rhs array right hand side of remainder</param>
    <param>rhsOffset offset of the right hand side in its array</param>
    <param>result array where result must be stored (it may be
 * one of the input arrays)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="remainder">
    <declaration type="double" name="rem" />
    <declaration type="double" name="k" />
    <scope />
    <comment>compute k such that lhs % rhs = lhs - k rhs</comment>
    <comment>set up value</comment>
    <comment>set up partial derivatives</comment>
  </method>
  <javadoc>
    <text>Compute power of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>p power to apply</param>
    <param>result array where result must be stored (for
 * power the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="pow">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="xk" />
    <scope />
    <declaration type="double" name="coefficient" />
    <scope />
    <comment>create the function value and derivatives</comment>
    <comment>[x^p, px^(p-1), p(p-1)x^(p-2), ... ]</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute integer power of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>n power to apply</param>
    <param>result array where result must be stored (for
 * power the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="pow">
    <scope />
    <declaration type="double[]" name="function" />
    <scope>
      <declaration type="int" name="maxOrder" />
      <declaration type="double" name="xk" />
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="inv" />
      <declaration type="double" name="xk" />
      <scope />
    </scope>
    <declaration type="double" name="coefficient" />
    <scope />
    <comment>special case, x^0 = 1 for all x</comment>
    <comment>create the power function value and derivatives</comment>
    <comment>[x^n, nx^(n-1), n(n-1)x^(n-2), ... ]</comment>
    <comment>strictly positive power</comment>
    <comment>strictly negative power</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute power of a derivative structure.</text>
    <param>x array holding the base</param>
    <param>xOffset offset of the base in its array</param>
    <param>y array holding the exponent</param>
    <param>yOffset offset of the exponent in its array</param>
    <param>result array where result must be stored (for
 * power the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="pow">
    <declaration type="double[]" name="logX" />
    <declaration type="double[]" name="yLogX" />
  </method>
  <javadoc>
    <text>Compute n&lt;sup&gt;th&lt;/sup&gt; root of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>n order of the root</param>
    <param>result array where result must be stored (for
 * n&lt;sup&gt;th&lt;/sup&gt; root the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="rootN">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="xk" />
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="nReciprocal" />
    <declaration type="double" name="xReciprocal" />
    <scope />
    <comment>create the function value and derivatives</comment>
    <comment>[x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute exponential of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * exponential the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="exp">
    <declaration type="double[]" name="function" />
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute exp(x) - 1 of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * exponential the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="expm1">
    <declaration type="double[]" name="function" />
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute natural logarithm of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * logarithm the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="log">
    <declaration type="double[]" name="function" />
    <scope>
      <declaration type="double" name="inv" />
      <declaration type="double" name="xk" />
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Computes shifted logarithm of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * shifted logarithm the result array &lt;em&gt;cannot&lt;/em&gt; be the input array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="log1p">
    <declaration type="double[]" name="function" />
    <scope>
      <declaration type="double" name="inv" />
      <declaration type="double" name="xk" />
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Computes base 10 logarithm of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * base 10 logarithm the result array &lt;em&gt;cannot&lt;/em&gt; be the input array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="log10">
    <declaration type="double[]" name="function" />
    <scope>
      <declaration type="double" name="inv" />
      <declaration type="double" name="xk" />
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute cosine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * cosine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="cos">
    <declaration type="double[]" name="function" />
    <scope>
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute sine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * sine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="sin">
    <declaration type="double[]" name="function" />
    <scope>
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute tangent of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * tangent the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="tan">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="t" />
    <scope>
      <declaration type="double[]" name="p" />
      <declaration type="double" name="t2" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of tan has the form:</comment>
    <comment>dn(tan(x)/dxn = P_n(tan(x))</comment>
    <comment>where P_n(t) is a degree n+1 polynomial with same parity as n+1</comment>
    <comment>P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...</comment>
    <comment>the general recurrence relation for P_n is:</comment>
    <comment>P_n(x) = (1+t^2) P_(n-1)'(t)</comment>
    <comment>as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array</comment>
    <comment>update and evaluate polynomial P_n(t)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute arc cosine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * arc cosine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="acos">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="x" />
    <scope>
      <declaration type="double[]" name="p" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="f" />
      <declaration type="double" name="coeff" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of acos has the form:</comment>
    <comment>dn(acos(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)</comment>
    <comment>where P_n(x) is a degree n-1 polynomial with same parity as n-1</comment>
    <comment>P_1(x) = -1, P_2(x) = -x, P_3(x) = -2x^2 - 1 ...</comment>
    <comment>the general recurrence relation for P_n is:</comment>
    <comment>P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)</comment>
    <comment>as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array</comment>
    <comment>update and evaluate polynomial P_n(x)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute arc sine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * arc sine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="asin">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="x" />
    <scope>
      <declaration type="double[]" name="p" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="f" />
      <declaration type="double" name="coeff" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of asin has the form:</comment>
    <comment>dn(asin(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)</comment>
    <comment>where P_n(x) is a degree n-1 polynomial with same parity as n-1</comment>
    <comment>P_1(x) = 1, P_2(x) = x, P_3(x) = 2x^2 + 1 ...</comment>
    <comment>the general recurrence relation for P_n is:</comment>
    <comment>P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)</comment>
    <comment>as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array</comment>
    <comment>update and evaluate polynomial P_n(x)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute arc tangent of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * arc tangent the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="atan">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="x" />
    <scope>
      <declaration type="double[]" name="q" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="f" />
      <declaration type="double" name="coeff" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of atan has the form:</comment>
    <comment>dn(atan(x)/dxn = Q_n(x) / (1 + x^2)^n</comment>
    <comment>where Q_n(x) is a degree n-1 polynomial with same parity as n-1</comment>
    <comment>Q_1(x) = 1, Q_2(x) = -2x, Q_3(x) = 6x^2 - 2 ...</comment>
    <comment>the general recurrence relation for Q_n is:</comment>
    <comment>Q_n(x) = (1+x^2) Q_(n-1)'(x) - 2(n-1) x Q_(n-1)(x)</comment>
    <comment>as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array</comment>
    <comment>update and evaluate polynomial Q_n(x)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute two arguments arc tangent of a derivative structure.</text>
    <param>y array holding the first operand</param>
    <param>yOffset offset of the first operand in its array</param>
    <param>x array holding the second operand</param>
    <param>xOffset offset of the second operand in its array</param>
    <param>result array where result must be stored (for
 * two arguments arc tangent the result array &lt;em&gt;cannot&lt;/em&gt;
 * be the input array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="atan2">
    <declaration type="double[]" name="tmp1" />
    <declaration type="double[]" name="tmp2" />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>compute r = sqrt(x^2+y^2)</comment>
    <comment>x^2</comment>
    <comment>y^2</comment>
    <comment>x^2 + y^2</comment>
    <comment>r = sqrt(x^2 + y^2)</comment>
    <comment>compute atan2(y, x) = 2 atan(y / (r + x))</comment>
    <comment>r + x</comment>
    <comment>y /(r + x)</comment>
    <comment>atan(y / (r + x))</comment>
    <comment>2 * atan(y / (r + x))</comment>
    <comment>compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))</comment>
    <comment>r - x</comment>
    <comment>y /(r - x)</comment>
    <comment>atan(y / (r - x))</comment>
    <comment>+/-pi - 2 * atan(y / (r - x))</comment>
    <comment>+/-pi - 2 * atan(y / (r - x))</comment>
    <comment>fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly</comment>
  </method>
  <javadoc>
    <text>Compute hyperbolic cosine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * hyperbolic cosine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="cosh">
    <declaration type="double[]" name="function" />
    <scope>
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute hyperbolic sine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * hyperbolic sine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="sinh">
    <declaration type="double[]" name="function" />
    <scope>
      <scope />
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute hyperbolic tangent of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * hyperbolic tangent the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="tanh">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="t" />
    <scope>
      <declaration type="double[]" name="p" />
      <declaration type="double" name="t2" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of tanh has the form:</comment>
    <comment>dn(tanh(x)/dxn = P_n(tanh(x))</comment>
    <comment>where P_n(t) is a degree n+1 polynomial with same parity as n+1</comment>
    <comment>P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ...</comment>
    <comment>the general recurrence relation for P_n is:</comment>
    <comment>P_n(x) = (1-t^2) P_(n-1)'(t)</comment>
    <comment>as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array</comment>
    <comment>update and evaluate polynomial P_n(t)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute inverse hyperbolic cosine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * inverse hyperbolic cosine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="acosh">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="x" />
    <scope>
      <declaration type="double[]" name="p" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="f" />
      <declaration type="double" name="coeff" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of acosh has the form:</comment>
    <comment>dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)</comment>
    <comment>where P_n(x) is a degree n-1 polynomial with same parity as n-1</comment>
    <comment>P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...</comment>
    <comment>the general recurrence relation for P_n is:</comment>
    <comment>P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)</comment>
    <comment>as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array</comment>
    <comment>update and evaluate polynomial P_n(x)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute inverse hyperbolic sine of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * inverse hyperbolic sine the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="asinh">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="x" />
    <scope>
      <declaration type="double[]" name="p" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="f" />
      <declaration type="double" name="coeff" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of asinh has the form:</comment>
    <comment>dn(asinh(x)/dxn = P_n(x) / [x^2 + 1]^((2n-1)/2)</comment>
    <comment>where P_n(x) is a degree n-1 polynomial with same parity as n-1</comment>
    <comment>P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 - 1 ...</comment>
    <comment>the general recurrence relation for P_n is:</comment>
    <comment>P_n(x) = (x^2+1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)</comment>
    <comment>as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array</comment>
    <comment>update and evaluate polynomial P_n(x)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute inverse hyperbolic tangent of a derivative structure.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>result array where result must be stored (for
 * inverse hyperbolic tangent the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="atanh">
    <declaration type="double[]" name="function" />
    <declaration type="double" name="x" />
    <scope>
      <declaration type="double[]" name="q" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="f" />
      <declaration type="double" name="coeff" />
      <scope>
        <declaration type="double" name="v" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>create the function value and derivatives</comment>
    <comment>the nth order derivative of atanh has the form:</comment>
    <comment>dn(atanh(x)/dxn = Q_n(x) / (1 - x^2)^n</comment>
    <comment>where Q_n(x) is a degree n-1 polynomial with same parity as n-1</comment>
    <comment>Q_1(x) = 1, Q_2(x) = 2x, Q_3(x) = 6x^2 + 2 ...</comment>
    <comment>the general recurrence relation for Q_n is:</comment>
    <comment>Q_n(x) = (1-x^2) Q_(n-1)'(x) + 2(n-1) x Q_(n-1)(x)</comment>
    <comment>as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array</comment>
    <comment>update and evaluate polynomial Q_n(x)</comment>
    <comment>apply function composition</comment>
  </method>
  <javadoc>
    <text>Compute composition of a derivative structure by a function.</text>
    <param>operand array holding the operand</param>
    <param>operandOffset offset of the operand in its array</param>
    <param>f array of value and derivatives of the function at
 * the current point (i.e. at {@code operand[operandOffset]}).</param>
    <param>result array where result must be stored (for
 * composition the result array &lt;em&gt;cannot&lt;/em&gt; be the input
 * array)</param>
    <param>resultOffset offset of the result in its array</param>
  </javadoc>
  <method type="void" name="compose">
    <scope>
      <declaration type="int[][]" name="mappingI" />
      <declaration type="double" name="r" />
      <scope>
        <declaration type="int[]" name="mappingIJ" />
        <declaration type="double" name="product" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Evaluate Taylor expansion of a derivative structure.</text>
    <param>ds array holding the derivative structure</param>
    <param>dsOffset offset of the derivative structure in its array</param>
    <param>delta parameters offsets (&amp;Delta;x, &amp;Delta;y, ...)</param>
    <return>value of the Taylor expansion at x + &amp;Delta;x, y + &amp;Delta;y, ...</return>
    <throws>MathArithmeticException if factorials becomes too large</throws>
  </javadoc>
  <method type="double" name="taylor">
    <declaration type="double" name="value" />
    <scope>
      <declaration type="int[]" name="orders" />
      <declaration type="double" name="term" />
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>this cannot happen</comment>
  </method>
  <javadoc>
    <text>Check rules set compatibility.</text>
    <param>compiler other compiler to check against instance</param>
    <exception>DimensionMismatchException if number of free parameters or orders are inconsistent</exception>
  </javadoc>
  <method type="void" name="checkCompatibility">
    <scope />
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
