<?xml version="1.0" encoding="UTF-8"?>
<class name="DfpMath">
  <javadoc>
    <text>Mathematical routines for use with {@link Dfp}.
 * The constants are defined in {@link DfpField}</text>
    <version>$Id: DfpMath.java 1462503 2013-03-29 15:48:27Z luc $</version>
    <since>2.2</since>
  </javadoc>
  <javadoc>
    <text>Name for traps triggered by pow.</text>
  </javadoc>
  <declaration type="String" name="POW_TRAP" />
  <javadoc>
    <text>Private Constructor.</text>
  </javadoc>
  <method type="constructor" name="DfpMath" />
  <javadoc>
    <text>Breaks a string representation up into two dfp's.
 * &lt;p&gt;The two dfp are such that the sum of them is equivalent
 * to the input string, but has higher precision than using a
 * single dfp. This is useful for improving accuracy of
 * exponentiation and critical multiplies.</text>
    <param>field field to which the Dfp must belong</param>
    <param>a string representation to split</param>
    <return>an array of two {@link Dfp} which sum is a</return>
  </javadoc>
  <method type="Dfp[]" name="split">
    <declaration type="Dfp[]" name="result" />
    <declaration type="char[]" name="buf" />
    <declaration type="boolean" name="leading" />
    <declaration type="int" name="sp" />
    <declaration type="int" name="sig" />
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.</text>
    <param>a number to split</param>
    <return>two elements array containing the split number</return>
  </javadoc>
  <method type="Dfp[]" name="split">
    <declaration type="Dfp[]" name="result" />
    <declaration type="Dfp" name="shift" />
  </method>
  <javadoc>
    <text>Multiply two numbers that are split in to two pieces that are
 * meant to be added together.
 * Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1
 * Store the first term in result0, the rest in result1</text>
    <param>a first factor of the multiplication, in split form</param>
    <param>b second factor of the multiplication, in split form</param>
    <return>a &amp;times; b, in split form</return>
  </javadoc>
  <method type="Dfp[]" name="splitMult">
    <declaration type="Dfp[]" name="result" />
    <scope />
    <comment>If result[0] is infinite or zero, don't compute result[1].
 Attempting to do so may produce NaNs.</comment>
  </method>
  <javadoc>
    <text>Divide two numbers that are split in to two pieces that are meant to be added together.
 * Inverse of split multiply above:
 * (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )</text>
    <param>a dividend, in split form</param>
    <param>b divisor, in split form</param>
    <return>a / b, in split form</return>
  </javadoc>
  <method type="Dfp[]" name="splitDiv">
    <declaration type="Dfp[]" name="result" />
  </method>
  <javadoc>
    <text>Raise a split base to the a power.</text>
    <param>base number to raise</param>
    <param>a power</param>
    <return>base&lt;sup&gt;a&lt;/sup&gt;</return>
  </javadoc>
  <method type="Dfp" name="splitPow">
    <declaration type="boolean" name="invert" />
    <declaration type="Dfp[]" name="r" />
    <declaration type="Dfp[]" name="result" />
    <scope />
    <scope />
    <scope>
      <declaration type="int" name="trial" />
      <declaration type="int" name="prevtrial" />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>Special case a = 0</comment>
    <comment>If a is less than zero</comment>
    <comment>Exponentiate by successive squaring</comment>
  </method>
  <javadoc>
    <text>Raises base to the power a by successive squaring.</text>
    <param>base number to raise</param>
    <param>a power</param>
    <return>base&lt;sup&gt;a&lt;/sup&gt;</return>
  </javadoc>
  <method type="Dfp" name="pow">
    <declaration type="boolean" name="invert" />
    <declaration type="Dfp" name="result" />
    <scope />
    <scope />
    <scope>
      <declaration type="Dfp" name="r" />
      <declaration type="Dfp" name="prevr" />
      <declaration type="int" name="trial" />
      <declaration type="int" name="prevtrial" />
      <scope />
    </scope>
    <scope />
    <comment>Special case</comment>
    <comment>Exponentiate by successive squaring</comment>
  </method>
  <javadoc>
    <text>Computes e to the given power.
 * a is broken into two parts, such that a = n+m  where n is an integer.
 * We use pow() to compute e&lt;sup&gt;n&lt;/sup&gt; and a Taylor series to compute
 * e&lt;sup&gt;m&lt;/sup&gt;.  We return e*&lt;sup&gt;n&lt;/sup&gt; &amp;times; e&lt;sup&gt;m&lt;/sup&gt;</text>
    <param>a power at which e should be raised</param>
    <return>e&lt;sup&gt;a&lt;/sup&gt;</return>
  </javadoc>
  <method type="Dfp" name="exp">
    <declaration type="Dfp" name="inta" />
    <declaration type="Dfp" name="fraca" />
    <declaration type="int" name="ia" />
    <scope />
    <scope />
    <declaration type="Dfp" name="einta" />
    <declaration type="Dfp" name="efraca" />
    <comment>return +Infinity</comment>
    <comment>return 0;</comment>
  </method>
  <javadoc>
    <text>Computes e to the given power.
 * Where -1 &lt; a &lt; 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...</text>
    <param>a power at which e should be raised</param>
    <return>e&lt;sup&gt;a&lt;/sup&gt;</return>
  </javadoc>
  <method type="Dfp" name="expInternal">
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="x" />
    <declaration type="Dfp" name="fact" />
    <declaration type="Dfp" name="py" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the natural logarithm of a.
 * a is first split into three parts such that  a = (10000^h)(2^j)k.
 * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)
 * k is in the range 2/3 &lt; k &lt;4/3 and is passed on to a series expansion.</text>
    <param>a number from which logarithm is requested</param>
    <return>log(a)</return>
  </javadoc>
  <method type="Dfp" name="log">
    <declaration type="int" name="lr" />
    <declaration type="Dfp" name="x" />
    <declaration type="int" name="ix" />
    <declaration type="int" name="p2" />
    <scope />
    <scope />
    <scope />
    <declaration type="Dfp[]" name="spx" />
    <declaration type="Dfp[]" name="spy" />
    <scope />
    <declaration type="Dfp[]" name="spz" />
    <comment>Check the arguments somewhat here</comment>
    <comment>negative, zero or NaN</comment>
    <comment>x = x.divide(pow(a.newInstance(10000), lr));   This puts x in the range 0-10000</comment>
    <comment>use spy[0] temporarily as a divisor</comment>
    <comment>Use spy[0] for comparison</comment>
    <comment>X is now in the range of 2/3 &lt; x &lt; 4/3</comment>
  </method>
  <javadoc>
    <text>Computes the natural log of a number between 0 and 2.
 * Let f(x) = ln(x),
 * We know that f'(x) = 1/x, thus from Taylor's theorum we have:
 * -----          n+1         n
 * f(x) =   \           (-1)    (x - 1)
 * /          ----------------    for 1 &lt;= n &lt;= infinity
 * -----             n
 * or
 * 2        3       4
 * (x-1)   (x-1)    (x-1)
 * ln(x) =  (x-1) - ----- + ------ - ------ + ...
 * 2       3        4
 * alternatively,
 * 2    3   4
 * x    x   x
 * ln(x+1) =  x - -  + - - - + ...
 * 2    3   4
 * This series can be used to compute ln(x), but it converges too slowly.
 * If we substitute -x for x above, we get
 * 2    3    4
 * x    x    x
 * ln(1-x) =  -x - -  - -  - - + ...
 * 2    3    4
 * Note that all terms are now negative.  Because the even powered ones
 * absorbed the sign.  Now, subtract the series above from the previous
 * one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
 * only the odd ones
 * 3     5      7
 * 2x    2x     2x
 * ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
 * 3     5      7
 * By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
 * 3        5        7
 * x+1           /          x        x        x          \
 * ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
 * x-1           \          3        5        7          /
 * But now we want to find ln(a), so we need to find the value of x
 * such that a = (x+1)/(x-1).   This is easily solved to find that
 * x = (a-1)/(a+1).</text>
    <param>a number from which logarithm is requested, in split form</param>
    <return>log(a)</return>
  </javadoc>
  <method type="Dfp[]" name="logInternal">
    <declaration type="Dfp" name="t" />
    <declaration type="Dfp" name="x" />
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="num" />
    <declaration type="Dfp" name="py" />
    <declaration type="int" name="den" />
    <scope>
      <scope />
    </scope>
    <comment>Now we want to compute x = (a-1)(a+1) but this is prone to
 loss of precision.  So instead, compute x = (a4 - 14)  (a4 + 14)</comment>
  </method>
  <javadoc>
    <text>Computes x to the y power.&lt;p&gt;
 * Uses the following method:&lt;p&gt;
 * &lt;ol&gt;
 * &lt;li&gt; Set u = rint(y), v = y-u
 * &lt;li&gt; Compute a = v * ln(x)
 * &lt;li&gt; Compute b = rint( a/ln(2) )
 * &lt;li&gt; Compute c = a - b*ln(2)
 * &lt;li&gt; x&lt;sup&gt;y&lt;/sup&gt; = x&lt;sup&gt;u&lt;/sup&gt;  *   2&lt;sup&gt;b&lt;/sup&gt; * e&lt;sup&gt;c&lt;/sup&gt;
 * &lt;/ol&gt;
 * if |y| &gt; 1e8, then we compute by exp(y*ln(x))   &lt;p&gt;
 * &lt;b&gt;Special Cases&lt;/b&gt;&lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;  if y is 0.0 or -0.0 then result is 1.0
 * &lt;li&gt;  if y is 1.0 then result is x
 * &lt;li&gt;  if y is NaN then result is NaN
 * &lt;li&gt;  if x is NaN and y is not zero then result is NaN
 * &lt;li&gt;  if |x| &gt; 1.0 and y is +Infinity then result is +Infinity
 * &lt;li&gt;  if |x| &lt; 1.0 and y is -Infinity then result is +Infinity
 * &lt;li&gt;  if |x| &gt; 1.0 and y is -Infinity then result is +0
 * &lt;li&gt;  if |x| &lt; 1.0 and y is +Infinity then result is +0
 * &lt;li&gt;  if |x| = 1.0 and y is +/-Infinity then result is NaN
 * &lt;li&gt;  if x = +0 and y &gt; 0 then result is +0
 * &lt;li&gt;  if x = +Inf and y &lt; 0 then result is +0
 * &lt;li&gt;  if x = +0 and y &lt; 0 then result is +Inf
 * &lt;li&gt;  if x = +Inf and y &gt; 0 then result is +Inf
 * &lt;li&gt;  if x = -0 and y &gt; 0, finite, not odd integer then result is +0
 * &lt;li&gt;  if x = -0 and y &lt; 0, finite, and odd integer then result is -Inf
 * &lt;li&gt;  if x = -Inf and y &gt; 0, finite, and odd integer then result is -Inf
 * &lt;li&gt;  if x = -0 and y &lt; 0, not finite odd integer then result is +Inf
 * &lt;li&gt;  if x = -Inf and y &gt; 0, not finite odd integer then result is +Inf
 * &lt;li&gt;  if x &lt; 0 and y &gt; 0, finite, and odd integer then result is -(|x|&lt;sup&gt;y&lt;/sup&gt;)
 * &lt;li&gt;  if x &lt; 0 and y &gt; 0, finite, and not integer then result is NaN
 * &lt;/ul&gt;</text>
    <param>x base to be raised</param>
    <param>y power to which base should be raised</param>
    <return>x&lt;sup&gt;y&lt;/sup&gt;</return>
  </javadoc>
  <method type="Dfp" name="pow">
    <scope>
      <declaration type="Dfp" name="result" />
    </scope>
    <declaration type="Dfp" name="zero" />
    <declaration type="Dfp" name="one" />
    <declaration type="Dfp" name="two" />
    <declaration type="boolean" name="invert" />
    <declaration type="int" name="ui" />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope>
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope />
    <declaration type="Dfp" name="r" />
    <scope>
      <declaration type="Dfp" name="u" />
      <declaration type="Dfp" name="v" />
      <scope>
        <declaration type="Dfp" name="a" />
        <declaration type="Dfp" name="b" />
        <declaration type="Dfp" name="c" />
      </scope>
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>make sure we don't mix number with different precision</comment>
    <comment>Check for special cases</comment>
    <comment>Test for NaNs</comment>
    <comment>Test for NaNs</comment>
    <comment>X == 0</comment>
    <comment>X == +0</comment>
    <comment>X == -0</comment>
    <comment>If y is odd integer</comment>
    <comment>Y is not odd integer</comment>
    <comment>Make x positive, but keep track of it</comment>
    <comment>x = +/- inf</comment>
    <comment>negative infinity</comment>
    <comment>If y is odd integer</comment>
    <comment>Y is not odd integer</comment>
    <comment>positive infinity</comment>
    <comment>End special cases</comment>
    <comment>very large exponent.  |y| &gt; 1e8</comment>
    <comment>if y is odd integer</comment>
  </method>
  <javadoc>
    <text>Computes sin(a)  Used when 0 &lt; a &lt; pi/4.
 * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...</text>
    <param>a number from which sine is desired, in split form</param>
    <return>sin(a)</return>
  </javadoc>
  <method type="Dfp" name="sinInternal">
    <declaration type="Dfp" name="c" />
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="x" />
    <declaration type="Dfp" name="fact" />
    <declaration type="Dfp" name="py" />
    <scope>
      <scope />
    </scope>
    <comment>1 over fact</comment>
  </method>
  <javadoc>
    <text>Computes cos(a)  Used when 0 &lt; a &lt; pi/4.
 * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...</text>
    <param>a number from which cosine is desired, in split form</param>
    <return>cos(a)</return>
  </javadoc>
  <method type="Dfp" name="cosInternal">
    <declaration type="Dfp" name="one" />
    <declaration type="Dfp" name="x" />
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="c" />
    <declaration type="Dfp" name="fact" />
    <declaration type="Dfp" name="py" />
    <scope>
      <scope />
    </scope>
    <comment>1 over fact</comment>
  </method>
  <javadoc>
    <text>computes the sine of the argument.</text>
    <param>a number from which sine is desired</param>
    <return>sin(a)</return>
  </javadoc>
  <method type="Dfp" name="sin">
    <declaration type="Dfp" name="pi" />
    <declaration type="Dfp" name="zero" />
    <declaration type="boolean" name="neg" />
    <declaration type="Dfp" name="x" />
    <scope />
    <scope />
    <declaration type="Dfp" name="y" />
    <scope>
      <declaration type="Dfp[]" name="c" />
    </scope>
    <scope>
      <declaration type="Dfp[]" name="c" />
      <declaration type="Dfp[]" name="piSplit" />
    </scope>
    <scope />
    <comment>First reduce the argument to the range of +- PI</comment>
    <comment>if x &lt; 0 then apply identity sin(-x) = -sin(x)</comment>
    <comment>This puts x in the range 0 &lt; x &lt; PI</comment>
    <comment>Since sine(x) = sine(pi - x) we can reduce the range to
 0 &lt; x &lt; pi2</comment>
    <comment>y = sinInternal(c);</comment>
  </method>
  <javadoc>
    <text>computes the cosine of the argument.</text>
    <param>a number from which cosine is desired</param>
    <return>cos(a)</return>
  </javadoc>
  <method type="Dfp" name="cos">
    <declaration type="Dfp" name="pi" />
    <declaration type="Dfp" name="zero" />
    <declaration type="boolean" name="neg" />
    <declaration type="Dfp" name="x" />
    <scope />
    <scope />
    <declaration type="Dfp" name="y" />
    <scope>
      <declaration type="Dfp[]" name="c" />
    </scope>
    <scope>
      <declaration type="Dfp[]" name="c" />
      <declaration type="Dfp[]" name="piSplit" />
    </scope>
    <scope />
    <comment>First reduce the argument to the range of +- PI</comment>
    <comment>if x &lt; 0 then apply identity cos(-x) = cos(x)</comment>
    <comment>This puts x in the range 0 &lt; x &lt; PI</comment>
    <comment>Since cos(x) = -cos(pi - x) we can reduce the range to
 0 &lt; x &lt; pi2</comment>
  </method>
  <javadoc>
    <text>computes the tangent of the argument.</text>
    <param>a number from which tangent is desired</param>
    <return>tan(a)</return>
  </javadoc>
  <method type="Dfp" name="tan" />
  <javadoc>
    <text>computes the arc-tangent of the argument.</text>
    <param>a number from which arc-tangent is desired</param>
    <return>atan(a)</return>
  </javadoc>
  <method type="Dfp" name="atanInternal">
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="x" />
    <declaration type="Dfp" name="py" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>computes the arc tangent of the argument
 * Uses the typical taylor series
 * but may reduce arguments using the following identity
 * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))
 * since tan(PI/8) = sqrt(2)-1,
 * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0</text>
    <param>a number from which arc-tangent is desired</param>
    <return>atan(a)</return>
  </javadoc>
  <method type="Dfp" name="atan">
    <declaration type="Dfp" name="zero" />
    <declaration type="Dfp" name="one" />
    <declaration type="Dfp[]" name="sqr2Split" />
    <declaration type="Dfp[]" name="piSplit" />
    <declaration type="boolean" name="recp" />
    <declaration type="boolean" name="neg" />
    <declaration type="boolean" name="sub" />
    <declaration type="Dfp" name="ty" />
    <declaration type="Dfp" name="x" />
    <scope />
    <scope />
    <scope>
      <declaration type="Dfp[]" name="sty" />
      <declaration type="Dfp[]" name="xs" />
      <declaration type="Dfp[]" name="ds" />
    </scope>
    <declaration type="Dfp" name="y" />
    <scope />
    <scope />
    <scope />
    <comment>x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));</comment>
  </method>
  <javadoc>
    <text>computes the arc-sine of the argument.</text>
    <param>a number from which arc-sine is desired</param>
    <return>asin(a)</return>
  </javadoc>
  <method type="Dfp" name="asin" />
  <javadoc>
    <text>computes the arc-cosine of the argument.</text>
    <param>a number from which arc-cosine is desired</param>
    <return>acos(a)</return>
  </javadoc>
  <method type="Dfp" name="acos">
    <declaration type="Dfp" name="result" />
    <declaration type="boolean" name="negative" />
    <scope />
    <scope />
    <comment>absolute value</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
