<?xml version="1.0" encoding="UTF-8"?>
<class name="PolynomialsUtils">
  <javadoc>
    <text>A collection of static methods that operate on or return polynomials.</text>
    <version>$Id: PolynomialsUtils.java 1364387 2012-07-22 18:14:11Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Coefficients for Chebyshev polynomials.</text>
  </javadoc>
  <declaration type="List&lt;BigFraction&gt;" name="CHEBYSHEV_COEFFICIENTS" />
  <javadoc>
    <text>Coefficients for Hermite polynomials.</text>
  </javadoc>
  <declaration type="List&lt;BigFraction&gt;" name="HERMITE_COEFFICIENTS" />
  <javadoc>
    <text>Coefficients for Laguerre polynomials.</text>
  </javadoc>
  <declaration type="List&lt;BigFraction&gt;" name="LAGUERRE_COEFFICIENTS" />
  <javadoc>
    <text>Coefficients for Legendre polynomials.</text>
  </javadoc>
  <declaration type="List&lt;BigFraction&gt;" name="LEGENDRE_COEFFICIENTS" />
  <javadoc>
    <text>Coefficients for Jacobi polynomials.</text>
  </javadoc>
  <declaration type="Map&lt;JacobiKey,List&lt;BigFraction&gt;&gt;" name="JACOBI_COEFFICIENTS" />
  <scope />
  <javadoc>
    <text>Private constructor, to prevent instantiation.</text>
  </javadoc>
  <method type="constructor" name="PolynomialsUtils" />
  <javadoc>
    <text>Create a Chebyshev polynomial of the first kind.
 * &lt;p&gt;&lt;a href="http://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html"&gt;Chebyshev
 * polynomials of the first kind&lt;/a&gt; are orthogonal polynomials.
 * They can be defined by the following recurrence relations:
 * &lt;pre&gt;
 * T&lt;sub&gt;0&lt;/sub&gt;(X)   = 1
 * T&lt;sub&gt;1&lt;/sub&gt;(X)   = X
 * T&lt;sub&gt;k+1&lt;/sub&gt;(X) = 2X T&lt;sub&gt;k&lt;/sub&gt;(X) - T&lt;sub&gt;k-1&lt;/sub&gt;(X)
 * &lt;/pre&gt;&lt;/p&gt;</text>
    <param>degree degree of the polynomial</param>
    <return>Chebyshev polynomial of specified degree</return>
  </javadoc>
  <method type="PolynomialFunction" name="createChebyshevPolynomial">
    <declaration type="BigFraction[]" name="coeffs" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="BigFraction[]" name="generate" />
  </method>
  <javadoc>
    <text>Create a Hermite polynomial.
 * &lt;p&gt;&lt;a href="http://mathworld.wolfram.com/HermitePolynomial.html"&gt;Hermite
 * polynomials&lt;/a&gt; are orthogonal polynomials.
 * They can be defined by the following recurrence relations:
 * &lt;pre&gt;
 * H&lt;sub&gt;0&lt;/sub&gt;(X)   = 1
 * H&lt;sub&gt;1&lt;/sub&gt;(X)   = 2X
 * H&lt;sub&gt;k+1&lt;/sub&gt;(X) = 2X H&lt;sub&gt;k&lt;/sub&gt;(X) - 2k H&lt;sub&gt;k-1&lt;/sub&gt;(X)
 * &lt;/pre&gt;&lt;/p&gt;</text>
    <param>degree degree of the polynomial</param>
    <return>Hermite polynomial of specified degree</return>
  </javadoc>
  <method type="PolynomialFunction" name="createHermitePolynomial">
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="BigFraction[]" name="generate" />
  </method>
  <javadoc>
    <text>Create a Laguerre polynomial.
 * &lt;p&gt;&lt;a href="http://mathworld.wolfram.com/LaguerrePolynomial.html"&gt;Laguerre
 * polynomials&lt;/a&gt; are orthogonal polynomials.
 * They can be defined by the following recurrence relations:
 * &lt;pre&gt;
 * L&lt;sub&gt;0&lt;/sub&gt;(X)   = 1
 * L&lt;sub&gt;1&lt;/sub&gt;(X)   = 1 - X
 * (k+1) L&lt;sub&gt;k+1&lt;/sub&gt;(X) = (2k + 1 - X) L&lt;sub&gt;k&lt;/sub&gt;(X) - k L&lt;sub&gt;k-1&lt;/sub&gt;(X)
 * &lt;/pre&gt;&lt;/p&gt;</text>
    <param>degree degree of the polynomial</param>
    <return>Laguerre polynomial of specified degree</return>
  </javadoc>
  <method type="PolynomialFunction" name="createLaguerrePolynomial">
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="BigFraction[]" name="generate">
      <declaration type="int" name="kP1" />
    </method>
  </method>
  <javadoc>
    <text>Create a Legendre polynomial.
 * &lt;p&gt;&lt;a href="http://mathworld.wolfram.com/LegendrePolynomial.html"&gt;Legendre
 * polynomials&lt;/a&gt; are orthogonal polynomials.
 * They can be defined by the following recurrence relations:
 * &lt;pre&gt;
 * P&lt;sub&gt;0&lt;/sub&gt;(X)   = 1
 * P&lt;sub&gt;1&lt;/sub&gt;(X)   = X
 * (k+1) P&lt;sub&gt;k+1&lt;/sub&gt;(X) = (2k+1) X P&lt;sub&gt;k&lt;/sub&gt;(X) - k P&lt;sub&gt;k-1&lt;/sub&gt;(X)
 * &lt;/pre&gt;&lt;/p&gt;</text>
    <param>degree degree of the polynomial</param>
    <return>Legendre polynomial of specified degree</return>
  </javadoc>
  <method type="PolynomialFunction" name="createLegendrePolynomial">
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="BigFraction[]" name="generate">
      <declaration type="int" name="kP1" />
    </method>
  </method>
  <javadoc>
    <text>Create a Jacobi polynomial.
 * &lt;p&gt;&lt;a href="http://mathworld.wolfram.com/JacobiPolynomial.html"&gt;Jacobi
 * polynomials&lt;/a&gt; are orthogonal polynomials.
 * They can be defined by the following recurrence relations:
 * &lt;pre&gt;
 * P&lt;sub&gt;0&lt;/sub&gt;&lt;sup&gt;vw&lt;/sup&gt;(X)   = 1
 * P&lt;sub&gt;-1&lt;/sub&gt;&lt;sup&gt;vw&lt;/sup&gt;(X)  = 0
 * 2k(k + v + w)(2k + v + w - 2) P&lt;sub&gt;k&lt;/sub&gt;&lt;sup&gt;vw&lt;/sup&gt;(X) =
 * (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) X + v&lt;sup&gt;2&lt;/sup&gt; - w&lt;sup&gt;2&lt;/sup&gt;] P&lt;sub&gt;k-1&lt;/sub&gt;&lt;sup&gt;vw&lt;/sup&gt;(X)
 * - 2(k + v - 1)(k + w - 1)(2k + v + w) P&lt;sub&gt;k-2&lt;/sub&gt;&lt;sup&gt;vw&lt;/sup&gt;(X)
 * &lt;/pre&gt;&lt;/p&gt;</text>
    <param>degree degree of the polynomial</param>
    <param>v first exponent</param>
    <param>w second exponent</param>
    <return>Jacobi polynomial of specified degree</return>
  </javadoc>
  <method type="PolynomialFunction" name="createJacobiPolynomial">
    <declaration type="JacobiKey" name="key" />
    <scope>
      <declaration type="List&lt;BigFraction&gt;" name="list" />
    </scope>
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="BigFraction[]" name="generate">
      <declaration type="int" name="kvw" />
      <declaration type="int" name="twoKvw" />
      <declaration type="int" name="twoKvwM1" />
      <declaration type="int" name="twoKvwM2" />
      <declaration type="int" name="den" />
    </method>
    <comment>select the appropriate list</comment>
    <comment>allocate a new list for v, w</comment>
    <comment>Pv,w,0(x) = 1;</comment>
    <comment>P1(x) = (v - w) / 2 + (2 + v + w) * X / 2</comment>
  </method>
  <javadoc>
    <text>Inner class for Jacobi polynomials keys.</text>
  </javadoc>
  <javadoc>
    <text>First exponent.</text>
  </javadoc>
  <declaration type="int" name="v" />
  <javadoc>
    <text>Second exponent.</text>
  </javadoc>
  <declaration type="int" name="w" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>v first exponent</param>
    <param>w second exponent</param>
  </javadoc>
  <method type="constructor" name="JacobiKey" />
  <javadoc>
    <text>Get hash code.</text>
    <return>hash code</return>
  </javadoc>
  <method type="int" name="hashCode" />
  <javadoc>
    <text>Check if the instance represent the same key as another instance.</text>
    <param>key other key</param>
    <return>true if the instance and the other key refer to the same polynomial</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <declaration type="JacobiKey" name="otherK" />
  </method>
  <javadoc>
    <text>Compute the coefficients of the polynomial &lt;code&gt;P&lt;sub&gt;s&lt;/sub&gt;(x)&lt;/code&gt;
 * whose values at point {@code x} will be the same as the those from the
 * original polynomial &lt;code&gt;P(x)&lt;/code&gt; when computed at {@code x + shift}.
 * Thus, if &lt;code&gt;P(x) = &amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; a&lt;sub&gt;i&lt;/sub&gt; x&lt;sup&gt;i&lt;/sup&gt;&lt;/code&gt;,
 * then
 * &lt;pre&gt;
 * &lt;table&gt;
 * &lt;tr&gt;
 * &lt;td&gt;&lt;code&gt;P&lt;sub&gt;s&lt;/sub&gt;(x)&lt;/td&gt;
 * &lt;td&gt;= &amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt; x&lt;sup&gt;i&lt;/sup&gt;&lt;/code&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;&lt;/td&gt;
 * &lt;td&gt;= &amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; a&lt;sub&gt;i&lt;/sub&gt; (x + shift)&lt;sup&gt;i&lt;/sup&gt;&lt;/code&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/pre&gt;</text>
    <param>coefficients Coefficients of the original polynomial.</param>
    <param>shift Shift value.</param>
    <return>the coefficients &lt;code&gt;b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt; of the shifted
 * polynomial.</return>
  </javadoc>
  <method type="double[]" name="shift">
    <declaration type="int" name="dp1" />
    <declaration type="double[]" name="newCoefficients" />
    <declaration type="int[][]" name="coeff" />
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="int" name="d" />
    <scope>
      <scope />
    </scope>
    <comment>Pascal triangle.</comment>
    <comment>First polynomial coefficient.</comment>
    <comment>Superior order.</comment>
  </method>
  <javadoc>
    <text>Get the coefficients array for a given degree.</text>
    <param>degree degree of the polynomial</param>
    <param>coefficients list where the computed coefficients are stored</param>
    <param>generator recurrence coefficients generator</param>
    <return>coefficients array</return>
  </javadoc>
  <method type="PolynomialFunction" name="buildPolynomial">
    <declaration type="int" name="maxDegree" />
    <scope>
      <scope />
    </scope>
    <declaration type="int" name="start" />
    <declaration type="double[]" name="a" />
    <scope />
    <comment>coefficient  for polynomial 0 is  l [0]</comment>
    <comment>coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)</comment>
    <comment>coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)</comment>
    <comment>coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)</comment>
    <comment>coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)</comment>
    <comment>coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)</comment>
    <comment>coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)</comment>
    <comment>...</comment>
    <comment>build the polynomial</comment>
  </method>
  <javadoc>
    <text>Compute polynomial coefficients up to a given degree.</text>
    <param>degree maximal degree</param>
    <param>maxDegree current maximal degree</param>
    <param>generator recurrence coefficients generator</param>
    <param>coefficients list where the computed coefficients should be appended</param>
  </javadoc>
  <method type="void" name="computeUpToDegree">
    <declaration type="int" name="startK" />
    <scope>
      <declaration type="int" name="startKm1" />
      <declaration type="BigFraction[]" name="ai" />
      <declaration type="BigFraction" name="ck" />
      <declaration type="BigFraction" name="ckm1" />
      <scope>
        <declaration type="BigFraction" name="ckPrev" />
      </scope>
      <declaration type="BigFraction" name="ckPrev" />
    </scope>
    <comment>start indices of two previous polynomials Pk(X) and Pk-1(X)</comment>
    <comment>Pk+1(X) = (a[0] + a[1] X) Pk(X) - a[2] Pk-1(X)</comment>
    <comment>degree 0 coefficient</comment>
    <comment>degree 1 to degree k-1 coefficients</comment>
    <comment>degree k coefficient</comment>
    <comment>degree k+1 coefficient</comment>
  </method>
  <javadoc>
    <text>Interface for recurrence coefficients generation.</text>
  </javadoc>
  <method name="generate" type="BigFraction[]" />
  <javadoc>
    <text>Generate recurrence coefficients.</text>
    <param>k highest degree of the polynomials used in the recurrence</param>
    <return>an array of three coefficients such that
 * P&lt;sub&gt;k+1&lt;/sub&gt;(X) = (a[0] + a[1] X) P&lt;sub&gt;k&lt;/sub&gt;(X) - a[2] P&lt;sub&gt;k-1&lt;/sub&gt;(X)</return>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>initialize recurrence for Chebyshev polynomials</comment>
  <comment>T0(X) = 1, T1(X) = 0 + 1 * X</comment>
  <comment>initialize recurrence for Hermite polynomials</comment>
  <comment>H0(X) = 1, H1(X) = 0 + 2 * X</comment>
  <comment>initialize recurrence for Laguerre polynomials</comment>
  <comment>L0(X) = 1, L1(X) = 1 - 1 * X</comment>
  <comment>initialize recurrence for Legendre polynomials</comment>
  <comment>P0(X) = 1, P1(X) = 0 + 1 * X</comment>
  <comment>initialize map for Jacobi polynomials</comment>
</class>
