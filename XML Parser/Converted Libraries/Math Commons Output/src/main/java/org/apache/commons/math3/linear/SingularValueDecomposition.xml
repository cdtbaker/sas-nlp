<?xml version="1.0" encoding="UTF-8"?>
<class name="SingularValueDecomposition">
  <javadoc>
    <text>Calculates the compact Singular Value Decomposition of a matrix.
 * &lt;p&gt;
 * The Singular Value Decomposition of matrix A is a set of three matrices: U,
 * &amp;Sigma; and V such that A = U &amp;times; &amp;Sigma; &amp;times; V&lt;sup&gt;T&lt;/sup&gt;. Let A be
 * a m &amp;times; n matrix, then U is a m &amp;times; p orthogonal matrix, &amp;Sigma; is a
 * p &amp;times; p diagonal matrix with positive or null elements, V is a p &amp;times;
 * n orthogonal matrix (hence V&lt;sup&gt;T&lt;/sup&gt; is also orthogonal) where
 * p=min(m,n).
 * &lt;/p&gt;
 * &lt;p&gt;This class is similar to the class with similar name from the
 * &lt;a href="http://math.nist.gov/javanumerics/jama/"&gt;JAMA&lt;/a&gt; library, with the
 * following changes:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;the {@code norm2} method which has been renamed as {@link #getNorm()getNorm},&lt;/li&gt;
 * &lt;li&gt;the {@code cond} method which has been renamed as {@link #getConditionNumber() getConditionNumber},&lt;/li&gt;
 * &lt;li&gt;the {@code rank} method which has been renamed as {@link #getRank()getRank},&lt;/li&gt;
 * &lt;li&gt;a {@link #getUT() getUT} method has been added,&lt;/li&gt;
 * &lt;li&gt;a {@link #getVT() getVT} method has been added,&lt;/li&gt;
 * &lt;li&gt;a {@link #getSolver() getSolver} method has been added,&lt;/li&gt;
 * &lt;li&gt;a {@link #getCovariance(double) getCovariance} method has been added.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <see>&lt;a href="http://mathworld.wolfram.com/SingularValueDecomposition.html"&gt;MathWorld&lt;/a&gt;</see>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Singular_value_decomposition"&gt;Wikipedia&lt;/a&gt;</see>
    <version>$Id: SingularValueDecomposition.java 1456931 2013-03-15 12:34:35Z luc $</version>
    <since>2.0 (changed to concrete class in 3.0)</since>
  </javadoc>
  <javadoc>
    <text>Relative threshold for small singular values.</text>
  </javadoc>
  <declaration type="double" name="EPS" />
  <javadoc>
    <text>Absolute threshold for small singular values.</text>
  </javadoc>
  <declaration type="double" name="TINY" />
  <javadoc>
    <text>Computed singular values.</text>
  </javadoc>
  <declaration type="double[]" name="singularValues" />
  <javadoc>
    <text>max(row dimension, column dimension).</text>
  </javadoc>
  <declaration type="int" name="m" />
  <javadoc>
    <text>min(row dimension, column dimension).</text>
  </javadoc>
  <declaration type="int" name="n" />
  <javadoc>
    <text>Indicator for transposed matrix.</text>
  </javadoc>
  <declaration type="boolean" name="transposed" />
  <javadoc>
    <text>Cached value of U matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedU" />
  <javadoc>
    <text>Cached value of transposed U matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedUt" />
  <javadoc>
    <text>Cached value of S (diagonal) matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedS" />
  <javadoc>
    <text>Cached value of V matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedV" />
  <javadoc>
    <text>Cached value of transposed V matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedVt" />
  <javadoc>
    <text>Tolerance value for small singular values, calculated once we have
 * populated "singularValues".</text>
  </javadoc>
  <declaration type="double" name="tol" />
  <javadoc>
    <text>Calculates the compact Singular Value Decomposition of the given matrix.</text>
    <param>matrix Matrix to decompose.</param>
  </javadoc>
  <method type="constructor" name="SingularValueDecomposition">
    <declaration type="double[][]" name="A" />
    <scope />
    <scope />
    <declaration type="double[][]" name="U" />
    <declaration type="double[][]" name="V" />
    <declaration type="double[]" name="e" />
    <declaration type="double[]" name="work" />
    <declaration type="int" name="nct" />
    <declaration type="int" name="nrt" />
    <scope>
      <scope>
        <scope />
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="t" />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
          <scope>
            <scope />
          </scope>
          <scope>
            <declaration type="double" name="t" />
            <scope />
          </scope>
        </scope>
        <scope />
      </scope>
    </scope>
    <declaration type="int" name="p" />
    <scope />
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope>
        <scope>
          <declaration type="double" name="t" />
          <scope />
          <scope />
        </scope>
        <scope />
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope>
          <declaration type="double" name="t" />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope />
    </scope>
    <declaration type="int" name="pp" />
    <declaration type="int" name="iter" />
    <scope>
      <declaration type="int" name="k" />
      <declaration type="int" name="kase" />
      <scope>
        <declaration type="double" name="threshold" />
        <scope />
      </scope>
      <scope />
      <scope>
        <declaration type="int" name="ks" />
        <scope>
          <scope />
          <declaration type="double" name="t" />
          <scope />
        </scope>
        <scope />
        <scope />
        <scope />
      </scope>
      <scope>
        <declaration type="double" name="f" />
        <scope>
          <declaration type="double" name="t" />
          <declaration type="double" name="cs" />
          <declaration type="double" name="sn" />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <declaration type="double" name="f" />
        <scope>
          <declaration type="double" name="t" />
          <declaration type="double" name="cs" />
          <declaration type="double" name="sn" />
          <scope />
        </scope>
      </scope>
      <scope>
        <declaration type="double" name="maxPm1Pm2" />
        <declaration type="double" name="scale" />
        <declaration type="double" name="sp" />
        <declaration type="double" name="spm1" />
        <declaration type="double" name="epm1" />
        <declaration type="double" name="sk" />
        <declaration type="double" name="ek" />
        <declaration type="double" name="b" />
        <declaration type="double" name="c" />
        <declaration type="double" name="shift" />
        <scope>
          <scope />
        </scope>
        <declaration type="double" name="f" />
        <declaration type="double" name="g" />
        <scope>
          <declaration type="double" name="t" />
          <declaration type="double" name="cs" />
          <declaration type="double" name="sn" />
          <scope />
          <scope />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
      <scope>
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
          <declaration type="double" name="t" />
          <scope>
            <scope />
          </scope>
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope />
    <scope />
    <comment>"m" is always the largest dimension.</comment>
    <comment>Reduce A to bidiagonal form, storing the diagonal elements</comment>
    <comment>in s and the super-diagonal elements in e.</comment>
    <comment>Compute the transformation for the k-th column and</comment>
    <comment>place the k-th diagonal in s[k].</comment>
    <comment>Compute 2-norm of k-th column without under/overflow.</comment>
    <comment>Apply the transformation.</comment>
    <comment>Place the k-th row of A into e for the</comment>
    <comment>subsequent calculation of the row transformation.</comment>
    <comment>Place the transformation in U for subsequent back</comment>
    <comment>multiplication.</comment>
    <comment>Compute the k-th row transformation and place the</comment>
    <comment>k-th super-diagonal in e[k].</comment>
    <comment>Compute 2-norm without under/overflow.</comment>
    <comment>Apply the transformation.</comment>
    <comment>Place the transformation in V for subsequent</comment>
    <comment>back multiplication.</comment>
    <comment>Set up the final bidiagonal matrix or order p.</comment>
    <comment>Generate U.</comment>
    <comment>Generate V.</comment>
    <comment>Main iteration loop for the singular values.</comment>
    <comment>Here is where a test for too many iterations would go.</comment>
    <comment>This section of the program inspects for</comment>
    <comment>negligible elements in the s and e arrays.  On</comment>
    <comment>completion the variables kase and k are set as follows.</comment>
    <comment>kase = 1     if s(p) and e[k-1] are negligible and k&lt;p</comment>
    <comment>kase = 2     if s(k) is negligible and k&lt;p</comment>
    <comment>kase = 3     if e[k-1] is negligible, k&lt;p, and</comment>
    <comment>s(k), ..., s(p) are not negligible (qr step).</comment>
    <comment>kase = 4     if e(p-1) is negligible (convergence).</comment>
    <comment>the following condition is written this way in order</comment>
    <comment>to break out of the loop when NaN occurs, writing it</comment>
    <comment>as "if (FastMath.abs(e[k]) &lt;= threshold)" would loop</comment>
    <comment>indefinitely in case of NaNs because comparison on NaNs</comment>
    <comment>always return false, regardless of what is checked</comment>
    <comment>see issue MATH-947</comment>
    <comment>Perform the task indicated by kase.</comment>
    <comment>Deflate negligible s(p).</comment>
    <comment>Split at negligible s(k).</comment>
    <comment>Perform one qr step.</comment>
    <comment>Calculate the shift.</comment>
    <comment>Chase zeros.</comment>
    <comment>Convergence.</comment>
    <comment>Make the singular values positive.</comment>
    <comment>Order the singular values.</comment>
    <comment>Set the small value tolerance used to calculate rank and pseudo-inverse</comment>
  </method>
  <javadoc>
    <text>Returns the matrix U of the decomposition.
 * &lt;p&gt;U is an orthogonal matrix, i.e. its transpose is also its inverse.&lt;/p&gt;</text>
    <return>the U matrix</return>
    <see>#getUT()</see>
  </javadoc>
  <method type="RealMatrix" name="getU">
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the transpose of the matrix U of the decomposition.
 * &lt;p&gt;U is an orthogonal matrix, i.e. its transpose is also its inverse.&lt;/p&gt;</text>
    <return>the U matrix (or null if decomposed matrix is singular)</return>
    <see>#getU()</see>
  </javadoc>
  <method type="RealMatrix" name="getUT">
    <scope />
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the diagonal matrix &amp;Sigma; of the decomposition.
 * &lt;p&gt;&amp;Sigma; is a diagonal matrix. The singular values are provided in
 * non-increasing order, for compatibility with Jama.&lt;/p&gt;</text>
    <return>the &amp;Sigma; matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getS">
    <scope />
    <comment>cache the matrix for subsequent calls</comment>
  </method>
  <javadoc>
    <text>Returns the diagonal elements of the matrix &amp;Sigma; of the decomposition.
 * &lt;p&gt;The singular values are provided in non-increasing order, for
 * compatibility with Jama.&lt;/p&gt;</text>
    <return>the diagonal elements of the &amp;Sigma; matrix</return>
  </javadoc>
  <method type="double[]" name="getSingularValues" />
  <javadoc>
    <text>Returns the matrix V of the decomposition.
 * &lt;p&gt;V is an orthogonal matrix, i.e. its transpose is also its inverse.&lt;/p&gt;</text>
    <return>the V matrix (or null if decomposed matrix is singular)</return>
    <see>#getVT()</see>
  </javadoc>
  <method type="RealMatrix" name="getV">
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the transpose of the matrix V of the decomposition.
 * &lt;p&gt;V is an orthogonal matrix, i.e. its transpose is also its inverse.&lt;/p&gt;</text>
    <return>the V matrix (or null if decomposed matrix is singular)</return>
    <see>#getV()</see>
  </javadoc>
  <method type="RealMatrix" name="getVT">
    <scope />
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the n &amp;times; n covariance matrix.
 * &lt;p&gt;The covariance matrix is V &amp;times; J &amp;times; V&lt;sup&gt;T&lt;/sup&gt;
 * where J is the diagonal matrix of the inverse of the squares of
 * the singular values.&lt;/p&gt;</text>
    <param>minSingularValue value below which singular values are ignored
 * (a 0 or negative value implies all singular value will be used)</param>
    <return>covariance matrix</return>
    <exception>IllegalArgumentException if minSingularValue is larger than
 * the largest singular value, meaning all singular values are ignored</exception>
  </javadoc>
  <method type="RealMatrix" name="getCovariance">
    <declaration type="int" name="p" />
    <declaration type="int" name="dimension" />
    <scope />
    <scope />
    <declaration type="double[][]" name="data" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="void" name="visit" />
    <declaration type="RealMatrix" name="jv" />
    <comment>get the number of singular values to consider</comment>
  </method>
  <javadoc>
    <text>Returns the L&lt;sub&gt;2&lt;/sub&gt; norm of the matrix.
 * &lt;p&gt;The L&lt;sub&gt;2&lt;/sub&gt; norm is max(|A &amp;times; u|&lt;sub&gt;2&lt;/sub&gt; /
 * |u|&lt;sub&gt;2&lt;/sub&gt;), where |.|&lt;sub&gt;2&lt;/sub&gt; denotes the vectorial 2-norm
 * (i.e. the traditional euclidian norm).&lt;/p&gt;</text>
    <return>norm</return>
  </javadoc>
  <method type="double" name="getNorm" />
  <javadoc>
    <text>Return the condition number of the matrix.</text>
    <return>condition number of the matrix</return>
  </javadoc>
  <method type="double" name="getConditionNumber" />
  <javadoc>
    <text>Computes the inverse of the condition number.
 * In cases of rank deficiency, the {@link #getConditionNumber() condition
 * number} will become undefined.</text>
    <return>the inverse of the condition number.</return>
  </javadoc>
  <method type="double" name="getInverseConditionNumber" />
  <javadoc>
    <text>Return the effective numerical matrix rank.
 * &lt;p&gt;The effective numerical rank is the number of non-negligible
 * singular values. The threshold used to identify non-negligible
 * terms is max(m,n) &amp;times; ulp(s&lt;sub&gt;1&lt;/sub&gt;) where ulp(s&lt;sub&gt;1&lt;/sub&gt;)
 * is the least significant bit of the largest singular value.&lt;/p&gt;</text>
    <return>effective numerical matrix rank</return>
  </javadoc>
  <method type="int" name="getRank">
    <declaration type="int" name="r" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get a solver for finding the A &amp;times; X = B solution in least square sense.</text>
    <return>a solver</return>
  </javadoc>
  <method type="DecompositionSolver" name="getSolver" />
  <javadoc>
    <text>Specialized solver.</text>
  </javadoc>
  <javadoc>
    <text>Pseudo-inverse of the initial matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="pseudoInverse" />
  <javadoc>
    <text>Singularity indicator.</text>
  </javadoc>
  <declaration type="boolean" name="nonSingular" />
  <javadoc>
    <text>Build a solver from decomposed matrix.</text>
    <param>singularValues Singular values.</param>
    <param>uT U&lt;sup&gt;T&lt;/sup&gt; matrix of the decomposition.</param>
    <param>v V matrix of the decomposition.</param>
    <param>nonSingular Singularity indicator.</param>
    <param>tol tolerance for singular values</param>
  </javadoc>
  <method type="constructor" name="Solver">
    <declaration type="double[][]" name="suT" />
    <scope>
      <declaration type="double" name="a" />
      <scope />
      <scope />
      <declaration type="double[]" name="suTi" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Solve the linear equation A &amp;times; X = B in least square sense.
 * &lt;p&gt;
 * The m&amp;times;n matrix A may not be square, the solution X is such that
 * ||A &amp;times; X - B|| is minimal.
 * &lt;/p&gt;</text>
    <param>b Right-hand side of the equation A &amp;times; X = B</param>
    <return>a vector X that minimizes the two norm of A &amp;times; X - B</return>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the matrices dimensions do not match.</throws>
  </javadoc>
  <method type="RealVector" name="solve" />
  <javadoc>
    <text>Solve the linear equation A &amp;times; X = B in least square sense.
 * &lt;p&gt;
 * The m&amp;times;n matrix A may not be square, the solution X is such that
 * ||A &amp;times; X - B|| is minimal.
 * &lt;/p&gt;</text>
    <param>b Right-hand side of the equation A &amp;times; X = B</param>
    <return>a matrix X that minimizes the two norm of A &amp;times; X - B</return>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the matrices dimensions do not match.</throws>
  </javadoc>
  <method type="RealMatrix" name="solve" />
  <javadoc>
    <text>Check if the decomposed matrix is non-singular.</text>
    <return>{@code true} if the decomposed matrix is non-singular.</return>
  </javadoc>
  <method type="boolean" name="isNonSingular" />
  <javadoc>
    <text>Get the pseudo-inverse of the decomposed matrix.</text>
    <return>the inverse matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="getInverse" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
