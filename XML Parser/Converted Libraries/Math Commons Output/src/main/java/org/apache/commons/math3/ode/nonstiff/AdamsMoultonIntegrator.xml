<?xml version="1.0" encoding="UTF-8"?>
<class name="AdamsMoultonIntegrator">
  <javadoc>
    <text>This class implements implicit Adams-Moulton integrators for Ordinary
 * Differential Equations.
 * &lt;p&gt;Adams-Moulton methods (in fact due to Adams alone) are implicit
 * multistep ODE solvers. This implementation is a variation of the classical
 * one: it uses adaptive stepsize to implement error control, whereas
 * classical implementations are fixed step size. The value of state vector
 * at step n+1 is a simple combination of the value at step n and of the
 * derivatives at steps n+1, n, n-1 ... Since y'&lt;sub&gt;n+1&lt;/sub&gt; is needed to
 * compute y&lt;sub&gt;n+1&lt;/sub&gt;, another method must be used to compute a first
 * estimate of y&lt;sub&gt;n+1&lt;/sub&gt;, then compute y'&lt;sub&gt;n+1&lt;/sub&gt;, then compute
 * a final estimate of y&lt;sub&gt;n+1&lt;/sub&gt; using the following formulas. Depending
 * on the number k of previous steps one wants to use for computing the next
 * value, different formulas are available for the final estimate:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;k = 1: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h y'&lt;sub&gt;n+1&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;k = 2: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (y'&lt;sub&gt;n+1&lt;/sub&gt;+y'&lt;sub&gt;n&lt;/sub&gt;)/2&lt;/li&gt;
 * &lt;li&gt;k = 3: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (5y'&lt;sub&gt;n+1&lt;/sub&gt;+8y'&lt;sub&gt;n&lt;/sub&gt;-y'&lt;sub&gt;n-1&lt;/sub&gt;)/12&lt;/li&gt;
 * &lt;li&gt;k = 4: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (9y'&lt;sub&gt;n+1&lt;/sub&gt;+19y'&lt;sub&gt;n&lt;/sub&gt;-5y'&lt;sub&gt;n-1&lt;/sub&gt;+y'&lt;sub&gt;n-2&lt;/sub&gt;)/24&lt;/li&gt;
 * &lt;li&gt;...&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;A k-steps Adams-Moulton method is of order k+1.&lt;/p&gt;
 * &lt;h3&gt;Implementation details&lt;/h3&gt;
 * &lt;p&gt;We define scaled derivatives s&lt;sub&gt;i&lt;/sub&gt;(n) at step n as:
 * &lt;pre&gt;
 * s&lt;sub&gt;1&lt;/sub&gt;(n) = h y'&lt;sub&gt;n&lt;/sub&gt; for first derivative
 * s&lt;sub&gt;2&lt;/sub&gt;(n) = h&lt;sup&gt;2&lt;/sup&gt;/2 y''&lt;sub&gt;n&lt;/sub&gt; for second derivative
 * s&lt;sub&gt;3&lt;/sub&gt;(n) = h&lt;sup&gt;3&lt;/sup&gt;/6 y'''&lt;sub&gt;n&lt;/sub&gt; for third derivative
 * ...
 * s&lt;sub&gt;k&lt;/sub&gt;(n) = h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;&lt;sub&gt;n&lt;/sub&gt; for k&lt;sup&gt;th&lt;/sup&gt; derivative
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;The definitions above use the classical representation with several previous first
 * derivatives. Lets define
 * &lt;pre&gt;
 * q&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;1&lt;/sub&gt;(n-1) s&lt;sub&gt;1&lt;/sub&gt;(n-2) ... s&lt;sub&gt;1&lt;/sub&gt;(n-(k-1)) ]&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/pre&gt;
 * (we omit the k index in the notation for clarity). With these definitions,
 * Adams-Moulton methods can be written:
 * &lt;ul&gt;
 * &lt;li&gt;k = 1: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n+1)&lt;/li&gt;
 * &lt;li&gt;k = 2: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 1/2 s&lt;sub&gt;1&lt;/sub&gt;(n+1) + [ 1/2 ] q&lt;sub&gt;n+1&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;k = 3: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 5/12 s&lt;sub&gt;1&lt;/sub&gt;(n+1) + [ 8/12 -1/12 ] q&lt;sub&gt;n+1&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;k = 4: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 9/24 s&lt;sub&gt;1&lt;/sub&gt;(n+1) + [ 19/24 -5/24 1/24 ] q&lt;sub&gt;n+1&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;...&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;Instead of using the classical representation with first derivatives only (y&lt;sub&gt;n&lt;/sub&gt;,
 * s&lt;sub&gt;1&lt;/sub&gt;(n+1) and q&lt;sub&gt;n+1&lt;/sub&gt;), our implementation uses the Nordsieck vector with
 * higher degrees scaled derivatives all taken at the same step (y&lt;sub&gt;n&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;(n)
 * and r&lt;sub&gt;n&lt;/sub&gt;) where r&lt;sub&gt;n&lt;/sub&gt; is defined as:
 * &lt;pre&gt;
 * r&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;2&lt;/sub&gt;(n), s&lt;sub&gt;3&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n) ]&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/pre&gt;
 * (here again we omit the k index in the notation for clarity)
 * &lt;/p&gt;
 * &lt;p&gt;Taylor series formulas show that for any index offset i, s&lt;sub&gt;1&lt;/sub&gt;(n-i) can be
 * computed from s&lt;sub&gt;1&lt;/sub&gt;(n), s&lt;sub&gt;2&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n), the formula being exact
 * for degree k polynomials.
 * &lt;pre&gt;
 * s&lt;sub&gt;1&lt;/sub&gt;(n-i) = s&lt;sub&gt;1&lt;/sub&gt;(n) + &amp;sum;&lt;sub&gt;j&lt;/sub&gt; j (-i)&lt;sup&gt;j-1&lt;/sup&gt; s&lt;sub&gt;j&lt;/sub&gt;(n)
 * &lt;/pre&gt;
 * The previous formula can be used with several values for i to compute the transform between
 * classical representation and Nordsieck vector. The transform between r&lt;sub&gt;n&lt;/sub&gt;
 * and q&lt;sub&gt;n&lt;/sub&gt; resulting from the Taylor series formulas above is:
 * &lt;pre&gt;
 * q&lt;sub&gt;n&lt;/sub&gt; = s&lt;sub&gt;1&lt;/sub&gt;(n) u + P r&lt;sub&gt;n&lt;/sub&gt;
 * &lt;/pre&gt;
 * where u is the [ 1 1 ... 1 ]&lt;sup&gt;T&lt;/sup&gt; vector and P is the (k-1)&amp;times;(k-1) matrix built
 * with the j (-i)&lt;sup&gt;j-1&lt;/sup&gt; terms:
 * &lt;pre&gt;
 * [  -2   3   -4    5  ... ]
 * [  -4  12  -32   80  ... ]
 * P =  [  -6  27 -108  405  ... ]
 * [  -8  48 -256 1280  ... ]
 * [          ...           ]
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;Using the Nordsieck vector has several advantages:
 * &lt;ul&gt;
 * &lt;li&gt;it greatly simplifies step interpolation as the interpolator mainly applies
 * Taylor series formulas,&lt;/li&gt;
 * &lt;li&gt;it simplifies step changes that occur when discrete events that truncate
 * the step are triggered,&lt;/li&gt;
 * &lt;li&gt;it allows to extend the methods in order to support adaptive stepsize.&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step
 * n as follows:
 * &lt;ul&gt;
 * &lt;li&gt;Y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n) + u&lt;sup&gt;T&lt;/sup&gt; r&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;S&lt;sub&gt;1&lt;/sub&gt;(n+1) = h f(t&lt;sub&gt;n+1&lt;/sub&gt;, Y&lt;sub&gt;n+1&lt;/sub&gt;)&lt;/li&gt;
 * &lt;li&gt;R&lt;sub&gt;n+1&lt;/sub&gt; = (s&lt;sub&gt;1&lt;/sub&gt;(n) - S&lt;sub&gt;1&lt;/sub&gt;(n+1)) P&lt;sup&gt;-1&lt;/sup&gt; u + P&lt;sup&gt;-1&lt;/sup&gt; A P r&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * where A is a rows shifting matrix (the lower left part is an identity matrix):
 * &lt;pre&gt;
 * [ 0 0   ...  0 0 | 0 ]
 * [ ---------------+---]
 * [ 1 0   ...  0 0 | 0 ]
 * A = [ 0 1   ...  0 0 | 0 ]
 * [       ...      | 0 ]
 * [ 0 0   ...  1 0 | 0 ]
 * [ 0 0   ...  0 1 | 0 ]
 * &lt;/pre&gt;
 * From this predicted vector, the corrected vector is computed as follows:
 * &lt;ul&gt;
 * &lt;li&gt;y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + S&lt;sub&gt;1&lt;/sub&gt;(n+1) + [ -1 +1 -1 +1 ... &amp;plusmn;1 ] r&lt;sub&gt;n+1&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;s&lt;sub&gt;1&lt;/sub&gt;(n+1) = h f(t&lt;sub&gt;n+1&lt;/sub&gt;, y&lt;sub&gt;n+1&lt;/sub&gt;)&lt;/li&gt;
 * &lt;li&gt;r&lt;sub&gt;n+1&lt;/sub&gt; = R&lt;sub&gt;n+1&lt;/sub&gt; + (s&lt;sub&gt;1&lt;/sub&gt;(n+1) - S&lt;sub&gt;1&lt;/sub&gt;(n+1)) P&lt;sup&gt;-1&lt;/sup&gt; u&lt;/li&gt;
 * &lt;/ul&gt;
 * where the upper case Y&lt;sub&gt;n+1&lt;/sub&gt;, S&lt;sub&gt;1&lt;/sub&gt;(n+1) and R&lt;sub&gt;n+1&lt;/sub&gt; represent the
 * predicted states whereas the lower case y&lt;sub&gt;n+1&lt;/sub&gt;, s&lt;sub&gt;n+1&lt;/sub&gt; and r&lt;sub&gt;n+1&lt;/sub&gt;
 * represent the corrected states.&lt;/p&gt;
 * &lt;p&gt;The P&lt;sup&gt;-1&lt;/sup&gt;u vector and the P&lt;sup&gt;-1&lt;/sup&gt; A P matrix do not depend on the state,
 * they only depend on k and therefore are precomputed once for all.&lt;/p&gt;</text>
    <version>$Id: AdamsMoultonIntegrator.java 1463684 2013-04-02 19:04:13Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Integrator method name.</text>
  </javadoc>
  <declaration type="String" name="METHOD_NAME" />
  <javadoc>
    <text>Build an Adams-Moulton integrator with the given order and error control parameters.</text>
    <param>nSteps number of steps of the method excluding the one being computed</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>scalAbsoluteTolerance allowed absolute error</param>
    <param>scalRelativeTolerance allowed relative error</param>
    <exception>NumberIsTooSmallException if order is 1 or less</exception>
  </javadoc>
  <method type="constructor" name="AdamsMoultonIntegrator" />
  <javadoc>
    <text>Build an Adams-Moulton integrator with the given order and error control parameters.</text>
    <param>nSteps number of steps of the method excluding the one being computed</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>vecAbsoluteTolerance allowed absolute error</param>
    <param>vecRelativeTolerance allowed relative error</param>
    <exception>IllegalArgumentException if order is 1 or less</exception>
  </javadoc>
  <method type="constructor" name="AdamsMoultonIntegrator" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="integrate">
    <declaration type="boolean" name="forward" />
    <declaration type="double[]" name="y0" />
    <declaration type="double[]" name="y" />
    <declaration type="double[]" name="yDot" />
    <declaration type="double[]" name="yTmp" />
    <declaration type="double[]" name="predictedScaled" />
    <declaration type="Array2DRowRealMatrix" name="nordsieckTmp" />
    <declaration type="NordsieckStepInterpolator" name="interpolator" />
    <declaration type="double" name="hNew" />
    <scope>
      <declaration type="double" name="error" />
      <scope>
        <declaration type="double" name="stepEnd" />
        <declaration type="ExpandableStatefulODE" name="expandable" />
        <declaration type="EquationsMapper" name="primary" />
        <declaration type="int" name="index" />
        <scope />
        <scope />
        <scope>
          <declaration type="double" name="factor" />
        </scope>
      </scope>
      <declaration type="double" name="stepEnd" />
      <declaration type="double[]" name="correctedScaled" />
      <scope />
      <scope>
        <scope />
        <declaration type="double" name="factor" />
        <declaration type="double" name="scaledH" />
        <declaration type="double" name="nextT" />
        <declaration type="boolean" name="nextIsLast" />
        <declaration type="double" name="filteredNextT" />
        <declaration type="boolean" name="filteredNextIsLast" />
        <scope />
      </scope>
    </scope>
    <comment>initialize working arrays</comment>
    <comment>set up two interpolators sharing the integrator arrays</comment>
    <comment>set up integration control objects</comment>
    <comment>compute the initial Nordsieck vector using the configured starter integrator</comment>
    <comment>predict a first estimate of the state at step end (P in the PECE sequence)</comment>
    <comment>evaluate a first estimate of the derivative (first E in the PECE sequence)</comment>
    <comment>update Nordsieck vector</comment>
    <comment>apply correction (C in the PECE sequence)</comment>
    <comment>reject the step and attempt to reduce error by stepsize control</comment>
    <comment>evaluate a final estimate of the derivative (second E in the PECE sequence)</comment>
    <comment>update Nordsieck vector</comment>
    <comment>discrete events handling</comment>
    <comment>prepare next step</comment>
    <comment>some events handler has triggered changes that</comment>
    <comment>invalidate the derivatives, we need to restart from scratch</comment>
    <comment>stepsize control for next step</comment>
    <comment>dispatch results</comment>
  </method>
  <javadoc>
    <text>Corrector for current state in Adams-Moulton method.
 * &lt;p&gt;
 * This visitor implements the Taylor series formula:
 * &lt;pre&gt;
 * Y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n+1) + [ -1 +1 -1 +1 ... &amp;plusmn;1 ] r&lt;sub&gt;n+1&lt;/sub&gt;
 * &lt;/pre&gt;
 * &lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>Previous state.</text>
  </javadoc>
  <declaration type="double[]" name="previous" />
  <javadoc>
    <text>Current scaled first derivative.</text>
  </javadoc>
  <declaration type="double[]" name="scaled" />
  <javadoc>
    <text>Current state before correction.</text>
  </javadoc>
  <declaration type="double[]" name="before" />
  <javadoc>
    <text>Current state after correction.</text>
  </javadoc>
  <declaration type="double[]" name="after" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>previous previous state</param>
    <param>scaled current scaled first derivative</param>
    <param>state state to correct (will be overwritten after visit)</param>
  </javadoc>
  <method type="constructor" name="Corrector" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="start" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visit">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>End visiting the Nordsieck vector.
 * &lt;p&gt;The correction is used to control stepsize. So its amplitude is
 * considered to be an error, which must be normalized according to
 * error control settings. If the normalized value is greater than 1,
 * the correction was too large and the step must be rejected.&lt;/p&gt;</text>
    <return>the normalized correction, if greater than 1, the step
 * must be rejected</return>
  </javadoc>
  <method type="double" name="end">
    <declaration type="double" name="error" />
    <scope>
      <scope>
        <declaration type="double" name="yScale" />
        <declaration type="double" name="tol" />
        <declaration type="double" name="ratio" />
      </scope>
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
