<?xml version="1.0" encoding="UTF-8"?>
<class name="BaseMultiStartMultivariateOptimizer">
  <javadoc>
    <text>Base class multi-start optimizer for a multivariate function.
 * &lt;br/&gt;
 * This class wraps an optimizer in order to use it several times in
 * turn with different starting points (trying to avoid being trapped
 * in a local extremum when looking for a global one).
 * &lt;em&gt;It is not a "user" class.&lt;/em&gt;</text>
    <param>&lt;PAIR&gt;
 *  Type of the point/value pair returned by the optimization
 * algorithm.</param>
    <version>$Id: BaseMultiStartMultivariateOptimizer.java 1454746 2013-03-09 17:37:30Z luc $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Underlying classical optimizer.</text>
  </javadoc>
  <declaration type="BaseMultivariateOptimizer&lt;PAIR&gt;" name="optimizer" />
  <javadoc>
    <text>Number of evaluations already performed for all starts.</text>
  </javadoc>
  <declaration type="int" name="totalEvaluations" />
  <javadoc>
    <text>Number of starts to go.</text>
  </javadoc>
  <declaration type="int" name="starts" />
  <javadoc>
    <text>Random generator for multi-start.</text>
  </javadoc>
  <declaration type="RandomVectorGenerator" name="generator" />
  <javadoc>
    <text>Optimization data.</text>
  </javadoc>
  <declaration type="OptimizationData[]" name="optimData" />
  <javadoc>
    <text>Location in {@link #optimData} where the updated maximum
 * number of evaluations will be stored.</text>
  </javadoc>
  <declaration type="int" name="maxEvalIndex" />
  <javadoc>
    <text>Location in {@link #optimData} where the updated start value
 * will be stored.</text>
  </javadoc>
  <declaration type="int" name="initialGuessIndex" />
  <javadoc>
    <text>Create a multi-start optimizer from a single-start optimizer.
 * &lt;p&gt;
 * Note that if there are bounds constraints (see {@link #getLowerBound()}and {@link #getUpperBound()}), then a simple rejection algorithm is used
 * at each restart. This implies that the random vector generator should have
 * a good probability to generate vectors in the bounded domain, otherwise the
 * rejection algorithm will hit the {@link #getMaxEvaluations()} count without
 * generating a proper restart point. Users must be take great care of the &lt;a
 * href="http://en.wikipedia.org/wiki/Curse_of_dimensionality"&gt;curse of dimensionality&lt;/a&gt;.
 * &lt;/p&gt;</text>
    <param>optimizer Single-start optimizer to wrap.</param>
    <param>starts Number of starts to perform. If {@code starts == 1},
 * the {@link #optimize(OptimizationData[]) optimize} will return the
 * same solution as the given {@code optimizer} would return.</param>
    <param>generator Random vector generator to use for restarts.</param>
    <throws>NotStrictlyPositiveException if {@code starts &lt; 1}.</throws>
  </javadoc>
  <method type="constructor" name="BaseMultiStartMultivariateOptimizer">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="getEvaluations" />
  <method name="getOptima" type="PAIR[]" />
  <javadoc>
    <text>Gets all the optima found during the last call to {@code optimize}.
 * The optimizer stores all the optima found during a set of
 * restarts. The {@code optimize} method returns the best point only.
 * This method returns all the points found at the end of each starts,
 * including the best one already returned by the {@code optimize} method.
 * &lt;br/&gt;
 * The returned array as one element for each start as specified
 * in the constructor. It is ordered with the results from the
 * runs that did converge first, sorted from best to worst
 * objective value (i.e in ascending order if minimizing and in
 * descending order if maximizing), followed by {@code null} elements
 * corresponding to the runs that did not converge. This means all
 * elements will be {@code null} if the {@code optimize} method did throw
 * an exception.
 * This also means that if the first element is not {@code null}, it is
 * the best point found across all starts.
 * &lt;br/&gt;
 * The behaviour is undefined if this method is called before{@code optimize}; it will likely throw {@code NullPointerException}.</text>
    <return>an array containing the optima sorted from best to worst.</return>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>MathIllegalStateException if {@code optData} does not contain an
 * instance of {@link MaxEval} or {@link InitialGuess}.</throws>
  </javadoc>
  <method type="PAIR" name="optimize">
    <comment>Store arguments in order to pass them to the internal optimizer.</comment>
    <comment>Set up base class and perform computations.</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PAIR" name="doOptimize">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <declaration type="RuntimeException" name="lastException" />
    <declaration type="int" name="maxEval" />
    <declaration type="double[]" name="min" />
    <declaration type="double[]" name="max" />
    <declaration type="double[]" name="startPoint" />
    <scope>
      <scope>
        <declaration type="double[]" name="s" />
        <scope />
        <scope>
          <declaration type="int" name="attempts" />
          <scope>
            <scope />
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
        <declaration type="PAIR" name="result" />
      </scope>
      <scope />
    </scope>
    <declaration type="PAIR[]" name="optima" />
    <scope />
    <comment>Remove all instances of "MaxEval" and "InitialGuess" from the</comment>
    <comment>array that will be passed to the internal optimizer.</comment>
    <comment>The former is to enforce smaller numbers of allowed evaluations</comment>
    <comment>(according to how many have been used up already), and the latter</comment>
    <comment>to impose a different start value for each start.</comment>
    <comment>Multi-start loop.</comment>
    <comment>CHECKSTYLE: stop IllegalCatch</comment>
    <comment>Decrease number of allowed evaluations.</comment>
    <comment>New start value.</comment>
    <comment>reject the vector</comment>
    <comment>Optimize.</comment>
    <comment>CHECKSTYLE: resume IllegalCatch</comment>
    <comment>All runs failed.</comment>
    <comment>Cannot be null if starts &gt;= 1.</comment>
    <comment>Return the best optimum.</comment>
  </method>
  <method name="store" type="void" />
  <javadoc>
    <text>Method that will be called in order to store each found optimum.</text>
    <param>optimum Result of an optimization run.</param>
  </javadoc>
  <method name="clear" type="void" />
  <javadoc>
    <text>Method that will called in order to clear all stored optima.</text>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
