<?xml version="1.0" encoding="UTF-8"?>
<class name="OrderedTuple">
  <javadoc>
    <text>This class implements an ordering operation for T-uples.
 * &lt;p&gt;Ordering is done by encoding all components of the T-uple into a
 * single scalar value and using this value as the sorting
 * key. Encoding is performed using the method invented by Georg
 * Cantor in 1877 when he proved it was possible to establish a
 * bijection between a line and a plane. The binary representations of
 * the components of the T-uple are mixed together to form a single
 * scalar. This means that the 2&lt;sup&gt;k&lt;/sup&gt; bit of component 0 is
 * followed by the 2&lt;sup&gt;k&lt;/sup&gt; bit of component 1, then by the
 * 2&lt;sup&gt;k&lt;/sup&gt; bit of component 2 up to the 2&lt;sup&gt;k&lt;/sup&gt; bit of
 * component {@code t}, which is followed by the 2&lt;sup&gt;k-1&lt;/sup&gt;
 * bit of component 0, followed by the 2&lt;sup&gt;k-1&lt;/sup&gt; bit of
 * component 1 ... The binary representations are extended as needed
 * to handle numbers with different scales and a suitable
 * 2&lt;sup&gt;p&lt;/sup&gt; offset is added to the components in order to avoid
 * negative numbers (this offset is adjusted as needed during the
 * comparison operations).&lt;/p&gt;
 * &lt;p&gt;The more interesting property of the encoding method for our
 * purpose is that it allows to select all the points that are in a
 * given range. This is depicted in dimension 2 by the following
 * picture:&lt;/p&gt;
 * &lt;img src="doc-files/OrderedTuple.png" /&gt;
 * &lt;p&gt;This picture shows a set of 100000 random 2-D pairs having their
 * first component between -50 and +150 and their second component
 * between -350 and +50. We wanted to extract all pairs having their
 * first component between +30 and +70 and their second component
 * between -120 and -30. We built the lower left point at coordinates
 * (30, -120) and the upper right point at coordinates (70, -30). All
 * points smaller than the lower left point are drawn in red and all
 * points larger than the upper right point are drawn in blue. The
 * green points are between the two limits. This picture shows that
 * all the desired points are selected, along with spurious points. In
 * this case, we get 15790 points, 4420 of which really belonging to
 * the desired rectangle. It is possible to extract very small
 * subsets. As an example extracting from the same 100000 points set
 * the points having their first component between +30 and +31 and
 * their second component between -91 and -90, we get a subset of 11
 * points, 2 of which really belonging to the desired rectangle.&lt;/p&gt;
 * &lt;p&gt;the previous selection technique can be applied in all
 * dimensions, still using two points to define the interval. The
 * first point will have all its components set to their lower bounds
 * while the second point will have all its components set to their
 * upper bounds.&lt;/p&gt;
 * &lt;p&gt;T-uples with negative infinite or positive infinite components
 * are sorted logically.&lt;/p&gt;
 * &lt;p&gt;Since the specification of the {@code Comparator} interface
 * allows only {@code ClassCastException} errors, some arbitrary
 * choices have been made to handle specific cases. The rationale for
 * these choices is to keep &lt;em&gt;regular&lt;/em&gt; and consistent T-uples
 * together.&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;instances with different dimensions are sorted according to
 * their dimension regardless of their components values&lt;/li&gt;
 * &lt;li&gt;instances with {@code Double.NaN} components are sorted
 * after all other ones (even after instances with positive infinite
 * components&lt;/li&gt;
 * &lt;li&gt;instances with both positive and negative infinite components
 * are considered as if they had {@code Double.NaN}components&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <version>$Id: OrderedTuple.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Sign bit mask.</text>
  </javadoc>
  <declaration type="long" name="SIGN_MASK" />
  <javadoc>
    <text>Exponent bits mask.</text>
  </javadoc>
  <declaration type="long" name="EXPONENT_MASK" />
  <javadoc>
    <text>Mantissa bits mask.</text>
  </javadoc>
  <declaration type="long" name="MANTISSA_MASK" />
  <javadoc>
    <text>Implicit MSB for normalized numbers.</text>
  </javadoc>
  <declaration type="long" name="IMPLICIT_ONE" />
  <javadoc>
    <text>Double components of the T-uple.</text>
  </javadoc>
  <declaration type="double[]" name="components" />
  <javadoc>
    <text>Offset scale.</text>
  </javadoc>
  <declaration type="int" name="offset" />
  <javadoc>
    <text>Least Significant Bit scale.</text>
  </javadoc>
  <declaration type="int" name="lsb" />
  <javadoc>
    <text>Ordering encoding of the double components.</text>
  </javadoc>
  <declaration type="long[]" name="encoding" />
  <javadoc>
    <text>Positive infinity marker.</text>
  </javadoc>
  <declaration type="boolean" name="posInf" />
  <javadoc>
    <text>Negative infinity marker.</text>
  </javadoc>
  <declaration type="boolean" name="negInf" />
  <javadoc>
    <text>Not A Number marker.</text>
  </javadoc>
  <declaration type="boolean" name="nan" />
  <javadoc>
    <text>Build an ordered T-uple from its components.</text>
    <param>components double components of the T-uple</param>
  </javadoc>
  <method type="constructor" name="OrderedTuple">
    <declaration type="int" name="msb" />
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
      <scope>
        <declaration type="long" name="b" />
        <declaration type="long" name="m" />
        <scope>
          <declaration type="int" name="e" />
        </scope>
      </scope>
    </scope>
    <scope />
    <scope />
    <scope />
    <comment>instance cannot be sorted logically</comment>
    <comment>encode the T-upple with the specified offset</comment>
  </method>
  <javadoc>
    <text>Encode the T-uple with a given offset.</text>
    <param>minOffset minimal scale of the offset to add to all
 * components (must be greater than the MSBs of all components)</param>
  </javadoc>
  <method type="void" name="encode">
    <scope />
    <declaration type="int" name="neededBits" />
    <declaration type="int" name="neededLongs" />
    <declaration type="int" name="eIndex" />
    <declaration type="int" name="shift" />
    <declaration type="long" name="word" />
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>choose an offset with some margins</comment>
    <comment>the components are all zeroes</comment>
    <comment>allocate an integer array to encode the components (we use only</comment>
    <comment>63 bits per element because there is no unsigned long in Java)</comment>
    <comment>mix the bits from all components</comment>
  </method>
  <javadoc>
    <text>Compares this ordered T-uple with the specified object.
 * &lt;p&gt;The ordering method is detailed in the general description of
 * the class. Its main property is to be consistent with distance:
 * geometrically close T-uples stay close to each other when stored
 * in a sorted collection using this comparison method.&lt;/p&gt;
 * &lt;p&gt;T-uples with negative infinite, positive infinite are sorted
 * logically.&lt;/p&gt;
 * &lt;p&gt;Some arbitrary choices have been made to handle specific
 * cases. The rationale for these choices is to keep
 * &lt;em&gt;normal&lt;/em&gt; and consistent T-uples together.&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;instances with different dimensions are sorted according to
 * their dimension regardless of their components values&lt;/li&gt;
 * &lt;li&gt;instances with {@code Double.NaN} components are sorted
 * after all other ones (evan after instances with positive infinite
 * components&lt;/li&gt;
 * &lt;li&gt;instances with both positive and negative infinite components
 * are considered as if they had {@code Double.NaN}components&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>ot T-uple to compare instance with</param>
    <return>a negative integer if the instance is less than the
 * object, zero if they are equal, or a positive integer if the
 * instance is greater than the object</return>
  </javadoc>
  <method type="int" name="compareTo">
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
      <scope>
        <scope />
        <scope />
        <declaration type="int" name="limit" />
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="hashCode">
    <declaration type="int" name="multiplier" />
    <declaration type="int" name="trueHash" />
    <declaration type="int" name="falseHash" />
    <declaration type="int" name="hash" />
    <comment>the following constants are arbitrary small primes</comment>
    <comment>hash fields and combine them</comment>
    <comment>(we rely on the multiplier to have different combined weights</comment>
    <comment>for all int fields and all boolean fields)</comment>
  </method>
  <javadoc>
    <text>Get the components array.</text>
    <return>array containing the T-uple components</return>
  </javadoc>
  <method type="double[]" name="getComponents" />
  <javadoc>
    <text>Extract the sign from the bits of a double.</text>
    <param>bits binary representation of the double</param>
    <return>sign bit (zero if positive, non zero if negative)</return>
  </javadoc>
  <method type="long" name="sign" />
  <javadoc>
    <text>Extract the exponent from the bits of a double.</text>
    <param>bits binary representation of the double</param>
    <return>exponent</return>
  </javadoc>
  <method type="int" name="exponent" />
  <javadoc>
    <text>Extract the mantissa from the bits of a double.</text>
    <param>bits binary representation of the double</param>
    <return>mantissa</return>
  </javadoc>
  <method type="long" name="mantissa">
    <comment>subnormal number</comment>
    <comment>normal number</comment>
  </method>
  <javadoc>
    <text>Compute the most significant bit of a long.</text>
    <param>l long from which the most significant bit is requested</param>
    <return>scale of the most significant bit of {@code l},
 * or 0 if {@code l} is zero</return>
    <see>#computeLSB</see>
  </javadoc>
  <method type="int" name="computeMSB">
    <declaration type="long" name="ll" />
    <declaration type="long" name="mask" />
    <declaration type="int" name="scale" />
    <declaration type="int" name="msb" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compute the least significant bit of a long.</text>
    <param>l long from which the least significant bit is requested</param>
    <return>scale of the least significant bit of {@code l},
 * or 63 if {@code l} is zero</return>
    <see>#computeMSB</see>
  </javadoc>
  <method type="int" name="computeLSB">
    <declaration type="long" name="ll" />
    <declaration type="long" name="mask" />
    <declaration type="int" name="scale" />
    <declaration type="int" name="lsb" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get a bit from the mantissa of a double.</text>
    <param>i index of the component</param>
    <param>k scale of the requested bit</param>
    <return>the specified bit (either 0 or 1), after the offset has
 * been added to the double</return>
  </javadoc>
  <method type="int" name="getBit">
    <declaration type="long" name="bits" />
    <declaration type="int" name="e" />
    <scope />
    <scope />
    <scope />
    <scope>
      <declaration type="long" name="m" />
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
