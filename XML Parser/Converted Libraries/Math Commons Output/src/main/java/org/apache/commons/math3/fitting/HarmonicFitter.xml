<?xml version="1.0" encoding="UTF-8"?>
<class name="HarmonicFitter">
  <javadoc>
    <text>Class that implements a curve fitting specialized for sinusoids.
 * Harmonic fitting is a very simple case of curve fitting. The
 * estimated coefficients are the amplitude a, the pulsation &amp;omega; and
 * the phase &amp;phi;: &lt;code&gt;f (t) = a cos (&amp;omega; t + &amp;phi;)&lt;/code&gt;. They are
 * searched by a least square estimator initialized with a rough guess
 * based on integrals.</text>
    <version>$Id: HarmonicFitter.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Simple constructor.</text>
    <param>optimizer Optimizer to use for the fitting.</param>
  </javadoc>
  <method type="constructor" name="HarmonicFitter" />
  <javadoc>
    <text>Fit an harmonic function to the observed points.</text>
    <param>initialGuess First guess values in the following order:
 * &lt;ul&gt;
 * &lt;li&gt;Amplitude&lt;/li&gt;
 * &lt;li&gt;Angular frequency&lt;/li&gt;
 * &lt;li&gt;Phase&lt;/li&gt;
 * &lt;/ul&gt;</param>
    <return>the parameters of the harmonic function that best fits the
 * observed points (in the same order as above).</return>
  </javadoc>
  <method type="double[]" name="fit" />
  <javadoc>
    <text>Fit an harmonic function to the observed points.
 * An initial guess will be automatically computed.</text>
    <return>the parameters of the harmonic function that best fits the
 * observed points (see the other {@link #fit(double[]) fit} method.</return>
    <throws>NumberIsTooSmallException if the sample is too short for the
 * the first guess to be computed.</throws>
    <throws>ZeroException if the first guess cannot be computed because
 * the abscissa range is zero.</throws>
  </javadoc>
  <method type="double[]" name="fit" />
  <javadoc>
    <text>This class guesses harmonic coefficients from a sample.
 * &lt;p&gt;The algorithm used to guess the coefficients is as follows:&lt;/p&gt;
 * &lt;p&gt;We know f (t) at some sampling points t&lt;sub&gt;i&lt;/sub&gt; and want to find a,
 * &amp;omega; and &amp;phi; such that f (t) = a cos (&amp;omega; t + &amp;phi;).
 * &lt;/p&gt;
 * &lt;p&gt;From the analytical expression, we can compute two primitives :
 * &lt;pre&gt;
 * If2  (t) = &amp;int; f&lt;sup&gt;2&lt;/sup&gt;  = a&lt;sup&gt;2&lt;/sup&gt; &amp;times; [t + S (t)] / 2
 * If'2 (t) = &amp;int; f'&lt;sup&gt;2&lt;/sup&gt; = a&lt;sup&gt;2&lt;/sup&gt; &amp;omega;&lt;sup&gt;2&lt;/sup&gt; &amp;times; [t - S (t)] / 2
 * where S (t) = sin (2 (&amp;omega; t + &amp;phi;)) / (2 &amp;omega;)
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;We can remove S between these expressions :
 * &lt;pre&gt;
 * If'2 (t) = a&lt;sup&gt;2&lt;/sup&gt; &amp;omega;&lt;sup&gt;2&lt;/sup&gt; t - &amp;omega;&lt;sup&gt;2&lt;/sup&gt; If2 (t)
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;The preceding expression shows that If'2 (t) is a linear
 * combination of both t and If2 (t): If'2 (t) = A &amp;times; t + B &amp;times; If2 (t)
 * &lt;/p&gt;
 * &lt;p&gt;From the primitive, we can deduce the same form for definite
 * integrals between t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;i&lt;/sub&gt; for each t&lt;sub&gt;i&lt;/sub&gt; :
 * &lt;pre&gt;
 * If2 (t&lt;sub&gt;i&lt;/sub&gt;) - If2 (t&lt;sub&gt;1&lt;/sub&gt;) = A &amp;times; (t&lt;sub&gt;i&lt;/sub&gt; - t&lt;sub&gt;1&lt;/sub&gt;) + B &amp;times; (If2 (t&lt;sub&gt;i&lt;/sub&gt;) - If2 (t&lt;sub&gt;1&lt;/sub&gt;))
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;We can find the coefficients A and B that best fit the sample
 * to this linear expression by computing the definite integrals for
 * each sample points.
 * &lt;/p&gt;
 * &lt;p&gt;For a bilinear expression z (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;) = A &amp;times; x&lt;sub&gt;i&lt;/sub&gt; + B &amp;times; y&lt;sub&gt;i&lt;/sub&gt;, the
 * coefficients A and B that minimize a least square criterion
 * &amp;sum; (z&lt;sub&gt;i&lt;/sub&gt; - z (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;))&lt;sup&gt;2&lt;/sup&gt; are given by these expressions:&lt;/p&gt;
 * &lt;pre&gt;
 * &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
 * A = ------------------------
 * &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;
 * &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
 * B = ------------------------
 * &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;In fact, we can assume both a and &amp;omega; are positive and
 * compute them directly, knowing that A = a&lt;sup&gt;2&lt;/sup&gt; &amp;omega;&lt;sup&gt;2&lt;/sup&gt; and that
 * B = - &amp;omega;&lt;sup&gt;2&lt;/sup&gt;. The complete algorithm is therefore:&lt;/p&gt;
 * &lt;pre&gt;
 * for each t&lt;sub&gt;i&lt;/sub&gt; from t&lt;sub&gt;1&lt;/sub&gt; to t&lt;sub&gt;n-1&lt;/sub&gt;, compute:
 * f  (t&lt;sub&gt;i&lt;/sub&gt;)
 * f' (t&lt;sub&gt;i&lt;/sub&gt;) = (f (t&lt;sub&gt;i+1&lt;/sub&gt;) - f(t&lt;sub&gt;i-1&lt;/sub&gt;)) / (t&lt;sub&gt;i+1&lt;/sub&gt; - t&lt;sub&gt;i-1&lt;/sub&gt;)
 * x&lt;sub&gt;i&lt;/sub&gt; = t&lt;sub&gt;i&lt;/sub&gt; - t&lt;sub&gt;1&lt;/sub&gt;
 * y&lt;sub&gt;i&lt;/sub&gt; = &amp;int; f&lt;sup&gt;2&lt;/sup&gt; from t&lt;sub&gt;1&lt;/sub&gt; to t&lt;sub&gt;i&lt;/sub&gt;
 * z&lt;sub&gt;i&lt;/sub&gt; = &amp;int; f'&lt;sup&gt;2&lt;/sup&gt; from t&lt;sub&gt;1&lt;/sub&gt; to t&lt;sub&gt;i&lt;/sub&gt;
 * update the sums &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt;, &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;, &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;, &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; and &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
 * end for
 * |--------------------------
 * \  | &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
 * a     =  \ | ------------------------
 * \| &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
 * |--------------------------
 * \  | &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
 * &amp;omega;     =  \ | ------------------------
 * \| &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;Once we know &amp;omega;, we can compute:
 * &lt;pre&gt;
 * fc = &amp;omega; f (t) cos (&amp;omega; t) - f' (t) sin (&amp;omega; t)
 * fs = &amp;omega; f (t) sin (&amp;omega; t) + f' (t) cos (&amp;omega; t)
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;It appears that &lt;code&gt;fc = a &amp;omega; cos (&amp;phi;)&lt;/code&gt; and
 * &lt;code&gt;fs = -a &amp;omega; sin (&amp;phi;)&lt;/code&gt;, so we can use these
 * expressions to compute &amp;phi;. The best estimate over the sample is
 * given by averaging these expressions.
 * &lt;/p&gt;
 * &lt;p&gt;Since integrals and means are involved in the preceding
 * estimations, these operations run in O(n) time, where n is the
 * number of measurements.&lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>Amplitude.</text>
  </javadoc>
  <declaration type="double" name="a" />
  <javadoc>
    <text>Angular frequency.</text>
  </javadoc>
  <declaration type="double" name="omega" />
  <javadoc>
    <text>Phase.</text>
  </javadoc>
  <declaration type="double" name="phi" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>observations Sampled observations.</param>
    <throws>NumberIsTooSmallException if the sample is too short.</throws>
    <throws>ZeroException if the abscissa range is zero.</throws>
    <throws>MathIllegalStateException when the guessing procedure cannot
 * produce sensible results.</throws>
  </javadoc>
  <method type="constructor" name="ParameterGuesser">
    <scope />
    <declaration type="WeightedObservedPoint[]" name="sorted" />
    <declaration type="double[]" name="aOmega" />
  </method>
  <javadoc>
    <text>Gets an estimation of the parameters.</text>
    <return>the guessed parameters, in the following order:
 * &lt;ul&gt;
 * &lt;li&gt;Amplitude&lt;/li&gt;
 * &lt;li&gt;Angular frequency&lt;/li&gt;
 * &lt;li&gt;Phase&lt;/li&gt;
 * &lt;/ul&gt;</return>
  </javadoc>
  <method type="double[]" name="guess" />
  <javadoc>
    <text>Sort the observations with respect to the abscissa.</text>
    <param>unsorted Input observations.</param>
    <return>the input observations, sorted.</return>
  </javadoc>
  <method type="WeightedObservedPoint[]" name="sortObservations">
    <declaration type="WeightedObservedPoint[]" name="observations" />
    <declaration type="WeightedObservedPoint" name="curr" />
    <scope>
      <declaration type="WeightedObservedPoint" name="prec" />
      <scope>
        <declaration type="int" name="i" />
        <declaration type="WeightedObservedPoint" name="mI" />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>Since the samples are almost always already sorted, this</comment>
    <comment>method is implemented as an insertion sort that reorders the</comment>
    <comment>elements in place. Insertion sort is very efficient in this case.</comment>
    <comment>the current element should be inserted closer to the beginning</comment>
  </method>
  <javadoc>
    <text>Estimate a first guess of the amplitude and angular frequency.
 * This method assumes that the {@link #sortObservations()} method
 * has been called previously.</text>
    <param>observations Observations, sorted w.r.t. abscissa.</param>
    <throws>ZeroException if the abscissa range is zero.</throws>
    <throws>MathIllegalStateException when the guessing procedure cannot
 * produce sensible results.</throws>
    <return>the guessed amplitude (at index 0) and circular frequency
 * (at index 1).</return>
  </javadoc>
  <method type="double[]" name="guessAOmega">
    <declaration type="double[]" name="aOmega" />
    <declaration type="double" name="sx2" />
    <declaration type="double" name="sy2" />
    <declaration type="double" name="sxy" />
    <declaration type="double" name="sxz" />
    <declaration type="double" name="syz" />
    <declaration type="double" name="currentX" />
    <declaration type="double" name="currentY" />
    <declaration type="double" name="f2Integral" />
    <declaration type="double" name="fPrime2Integral" />
    <declaration type="double" name="startX" />
    <scope>
      <declaration type="double" name="previousX" />
      <declaration type="double" name="previousY" />
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
      <declaration type="double" name="f2StepIntegral" />
      <declaration type="double" name="fPrime2StepIntegral" />
      <declaration type="double" name="x" />
    </scope>
    <declaration type="double" name="c1" />
    <declaration type="double" name="c2" />
    <declaration type="double" name="c3" />
    <scope>
      <declaration type="int" name="last" />
      <declaration type="double" name="xRange" />
      <scope />
      <declaration type="double" name="yMin" />
      <declaration type="double" name="yMax" />
      <scope>
        <declaration type="double" name="y" />
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>initialize the sums for the linear model between the two integrals</comment>
    <comment>one step forward</comment>
    <comment>update the integrals of f&lt;sup&gt;2&lt;/sup&gt; and f'&lt;sup&gt;2&lt;/sup&gt;</comment>
    <comment>considering a linear model for f (and therefore constant f')</comment>
    <comment>compute the amplitude and pulsation coefficients</comment>
    <comment>Range of the observations, assuming that the</comment>
    <comment>observations are sorted.</comment>
    <comment>In some ill-conditioned cases (cf. MATH-844), the guesser</comment>
    <comment>procedure cannot produce sensible results.</comment>
  </method>
  <javadoc>
    <text>Estimate a first guess of the phase.</text>
    <param>observations Observations, sorted w.r.t. abscissa.</param>
    <return>the guessed phase.</return>
  </javadoc>
  <method type="double" name="guessPhi">
    <declaration type="double" name="fcMean" />
    <declaration type="double" name="fsMean" />
    <declaration type="double" name="currentX" />
    <declaration type="double" name="currentY" />
    <scope>
      <declaration type="double" name="previousX" />
      <declaration type="double" name="previousY" />
      <declaration type="double" name="currentYPrime" />
      <declaration type="double" name="omegaX" />
      <declaration type="double" name="cosine" />
      <declaration type="double" name="sine" />
    </scope>
    <comment>initialize the means</comment>
    <comment>one step forward</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
