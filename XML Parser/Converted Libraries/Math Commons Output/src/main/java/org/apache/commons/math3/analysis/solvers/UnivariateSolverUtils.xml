<?xml version="1.0" encoding="UTF-8"?>
<class name="UnivariateSolverUtils">
  <javadoc>
    <text>Utility routines for {@link UnivariateSolver} objects.</text>
    <version>$Id: UnivariateSolverUtils.java 1400850 2012-10-22 11:57:17Z erans $</version>
  </javadoc>
  <javadoc>
    <text>Class contains only static methods.</text>
  </javadoc>
  <method type="constructor" name="UnivariateSolverUtils" />
  <javadoc>
    <text>Convenience method to find a zero of a univariate real function.  A default
 * solver is used.</text>
    <param>function Function.</param>
    <param>x0 Lower bound for the interval.</param>
    <param>x1 Upper bound for the interval.</param>
    <return>a value where the function is zero.</return>
    <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
    <throws>NullArgumentException if {@code function} is {@code null}.</throws>
  </javadoc>
  <method type="double" name="solve">
    <scope />
    <declaration type="UnivariateSolver" name="solver" />
  </method>
  <javadoc>
    <text>Convenience method to find a zero of a univariate real function.  A default
 * solver is used.</text>
    <param>function Function.</param>
    <param>x0 Lower bound for the interval.</param>
    <param>x1 Upper bound for the interval.</param>
    <param>absoluteAccuracy Accuracy to be used by the solver.</param>
    <return>a value where the function is zero.</return>
    <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
    <throws>NullArgumentException if {@code function} is {@code null}.</throws>
  </javadoc>
  <method type="double" name="solve">
    <scope />
    <declaration type="UnivariateSolver" name="solver" />
  </method>
  <javadoc>
    <text>Force a root found by a non-bracketing solver to lie on a specified side,
 * as if the solver was a bracketing one.</text>
    <param>maxEval maximal number of new evaluations of the function
 * (evaluations already done for finding the root should have already been subtracted
 * from this number)</param>
    <param>f function to solve</param>
    <param>bracketing bracketing solver to use for shifting the root</param>
    <param>baseRoot original root found by a previous non-bracketing solver</param>
    <param>min minimal bound of the search interval</param>
    <param>max maximal bound of the search interval</param>
    <param>allowedSolution the kind of solutions that the root-finding algorithm may
 * accept as solutions.</param>
    <return>a root approximation, on the specified side of the exact root</return>
    <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
  </javadoc>
  <method type="double" name="forceSide">
    <scope />
    <declaration type="double" name="step" />
    <declaration type="double" name="xLo" />
    <declaration type="double" name="fLo" />
    <declaration type="double" name="xHi" />
    <declaration type="double" name="fHi" />
    <declaration type="int" name="remainingEval" />
    <scope>
      <scope />
      <declaration type="boolean" name="changeLo" />
      <declaration type="boolean" name="changeHi" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>no further bracketing required</comment>
    <comment>find a very small interval bracketing the root</comment>
    <comment>compute the root on the selected side</comment>
    <comment>try increasing the interval</comment>
    <comment>increasing function</comment>
    <comment>decreasing function</comment>
    <comment>unknown variation</comment>
    <comment>update the lower bound</comment>
    <comment>update the higher bound</comment>
  </method>
  <javadoc>
    <text>This method attempts to find two values a and b satisfying &lt;ul&gt;
 * &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt; 0 &lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
 * and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
 * &lt;p&gt;
 * The algorithm starts by setting
 * &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
 * function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
 * the endpoints out by one unit each time through a loop that terminates
 * when one of the following happens: &lt;ul&gt;
 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt; 0 &lt;/code&gt; --  success!&lt;/li&gt;
 * &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
 * -- NoBracketingException &lt;/li&gt;
 * &lt;li&gt; &lt;code&gt; Integer.MAX_VALUE&lt;/code&gt; iterations elapse
 * -- NoBracketingException &lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Note: &lt;/strong&gt; this method can take
 * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; iterations to throw a
 * &lt;code&gt;ConvergenceException.&lt;/code&gt;  Unless you are confident that there
 * is a root between &lt;code&gt;lowerBound&lt;/code&gt; and &lt;code&gt;upperBound&lt;/code&gt;
 * near &lt;code&gt;initial,&lt;/code&gt; it is better to use{@link #bracket(UnivariateFunction,double,double,double,int)},
 * explicitly specifying the maximum number of iterations.&lt;/p&gt;</text>
    <param>function Function.</param>
    <param>initial Initial midpoint of interval being expanded to
 * bracket a root.</param>
    <param>lowerBound Lower bound (a is never lower than this value)</param>
    <param>upperBound Upper bound (b never is greater than this
 * value).</param>
    <return>a two-element array holding a and b.</return>
    <throws>NoBracketingException if a root cannot be bracketted.</throws>
    <throws>NotStrictlyPositiveException if {@code maximumIterations &lt;= 0}.</throws>
    <throws>NullArgumentException if {@code function} is {@code null}.</throws>
  </javadoc>
  <method type="double[]" name="bracket" />
  <javadoc>
    <text>This method attempts to find two values a and b satisfying &lt;ul&gt;
 * &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt;= 0 &lt;/code&gt; &lt;/li&gt;
 * &lt;/ul&gt;
 * If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
 * and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
 * &lt;p&gt;
 * The algorithm starts by setting
 * &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
 * function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
 * the endpoints out by one unit each time through a loop that terminates
 * when one of the following happens: &lt;ul&gt;
 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt;= 0 &lt;/code&gt; --  success!&lt;/li&gt;
 * &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
 * -- NoBracketingException &lt;/li&gt;
 * &lt;li&gt; &lt;code&gt; maximumIterations&lt;/code&gt; iterations elapse
 * -- NoBracketingException &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;</text>
    <param>function Function.</param>
    <param>initial Initial midpoint of interval being expanded to
 * bracket a root.</param>
    <param>lowerBound Lower bound (a is never lower than this value).</param>
    <param>upperBound Upper bound (b never is greater than this
 * value).</param>
    <param>maximumIterations Maximum number of iterations to perform</param>
    <return>a two element array holding a and b.</return>
    <throws>NoBracketingException if the algorithm fails to find a and b
 * satisfying the desired conditions.</throws>
    <throws>NotStrictlyPositiveException if {@code maximumIterations &lt;= 0}.</throws>
    <throws>NullArgumentException if {@code function} is {@code null}.</throws>
  </javadoc>
  <method type="double[]" name="bracket">
    <scope />
    <scope />
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <declaration type="double" name="fa" />
    <declaration type="double" name="fb" />
    <declaration type="int" name="numIterations" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compute the midpoint of two values.</text>
    <param>a first value.</param>
    <param>b second value.</param>
    <return>the midpoint.</return>
  </javadoc>
  <method type="double" name="midpoint" />
  <javadoc>
    <text>Check whether the interval bounds bracket a root. That is, if the
 * values at the endpoints are not equal to zero, then the function takes
 * opposite signs at the endpoints.</text>
    <param>function Function.</param>
    <param>lower Lower endpoint.</param>
    <param>upper Upper endpoint.</param>
    <return>{@code true} if the function values have opposite signs at the
 * given points.</return>
    <throws>NullArgumentException if {@code function} is {@code null}.</throws>
  </javadoc>
  <method type="boolean" name="isBracketing">
    <scope />
    <declaration type="double" name="fLo" />
    <declaration type="double" name="fHi" />
  </method>
  <javadoc>
    <text>Check whether the arguments form a (strictly) increasing sequence.</text>
    <param>start First number.</param>
    <param>mid Second number.</param>
    <param>end Third number.</param>
    <return>{@code true} if the arguments form an increasing sequence.</return>
  </javadoc>
  <method type="boolean" name="isSequence" />
  <javadoc>
    <text>Check that the endpoints specify an interval.</text>
    <param>lower Lower endpoint.</param>
    <param>upper Upper endpoint.</param>
    <throws>NumberIsTooLargeException if {@code lower &gt;= upper}.</throws>
  </javadoc>
  <method type="void" name="verifyInterval">
    <scope />
  </method>
  <javadoc>
    <text>Check that {@code lower &lt; initial &lt; upper}.</text>
    <param>lower Lower endpoint.</param>
    <param>initial Initial value.</param>
    <param>upper Upper endpoint.</param>
    <throws>NumberIsTooLargeException if {@code lower &gt;= initial} or{@code initial &gt;= upper}.</throws>
  </javadoc>
  <method type="void" name="verifySequence" />
  <javadoc>
    <text>Check that the endpoints specify an interval and the end points
 * bracket a root.</text>
    <param>function Function.</param>
    <param>lower Lower endpoint.</param>
    <param>upper Upper endpoint.</param>
    <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
    <throws>NullArgumentException if {@code function} is {@code null}.</throws>
  </javadoc>
  <method type="void" name="verifyBracketing">
    <scope />
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
