<?xml version="1.0" encoding="UTF-8"?>
<class name="Gamma">
  <javadoc>
    <text>&lt;p&gt;
 * This is a utility class that provides computation methods related to the
 * &amp;Gamma; (Gamma) family of functions.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Implementation of {@link #invGamma1pm1(double)} and{@link #logGamma1p(double)} is based on the algorithms described in
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href="http://dx.doi.org/10.1145/22721.23109"&gt;Didonato and Morris
 * (1986)&lt;/a&gt;, &lt;em&gt;Computation of the Incomplete Gamma Function Ratios and
 * their Inverse&lt;/em&gt;, TOMS 12(4), 377-393,&lt;/li&gt;
 * &lt;li&gt;&lt;a href="http://dx.doi.org/10.1145/131766.131776"&gt;Didonato and Morris
 * (1992)&lt;/a&gt;, &lt;em&gt;Algorithm 708: Significant Digit Computation of the
 * Incomplete Beta Function Ratios&lt;/em&gt;, TOMS 18(3), 360-373,&lt;/li&gt;
 * &lt;/ul&gt;
 * and implemented in the
 * &lt;a href="http://www.dtic.mil/docs/citations/ADA476840"&gt;NSWC Library of Mathematical Functions&lt;/a&gt;,
 * available
 * &lt;a href="http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html"&gt;here&lt;/a&gt;.
 * This library is "approved for public release", and the
 * &lt;a href="http://www.dtic.mil/dtic/pdf/announcements/CopyrightGuidance.pdf"&gt;Copyright guidance&lt;/a&gt;
 * indicates that unless otherwise stated in the code, all FORTRAN functions in
 * this library are license free. Since no such notice appears in the code these
 * functions can safely be ported to Commons-Math.
 * &lt;/p&gt;</text>
    <version>$Id: Gamma.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
  </javadoc>
  <javadoc>
    <text>&lt;a href="http://en.wikipedia.org/wiki/Euler-Mascheroni_constant"&gt;Euler-Mascheroni constant&lt;/a&gt;</text>
    <since>2.0</since>
  </javadoc>
  <declaration type="double" name="GAMMA" />
  <javadoc>
    <text>The value of the {@code g} constant in the Lanczos approximation, see{@link #lanczos(double)}.</text>
    <since>3.1</since>
  </javadoc>
  <declaration type="double" name="LANCZOS_G" />
  <javadoc>
    <text>Maximum allowed numerical error.</text>
  </javadoc>
  <declaration type="double" name="DEFAULT_EPSILON" />
  <javadoc>
    <text>Lanczos coefficients</text>
  </javadoc>
  <declaration type="double[]" name="LANCZOS" />
  <javadoc>
    <text>Avoid repeated computation of log of 2 PI in logGamma</text>
  </javadoc>
  <declaration type="double" name="HALF_LOG_2_PI" />
  <javadoc>
    <text>The constant value of &amp;radic;(2&amp;pi;).</text>
  </javadoc>
  <declaration type="double" name="SQRT_TWO_PI" />
  <javadoc>
    <text>C limit.</text>
  </javadoc>
  <declaration type="double" name="C_LIMIT" />
  <javadoc>
    <text>S limit.</text>
  </javadoc>
  <declaration type="double" name="S_LIMIT" />
  <javadoc>
    <text>The constant {@code A0} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_A0" />
  <javadoc>
    <text>The constant {@code A1} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_A1" />
  <javadoc>
    <text>The constant {@code B1} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B1" />
  <javadoc>
    <text>The constant {@code B2} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B2" />
  <javadoc>
    <text>The constant {@code B3} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B3" />
  <javadoc>
    <text>The constant {@code B4} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B4" />
  <javadoc>
    <text>The constant {@code B5} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B5" />
  <javadoc>
    <text>The constant {@code B6} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B6" />
  <javadoc>
    <text>The constant {@code B7} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B7" />
  <javadoc>
    <text>The constant {@code B8} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_B8" />
  <javadoc>
    <text>The constant {@code P0} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P0" />
  <javadoc>
    <text>The constant {@code P1} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P1" />
  <javadoc>
    <text>The constant {@code P2} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P2" />
  <javadoc>
    <text>The constant {@code P3} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P3" />
  <javadoc>
    <text>The constant {@code P4} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P4" />
  <javadoc>
    <text>The constant {@code P5} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P5" />
  <javadoc>
    <text>The constant {@code P6} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_P6" />
  <javadoc>
    <text>The constant {@code Q1} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_Q1" />
  <javadoc>
    <text>The constant {@code Q2} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_Q2" />
  <javadoc>
    <text>The constant {@code Q3} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_Q3" />
  <javadoc>
    <text>The constant {@code Q4} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_Q4" />
  <javadoc>
    <text>The constant {@code C} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C" />
  <javadoc>
    <text>The constant {@code C0} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C0" />
  <javadoc>
    <text>The constant {@code C1} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C1" />
  <javadoc>
    <text>The constant {@code C2} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C2" />
  <javadoc>
    <text>The constant {@code C3} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C3" />
  <javadoc>
    <text>The constant {@code C4} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C4" />
  <javadoc>
    <text>The constant {@code C5} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C5" />
  <javadoc>
    <text>The constant {@code C6} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C6" />
  <javadoc>
    <text>The constant {@code C7} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C7" />
  <javadoc>
    <text>The constant {@code C8} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C8" />
  <javadoc>
    <text>The constant {@code C9} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C9" />
  <javadoc>
    <text>The constant {@code C10} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C10" />
  <javadoc>
    <text>The constant {@code C11} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C11" />
  <javadoc>
    <text>The constant {@code C12} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C12" />
  <javadoc>
    <text>The constant {@code C13} defined in {@code DGAM1}.</text>
  </javadoc>
  <declaration type="double" name="INV_GAMMA1P_M1_C13" />
  <javadoc>
    <text>Default constructor.  Prohibit instantiation.</text>
  </javadoc>
  <method type="constructor" name="Gamma" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns the value of log&amp;nbsp;&amp;Gamma;(x) for x&amp;nbsp;&amp;gt;&amp;nbsp;0.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For x &amp;le; 8, the implementation is based on the double precision
 * implementation in the &lt;em&gt;NSWC Library of Mathematics Subroutines&lt;/em&gt;,{@code DGAMLN}. For x &amp;gt; 8, the implementation is based on
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href="http://mathworld.wolfram.com/GammaFunction.html"&gt;Gamma
 * Function&lt;/a&gt;, equation (28).&lt;/li&gt;
 * &lt;li&gt;&lt;a href="http://mathworld.wolfram.com/LanczosApproximation.html"&gt;
 * Lanczos Approximation&lt;/a&gt;, equations (1) through (5).&lt;/li&gt;
 * &lt;li&gt;&lt;a href="http://my.fit.edu/~gabdo/gamma.txt"&gt;Paul Godfrey, A note on
 * the computation of the convergent Lanczos complex Gamma
 * approximation&lt;/a&gt;&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>x Argument.</param>
    <return>the value of {@code log(Gamma(x))}, {@code Double.NaN} if{@code x &lt;= 0.0}.</return>
  </javadoc>
  <method type="double" name="logGamma">
    <declaration type="double" name="ret" />
    <scope />
    <scope />
    <scope />
    <scope>
      <declaration type="int" name="n" />
      <declaration type="double" name="prod" />
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="sum" />
      <declaration type="double" name="tmp" />
    </scope>
  </method>
  <javadoc>
    <text>Returns the regularized gamma function P(a, x).</text>
    <param>a Parameter.</param>
    <param>x Value.</param>
    <return>the regularized gamma function P(a, x).</return>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
  </javadoc>
  <method type="double" name="regularizedGammaP" />
  <javadoc>
    <text>Returns the regularized gamma function P(a, x).
 * The implementation of this method is based on:
 * &lt;ul&gt;
 * &lt;li&gt;
 * &lt;a href="http://mathworld.wolfram.com/RegularizedGammaFunction.html"&gt;
 * Regularized Gamma Function&lt;/a&gt;, equation (1)
 * &lt;/li&gt;
 * &lt;li&gt;
 * &lt;a href="http://mathworld.wolfram.com/IncompleteGammaFunction.html"&gt;
 * Incomplete Gamma Function&lt;/a&gt;, equation (4).
 * &lt;/li&gt;
 * &lt;li&gt;
 * &lt;a href="http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"&gt;
 * Confluent Hypergeometric Function of the First Kind&lt;/a&gt;, equation (1).
 * &lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>a the a parameter.</param>
    <param>x the value.</param>
    <param>epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.</param>
    <param>maxIterations Maximum number of "iterations" to complete.</param>
    <return>the regularized gamma function P(a, x)</return>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
  </javadoc>
  <method type="double" name="regularizedGammaP">
    <declaration type="double" name="ret" />
    <scope />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="n" />
      <declaration type="double" name="an" />
      <declaration type="double" name="sum" />
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>use regularizedGammaQ because it should converge faster in this</comment>
    <comment>case.</comment>
    <comment>calculate series</comment>
    <comment>current element index</comment>
    <comment>n-th element in the series</comment>
    <comment>partial sum</comment>
    <comment>compute next element in the series</comment>
    <comment>update partial sum</comment>
  </method>
  <javadoc>
    <text>Returns the regularized gamma function Q(a, x) = 1 - P(a, x).</text>
    <param>a the a parameter.</param>
    <param>x the value.</param>
    <return>the regularized gamma function Q(a, x)</return>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
  </javadoc>
  <method type="double" name="regularizedGammaQ" />
  <javadoc>
    <text>Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
 * The implementation of this method is based on:
 * &lt;ul&gt;
 * &lt;li&gt;
 * &lt;a href="http://mathworld.wolfram.com/RegularizedGammaFunction.html"&gt;
 * Regularized Gamma Function&lt;/a&gt;, equation (1).
 * &lt;/li&gt;
 * &lt;li&gt;
 * &lt;a href="http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"&gt;
 * Regularized incomplete gamma function: Continued fraction representations
 * (formula 06.08.10.0003)&lt;/a&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>a the a parameter.</param>
    <param>x the value.</param>
    <param>epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.</param>
    <param>maxIterations Maximum number of "iterations" to complete.</param>
    <return>the regularized gamma function P(a, x)</return>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
  </javadoc>
  <method type="double" name="regularizedGammaQ">
    <declaration type="double" name="ret" />
    <scope />
    <scope />
    <scope />
    <scope>
      <declaration type="ContinuedFraction" name="cf" />
      <method type="double" name="getA" />
      <method type="double" name="getB" />
    </scope>
    <comment>use regularizedGammaP because it should converge faster in this</comment>
    <comment>case.</comment>
    <comment>create continued fraction</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;Computes the digamma function of x.&lt;/p&gt;
 * &lt;p&gt;This is an independently written implementation of the algorithm described in
 * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.&lt;/p&gt;
 * &lt;p&gt;Some of the constants have been changed to increase accuracy at the moderate expense
 * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for
 * x &gt;= 10^-5 and within 10^-8 relative tolerance for x &gt; 0.&lt;/p&gt;
 * &lt;p&gt;Performance for large negative values of x will be quite expensive (proportional to
 * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results
 * less than 10^5 and 10^-8 relative for results larger than that.&lt;/p&gt;</text>
    <param>x Argument.</param>
    <return>digamma(x) to within 10-8 relative or absolute error whichever is smaller.</return>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Digamma_function"&gt;Digamma&lt;/a&gt;</see>
    <see>&lt;a href="http://www.uv.es/~bernardo/1976AppStatist.pdf"&gt;Bernardo&amp;apos;s original article &lt;/a&gt;</see>
    <since>2.0</since>
  </javadoc>
  <method type="double" name="digamma">
    <scope />
    <scope>
      <declaration type="double" name="inv" />
    </scope>
    <comment>use method 5 from Bernardo AS103</comment>
    <comment>accurate to O(x)</comment>
    <comment>use method 4 (accurate to O(1/x^8)</comment>
    <comment>1       1        1         1</comment>
    <comment>log(x) -  --- - ------ + ------- - -------</comment>
    <comment>2 x   12 x^2   120 x^4   252 x^6</comment>
  </method>
  <javadoc>
    <text>Computes the trigamma function of x.
 * This function is derived by taking the derivative of the implementation
 * of digamma.</text>
    <param>x Argument.</param>
    <return>trigamma(x) to within 10-8 relative or absolute error whichever is smaller</return>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Trigamma_function"&gt;Trigamma&lt;/a&gt;</see>
    <see>Gamma#digamma(double)</see>
    <since>2.0</since>
  </javadoc>
  <method type="double" name="trigamma">
    <scope />
    <scope>
      <declaration type="double" name="inv" />
    </scope>
    <comment>1    1      1       1       1</comment>
    <comment>- + ---- + ---- - ----- + -----</comment>
    <comment>x      2      3       5       7</comment>
    <comment>2 x    6 x    30 x    42 x</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the Lanczos approximation used to compute the gamma function.
 * The Lanczos approximation is related to the Gamma function by the
 * following equation
 * &lt;center&gt;{@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)
 * * exp(-x - g - 0.5) * lanczos(x)},
 * &lt;/center&gt;
 * where {@code g} is the Lanczos constant.
 * &lt;/p&gt;</text>
    <param>x Argument.</param>
    <return>The Lanczos approximation.</return>
    <see>&lt;a href="http://mathworld.wolfram.com/LanczosApproximation.html"&gt;Lanczos Approximation&lt;/a&gt;
 * equations (1) through (5), and Paul Godfrey's
 * &lt;a href="http://my.fit.edu/~gabdo/gamma.txt"&gt;Note on the computation
 * of the convergent Lanczos complex Gamma approximation&lt;/a&gt;</see>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="lanczos">
    <declaration type="double" name="sum" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the value of 1 / &amp;Gamma;(1 + x) - 1 for -0&amp;#46;5 &amp;le; x &amp;le;
 * 1&amp;#46;5. This implementation is based on the double precision
 * implementation in the &lt;em&gt;NSWC Library of Mathematics Subroutines&lt;/em&gt;,{@code DGAM1}.</text>
    <param>x Argument.</param>
    <return>The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.</return>
    <throws>NumberIsTooSmallException if {@code x &lt; -0.5}</throws>
    <throws>NumberIsTooLargeException if {@code x &gt; 1.5}</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="invGamma1pm1">
    <scope />
    <scope />
    <declaration type="double" name="ret" />
    <declaration type="double" name="t" />
    <scope>
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="c" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="p" />
      <declaration type="double" name="q" />
      <declaration type="double" name="c" />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the value of log &amp;Gamma;(1 + x) for -0&amp;#46;5 &amp;le; x &amp;le; 1&amp;#46;5.
 * This implementation is based on the double precision implementation in
 * the &lt;em&gt;NSWC Library of Mathematics Subroutines&lt;/em&gt;, {@code DGMLN1}.</text>
    <param>x Argument.</param>
    <return>The value of {@code log(Gamma(1 + x))}.</return>
    <throws>NumberIsTooSmallException if {@code x &lt; -0.5}.</throws>
    <throws>NumberIsTooLargeException if {@code x &gt; 1.5}.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="logGamma1p">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns the value of Î“(x). Based on the &lt;em&gt;NSWC Library of
 * Mathematics Subroutines&lt;/em&gt; double precision implementation,{@code DGAMMA}.</text>
    <param>x Argument.</param>
    <return>the value of {@code Gamma(x)}.</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="gamma">
    <scope />
    <declaration type="double" name="ret" />
    <declaration type="double" name="absX" />
    <scope>
      <scope>
        <declaration type="double" name="prod" />
        <declaration type="double" name="t" />
        <scope />
      </scope>
      <scope>
        <declaration type="double" name="prod" />
        <declaration type="double" name="t" />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="double" name="y" />
      <declaration type="double" name="gammaAbs" />
      <scope />
      <scope />
    </scope>
    <comment>From the recurrence relation
 Gamma(x) = (x - 1)  ...  (x - n)  Gamma(x - n),
 then
 Gamma(t) = 1  [1 + invGamma1pm1(t - 1)],
 where t = x - n. This means that t must satisfy
 -0.5 &lt;= t - 1 &lt;= 1.5.</comment>
    <comment>From the recurrence relation
 Gamma(x) = Gamma(x + n + 1)  [x  (x + 1)  ...  (x + n)]
 then
 Gamma(x + n + 1) = 1  [1 + invGamma1pm1(x + n)],
 which requires -0.5 &lt;= x + n &lt;= 1.5.</comment>
    <comment>From the reflection formula
 Gamma(x)  Gamma(1 - x)  sin(pi  x) = pi,
 and the recurrence relation
 Gamma(1 - x) = -x  Gamma(-x),
 it is found
 Gamma(x) = -pi  [x  sin(pi  x)  Gamma(-x)].</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>limits for switching algorithm in digamma</comment>
  <comment>Constants for the computation of double invGamma1pm1(double).
 Copied from DGAM1 in the NSWC library.</comment>
</class>
