<?xml version="1.0" encoding="UTF-8"?>
<class name="Plane">
  <javadoc>
    <text>The class represent planes in a three dimensional space.</text>
    <version>$Id: Plane.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Offset of the origin with respect to the plane.</text>
  </javadoc>
  <declaration type="double" name="originOffset" />
  <javadoc>
    <text>Origin of the plane frame.</text>
  </javadoc>
  <declaration type="Vector3D" name="origin" />
  <javadoc>
    <text>First vector of the plane frame (in plane).</text>
  </javadoc>
  <declaration type="Vector3D" name="u" />
  <javadoc>
    <text>Second vector of the plane frame (in plane).</text>
  </javadoc>
  <declaration type="Vector3D" name="v" />
  <javadoc>
    <text>Third vector of the plane frame (plane normal).</text>
  </javadoc>
  <declaration type="Vector3D" name="w" />
  <javadoc>
    <text>Build a plane normal to a given direction and containing the origin.</text>
    <param>normal normal direction to the plane</param>
    <exception>MathArithmeticException if the normal norm is too small</exception>
  </javadoc>
  <method type="constructor" name="Plane" />
  <javadoc>
    <text>Build a plane from a point and a normal.</text>
    <param>p point belonging to the plane</param>
    <param>normal normal direction to the plane</param>
    <exception>MathArithmeticException if the normal norm is too small</exception>
  </javadoc>
  <method type="constructor" name="Plane" />
  <javadoc>
    <text>Build a plane from three points.
 * &lt;p&gt;The plane is oriented in the direction of{@code (p2-p1) ^ (p3-p1)}&lt;/p&gt;</text>
    <param>p1 first point belonging to the plane</param>
    <param>p2 second point belonging to the plane</param>
    <param>p3 third point belonging to the plane</param>
    <exception>MathArithmeticException if the points do not constitute a plane</exception>
  </javadoc>
  <method type="constructor" name="Plane" />
  <javadoc>
    <text>Copy constructor.
 * &lt;p&gt;The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying object are
 * shared.&lt;/p&gt;</text>
    <param>plane plane to copy</param>
  </javadoc>
  <method type="constructor" name="Plane" />
  <javadoc>
    <text>Copy the instance.
 * &lt;p&gt;The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying objects are
 * shared (except for immutable objects).&lt;/p&gt;</text>
    <return>a new hyperplane, copy of the instance</return>
  </javadoc>
  <method type="Plane" name="copySelf" />
  <javadoc>
    <text>Reset the instance as if built from a point and a normal.</text>
    <param>p point belonging to the plane</param>
    <param>normal normal direction to the plane</param>
    <exception>MathArithmeticException if the normal norm is too small</exception>
  </javadoc>
  <method type="void" name="reset" />
  <javadoc>
    <text>Reset the instance from another one.
 * &lt;p&gt;The updated instance is completely independant of the original
 * one. A deep reset is used none of the underlying object is
 * shared.&lt;/p&gt;</text>
    <param>original plane to reset from</param>
  </javadoc>
  <method type="void" name="reset" />
  <javadoc>
    <text>Set the normal vactor.</text>
    <param>normal normal direction to the plane (will be copied)</param>
    <exception>MathArithmeticException if the normal norm is too small</exception>
  </javadoc>
  <method type="void" name="setNormal">
    <declaration type="double" name="norm" />
    <scope />
  </method>
  <javadoc>
    <text>Reset the plane frame.</text>
  </javadoc>
  <method type="void" name="setFrame" />
  <javadoc>
    <text>Get the origin point of the plane frame.
 * &lt;p&gt;The point returned is the orthogonal projection of the
 * 3D-space origin in the plane.&lt;/p&gt;</text>
    <return>the origin point of the plane frame (point closest to the
 * 3D-space origin)</return>
  </javadoc>
  <method type="Vector3D" name="getOrigin" />
  <javadoc>
    <text>Get the normalized normal vector.
 * &lt;p&gt;The frame defined by ({@link #getU getU}, {@link #getV getV},{@link #getNormal getNormal}) is a rigth-handed orthonormalized
 * frame).&lt;/p&gt;</text>
    <return>normalized normal vector</return>
    <see>#getU</see>
    <see>#getV</see>
  </javadoc>
  <method type="Vector3D" name="getNormal" />
  <javadoc>
    <text>Get the plane first canonical vector.
 * &lt;p&gt;The frame defined by ({@link #getU getU}, {@link #getV getV},{@link #getNormal getNormal}) is a rigth-handed orthonormalized
 * frame).&lt;/p&gt;</text>
    <return>normalized first canonical vector</return>
    <see>#getV</see>
    <see>#getNormal</see>
  </javadoc>
  <method type="Vector3D" name="getU" />
  <javadoc>
    <text>Get the plane second canonical vector.
 * &lt;p&gt;The frame defined by ({@link #getU getU}, {@link #getV getV},{@link #getNormal getNormal}) is a rigth-handed orthonormalized
 * frame).&lt;/p&gt;</text>
    <return>normalized second canonical vector</return>
    <see>#getU</see>
    <see>#getNormal</see>
  </javadoc>
  <method type="Vector3D" name="getV" />
  <javadoc>
    <text>Revert the plane.
 * &lt;p&gt;Replace the instance by a similar plane with opposite orientation.&lt;/p&gt;
 * &lt;p&gt;The new plane frame is chosen in such a way that a 3D point that had{@code (x, y)} in-plane coordinates and {@code z} offset with
 * respect to the plane and is unaffected by the change will have{@code (y, x)} in-plane coordinates and {@code -z} offset with
 * respect to the new plane. This means that the {@code u} and {@code v}vectors returned by the {@link #getU} and {@link #getV} methods are exchanged,
 * and the {@code w} vector returned by the {@link #getNormal} method is
 * reversed.&lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="revertSelf">
    <declaration type="Vector3D" name="tmp" />
  </method>
  <javadoc>
    <text>Transform a 3D space point into an in-plane point.</text>
    <param>point point of the space (must be a {@link Vector3DVector3D} instance)</param>
    <return>in-plane point (really a {@link org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)</return>
    <see>#toSpace</see>
  </javadoc>
  <method type="Vector2D" name="toSubSpace" />
  <javadoc>
    <text>Transform an in-plane point into a 3D space point.</text>
    <param>point in-plane point (must be a {@link org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)</param>
    <return>3D space point (really a {@link Vector3D Vector3D} instance)</return>
    <see>#toSubSpace</see>
  </javadoc>
  <method type="Vector3D" name="toSpace">
    <declaration type="Vector2D" name="p2D" />
  </method>
  <javadoc>
    <text>Get one point from the 3D-space.</text>
    <param>inPlane desired in-plane coordinates for the point in the
 * plane</param>
    <param>offset desired offset for the point</param>
    <return>one point in the 3D-space, with given coordinates and offset
 * relative to the plane</return>
  </javadoc>
  <method type="Vector3D" name="getPointAt" />
  <javadoc>
    <text>Check if the instance is similar to another plane.
 * &lt;p&gt;Planes are considered similar if they contain the same
 * points. This does not mean they are equal since they can have
 * opposite normals.&lt;/p&gt;</text>
    <param>plane plane to which the instance is compared</param>
    <return>true if the planes are similar</return>
  </javadoc>
  <method type="boolean" name="isSimilarTo">
    <declaration type="double" name="angle" />
  </method>
  <javadoc>
    <text>Rotate the plane around the specified point.
 * &lt;p&gt;The instance is not modified, a new instance is created.&lt;/p&gt;</text>
    <param>center rotation center</param>
    <param>rotation vectorial rotation operator</param>
    <return>a new plane</return>
  </javadoc>
  <method type="Plane" name="rotate">
    <declaration type="Vector3D" name="delta" />
    <declaration type="Plane" name="plane" />
    <comment>make sure the frame is transformed as desired</comment>
  </method>
  <javadoc>
    <text>Translate the plane by the specified amount.
 * &lt;p&gt;The instance is not modified, a new instance is created.&lt;/p&gt;</text>
    <param>translation translation to apply</param>
    <return>a new plane</return>
  </javadoc>
  <method type="Plane" name="translate">
    <declaration type="Plane" name="plane" />
    <comment>make sure the frame is transformed as desired</comment>
  </method>
  <javadoc>
    <text>Get the intersection of a line with the instance.</text>
    <param>line line intersecting the instance</param>
    <return>intersection point between between the line and the
 * instance (null if the line is parallel to the instance)</return>
  </javadoc>
  <method type="Vector3D" name="intersection">
    <declaration type="Vector3D" name="direction" />
    <declaration type="double" name="dot" />
    <scope />
    <declaration type="Vector3D" name="point" />
    <declaration type="double" name="k" />
  </method>
  <javadoc>
    <text>Build the line shared by the instance and another plane.</text>
    <param>other other plane</param>
    <return>line at the intersection of the instance and the
 * other plane (really a {@link Line Line} instance)</return>
  </javadoc>
  <method type="Line" name="intersection">
    <declaration type="Vector3D" name="direction" />
    <scope />
    <declaration type="Vector3D" name="point" />
  </method>
  <javadoc>
    <text>Get the intersection point of three planes.</text>
    <param>plane1 first plane1</param>
    <param>plane2 second plane2</param>
    <param>plane3 third plane2</param>
    <return>intersection point of three planes, null if some planes are parallel</return>
  </javadoc>
  <method type="Vector3D" name="intersection">
    <declaration type="double" name="a1" />
    <declaration type="double" name="b1" />
    <declaration type="double" name="c1" />
    <declaration type="double" name="d1" />
    <declaration type="double" name="a2" />
    <declaration type="double" name="b2" />
    <declaration type="double" name="c2" />
    <declaration type="double" name="d2" />
    <declaration type="double" name="a3" />
    <declaration type="double" name="b3" />
    <declaration type="double" name="c3" />
    <declaration type="double" name="d3" />
    <declaration type="double" name="a23" />
    <declaration type="double" name="b23" />
    <declaration type="double" name="c23" />
    <declaration type="double" name="determinant" />
    <scope />
    <declaration type="double" name="r" />
    <comment>coefficients of the three planes linear equations</comment>
    <comment>direct Cramer resolution of the linear system</comment>
    <comment>(this is still feasible for a 3x3 system)</comment>
  </method>
  <javadoc>
    <text>Build a region covering the whole hyperplane.</text>
    <return>a region covering the whole hyperplane</return>
  </javadoc>
  <method type="SubPlane" name="wholeHyperplane" />
  <javadoc>
    <text>Build a region covering the whole space.</text>
    <return>a region containing the instance (really a {@link PolyhedronsSet PolyhedronsSet} instance)</return>
  </javadoc>
  <method type="PolyhedronsSet" name="wholeSpace" />
  <javadoc>
    <text>Check if the instance contains a point.</text>
    <param>p point to check</param>
    <return>true if p belongs to the plane</return>
  </javadoc>
  <method type="boolean" name="contains" />
  <javadoc>
    <text>Get the offset (oriented distance) of a parallel plane.
 * &lt;p&gt;This method should be called only for parallel planes otherwise
 * the result is not meaningful.&lt;/p&gt;
 * &lt;p&gt;The offset is 0 if both planes are the same, it is
 * positive if the plane is on the plus side of the instance and
 * negative if it is on the minus side, according to its natural
 * orientation.&lt;/p&gt;</text>
    <param>plane plane to check</param>
    <return>offset of the plane</return>
  </javadoc>
  <method type="double" name="getOffset" />
  <javadoc>
    <text>Get the offset (oriented distance) of a point.
 * &lt;p&gt;The offset is 0 if the point is on the underlying hyperplane,
 * it is positive if the point is on one particular side of the
 * hyperplane, and it is negative if the point is on the other side,
 * according to the hyperplane natural orientation.&lt;/p&gt;</text>
    <param>point point to check</param>
    <return>offset of the point</return>
  </javadoc>
  <method type="double" name="getOffset" />
  <javadoc>
    <text>Check if the instance has the same orientation as another hyperplane.</text>
    <param>other other hyperplane to check against the instance</param>
    <return>true if the instance and the other hyperplane have
 * the same orientation</return>
  </javadoc>
  <method type="boolean" name="sameOrientationAs" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
