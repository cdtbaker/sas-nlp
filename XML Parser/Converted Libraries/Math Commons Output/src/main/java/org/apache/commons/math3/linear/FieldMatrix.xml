<?xml version="1.0" encoding="UTF-8"?>
<class name="FieldMatrix">
  <javadoc>
    <text>Interface defining field-valued matrix with basic algebraic operations.
 * &lt;p&gt;
 * Matrix element indexing is 0-based -- e.g., &lt;code&gt;getEntry(0, 0)&lt;/code&gt;
 * returns the element in the first row, first column of the matrix.&lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <version>$Id: FieldMatrix.java 1416643 2012-12-03 19:37:14Z tn $</version>
  </javadoc>
  <method name="getField" type="Field&lt;T&gt;" />
  <javadoc>
    <text>Get the type of field elements of the matrix.</text>
    <return>the type of field elements of the matrix.</return>
  </javadoc>
  <method name="createMatrix" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Create a new FieldMatrix&lt;T&gt; of the same type as the instance with
 * the supplied row and column dimensions.</text>
    <param>rowDimension  the number of rows in the new matrix</param>
    <param>columnDimension  the number of columns in the new matrix</param>
    <return>a new matrix of the same type as the instance</return>
    <throws>NotStrictlyPositiveException if row or column dimension is not
 * positive.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="copy" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Make a (deep) copy of this.</text>
    <return>a copy of this matrix.</return>
  </javadoc>
  <method name="add" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Compute the sum of this and m.</text>
    <param>m Matrix to be added.</param>
    <return>{@code this} + {@code m}.</return>
    <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this} matrix.</throws>
  </javadoc>
  <method name="subtract" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Subtract {@code m} from this matrix.</text>
    <param>m Matrix to be subtracted.</param>
    <return>{@code this} - {@code m}.</return>
    <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this} matrix.</throws>
  </javadoc>
  <method name="scalarAdd" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Increment each entry of this matrix.</text>
    <param>d Value to be added to each entry.</param>
    <return>{@code d} + {@code this}.</return>
  </javadoc>
  <method name="scalarMultiply" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Multiply each entry by {@code d}.</text>
    <param>d Value to multiply all entries by.</param>
    <return>{@code d} * {@code this}.</return>
  </javadoc>
  <method name="multiply" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Postmultiply this matrix by {@code m}.</text>
    <param>m  Matrix to postmultiply by.</param>
    <return>{@code this} * {@code m}.</return>
    <throws>DimensionMismatchException if the number of columns of{@code this} matrix is not equal to the number of rows of matrix{@code m}.</throws>
  </javadoc>
  <method name="preMultiply" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Premultiply this matrix by {@code m}.</text>
    <param>m Matrix to premultiply by.</param>
    <return>{@code m} * {@code this}.</return>
    <throws>DimensionMismatchException if the number of columns of {@code m}differs from the number of rows of {@code this} matrix.</throws>
  </javadoc>
  <method name="power" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Returns the result multiplying this with itself &lt;code&gt;p&lt;/code&gt; times.
 * Depending on the type of the field elements, T, instability for high
 * powers might occur.</text>
    <param>p raise this to power p</param>
    <return>this^p</return>
    <throws>NotPositiveException if {@code p &lt; 0}</throws>
    <throws>NonSquareMatrixException if {@code this matrix} is not square</throws>
  </javadoc>
  <method name="getData" type="T[][]" />
  <javadoc>
    <text>Returns matrix entries as a two-dimensional array.</text>
    <return>a 2-dimensional array of entries.</return>
  </javadoc>
  <method name="getSubMatrix" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Get a submatrix. Rows and columns are indicated
 * counting from 0 to n - 1.</text>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <return>the matrix containing the data of the specified rows and columns.</return>
    <throws>NumberIsTooSmallException is {@code endRow &lt; startRow} of{@code endColumn &lt; startColumn}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
  </javadoc>
  <method name="getSubMatrix" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Get a submatrix. Rows and columns are indicated
 * counting from 0 to n - 1.</text>
    <param>selectedRows Array of row indices.</param>
    <param>selectedColumns Array of column indices.</param>
    <return>the matrix containing the data in the
 * specified rows and columns.</return>
    <throws>NoDataException if {@code selectedRows} or{@code selectedColumns} is empty</throws>
    <throws>NullArgumentException if {@code selectedRows} or{@code selectedColumns} is {@code null}.</throws>
    <throws>OutOfRangeException if row or column selections are not valid.</throws>
  </javadoc>
  <method name="copySubMatrix" type="void" />
  <javadoc>
    <text>Copy a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.</text>
    <param>startRow Initial row index.</param>
    <param>endRow Final row index (inclusive).</param>
    <param>startColumn Initial column index.</param>
    <param>endColumn Final column index (inclusive).</param>
    <param>destination The arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be used).</param>
    <throws>MatrixDimensionMismatchException if the dimensions of{@code destination} do not match those of {@code this}.</throws>
    <throws>NumberIsTooSmallException is {@code endRow &lt; startRow} of{@code endColumn &lt; startColumn}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <exception>IllegalArgumentException if the destination array is too small.</exception>
  </javadoc>
  <method name="copySubMatrix" type="void" />
  <javadoc>
    <text>Copy a submatrix. Rows and columns are indicated
 * counting from 0 to n - 1.</text>
    <param>selectedRows Array of row indices.</param>
    <param>selectedColumns Array of column indices.</param>
    <param>destination Arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be used)</param>
    <throws>MatrixDimensionMismatchException if the dimensions of{@code destination} do not match those of {@code this}.</throws>
    <throws>NoDataException if {@code selectedRows} or{@code selectedColumns} is empty</throws>
    <throws>NullArgumentException if {@code selectedRows} or{@code selectedColumns} is {@code null}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
  </javadoc>
  <method name="setSubMatrix" type="void" />
  <javadoc>
    <text>Replace the submatrix starting at {@code (row, column)} using data in the
 * input {@code subMatrix} array. Indexes are 0-based.
 * &lt;p&gt;
 * Example:&lt;br&gt;
 * Starting with
 * &lt;pre&gt;
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * &lt;/pre&gt;
 * and &lt;code&gt;subMatrix = {{3, 4} {5,6}}&lt;/code&gt;, invoking
 * &lt;code&gt;setSubMatrix(subMatrix,1,1))&lt;/code&gt; will result in
 * &lt;pre&gt;
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * &lt;/pre&gt;
 * &lt;/p&gt;</text>
    <param>subMatrix Array containing the submatrix replacement data.</param>
    <param>row Row coordinate of the top-left element to be replaced.</param>
    <param>column Column coordinate of the top-left element to be replaced.</param>
    <throws>OutOfRangeException if {@code subMatrix} does not fit into this
 * matrix from element in {@code (row, column)}.</throws>
    <throws>NoDataException if a row or column of {@code subMatrix} is empty.</throws>
    <throws>DimensionMismatchException if {@code subMatrix} is not
 * rectangular (not all rows have the same length).</throws>
    <throws>NullArgumentException if {@code subMatrix} is {@code null}.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="getRowMatrix" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Get the entries in row number {@code row}as a row matrix.</text>
    <param>row Row to be fetched.</param>
    <return>a row matrix.</return>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
  </javadoc>
  <method name="setRowMatrix" type="void" />
  <javadoc>
    <text>Set the entries in row number {@code row}as a row matrix.</text>
    <param>row Row to be set.</param>
    <param>matrix Row matrix (must have one row and the same number
 * of columns as the instance).</param>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
    <throws>MatrixDimensionMismatchExceptionif the matrix dimensions do not match one instance row.</throws>
  </javadoc>
  <method name="getColumnMatrix" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Get the entries in column number {@code column}as a column matrix.</text>
    <param>column Column to be fetched.</param>
    <return>a column matrix.</return>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
  </javadoc>
  <method name="setColumnMatrix" type="void" />
  <javadoc>
    <text>Set the entries in column number {@code column}as a column matrix.</text>
    <param>column Column to be set.</param>
    <param>matrix column matrix (must have one column and the same
 * number of rows as the instance).</param>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the matrix dimensions do
 * not match one instance column.</throws>
  </javadoc>
  <method name="getRowVector" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Get the entries in row number {@code row}as a vector.</text>
    <param>row Row to be fetched</param>
    <return>a row vector.</return>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
  </javadoc>
  <method name="setRowVector" type="void" />
  <javadoc>
    <text>Set the entries in row number {@code row}as a vector.</text>
    <param>row Row to be set.</param>
    <param>vector row vector (must have the same number of columns
 * as the instance).</param>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the vector dimension does not
 * match one instance row.</throws>
  </javadoc>
  <method name="getColumnVector" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Returns the entries in column number {@code column}as a vector.</text>
    <param>column Column to be fetched.</param>
    <return>a column vector.</return>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
  </javadoc>
  <method name="setColumnVector" type="void" />
  <javadoc>
    <text>Set the entries in column number {@code column}as a vector.</text>
    <param>column Column to be set.</param>
    <param>vector Column vector (must have the same number of rows
 * as the instance).</param>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the vector dimension does not
 * match one instance column.</throws>
  </javadoc>
  <method name="getRow" type="T[]" />
  <javadoc>
    <text>Get the entries in row number {@code row} as an array.</text>
    <param>row Row to be fetched.</param>
    <return>array of entries in the row.</return>
    <throws>OutOfRangeException if the specified row index is not valid.</throws>
  </javadoc>
  <method name="setRow" type="void" />
  <javadoc>
    <text>Set the entries in row number {@code row}as a row matrix.</text>
    <param>row Row to be set.</param>
    <param>array Row matrix (must have the same number of columns as
 * the instance).</param>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the array size does not match
 * one instance row.</throws>
  </javadoc>
  <method name="getColumn" type="T[]" />
  <javadoc>
    <text>Get the entries in column number {@code col} as an array.</text>
    <param>column the column to be fetched</param>
    <return>array of entries in the column</return>
    <throws>OutOfRangeException if the specified column index is not valid.</throws>
  </javadoc>
  <method name="setColumn" type="void" />
  <javadoc>
    <text>Set the entries in column number {@code column}as a column matrix.</text>
    <param>column the column to be set</param>
    <param>array column array (must have the same number of rows as the instance)</param>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the array size does not match
 * one instance column.</throws>
  </javadoc>
  <method name="getEntry" type="T" />
  <javadoc>
    <text>Returns the entry in the specified row and column.</text>
    <param>row  row location of entry to be fetched</param>
    <param>column  column location of entry to be fetched</param>
    <return>matrix entry in row,column</return>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
  </javadoc>
  <method name="setEntry" type="void" />
  <javadoc>
    <text>Set the entry in the specified row and column.</text>
    <param>row  row location of entry to be set</param>
    <param>column  column location of entry to be set</param>
    <param>value matrix entry to be set in row,column</param>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="addToEntry" type="void" />
  <javadoc>
    <text>Change an entry in the specified row and column.</text>
    <param>row Row location of entry to be set.</param>
    <param>column Column location of entry to be set.</param>
    <param>increment Value to add to the current matrix entry in{@code (row, column)}.</param>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="multiplyEntry" type="void" />
  <javadoc>
    <text>Change an entry in the specified row and column.</text>
    <param>row Row location of entry to be set.</param>
    <param>column Column location of entry to be set.</param>
    <param>factor Multiplication factor for the current matrix entry
 * in {@code (row,column)}</param>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="transpose" type="FieldMatrix&lt;T&gt;" />
  <javadoc>
    <text>Returns the transpose of this matrix.</text>
    <return>transpose matrix</return>
  </javadoc>
  <method name="getTrace" type="T" />
  <javadoc>
    <text>Returns the &lt;a href="http://mathworld.wolfram.com/MatrixTrace.html"&gt;
 * trace&lt;/a&gt; of the matrix (the sum of the elements on the main diagonal).</text>
    <return>trace</return>
    <throws>NonSquareMatrixException if the matrix is not square.</throws>
  </javadoc>
  <method name="operate" type="T[]" />
  <javadoc>
    <text>Returns the result of multiplying this by the vector {@code v}.</text>
    <param>v the vector to operate on</param>
    <return>{@code this * v}</return>
    <throws>DimensionMismatchException if the number of columns of{@code this} matrix is not equal to the size of the vector {@code v}.</throws>
  </javadoc>
  <method name="operate" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Returns the result of multiplying this by the vector {@code v}.</text>
    <param>v the vector to operate on</param>
    <return>{@code this * v}</return>
    <throws>DimensionMismatchException if the number of columns of{@code this} matrix is not equal to the size of the vector {@code v}.</throws>
  </javadoc>
  <method name="preMultiply" type="T[]" />
  <javadoc>
    <text>Returns the (row) vector result of premultiplying this by the vector{@code v}.</text>
    <param>v the row vector to premultiply by</param>
    <return>{@code v * this}</return>
    <throws>DimensionMismatchException if the number of rows of {@code this}matrix is not equal to the size of the vector {@code v}</throws>
  </javadoc>
  <method name="preMultiply" type="FieldVector&lt;T&gt;" />
  <javadoc>
    <text>Returns the (row) vector result of premultiplying this by the vector{@code v}.</text>
    <param>v the row vector to premultiply by</param>
    <return>{@code v * this}</return>
    <throws>DimensionMismatchException if the number of rows of {@code this}matrix is not equal to the size of the vector {@code v}</throws>
  </javadoc>
  <method name="walkInRowOrder" type="T" />
  <javadoc>
    <text>Visit (and possibly change) all matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInRowOrder" type="T" />
  <javadoc>
    <text>Visit (but don't change) all matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInRowOrder" type="T" />
  <javadoc>
    <text>Visit (and possibly change) some matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInRowOrder" type="T" />
  <javadoc>
    <text>Visit (but don't change) some matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="T" />
  <javadoc>
    <text>Visit (and possibly change) all matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="T" />
  <javadoc>
    <text>Visit (but don't change) all matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="T" />
  <javadoc>
    <text>Visit (and possibly change) some matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="T" />
  <javadoc>
    <text>Visit (but don't change) some matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="T" />
  <javadoc>
    <text>Visit (and possibly change) all matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="T" />
  <javadoc>
    <text>Visit (but don't change) all matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="T" />
  <javadoc>
    <text>Visit (and possibly change) some matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="T" />
  <javadoc>
    <text>Visit (but don't change) some matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
