<?xml version="1.0" encoding="UTF-8"?>
<class name="Precision">
  <javadoc>
    <text>Utilities for comparing numbers.</text>
    <since>3.0</since>
    <version>$Id: Precision.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * Largest double-precision floating-point number such that{@code 1 + EPSILON} is numerically equal to 1. This value is an upper
 * bound on the relative error due to rounding real numbers to double
 * precision floating-point numbers.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In IEEE 754 arithmetic, this is 2&lt;sup&gt;-53&lt;/sup&gt;.
 * &lt;/p&gt;</text>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Machine_epsilon"&gt;Machine epsilon&lt;/a&gt;</see>
  </javadoc>
  <declaration type="double" name="EPSILON" />
  <javadoc>
    <text>Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.
 * &lt;br/&gt;
 * In IEEE 754 arithmetic, this is also the smallest normalized
 * number 2&lt;sup&gt;-1022&lt;/sup&gt;.</text>
  </javadoc>
  <declaration type="double" name="SAFE_MIN" />
  <javadoc>
    <text>Exponent offset in IEEE754 representation.</text>
  </javadoc>
  <declaration type="long" name="EXPONENT_OFFSET" />
  <javadoc>
    <text>Offset to order signed double numbers lexicographically.</text>
  </javadoc>
  <declaration type="long" name="SGN_MASK" />
  <javadoc>
    <text>Offset to order signed double numbers lexicographically.</text>
  </javadoc>
  <declaration type="int" name="SGN_MASK_FLOAT" />
  <scope />
  <javadoc>
    <text>Private constructor.</text>
  </javadoc>
  <method type="constructor" name="Precision" />
  <javadoc>
    <text>Compares two numbers given some amount of allowed error.</text>
    <param>x the first number</param>
    <param>y the second number</param>
    <param>eps the amount of error to allow when checking for equality</param>
    <return>&lt;ul&gt;&lt;li&gt;0 if  {@link #equals(double,double,double) equals(x, y, eps)}&lt;/li&gt;
 * &lt;li&gt;&amp;lt; 0 if !{@link #equals(double,double,double) equals(x, y, eps)} &amp;amp;&amp;amp; x &amp;lt; y&lt;/li&gt;
 * &lt;li&gt;&gt; 0 if !{@link #equals(double,double,double) equals(x, y, eps)} &amp;amp;&amp;amp; x &gt; y&lt;/li&gt;&lt;/ul&gt;</return>
  </javadoc>
  <method type="int" name="compareTo">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compares two numbers given some amount of allowed error.
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from &lt;a
 * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"&gt;
 * Bruce Dawson&lt;/a&gt;</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
    <return>&lt;ul&gt;&lt;li&gt;0 if  {@link #equals(double,double,int) equals(x, y, maxUlps)}&lt;/li&gt;
 * &lt;li&gt;&amp;lt; 0 if !{@link #equals(double,double,int) equals(x, y, maxUlps)} &amp;amp;&amp;amp; x &amp;lt; y&lt;/li&gt;
 * &lt;li&gt;&gt; 0 if !{@link #equals(double,double,int) equals(x, y, maxUlps)} &amp;amp;&amp;amp; x &gt; y&lt;/li&gt;&lt;/ul&gt;</return>
  </javadoc>
  <method type="int" name="compareTo">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns true iff they are equal as defined by{@link #equals(float,float,int) equals(x, y, 1)}.</text>
    <param>x first value</param>
    <param>y second value</param>
    <return>{@code true} if the values are equal.</return>
  </javadoc>
  <method type="boolean" name="equals" />
  <javadoc>
    <text>Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.</text>
    <param>x first value</param>
    <param>y second value</param>
    <return>{@code true} if the values are equal or both are NaN.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN" />
  <javadoc>
    <text>Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>eps the amount of absolute error to allow.</param>
    <return>{@code true} if the values are equal or within range of each other.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equals" />
  <javadoc>
    <text>Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>eps the amount of absolute error to allow.</param>
    <return>{@code true} if the values are equal or within range of each other,
 * or both are NaN.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN" />
  <javadoc>
    <text>Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from &lt;a
 * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"&gt;
 * Bruce Dawson&lt;/a&gt;</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
    <return>{@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="int" name="xInt" />
    <declaration type="int" name="yInt" />
    <scope />
    <scope />
    <declaration type="boolean" name="isEqual" />
    <comment>Make lexicographically ordered as a two's-complement integer.</comment>
  </method>
  <javadoc>
    <text>Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
    <return>{@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN" />
  <javadoc>
    <text>Returns true iff they are equal as defined by{@link #equals(double,double,int) equals(x, y, 1)}.</text>
    <param>x first value</param>
    <param>y second value</param>
    <return>{@code true} if the values are equal.</return>
  </javadoc>
  <method type="boolean" name="equals" />
  <javadoc>
    <text>Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.</text>
    <param>x first value</param>
    <param>y second value</param>
    <return>{@code true} if the values are equal or both are NaN.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN" />
  <javadoc>
    <text>Returns {@code true} if there is no double value strictly between the
 * arguments or the difference between them is within the range of allowed
 * error (inclusive).</text>
    <param>x First value.</param>
    <param>y Second value.</param>
    <param>eps Amount of allowed absolute error.</param>
    <return>{@code true} if the values are two adjacent floating point
 * numbers or they are within range of each other.</return>
  </javadoc>
  <method type="boolean" name="equals" />
  <javadoc>
    <text>Returns {@code true} if there is no double value strictly between the
 * arguments or the reltaive difference between them is smaller or equal
 * to the given tolerance.</text>
    <param>x First value.</param>
    <param>y Second value.</param>
    <param>eps Amount of allowed relative error.</param>
    <return>{@code true} if the values are two adjacent floating point
 * numbers or they are within range of each other.</return>
    <since>3.1</since>
  </javadoc>
  <method type="boolean" name="equalsWithRelativeTolerance">
    <scope />
    <declaration type="double" name="absoluteMax" />
    <declaration type="double" name="relativeDifference" />
  </method>
  <javadoc>
    <text>Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>eps the amount of absolute error to allow.</param>
    <return>{@code true} if the values are equal or within range of each other,
 * or both are NaN.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN" />
  <javadoc>
    <text>Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from &lt;a
 * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"&gt;
 * Bruce Dawson&lt;/a&gt;</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
    <return>{@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <declaration type="long" name="xInt" />
    <declaration type="long" name="yInt" />
    <scope />
    <scope />
    <declaration type="boolean" name="isEqual" />
    <comment>Make lexicographically ordered as a two's-complement integer.</comment>
  </method>
  <javadoc>
    <text>Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.</text>
    <param>x first value</param>
    <param>y second value</param>
    <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
    <return>{@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN" />
  <javadoc>
    <text>Rounds the given value to the specified number of decimal places.
 * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.</text>
    <param>x Value to round.</param>
    <param>scale Number of digits to the right of the decimal point.</param>
    <return>the rounded value.</return>
    <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
  </javadoc>
  <method type="double" name="round" />
  <javadoc>
    <text>Rounds the given value to the specified number of decimal places.
 * The value is rounded using the given method which is any method defined
 * in {@link BigDecimal}.
 * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is
 * returned unchanged, regardless of the other parameters.</text>
    <param>x Value to round.</param>
    <param>scale Number of digits to the right of the decimal point.</param>
    <param>roundingMethod Rounding method as defined in {@link BigDecimal}.</param>
    <return>the rounded value.</return>
    <throws>ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}and the specified scaling operation would require rounding.</throws>
    <throws>IllegalArgumentException if {@code roundingMethod} does not
 * represent a valid rounding mode.</throws>
    <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
  </javadoc>
  <method type="double" name="round">
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Rounds the given value to the specified number of decimal places.
 * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.</text>
    <param>x Value to round.</param>
    <param>scale Number of digits to the right of the decimal point.</param>
    <return>the rounded value.</return>
    <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
  </javadoc>
  <method type="float" name="round" />
  <javadoc>
    <text>Rounds the given value to the specified number of decimal places.
 * The value is rounded using the given method which is any method defined
 * in {@link BigDecimal}.</text>
    <param>x Value to round.</param>
    <param>scale Number of digits to the right of the decimal point.</param>
    <param>roundingMethod Rounding method as defined in {@link BigDecimal}.</param>
    <return>the rounded value.</return>
    <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
    <throws>MathArithmeticException if an exact operation is required but result is not exact</throws>
    <throws>MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.</throws>
  </javadoc>
  <method type="float" name="round">
    <declaration type="float" name="sign" />
    <declaration type="float" name="factor" />
  </method>
  <javadoc>
    <text>Rounds the given non-negative value to the "nearest" integer. Nearest is
 * determined by the rounding method specified. Rounding methods are defined
 * in {@link BigDecimal}.</text>
    <param>unscaled Value to round.</param>
    <param>sign Sign of the original, scaled value.</param>
    <param>roundingMethod Rounding method, as defined in {@link BigDecimal}.</param>
    <return>the rounded value.</return>
    <throws>MathArithmeticException if an exact operation is required but result is not exact</throws>
    <throws>MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.</throws>
    <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
  </javadoc>
  <method type="double" name="roundUnscaled">
    <scope />
    <scope />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="fraction" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="fraction" />
      <scope />
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="double" name="fraction" />
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>The following equality test is intentional and needed for rounding purposes</comment>
    <comment>even</comment>
    <comment>odd</comment>
  </method>
  <javadoc>
    <text>Computes a number {@code delta} close to {@code originalDelta} with
 * the property that &lt;pre&gt;&lt;code&gt;
 * x + delta - x
 * &lt;/code&gt;&lt;/pre&gt;
 * is exactly machine-representable.
 * This is useful when computing numerical derivatives, in order to reduce
 * roundoff errors.</text>
    <param>x Value.</param>
    <param>originalDelta Offset value.</param>
    <return>a number {@code delta} so that {@code x + delta} and {@code x}differ by a representable floating number.</return>
  </javadoc>
  <method type="double" name="representableDelta" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>This was previously expressed as = 0x1.0p-53;
  However, OpenJDK (Sparc Solaris) cannot handle such small
  constants: MATH-721</comment>
  <comment>This was previously expressed as = 0x1.0p-1022;
 However, OpenJDK (Sparc Solaris) cannot handle such small
 constants: MATH-721</comment>
</class>
