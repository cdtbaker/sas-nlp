<?xml version="1.0" encoding="UTF-8"?>
<class name="SphericalCoordinates">
  <javadoc>
    <text>This class provides conversions related to &lt;a
 * href="http://mathworld.wolfram.com/SphericalCoordinates.html"&gt;spherical coordinates&lt;/a&gt;.
 * &lt;p&gt;
 * The conventions used here are the mathematical ones, i.e. spherical coordinates are
 * related to Cartesian coordinates as follows:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;x = r cos(&amp;theta;) sin(&amp;Phi;)&lt;/li&gt;
 * &lt;li&gt;y = r sin(&amp;theta;) sin(&amp;Phi;)&lt;/li&gt;
 * &lt;li&gt;z = r cos(&amp;Phi;)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;ul&gt;
 * &lt;li&gt;r       = &amp;radic;(x&lt;sup&gt;2&lt;/sup&gt;+y&lt;sup&gt;2&lt;/sup&gt;+z&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
 * &lt;li&gt;&amp;theta; = atan2(y, x)&lt;/li&gt;
 * &lt;li&gt;&amp;Phi;   = acos(z/r)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * r is the radius, &amp;theta; is the azimuthal angle in the x-y plane and &amp;Phi; is the polar
 * (co-latitude) angle. These conventions are &lt;em&gt;different&lt;/em&gt; from the conventions used
 * in physics (and in particular in spherical harmonics) where the meanings of &amp;theta; and
 * &amp;Phi; are reversed.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class provides conversion of coordinates and also of gradient and Hessian
 * between spherical and Cartesian coordinates.
 * &lt;/p&gt;</text>
    <since>3.2</since>
    <version>$Id: SphericalCoordinates.java 1443364 2013-02-07 09:28:04Z luc $</version>
  </javadoc>
  <javadoc>
    <text>Serializable UID.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Cartesian coordinates.</text>
  </javadoc>
  <declaration type="Vector3D" name="v" />
  <javadoc>
    <text>Radius.</text>
  </javadoc>
  <declaration type="double" name="r" />
  <javadoc>
    <text>Azimuthal angle in the x-y plane &amp;theta;.</text>
  </javadoc>
  <declaration type="double" name="theta" />
  <javadoc>
    <text>Polar angle (co-latitude) &amp;Phi;.</text>
  </javadoc>
  <declaration type="double" name="phi" />
  <javadoc>
    <text>Jacobian of (r, &amp;theta; &amp;Phi).</text>
  </javadoc>
  <declaration type="double[][]" name="jacobian" />
  <javadoc>
    <text>Hessian of radius.</text>
  </javadoc>
  <declaration type="double[][]" name="rHessian" />
  <javadoc>
    <text>Hessian of azimuthal angle in the x-y plane &amp;theta;.</text>
  </javadoc>
  <declaration type="double[][]" name="thetaHessian" />
  <javadoc>
    <text>Hessian of polar (co-latitude) angle &amp;Phi;.</text>
  </javadoc>
  <declaration type="double[][]" name="phiHessian" />
  <javadoc>
    <text>Build a spherical coordinates transformer from Cartesian coordinates.</text>
    <param>v Cartesian coordinates</param>
  </javadoc>
  <method type="constructor" name="SphericalCoordinates">
    <comment>Cartesian coordinates</comment>
    <comment>remaining spherical coordinates</comment>
  </method>
  <javadoc>
    <text>Build a spherical coordinates transformer from spherical coordinates.</text>
    <param>r radius</param>
    <param>theta azimuthal angle in x-y plane</param>
    <param>phi polar (co-latitude) angle</param>
  </javadoc>
  <method type="constructor" name="SphericalCoordinates">
    <declaration type="double" name="cosTheta" />
    <declaration type="double" name="sinTheta" />
    <declaration type="double" name="cosPhi" />
    <declaration type="double" name="sinPhi" />
    <comment>spherical coordinates</comment>
    <comment>Cartesian coordinates</comment>
  </method>
  <javadoc>
    <text>Get the Cartesian coordinates.</text>
    <return>Cartesian coordinates</return>
  </javadoc>
  <method type="Vector3D" name="getCartesian" />
  <javadoc>
    <text>Get the radius.</text>
    <return>radius r</return>
    <see>#getTheta()</see>
    <see>#getPhi()</see>
  </javadoc>
  <method type="double" name="getR" />
  <javadoc>
    <text>Get the azimuthal angle in x-y plane.</text>
    <return>azimuthal angle in x-y plane &amp;theta;</return>
    <see>#getR()</see>
    <see>#getPhi()</see>
  </javadoc>
  <method type="double" name="getTheta" />
  <javadoc>
    <text>Get the polar (co-latitude) angle.</text>
    <return>polar (co-latitude) angle &amp;Phi;</return>
    <see>#getR()</see>
    <see>#getTheta()</see>
  </javadoc>
  <method type="double" name="getPhi" />
  <javadoc>
    <text>Convert a gradient with respect to spherical coordinates into a gradient
 * with respect to Cartesian coordinates.</text>
    <param>sGradient gradient with respect to spherical coordinates
 * {df/dr, df/d&amp;theta;, df/d&amp;Phi;}</param>
    <return>gradient with respect to Cartesian coordinates
 * {df/dx, df/dy, df/dz}</return>
  </javadoc>
  <method type="double[]" name="toCartesianGradient">
    <comment>lazy evaluation of Jacobian</comment>
    <comment>compose derivatives as gradient^T . J</comment>
    <comment>the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0</comment>
  </method>
  <javadoc>
    <text>Convert a Hessian with respect to spherical coordinates into a Hessian
 * with respect to Cartesian coordinates.
 * &lt;p&gt;
 * As Hessian are always symmetric, we use only the lower left part of the provided
 * spherical Hessian, so the upper part may not be initialized. However, we still
 * do fill up the complete array we create, with guaranteed symmetry.
 * &lt;/p&gt;</text>
    <param>sHessian Hessian with respect to spherical coordinates
 * {{d&lt;sup&gt;2&lt;/sup&gt;f/dr&lt;sup&gt;2&lt;/sup&gt;, d&lt;sup&gt;2&lt;/sup&gt;f/drd&amp;theta;, d&lt;sup&gt;2&lt;/sup&gt;f/drd&amp;Phi;},
 * {d&lt;sup&gt;2&lt;/sup&gt;f/drd&amp;theta;, d&lt;sup&gt;2&lt;/sup&gt;f/d&amp;theta;&lt;sup&gt;2&lt;/sup&gt;, d&lt;sup&gt;2&lt;/sup&gt;f/d&amp;theta;d&amp;Phi;},
 * {d&lt;sup&gt;2&lt;/sup&gt;f/drd&amp;Phi;, d&lt;sup&gt;2&lt;/sup&gt;f/d&amp;theta;d&amp;Phi;, d&lt;sup&gt;2&lt;/sup&gt;f/d&amp;Phi;&lt;sup&gt;2&lt;/sup&gt;}</param>
    <param>sGradient gradient with respect to spherical coordinates
 * {df/dr, df/d&amp;theta;, df/d&amp;Phi;}</param>
    <return>Hessian with respect to Cartesian coordinates
 * {{d&lt;sup&gt;2&lt;/sup&gt;f/dx&lt;sup&gt;2&lt;/sup&gt;, d&lt;sup&gt;2&lt;/sup&gt;f/dxdy, d&lt;sup&gt;2&lt;/sup&gt;f/dxdz},
 * {d&lt;sup&gt;2&lt;/sup&gt;f/dxdy, d&lt;sup&gt;2&lt;/sup&gt;f/dy&lt;sup&gt;2&lt;/sup&gt;, d&lt;sup&gt;2&lt;/sup&gt;f/dydz},
 * {d&lt;sup&gt;2&lt;/sup&gt;f/dxdz, d&lt;sup&gt;2&lt;/sup&gt;f/dydz, d&lt;sup&gt;2&lt;/sup&gt;f/dz&lt;sup&gt;2&lt;/sup&gt;}}</return>
  </javadoc>
  <method type="double[][]" name="toCartesianHessian">
    <declaration type="double[][]" name="hj" />
    <declaration type="double[][]" name="cHessian" />
    <comment>compose derivative as J^T . H_f . J + df/dr H_r + df/dtheta H_theta + df/dphi H_phi</comment>
    <comment>the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0</comment>
    <comment>and H_theta is only a 2x2 matrix as it does not depend on z</comment>
    <comment>compute H_f . J</comment>
    <comment>beware we use ONLY the lower-left part of sHessian</comment>
    <comment>don't compute hj[1][2] as it is not used below</comment>
    <comment>compute lower-left part of J^T . H_f . J</comment>
    <comment>add gradient contribution</comment>
    <comment>ensure symmetry</comment>
  </method>
  <javadoc>
    <text>Lazy evaluation of (r, &amp;theta;, &amp;phi;) Jacobian.</text>
  </javadoc>
  <method type="void" name="computeJacobian">
    <scope>
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="double" name="rho2" />
      <declaration type="double" name="rho" />
      <declaration type="double" name="r2" />
    </scope>
    <comment>intermediate variables</comment>
    <comment>row representing the gradient of r</comment>
    <comment>row representing the gradient of theta</comment>
    <comment>jacobian[1][2] is already set to 0 at allocation time</comment>
    <comment>row representing the gradient of phi</comment>
  </method>
  <javadoc>
    <text>Lazy evaluation of Hessians.</text>
  </javadoc>
  <method type="void" name="computeHessians">
    <scope>
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="y2" />
      <declaration type="double" name="z2" />
      <declaration type="double" name="rho2" />
      <declaration type="double" name="rho" />
      <declaration type="double" name="r2" />
      <declaration type="double" name="xOr" />
      <declaration type="double" name="yOr" />
      <declaration type="double" name="zOr" />
      <declaration type="double" name="xOrho2" />
      <declaration type="double" name="yOrho2" />
      <declaration type="double" name="xOr3" />
      <declaration type="double" name="yOr3" />
      <declaration type="double" name="zOr3" />
      <declaration type="double" name="rhor2" />
      <declaration type="double" name="rho2r2" />
      <declaration type="double" name="rhor4" />
      <declaration type="double" name="rho3r4" />
      <declaration type="double" name="r2P2rho2" />
    </scope>
    <comment>intermediate variables</comment>
    <comment>lower-left part of Hessian of r</comment>
    <comment>upper-right part is symmetric</comment>
    <comment>lower-left part of Hessian of azimuthal angle theta</comment>
    <comment>upper-right part is symmetric</comment>
    <comment>lower-left part of Hessian of polar (co-latitude) angle phi</comment>
    <comment>upper-right part is symmetric</comment>
  </method>
  <javadoc>
    <text>Replace the instance with a data transfer object for serialization.</text>
    <return>data transfer object that will be serialized</return>
  </javadoc>
  <method type="Object" name="writeReplace" />
  <javadoc>
    <text>Internal class used only for serialization.</text>
  </javadoc>
  <javadoc>
    <text>Serializable UID.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Abscissa.</text>
    <serial />
  </javadoc>
  <declaration type="double" name="x" />
  <javadoc>
    <text>Ordinate.</text>
    <serial />
  </javadoc>
  <declaration type="double" name="y" />
  <javadoc>
    <text>Height.</text>
    <serial />
  </javadoc>
  <declaration type="double" name="z" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>x abscissa</param>
    <param>y ordinate</param>
    <param>z height</param>
  </javadoc>
  <method type="constructor" name="DataTransferObject" />
  <javadoc>
    <text>Replace the deserialized data transfer object with a {@link SphericalCoordinates}.</text>
    <return>replacement {@link SphericalCoordinates}</return>
  </javadoc>
  <method type="Object" name="readResolve" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
