<?xml version="1.0" encoding="UTF-8"?>
<class name="SimplexOptimizer">
  <javadoc>
    <text>This class implements simplex-based direct search optimization.
 * &lt;p&gt;
 * Direct search methods only use objective function values, they do
 * not need derivatives and don't either try to compute approximation
 * of the derivatives. According to a 1996 paper by Margaret H. Wright
 * (&lt;a href="http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz"&gt;Direct
 * Search Methods: Once Scorned, Now Respectable&lt;/a&gt;), they are used
 * when either the computation of the derivative is impossible (noisy
 * functions, unpredictable discontinuities) or difficult (complexity,
 * computation cost). In the first cases, rather than an optimum, a
 * &lt;em&gt;not too bad&lt;/em&gt; point is desired. In the latter cases, an
 * optimum is desired but cannot be reasonably found. In all cases
 * direct search methods can be useful.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Simplex-based direct search methods are based on comparison of
 * the objective function values at the vertices of a simplex (which is a
 * set of n+1 points in dimension n) that is updated by the algorithms
 * steps.
 * &lt;p&gt;
 * &lt;p&gt;
 * The simplex update procedure ({@link NelderMeadSimplex} or{@link MultiDirectionalSimplex})  must be passed to the{@code optimize} method.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Each call to {@code optimize} will re-use the start configuration of
 * the current simplex and move it such that its first vertex is at the
 * provided start point of the optimization.
 * If the {@code optimize} method is called to solve a different problem
 * and the number of parameters change, the simplex must be re-initialized
 * to one with the appropriate dimensions.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Convergence is checked by providing the &lt;em&gt;worst&lt;/em&gt; points of
 * previous and current simplex to the convergence checker, not the best
 * ones.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This simplex optimizer implementation does not directly support constrained
 * optimization with simple bounds; so, for such optimizations, either a more
 * dedicated algorithm must be used like{@link CMAESOptimizer} or {@link BOBYQAOptimizer}, or the objective
 * function must be wrapped in an adapter like{@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionMappingAdapterMultivariateFunctionMappingAdapter} or{@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapterMultivariateFunctionPenaltyAdapter}.
 * &lt;br/&gt;
 * The call to {@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.
 * &lt;/p&gt;</text>
    <version>$Id: SimplexOptimizer.java 1458323 2013-03-19 14:51:30Z erans $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Simplex update rule.</text>
  </javadoc>
  <declaration type="AbstractSimplex" name="simplex" />
  <javadoc>
    <param>checker Convergence checker.</param>
  </javadoc>
  <method type="constructor" name="SimplexOptimizer" />
  <javadoc>
    <param>rel Relative threshold.</param>
    <param>abs Absolute threshold.</param>
  </javadoc>
  <method type="constructor" name="SimplexOptimizer" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>optData Optimization data. In addition to those documented in{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])MultivariateOptimizer}, this method will register the following data:
 * &lt;ul&gt;
 * &lt;li&gt;{@link AbstractSimplex}&lt;/li&gt;
 * &lt;/ul&gt;</param>
    <return>{@inheritDoc}</return>
  </javadoc>
  <method type="PointValuePair" name="optimize">
    <comment>Set up base class and perform computation.</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PointValuePair" name="doOptimize">
    <declaration type="MultivariateFunction[]" name="evalFunc" />
    <method type="double" name="value" />
    <declaration type="boolean" name="isMinim" />
    <declaration type="Comparator&lt;PointValuePair&gt;" name="comparator" />
    <method type="int" name="compare">
      <declaration type="double" name="v1" />
      <declaration type="double" name="v2" />
    </method>
    <declaration type="PointValuePair[]" name="previous" />
    <declaration type="int" name="iteration" />
    <declaration type="ConvergenceChecker&lt;PointValuePair&gt;" name="checker" />
    <scope>
      <scope>
        <declaration type="boolean" name="converged" />
        <scope>
          <declaration type="PointValuePair" name="prev" />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>Indirect call to "computeObjectiveValue" in order to update the</comment>
    <comment>evaluations counter.</comment>
    <comment>Initialize search.</comment>
    <comment>We have found an optimum.</comment>
    <comment>We still need to search.</comment>
  </method>
  <javadoc>
    <text>Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
    <param>optData Optimization data.
 * The following data will be looked for:
 * &lt;ul&gt;
 * &lt;li&gt;{@link AbstractSimplex}&lt;/li&gt;
 * &lt;/ul&gt;</param>
  </javadoc>
  <method type="void" name="parseOptimizationData">
    <scope>
      <scope />
    </scope>
    <comment>Allow base class to register its own data.</comment>
    <comment>The existing values (as set by the previous call) are reused if</comment>
    <comment>not provided in the argument list.</comment>
    <comment>If more data must be parsed, this statement _must_ be</comment>
    <comment>changed to "continue".</comment>
  </method>
  <javadoc>
    <throws>MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.</throws>
    <throws>NullArgumentException if no initial simplex was passed to the{@link #optimize(OptimizationData[]) optimize} method.</throws>
  </javadoc>
  <method type="void" name="checkParameters">
    <scope />
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
