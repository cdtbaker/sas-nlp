<?xml version="1.0" encoding="UTF-8"?>
<class name="RegionFactory">
  <javadoc>
    <text>This class is a factory for {@link Region}.</text>
    <param>&lt;S&gt;
 *  Type of the space.</param>
    <version>$Id: RegionFactory.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Visitor removing internal nodes attributes.</text>
  </javadoc>
  <declaration type="NodesCleaner" name="nodeCleaner" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="RegionFactory" />
  <javadoc>
    <text>Build a convex region from a collection of bounding hyperplanes.</text>
    <param>hyperplanes collection of bounding hyperplanes</param>
    <return>a new convex region, or null if the collection is empty</return>
  </javadoc>
  <method type="Region&lt;S&gt;" name="buildConvex">
    <scope />
    <declaration type="Region&lt;S&gt;" name="region" />
    <declaration type="BSPTree&lt;S&gt;" name="node" />
    <scope>
      <scope />
    </scope>
    <comment>use the first hyperplane to build the right class</comment>
    <comment>chop off parts of the space</comment>
  </method>
  <javadoc>
    <text>Compute the union of two regions.</text>
    <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <return>a new region, result of {@code region1 union region2}</return>
  </javadoc>
  <method type="Region&lt;S&gt;" name="union">
    <declaration type="BSPTree&lt;S&gt;" name="tree" />
  </method>
  <javadoc>
    <text>Compute the intersection of two regions.</text>
    <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <return>a new region, result of {@code region1 intersection region2}</return>
  </javadoc>
  <method type="Region&lt;S&gt;" name="intersection">
    <declaration type="BSPTree&lt;S&gt;" name="tree" />
  </method>
  <javadoc>
    <text>Compute the symmetric difference (exclusive or) of two regions.</text>
    <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <return>a new region, result of {@code region1 xor region2}</return>
  </javadoc>
  <method type="Region&lt;S&gt;" name="xor">
    <declaration type="BSPTree&lt;S&gt;" name="tree" />
  </method>
  <javadoc>
    <text>Compute the difference of two regions.</text>
    <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
    <return>a new region, result of {@code region1 minus region2}</return>
  </javadoc>
  <method type="Region&lt;S&gt;" name="difference">
    <declaration type="BSPTree&lt;S&gt;" name="tree" />
  </method>
  <javadoc>
    <text>Get the complement of the region (exchanged interior/exterior).</text>
    <param>region region to complement, it will not modified, a new
 * region independent region will be built</param>
    <return>a new region, complement of the specified one</return>
  </javadoc>
  <method type="Region&lt;S&gt;" name="getComplement" />
  <javadoc>
    <text>Recursively build the complement of a BSP tree.</text>
    <param>node current node of the original tree</param>
    <return>new tree, complement of the node</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="recurseComplement">
    <scope />
    <declaration type="BoundaryAttribute&lt;S&gt;" name="attribute" />
    <scope>
      <declaration type="SubHyperplane&lt;S&gt;" name="plusOutside" />
      <declaration type="SubHyperplane&lt;S&gt;" name="plusInside" />
    </scope>
  </method>
  <javadoc>
    <text>BSP tree leaf merger computing union of two regions.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="merge">
    <scope />
    <comment>the leaf node represents an inside cell</comment>
    <comment>the leaf node represents an outside cell</comment>
  </method>
  <javadoc>
    <text>BSP tree leaf merger computing union of two regions.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="merge">
    <scope />
    <comment>the leaf node represents an inside cell</comment>
    <comment>the leaf node represents an outside cell</comment>
  </method>
  <javadoc>
    <text>BSP tree leaf merger computing union of two regions.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="merge">
    <declaration type="BSPTree&lt;S&gt;" name="t" />
    <scope />
    <comment>the leaf node represents an inside cell</comment>
  </method>
  <javadoc>
    <text>BSP tree leaf merger computing union of two regions.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="merge">
    <scope>
      <declaration type="BSPTree&lt;S&gt;" name="argTree" />
    </scope>
    <declaration type="BSPTree&lt;S&gt;" name="instanceTree" />
    <comment>the leaf node represents an inside cell</comment>
    <comment>the leaf node represents an outside cell</comment>
  </method>
  <javadoc>
    <text>Visitor removing internal nodes attributes.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Order" name="visitOrder" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitInternalNode" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitLeafNode" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
