<?xml version="1.0" encoding="UTF-8"?>
<class name="DfpField">
  <javadoc>
    <text>Field for Decimal floating point instances.</text>
    <version>$Id: DfpField.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>2.2</since>
  </javadoc>
  <javadoc>
    <text>Enumerate for rounding modes.</text>
  </javadoc>
  <javadoc>
    <text>Rounds toward zero (truncation).</text>
  </javadoc>
  <javadoc>
    <text>Rounds away from zero if discarded digit is non-zero.</text>
  </javadoc>
  <javadoc>
    <text>Rounds towards nearest unless both are equidistant in which case it rounds away from zero.</text>
  </javadoc>
  <javadoc>
    <text>Rounds towards nearest unless both are equidistant in which case it rounds toward zero.</text>
  </javadoc>
  <javadoc>
    <text>Rounds towards nearest unless both are equidistant in which case it rounds toward the even neighbor.
 * This is the default as  specified by IEEE 854-1987</text>
  </javadoc>
  <javadoc>
    <text>Rounds towards nearest unless both are equidistant in which case it rounds toward the odd neighbor.</text>
  </javadoc>
  <javadoc>
    <text>Rounds towards positive infinity.</text>
  </javadoc>
  <javadoc>
    <text>Rounds towards negative infinity.</text>
  </javadoc>
  <javadoc>
    <text>IEEE 854-1987 flag for invalid operation.</text>
  </javadoc>
  <declaration type="int" name="FLAG_INVALID" />
  <javadoc>
    <text>IEEE 854-1987 flag for division by zero.</text>
  </javadoc>
  <declaration type="int" name="FLAG_DIV_ZERO" />
  <javadoc>
    <text>IEEE 854-1987 flag for overflow.</text>
  </javadoc>
  <declaration type="int" name="FLAG_OVERFLOW" />
  <javadoc>
    <text>IEEE 854-1987 flag for underflow.</text>
  </javadoc>
  <declaration type="int" name="FLAG_UNDERFLOW" />
  <javadoc>
    <text>IEEE 854-1987 flag for inexact result.</text>
  </javadoc>
  <declaration type="int" name="FLAG_INEXACT" />
  <javadoc>
    <text>High precision string representation of &amp;radic;2.</text>
  </javadoc>
  <declaration type="String" name="sqr2String" />
  <javadoc>
    <text>High precision string representation of &amp;radic;2 / 2.</text>
  </javadoc>
  <declaration type="String" name="sqr2ReciprocalString" />
  <javadoc>
    <text>High precision string representation of &amp;radic;3.</text>
  </javadoc>
  <declaration type="String" name="sqr3String" />
  <javadoc>
    <text>High precision string representation of &amp;radic;3 / 3.</text>
  </javadoc>
  <declaration type="String" name="sqr3ReciprocalString" />
  <javadoc>
    <text>High precision string representation of &amp;pi;.</text>
  </javadoc>
  <declaration type="String" name="piString" />
  <javadoc>
    <text>High precision string representation of e.</text>
  </javadoc>
  <declaration type="String" name="eString" />
  <javadoc>
    <text>High precision string representation of ln(2).</text>
  </javadoc>
  <declaration type="String" name="ln2String" />
  <javadoc>
    <text>High precision string representation of ln(5).</text>
  </javadoc>
  <declaration type="String" name="ln5String" />
  <javadoc>
    <text>High precision string representation of ln(10).</text>
  </javadoc>
  <declaration type="String" name="ln10String" />
  <javadoc>
    <text>The number of radix digits.
 * Note these depend on the radix which is 10000 digits,
 * so each one is equivalent to 4 decimal digits.</text>
  </javadoc>
  <declaration type="int" name="radixDigits" />
  <javadoc>
    <text>A {@link Dfp} with value 0.</text>
  </javadoc>
  <declaration type="Dfp" name="zero" />
  <javadoc>
    <text>A {@link Dfp} with value 1.</text>
  </javadoc>
  <declaration type="Dfp" name="one" />
  <javadoc>
    <text>A {@link Dfp} with value 2.</text>
  </javadoc>
  <declaration type="Dfp" name="two" />
  <javadoc>
    <text>A {@link Dfp} with value &amp;radic;2.</text>
  </javadoc>
  <declaration type="Dfp" name="sqr2" />
  <javadoc>
    <text>A two elements {@link Dfp} array with value &amp;radic;2 split in two pieces.</text>
  </javadoc>
  <declaration type="Dfp[]" name="sqr2Split" />
  <javadoc>
    <text>A {@link Dfp} with value &amp;radic;2 / 2.</text>
  </javadoc>
  <declaration type="Dfp" name="sqr2Reciprocal" />
  <javadoc>
    <text>A {@link Dfp} with value &amp;radic;3.</text>
  </javadoc>
  <declaration type="Dfp" name="sqr3" />
  <javadoc>
    <text>A {@link Dfp} with value &amp;radic;3 / 3.</text>
  </javadoc>
  <declaration type="Dfp" name="sqr3Reciprocal" />
  <javadoc>
    <text>A {@link Dfp} with value &amp;pi;.</text>
  </javadoc>
  <declaration type="Dfp" name="pi" />
  <javadoc>
    <text>A two elements {@link Dfp} array with value &amp;pi; split in two pieces.</text>
  </javadoc>
  <declaration type="Dfp[]" name="piSplit" />
  <javadoc>
    <text>A {@link Dfp} with value e.</text>
  </javadoc>
  <declaration type="Dfp" name="e" />
  <javadoc>
    <text>A two elements {@link Dfp} array with value e split in two pieces.</text>
  </javadoc>
  <declaration type="Dfp[]" name="eSplit" />
  <javadoc>
    <text>A {@link Dfp} with value ln(2).</text>
  </javadoc>
  <declaration type="Dfp" name="ln2" />
  <javadoc>
    <text>A two elements {@link Dfp} array with value ln(2) split in two pieces.</text>
  </javadoc>
  <declaration type="Dfp[]" name="ln2Split" />
  <javadoc>
    <text>A {@link Dfp} with value ln(5).</text>
  </javadoc>
  <declaration type="Dfp" name="ln5" />
  <javadoc>
    <text>A two elements {@link Dfp} array with value ln(5) split in two pieces.</text>
  </javadoc>
  <declaration type="Dfp[]" name="ln5Split" />
  <javadoc>
    <text>A {@link Dfp} with value ln(10).</text>
  </javadoc>
  <declaration type="Dfp" name="ln10" />
  <javadoc>
    <text>Current rounding mode.</text>
  </javadoc>
  <declaration type="RoundingMode" name="rMode" />
  <javadoc>
    <text>IEEE 854-1987 signals.</text>
  </javadoc>
  <declaration type="int" name="ieeeFlags" />
  <javadoc>
    <text>Create a factory for the specified number of radix digits.
 * &lt;p&gt;
 * Note that since the {@link Dfp} class uses 10000 as its radix, each radix
 * digit is equivalent to 4 decimal digits. This implies that asking for
 * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
 * all cases.
 * &lt;/p&gt;</text>
    <param>decimalDigits minimal number of decimal digits.</param>
  </javadoc>
  <method type="constructor" name="DfpField" />
  <javadoc>
    <text>Create a factory for the specified number of radix digits.
 * &lt;p&gt;
 * Note that since the {@link Dfp} class uses 10000 as its radix, each radix
 * digit is equivalent to 4 decimal digits. This implies that asking for
 * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
 * all cases.
 * &lt;/p&gt;</text>
    <param>decimalDigits minimal number of decimal digits</param>
    <param>computeConstants if true, the transcendental constants for the given precision
 * must be computed (setting this flag to false is RESERVED for the internal recursive call)</param>
  </javadoc>
  <method type="constructor" name="DfpField">
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>set up transcendental constants</comment>
    <comment>as a heuristic to circumvent Table-Maker's Dilemma, we set the string</comment>
    <comment>representation of the constants to be at least 3 times larger than the</comment>
    <comment>number of decimal digits, also as an attempt to really compute these</comment>
    <comment>constants only once, we set a minimum number of digits</comment>
    <comment>set up the constants at current field accuracy</comment>
    <comment>dummy settings for unused constants</comment>
  </method>
  <javadoc>
    <text>Get the number of radix digits of the {@link Dfp} instances built by this factory.</text>
    <return>number of radix digits</return>
  </javadoc>
  <method type="int" name="getRadixDigits" />
  <javadoc>
    <text>Set the rounding mode.
 * If not set, the default value is {@link RoundingMode#ROUND_HALF_EVEN}.</text>
    <param>mode desired rounding mode
 * Note that the rounding mode is common to all {@link Dfp} instances
 * belonging to the current {@link DfpField} in the system and will
 * affect all future calculations.</param>
  </javadoc>
  <method type="void" name="setRoundingMode" />
  <javadoc>
    <text>Get the current rounding mode.</text>
    <return>current rounding mode</return>
  </javadoc>
  <method type="RoundingMode" name="getRoundingMode" />
  <javadoc>
    <text>Get the IEEE 854 status flags.</text>
    <return>IEEE 854 status flags</return>
    <see>#clearIEEEFlags()</see>
    <see>#setIEEEFlags(int)</see>
    <see>#setIEEEFlagsBits(int)</see>
    <see>#FLAG_INVALID</see>
    <see>#FLAG_DIV_ZERO</see>
    <see>#FLAG_OVERFLOW</see>
    <see>#FLAG_UNDERFLOW</see>
    <see>#FLAG_INEXACT</see>
  </javadoc>
  <method type="int" name="getIEEEFlags" />
  <javadoc>
    <text>Clears the IEEE 854 status flags.</text>
    <see>#getIEEEFlags()</see>
    <see>#setIEEEFlags(int)</see>
    <see>#setIEEEFlagsBits(int)</see>
    <see>#FLAG_INVALID</see>
    <see>#FLAG_DIV_ZERO</see>
    <see>#FLAG_OVERFLOW</see>
    <see>#FLAG_UNDERFLOW</see>
    <see>#FLAG_INEXACT</see>
  </javadoc>
  <method type="void" name="clearIEEEFlags" />
  <javadoc>
    <text>Sets the IEEE 854 status flags.</text>
    <param>flags desired value for the flags</param>
    <see>#getIEEEFlags()</see>
    <see>#clearIEEEFlags()</see>
    <see>#setIEEEFlagsBits(int)</see>
    <see>#FLAG_INVALID</see>
    <see>#FLAG_DIV_ZERO</see>
    <see>#FLAG_OVERFLOW</see>
    <see>#FLAG_UNDERFLOW</see>
    <see>#FLAG_INEXACT</see>
  </javadoc>
  <method type="void" name="setIEEEFlags" />
  <javadoc>
    <text>Sets some bits in the IEEE 854 status flags, without changing the already set bits.
 * &lt;p&gt;
 * Calling this method is equivalent to call {@code setIEEEFlags(getIEEEFlags() | bits)}&lt;/p&gt;</text>
    <param>bits bits to set</param>
    <see>#getIEEEFlags()</see>
    <see>#clearIEEEFlags()</see>
    <see>#setIEEEFlags(int)</see>
    <see>#FLAG_INVALID</see>
    <see>#FLAG_DIV_ZERO</see>
    <see>#FLAG_OVERFLOW</see>
    <see>#FLAG_UNDERFLOW</see>
    <see>#FLAG_INEXACT</see>
  </javadoc>
  <method type="void" name="setIEEEFlagsBits" />
  <javadoc>
    <text>Makes a {@link Dfp} with a value of 0.</text>
    <return>a new {@link Dfp} with a value of 0</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Create an instance from a byte value.</text>
    <param>x value to convert to an instance</param>
    <return>a new {@link Dfp} with the same value as x</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Create an instance from an int value.</text>
    <param>x value to convert to an instance</param>
    <return>a new {@link Dfp} with the same value as x</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Create an instance from a long value.</text>
    <param>x value to convert to an instance</param>
    <return>a new {@link Dfp} with the same value as x</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Create an instance from a double value.</text>
    <param>x value to convert to an instance</param>
    <return>a new {@link Dfp} with the same value as x</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Copy constructor.</text>
    <param>d instance to copy</param>
    <return>a new {@link Dfp} with the same value as d</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Create a {@link Dfp} given a String representation.</text>
    <param>s string representation of the instance</param>
    <return>a new {@link Dfp} parsed from specified string</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Creates a {@link Dfp} with a non-finite value.</text>
    <param>sign sign of the Dfp to create</param>
    <param>nans code of the value, must be one of {@link Dfp#INFINITE},{@link Dfp#SNAN},  {@link Dfp#QNAN}</param>
    <return>a new {@link Dfp} with a non-finite value</return>
  </javadoc>
  <method type="Dfp" name="newDfp" />
  <javadoc>
    <text>Get the constant 0.</text>
    <return>a {@link Dfp} with value 0</return>
  </javadoc>
  <method type="Dfp" name="getZero" />
  <javadoc>
    <text>Get the constant 1.</text>
    <return>a {@link Dfp} with value 1</return>
  </javadoc>
  <method type="Dfp" name="getOne" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Class&lt;? extends FieldElement&lt;Dfp&gt;&gt;" name="getRuntimeClass" />
  <javadoc>
    <text>Get the constant 2.</text>
    <return>a {@link Dfp} with value 2</return>
  </javadoc>
  <method type="Dfp" name="getTwo" />
  <javadoc>
    <text>Get the constant &amp;radic;2.</text>
    <return>a {@link Dfp} with value &amp;radic;2</return>
  </javadoc>
  <method type="Dfp" name="getSqr2" />
  <javadoc>
    <text>Get the constant &amp;radic;2 split in two pieces.</text>
    <return>a {@link Dfp} with value &amp;radic;2 split in two pieces</return>
  </javadoc>
  <method type="Dfp[]" name="getSqr2Split" />
  <javadoc>
    <text>Get the constant &amp;radic;2 / 2.</text>
    <return>a {@link Dfp} with value &amp;radic;2 / 2</return>
  </javadoc>
  <method type="Dfp" name="getSqr2Reciprocal" />
  <javadoc>
    <text>Get the constant &amp;radic;3.</text>
    <return>a {@link Dfp} with value &amp;radic;3</return>
  </javadoc>
  <method type="Dfp" name="getSqr3" />
  <javadoc>
    <text>Get the constant &amp;radic;3 / 3.</text>
    <return>a {@link Dfp} with value &amp;radic;3 / 3</return>
  </javadoc>
  <method type="Dfp" name="getSqr3Reciprocal" />
  <javadoc>
    <text>Get the constant &amp;pi;.</text>
    <return>a {@link Dfp} with value &amp;pi;</return>
  </javadoc>
  <method type="Dfp" name="getPi" />
  <javadoc>
    <text>Get the constant &amp;pi; split in two pieces.</text>
    <return>a {@link Dfp} with value &amp;pi; split in two pieces</return>
  </javadoc>
  <method type="Dfp[]" name="getPiSplit" />
  <javadoc>
    <text>Get the constant e.</text>
    <return>a {@link Dfp} with value e</return>
  </javadoc>
  <method type="Dfp" name="getE" />
  <javadoc>
    <text>Get the constant e split in two pieces.</text>
    <return>a {@link Dfp} with value e split in two pieces</return>
  </javadoc>
  <method type="Dfp[]" name="getESplit" />
  <javadoc>
    <text>Get the constant ln(2).</text>
    <return>a {@link Dfp} with value ln(2)</return>
  </javadoc>
  <method type="Dfp" name="getLn2" />
  <javadoc>
    <text>Get the constant ln(2) split in two pieces.</text>
    <return>a {@link Dfp} with value ln(2) split in two pieces</return>
  </javadoc>
  <method type="Dfp[]" name="getLn2Split" />
  <javadoc>
    <text>Get the constant ln(5).</text>
    <return>a {@link Dfp} with value ln(5)</return>
  </javadoc>
  <method type="Dfp" name="getLn5" />
  <javadoc>
    <text>Get the constant ln(5) split in two pieces.</text>
    <return>a {@link Dfp} with value ln(5) split in two pieces</return>
  </javadoc>
  <method type="Dfp[]" name="getLn5Split" />
  <javadoc>
    <text>Get the constant ln(10).</text>
    <return>a {@link Dfp} with value ln(10)</return>
  </javadoc>
  <method type="Dfp" name="getLn10" />
  <javadoc>
    <text>Breaks a string representation up into two {@link Dfp}'s.
 * The split is such that the sum of them is equivalent to the input string,
 * but has higher precision than using a single Dfp.</text>
    <param>a string representation of the number to split</param>
    <return>an array of two {@link Dfp Dfp} instances which sum equals a</return>
  </javadoc>
  <method type="Dfp[]" name="split">
    <declaration type="Dfp[]" name="result" />
    <declaration type="boolean" name="leading" />
    <declaration type="int" name="sp" />
    <declaration type="int" name="sig" />
    <declaration type="char[]" name="buf" />
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Recompute the high precision string constants.</text>
    <param>highPrecisionDecimalDigits precision at which the string constants mus be computed</param>
  </javadoc>
  <method type="void" name="computeStringConstants">
    <scope>
      <declaration type="DfpField" name="highPrecisionField" />
      <declaration type="Dfp" name="highPrecisionOne" />
      <declaration type="Dfp" name="highPrecisionTwo" />
      <declaration type="Dfp" name="highPrecisionThree" />
      <declaration type="Dfp" name="highPrecisionSqr2" />
      <declaration type="Dfp" name="highPrecisionSqr3" />
    </scope>
    <comment>recompute the string representation of the transcendental constants</comment>
  </method>
  <javadoc>
    <text>Compute &amp;pi; using Jonathan and Peter Borwein quartic formula.</text>
    <param>one constant with value 1 at desired precision</param>
    <param>two constant with value 2 at desired precision</param>
    <param>three constant with value 3 at desired precision</param>
    <return>&amp;pi;</return>
  </javadoc>
  <method type="Dfp" name="computePi">
    <declaration type="Dfp" name="sqrt2" />
    <declaration type="Dfp" name="yk" />
    <declaration type="Dfp" name="four" />
    <declaration type="Dfp" name="two2kp3" />
    <declaration type="Dfp" name="ak" />
    <scope>
      <declaration type="Dfp" name="ykM1" />
      <declaration type="Dfp" name="y2" />
      <declaration type="Dfp" name="oneMinusY4" />
      <declaration type="Dfp" name="s" />
      <declaration type="Dfp" name="p" />
      <declaration type="Dfp" name="p2" />
      <scope />
    </scope>
    <comment>The formula converges quartically. This means the number of correct</comment>
    <comment>digits is multiplied by 4 at each iteration! Five iterations are</comment>
    <comment>sufficient for about 160 digits, eight iterations give about</comment>
    <comment>10000 digits (this has been checked) and 20 iterations more than</comment>
    <comment>160 billions of digits (this has NOT been checked).</comment>
    <comment>So the limit here is considered sufficient for most purposes ...</comment>
  </method>
  <javadoc>
    <text>Compute exp(a).</text>
    <param>a number for which we want the exponential</param>
    <param>one constant with value 1 at desired precision</param>
    <return>exp(a)</return>
  </javadoc>
  <method type="Dfp" name="computeExp">
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="py" />
    <declaration type="Dfp" name="f" />
    <declaration type="Dfp" name="fi" />
    <declaration type="Dfp" name="x" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compute ln(a).
 * Let f(x) = ln(x),
 * We know that f'(x) = 1/x, thus from Taylor's theorem we have:
 * -----          n+1         n
 * f(x) =   \           (-1)    (x - 1)
 * /          ----------------    for 1 &lt;= n &lt;= infinity
 * -----             n
 * or
 * 2        3       4
 * (x-1)   (x-1)    (x-1)
 * ln(x) =  (x-1) - ----- + ------ - ------ + ...
 * 2       3        4
 * alternatively,
 * 2    3   4
 * x    x   x
 * ln(x+1) =  x - -  + - - - + ...
 * 2    3   4
 * This series can be used to compute ln(x), but it converges too slowly.
 * If we substitute -x for x above, we get
 * 2    3    4
 * x    x    x
 * ln(1-x) =  -x - -  - -  - - + ...
 * 2    3    4
 * Note that all terms are now negative.  Because the even powered ones
 * absorbed the sign.  Now, subtract the series above from the previous
 * one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
 * only the odd ones
 * 3     5      7
 * 2x    2x     2x
 * ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
 * 3     5      7
 * By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
 * 3        5        7
 * x+1           /          x        x        x          \
 * ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
 * x-1           \          3        5        7          /
 * But now we want to find ln(a), so we need to find the value of x
 * such that a = (x+1)/(x-1).   This is easily solved to find that
 * x = (a-1)/(a+1).</text>
    <param>a number for which we want the exponential</param>
    <param>one constant with value 1 at desired precision</param>
    <param>two constant with value 2 at desired precision</param>
    <return>ln(a)</return>
  </javadoc>
  <method type="Dfp" name="computeLn">
    <declaration type="int" name="den" />
    <declaration type="Dfp" name="x" />
    <declaration type="Dfp" name="y" />
    <declaration type="Dfp" name="num" />
    <declaration type="Dfp" name="py" />
    <scope>
      <declaration type="Dfp" name="t" />
      <scope />
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>Note: the static strings are set up (once) by the ctor and @GuardedBy("DfpField.class")</comment>
</class>
