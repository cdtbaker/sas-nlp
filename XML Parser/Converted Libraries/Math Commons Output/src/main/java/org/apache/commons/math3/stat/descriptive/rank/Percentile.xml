<?xml version="1.0" encoding="UTF-8"?>
<class name="Percentile">
  <javadoc>
    <text>Provides percentile computation.
 * &lt;p&gt;
 * There are several commonly used methods for estimating percentiles (a.k.a.
 * quantiles) based on sample data.  For large samples, the different methods
 * agree closely, but when sample sizes are small, different methods will give
 * significantly different results.  The algorithm implemented here works as follows:
 * &lt;ol&gt;
 * &lt;li&gt;Let &lt;code&gt;n&lt;/code&gt; be the length of the (sorted) array and
 * &lt;code&gt;0 &lt; p &lt;= 100&lt;/code&gt; be the desired percentile.&lt;/li&gt;
 * &lt;li&gt;If &lt;code&gt; n = 1 &lt;/code&gt; return the unique array element (regardless of
 * the value of &lt;code&gt;p&lt;/code&gt;); otherwise &lt;/li&gt;
 * &lt;li&gt;Compute the estimated percentile position
 * &lt;code&gt; pos = p * (n + 1) / 100&lt;/code&gt; and the difference, &lt;code&gt;d&lt;/code&gt;
 * between &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;floor(pos)&lt;/code&gt; (i.e. the fractional
 * part of &lt;code&gt;pos&lt;/code&gt;).&lt;/li&gt;
 * &lt;li&gt; If &lt;code&gt;pos &lt; 1&lt;/code&gt; return the smallest element in the array.&lt;/li&gt;
 * &lt;li&gt; Else if &lt;code&gt;pos &gt;= n&lt;/code&gt; return the largest element in the array.&lt;/li&gt;
 * &lt;li&gt; Else let &lt;code&gt;lower&lt;/code&gt; be the element in position
 * &lt;code&gt;floor(pos)&lt;/code&gt; in the array and let &lt;code&gt;upper&lt;/code&gt; be the
 * next element in the array.  Return &lt;code&gt;lower + d * (upper - lower)&lt;/code&gt;
 * &lt;/li&gt;
 * &lt;/ol&gt;&lt;/p&gt;
 * &lt;p&gt;
 * To compute percentiles, the data must be at least partially ordered.  Input
 * arrays are copied and recursively partitioned using an ordering definition.
 * The ordering used by &lt;code&gt;Arrays.sort(double[])&lt;/code&gt; is the one determined
 * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes
 * &lt;code&gt;Double.NaN&lt;/code&gt; larger than any other value (including
 * &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt;).  Therefore, for example, the median
 * (50th percentile) of
 * &lt;code&gt;{0, 1, 2, 3, 4, Double.NaN}&lt;/code&gt; evaluates to &lt;code&gt;2.5.&lt;/code&gt;&lt;/p&gt;
 * &lt;p&gt;
 * Since percentile estimation usually involves interpolation between array
 * elements, arrays containing  &lt;code&gt;NaN&lt;/code&gt; or infinite values will often
 * result in &lt;code&gt;NaN&lt;/code&gt; or infinite values returned.&lt;/p&gt;
 * &lt;p&gt;
 * Since 2.2, Percentile uses only selection instead of complete sorting
 * and caches selection algorithm state between calls to the various{@code evaluate} methods. This greatly improves efficiency, both for a single
 * percentile and multiple percentile computations. To maximize performance when
 * multiple percentiles are computed based on the same data, users should set the
 * data array once using either one of the {@link #evaluate(double[],double)} or{@link #setData(double[])} methods and thereafter {@link #evaluate(double)}with just the percentile provided.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; If
 * multiple threads access an instance of this class concurrently, and at least
 * one of the threads invokes the &lt;code&gt;increment()&lt;/code&gt; or
 * &lt;code&gt;clear()&lt;/code&gt; method, it must be synchronized externally.&lt;/p&gt;</text>
    <version>$Id: Percentile.java 1416643 2012-12-03 19:37:14Z tn $</version>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Minimum size under which we use a simple insertion sort rather than Hoare's select.</text>
  </javadoc>
  <declaration type="int" name="MIN_SELECT_SIZE" />
  <javadoc>
    <text>Maximum number of partitioning pivots cached (each level double the number of pivots).</text>
  </javadoc>
  <declaration type="int" name="MAX_CACHED_LEVELS" />
  <javadoc>
    <text>Determines what percentile is computed when evaluate() is activated
 * with no quantile argument</text>
  </javadoc>
  <declaration type="double" name="quantile" />
  <javadoc>
    <text>Cached pivots.</text>
  </javadoc>
  <declaration type="int[]" name="cachedPivots" />
  <javadoc>
    <text>Constructs a Percentile with a default quantile
 * value of 50.0.</text>
  </javadoc>
  <method type="constructor" name="Percentile">
    <comment>No try-catch or advertised exception here - arg is valid</comment>
  </method>
  <javadoc>
    <text>Constructs a Percentile with the specific quantile value.</text>
    <param>p the quantile</param>
    <throws>MathIllegalArgumentException  if p is not greater than 0 and less
 * than or equal to 100</throws>
  </javadoc>
  <method type="constructor" name="Percentile" />
  <javadoc>
    <text>Copy constructor, creates a new {@code Percentile} identical
 * to the {@code original}</text>
    <param>original the {@code Percentile} instance to copy</param>
    <throws>NullArgumentException if original is null</throws>
  </javadoc>
  <method type="constructor" name="Percentile" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setData">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setData">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns the result of evaluating the statistic over the stored data.
 * &lt;p&gt;
 * The stored array is the one which was set by previous calls to{@link #setData(double[])}&lt;/p&gt;</text>
    <param>p the percentile value to compute</param>
    <return>the value of the statistic applied to the stored data</return>
    <throws>MathIllegalArgumentException if p is not a valid quantile value
 * (p must be greater than 0 and less than or equal to 100)</throws>
  </javadoc>
  <method type="double" name="evaluate" />
  <javadoc>
    <text>Returns an estimate of the &lt;code&gt;p&lt;/code&gt;th percentile of the values
 * in the &lt;code&gt;values&lt;/code&gt; array.
 * &lt;p&gt;
 * Calls to this method do not modify the internal &lt;code&gt;quantile&lt;/code&gt;
 * state of this statistic.&lt;/p&gt;
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Returns &lt;code&gt;Double.NaN&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt; has length
 * &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;Returns (for any value of &lt;code&gt;p&lt;/code&gt;) &lt;code&gt;values[0]&lt;/code&gt;
 * if &lt;code&gt;values&lt;/code&gt; has length &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt;
 * is null or p is not a valid quantile value (p must be greater than 0
 * and less than or equal to 100) &lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * See {@link Percentile} for a description of the percentile estimation
 * algorithm used.&lt;/p&gt;</text>
    <param>values input array of values</param>
    <param>p the percentile value to compute</param>
    <return>the percentile value or Double.NaN if the array is empty</return>
    <throws>MathIllegalArgumentException if &lt;code&gt;values&lt;/code&gt; is null
 * or p is invalid</throws>
  </javadoc>
  <method type="double" name="evaluate" />
  <javadoc>
    <text>Returns an estimate of the &lt;code&gt;quantile&lt;/code&gt;th percentile of the
 * designated values in the &lt;code&gt;values&lt;/code&gt; array.  The quantile
 * estimated is determined by the &lt;code&gt;quantile&lt;/code&gt; property.
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Returns &lt;code&gt;Double.NaN&lt;/code&gt; if &lt;code&gt;length = 0&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;Returns (for any value of &lt;code&gt;quantile&lt;/code&gt;)
 * &lt;code&gt;values[begin]&lt;/code&gt; if &lt;code&gt;length = 1 &lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt;
 * is null, or &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; is invalid&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * See {@link Percentile} for a description of the percentile estimation
 * algorithm used.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>start index of the first array element to include</param>
    <param>length the number of elements to include</param>
    <return>the percentile value</return>
    <throws>MathIllegalArgumentException if the parameters are not valid</throws>
  </javadoc>
  <method type="double" name="evaluate" />
  <javadoc>
    <text>Returns an estimate of the &lt;code&gt;p&lt;/code&gt;th percentile of the values
 * in the &lt;code&gt;values&lt;/code&gt; array, starting with the element in (0-based)
 * position &lt;code&gt;begin&lt;/code&gt; in the array and including &lt;code&gt;length&lt;/code&gt;
 * values.
 * &lt;p&gt;
 * Calls to this method do not modify the internal &lt;code&gt;quantile&lt;/code&gt;
 * state of this statistic.&lt;/p&gt;
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Returns &lt;code&gt;Double.NaN&lt;/code&gt; if &lt;code&gt;length = 0&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;Returns (for any value of &lt;code&gt;p&lt;/code&gt;) &lt;code&gt;values[begin]&lt;/code&gt;
 * if &lt;code&gt;length = 1 &lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt;
 * is null , &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; is invalid, or
 * &lt;code&gt;p&lt;/code&gt; is not a valid quantile value (p must be greater than 0
 * and less than or equal to 100)&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * See {@link Percentile} for a description of the percentile estimation
 * algorithm used.&lt;/p&gt;</text>
    <param>values array of input values</param>
    <param>p  the percentile to compute</param>
    <param>begin  the first (0-based) element to include in the computation</param>
    <param>length  the number of array elements to include</param>
    <return>the percentile value</return>
    <throws>MathIllegalArgumentException if the parameters are not valid or the
 * input array is null</throws>
  </javadoc>
  <method type="double" name="evaluate">
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="n" />
    <declaration type="double" name="pos" />
    <declaration type="double" name="fpos" />
    <declaration type="int" name="intPos" />
    <declaration type="double" name="dif" />
    <declaration type="double[]" name="work" />
    <declaration type="int[]" name="pivotsHeap" />
    <scope />
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="lower" />
    <declaration type="double" name="upper" />
    <comment>always return single value for n = 1</comment>
  </method>
  <javadoc>
    <text>Select the k&lt;sup&gt;th&lt;/sup&gt; smallest element from work array</text>
    <param>work work array (will be reorganized during the call)</param>
    <param>pivotsHeap set of pivot index corresponding to elements that
 * are already at their sorted location, stored as an implicit heap
 * (i.e. a sorted binary tree stored in a flat array, where the
 * children of a node at index n are at indices 2n+1 for the left
 * child and 2n+2 for the right child, with 0-based indices)</param>
    <param>k index of the desired element</param>
    <return>k&lt;sup&gt;th&lt;/sup&gt; smallest element</return>
  </javadoc>
  <method type="double" name="select">
    <declaration type="int" name="begin" />
    <declaration type="int" name="end" />
    <declaration type="int" name="node" />
    <scope>
      <declaration type="int" name="pivot" />
      <scope />
      <scope>
        <scope />
      </scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>the pivot has already been found in a previous call</comment>
    <comment>and the array has already been partitioned around it</comment>
    <comment>select a pivot and partition work array around it</comment>
    <comment>the pivot was exactly the element we wanted</comment>
    <comment>the element is in the left partition</comment>
    <comment>the min is here to avoid integer overflow</comment>
    <comment>the element is in the right partition</comment>
    <comment>the min is here to avoid integer overflow</comment>
    <comment>the element is somewhere in the small sub-array</comment>
    <comment>sort the sub-array using insertion sort</comment>
  </method>
  <javadoc>
    <text>Select a pivot index as the median of three</text>
    <param>work data array</param>
    <param>begin index of the first element of the slice</param>
    <param>end index after the last element of the slice</param>
    <return>the index of the median element chosen between the
 * first, the middle and the last element of the array slice</return>
  </javadoc>
  <method type="int" name="medianOf3">
    <declaration type="int" name="inclusiveEnd" />
    <declaration type="int" name="middle" />
    <declaration type="double" name="wBegin" />
    <declaration type="double" name="wMiddle" />
    <declaration type="double" name="wEnd" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Partition an array slice around a pivot
 * &lt;p&gt;
 * Partitioning exchanges array elements such that all elements
 * smaller than pivot are before it and all elements larger than
 * pivot are after it
 * &lt;/p&gt;</text>
    <param>work data array</param>
    <param>begin index of the first element of the slice</param>
    <param>end index after the last element of the slice</param>
    <param>pivot initial index of the pivot</param>
    <return>index of the pivot after partition</return>
  </javadoc>
  <method type="int" name="partition">
    <declaration type="double" name="value" />
    <declaration type="int" name="i" />
    <declaration type="int" name="j" />
    <scope>
      <scope />
      <scope />
      <scope>
        <declaration type="double" name="tmp" />
      </scope>
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>Sort in place a (small) array slice using insertion sort</text>
    <param>work array to sort</param>
    <param>begin index of the first element of the slice to sort</param>
    <param>end index after the last element of the slice to sort</param>
  </javadoc>
  <method type="void" name="insertionSort">
    <scope>
      <declaration type="double" name="saved" />
      <declaration type="int" name="i" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the value of the quantile field (determines what percentile is
 * computed when evaluate() is called with no quantile argument).</text>
    <return>quantile</return>
  </javadoc>
  <method type="double" name="getQuantile" />
  <javadoc>
    <text>Sets the value of the quantile field (determines what percentile is
 * computed when evaluate() is called with no quantile argument).</text>
    <param>p a value between 0 &lt; p &lt;= 100</param>
    <throws>MathIllegalArgumentException  if p is not greater than 0 and less
 * than or equal to 100</throws>
  </javadoc>
  <method type="void" name="setQuantile">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Percentile" name="copy">
    <declaration type="Percentile" name="result" />
    <comment>No try-catch or advertised exception because args are guaranteed non-null</comment>
  </method>
  <javadoc>
    <text>Copies source to dest.
 * &lt;p&gt;Neither source nor dest can be null.&lt;/p&gt;</text>
    <param>source Percentile to copy</param>
    <param>dest Percentile to copy to</param>
    <throws>NullArgumentException if either source or dest is null</throws>
  </javadoc>
  <method type="void" name="copy">
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
