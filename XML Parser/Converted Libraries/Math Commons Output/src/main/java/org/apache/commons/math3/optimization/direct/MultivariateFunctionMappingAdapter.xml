<?xml version="1.0" encoding="UTF-8"?>
<class name="MultivariateFunctionMappingAdapter">
  <javadoc>
    <text>&lt;p&gt;Adapter for mapping bounded {@link MultivariateFunction} to unbounded ones.&lt;/p&gt;
 * &lt;p&gt;
 * This adapter can be used to wrap functions subject to simple bounds on
 * parameters so they can be used by optimizers that do &lt;em&gt;not&lt;/em&gt; directly
 * support simple bounds.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The principle is that the user function that will be wrapped will see its
 * parameters bounded as required, i.e when its {@code value} method is called
 * with argument array {@code point}, the elements array will fulfill requirement{@code lower[i] &lt;= point[i] &lt;= upper[i]} for all i. Some of the components
 * may be unbounded or bounded only on one side if the corresponding bound is
 * set to an infinite value. The optimizer will not manage the user function by
 * itself, but it will handle this adapter and it is this adapter that will take
 * care the bounds are fulfilled. The adapter {@link #value(double[])} method will
 * be called by the optimizer with unbound parameters, and the adapter will map
 * the unbounded value to the bounded range using appropriate functions like{@link Sigmoid} for double bounded elements for example.
 * &lt;/p&gt;
 * &lt;p&gt;
 * As the optimizer sees only unbounded parameters, it should be noted that the
 * start point or simplex expected by the optimizer should be unbounded, so the
 * user is responsible for converting his bounded point to unbounded by calling{@link #boundedToUnbounded(double[])} before providing them to the optimizer.
 * For the same reason, the point returned by the {@link org.apache.commons.math3.optimization.BaseMultivariateOptimizer#optimize(int,MultivariateFunction,org.apache.commons.math3.optimization.GoalType,double[])}method is unbounded. So to convert this point to bounded, users must call{@link #unboundedToBounded(double[])} by themselves!&lt;/p&gt;
 * &lt;p&gt;
 * This adapter is only a poor man solution to simple bounds optimization constraints
 * that can be used with simple optimizers like {@link SimplexOptimizer} with {@link NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use
 * an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or{@link BOBYQAOptimizer}. One caveat of this poor man solution is that behavior near
 * the bounds may be numerically unstable as bounds are mapped from infinite values.
 * Another caveat is that convergence values are evaluated by the optimizer with respect
 * to unbounded variables, so there will be scales differences when converted to bounded
 * variables.
 * &lt;/p&gt;</text>
    <see>MultivariateFunctionPenaltyAdapter</see>
    <version>$Id: MultivariateFunctionMappingAdapter.java 1422230 2012-12-15 12:11:13Z erans $</version>
    <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Underlying bounded function.</text>
  </javadoc>
  <declaration type="MultivariateFunction" name="bounded" />
  <javadoc>
    <text>Mapping functions.</text>
  </javadoc>
  <declaration type="Mapper[]" name="mappers" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>bounded bounded function</param>
    <param>lower lower bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for
 * unbounded values)</param>
    <param>upper upper bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.POSITIVE_INFINITY} for
 * unbounded values)</param>
    <exception>DimensionMismatchException if lower and upper bounds are not
 * consistent, either according to dimension or to values</exception>
  </javadoc>
  <method type="constructor" name="MultivariateFunctionMappingAdapter">
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>safety checks</comment>
    <comment>note the following test is written in such a way it also fails for NaN</comment>
    <comment>element is unbounded, no transformation is needed</comment>
    <comment>element is simple-bounded on the upper side</comment>
    <comment>element is simple-bounded on the lower side</comment>
    <comment>element is double-bounded</comment>
  </method>
  <javadoc>
    <text>Map an array from unbounded to bounded.</text>
    <param>point unbounded value</param>
    <return>bounded value</return>
  </javadoc>
  <method type="double[]" name="unboundedToBounded">
    <declaration type="double[]" name="mapped" />
    <scope />
    <comment>map unbounded input point to bounded point</comment>
  </method>
  <javadoc>
    <text>Map an array from bounded to unbounded.</text>
    <param>point bounded value</param>
    <return>unbounded value</return>
  </javadoc>
  <method type="double[]" name="boundedToUnbounded">
    <declaration type="double[]" name="mapped" />
    <scope />
    <comment>map bounded input point to unbounded point</comment>
  </method>
  <javadoc>
    <text>Compute the underlying function value from an unbounded point.
 * &lt;p&gt;
 * This method simply bounds the unbounded point using the mappings
 * set up at construction and calls the underlying function using
 * the bounded point.
 * &lt;/p&gt;</text>
    <param>point unbounded value</param>
    <return>underlying function value</return>
    <see>#unboundedToBounded(double[])</see>
  </javadoc>
  <method type="double" name="value" />
  <javadoc>
    <text>Mapping interface.</text>
  </javadoc>
  <method name="unboundedToBounded" type="double" />
  <javadoc>
    <text>Map a value from unbounded to bounded.</text>
    <param>y unbounded value</param>
    <return>bounded value</return>
  </javadoc>
  <method name="boundedToUnbounded" type="double" />
  <javadoc>
    <text>Map a value from bounded to unbounded.</text>
    <param>x bounded value</param>
    <return>unbounded value</return>
  </javadoc>
  <javadoc>
    <text>Local class for no bounds mapping.</text>
  </javadoc>
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="NoBoundsMapper" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="unboundedToBounded" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="boundedToUnbounded" />
  <javadoc>
    <text>Local class for lower bounds mapping.</text>
  </javadoc>
  <javadoc>
    <text>Low bound.</text>
  </javadoc>
  <declaration type="double" name="lower" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>lower lower bound</param>
  </javadoc>
  <method type="constructor" name="LowerBoundMapper" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="unboundedToBounded" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="boundedToUnbounded" />
  <javadoc>
    <text>Local class for upper bounds mapping.</text>
  </javadoc>
  <javadoc>
    <text>Upper bound.</text>
  </javadoc>
  <declaration type="double" name="upper" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>upper upper bound</param>
  </javadoc>
  <method type="constructor" name="UpperBoundMapper" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="unboundedToBounded" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="boundedToUnbounded" />
  <javadoc>
    <text>Local class for lower and bounds mapping.</text>
  </javadoc>
  <javadoc>
    <text>Function from unbounded to bounded.</text>
  </javadoc>
  <declaration type="UnivariateFunction" name="boundingFunction" />
  <javadoc>
    <text>Function from bounded to unbounded.</text>
  </javadoc>
  <declaration type="UnivariateFunction" name="unboundingFunction" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>lower lower bound</param>
    <param>upper upper bound</param>
  </javadoc>
  <method type="constructor" name="LowerUpperBoundMapper" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="unboundedToBounded" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="boundedToUnbounded" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
