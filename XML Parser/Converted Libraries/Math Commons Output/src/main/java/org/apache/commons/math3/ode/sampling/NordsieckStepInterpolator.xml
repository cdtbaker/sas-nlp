<?xml version="1.0" encoding="UTF-8"?>
<class name="NordsieckStepInterpolator">
  <javadoc>
    <text>This class implements an interpolator for integrators using Nordsieck representation.
 * &lt;p&gt;This interpolator computes dense output around the current point.
 * The interpolation equation is based on Taylor series formulas.</text>
    <see>org.apache.commons.math3.ode.nonstiff.AdamsBashforthIntegrator</see>
    <see>org.apache.commons.math3.ode.nonstiff.AdamsMoultonIntegrator</see>
    <version>$Id: NordsieckStepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>State variation.</text>
  </javadoc>
  <declaration type="double[]" name="stateVariation" />
  <javadoc>
    <text>Step size used in the first scaled derivative and Nordsieck vector.</text>
  </javadoc>
  <declaration type="double" name="scalingH" />
  <javadoc>
    <text>Reference time for all arrays.
 * &lt;p&gt;Sometimes, the reference time is the same as previousTime,
 * sometimes it is the same as currentTime, so we use a separate
 * field to avoid any confusion.
 * &lt;/p&gt;</text>
  </javadoc>
  <declaration type="double" name="referenceTime" />
  <javadoc>
    <text>First scaled derivative.</text>
  </javadoc>
  <declaration type="double[]" name="scaled" />
  <javadoc>
    <text>Nordsieck vector.</text>
  </javadoc>
  <declaration type="Array2DRowRealMatrix" name="nordsieck" />
  <javadoc>
    <text>Simple constructor.
 * This constructor builds an instance that is not usable yet, the{@link AbstractStepInterpolator#reinitialize} method should be called
 * before using the instance in order to initialize the internal arrays. This
 * constructor is used only in order to delay the initialization in
 * some cases.</text>
  </javadoc>
  <method type="constructor" name="NordsieckStepInterpolator" />
  <javadoc>
    <text>Copy constructor.</text>
    <param>interpolator interpolator to copy from. The copy is a deep
 * copy: its arrays are separated from the original arrays of the
 * instance</param>
  </javadoc>
  <method type="constructor" name="NordsieckStepInterpolator">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="StepInterpolator" name="doCopy" />
  <javadoc>
    <text>Reinitialize the instance.
 * &lt;p&gt;Beware that all arrays &lt;em&gt;must&lt;/em&gt; be references to integrator
 * arrays, in order to ensure proper update without copy.&lt;/p&gt;</text>
    <param>y reference to the integrator array holding the state at
 * the end of the step</param>
    <param>forward integration direction indicator</param>
    <param>primaryMapper equations mapper for the primary equations set</param>
    <param>secondaryMappers equations mappers for the secondary equations sets</param>
  </javadoc>
  <method type="void" name="reinitialize" />
  <javadoc>
    <text>Reinitialize the instance.
 * &lt;p&gt;Beware that all arrays &lt;em&gt;must&lt;/em&gt; be references to integrator
 * arrays, in order to ensure proper update without copy.&lt;/p&gt;</text>
    <param>time time at which all arrays are defined</param>
    <param>stepSize step size used in the scaled and nordsieck arrays</param>
    <param>scaledDerivative reference to the integrator array holding the first
 * scaled derivative</param>
    <param>nordsieckVector reference to the integrator matrix holding the
 * nordsieck vector</param>
  </javadoc>
  <method type="void" name="reinitialize">
    <comment>make sure the state and derivatives will depend on the new arrays</comment>
  </method>
  <javadoc>
    <text>Rescale the instance.
 * &lt;p&gt;Since the scaled and Nordiseck arrays are shared with the caller,
 * this method has the side effect of rescaling this arrays in the caller too.&lt;/p&gt;</text>
    <param>stepSize new step size to use in the scaled and nordsieck arrays</param>
  </javadoc>
  <method type="void" name="rescale">
    <declaration type="double" name="ratio" />
    <scope />
    <declaration type="double[][]" name="nData" />
    <declaration type="double" name="power" />
    <scope>
      <declaration type="double[]" name="nDataI" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the state vector variation from current to interpolated state.
 * &lt;p&gt;This method is aimed at computing y(t&lt;sub&gt;interpolation&lt;/sub&gt;)
 * -y(t&lt;sub&gt;current&lt;/sub&gt;) accurately by avoiding the cancellation errors
 * that would occur if the subtraction were performed explicitly.&lt;/p&gt;
 * &lt;p&gt;The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.&lt;/p&gt;</text>
    <return>state vector at time {@link #getInterpolatedTime}</return>
    <see>#getInterpolatedDerivatives()</see>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method type="double[]" name="getInterpolatedStateVariation">
    <comment>compute and ignore interpolated state</comment>
    <comment>to make sure state variation is computed as a side effect</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="computeInterpolatedStateAndDerivatives">
    <declaration type="double" name="x" />
    <declaration type="double" name="normalizedAbscissa" />
    <declaration type="double[][]" name="nData" />
    <scope>
      <declaration type="int" name="order" />
      <declaration type="double[]" name="nDataI" />
      <declaration type="double" name="power" />
      <scope>
        <declaration type="double" name="d" />
      </scope>
    </scope>
    <scope />
    <comment>apply Taylor formula from high order to low order,</comment>
    <comment>for the sake of numerical accuracy</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="writeExternal">
    <declaration type="int" name="n" />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>save the state of the base class</comment>
    <comment>save the local attributes</comment>
    <comment>we don't save state variation, it will be recomputed</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="readExternal">
    <declaration type="double" name="t" />
    <declaration type="int" name="n" />
    <declaration type="boolean" name="hasScaled" />
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="boolean" name="hasNordsieck" />
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>read the base class</comment>
    <comment>read the local attributes</comment>
    <comment>we can now set the interpolated time and state</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
