<?xml version="1.0" encoding="UTF-8"?>
<class name="EventState">
  <javadoc>
    <text>This class handles the state for one {@link EventHandlerevent handler} during integration steps.
 * &lt;p&gt;Each time the integrator proposes a step, the event handler
 * switching function should be checked. This class handles the state
 * of one handler during one integration step, with references to the
 * state at the end of the preceding step. This information is used to
 * decide if the handler should trigger an event or not during the
 * proposed step.&lt;/p&gt;</text>
    <version>$Id: EventState.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Event handler.</text>
  </javadoc>
  <declaration type="EventHandler" name="handler" />
  <javadoc>
    <text>Maximal time interval between events handler checks.</text>
  </javadoc>
  <declaration type="double" name="maxCheckInterval" />
  <javadoc>
    <text>Convergence threshold for event localization.</text>
  </javadoc>
  <declaration type="double" name="convergence" />
  <javadoc>
    <text>Upper limit in the iteration count for event localization.</text>
  </javadoc>
  <declaration type="int" name="maxIterationCount" />
  <javadoc>
    <text>Time at the beginning of the step.</text>
  </javadoc>
  <declaration type="double" name="t0" />
  <javadoc>
    <text>Value of the events handler at the beginning of the step.</text>
  </javadoc>
  <declaration type="double" name="g0" />
  <javadoc>
    <text>Simulated sign of g0 (we cheat when crossing events).</text>
  </javadoc>
  <declaration type="boolean" name="g0Positive" />
  <javadoc>
    <text>Indicator of event expected during the step.</text>
  </javadoc>
  <declaration type="boolean" name="pendingEvent" />
  <javadoc>
    <text>Occurrence time of the pending event.</text>
  </javadoc>
  <declaration type="double" name="pendingEventTime" />
  <javadoc>
    <text>Occurrence time of the previous event.</text>
  </javadoc>
  <declaration type="double" name="previousEventTime" />
  <javadoc>
    <text>Integration direction.</text>
  </javadoc>
  <declaration type="boolean" name="forward" />
  <javadoc>
    <text>Variation direction around pending event.
 * (this is considered with respect to the integration direction)</text>
  </javadoc>
  <declaration type="boolean" name="increasing" />
  <javadoc>
    <text>Next action indicator.</text>
  </javadoc>
  <declaration type="EventHandler.Action" name="nextAction" />
  <javadoc>
    <text>Root-finding algorithm to use to detect state events.</text>
  </javadoc>
  <declaration type="UnivariateSolver" name="solver" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>handler event handler</param>
    <param>maxCheckInterval maximal time interval between switching
 * function checks (this interval prevents missing sign changes in
 * case the integration steps becomes very large)</param>
    <param>convergence convergence threshold in the event time search</param>
    <param>maxIterationCount upper limit of the iteration count in
 * the event time search</param>
    <param>solver Root-finding algorithm to use to detect state events</param>
  </javadoc>
  <method type="constructor" name="EventState">
    <comment>some dummy values ...</comment>
  </method>
  <javadoc>
    <text>Get the underlying event handler.</text>
    <return>underlying event handler</return>
  </javadoc>
  <method type="EventHandler" name="getEventHandler" />
  <javadoc>
    <text>Get the maximal time interval between events handler checks.</text>
    <return>maximal time interval between events handler checks</return>
  </javadoc>
  <method type="double" name="getMaxCheckInterval" />
  <javadoc>
    <text>Get the convergence threshold for event localization.</text>
    <return>convergence threshold for event localization</return>
  </javadoc>
  <method type="double" name="getConvergence" />
  <javadoc>
    <text>Get the upper limit in the iteration count for event localization.</text>
    <return>upper limit in the iteration count for event localization</return>
  </javadoc>
  <method type="int" name="getMaxIterationCount" />
  <javadoc>
    <text>Reinitialize the beginning of the step.</text>
    <param>interpolator valid for the current step</param>
    <exception>MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method type="void" name="reinitializeBegin">
    <scope>
      <declaration type="double" name="epsilon" />
      <declaration type="double" name="tStart" />
    </scope>
    <comment>excerpt from MATH-421 issue:</comment>
    <comment>If an ODE solver is setup with an EventHandler that return STOP</comment>
    <comment>when the even is triggered, the integrator stops (which is exactly</comment>
    <comment>the expected behavior). If however the user wants to restart the</comment>
    <comment>solver from the final state reached at the event with the same</comment>
    <comment>configuration (expecting the event to be triggered again at a</comment>
    <comment>later time), then the integrator may fail to start. It can get stuck</comment>
    <comment>at the previous event. The use case for the bug MATH-421 is fairly</comment>
    <comment>general, so events occurring exactly at start in the first step should</comment>
    <comment>be ignored.</comment>
    <comment>extremely rare case: there is a zero EXACTLY at interval start</comment>
    <comment>we will use the sign slightly after step beginning to force ignoring this zero</comment>
  </method>
  <javadoc>
    <text>Evaluate the impact of the proposed step on the event handler.</text>
    <param>interpolator step interpolator for the proposed step</param>
    <return>true if the event handler triggers an event before
 * the end of the proposed step</return>
    <exception>MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded</exception>
    <exception>NoBracketingException if the event cannot be bracketed</exception>
  </javadoc>
  <method type="boolean" name="evaluateStep">
    <scope>
      <declaration type="double" name="t1" />
      <declaration type="double" name="dt" />
      <scope />
      <declaration type="int" name="n" />
      <declaration type="double" name="h" />
      <declaration type="UnivariateFunction" name="f" />
      <method type="double" name="value">
        <scope />
        <scope />
      </method>
      <declaration type="double" name="ta" />
      <declaration type="double" name="ga" />
      <scope>
        <declaration type="double" name="tb" />
        <declaration type="double" name="gb" />
        <scope>
          <declaration type="double" name="root" />
          <scope>
            <declaration type="BracketedUnivariateSolver&lt;UnivariateFunction&gt;" name="bracketing" />
          </scope>
          <scope>
            <declaration type="double" name="baseRoot" />
            <declaration type="int" name="remainingEval" />
            <declaration type="BracketedUnivariateSolver&lt;UnivariateFunction&gt;" name="bracketing" />
          </scope>
          <scope />
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>we cannot do anything on such a small step, don't trigger any events</comment>
    <comment>evaluate handler value at the end of the substep</comment>
    <comment>check events occurrence</comment>
    <comment>there is a sign change: an event is expected during this step</comment>
    <comment>variation direction, with respect to the integration direction</comment>
    <comment>find the event time making sure we select a solution just at or past the exact root</comment>
    <comment>we have either found nothing or found (again ?) a past event,</comment>
    <comment>retry the substep excluding this value</comment>
    <comment>no sign change: there is no event for now</comment>
    <comment>no sign change: there is no event for now</comment>
    <comment>no event during the whole step</comment>
  </method>
  <javadoc>
    <text>Get the occurrence time of the event triggered in the current step.</text>
    <return>occurrence time of the event triggered in the current
 * step or infinity if no events are triggered</return>
  </javadoc>
  <method type="double" name="getEventTime" />
  <javadoc>
    <text>Acknowledge the fact the step has been accepted by the integrator.</text>
    <param>t value of the independent &lt;i&gt;time&lt;/i&gt; variable at the
 * end of the step</param>
    <param>y array containing the current value of the state vector
 * at the end of the step</param>
  </javadoc>
  <method type="void" name="stepAccepted">
    <scope />
    <scope />
    <comment>force the sign to its value "just after the event"</comment>
  </method>
  <javadoc>
    <text>Check if the integration should be stopped at the end of the
 * current step.</text>
    <return>true if the integration should be stopped</return>
  </javadoc>
  <method type="boolean" name="stop" />
  <javadoc>
    <text>Let the event handler reset the state if it wants.</text>
    <param>t value of the independent &lt;i&gt;time&lt;/i&gt; variable at the
 * beginning of the next step</param>
    <param>y array were to put the desired state vector at the beginning
 * of the next step</param>
    <return>true if the integrator should reset the derivatives too</return>
  </javadoc>
  <method type="boolean" name="reset">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Local wrapper to propagate exceptions.</text>
  </javadoc>
  <javadoc>
    <text>Serializable UID.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Wrapped exception.</text>
  </javadoc>
  <declaration type="MaxCountExceededException" name="wrapped" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>exception exception to wrap</param>
  </javadoc>
  <method type="constructor" name="LocalMaxCountExceededException" />
  <javadoc>
    <text>Get the wrapped exception.</text>
    <return>wrapped exception</return>
  </javadoc>
  <method type="MaxCountExceededException" name="getException" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
