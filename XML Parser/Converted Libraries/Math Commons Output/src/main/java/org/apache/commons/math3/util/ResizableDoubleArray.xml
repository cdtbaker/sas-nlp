<?xml version="1.0" encoding="UTF-8"?>
<class name="ResizableDoubleArray">
  <javadoc>
    <text>&lt;p&gt;
 * A variable length {@link DoubleArray} implementation that automatically
 * handles expanding and contracting its internal storage array as elements
 * are added and removed.
 * &lt;/p&gt;
 * &lt;h3&gt;Important note: Usage should not assume that this class is thread-safe
 * even though some of the methods are {@code synchronized}.
 * This qualifier will be dropped in the next major release (4.0).&lt;/h3&gt;
 * &lt;p&gt;
 * The internal storage array starts with capacity determined by the{@code initialCapacity} property, which can be set by the constructor.
 * The default initial capacity is 16.  Adding elements using{@link #addElement(double)} appends elements to the end of the array.
 * When there are no open entries at the end of the internal storage array,
 * the array is expanded.  The size of the expanded array depends on the{@code expansionMode} and {@code expansionFactor} properties.
 * The {@code expansionMode} determines whether the size of the array is
 * multiplied by the {@code expansionFactor}({@link ExpansionMode#MULTIPLICATIVE}) or if the expansion is additive
 * ({@link ExpansionMode#ADDITIVE} -- {@code expansionFactor} storage
 * locations added).
 * The default {@code expansionMode} is {@code MULTIPLICATIVE} and the default{@code expansionFactor} is 2.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The {@link #addElementRolling(double)} method adds a new element to the end
 * of the internal storage array and adjusts the "usable window" of the
 * internal array forward by one position (effectively making what was the
 * second element the first, and so on).  Repeated activations of this method
 * (or activation of {@link #discardFrontElements(int)}) will effectively orphan
 * the storage locations at the beginning of the internal storage array.  To
 * reclaim this storage, each time one of these methods is activated, the size
 * of the internal storage array is compared to the number of addressable
 * elements (the {@code numElements} property) and if the difference
 * is too large, the internal array is contracted to size{@code numElements + 1}.  The determination of when the internal
 * storage array is "too large" depends on the {@code expansionMode} and{@code contractionFactor} properties.  If  the {@code expansionMode}is {@code MULTIPLICATIVE}, contraction is triggered when the
 * ratio between storage array length and {@code numElements} exceeds{@code contractionFactor.}  If the {@code expansionMode}is {@code ADDITIVE}, the number of excess storage locations
 * is compared to {@code contractionFactor}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To avoid cycles of expansions and contractions, the{@code expansionFactor} must not exceed the {@code contractionFactor}.
 * Constructors and mutators for both of these properties enforce this
 * requirement, throwing a {@code MathIllegalArgumentException} if it is
 * violated.
 * &lt;/p&gt;</text>
    <version>$Id: ResizableDoubleArray.java 1462504 2013-03-29 15:48:57Z luc $</version>
  </javadoc>
  <javadoc>
    <text>Additive expansion mode.</text>
    <deprecated>As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.</deprecated>
  </javadoc>
  <declaration type="int" name="ADDITIVE_MODE" />
  <javadoc>
    <text>Multiplicative expansion mode.</text>
    <deprecated>As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.</deprecated>
  </javadoc>
  <declaration type="int" name="MULTIPLICATIVE_MODE" />
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Default value for initial capacity.</text>
  </javadoc>
  <declaration type="int" name="DEFAULT_INITIAL_CAPACITY" />
  <javadoc>
    <text>Default value for array size modifier.</text>
  </javadoc>
  <declaration type="double" name="DEFAULT_EXPANSION_FACTOR" />
  <javadoc>
    <text>Default value for the difference between {@link #contractionCriterion}and {@link #expansionFactor}.</text>
  </javadoc>
  <declaration type="double" name="DEFAULT_CONTRACTION_DELTA" />
  <javadoc>
    <text>The contraction criteria determines when the internal array will be
 * contracted to fit the number of elements contained in the element
 * array + 1.</text>
  </javadoc>
  <declaration type="double" name="contractionCriterion" />
  <javadoc>
    <text>The expansion factor of the array.  When the array needs to be expanded,
 * the new array size will be{@code internalArray.length * expansionFactor}if {@code expansionMode} is set to MULTIPLICATIVE_MODE, or{@code internalArray.length + expansionFactor} if{@code expansionMode} is set to ADDITIVE_MODE.</text>
  </javadoc>
  <declaration type="double" name="expansionFactor" />
  <javadoc>
    <text>Determines whether array expansion by {@code expansionFactor}is additive or multiplicative.</text>
  </javadoc>
  <declaration type="ExpansionMode" name="expansionMode" />
  <javadoc>
    <text>The internal storage array.</text>
  </javadoc>
  <declaration type="double[]" name="internalArray" />
  <javadoc>
    <text>The number of addressable elements in the array.  Note that this
 * has nothing to do with the length of the internal storage array.</text>
  </javadoc>
  <declaration type="int" name="numElements" />
  <javadoc>
    <text>The position of the first addressable element in the internal storage
 * array.  The addressable elements in the array are{@code internalArray[startIndex],...,internalArray[startIndex + numElements - 1]}.</text>
  </javadoc>
  <declaration type="int" name="startIndex" />
  <javadoc>
    <text>Specification of expansion algorithm.</text>
    <since>3.1</since>
  </javadoc>
  <javadoc>
    <text>Multiplicative expansion mode.</text>
  </javadoc>
  <javadoc>
    <text>Additive expansion mode.</text>
  </javadoc>
  <javadoc>
    <text>Creates an instance with default properties.
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity = 16}&lt;/li&gt;
 * &lt;li&gt;{@code expansionMode = MULTIPLICATIVE}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor = 2.0}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion = 2.5}&lt;/li&gt;
 * &lt;/ul&gt;</text>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Creates an instance with the specified initial capacity.
 * Other properties take default values:
 * &lt;ul&gt;
 * &lt;li&gt;{@code expansionMode = MULTIPLICATIVE}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor = 2.0}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion = 2.5}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialCapacity Initial size of the internal storage array.</param>
    <throws>MathIllegalArgumentException if {@code initialCapacity &lt;= 0}.</throws>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Creates an instance from an existing {@code double[]} with the
 * initial capacity and numElements corresponding to the size of
 * the supplied {@code double[]} array.
 * If the supplied array is null, a new empty array with the default
 * initial capacity will be created.
 * The input array is copied, not referenced.
 * Other properties take default values:
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity = 16}&lt;/li&gt;
 * &lt;li&gt;{@code expansionMode = MULTIPLICATIVE}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor = 2.0}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion = 2.5}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialArray initial array</param>
    <since>2.2</since>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Creates an instance with the specified initial capacity
 * and expansion factor.
 * The remaining properties take default values:
 * &lt;ul&gt;
 * &lt;li&gt;{@code expansionMode = MULTIPLICATIVE}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion = 0.5 + expansionFactor}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;br/&gt;
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity &gt; 0}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor &gt; 1}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialCapacity Initial size of the internal storage array.</param>
    <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
    <throws>MathIllegalArgumentException if parameters are not valid.</throws>
    <deprecated>As of 3.1. Please use{@link #ResizableDoubleArray(int,double)} instead.</deprecated>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Creates an instance with the specified initial capacity
 * and expansion factor.
 * The remaining properties take default values:
 * &lt;ul&gt;
 * &lt;li&gt;{@code expansionMode = MULTIPLICATIVE}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion = 0.5 + expansionFactor}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;br/&gt;
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity &gt; 0}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor &gt; 1}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialCapacity Initial size of the internal storage array.</param>
    <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
    <throws>MathIllegalArgumentException if parameters are not valid.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Creates an instance with the specified initialCapacity,
 * expansionFactor, and contractionCriterion.
 * The expansion mode will default to {@code MULTIPLICATIVE}.
 * &lt;br/&gt;
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity &gt; 0}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor &gt; 1}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion &gt;= expansionFactor}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialCapacity Initial size of the internal storage array..</param>
    <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
    <param>contractionCriteria Contraction criteria.</param>
    <throws>MathIllegalArgumentException if parameters are not valid.</throws>
    <deprecated>As of 3.1. Please use{@link #ResizableDoubleArray(int,double,double)} instead.</deprecated>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Creates an instance with the specified initial capacity,
 * expansion factor, and contraction criteria.
 * The expansion mode will default to {@code MULTIPLICATIVE}.
 * &lt;br/&gt;
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity &gt; 0}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor &gt; 1}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion &gt;= expansionFactor}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialCapacity Initial size of the internal storage array..</param>
    <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
    <param>contractionCriterion Contraction criterion.</param>
    <throws>MathIllegalArgumentException if the parameters are not valid.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>&lt;p&gt;
 * Create a ResizableArray with the specified properties.&lt;/p&gt;
 * &lt;p&gt;
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;initialCapacity &gt; 0&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;expansionFactor &gt; 1&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;contractionFactor &gt;= expansionFactor&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}&lt;/code&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;</text>
    <param>initialCapacity the initial size of the internal storage array</param>
    <param>expansionFactor the array will be expanded based on this
 * parameter</param>
    <param>contractionCriteria the contraction Criteria</param>
    <param>expansionMode  the expansion mode</param>
    <throws>MathIllegalArgumentException if parameters are not valid</throws>
    <deprecated>As of 3.1. Please use{@link #ResizableDoubleArray(int,double,double,ExpansionMode,double[])}instead.</deprecated>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray">
    <comment>XXX Just ot retain the expected failure in a unit test.</comment>
    <comment>With the new "enum", that test will become obsolete.</comment>
  </method>
  <javadoc>
    <text>Creates an instance with the specified properties.
 * &lt;br/&gt;
 * Throws MathIllegalArgumentException if the following conditions are
 * not met:
 * &lt;ul&gt;
 * &lt;li&gt;{@code initialCapacity &gt; 0}&lt;/li&gt;
 * &lt;li&gt;{@code expansionFactor &gt; 1}&lt;/li&gt;
 * &lt;li&gt;{@code contractionCriterion &gt;= expansionFactor}&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>initialCapacity Initial size of the internal storage array.</param>
    <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
    <param>contractionCriterion Contraction criteria.</param>
    <param>expansionMode Expansion mode.</param>
    <param>data Initial contents of the array.</param>
    <throws>MathIllegalArgumentException if the parameters are not valid.</throws>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Copy constructor.  Creates a new ResizableDoubleArray that is a deep,
 * fresh copy of the original. Needs to acquire synchronization lock
 * on original.  Original may not be null; otherwise a {@link NullArgumentException}is thrown.</text>
    <param>original array to copy</param>
    <exception>NullArgumentException if original is null</exception>
    <since>2.0</since>
  </javadoc>
  <method type="constructor" name="ResizableDoubleArray" />
  <javadoc>
    <text>Adds an element to the end of this expandable array.</text>
    <param>value Value to be added to end of array.</param>
  </javadoc>
  <method type="void" name="addElement">
    <scope />
  </method>
  <javadoc>
    <text>Adds several element to the end of this expandable array.</text>
    <param>values Values to be added to end of array.</param>
    <since>2.2</since>
  </javadoc>
  <method type="void" name="addElements">
    <declaration type="double[]" name="tempArray" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Adds an element to the end of the array and removes the first
 * element in the array.  Returns the discarded first element.
 * The effect is similar to a push operation in a FIFO queue.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Example: If the array contains the elements 1, 2, 3, 4 (in that order)
 * and addElementRolling(5) is invoked, the result is an array containing
 * the entries 2, 3, 4, 5 and the value returned is 1.
 * &lt;/p&gt;</text>
    <param>value Value to be added to the array.</param>
    <return>the value which has been discarded or "pushed" out of the array
 * by this rolling insert.</return>
  </javadoc>
  <method type="double" name="addElementRolling">
    <declaration type="double" name="discarded" />
    <scope />
    <scope />
    <comment>Increment the start index</comment>
    <comment>Add the new value</comment>
    <comment>Check the contraction criterion.</comment>
  </method>
  <javadoc>
    <text>Substitutes &lt;code&gt;value&lt;/code&gt; for the most recently added value.
 * Returns the value that has been replaced. If the array is empty (i.e.
 * if {@link #numElements} is zero), an IllegalStateException is thrown.</text>
    <param>value New value to substitute for the most recently added value</param>
    <return>the value that has been replaced in the array.</return>
    <throws>MathIllegalStateException if the array is empty</throws>
    <since>2.0</since>
  </javadoc>
  <method type="double" name="substituteMostRecentElement">
    <scope />
    <declaration type="int" name="substIndex" />
    <declaration type="double" name="discarded" />
  </method>
  <javadoc>
    <text>Checks the expansion factor and the contraction criterion and throws an
 * IllegalArgumentException if the contractionCriteria is less than the
 * expansionCriteria</text>
    <param>expansion factor to be checked</param>
    <param>contraction criteria to be checked</param>
    <throws>MathIllegalArgumentException if the contractionCriteria is less than
 * the expansionCriteria.</throws>
    <deprecated>As of 3.1. Please use{@link #checkContractExpand(double,double)} instead.</deprecated>
  </javadoc>
  <method type="void" name="checkContractExpand" />
  <javadoc>
    <text>Checks the expansion factor and the contraction criterion and raises
 * an exception if the contraction criterion is smaller than the
 * expansion criterion.</text>
    <param>contraction Criterion to be checked.</param>
    <param>expansion Factor to be checked.</param>
    <throws>NumberIsTooSmallException if {@code contraction &lt; expansion}.</throws>
    <throws>NumberIsTooSmallException if {@code contraction &lt;= 1}.</throws>
    <throws>NumberIsTooSmallException if {@code expansion &lt;= 1 }.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkContractExpand">
    <scope>
      <declaration type="NumberIsTooSmallException" name="e" />
    </scope>
    <scope>
      <declaration type="NumberIsTooSmallException" name="e" />
    </scope>
    <scope>
      <declaration type="NumberIsTooSmallException" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Clear the array contents, resetting the number of elements to zero.</text>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Contracts the storage array to the (size of the element set) + 1 - to
 * avoid a zero length array. This function also resets the startIndex to
 * zero.</text>
  </javadoc>
  <method type="void" name="contract">
    <declaration type="double[]" name="tempArray" />
    <comment>Copy and swap - copy only the element array from the src array.</comment>
    <comment>Reset the start index to zero</comment>
  </method>
  <javadoc>
    <text>Discards the &lt;code&gt;i&lt;/code&gt; initial elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * &lt;code&gt;discardFrontElements(2)&lt;/code&gt; will cause the first two elements
 * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.</text>
    <param>i  the number of elements to discard from the front of the array</param>
    <throws>MathIllegalArgumentException if i is greater than numElements.</throws>
    <since>2.0</since>
  </javadoc>
  <method type="void" name="discardFrontElements" />
  <javadoc>
    <text>Discards the &lt;code&gt;i&lt;/code&gt; last elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * &lt;code&gt;discardMostRecentElements(2)&lt;/code&gt; will cause the last two elements
 * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.</text>
    <param>i  the number of elements to discard from the end of the array</param>
    <throws>MathIllegalArgumentException if i is greater than numElements.</throws>
    <since>2.0</since>
  </javadoc>
  <method type="void" name="discardMostRecentElements" />
  <javadoc>
    <text>Discards the &lt;code&gt;i&lt;/code&gt; first or last elements of the array,
 * depending on the value of &lt;code&gt;front&lt;/code&gt;.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * &lt;code&gt;discardExtremeElements(2,false)&lt;/code&gt; will cause the last two elements
 * to be discarded, leaving 1,2 in the array.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * &lt;code&gt;discardExtremeElements(2,true)&lt;/code&gt; will cause the first two elements
 * to be discarded, leaving 3,4 in the array.
 * Throws illegalArgumentException
 * if i exceeds numElements.</text>
    <param>i  the number of elements to discard from the front/end of the array</param>
    <param>front true if elements are to be discarded from the front
 * of the array, false if elements are to be discarded from the end
 * of the array</param>
    <throws>MathIllegalArgumentException if i is greater than numElements.</throws>
    <since>2.0</since>
  </javadoc>
  <method type="void" name="discardExtremeElements">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>"Subtract" this number of discarded from numElements</comment>
  </method>
  <javadoc>
    <text>Expands the internal storage array using the expansion factor.
 * &lt;p&gt;
 * if &lt;code&gt;expansionMode&lt;/code&gt; is set to MULTIPLICATIVE_MODE,
 * the new array size will be &lt;code&gt;internalArray.length * expansionFactor.&lt;/code&gt;
 * If &lt;code&gt;expansionMode&lt;/code&gt; is set to ADDITIVE_MODE,  the length
 * after expansion will be &lt;code&gt;internalArray.length + expansionFactor&lt;/code&gt;
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="expand">
    <declaration type="int" name="newSize" />
    <scope />
    <scope />
    <declaration type="double[]" name="tempArray" />
    <comment>notice the use of FastMath.ceil(), this guarantees that we will always</comment>
    <comment>have an array of at least currentSize + 1.   Assume that the</comment>
    <comment>current initial capacity is 1 and the expansion factor</comment>
    <comment>is 1.000000000000000001.  The newly calculated size will be</comment>
    <comment>rounded up to 2 after the multiplication is performed.</comment>
    <comment>Copy and swap</comment>
  </method>
  <javadoc>
    <text>Expands the internal storage array to the specified size.</text>
    <param>size Size of the new internal storage array.</param>
  </javadoc>
  <method type="void" name="expandTo">
    <declaration type="double[]" name="tempArray" />
    <comment>Copy and swap</comment>
  </method>
  <javadoc>
    <text>The contraction criteria defines when the internal array will contract
 * to store only the number of elements in the element array.
 * If  the &lt;code&gt;expansionMode&lt;/code&gt; is &lt;code&gt;MULTIPLICATIVE_MODE&lt;/code&gt;,
 * contraction is triggered when the ratio between storage array length
 * and &lt;code&gt;numElements&lt;/code&gt; exceeds &lt;code&gt;contractionFactor&lt;/code&gt;.
 * If the &lt;code&gt;expansionMode&lt;/code&gt; is &lt;code&gt;ADDITIVE_MODE&lt;/code&gt;, the
 * number of excess storage locations is compared to
 * &lt;code&gt;contractionFactor.&lt;/code&gt;</text>
    <return>the contraction criteria used to reclaim memory.</return>
    <deprecated>As of 3.1. Please use {@link #getContractionCriterion()}instead.</deprecated>
  </javadoc>
  <method type="float" name="getContractionCriteria" />
  <javadoc>
    <text>The contraction criterion defines when the internal array will contract
 * to store only the number of elements in the element array.
 * If  the &lt;code&gt;expansionMode&lt;/code&gt; is &lt;code&gt;MULTIPLICATIVE_MODE&lt;/code&gt;,
 * contraction is triggered when the ratio between storage array length
 * and &lt;code&gt;numElements&lt;/code&gt; exceeds &lt;code&gt;contractionFactor&lt;/code&gt;.
 * If the &lt;code&gt;expansionMode&lt;/code&gt; is &lt;code&gt;ADDITIVE_MODE&lt;/code&gt;, the
 * number of excess storage locations is compared to
 * &lt;code&gt;contractionFactor.&lt;/code&gt;</text>
    <return>the contraction criterion used to reclaim memory.</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="getContractionCriterion" />
  <javadoc>
    <text>Returns the element at the specified index</text>
    <param>index index to fetch a value from</param>
    <return>value stored at the specified index</return>
    <throws>ArrayIndexOutOfBoundsException if &lt;code&gt;index&lt;/code&gt; is less than
 * zero or is greater than &lt;code&gt;getNumElements() - 1&lt;/code&gt;.</throws>
  </javadoc>
  <method type="double" name="getElement">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns a double array containing the elements of this
 * &lt;code&gt;ResizableArray&lt;/code&gt;.  This method returns a copy, not a
 * reference to the underlying array, so that changes made to the returned
 * array have no effect on this &lt;code&gt;ResizableArray.&lt;/code&gt;</text>
    <return>the double array.</return>
  </javadoc>
  <method type="double[]" name="getElements">
    <declaration type="double[]" name="elementArray" />
  </method>
  <javadoc>
    <text>The expansion factor controls the size of a new array when an array
 * needs to be expanded.  The &lt;code&gt;expansionMode&lt;/code&gt;
 * determines whether the size of the array is multiplied by the
 * &lt;code&gt;expansionFactor&lt;/code&gt; (MULTIPLICATIVE_MODE) or if
 * the expansion is additive (ADDITIVE_MODE -- &lt;code&gt;expansionFactor&lt;/code&gt;
 * storage locations added).  The default &lt;code&gt;expansionMode&lt;/code&gt; is
 * MULTIPLICATIVE_MODE and the default &lt;code&gt;expansionFactor&lt;/code&gt;
 * is 2.0.</text>
    <return>the expansion factor of this expandable double array</return>
    <deprecated>As of 3.1. Return type will be changed to "double" in 4.0.</deprecated>
  </javadoc>
  <method type="float" name="getExpansionFactor" />
  <javadoc>
    <text>The expansion mode determines whether the internal storage
 * array grows additively or multiplicatively when it is expanded.</text>
    <return>the expansion mode.</return>
    <deprecated>As of 3.1. Return value to be changed to{@link ExpansionMode} in 4.0.</deprecated>
  </javadoc>
  <method type="int" name="getExpansionMode">
    <comment>Should never happen.</comment>
  </method>
  <javadoc>
    <text>Notice the package scope on this method.   This method is simply here
 * for the JUnit test, it allows us check if the expansion is working
 * properly after a number of expansions.  This is not meant to be a part
 * of the public interface of this class.</text>
    <return>the length of the internal storage array.</return>
    <deprecated>As of 3.1. Please use {@link #getCapacity()} instead.</deprecated>
  </javadoc>
  <method type="int" name="getInternalLength" />
  <javadoc>
    <text>Gets the currently allocated size of the internal data structure used
 * for storing elements.
 * This is not to be confused with {@link #getNumElements() the number of
 * elements actually stored}.</text>
    <return>the length of the internal array.</return>
    <since>3.1</since>
  </javadoc>
  <method type="int" name="getCapacity" />
  <javadoc>
    <text>Returns the number of elements currently in the array.  Please note
 * that this is different from the length of the internal storage array.</text>
    <return>the number of elements.</return>
  </javadoc>
  <method type="int" name="getNumElements" />
  <javadoc>
    <text>Returns the internal storage array.  Note that this method returns
 * a reference to the internal storage array, not a copy, and to correctly
 * address elements of the array, the &lt;code&gt;startIndex&lt;/code&gt; is
 * required (available via the {@link #start} method).  This method should
 * only be used in cases where copying the internal array is not practical.
 * The {@link #getElements} method should be used in all other cases.</text>
    <return>the internal storage array used by this object</return>
    <since>2.0</since>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <method type="double[]" name="getInternalValues" />
  <javadoc>
    <text>Provides &lt;em&gt;direct&lt;/em&gt; access to the internal storage array.
 * Please note that this method returns a reference to this object's
 * storage array, not a copy.
 * &lt;br/&gt;
 * To correctly address elements of the array, the "start index" is
 * required (available via the {@link #getStartIndex() getStartIndex}method.
 * &lt;br/&gt;
 * This method should only be used to avoid copying the internal array.
 * The returned value &lt;em&gt;must&lt;/em&gt; be used for reading only; other
 * uses could lead to this object becoming inconsistent.
 * &lt;br/&gt;
 * The {@link #getElements} method has no such limitation since it
 * returns a copy of this array's addressable elements.</text>
    <return>the internal storage array used by this object.</return>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="getArrayRef" />
  <javadoc>
    <text>Returns the "start index" of the internal array.
 * This index is the position of the first addressable element in the
 * internal storage array.
 * The addressable elements in the array are at indices contained in
 * the interval [{@link #getStartIndex()},{@link #getStartIndex()} + {@link #getNumElements()} - 1].</text>
    <return>the start index.</return>
    <since>3.1</since>
  </javadoc>
  <method type="int" name="getStartIndex" />
  <javadoc>
    <text>Sets the contraction criteria.</text>
    <param>contractionCriteria contraction criteria</param>
    <throws>MathIllegalArgumentException if the contractionCriteria is less than
 * the expansionCriteria.</throws>
    <deprecated>As of 3.1 (to be removed in 4.0 as field will become "final").</deprecated>
  </javadoc>
  <method type="void" name="setContractionCriteria">
    <scope />
  </method>
  <javadoc>
    <text>Performs an operation on the addressable elements of the array.</text>
    <param>f Function to be applied on this array.</param>
    <return>the result.</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="compute">
    <declaration type="double[]" name="array" />
    <declaration type="int" name="start" />
    <declaration type="int" name="num" />
    <scope />
  </method>
  <javadoc>
    <text>Sets the element at the specified index.  If the specified index is greater than
 * &lt;code&gt;getNumElements() - 1&lt;/code&gt;, the &lt;code&gt;numElements&lt;/code&gt; property
 * is increased to &lt;code&gt;index +1&lt;/code&gt; and additional storage is allocated
 * (if necessary) for the new element and all  (uninitialized) elements
 * between the new element and the previous end of the array).</text>
    <param>index index to store a value in</param>
    <param>value value to store at the specified index</param>
    <throws>ArrayIndexOutOfBoundsException if {@code index &lt; 0}.</throws>
  </javadoc>
  <method type="void" name="setElement">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Sets the expansionFactor.  Throws IllegalArgumentException if the
 * the following conditions are not met:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;expansionFactor &gt; 1&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;contractionFactor &gt;= expansionFactor&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>expansionFactor the new expansion factor value.</param>
    <throws>MathIllegalArgumentException if expansionFactor is &lt;= 1 or greater
 * than contractionFactor</throws>
    <deprecated>As of 3.1 (to be removed in 4.0 as field will become "final").</deprecated>
  </javadoc>
  <method type="void" name="setExpansionFactor">
    <scope />
    <comment>The check above verifies that the expansion factor is &gt; 1.0;</comment>
  </method>
  <javadoc>
    <text>Sets the &lt;code&gt;expansionMode&lt;/code&gt;. The specified value must be one of
 * ADDITIVE_MODE, MULTIPLICATIVE_MODE.</text>
    <param>expansionMode The expansionMode to set.</param>
    <throws>MathIllegalArgumentException if the specified mode value is not valid.</throws>
    <deprecated>As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.</deprecated>
  </javadoc>
  <method type="void" name="setExpansionMode">
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Sets the {@link ExpansionMode expansion mode}.</text>
    <param>expansionMode Expansion mode to use for resizing the array.</param>
    <deprecated>As of 3.1 (to be removed in 4.0 as field will become "final").</deprecated>
  </javadoc>
  <method type="void" name="setExpansionMode" />
  <javadoc>
    <text>Sets the initial capacity.  Should only be invoked by constructors.</text>
    <param>initialCapacity of the array</param>
    <throws>MathIllegalArgumentException if &lt;code&gt;initialCapacity&lt;/code&gt; is not
 * positive.</throws>
    <deprecated>As of 3.1, this is a no-op.</deprecated>
  </javadoc>
  <method type="void" name="setInitialCapacity">
    <comment>Body removed in 3.1.</comment>
  </method>
  <javadoc>
    <text>This function allows you to control the number of elements contained
 * in this array, and can be used to "throw out" the last n values in an
 * array. This function will also expand the internal array as needed.</text>
    <param>i a new number of elements</param>
    <throws>MathIllegalArgumentException if &lt;code&gt;i&lt;/code&gt; is negative.</throws>
  </javadoc>
  <method type="void" name="setNumElements">
    <scope />
    <declaration type="int" name="newSize" />
    <scope />
    <comment>If index is negative thrown an error.</comment>
    <comment>Test the new num elements, check to see if the array needs to be</comment>
    <comment>expanded to accommodate this new number of elements.</comment>
    <comment>Set the new number of elements to new value.</comment>
  </method>
  <javadoc>
    <text>Returns true if the internal storage array has too many unused
 * storage positions.</text>
    <return>true if array satisfies the contraction criteria</return>
  </javadoc>
  <method type="boolean" name="shouldContract">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns the starting index of the internal array.  The starting index is
 * the position of the first addressable element in the internal storage
 * array.  The addressable elements in the array are &lt;code&gt;
 * internalArray[startIndex],...,internalArray[startIndex + numElements -1]
 * &lt;/code&gt;</text>
    <return>the starting index.</return>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <method type="int" name="start" />
  <javadoc>
    <text>&lt;p&gt;Copies source to dest, copying the underlying data, so dest is
 * a new, independent copy of source.  Does not contract before
 * the copy.&lt;/p&gt;
 * &lt;p&gt;Obtains synchronization locks on both source and dest
 * (in that order) before performing the copy.&lt;/p&gt;
 * &lt;p&gt;Neither source nor dest may be null; otherwise a {@link NullArgumentException}is thrown&lt;/p&gt;</text>
    <param>source ResizableDoubleArray to copy</param>
    <param>dest ResizableArray to replace with a copy of the source array</param>
    <exception>NullArgumentException if either source or dest is null</exception>
    <since>2.0</since>
  </javadoc>
  <method type="void" name="copy">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns a copy of the ResizableDoubleArray.  Does not contract before
 * the copy, so the returned object is an exact copy of this.</text>
    <return>a new ResizableDoubleArray with the same data and configuration
 * properties as this</return>
    <since>2.0</since>
  </javadoc>
  <method type="ResizableDoubleArray" name="copy">
    <declaration type="ResizableDoubleArray" name="result" />
  </method>
  <javadoc>
    <text>Returns true iff object is a ResizableDoubleArray with the same properties
 * as this and an identical internal storage array.</text>
    <param>object object to be compared for equality with this</param>
    <return>true iff object is a ResizableDoubleArray with the same data and
 * properties as this</return>
    <since>2.0</since>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <scope>
      <scope>
        <declaration type="boolean" name="result" />
        <declaration type="ResizableDoubleArray" name="other" />
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Returns a hash code consistent with equals.</text>
    <return>the hash code representing this {@code ResizableDoubleArray}.</return>
    <since>2.0</since>
  </javadoc>
  <method type="int" name="hashCode">
    <declaration type="int[]" name="hashData" />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
