<?xml version="1.0" encoding="UTF-8"?>
<class name="EigenDecomposition">
  <javadoc>
    <text>Calculates the eigen decomposition of a real matrix.
 * &lt;p&gt;The eigen decomposition of matrix A is a set of two matrices:
 * V and D such that A = V &amp;times; D &amp;times; V&lt;sup&gt;T&lt;/sup&gt;.
 * A, V and D are all m &amp;times; m matrices.&lt;/p&gt;
 * &lt;p&gt;This class is similar in spirit to the &lt;code&gt;EigenvalueDecomposition&lt;/code&gt;
 * class from the &lt;a href="http://math.nist.gov/javanumerics/jama/"&gt;JAMA&lt;/a&gt;
 * library, with the following changes:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;a {@link #getVT() getVt} method has been added,&lt;/li&gt;
 * &lt;li&gt;two {@link #getRealEigenvalue(int) getRealEigenvalue} and {@link #getImagEigenvalue(int)getImagEigenvalue} methods to pick up a single eigenvalue have been added,&lt;/li&gt;
 * &lt;li&gt;a {@link #getEigenvector(int) getEigenvector} method to pick up a single
 * eigenvector has been added,&lt;/li&gt;
 * &lt;li&gt;a {@link #getDeterminant() getDeterminant} method has been added.&lt;/li&gt;
 * &lt;li&gt;a {@link #getSolver() getSolver} method has been added.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * As of 3.1, this class supports general real matrices (both symmetric and non-symmetric):
 * &lt;/p&gt;
 * &lt;p&gt;
 * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector
 * matrix V is orthogonal, i.e. A = V.multiply(D.multiply(V.transpose())) and
 * V.multiply(V.transpose()) equals the identity matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues
 * in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks:
 * &lt;pre&gt;
 * [lambda, mu    ]
 * [   -mu, lambda]
 * &lt;/pre&gt;
 * The columns of V represent the eigenvectors in the sense that A*V = V*D,
 * i.e. A.multiply(V) equals V.multiply(D).
 * The matrix V may be badly conditioned, or even singular, so the validity of the equation
 * A = V*D*inverse(V) depends upon the condition of V.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This implementation is based on the paper by A. Drubrulle, R.S. Martin and
 * J.H. Wilkinson "The Implicit QL Algorithm" in Wilksinson and Reinsch (1971)
 * Handbook for automatic computation, vol. 2, Linear algebra, Springer-Verlag,
 * New-York
 * &lt;/p&gt;</text>
    <see>&lt;a href="http://mathworld.wolfram.com/EigenDecomposition.html"&gt;MathWorld&lt;/a&gt;</see>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix"&gt;Wikipedia&lt;/a&gt;</see>
    <version>$Id: EigenDecomposition.java 1452595 2013-03-04 23:29:39Z tn $</version>
    <since>2.0 (changed to concrete class in 3.0)</since>
  </javadoc>
  <javadoc>
    <text>Internally used epsilon criteria.</text>
  </javadoc>
  <declaration type="double" name="EPSILON" />
  <javadoc>
    <text>Maximum number of iterations accepted in the implicit QL transformation</text>
  </javadoc>
  <declaration type="byte" name="maxIter" />
  <javadoc>
    <text>Main diagonal of the tridiagonal matrix.</text>
  </javadoc>
  <declaration type="double[]" name="main" />
  <javadoc>
    <text>Secondary diagonal of the tridiagonal matrix.</text>
  </javadoc>
  <declaration type="double[]" name="secondary" />
  <javadoc>
    <text>Transformer to tridiagonal (may be null if matrix is already
 * tridiagonal).</text>
  </javadoc>
  <declaration type="TriDiagonalTransformer" name="transformer" />
  <javadoc>
    <text>Real part of the realEigenvalues.</text>
  </javadoc>
  <declaration type="double[]" name="realEigenvalues" />
  <javadoc>
    <text>Imaginary part of the realEigenvalues.</text>
  </javadoc>
  <declaration type="double[]" name="imagEigenvalues" />
  <javadoc>
    <text>Eigenvectors.</text>
  </javadoc>
  <declaration type="ArrayRealVector[]" name="eigenvectors" />
  <javadoc>
    <text>Cached value of V.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedV" />
  <javadoc>
    <text>Cached value of D.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedD" />
  <javadoc>
    <text>Cached value of Vt.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedVt" />
  <javadoc>
    <text>Whether the matrix is symmetric.</text>
  </javadoc>
  <declaration type="boolean" name="isSymmetric" />
  <javadoc>
    <text>Calculates the eigen decomposition of the given real matrix.
 * &lt;p&gt;
 * Supports decomposition of a general matrix since 3.1.</text>
    <param>matrix Matrix to decompose.</param>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
    <throws>MathArithmeticException if the decomposition of a general matrix
 * results in a matrix with zero norm</throws>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="EigenDecomposition">
    <declaration type="double" name="symTol" />
    <scope />
    <scope>
      <declaration type="SchurTransformer" name="t" />
    </scope>
  </method>
  <javadoc>
    <text>Calculates the eigen decomposition of the given real matrix.</text>
    <param>matrix Matrix to decompose.</param>
    <param>splitTolerance Dummy parameter (present for backward
 * compatibility only).</param>
    <throws>MathArithmeticException  if the decomposition of a general matrix
 * results in a matrix with zero norm</throws>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
    <deprecated>in 3.1 (to be removed in 4.0) due to unused parameter</deprecated>
  </javadoc>
  <method type="constructor" name="EigenDecomposition" />
  <javadoc>
    <text>Calculates the eigen decomposition of the symmetric tridiagonal
 * matrix.  The Householder matrix is assumed to be the identity matrix.</text>
    <param>main Main diagonal of the symmetric tridiagonal form.</param>
    <param>secondary Secondary of the tridiagonal form.</param>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="EigenDecomposition">
    <declaration type="int" name="size" />
    <declaration type="double[][]" name="z" />
    <scope />
  </method>
  <javadoc>
    <text>Calculates the eigen decomposition of the symmetric tridiagonal
 * matrix.  The Householder matrix is assumed to be the identity matrix.</text>
    <param>main Main diagonal of the symmetric tridiagonal form.</param>
    <param>secondary Secondary of the tridiagonal form.</param>
    <param>splitTolerance Dummy parameter (present for backward
 * compatibility only).</param>
    <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
    <deprecated>in 3.1 (to be removed in 4.0) due to unused parameter</deprecated>
  </javadoc>
  <method type="constructor" name="EigenDecomposition" />
  <javadoc>
    <text>Gets the matrix V of the decomposition.
 * V is an orthogonal matrix, i.e. its transpose is also its inverse.
 * The columns of V are the eigenvectors of the original matrix.
 * No assumption is made about the orientation of the system axes formed
 * by the columns of V (e.g. in a 3-dimension space, V can form a left-
 * or right-handed system).</text>
    <return>the V matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="getV">
    <scope>
      <declaration type="int" name="m" />
      <scope />
    </scope>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Gets the block diagonal matrix D of the decomposition.
 * D is a block diagonal matrix.
 * Real eigenvalues are on the diagonal while complex values are on
 * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.</text>
    <return>the D matrix.</return>
    <see>#getRealEigenvalues()</see>
    <see>#getImagEigenvalues()</see>
  </javadoc>
  <method type="RealMatrix" name="getD">
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>cache the matrix for subsequent calls</comment>
  </method>
  <javadoc>
    <text>Gets the transpose of the matrix V of the decomposition.
 * V is an orthogonal matrix, i.e. its transpose is also its inverse.
 * The columns of V are the eigenvectors of the original matrix.
 * No assumption is made about the orientation of the system axes formed
 * by the columns of V (e.g. in a 3-dimension space, V can form a left-
 * or right-handed system).</text>
    <return>the transpose of the V matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="getVT">
    <scope>
      <declaration type="int" name="m" />
      <scope />
    </scope>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns whether the calculated eigen values are complex or real.
 * &lt;p&gt;The method performs a zero check for each element of the{@link #getImagEigenvalues()} array and returns {@code true} if any
 * element is not equal to zero.</text>
    <return>{@code true} if the eigen values are complex, {@code false} otherwise</return>
    <since>3.1</since>
  </javadoc>
  <method type="boolean" name="hasComplexEigenvalues">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Gets a copy of the real parts of the eigenvalues of the original matrix.</text>
    <return>a copy of the real parts of the eigenvalues of the original matrix.</return>
    <see>#getD()</see>
    <see>#getRealEigenvalue(int)</see>
    <see>#getImagEigenvalues()</see>
  </javadoc>
  <method type="double[]" name="getRealEigenvalues" />
  <javadoc>
    <text>Returns the real part of the i&lt;sup&gt;th&lt;/sup&gt; eigenvalue of the original
 * matrix.</text>
    <param>i index of the eigenvalue (counting from 0)</param>
    <return>real part of the i&lt;sup&gt;th&lt;/sup&gt; eigenvalue of the original
 * matrix.</return>
    <see>#getD()</see>
    <see>#getRealEigenvalues()</see>
    <see>#getImagEigenvalue(int)</see>
  </javadoc>
  <method type="double" name="getRealEigenvalue" />
  <javadoc>
    <text>Gets a copy of the imaginary parts of the eigenvalues of the original
 * matrix.</text>
    <return>a copy of the imaginary parts of the eigenvalues of the original
 * matrix.</return>
    <see>#getD()</see>
    <see>#getImagEigenvalue(int)</see>
    <see>#getRealEigenvalues()</see>
  </javadoc>
  <method type="double[]" name="getImagEigenvalues" />
  <javadoc>
    <text>Gets the imaginary part of the i&lt;sup&gt;th&lt;/sup&gt; eigenvalue of the original
 * matrix.</text>
    <param>i Index of the eigenvalue (counting from 0).</param>
    <return>the imaginary part of the i&lt;sup&gt;th&lt;/sup&gt; eigenvalue of the original
 * matrix.</return>
    <see>#getD()</see>
    <see>#getImagEigenvalues()</see>
    <see>#getRealEigenvalue(int)</see>
  </javadoc>
  <method type="double" name="getImagEigenvalue" />
  <javadoc>
    <text>Gets a copy of the i&lt;sup&gt;th&lt;/sup&gt; eigenvector of the original matrix.</text>
    <param>i Index of the eigenvector (counting from 0).</param>
    <return>a copy of the i&lt;sup&gt;th&lt;/sup&gt; eigenvector of the original matrix.</return>
    <see>#getD()</see>
  </javadoc>
  <method type="RealVector" name="getEigenvector" />
  <javadoc>
    <text>Computes the determinant of the matrix.</text>
    <return>the determinant of the matrix.</return>
  </javadoc>
  <method type="double" name="getDeterminant">
    <declaration type="double" name="determinant" />
    <scope />
  </method>
  <javadoc>
    <text>Computes the square-root of the matrix.
 * This implementation assumes that the matrix is symmetric and positive
 * definite.</text>
    <return>the square-root of the matrix.</return>
    <throws>MathUnsupportedOperationException if the matrix is not
 * symmetric or not positive definite.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="RealMatrix" name="getSquareRoot">
    <scope />
    <declaration type="double[]" name="sqrtEigenValues" />
    <scope>
      <declaration type="double" name="eigen" />
      <scope />
    </scope>
    <declaration type="RealMatrix" name="sqrtEigen" />
    <declaration type="RealMatrix" name="v" />
    <declaration type="RealMatrix" name="vT" />
  </method>
  <javadoc>
    <text>Gets a solver for finding the A &amp;times; X = B solution in exact
 * linear sense.
 * &lt;p&gt;
 * Since 3.1, eigen decomposition of a general matrix is supported,
 * but the {@link DecompositionSolver} only supports real eigenvalues.</text>
    <return>a solver</return>
    <throws>MathUnsupportedOperationException if the decomposition resulted in
 * complex eigenvalues</throws>
  </javadoc>
  <method type="DecompositionSolver" name="getSolver">
    <scope />
  </method>
  <javadoc>
    <text>Specialized solver.</text>
  </javadoc>
  <javadoc>
    <text>Real part of the realEigenvalues.</text>
  </javadoc>
  <declaration type="double[]" name="realEigenvalues" />
  <javadoc>
    <text>Imaginary part of the realEigenvalues.</text>
  </javadoc>
  <declaration type="double[]" name="imagEigenvalues" />
  <javadoc>
    <text>Eigenvectors.</text>
  </javadoc>
  <declaration type="ArrayRealVector[]" name="eigenvectors" />
  <javadoc>
    <text>Builds a solver from decomposed matrix.</text>
    <param>realEigenvalues Real parts of the eigenvalues.</param>
    <param>imagEigenvalues Imaginary parts of the eigenvalues.</param>
    <param>eigenvectors Eigenvectors.</param>
  </javadoc>
  <method type="constructor" name="Solver" />
  <javadoc>
    <text>Solves the linear equation A &amp;times; X = B for symmetric matrices A.
 * &lt;p&gt;
 * This method only finds exact linear solutions, i.e. solutions for
 * which ||A &amp;times; X - B|| is exactly 0.
 * &lt;/p&gt;</text>
    <param>b Right-hand side of the equation A &amp;times; X = B.</param>
    <return>a Vector X that minimizes the two norm of A &amp;times; X - B.</return>
    <throws>DimensionMismatchException if the matrices dimensions do not match.</throws>
    <throws>SingularMatrixException if the decomposed matrix is singular.</throws>
  </javadoc>
  <method type="RealVector" name="solve">
    <scope />
    <declaration type="int" name="m" />
    <scope />
    <declaration type="double[]" name="bp" />
    <scope>
      <declaration type="ArrayRealVector" name="v" />
      <declaration type="double[]" name="vData" />
      <declaration type="double" name="s" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealMatrix" name="solve">
    <scope />
    <declaration type="int" name="m" />
    <scope />
    <declaration type="int" name="nColB" />
    <declaration type="double[][]" name="bp" />
    <declaration type="double[]" name="tmpCol" />
    <scope>
      <scope />
      <scope>
        <declaration type="ArrayRealVector" name="v" />
        <declaration type="double[]" name="vData" />
        <declaration type="double" name="s" />
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Checks whether the decomposed matrix is non-singular.</text>
    <return>true if the decomposed matrix is non-singular.</return>
  </javadoc>
  <method type="boolean" name="isNonSingular">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the inverse of the decomposed matrix.</text>
    <return>the inverse matrix.</return>
    <throws>SingularMatrixException if the decomposed matrix is singular.</throws>
  </javadoc>
  <method type="RealMatrix" name="getInverse">
    <scope />
    <declaration type="int" name="m" />
    <declaration type="double[][]" name="invData" />
    <scope>
      <declaration type="double[]" name="invI" />
      <scope>
        <declaration type="double" name="invIJ" />
        <scope>
          <declaration type="double[]" name="vK" />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Transforms the matrix to tridiagonal form.</text>
    <param>matrix Matrix to transform.</param>
  </javadoc>
  <method type="void" name="transformToTridiagonal">
    <comment>transform the matrix to tridiagonal</comment>
  </method>
  <javadoc>
    <text>Find eigenvalues and eigenvectors (Dubrulle et al., 1971)</text>
    <param>householderMatrix Householder matrix of the transformation
 * to tridiagonal form.</param>
  </javadoc>
  <method type="void" name="findEigenVectors">
    <declaration type="double[][]" name="z" />
    <declaration type="int" name="n" />
    <declaration type="double[]" name="e" />
    <scope />
    <declaration type="double" name="maxAbsoluteValue" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="int" name="its" />
      <declaration type="int" name="m" />
      <scope>
        <scope>
          <declaration type="double" name="delta" />
          <scope />
        </scope>
        <scope>
          <scope />
          <declaration type="double" name="q" />
          <declaration type="double" name="t" />
          <scope />
          <scope />
          <declaration type="double" name="u" />
          <declaration type="double" name="s" />
          <declaration type="double" name="c" />
          <declaration type="int" name="i" />
          <scope>
            <declaration type="double" name="p" />
            <declaration type="double" name="h" />
            <scope />
            <scope />
            <scope />
            <scope />
          </scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <scope>
      <declaration type="int" name="k" />
      <declaration type="double" name="p" />
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="double[]" name="tmp" />
    <scope>
      <scope />
    </scope>
    <comment>Determine the largest main and secondary value in absolute term.</comment>
    <comment>Make null any main and secondary value too small to be significant</comment>
    <comment>Sort the eigen values (and vectors) in increase order</comment>
    <comment>Determine the largest eigen value in absolute term.</comment>
    <comment>Make null any eigen value too small to be significant</comment>
  </method>
  <javadoc>
    <text>Transforms the matrix to Schur form and calculates the eigenvalues.</text>
    <param>matrix Matrix to transform.</param>
    <return>the {@link SchurTransformer Shur transform} for this matrix</return>
  </javadoc>
  <method type="SchurTransformer" name="transformToSchur">
    <declaration type="SchurTransformer" name="schurTransform" />
    <declaration type="double[][]" name="matT" />
    <scope>
      <scope />
      <scope>
        <declaration type="double" name="x" />
        <declaration type="double" name="p" />
        <declaration type="double" name="z" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Performs a division of two complex numbers.</text>
    <param>xr real part of the first number</param>
    <param>xi imaginary part of the first number</param>
    <param>yr real part of the second number</param>
    <param>yi imaginary part of the second number</param>
    <return>result of the complex division</return>
  </javadoc>
  <method type="Complex" name="cdiv" />
  <javadoc>
    <text>Find eigenvectors from a matrix transformed to Schur form.</text>
    <param>schur the schur transformation of the matrix</param>
    <throws>MathArithmeticException if the Schur form has a norm of zero</throws>
  </javadoc>
  <method type="void" name="findEigenVectorsFromSchur">
    <declaration type="double[][]" name="matrixT" />
    <declaration type="double[][]" name="matrixP" />
    <declaration type="int" name="n" />
    <declaration type="double" name="norm" />
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="double" name="r" />
    <declaration type="double" name="s" />
    <declaration type="double" name="z" />
    <scope>
      <declaration type="double" name="p" />
      <declaration type="double" name="q" />
      <scope>
        <declaration type="int" name="l" />
        <scope>
          <declaration type="double" name="w" />
          <scope />
          <scope />
          <scope>
            <scope>
              <scope />
              <scope />
            </scope>
            <scope>
              <declaration type="double" name="x" />
              <declaration type="double" name="y" />
              <declaration type="double" name="t" />
              <scope />
              <scope />
            </scope>
            <declaration type="double" name="t" />
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
      <scope>
        <declaration type="int" name="l" />
        <scope />
        <scope>
          <declaration type="Complex" name="result" />
        </scope>
        <scope>
          <declaration type="double" name="ra" />
          <declaration type="double" name="sa" />
          <scope />
          <declaration type="double" name="w" />
          <scope />
          <scope>
            <scope>
              <declaration type="Complex" name="c" />
            </scope>
            <scope>
              <declaration type="double" name="x" />
              <declaration type="double" name="y" />
              <declaration type="double" name="vr" />
              <declaration type="double" name="vi" />
              <scope />
              <declaration type="Complex" name="c" />
              <scope />
              <scope>
                <declaration type="Complex" name="c2" />
              </scope>
            </scope>
            <declaration type="double" name="t" />
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="double[]" name="tmp" />
    <scope>
      <scope />
    </scope>
    <comment>compute matrix norm</comment>
    <comment>we can not handle a matrix with zero norm</comment>
    <comment>Backsubstitute to find vectors of upper triangular form</comment>
    <comment>Real vector</comment>
    <comment>Solve real equations</comment>
    <comment>Overflow control</comment>
    <comment>Complex vector</comment>
    <comment>Last vector component imaginary so matrix is triangular</comment>
    <comment>Solve complex equations</comment>
    <comment>Overflow control</comment>
    <comment>Vectors of isolated roots</comment>
    <comment>Back transformation to get eigenvectors of original matrix</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
