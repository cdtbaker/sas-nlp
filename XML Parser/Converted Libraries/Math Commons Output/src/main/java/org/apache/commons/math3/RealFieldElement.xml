<?xml version="1.0" encoding="UTF-8"?>
<class name="RealFieldElement">
  <javadoc>
    <text>Interface representing a &lt;a href="http://mathworld.wolfram.com/RealNumber.html"&gt;real&lt;/a&gt;
 * &lt;a href="http://mathworld.wolfram.com/Field.html"&gt;field&lt;/a&gt;.</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <see>FieldElement</see>
    <version>$Id: RealFieldElement.java 1455053 2013-03-11 08:37:12Z luc $</version>
    <since>3.2</since>
  </javadoc>
  <method name="getReal" type="double" />
  <javadoc>
    <text>Get the real value of the number.</text>
    <return>real value</return>
  </javadoc>
  <method name="add" type="T" />
  <javadoc>
    <text>'+' operator.</text>
    <param>a right hand side parameter of the operator</param>
    <return>this+a</return>
  </javadoc>
  <method name="subtract" type="T" />
  <javadoc>
    <text>'-' operator.</text>
    <param>a right hand side parameter of the operator</param>
    <return>this-a</return>
  </javadoc>
  <method name="multiply" type="T" />
  <javadoc>
    <text>'&amp;times;' operator.</text>
    <param>a right hand side parameter of the operator</param>
    <return>this&amp;times;a</return>
  </javadoc>
  <method name="divide" type="T" />
  <javadoc>
    <text>'&amp;divides;' operator.</text>
    <param>a right hand side parameter of the operator</param>
    <return>this&amp;divides;a</return>
  </javadoc>
  <method name="remainder" type="T" />
  <javadoc>
    <text>IEEE remainder operator.</text>
    <param>a right hand side parameter of the operator</param>
    <return>this - n &amp;times; a where n is the closest integer to this/a
 * (the even integer is chosen for n if this/a is halfway between two integers)</return>
  </javadoc>
  <method name="remainder" type="T" />
  <javadoc>
    <text>IEEE remainder operator.</text>
    <param>a right hand side parameter of the operator</param>
    <return>this - n &amp;times; a where n is the closest integer to this/a
 * (the even integer is chosen for n if this/a is halfway between two integers)</return>
    <exception>DimensionMismatchException if number of free parameters or orders are inconsistent</exception>
  </javadoc>
  <method name="abs" type="T" />
  <javadoc>
    <text>absolute value.</text>
    <return>abs(this)</return>
  </javadoc>
  <method name="ceil" type="T" />
  <javadoc>
    <text>Get the smallest whole number larger than instance.</text>
    <return>ceil(this)</return>
  </javadoc>
  <method name="floor" type="T" />
  <javadoc>
    <text>Get the largest whole number smaller than instance.</text>
    <return>floor(this)</return>
  </javadoc>
  <method name="rint" type="T" />
  <javadoc>
    <text>Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.</text>
    <return>a double number r such that r is an integer r - 0.5 &lt;= this &lt;= r + 0.5</return>
  </javadoc>
  <method name="round" type="long" />
  <javadoc>
    <text>Get the closest long to instance value.</text>
    <return>closest long to {@link #getReal()}</return>
  </javadoc>
  <method name="signum" type="T" />
  <javadoc>
    <text>Compute the signum of the instance.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise</text>
    <return>-1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a</return>
  </javadoc>
  <method name="copySign" type="T" />
  <javadoc>
    <text>Returns the instance with the sign of the argument.
 * A NaN {@code sign} argument is treated as positive.</text>
    <param>sign the sign for the returned value</param>
    <return>the instance with the same sign as the {@code sign} argument</return>
  </javadoc>
  <method name="copySign" type="T" />
  <javadoc>
    <text>Returns the instance with the sign of the argument.
 * A NaN {@code sign} argument is treated as positive.</text>
    <param>sign the sign for the returned value</param>
    <return>the instance with the same sign as the {@code sign} argument</return>
  </javadoc>
  <method name="scalb" type="T" />
  <javadoc>
    <text>Multiply the instance by a power of 2.</text>
    <param>n power of 2</param>
    <return>this &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;</return>
  </javadoc>
  <method name="hypot" type="T" />
  <javadoc>
    <text>Returns the hypotenuse of a triangle with sides {@code this} and {@code y}- sqrt(&lt;i&gt;this&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)&lt;br/&gt;
 * avoiding intermediate overflow or underflow.
 * &lt;ul&gt;
 * &lt;li&gt; If either argument is infinite, then the result is positive infinity.&lt;/li&gt;
 * &lt;li&gt; else, if either argument is NaN then the result is NaN.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>y a value</param>
    <return>sqrt(&lt;i&gt;this&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)</return>
    <exception>DimensionMismatchException if number of free parameters or orders are inconsistent</exception>
  </javadoc>
  <method name="reciprocal" type="T" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method name="sqrt" type="T" />
  <javadoc>
    <text>Square root.</text>
    <return>square root of the instance</return>
  </javadoc>
  <method name="cbrt" type="T" />
  <javadoc>
    <text>Cubic root.</text>
    <return>cubic root of the instance</return>
  </javadoc>
  <method name="rootN" type="T" />
  <javadoc>
    <text>N&lt;sup&gt;th&lt;/sup&gt; root.</text>
    <param>n order of the root</param>
    <return>n&lt;sup&gt;th&lt;/sup&gt; root of the instance</return>
  </javadoc>
  <method name="pow" type="T" />
  <javadoc>
    <text>Power operation.</text>
    <param>p power to apply</param>
    <return>this&lt;sup&gt;p&lt;/sup&gt;</return>
  </javadoc>
  <method name="pow" type="T" />
  <javadoc>
    <text>Integer power operation.</text>
    <param>n power to apply</param>
    <return>this&lt;sup&gt;n&lt;/sup&gt;</return>
  </javadoc>
  <method name="pow" type="T" />
  <javadoc>
    <text>Power operation.</text>
    <param>e exponent</param>
    <return>this&lt;sup&gt;e&lt;/sup&gt;</return>
    <exception>DimensionMismatchException if number of free parameters or orders are inconsistent</exception>
  </javadoc>
  <method name="exp" type="T" />
  <javadoc>
    <text>Exponential.</text>
    <return>exponential of the instance</return>
  </javadoc>
  <method name="expm1" type="T" />
  <javadoc>
    <text>Exponential minus 1.</text>
    <return>exponential minus one of the instance</return>
  </javadoc>
  <method name="log" type="T" />
  <javadoc>
    <text>Natural logarithm.</text>
    <return>logarithm of the instance</return>
  </javadoc>
  <method name="log1p" type="T" />
  <javadoc>
    <text>Shifted natural logarithm.</text>
    <return>logarithm of one plus the instance</return>
  </javadoc>
  <method name="cos" type="T" />
  <javadoc>
    <text>Cosine operation.</text>
    <return>cos(this)</return>
  </javadoc>
  <method name="sin" type="T" />
  <javadoc>
    <text>Sine operation.</text>
    <return>sin(this)</return>
  </javadoc>
  <method name="tan" type="T" />
  <javadoc>
    <text>Tangent operation.</text>
    <return>tan(this)</return>
  </javadoc>
  <method name="acos" type="T" />
  <javadoc>
    <text>Arc cosine operation.</text>
    <return>acos(this)</return>
  </javadoc>
  <method name="asin" type="T" />
  <javadoc>
    <text>Arc sine operation.</text>
    <return>asin(this)</return>
  </javadoc>
  <method name="atan" type="T" />
  <javadoc>
    <text>Arc tangent operation.</text>
    <return>atan(this)</return>
  </javadoc>
  <method name="atan2" type="T" />
  <javadoc>
    <text>Two arguments arc tangent operation.</text>
    <param>x second argument of the arc tangent</param>
    <return>atan2(this, x)</return>
    <exception>DimensionMismatchException if number of free parameters or orders are inconsistent</exception>
  </javadoc>
  <method name="cosh" type="T" />
  <javadoc>
    <text>Hyperbolic cosine operation.</text>
    <return>cosh(this)</return>
  </javadoc>
  <method name="sinh" type="T" />
  <javadoc>
    <text>Hyperbolic sine operation.</text>
    <return>sinh(this)</return>
  </javadoc>
  <method name="tanh" type="T" />
  <javadoc>
    <text>Hyperbolic tangent operation.</text>
    <return>tanh(this)</return>
  </javadoc>
  <method name="acosh" type="T" />
  <javadoc>
    <text>Inverse hyperbolic cosine operation.</text>
    <return>acosh(this)</return>
  </javadoc>
  <method name="asinh" type="T" />
  <javadoc>
    <text>Inverse hyperbolic sine operation.</text>
    <return>asin(this)</return>
  </javadoc>
  <method name="atanh" type="T" />
  <javadoc>
    <text>Inverse hyperbolic  tangent operation.</text>
    <return>atanh(this)</return>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a Factors.</param>
    <param>b Factors.</param>
    <return>&lt;code&gt;&amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.</return>
    <throws>DimensionMismatchException if arrays dimensions don't match</throws>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a Factors.</param>
    <param>b Factors.</param>
    <return>&lt;code&gt;&amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.</return>
    <throws>DimensionMismatchException if arrays dimensions don't match</throws>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt;</return>
    <see>#linearCombination(Object,Object,Object,Object,Object,Object)</see>
    <see>#linearCombination(Object,Object,Object,Object,Object,Object,Object,Object)</see>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt;</return>
    <see>#linearCombination(double,Object,double,Object,double,Object)</see>
    <see>#linearCombination(double,Object,double,Object,double,Object,double,Object)</see>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <param>a3 first factor of the third term</param>
    <param>b3 second factor of the third term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;</return>
    <see>#linearCombination(Object,Object,Object,Object)</see>
    <see>#linearCombination(Object,Object,Object,Object,Object,Object,Object,Object)</see>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <param>a3 first factor of the third term</param>
    <param>b3 second factor of the third term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;</return>
    <see>#linearCombination(double,Object,double,Object)</see>
    <see>#linearCombination(double,Object,double,Object,double,Object,double,Object)</see>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <param>a3 first factor of the third term</param>
    <param>b3 second factor of the third term</param>
    <param>a4 first factor of the third term</param>
    <param>b4 second factor of the third term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
 * a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;</return>
    <see>#linearCombination(Object,Object,Object,Object)</see>
    <see>#linearCombination(Object,Object,Object,Object,Object,Object)</see>
    <since>3.2</since>
  </javadoc>
  <method name="linearCombination" type="T" />
  <javadoc>
    <text>Compute a linear combination.</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <param>a3 first factor of the third term</param>
    <param>b3 second factor of the third term</param>
    <param>a4 first factor of the third term</param>
    <param>b4 second factor of the third term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
 * a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;</return>
    <see>#linearCombination(double,Object,double,Object)</see>
    <see>#linearCombination(double,Object,double,Object,double,Object)</see>
    <since>3.2</since>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>TODO: add this method in 4.0, as it is not possible to do it in 3.2</comment>
  <comment>due to incompatibility of the return type in the Dfp class</comment>
  <comment>/** Base 10 logarithm.</comment>
  <comment>* @return base 10 logarithm of the instance</comment>
  <comment>*/</comment>
  <comment>T log10();</comment>
</class>
