<?xml version="1.0" encoding="UTF-8"?>
<class name="FastMathCalc">
  <javadoc>
    <text>Class used to compute the classical functions tables.</text>
    <version>$Id: FastMathCalc.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>0x40000000 - used to split a double into two parts, both with the low order bits cleared.
 * Equivalent to 2^30.</text>
  </javadoc>
  <declaration type="long" name="HEX_40000000" />
  <javadoc>
    <text>Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19!</text>
  </javadoc>
  <declaration type="double" name="FACT" />
  <javadoc>
    <text>Coefficients for slowLog.</text>
  </javadoc>
  <declaration type="double" name="LN_SPLIT_COEF" />
  <javadoc>
    <text>Table start declaration.</text>
  </javadoc>
  <declaration type="String" name="TABLE_START_DECL" />
  <javadoc>
    <text>Table end declaration.</text>
  </javadoc>
  <declaration type="String" name="TABLE_END_DECL" />
  <javadoc>
    <text>Private Constructor.</text>
  </javadoc>
  <method type="constructor" name="FastMathCalc" />
  <javadoc>
    <text>Build the sine and cosine tables.</text>
    <param>SINE_TABLE_A table of the most significant part of the sines</param>
    <param>SINE_TABLE_B table of the least significant part of the sines</param>
    <param>COSINE_TABLE_A table of the most significant part of the cosines</param>
    <param>COSINE_TABLE_B table of the most significant part of the cosines</param>
    <param>SINE_TABLE_LEN length of the tables</param>
    <param>TANGENT_TABLE_A table of the most significant part of the tangents</param>
    <param>TANGENT_TABLE_B table of the most significant part of the tangents</param>
  </javadoc>
  <method type="void" name="buildSinCosTables">
    <declaration type="double[]" name="result" />
    <scope>
      <declaration type="double" name="x" />
    </scope>
    <scope>
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="ys" />
      <declaration type="double[]" name="as" />
      <declaration type="double[]" name="bs" />
      <declaration type="double[]" name="temps" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="ys" />
      <declaration type="double[]" name="as" />
    </scope>
    <comment>Use taylor series for 0 &lt;= x &lt;= 68</comment>
    <comment>Use angle addition formula to complete table to 138, just beyond pi2</comment>
    <comment>Even, use double angle</comment>
    <comment>compute sine</comment>
    <comment>Compute cosine</comment>
    <comment>compute sine</comment>
    <comment>Compute cosine</comment>
    <comment>Compute tangent = sinecosine</comment>
  </method>
  <javadoc>
    <text>For x between 0 and pi/4 compute cosine using Talor series
 * cos(x) = 1 - x^2/2! + x^4/4! ...</text>
    <param>x number from which cosine is requested</param>
    <param>result placeholder where to put the result in extended precision
 * (may be null)</param>
    <return>cos(x)</return>
  </javadoc>
  <method type="double" name="slowCos">
    <declaration type="double[]" name="xs" />
    <declaration type="double[]" name="ys" />
    <declaration type="double[]" name="facts" />
    <declaration type="double[]" name="as" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>skip odd entries</comment>
    <comment>alternate terms are negative</comment>
  </method>
  <javadoc>
    <text>For x between 0 and pi/4 compute sine using Taylor expansion:
 * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...</text>
    <param>x number from which sine is requested</param>
    <param>result placeholder where to put the result in extended precision
 * (may be null)</param>
    <return>sin(x)</return>
  </javadoc>
  <method type="double" name="slowSin">
    <declaration type="double[]" name="xs" />
    <declaration type="double[]" name="ys" />
    <declaration type="double[]" name="facts" />
    <declaration type="double[]" name="as" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>Ignore even numbers</comment>
    <comment>alternate terms are negative</comment>
  </method>
  <javadoc>
    <text>For x between 0 and 1, returns exp(x), uses extended precision</text>
    <param>x argument of exponential</param>
    <param>result placeholder where to place exp(x) split in two terms
 * for extra precision (i.e. exp(x) = result[0] + result[1]</param>
    <return>exp(x)</return>
  </javadoc>
  <method type="double" name="slowexp">
    <declaration type="double[]" name="xs" />
    <declaration type="double[]" name="ys" />
    <declaration type="double[]" name="facts" />
    <declaration type="double[]" name="as" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compute split[0], split[1] such that their sum is equal to d,
 * and split[0] has its 30 least significant bits as zero.</text>
    <param>d number to split</param>
    <param>split placeholder where to place the result</param>
  </javadoc>
  <method type="void" name="split">
    <scope>
      <declaration type="double" name="a" />
    </scope>
    <scope>
      <declaration type="double" name="a" />
    </scope>
  </method>
  <javadoc>
    <text>Recompute a split.</text>
    <param>a input/out array containing the split, changed
 * on output</param>
  </javadoc>
  <method type="void" name="resplit">
    <declaration type="double" name="c" />
    <declaration type="double" name="d" />
    <scope>
      <declaration type="double" name="z" />
    </scope>
    <scope>
      <declaration type="double" name="z" />
    </scope>
    <comment>MAGIC NUMBER</comment>
  </method>
  <javadoc>
    <text>Multiply two numbers in split form.</text>
    <param>a first term of multiplication</param>
    <param>b second term of multiplication</param>
    <param>ans placeholder where to put the result</param>
  </javadoc>
  <method type="void" name="splitMult">
    <comment>Resplit</comment>
  </method>
  <javadoc>
    <text>Add two numbers in split form.</text>
    <param>a first term of addition</param>
    <param>b second term of addition</param>
    <param>ans placeholder where to put the result</param>
  </javadoc>
  <method type="void" name="splitAdd" />
  <javadoc>
    <text>Compute the reciprocal of in.  Use the following algorithm.
 * in = c + d.
 * want to find x + y such that x+y = 1/(c+d) and x is much
 * larger than y and x has several zero bits on the right.
 * Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.
 * Use following identity to compute (a+b)/(c+d)
 * (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)
 * set x = a/c  and y = (bc - ad) / (c^2 + cd)
 * This will be close to the right answer, but there will be
 * some rounding in the calculation of X.  So by carefully
 * computing 1 - (c+d)(x+y) we can compute an error and
 * add that back in.   This is done carefully so that terms
 * of similar size are subtracted first.</text>
    <param>in initial number, in split form</param>
    <param>result placeholder where to put the result</param>
  </javadoc>
  <method type="void" name="splitReciprocal">
    <declaration type="double" name="b" />
    <declaration type="double" name="a" />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="err" />
    </scope>
    <comment>can happen if result[1] is NAN</comment>
    <comment>Resplit</comment>
    <comment>this may be overkill, probably once is enough</comment>
    <comment>err = 1.0 - err;</comment>
    <comment>printf("err = %16e\n", err);</comment>
  </method>
  <javadoc>
    <text>Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.</text>
    <param>a first term of the multiplication</param>
    <param>b second term of the multiplication</param>
    <param>result placeholder where to put the result</param>
  </javadoc>
  <method type="void" name="quadMult">
    <declaration type="double[]" name="xs" />
    <declaration type="double[]" name="ys" />
    <declaration type="double[]" name="zs" />
    <declaration type="double" name="tmp" />
    <comment>a[0]  b[0]</comment>
    <comment>a[0]  b[1]</comment>
    <comment>a[1]  b[0]</comment>
    <comment>a[1]  b[0]</comment>
  </method>
  <javadoc>
    <text>Compute exp(p) for a integer p in extended precision.</text>
    <param>p integer whose exponential is requested</param>
    <param>result placeholder where to put the result in extended precision</param>
    <return>exp(p) in standard precision (equal to result[0] + result[1])</return>
  </javadoc>
  <method type="double" name="expint">
    <declaration type="double[]" name="xs" />
    <declaration type="double[]" name="as" />
    <declaration type="double[]" name="ys" />
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>double x = M_E;</comment>
    <comment>split(x, xs);</comment>
    <comment>xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);</comment>
    <comment>xs[0] = 2.71827697753906250000;</comment>
    <comment>xs[1] = 4.85091998273542816811e-06;</comment>
    <comment>xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);</comment>
    <comment>xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);</comment>
    <comment>E</comment>
  </method>
  <javadoc>
    <text>xi in the range of [1, 2].
 * 3        5        7
 * x+1           /          x        x        x          \
 * ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
 * 1-x           \          3        5        7          /
 * So, compute a Remez approximation of the following function
 * ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x
 * This will be an even function with only positive coefficents.
 * x is in the range [0 - 1/3].
 * Transform xi for input to the above function by setting
 * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then
 * the result is multiplied by x.</text>
    <param>xi number from which log is requested</param>
    <return>log(xi)</return>
  </javadoc>
  <method type="double[]" name="slowLog">
    <declaration type="double[]" name="x" />
    <declaration type="double[]" name="x2" />
    <declaration type="double[]" name="y" />
    <declaration type="double[]" name="a" />
    <scope />
    <comment>Set X = (x-1)(x+1)</comment>
    <comment>Square X -&gt; X2</comment>
    <comment>x[0] -= 1.0;</comment>
    <comment>resplit(x);</comment>
  </method>
  <javadoc>
    <text>Print an array.</text>
    <param>out text output stream where output should be printed</param>
    <param>name array name</param>
    <param>expectedLen expected length of the array</param>
    <param>array2d array data</param>
  </javadoc>
  <method type="void" name="printarray">
    <declaration type="int" name="i" />
    <scope>
      <scope />
    </scope>
    <comment>"double array[]" causes PMD parsing error</comment>
    <comment>assume inner array has very few entries</comment>
    <comment>multiple entries per line</comment>
  </method>
  <javadoc>
    <text>Print an array.</text>
    <param>out text output stream where output should be printed</param>
    <param>name array name</param>
    <param>expectedLen expected length of the array</param>
    <param>array array data</param>
  </javadoc>
  <method type="void" name="printarray">
    <scope />
    <comment>one entry per line</comment>
  </method>
  <javadoc>
    <text>Format a double.</text>
    <param>d double number to format</param>
    <return>formatted number</return>
  </javadoc>
  <method type="String" name="format">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Check two lengths are equal.</text>
    <param>expectedLen expected length</param>
    <param>actual actual length</param>
    <exception>DimensionMismatchException if the two lengths are not equal</exception>
  </javadoc>
  <method type="void" name="checkLen">
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>1073741824L</comment>
  <comment>0</comment>
  <comment>1</comment>
  <comment>2</comment>
  <comment>3</comment>
  <comment>4</comment>
  <comment>5</comment>
  <comment>6</comment>
  <comment>7</comment>
  <comment>8</comment>
  <comment>9</comment>
  <comment>10</comment>
  <comment>11</comment>
  <comment>12</comment>
  <comment>13</comment>
  <comment>14</comment>
  <comment>15</comment>
  <comment>16</comment>
  <comment>17</comment>
  <comment>18</comment>
  <comment>19</comment>
</class>
