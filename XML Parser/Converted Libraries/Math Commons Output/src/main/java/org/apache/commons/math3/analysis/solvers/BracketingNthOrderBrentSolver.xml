<?xml version="1.0" encoding="UTF-8"?>
<class name="BracketingNthOrderBrentSolver">
  <javadoc>
    <text>This class implements a modification of the &lt;a
 * href="http://mathworld.wolfram.com/BrentsMethod.html"&gt; Brent algorithm&lt;/a&gt;.
 * &lt;p&gt;
 * The changes with respect to the original Brent algorithm are:
 * &lt;ul&gt;
 * &lt;li&gt;the returned value is chosen in the current interval according
 * to user specified {@link AllowedSolution},&lt;/li&gt;
 * &lt;li&gt;the maximal order for the invert polynomial root search is
 * user-specified instead of being invert quadratic only&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * The given interval must bracket the root.</text>
    <version>$Id: BracketingNthOrderBrentSolver.java 1379560 2012-08-31 19:40:30Z erans $</version>
  </javadoc>
  <javadoc>
    <text>Default absolute accuracy.</text>
  </javadoc>
  <declaration type="double" name="DEFAULT_ABSOLUTE_ACCURACY" />
  <javadoc>
    <text>Default maximal order.</text>
  </javadoc>
  <declaration type="int" name="DEFAULT_MAXIMAL_ORDER" />
  <javadoc>
    <text>Maximal aging triggering an attempt to balance the bracketing interval.</text>
  </javadoc>
  <declaration type="int" name="MAXIMAL_AGING" />
  <javadoc>
    <text>Reduction factor for attempts to balance the bracketing interval.</text>
  </javadoc>
  <declaration type="double" name="REDUCTION_FACTOR" />
  <javadoc>
    <text>Maximal order.</text>
  </javadoc>
  <declaration type="int" name="maximalOrder" />
  <javadoc>
    <text>The kinds of solutions that the algorithm may accept.</text>
  </javadoc>
  <declaration type="AllowedSolution" name="allowed" />
  <javadoc>
    <text>Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)</text>
  </javadoc>
  <method type="constructor" name="BracketingNthOrderBrentSolver" />
  <javadoc>
    <text>Construct a solver.</text>
    <param>absoluteAccuracy Absolute accuracy.</param>
    <param>maximalOrder maximal order.</param>
    <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
  </javadoc>
  <method type="constructor" name="BracketingNthOrderBrentSolver">
    <scope />
  </method>
  <javadoc>
    <text>Construct a solver.</text>
    <param>relativeAccuracy Relative accuracy.</param>
    <param>absoluteAccuracy Absolute accuracy.</param>
    <param>maximalOrder maximal order.</param>
    <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
  </javadoc>
  <method type="constructor" name="BracketingNthOrderBrentSolver">
    <scope />
  </method>
  <javadoc>
    <text>Construct a solver.</text>
    <param>relativeAccuracy Relative accuracy.</param>
    <param>absoluteAccuracy Absolute accuracy.</param>
    <param>functionValueAccuracy Function value accuracy.</param>
    <param>maximalOrder maximal order.</param>
    <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
  </javadoc>
  <method type="constructor" name="BracketingNthOrderBrentSolver">
    <scope />
  </method>
  <javadoc>
    <text>Get the maximal order.</text>
    <return>maximal order</return>
  </javadoc>
  <method type="int" name="getMaximalOrder" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="doSolve">
    <declaration type="double[]" name="x" />
    <declaration type="double[]" name="y" />
    <scope />
    <scope />
    <declaration type="int" name="nbPoints" />
    <declaration type="int" name="signChangeIndex" />
    <scope />
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <declaration type="double[]" name="tmpX" />
    <declaration type="double" name="xA" />
    <declaration type="double" name="yA" />
    <declaration type="double" name="absYA" />
    <declaration type="int" name="agingA" />
    <declaration type="double" name="xB" />
    <declaration type="double" name="yB" />
    <declaration type="double" name="absYB" />
    <declaration type="int" name="agingB" />
    <scope>
      <declaration type="double" name="xTol" />
      <scope />
      <declaration type="double" name="targetY" />
      <scope>
        <declaration type="int" name="p" />
        <declaration type="double" name="weightA" />
        <declaration type="double" name="weightB" />
      </scope>
      <scope>
        <declaration type="int" name="p" />
        <declaration type="double" name="weightA" />
        <declaration type="double" name="weightB" />
      </scope>
      <scope />
      <declaration type="double" name="nextX" />
      <declaration type="int" name="start" />
      <declaration type="int" name="end" />
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <scope />
      <declaration type="double" name="nextY" />
      <scope />
      <scope />
      <scope>
        <scope />
      </scope>
      <scope />
      <scope />
    </scope>
    <comment>prepare arrays with the first points</comment>
    <comment>evaluate initial guess</comment>
    <comment>return the initial guess if it is a perfect root.</comment>
    <comment>evaluate first  endpoint</comment>
    <comment>return the first endpoint if it is a perfect root.</comment>
    <comment>reduce interval if it brackets the root</comment>
    <comment>evaluate second endpoint</comment>
    <comment>return the second endpoint if it is a perfect root.</comment>
    <comment>use all computed point as a start sampling array for solving</comment>
    <comment>prepare a work array for inverse polynomial interpolation</comment>
    <comment>current tightest bracketing of the root</comment>
    <comment>search loop</comment>
    <comment>check convergence of bracketing interval</comment>
    <comment>this should never happen</comment>
    <comment>target for the next evaluation point</comment>
    <comment>we keep updating the high bracket, try to compensate this</comment>
    <comment>we keep updating the low bracket, try to compensate this</comment>
    <comment>bracketing is balanced, try to find the root itself</comment>
    <comment>make a few attempts to guess a root,</comment>
    <comment>guess a value for current target, using inverse polynomial interpolation</comment>
    <comment>the guessed root is not strictly inside of the tightest bracketing interval</comment>
    <comment>the guessed root is either not strictly inside the interval or it</comment>
    <comment>is a NaN (which occurs when some sampling points share the same y)</comment>
    <comment>we try again with a lower interpolation order</comment>
    <comment>we have more points before the sign change, drop the lowest point</comment>
    <comment>we have more points after sign change, drop the highest point</comment>
    <comment>we need to do one more attempt</comment>
    <comment>fall back to bisection</comment>
    <comment>evaluate the function at the guessed root</comment>
    <comment>we have found an exact root, since it is not an approximation</comment>
    <comment>we don't need to bother about the allowed solutions setting</comment>
    <comment>we have been forced to ignore some points to keep bracketing,</comment>
    <comment>they are probably too far from the root, drop them from now on</comment>
    <comment>we have to drop one point in order to insert the new one</comment>
    <comment>keep the tightest bracketing interval as centered as possible</comment>
    <comment>we drop the lowest point, we have to shift the arrays and the index</comment>
    <comment>insert the last computed point</comment>
    <comment>(by construction, we know it lies inside the tightest bracketing interval)</comment>
    <comment>update the bracketing interval</comment>
    <comment>the sign change occurs before the inserted point</comment>
    <comment>the sign change occurs after the inserted point</comment>
    <comment>update the sign change index</comment>
  </method>
  <javadoc>
    <text>Guess an x value by n&lt;sup&gt;th&lt;/sup&gt; order inverse polynomial interpolation.
 * &lt;p&gt;
 * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
 * is built such that for all considered points (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;),
 * Q(y&lt;sub&gt;i&lt;/sub&gt;) = x&lt;sub&gt;i&lt;/sub&gt;.
 * &lt;/p&gt;</text>
    <param>targetY target value for y</param>
    <param>x reference points abscissas for interpolation,
 * note that this array &lt;em&gt;is&lt;/em&gt; modified during computation</param>
    <param>y reference points ordinates for interpolation</param>
    <param>start start index of the points to consider (inclusive)</param>
    <param>end end index of the points to consider (exclusive)</param>
    <return>guessed root (will be a NaN if two points share the same y)</return>
  </javadoc>
  <method type="double" name="guessX">
    <scope>
      <declaration type="int" name="delta" />
      <scope />
    </scope>
    <declaration type="double" name="x0" />
    <scope />
    <comment>compute Q Newton coefficients by divided differences</comment>
    <comment>evaluate Q(targetY)</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="solve" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="solve" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
