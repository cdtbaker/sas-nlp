<?xml version="1.0" encoding="UTF-8"?>
<class name="AdaptiveStepsizeIntegrator">
  <javadoc>
    <text>This abstract class holds the common part of all adaptive
 * stepsize integrators for Ordinary Differential Equations.
 * &lt;p&gt;These algorithms perform integration with stepsize control, which
 * means the user does not specify the integration step but rather a
 * tolerance on error. The error threshold is computed as
 * &lt;pre&gt;
 * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))
 * &lt;/pre&gt;
 * where absTol_i is the absolute tolerance for component i of the
 * state vector and relTol_i is the relative tolerance for the same
 * component. The user can also use only two scalar values absTol and
 * relTol which will be used for all components.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the Ordinary Differential Equations is an {@link ExpandableStatefulODEextended ODE} rather than a {@link org.apache.commons.math3.ode.FirstOrderDifferentialEquations basic ODE}, then
 * &lt;em&gt;only&lt;/em&gt; the {@link ExpandableStatefulODE#getPrimaryState() primary part}of the state vector is used for stepsize control, not the complete state vector.
 * &lt;/p&gt;
 * &lt;p&gt;If the estimated error for ym+1 is such that
 * &lt;pre&gt;
 * sqrt((sum (errEst_i / threshold_i)^2 ) / n) &lt; 1
 * &lt;/pre&gt;
 * (where n is the main set dimension) then the step is accepted,
 * otherwise the step is rejected and a new attempt is made with a new
 * stepsize.&lt;/p&gt;</text>
    <version>$Id: AdaptiveStepsizeIntegrator.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Allowed absolute scalar error.</text>
  </javadoc>
  <declaration type="double" name="scalAbsoluteTolerance" />
  <javadoc>
    <text>Allowed relative scalar error.</text>
  </javadoc>
  <declaration type="double" name="scalRelativeTolerance" />
  <javadoc>
    <text>Allowed absolute vectorial error.</text>
  </javadoc>
  <declaration type="double[]" name="vecAbsoluteTolerance" />
  <javadoc>
    <text>Allowed relative vectorial error.</text>
  </javadoc>
  <declaration type="double[]" name="vecRelativeTolerance" />
  <javadoc>
    <text>Main set dimension.</text>
  </javadoc>
  <declaration type="int" name="mainSetDimension" />
  <javadoc>
    <text>User supplied initial step.</text>
  </javadoc>
  <declaration type="double" name="initialStep" />
  <javadoc>
    <text>Minimal step.</text>
  </javadoc>
  <declaration type="double" name="minStep" />
  <javadoc>
    <text>Maximal step.</text>
  </javadoc>
  <declaration type="double" name="maxStep" />
  <javadoc>
    <text>Build an integrator with the given stepsize bounds.
 * The default step handler does nothing.</text>
    <param>name name of the method</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>scalAbsoluteTolerance allowed absolute error</param>
    <param>scalRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="AdaptiveStepsizeIntegrator" />
  <javadoc>
    <text>Build an integrator with the given stepsize bounds.
 * The default step handler does nothing.</text>
    <param>name name of the method</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>vecAbsoluteTolerance allowed absolute error</param>
    <param>vecRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="AdaptiveStepsizeIntegrator" />
  <javadoc>
    <text>Set the adaptive step size control parameters.
 * &lt;p&gt;
 * A side effect of this method is to also reset the initial
 * step so it will be automatically computed by the integrator
 * if {@link #setInitialStepSize(double) setInitialStepSize}is not called by the user.
 * &lt;/p&gt;</text>
    <param>minimalStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
    <param>maximalStep maximal step (must be positive even for backward
 * integration)</param>
    <param>absoluteTolerance allowed absolute error</param>
    <param>relativeTolerance allowed relative error</param>
  </javadoc>
  <method type="void" name="setStepSizeControl" />
  <javadoc>
    <text>Set the adaptive step size control parameters.
 * &lt;p&gt;
 * A side effect of this method is to also reset the initial
 * step so it will be automatically computed by the integrator
 * if {@link #setInitialStepSize(double) setInitialStepSize}is not called by the user.
 * &lt;/p&gt;</text>
    <param>minimalStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
    <param>maximalStep maximal step (must be positive even for backward
 * integration)</param>
    <param>absoluteTolerance allowed absolute error</param>
    <param>relativeTolerance allowed relative error</param>
  </javadoc>
  <method type="void" name="setStepSizeControl" />
  <javadoc>
    <text>Set the initial step size.
 * &lt;p&gt;This method allows the user to specify an initial positive
 * step size instead of letting the integrator guess it by
 * itself. If this method is not called before integration is
 * started, the initial step size will be estimated by the
 * integrator.&lt;/p&gt;</text>
    <param>initialStepSize initial step size to use (must be positive even
 * for backward integration ; providing a negative value or a value
 * outside of the min/max step interval will lead the integrator to
 * ignore the value and compute the initial step size by itself)</param>
  </javadoc>
  <method type="void" name="setInitialStepSize">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="sanityChecks">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Initialize the integration step.</text>
    <param>forward forward integration indicator</param>
    <param>order order of the method</param>
    <param>scale scaling vector for the state vector (can be shorter than state vector)</param>
    <param>t0 start time</param>
    <param>y0 state vector at t0</param>
    <param>yDot0 first time derivative of y0</param>
    <param>y1 work array for a state vector</param>
    <param>yDot1 work array for the first time derivative of y1</param>
    <return>first integration step</return>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    <exception>DimensionMismatchException if arrays dimensions do not match equations settings</exception>
  </javadoc>
  <method type="double" name="initializeStep">
    <scope />
    <declaration type="double" name="ratio" />
    <declaration type="double" name="yOnScale2" />
    <declaration type="double" name="yDotOnScale2" />
    <scope />
    <declaration type="double" name="h" />
    <scope />
    <scope />
    <declaration type="double" name="yDDotOnScale" />
    <scope />
    <declaration type="double" name="maxInv2" />
    <declaration type="double" name="h1" />
    <scope />
    <scope />
    <scope />
    <comment>use the user provided value</comment>
    <comment>very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||</comment>
    <comment>this guess will be used to perform an Euler step</comment>
    <comment>perform an Euler step using the preceding rough guess</comment>
    <comment>estimate the second derivative of the solution</comment>
    <comment>step size is computed such that</comment>
    <comment>h^order * max (||y'/tol||, ||y''/tol||) = 0.01</comment>
    <comment>avoids cancellation when computing t1 - t0</comment>
  </method>
  <javadoc>
    <text>Filter the integration step.</text>
    <param>h signed step</param>
    <param>forward forward integration indicator</param>
    <param>acceptSmall if true, steps smaller than the minimal value
 * are silently increased up to this value, if false such small
 * steps generate an exception</param>
    <return>a bounded integration step (h if no bound is reach, or a bounded value)</return>
    <exception>NumberIsTooSmallException if the step is too small and acceptSmall is false</exception>
  </javadoc>
  <method type="double" name="filterStep">
    <declaration type="double" name="filteredH" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
  </method>
  <method name="integrate" type="void" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getCurrentStepStart" />
  <javadoc>
    <text>Reset internal state to dummy values.</text>
  </javadoc>
  <method type="void" name="resetInternalState" />
  <javadoc>
    <text>Get the minimal step.</text>
    <return>minimal step</return>
  </javadoc>
  <method type="double" name="getMinStep" />
  <javadoc>
    <text>Get the maximal step.</text>
    <return>maximal step</return>
  </javadoc>
  <method type="double" name="getMaxStep" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
