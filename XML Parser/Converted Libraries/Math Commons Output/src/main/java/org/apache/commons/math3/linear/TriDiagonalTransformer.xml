<?xml version="1.0" encoding="UTF-8"?>
<class name="TriDiagonalTransformer">
  <javadoc>
    <text>Class transforming a symmetrical matrix to tridiagonal shape.
 * &lt;p&gt;A symmetrical m &amp;times; m matrix A can be written as the product of three matrices:
 * A = Q &amp;times; T &amp;times; Q&lt;sup&gt;T&lt;/sup&gt; with Q an orthogonal matrix and T a symmetrical
 * tridiagonal matrix. Both Q and T are m &amp;times; m matrices.&lt;/p&gt;
 * &lt;p&gt;This implementation only uses the upper part of the matrix, the part below the
 * diagonal is not accessed at all.&lt;/p&gt;
 * &lt;p&gt;Transformation to tridiagonal shape is often not a goal by itself, but it is
 * an intermediate step in more general decomposition algorithms like {@link EigenDecomposition eigen decomposition}. This class is therefore intended for internal
 * use by the library and is not public. As a consequence of this explicitly limited scope,
 * many methods directly returns references to internal arrays, not copies.&lt;/p&gt;</text>
    <version>$Id: TriDiagonalTransformer.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Householder vectors.</text>
  </javadoc>
  <declaration type="double" name="householderVectors" />
  <javadoc>
    <text>Main diagonal.</text>
  </javadoc>
  <declaration type="double[]" name="main" />
  <javadoc>
    <text>Secondary diagonal.</text>
  </javadoc>
  <declaration type="double[]" name="secondary" />
  <javadoc>
    <text>Cached value of Q.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedQ" />
  <javadoc>
    <text>Cached value of Qt.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedQt" />
  <javadoc>
    <text>Cached value of T.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedT" />
  <javadoc>
    <text>Build the transformation to tridiagonal shape of a symmetrical matrix.
 * &lt;p&gt;The specified matrix is assumed to be symmetrical without any check.
 * Only the upper triangular part of the matrix is used.&lt;/p&gt;</text>
    <param>matrix Symmetrical matrix to transform.</param>
    <throws>NonSquareMatrixException if the matrix is not square.</throws>
  </javadoc>
  <method type="constructor" name="TriDiagonalTransformer">
    <scope />
    <declaration type="int" name="m" />
    <comment>transform matrix</comment>
  </method>
  <javadoc>
    <text>Returns the matrix Q of the transform.
 * &lt;p&gt;Q is an orthogonal matrix, i.e. its transpose is also its inverse.&lt;/p&gt;</text>
    <return>the Q matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getQ">
    <scope />
  </method>
  <javadoc>
    <text>Returns the transpose of the matrix Q of the transform.
 * &lt;p&gt;Q is an orthogonal matrix, i.e. its transpose is also its inverse.&lt;/p&gt;</text>
    <return>the Q matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getQT">
    <scope>
      <declaration type="int" name="m" />
      <declaration type="double[][]" name="qta" />
      <scope>
        <declaration type="double[]" name="hK" />
        <scope>
          <declaration type="double" name="inv" />
          <declaration type="double" name="beta" />
          <scope />
          <scope>
            <scope />
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>build up first part of the matrix by applying Householder transforms</comment>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the tridiagonal matrix T of the transform.</text>
    <return>the T matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getT">
    <scope>
      <declaration type="int" name="m" />
      <declaration type="double[][]" name="ta" />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Get the Householder vectors of the transform.
 * &lt;p&gt;Note that since this class is only intended for internal use,
 * it returns directly a reference to its internal arrays, not a copy.&lt;/p&gt;</text>
    <return>the main diagonal elements of the B matrix</return>
  </javadoc>
  <method type="double[][]" name="getHouseholderVectorsRef" />
  <javadoc>
    <text>Get the main diagonal elements of the matrix T of the transform.
 * &lt;p&gt;Note that since this class is only intended for internal use,
 * it returns directly a reference to its internal arrays, not a copy.&lt;/p&gt;</text>
    <return>the main diagonal elements of the T matrix</return>
  </javadoc>
  <method type="double[]" name="getMainDiagonalRef" />
  <javadoc>
    <text>Get the secondary diagonal elements of the matrix T of the transform.
 * &lt;p&gt;Note that since this class is only intended for internal use,
 * it returns directly a reference to its internal arrays, not a copy.&lt;/p&gt;</text>
    <return>the secondary diagonal elements of the T matrix</return>
  </javadoc>
  <method type="double[]" name="getSecondaryDiagonalRef" />
  <javadoc>
    <text>Transform original matrix to tridiagonal form.
 * &lt;p&gt;Transformation is done using Householder transforms.&lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="transform">
    <declaration type="int" name="m" />
    <declaration type="double[]" name="z" />
    <scope>
      <declaration type="double[]" name="hK" />
      <declaration type="double" name="xNormSqr" />
      <scope>
        <declaration type="double" name="c" />
      </scope>
      <declaration type="double" name="a" />
      <scope>
        <declaration type="double" name="beta" />
        <scope>
          <declaration type="double[]" name="hI" />
          <declaration type="double" name="hKI" />
          <declaration type="double" name="zI" />
          <scope>
            <declaration type="double" name="hIJ" />
          </scope>
        </scope>
        <declaration type="double" name="gamma" />
        <scope />
        <scope />
        <scope>
          <declaration type="double[]" name="hI" />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>zero-out a row and a column simultaneously</comment>
    <comment>apply Householder transform from left and right simultaneously</comment>
    <comment>compute a = beta A v, where v is the Householder vector</comment>
    <comment>this loop is written in such a way</comment>
    <comment>1) only the upper triangular part of the matrix is accessed</comment>
    <comment>2) access is cache-friendly for a matrix stored in rows</comment>
    <comment>compute gamma = beta vT z / 2</comment>
    <comment>compute z = z - gamma v</comment>
    <comment>update matrix: A = A - v zT - z vT</comment>
    <comment>only the upper triangular part of the matrix is updated</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
