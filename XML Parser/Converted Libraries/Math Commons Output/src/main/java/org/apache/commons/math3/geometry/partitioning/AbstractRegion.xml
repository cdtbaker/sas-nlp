<?xml version="1.0" encoding="UTF-8"?>
<class name="AbstractRegion">
  <javadoc>
    <text>Abstract class for all regions, independently of geometry type or dimension.</text>
    <param>&lt;S&gt;
 *  Type of the space.</param>
    <param>&lt;T&gt;
 *  Type of the sub-space.</param>
    <version>$Id: AbstractRegion.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Inside/Outside BSP tree.</text>
  </javadoc>
  <declaration type="BSPTree&lt;S&gt;" name="tree" />
  <javadoc>
    <text>Size of the instance.</text>
  </javadoc>
  <declaration type="double" name="size" />
  <javadoc>
    <text>Barycenter.</text>
  </javadoc>
  <declaration type="Vector&lt;S&gt;" name="barycenter" />
  <javadoc>
    <text>Build a region representing the whole space.</text>
  </javadoc>
  <method type="constructor" name="AbstractRegion" />
  <javadoc>
    <text>Build a region from an inside/outside BSP tree.
 * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
 * tree also &lt;em&gt;must&lt;/em&gt; have either null internal nodes or
 * internal nodes representing the boundary as specified in the{@link #getTree getTree} method).&lt;/p&gt;</text>
    <param>tree inside/outside BSP tree representing the region</param>
  </javadoc>
  <method type="constructor" name="AbstractRegion" />
  <javadoc>
    <text>Build a Region from a Boundary REPresentation (B-rep).
 * &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.&lt;/p&gt;
 * &lt;p&gt;The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polygons with holes
 * or a set of disjoints polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link #checkPoint(Vector) checkPoint} method will not be
 * meaningful anymore.&lt;/p&gt;
 * &lt;p&gt;If the boundary is empty, the region will represent the whole
 * space.&lt;/p&gt;</text>
    <param>boundary collection of boundary elements, as a
 * collection of {@link SubHyperplane SubHyperplane} objects</param>
  </javadoc>
  <method type="constructor" name="AbstractRegion">
    <scope />
    <scope>
      <declaration type="TreeSet&lt;SubHyperplane&lt;S&gt;&gt;" name="ordered" />
      <method type="int" name="compare">
        <declaration type="double" name="size1" />
        <declaration type="double" name="size2" />
      </method>
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="Order" name="visitOrder" />
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visitInternalNode" />
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visitLeafNode" />
    </scope>
    <comment>the tree represents the whole space</comment>
    <comment>sort the boundary elements in decreasing size order</comment>
    <comment>(we don't want equal size elements to be removed, so</comment>
    <comment>we use a trick to fool the TreeSet)</comment>
    <comment>build the tree top-down</comment>
    <comment>set up the inside/outside flags</comment>
  </method>
  <javadoc>
    <text>Build a convex region from an array of bounding hyperplanes.</text>
    <param>hyperplanes array of bounding hyperplanes (if null, an
 * empty region will be built)</param>
  </javadoc>
  <method type="constructor" name="AbstractRegion">
    <scope />
    <scope>
      <declaration type="BSPTree&lt;S&gt;" name="node" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>use the first hyperplane to build the right class</comment>
    <comment>chop off parts of the space</comment>
  </method>
  <method name="buildNew" type="AbstractRegion&lt;S,T&gt;" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <javadoc>
    <text>Recursively build a tree by inserting cut sub-hyperplanes.</text>
    <param>node current tree node (it is a leaf node at the beginning
 * of the call)</param>
    <param>boundary collection of edges belonging to the cell defined
 * by the node</param>
  </javadoc>
  <method type="void" name="insertCuts">
    <declaration type="Iterator&lt;SubHyperplane&lt;S&gt;&gt;" name="iterator" />
    <declaration type="Hyperplane&lt;S&gt;" name="inserted" />
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="ArrayList&lt;SubHyperplane&lt;S&gt;&gt;" name="plusList" />
    <declaration type="ArrayList&lt;SubHyperplane&lt;S&gt;&gt;" name="minusList" />
    <scope>
      <declaration type="SubHyperplane&lt;S&gt;" name="other" />
      <declaration type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" name="split" />
    </scope>
    <comment>build the current level</comment>
    <comment>distribute the remaining edges in the two sub-trees</comment>
    <comment>ignore the sub-hyperplanes belonging to the cut hyperplane</comment>
    <comment>recurse through lower levels</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="AbstractRegion&lt;S,T&gt;" name="copySelf" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isEmpty" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isEmpty">
    <scope />
    <comment>we use a recursive function rather than the BSPTreeVisitor</comment>
    <comment>interface because we can stop visiting the tree as soon as we</comment>
    <comment>have found an inside cell</comment>
    <comment>if we find an inside node, the region is not empty</comment>
    <comment>check both sides of the sub-tree</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="contains" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Location" name="checkPoint" />
  <javadoc>
    <text>Check a point with respect to the region starting at a given node.</text>
    <param>node root node of the region</param>
    <param>point point to check</param>
    <return>a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDEOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}</return>
  </javadoc>
  <method type="Location" name="checkPoint">
    <declaration type="BSPTree&lt;S&gt;" name="cell" />
    <scope />
    <declaration type="Location" name="minusCode" />
    <declaration type="Location" name="plusCode" />
    <comment>the point is in the interior of a cell, just check the attribute</comment>
    <comment>the point is on a cut-sub-hyperplane, is it on a boundary ?</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="getTree">
    <scope />
    <comment>we need to compute the boundary attributes</comment>
  </method>
  <javadoc>
    <text>Visitor building boundary shell tree.
 * &lt;p&gt;
 * The boundary shell is represented as {@link BoundaryAttribute boundary attributes}at each internal node.
 * &lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Order" name="visitOrder" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitInternalNode">
    <declaration type="SubHyperplane&lt;S&gt;" name="plusOutside" />
    <declaration type="SubHyperplane&lt;S&gt;" name="plusInside" />
    <declaration type="SubHyperplane&lt;S&gt;[][]" name="plusChar" />
    <scope>
      <declaration type="SubHyperplane&lt;S&gt;[][]" name="minusChar" />
      <scope />
    </scope>
    <scope>
      <declaration type="SubHyperplane&lt;S&gt;[][]" name="minusChar" />
      <scope />
    </scope>
    <comment>characterize the cut sub-hyperplane,</comment>
    <comment>first with respect to the plus sub-tree</comment>
    <comment>plusChar[0] corresponds to a subset of the cut sub-hyperplane known to have</comment>
    <comment>outside cells on its plus side, we want to check if parts of this subset</comment>
    <comment>do have inside cells on their minus side</comment>
    <comment>this part belongs to the boundary,</comment>
    <comment>it has the outside on its plus side and the inside on its minus side</comment>
    <comment>plusChar[1] corresponds to a subset of the cut sub-hyperplane known to have</comment>
    <comment>inside cells on its plus side, we want to check if parts of this subset</comment>
    <comment>do have outside cells on their minus side</comment>
    <comment>this part belongs to the boundary,</comment>
    <comment>it has the inside on its plus side and the outside on its minus side</comment>
    <comment>set the boundary attribute at non-leaf nodes</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitLeafNode" />
  <javadoc>
    <text>Filter the parts of an hyperplane belonging to the boundary.
 * &lt;p&gt;The filtering consist in splitting the specified
 * sub-hyperplane into several parts lying in inside and outside
 * cells of the tree. The principle is to call this method twice for
 * each cut sub-hyperplane in the tree, once one the plus node and
 * once on the minus node. The parts that have the same flag
 * (inside/inside or outside/outside) do not belong to the boundary
 * while parts that have different flags (inside/outside or
 * outside/inside) do belong to the boundary.&lt;/p&gt;</text>
    <param>node current BSP tree node</param>
    <param>sub sub-hyperplane to characterize</param>
    <param>characterization placeholder where to put the characterized parts</param>
  </javadoc>
  <method type="void" name="characterize">
    <scope>
      <declaration type="boolean" name="inside" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="Hyperplane&lt;S&gt;" name="hyperplane" />
      <declaration type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" name="split" />
    </scope>
    <comment>we have reached a leaf node</comment>
    <comment>this should not happen</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getBoundarySize">
    <declaration type="BoundarySizeVisitor&lt;S&gt;" name="visitor" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getSize">
    <scope />
  </method>
  <javadoc>
    <text>Set the size of the instance.</text>
    <param>size size of the instance</param>
  </javadoc>
  <method type="void" name="setSize" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector&lt;S&gt;" name="getBarycenter">
    <scope />
  </method>
  <javadoc>
    <text>Set the barycenter of the instance.</text>
    <param>barycenter barycenter of the instance</param>
  </javadoc>
  <method type="void" name="setBarycenter" />
  <method name="computeGeometricalProperties" type="void" />
  <javadoc>
    <text>Compute some geometrical properties.
 * &lt;p&gt;The properties to compute are the barycenter and the size.&lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Side" name="side">
    <declaration type="Sides" name="sides" />
  </method>
  <javadoc>
    <text>Search recursively for inside leaf nodes on each side of the given hyperplane.
 * &lt;p&gt;The algorithm used here is directly derived from the one
 * described in section III (&lt;i&gt;Binary Partitioning of a BSP
 * Tree&lt;/i&gt;) of the Bruce Naylor, John Amanatides and William
 * Thibault paper &lt;a
 * href="http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf"&gt;Merging
 * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph
 * '90, Computer Graphics 24(4), August 1990, pp 115-124, published
 * by the Association for Computing Machinery (ACM)..&lt;/p&gt;</text>
    <param>node current BSP tree node</param>
    <param>sub sub-hyperplane</param>
    <param>sides object holding the sides found</param>
  </javadoc>
  <method type="void" name="recurseSides">
    <scope>
      <scope />
    </scope>
    <declaration type="Hyperplane&lt;S&gt;" name="hyperplane" />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" name="split" />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>this is an inside cell expanding across the hyperplane</comment>
    <comment>the sub-hyperplane is entirely in the plus sub-tree</comment>
    <comment>the sub-hyperplane is entirely in the minus sub-tree</comment>
    <comment>the sub-hyperplane extends in both sub-trees</comment>
    <comment>explore first the plus sub-tree</comment>
    <comment>if needed, explore the minus sub-tree</comment>
    <comment>the sub-hyperplane and the cut sub-hyperplane share the same hyperplane</comment>
  </method>
  <javadoc>
    <text>Utility class holding the already found sides.</text>
  </javadoc>
  <javadoc>
    <text>Indicator of inside leaf nodes found on the plus side.</text>
  </javadoc>
  <declaration type="boolean" name="plusFound" />
  <javadoc>
    <text>Indicator of inside leaf nodes found on the plus side.</text>
  </javadoc>
  <declaration type="boolean" name="minusFound" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="Sides" />
  <javadoc>
    <text>Remember the fact that inside leaf nodes have been found on the plus side.</text>
  </javadoc>
  <method type="void" name="rememberPlusFound" />
  <javadoc>
    <text>Check if inside leaf nodes have been found on the plus side.</text>
    <return>true if inside leaf nodes have been found on the plus side</return>
  </javadoc>
  <method type="boolean" name="plusFound" />
  <javadoc>
    <text>Remember the fact that inside leaf nodes have been found on the minus side.</text>
  </javadoc>
  <method type="void" name="rememberMinusFound" />
  <javadoc>
    <text>Check if inside leaf nodes have been found on the minus side.</text>
    <return>true if inside leaf nodes have been found on the minus side</return>
  </javadoc>
  <method type="boolean" name="minusFound" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="SubHyperplane&lt;S&gt;" name="intersection" />
  <javadoc>
    <text>Recursively compute the parts of a sub-hyperplane that are
 * contained in the region.</text>
    <param>node current BSP tree node</param>
    <param>sub sub-hyperplane traversing the region</param>
    <return>filtered sub-hyperplane</return>
  </javadoc>
  <method type="SubHyperplane&lt;S&gt;" name="recurseIntersection">
    <scope />
    <declaration type="Hyperplane&lt;S&gt;" name="hyperplane" />
    <declaration type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" name="split" />
    <declaration type="SubHyperplane&lt;S&gt;" name="plus" />
    <declaration type="SubHyperplane&lt;S&gt;" name="minus" />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Transform a region.
 * &lt;p&gt;Applying a transform to a region consist in applying the
 * transform to all the hyperplanes of the underlying BSP tree and
 * of the boundary (and also to the sub-hyperplanes embedded in
 * these hyperplanes) and to the barycenter. The instance is not
 * modified, a new instance is built.&lt;/p&gt;</text>
    <param>transform transform to apply</param>
    <return>a new region, resulting from the application of the
 * transform to the instance</return>
  </javadoc>
  <method type="AbstractRegion&lt;S,T&gt;" name="applyTransform" />
  <javadoc>
    <text>Recursively transform an inside/outside BSP-tree.</text>
    <param>node current BSP tree node</param>
    <param>transform transform to apply</param>
    <return>a new tree</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="recurseTransform">
    <scope />
    <declaration type="SubHyperplane&lt;S&gt;" name="sub" />
    <declaration type="SubHyperplane&lt;S&gt;" name="tSub" />
    <declaration type="BoundaryAttribute&lt;S&gt;" name="attribute" />
    <scope>
      <declaration type="SubHyperplane&lt;S&gt;" name="tPO" />
      <declaration type="SubHyperplane&lt;S&gt;" name="tPI" />
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
