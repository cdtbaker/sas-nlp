<?xml version="1.0" encoding="UTF-8"?>
<class name="MultistepIntegrator">
  <javadoc>
    <text>This class is the base class for multistep integrators for Ordinary
 * Differential Equations.
 * &lt;p&gt;We define scaled derivatives s&lt;sub&gt;i&lt;/sub&gt;(n) at step n as:
 * &lt;pre&gt;
 * s&lt;sub&gt;1&lt;/sub&gt;(n) = h y'&lt;sub&gt;n&lt;/sub&gt; for first derivative
 * s&lt;sub&gt;2&lt;/sub&gt;(n) = h&lt;sup&gt;2&lt;/sup&gt;/2 y''&lt;sub&gt;n&lt;/sub&gt; for second derivative
 * s&lt;sub&gt;3&lt;/sub&gt;(n) = h&lt;sup&gt;3&lt;/sup&gt;/6 y'''&lt;sub&gt;n&lt;/sub&gt; for third derivative
 * ...
 * s&lt;sub&gt;k&lt;/sub&gt;(n) = h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;&lt;sub&gt;n&lt;/sub&gt; for k&lt;sup&gt;th&lt;/sup&gt; derivative
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;Rather than storing several previous steps separately, this implementation uses
 * the Nordsieck vector with higher degrees scaled derivatives all taken at the same
 * step (y&lt;sub&gt;n&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;(n) and r&lt;sub&gt;n&lt;/sub&gt;) where r&lt;sub&gt;n&lt;/sub&gt; is defined as:
 * &lt;pre&gt;
 * r&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;2&lt;/sub&gt;(n), s&lt;sub&gt;3&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n) ]&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/pre&gt;
 * (we omit the k index in the notation for clarity)&lt;/p&gt;
 * &lt;p&gt;
 * Multistep integrators with Nordsieck representation are highly sensitive to
 * large step changes because when the step is multiplied by factor a, the
 * k&lt;sup&gt;th&lt;/sup&gt; component of the Nordsieck vector is multiplied by a&lt;sup&gt;k&lt;/sup&gt;
 * and the last components are the least accurate ones. The default max growth
 * factor is therefore set to a quite low value: 2&lt;sup&gt;1/order&lt;/sup&gt;.
 * &lt;/p&gt;</text>
    <see>org.apache.commons.math3.ode.nonstiff.AdamsBashforthIntegrator</see>
    <see>org.apache.commons.math3.ode.nonstiff.AdamsMoultonIntegrator</see>
    <version>$Id: MultistepIntegrator.java 1463684 2013-04-02 19:04:13Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>First scaled derivative (h y').</text>
  </javadoc>
  <declaration type="double[]" name="scaled" />
  <javadoc>
    <text>Nordsieck matrix of the higher scaled derivatives.
 * &lt;p&gt;(h&lt;sup&gt;2&lt;/sup&gt;/2 y'', h&lt;sup&gt;3&lt;/sup&gt;/6 y''' ..., h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;)&lt;/p&gt;</text>
  </javadoc>
  <declaration type="Array2DRowRealMatrix" name="nordsieck" />
  <javadoc>
    <text>Starter integrator.</text>
  </javadoc>
  <declaration type="FirstOrderIntegrator" name="starter" />
  <javadoc>
    <text>Number of steps of the multistep method (excluding the one being computed).</text>
  </javadoc>
  <declaration type="int" name="nSteps" />
  <javadoc>
    <text>Stepsize control exponent.</text>
  </javadoc>
  <declaration type="double" name="exp" />
  <javadoc>
    <text>Safety factor for stepsize control.</text>
  </javadoc>
  <declaration type="double" name="safety" />
  <javadoc>
    <text>Minimal reduction factor for stepsize control.</text>
  </javadoc>
  <declaration type="double" name="minReduction" />
  <javadoc>
    <text>Maximal growth factor for stepsize control.</text>
  </javadoc>
  <declaration type="double" name="maxGrowth" />
  <javadoc>
    <text>Build a multistep integrator with the given stepsize bounds.
 * &lt;p&gt;The default starter integrator is set to the {@link DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with
 * some defaults settings.&lt;/p&gt;
 * &lt;p&gt;
 * The default max growth factor is set to a quite low value: 2&lt;sup&gt;1/order&lt;/sup&gt;.
 * &lt;/p&gt;</text>
    <param>name name of the method</param>
    <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
    <param>order order of the method</param>
    <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
    <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
    <param>scalAbsoluteTolerance allowed absolute error</param>
    <param>scalRelativeTolerance allowed relative error</param>
    <exception>NumberIsTooSmallException if number of steps is smaller than 2</exception>
  </javadoc>
  <method type="constructor" name="MultistepIntegrator">
    <scope />
    <comment>set the default values of the algorithm control parameters</comment>
  </method>
  <javadoc>
    <text>Build a multistep integrator with the given stepsize bounds.
 * &lt;p&gt;The default starter integrator is set to the {@link DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with
 * some defaults settings.&lt;/p&gt;
 * &lt;p&gt;
 * The default max growth factor is set to a quite low value: 2&lt;sup&gt;1/order&lt;/sup&gt;.
 * &lt;/p&gt;</text>
    <param>name name of the method</param>
    <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
    <param>order order of the method</param>
    <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
    <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
    <param>vecAbsoluteTolerance allowed absolute error</param>
    <param>vecRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="MultistepIntegrator">
    <comment>set the default values of the algorithm control parameters</comment>
  </method>
  <javadoc>
    <text>Get the starter integrator.</text>
    <return>starter integrator</return>
  </javadoc>
  <method type="ODEIntegrator" name="getStarterIntegrator" />
  <javadoc>
    <text>Set the starter integrator.
 * &lt;p&gt;The various step and event handlers for this starter integrator
 * will be managed automatically by the multi-step integrator. Any
 * user configuration for these elements will be cleared before use.&lt;/p&gt;</text>
    <param>starterIntegrator starter integrator</param>
  </javadoc>
  <method type="void" name="setStarterIntegrator" />
  <javadoc>
    <text>Start the integration.
 * &lt;p&gt;This method computes one step using the underlying starter integrator,
 * and initializes the Nordsieck vector at step start. The starter integrator
 * purpose is only to establish initial conditions, it does not really change
 * time by itself. The top level multistep integrator remains in charge of
 * handling time propagation and events handling as it will starts its own
 * computation right from the beginning. In a sense, the starter integrator
 * can be seen as a dummy one and so it will never trigger any user event nor
 * call any user step handler.&lt;/p&gt;</text>
    <param>t0 initial time</param>
    <param>y0 initial value of the state vector at t0</param>
    <param>t target time for the integration
 * (can be set to a value smaller than &lt;code&gt;t0&lt;/code&gt; for backward integration)</param>
    <exception>DimensionMismatchException if arrays dimension do not match equations settings</exception>
    <exception>NumberIsTooSmallException if integration step is too small</exception>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    <exception>NoBracketingException if the location of an event cannot be bracketed</exception>
  </javadoc>
  <method type="void" name="start">
    <scope>
      <scope />
      <scope>
        <javadoc>
          <text>{@inheritDoc}</text>
        </javadoc>
        <method type="int" name="getDimension" />
        <javadoc>
          <text>{@inheritDoc}</text>
        </javadoc>
        <method type="void" name="computeDerivatives" />
      </scope>
    </scope>
    <scope />
    <comment>make sure NO user event nor user step handler is triggered,</comment>
    <comment>this is the task of the top level integrator, not the task</comment>
    <comment>of the starter integrator</comment>
    <comment>set up one specific step handler to extract initial Nordsieck vector</comment>
    <comment>start integration, expecting a InitializationCompletedMarkerException</comment>
    <comment>NOPMD</comment>
    <comment>this is the expected nominal interruption of the start integrator</comment>
    <comment>count the evaluations used by the starter</comment>
    <comment>remove the specific step handler</comment>
  </method>
  <method name="initializeHighOrderDerivatives" type="Array2DRowRealMatrix" />
  <javadoc>
    <text>Initialize the high order scaled derivatives at step start.</text>
    <param>h step size to use for scaling</param>
    <param>t first steps times</param>
    <param>y first steps states</param>
    <param>yDot first steps derivatives</param>
    <return>Nordieck vector at first step (h&lt;sup&gt;2&lt;/sup&gt;/2 y''&lt;sub&gt;n&lt;/sub&gt;,
 * h&lt;sup&gt;3&lt;/sup&gt;/6 y'''&lt;sub&gt;n&lt;/sub&gt; ... h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;&lt;sub&gt;n&lt;/sub&gt;)</return>
  </javadoc>
  <javadoc>
    <text>Get the minimal reduction factor for stepsize control.</text>
    <return>minimal reduction factor</return>
  </javadoc>
  <method type="double" name="getMinReduction" />
  <javadoc>
    <text>Set the minimal reduction factor for stepsize control.</text>
    <param>minReduction minimal reduction factor</param>
  </javadoc>
  <method type="void" name="setMinReduction" />
  <javadoc>
    <text>Get the maximal growth factor for stepsize control.</text>
    <return>maximal growth factor</return>
  </javadoc>
  <method type="double" name="getMaxGrowth" />
  <javadoc>
    <text>Set the maximal growth factor for stepsize control.</text>
    <param>maxGrowth maximal growth factor</param>
  </javadoc>
  <method type="void" name="setMaxGrowth" />
  <javadoc>
    <text>Get the safety factor for stepsize control.</text>
    <return>safety factor</return>
  </javadoc>
  <method type="double" name="getSafety" />
  <javadoc>
    <text>Set the safety factor for stepsize control.</text>
    <param>safety safety factor</param>
  </javadoc>
  <method type="void" name="setSafety" />
  <javadoc>
    <text>Compute step grow/shrink factor according to normalized error.</text>
    <param>error normalized error of the current step</param>
    <return>grow/shrink factor for next step</return>
  </javadoc>
  <method type="double" name="computeStepGrowShrinkFactor" />
  <javadoc>
    <text>Transformer used to convert the first step to Nordsieck representation.</text>
  </javadoc>
  <method name="initializeHighOrderDerivatives" type="Array2DRowRealMatrix" />
  <javadoc>
    <text>Initialize the high order scaled derivatives at step start.</text>
    <param>h step size to use for scaling</param>
    <param>t first steps times</param>
    <param>y first steps states</param>
    <param>yDot first steps derivatives</param>
    <return>Nordieck vector at first step (h&lt;sup&gt;2&lt;/sup&gt;/2 y''&lt;sub&gt;n&lt;/sub&gt;,
 * h&lt;sup&gt;3&lt;/sup&gt;/6 y'''&lt;sub&gt;n&lt;/sub&gt; ... h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;&lt;sub&gt;n&lt;/sub&gt;)</return>
  </javadoc>
  <javadoc>
    <text>Specialized step handler storing the first step.</text>
  </javadoc>
  <javadoc>
    <text>Steps counter.</text>
  </javadoc>
  <declaration type="int" name="count" />
  <javadoc>
    <text>First steps times.</text>
  </javadoc>
  <declaration type="double[]" name="t" />
  <javadoc>
    <text>First steps states.</text>
  </javadoc>
  <declaration type="double[][]" name="y" />
  <javadoc>
    <text>First steps derivatives.</text>
  </javadoc>
  <declaration type="double[][]" name="yDot" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>nSteps number of steps of the multistep method (excluding the one being computed)</param>
    <param>n problem dimension</param>
  </javadoc>
  <method type="constructor" name="NordsieckInitializer" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="handleStep">
    <declaration type="double" name="prev" />
    <declaration type="double" name="curr" />
    <scope>
      <declaration type="ExpandableStatefulODE" name="expandable" />
      <declaration type="EquationsMapper" name="primary" />
      <declaration type="int" name="index" />
      <scope />
    </scope>
    <declaration type="ExpandableStatefulODE" name="expandable" />
    <declaration type="EquationsMapper" name="primary" />
    <declaration type="int" name="index" />
    <scope />
    <scope>
      <scope />
    </scope>
    <comment>first step, we need to store also the beginning of the step</comment>
    <comment>store the end of the step</comment>
    <comment>this was the last step we needed, we can compute the derivatives</comment>
    <comment>first scaled derivative</comment>
    <comment>higher order derivatives</comment>
    <comment>stop the integrator now that all needed steps have been handled</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="init">
    <comment>nothing to do</comment>
  </method>
  <javadoc>
    <text>Marker exception used ONLY to stop the starter integrator after first step.</text>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="InitializationCompletedMarkerException" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
