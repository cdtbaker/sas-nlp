<?xml version="1.0" encoding="UTF-8"?>
<class name="BlockFieldMatrix">
  <javadoc>
    <text>Cache-friendly implementation of FieldMatrix using a flat arrays to store
 * square blocks of the matrix.
 * &lt;p&gt;
 * This implementation is specially designed to be cache-friendly. Square blocks are
 * stored as small arrays and allow efficient traversal of data both in row major direction
 * and columns major direction, one block at a time. This greatly increases performances
 * for algorithms that use crossed directions loops like multiplication or transposition.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The size of square blocks is a static parameter. It may be tuned according to the cache
 * size of the target computer processor. As a rule of thumbs, it should be the largest
 * value that allows three blocks to be simultaneously cached (this is necessary for example
 * for matrix multiplication). The default value is to use 36x36 blocks.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks
 * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square
 * blocks are flattened in row major order in single dimension arrays which are therefore{@link #BLOCK_SIZE}&lt;sup&gt;2&lt;/sup&gt; elements long for regular blocks. The blocks are themselves
 * organized in row major order.
 * &lt;/p&gt;
 * &lt;p&gt;
 * As an example, for a block size of 36x36, a 100x60 matrix would be stored in 6 blocks.
 * Block 0 would be a Field[1296] array holding the upper left 36x36 square, block 1 would be
 * a Field[1296] array holding the upper center 36x36 square, block 2 would be a Field[1008]
 * array holding the upper right 36x28 rectangle, block 3 would be a Field[864] array holding
 * the lower left 24x36 rectangle, block 4 would be a Field[864] array holding the lower center
 * 24x36 rectangle and block 5 would be a Field[672] array holding the lower right 24x28
 * rectangle.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The layout complexity overhead versus simple mapping of matrices to java
 * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads
 * to up to 3-fold improvements for matrices of moderate to large size.
 * &lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <version>$Id: BlockFieldMatrix.java 1449528 2013-02-24 19:06:20Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Block size.</text>
  </javadoc>
  <declaration type="int" name="BLOCK_SIZE" />
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Blocks of matrix entries.</text>
  </javadoc>
  <declaration type="T" name="blocks" />
  <javadoc>
    <text>Number of rows of the matrix.</text>
  </javadoc>
  <declaration type="int" name="rows" />
  <javadoc>
    <text>Number of columns of the matrix.</text>
  </javadoc>
  <declaration type="int" name="columns" />
  <javadoc>
    <text>Number of block rows of the matrix.</text>
  </javadoc>
  <declaration type="int" name="blockRows" />
  <javadoc>
    <text>Number of block columns of the matrix.</text>
  </javadoc>
  <declaration type="int" name="blockColumns" />
  <javadoc>
    <text>Create a new matrix with the supplied row and column dimensions.</text>
    <param>field Field to which the elements belong.</param>
    <param>rows Number of rows in the new matrix.</param>
    <param>columns Number of columns in the new matrix.</param>
    <throws>NotStrictlyPositiveException if row or column dimension is not
 * positive.</throws>
  </javadoc>
  <method type="constructor" name="BlockFieldMatrix">
    <comment>number of blocks</comment>
    <comment>allocate storage blocks, taking care of smaller ones at right and bottom</comment>
  </method>
  <javadoc>
    <text>Create a new dense matrix copying entries from raw layout data.
 * &lt;p&gt;The input array &lt;em&gt;must&lt;/em&gt; already be in raw layout.&lt;/p&gt;
 * &lt;p&gt;Calling this constructor is equivalent to call:
 * &lt;pre&gt;matrix = new BlockFieldMatrix&lt;T&gt;(getField(), rawData.length, rawData[0].length,
 * toBlocksLayout(rawData), false);&lt;/pre&gt;
 * &lt;/p&gt;</text>
    <param>rawData Data for the new matrix, in raw layout.</param>
    <throws>DimensionMismatchException if the {@code blockData} shape is
 * inconsistent with block layout.</throws>
    <see>#BlockFieldMatrix(int,int,FieldElement[][],boolean)</see>
  </javadoc>
  <method type="constructor" name="BlockFieldMatrix" />
  <javadoc>
    <text>Create a new dense matrix copying entries from block layout data.
 * &lt;p&gt;The input array &lt;em&gt;must&lt;/em&gt; already be in blocks layout.&lt;/p&gt;</text>
    <param>rows  the number of rows in the new matrix</param>
    <param>columns  the number of columns in the new matrix</param>
    <param>blockData data for new matrix</param>
    <param>copyArray if true, the input array will be copied, otherwise
 * it will be referenced</param>
    <throws>DimensionMismatchException if the {@code blockData} shape is
 * inconsistent with block layout.</throws>
    <throws>NotStrictlyPositiveException if row or column dimension is not
 * positive.</throws>
    <see>#createBlocksLayout(Field,int,int)</see>
    <see>#toBlocksLayout(FieldElement[][])</see>
    <see>#BlockFieldMatrix(FieldElement[][])</see>
  </javadoc>
  <method type="constructor" name="BlockFieldMatrix">
    <scope />
    <scope />
    <declaration type="int" name="index" />
    <scope>
      <declaration type="int" name="iHeight" />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>number of blocks</comment>
    <comment>allocate storage blocks, taking care of smaller ones at right and bottom</comment>
    <comment>reference existing array</comment>
  </method>
  <javadoc>
    <text>Convert a data array from raw layout to blocks layout.
 * &lt;p&gt;
 * Raw layout is the straightforward layout where element at row i and
 * column j is in array element &lt;code&gt;rawData[i][j]&lt;/code&gt;. Blocks layout
 * is the layout used in {@link BlockFieldMatrix} instances, where the matrix
 * is split in square blocks (except at right and bottom side where blocks may
 * be rectangular to fit matrix size) and each block is stored in a flattened
 * one-dimensional array.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This method creates an array in blocks layout from an input array in raw layout.
 * It can be used to provide the array argument of the {@link #BlockFieldMatrix(int,int,FieldElement[][],boolean)}constructor.
 * &lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  Type of the field elements.</param>
    <param>rawData Data array in raw layout.</param>
    <return>a new data array containing the same entries but in blocks layout</return>
    <throws>DimensionMismatchException if {@code rawData} is not rectangular
 * (not all rows have the same length).</throws>
    <see>#createBlocksLayout(Field,int,int)</see>
    <see>#BlockFieldMatrix(int,int,FieldElement[][],boolean)</see>
  </javadoc>
  <method type="T[][]" name="toBlocksLayout">
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="int" name="blockRows" />
    <declaration type="int" name="blockColumns" />
    <scope>
      <declaration type="int" name="length" />
      <scope />
    </scope>
    <declaration type="Field&lt;T&gt;" name="field" />
    <declaration type="T[][]" name="blocks" />
    <declaration type="int" name="blockIndex" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <declaration type="int" name="iHeight" />
      <scope>
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="int" name="jWidth" />
        <declaration type="T[]" name="block" />
        <declaration type="int" name="index" />
        <scope />
      </scope>
    </scope>
    <comment>safety checks</comment>
    <comment>convert array</comment>
    <comment>allocate new block</comment>
    <comment>copy data</comment>
  </method>
  <javadoc>
    <text>Create a data array in blocks layout.
 * &lt;p&gt;
 * This method can be used to create the array argument of the {@link #BlockFieldMatrix(int,int,FieldElement[][],boolean)}constructor.
 * &lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  Type of the field elements.</param>
    <param>field Field to which the elements belong.</param>
    <param>rows Number of rows in the new matrix.</param>
    <param>columns Number of columns in the new matrix.</param>
    <return>a new data array in blocks layout.</return>
    <see>#toBlocksLayout(FieldElement[][])</see>
    <see>#BlockFieldMatrix(int,int,FieldElement[][],boolean)</see>
  </javadoc>
  <method type="T[][]" name="createBlocksLayout">
    <declaration type="int" name="blockRows" />
    <declaration type="int" name="blockColumns" />
    <declaration type="T[][]" name="blocks" />
    <declaration type="int" name="blockIndex" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <declaration type="int" name="iHeight" />
      <scope>
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="int" name="jWidth" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="createMatrix" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="copy">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="copied" />
    <scope />
    <comment>create an empty matrix</comment>
    <comment>copy the blocks</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="add">
    <scope />
    <scope>
      <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
      <declaration type="int" name="blockIndex" />
      <scope>
        <scope>
          <declaration type="T[]" name="outBlock" />
          <declaration type="T[]" name="tBlock" />
          <declaration type="int" name="pStart" />
          <declaration type="int" name="pEnd" />
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="int" name="k" />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>safety check</comment>
    <comment>perform addition block-wise, to ensure good cache behavior</comment>
    <comment>perform addition on the current block</comment>
    <comment>go to next block</comment>
  </method>
  <javadoc>
    <text>Compute the sum of {@code this} and {@code m}.</text>
    <param>m matrix to be added</param>
    <return>{@code this + m}</return>
    <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this}</throws>
  </javadoc>
  <method type="BlockFieldMatrix&lt;T&gt;" name="add">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <scope>
      <declaration type="T[]" name="outBlock" />
      <declaration type="T[]" name="tBlock" />
      <declaration type="T[]" name="mBlock" />
      <scope />
    </scope>
    <comment>safety check</comment>
    <comment>perform addition block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="subtract">
    <scope />
    <scope>
      <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
      <declaration type="int" name="blockIndex" />
      <scope>
        <scope>
          <declaration type="T[]" name="outBlock" />
          <declaration type="T[]" name="tBlock" />
          <declaration type="int" name="pStart" />
          <declaration type="int" name="pEnd" />
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="int" name="k" />
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>safety check</comment>
    <comment>perform subtraction block-wise, to ensure good cache behavior</comment>
    <comment>perform subtraction on the current block</comment>
    <comment>go to next block</comment>
  </method>
  <javadoc>
    <text>Compute {@code this - m}.</text>
    <param>m matrix to be subtracted</param>
    <return>{@code this - m}</return>
    <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this}</throws>
  </javadoc>
  <method type="BlockFieldMatrix&lt;T&gt;" name="subtract">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <scope>
      <declaration type="T[]" name="outBlock" />
      <declaration type="T[]" name="tBlock" />
      <declaration type="T[]" name="mBlock" />
      <scope />
    </scope>
    <comment>safety check</comment>
    <comment>perform subtraction block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="scalarAdd">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <scope>
      <declaration type="T[]" name="outBlock" />
      <declaration type="T[]" name="tBlock" />
      <scope />
    </scope>
    <comment>perform subtraction block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="scalarMultiply">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <scope>
      <declaration type="T[]" name="outBlock" />
      <declaration type="T[]" name="tBlock" />
      <scope />
    </scope>
    <comment>perform subtraction block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="multiply">
    <scope />
    <scope>
      <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
      <declaration type="T" name="zero" />
      <declaration type="int" name="blockIndex" />
      <scope>
        <declaration type="int" name="pStart" />
        <declaration type="int" name="pEnd" />
        <scope>
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="T[]" name="outBlock" />
          <scope>
            <declaration type="int" name="kWidth" />
            <declaration type="T[]" name="tBlock" />
            <declaration type="int" name="rStart" />
            <declaration type="int" name="k" />
            <scope>
              <declaration type="int" name="lStart" />
              <declaration type="int" name="lEnd" />
              <scope>
                <declaration type="T" name="sum" />
                <declaration type="int" name="r" />
                <scope />
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>safety check</comment>
    <comment>perform multiplication block-wise, to ensure good cache behavior</comment>
    <comment>select current block</comment>
    <comment>perform multiplication on current block</comment>
    <comment>go to next block</comment>
  </method>
  <javadoc>
    <text>Returns the result of postmultiplying {@code this} by {@code m}.</text>
    <param>m matrix to postmultiply by</param>
    <return>{@code this * m}</return>
    <throws>DimensionMismatchException if the matrices are not compatible.</throws>
  </javadoc>
  <method type="BlockFieldMatrix&lt;T&gt;" name="multiply">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <declaration type="T" name="zero" />
    <declaration type="int" name="blockIndex" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <declaration type="int" name="jWidth" />
        <declaration type="int" name="jWidth2" />
        <declaration type="int" name="jWidth3" />
        <declaration type="int" name="jWidth4" />
        <declaration type="T[]" name="outBlock" />
        <scope>
          <declaration type="int" name="kWidth" />
          <declaration type="T[]" name="tBlock" />
          <declaration type="T[]" name="mBlock" />
          <declaration type="int" name="k" />
          <scope>
            <declaration type="int" name="lStart" />
            <declaration type="int" name="lEnd" />
            <scope>
              <declaration type="T" name="sum" />
              <declaration type="int" name="l" />
              <declaration type="int" name="n" />
              <scope />
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>safety check</comment>
    <comment>perform multiplication block-wise, to ensure good cache behavior</comment>
    <comment>select current block</comment>
    <comment>perform multiplication on current block</comment>
    <comment>go to next block</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[][]" name="getData">
    <declaration type="T[][]" name="data" />
    <declaration type="int" name="lastColumns" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <declaration type="int" name="regularPos" />
      <declaration type="int" name="lastPos" />
      <scope>
        <declaration type="T[]" name="dataP" />
        <declaration type="int" name="blockIndex" />
        <declaration type="int" name="dataPos" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="getSubMatrix">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <declaration type="int" name="blockStartRow" />
    <declaration type="int" name="rowsShift" />
    <declaration type="int" name="blockStartColumn" />
    <declaration type="int" name="columnsShift" />
    <declaration type="int" name="pBlock" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="int" name="qBlock" />
      <scope>
        <declaration type="int" name="jWidth" />
        <declaration type="int" name="outIndex" />
        <declaration type="T[]" name="outBlock" />
        <declaration type="int" name="index" />
        <declaration type="int" name="width" />
        <declaration type="int" name="heightExcess" />
        <declaration type="int" name="widthExcess" />
        <scope>
          <scope>
            <declaration type="int" name="width2" />
          </scope>
          <scope />
        </scope>
        <scope>
          <scope>
            <declaration type="int" name="width2" />
          </scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>safety checks</comment>
    <comment>create the output matrix</comment>
    <comment>compute blocks shifts</comment>
    <comment>perform extraction block-wise, to ensure good cache behavior</comment>
    <comment>handle one block of the output matrix</comment>
    <comment>the submatrix block spans on two blocks rows from the original matrix</comment>
    <comment>the submatrix block spans on two blocks columns from the original matrix</comment>
    <comment>the submatrix block spans on one block column from the original matrix</comment>
    <comment>the submatrix block spans on one block row from the original matrix</comment>
    <comment>the submatrix block spans on two blocks columns from the original matrix</comment>
    <comment>the submatrix block spans on one block column from the original matrix</comment>
  </method>
  <javadoc>
    <text>Copy a part of a block into another one
 * &lt;p&gt;This method can be called only when the specified part fits in both
 * blocks, no verification is done here.&lt;/p&gt;</text>
    <param>srcBlock source block</param>
    <param>srcWidth source block width ({@link #BLOCK_SIZE} or smaller)</param>
    <param>srcStartRow start row in the source block</param>
    <param>srcEndRow end row (exclusive) in the source block</param>
    <param>srcStartColumn start column in the source block</param>
    <param>srcEndColumn end column (exclusive) in the source block</param>
    <param>dstBlock destination block</param>
    <param>dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)</param>
    <param>dstStartRow start row in the destination block</param>
    <param>dstStartColumn start column in the destination block</param>
  </javadoc>
  <method type="void" name="copyBlockPart">
    <declaration type="int" name="length" />
    <declaration type="int" name="srcPos" />
    <declaration type="int" name="dstPos" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setSubMatrix">
    <declaration type="int" name="refLength" />
    <scope />
    <declaration type="int" name="endRow" />
    <declaration type="int" name="endColumn" />
    <scope>
      <scope />
    </scope>
    <declaration type="int" name="blockStartRow" />
    <declaration type="int" name="blockEndRow" />
    <declaration type="int" name="blockStartColumn" />
    <declaration type="int" name="blockEndColumn" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="int" name="firstRow" />
      <declaration type="int" name="iStart" />
      <declaration type="int" name="iEnd" />
      <scope>
        <declaration type="int" name="jWidth" />
        <declaration type="int" name="firstColumn" />
        <declaration type="int" name="jStart" />
        <declaration type="int" name="jEnd" />
        <declaration type="int" name="jLength" />
        <declaration type="T[]" name="block" />
        <scope />
      </scope>
    </scope>
    <comment>safety checks</comment>
    <comment>compute blocks bounds</comment>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
    <comment>handle one block, row by row</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="getRowMatrix">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="iRow" />
    <declaration type="int" name="outBlockIndex" />
    <declaration type="int" name="outIndex" />
    <declaration type="T[]" name="outBlock" />
    <scope>
      <declaration type="int" name="jWidth" />
      <declaration type="T[]" name="block" />
      <declaration type="int" name="available" />
      <scope />
      <scope />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setRowMatrix">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Sets the entries in row number &lt;code&gt;row&lt;/code&gt;
 * as a row matrix.  Row indices start at 0.</text>
    <param>row the row to be set</param>
    <param>matrix row matrix (must have one row and the same number of columns
 * as the instance)</param>
    <throws>MatrixDimensionMismatchException if the matrix dimensions do
 * not match one instance row.</throws>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
  </javadoc>
  <method type="void" name="setRowMatrix">
    <declaration type="int" name="nCols" />
    <scope />
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="iRow" />
    <declaration type="int" name="mBlockIndex" />
    <declaration type="int" name="mIndex" />
    <declaration type="T[]" name="mBlock" />
    <scope>
      <declaration type="int" name="jWidth" />
      <declaration type="T[]" name="block" />
      <declaration type="int" name="available" />
      <scope />
      <scope />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="getColumnMatrix">
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="jColumn" />
    <declaration type="int" name="jWidth" />
    <declaration type="int" name="outBlockIndex" />
    <declaration type="int" name="outIndex" />
    <declaration type="T[]" name="outBlock" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="T[]" name="block" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setColumnMatrix">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Sets the entries in column number {@code column}as a column matrix.  Column indices start at 0.</text>
    <param>column Column to be set.</param>
    <param>matrix Column matrix (must have one column and the same number of rows
 * as the instance).</param>
    <throws>MatrixDimensionMismatchException if the matrix dimensions do
 * not match one instance column.</throws>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
  </javadoc>
  <method type="void" name="setColumnMatrix">
    <declaration type="int" name="nRows" />
    <scope />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="jColumn" />
    <declaration type="int" name="jWidth" />
    <declaration type="int" name="mBlockIndex" />
    <declaration type="int" name="mIndex" />
    <declaration type="T[]" name="mBlock" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="T[]" name="block" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="getRowVector">
    <declaration type="T[]" name="outData" />
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="iRow" />
    <declaration type="int" name="outIndex" />
    <scope>
      <declaration type="int" name="jWidth" />
      <declaration type="T[]" name="block" />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setRowVector">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldVector&lt;T&gt;" name="getColumnVector">
    <declaration type="T[]" name="outData" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="jColumn" />
    <declaration type="int" name="jWidth" />
    <declaration type="int" name="outIndex" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="T[]" name="block" />
      <scope />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setColumnVector">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[]" name="getRow">
    <declaration type="T[]" name="out" />
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="iRow" />
    <declaration type="int" name="outIndex" />
    <scope>
      <declaration type="int" name="jWidth" />
      <declaration type="T[]" name="block" />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setRow">
    <declaration type="int" name="nCols" />
    <scope />
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="iRow" />
    <declaration type="int" name="outIndex" />
    <scope>
      <declaration type="int" name="jWidth" />
      <declaration type="T[]" name="block" />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[]" name="getColumn">
    <declaration type="T[]" name="out" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="jColumn" />
    <declaration type="int" name="jWidth" />
    <declaration type="int" name="outIndex" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="T[]" name="block" />
      <scope />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setColumn">
    <declaration type="int" name="nRows" />
    <scope />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="jColumn" />
    <declaration type="int" name="jWidth" />
    <declaration type="int" name="outIndex" />
    <scope>
      <declaration type="int" name="iHeight" />
      <declaration type="T[]" name="block" />
      <scope />
    </scope>
    <comment>perform copy block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="getEntry">
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="k" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setEntry">
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="k" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="addToEntry">
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="k" />
    <declaration type="T[]" name="blockIJ" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="multiplyEntry">
    <declaration type="int" name="iBlock" />
    <declaration type="int" name="jBlock" />
    <declaration type="int" name="k" />
    <declaration type="T[]" name="blockIJ" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="FieldMatrix&lt;T&gt;" name="transpose">
    <declaration type="int" name="nRows" />
    <declaration type="int" name="nCols" />
    <declaration type="BlockFieldMatrix&lt;T&gt;" name="out" />
    <declaration type="int" name="blockIndex" />
    <scope>
      <scope>
        <declaration type="T[]" name="outBlock" />
        <declaration type="T[]" name="tBlock" />
        <declaration type="int" name="pStart" />
        <declaration type="int" name="pEnd" />
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="int" name="k" />
        <scope>
          <declaration type="int" name="lInc" />
          <declaration type="int" name="l" />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>perform transpose block-wise, to ensure good cache behavior</comment>
    <comment>transpose current block</comment>
    <comment>go to next block</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="getRowDimension" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="getColumnDimension" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[]" name="operate">
    <scope />
    <declaration type="T[]" name="out" />
    <declaration type="T" name="zero" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <declaration type="T[]" name="block" />
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="int" name="k" />
        <scope>
          <declaration type="T" name="sum" />
          <declaration type="int" name="q" />
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>perform multiplication block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T[]" name="preMultiply">
    <scope />
    <declaration type="T[]" name="out" />
    <declaration type="T" name="zero" />
    <scope>
      <declaration type="int" name="jWidth" />
      <declaration type="int" name="jWidth2" />
      <declaration type="int" name="jWidth3" />
      <declaration type="int" name="jWidth4" />
      <declaration type="int" name="qStart" />
      <declaration type="int" name="qEnd" />
      <scope>
        <declaration type="T[]" name="block" />
        <declaration type="int" name="pStart" />
        <declaration type="int" name="pEnd" />
        <scope>
          <declaration type="int" name="k" />
          <declaration type="T" name="sum" />
          <declaration type="int" name="p" />
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>perform multiplication block-wise, to ensure good cache behavior</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInRowOrder">
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <scope>
          <declaration type="int" name="jWidth" />
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="T[]" name="block" />
          <declaration type="int" name="k" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInRowOrder">
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <scope>
          <declaration type="int" name="jWidth" />
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="T[]" name="block" />
          <declaration type="int" name="k" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInRowOrder">
    <scope>
      <declaration type="int" name="p0" />
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <scope>
          <declaration type="int" name="jWidth" />
          <declaration type="int" name="q0" />
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="T[]" name="block" />
          <declaration type="int" name="k" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInRowOrder">
    <scope>
      <declaration type="int" name="p0" />
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <scope>
          <declaration type="int" name="jWidth" />
          <declaration type="int" name="q0" />
          <declaration type="int" name="qStart" />
          <declaration type="int" name="qEnd" />
          <declaration type="T[]" name="block" />
          <declaration type="int" name="k" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInOptimizedOrder">
    <declaration type="int" name="blockIndex" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="T[]" name="block" />
        <declaration type="int" name="k" />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInOptimizedOrder">
    <declaration type="int" name="blockIndex" />
    <scope>
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="T[]" name="block" />
        <declaration type="int" name="k" />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInOptimizedOrder">
    <scope>
      <declaration type="int" name="p0" />
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <declaration type="int" name="jWidth" />
        <declaration type="int" name="q0" />
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="T[]" name="block" />
        <scope>
          <declaration type="int" name="k" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="T" name="walkInOptimizedOrder">
    <scope>
      <declaration type="int" name="p0" />
      <declaration type="int" name="pStart" />
      <declaration type="int" name="pEnd" />
      <scope>
        <declaration type="int" name="jWidth" />
        <declaration type="int" name="q0" />
        <declaration type="int" name="qStart" />
        <declaration type="int" name="qEnd" />
        <declaration type="T[]" name="block" />
        <scope>
          <declaration type="int" name="k" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Get the height of a block.</text>
    <param>blockRow row index (in block sense) of the block</param>
    <return>height (number of rows) of the block</return>
  </javadoc>
  <method type="int" name="blockHeight" />
  <javadoc>
    <text>Get the width of a block.</text>
    <param>blockColumn column index (in block sense) of the block</param>
    <return>width (number of columns) of the block</return>
  </javadoc>
  <method type="int" name="blockWidth" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
