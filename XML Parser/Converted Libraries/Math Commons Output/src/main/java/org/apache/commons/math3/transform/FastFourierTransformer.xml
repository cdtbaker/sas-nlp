<?xml version="1.0" encoding="UTF-8"?>
<class name="FastFourierTransformer">
  <javadoc>
    <text>Implements the Fast Fourier Transform for transformation of one-dimensional
 * real or complex data sets. For reference, see &lt;em&gt;Applied Numerical Linear
 * Algebra&lt;/em&gt;, ISBN 0898713897, chapter 6.
 * &lt;p&gt;
 * There are several variants of the discrete Fourier transform, with various
 * normalization conventions, which are specified by the parameter{@link DftNormalization}.
 * &lt;p&gt;
 * The current implementation of the discrete Fourier transform as a fast
 * Fourier transform requires the length of the data set to be a power of 2.
 * This greatly simplifies and speeds up the code. Users can pad the data with
 * zeros to meet this requirement. There are other flavors of FFT, for
 * reference, see S. Winograd,
 * &lt;i&gt;On computing the discrete Fourier transform&lt;/i&gt;, Mathematics of
 * Computation, 32 (1978), 175 - 199.</text>
    <see>DftNormalization</see>
    <version>$Id: FastFourierTransformer.java 1385310 2012-09-16 16:32:10Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>{@code W_SUB_N_R[i]} is the real part of{@code exp(- 2 * i * pi / n)}:{@code W_SUB_N_R[i] = cos(2 * pi/ n)}, where {@code n = 2^i}.</text>
  </javadoc>
  <declaration type="double[]" name="W_SUB_N_R" />
  <javadoc>
    <text>{@code W_SUB_N_I[i]} is the imaginary part of{@code exp(- 2 * i * pi / n)}:{@code W_SUB_N_I[i] = -sin(2 * pi/ n)}, where {@code n = 2^i}.</text>
  </javadoc>
  <declaration type="double[]" name="W_SUB_N_I" />
  <javadoc>
    <text>The type of DFT to be performed.</text>
  </javadoc>
  <declaration type="DftNormalization" name="normalization" />
  <javadoc>
    <text>Creates a new instance of this class, with various normalization
 * conventions.</text>
    <param>normalization the type of normalization to be applied to the
 * transformed data</param>
  </javadoc>
  <method type="constructor" name="FastFourierTransformer" />
  <javadoc>
    <text>Performs identical index bit reversal shuffles on two arrays of identical
 * size. Each element in the array is swapped with another element based on
 * the bit-reversal of the index. For example, in an array with length 16,
 * item at binary index 0011 (decimal 3) would be swapped with the item at
 * binary index 1100 (decimal 12).</text>
    <param>a the first array to be shuffled</param>
    <param>b the second array to be shuffled</param>
  </javadoc>
  <method type="void" name="bitReversalShuffle2">
    <declaration type="int" name="n" />
    <declaration type="int" name="halfOfN" />
    <declaration type="int" name="j" />
    <scope>
      <scope>
        <declaration type="double" name="temp" />
      </scope>
      <declaration type="int" name="k" />
      <scope />
    </scope>
    <comment>swap indices i &amp; j</comment>
  </method>
  <javadoc>
    <text>Applies the proper normalization to the specified transformed data.</text>
    <param>dataRI the unscaled transformed data</param>
    <param>normalization the normalization to be applied</param>
    <param>type the type of transform (forward, inverse) which resulted in the specified data</param>
  </javadoc>
  <method type="void" name="normalizeTransformedData">
    <declaration type="double[]" name="dataR" />
    <declaration type="double[]" name="dataI" />
    <declaration type="int" name="n" />
    <scope>
      <declaration type="double" name="scaleFactor" />
      <scope />
    </scope>
    <declaration type="double" name="scaleFactor" />
    <scope />
    <comment>This should never occur in normal conditions. However this
 clause has been added as a safeguard if other types of
 normalizations are ever implemented, and the corresponding
 test is forgotten in the present switch.</comment>
  </method>
  <javadoc>
    <text>Computes the standard transform of the specified complex data. The
 * computation is done in place. The input data is laid out as follows
 * &lt;ul&gt;
 * &lt;li&gt;{@code dataRI[0][i]} is the real part of the {@code i}-th data point,&lt;/li&gt;
 * &lt;li&gt;{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data point.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>dataRI the two dimensional array of real and imaginary parts of the data</param>
    <param>normalization the normalization to be applied to the transformed data</param>
    <param>type the type of transform (forward, inverse) to be performed</param>
    <throws>DimensionMismatchException if the number of rows of the specified
 * array is not two, or the array is not rectangular</throws>
    <throws>MathIllegalArgumentException if the number of data points is not
 * a power of two</throws>
  </javadoc>
  <method type="void" name="transformInPlace">
    <scope />
    <declaration type="double[]" name="dataR" />
    <declaration type="double[]" name="dataI" />
    <scope />
    <declaration type="int" name="n" />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="srcR0" />
      <declaration type="double" name="srcI0" />
      <declaration type="double" name="srcR1" />
      <declaration type="double" name="srcI1" />
    </scope>
    <scope>
      <scope>
        <declaration type="int" name="i1" />
        <declaration type="int" name="i2" />
        <declaration type="int" name="i3" />
        <declaration type="double" name="srcR0" />
        <declaration type="double" name="srcI0" />
        <declaration type="double" name="srcR1" />
        <declaration type="double" name="srcI1" />
        <declaration type="double" name="srcR2" />
        <declaration type="double" name="srcI2" />
        <declaration type="double" name="srcR3" />
        <declaration type="double" name="srcI3" />
      </scope>
    </scope>
    <scope>
      <scope>
        <declaration type="int" name="i1" />
        <declaration type="int" name="i2" />
        <declaration type="int" name="i3" />
        <declaration type="double" name="srcR0" />
        <declaration type="double" name="srcI0" />
        <declaration type="double" name="srcR1" />
        <declaration type="double" name="srcI1" />
        <declaration type="double" name="srcR2" />
        <declaration type="double" name="srcI2" />
        <declaration type="double" name="srcR3" />
        <declaration type="double" name="srcI3" />
      </scope>
    </scope>
    <declaration type="int" name="lastN0" />
    <declaration type="int" name="lastLogN0" />
    <scope>
      <declaration type="int" name="n0" />
      <declaration type="int" name="logN0" />
      <declaration type="double" name="wSubN0R" />
      <declaration type="double" name="wSubN0I" />
      <scope />
      <scope>
        <declaration type="int" name="destOddStartIndex" />
        <declaration type="double" name="wSubN0ToRR" />
        <declaration type="double" name="wSubN0ToRI" />
        <scope>
          <declaration type="double" name="grR" />
          <declaration type="double" name="grI" />
          <declaration type="double" name="hrR" />
          <declaration type="double" name="hrI" />
          <declaration type="double" name="nextWsubN0ToRR" />
          <declaration type="double" name="nextWsubN0ToRI" />
        </scope>
      </scope>
    </scope>
    <comment>X_0 = x_0 + x_1</comment>
    <comment>X_1 = x_0 - x_1</comment>
    <comment>Do 4-term DFT.</comment>
    <comment>4-term DFT</comment>
    <comment>X_0 = x_0 + x_1 + x_2 + x_3</comment>
    <comment>X_1 = x_0 - x_2 + j * (x_3 - x_1)</comment>
    <comment>X_2 = x_0 - x_1 + x_2 - x_3</comment>
    <comment>X_3 = x_0 - x_2 + j * (x_1 - x_3)</comment>
    <comment>4-term DFT</comment>
    <comment>X_0 = x_0 + x_1 + x_2 + x_3</comment>
    <comment>X_1 = x_0 - x_2 + j * (x_3 - x_1)</comment>
    <comment>X_2 = x_0 - x_1 + x_2 - x_3</comment>
    <comment>X_3 = x_0 - x_2 + j * (x_1 - x_3)</comment>
    <comment>Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).</comment>
    <comment>dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr</comment>
    <comment>dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr</comment>
    <comment>WsubN0ToR *= WsubN0R</comment>
  </method>
  <javadoc>
    <text>Returns the (forward, inverse) transform of the specified real data set.</text>
    <param>f the real data array to be transformed</param>
    <param>type the type of transform (forward, inverse) to be performed</param>
    <return>the complex transformed array</return>
    <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
  </javadoc>
  <method type="Complex[]" name="transform">
    <declaration type="double[][][]" name="dataRI" />
  </method>
  <javadoc>
    <text>Returns the (forward, inverse) transform of the specified real function,
 * sampled on the specified interval.</text>
    <param>f the function to be sampled and transformed</param>
    <param>min the (inclusive) lower bound for the interval</param>
    <param>max the (exclusive) upper bound for the interval</param>
    <param>n the number of sample points</param>
    <param>type the type of transform (forward, inverse) to be performed</param>
    <return>the complex transformed array</return>
    <throws>org.apache.commons.math3.exception.NumberIsTooLargeExceptionif the lower bound is greater than, or equal to the upper bound</throws>
    <throws>org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points {@code n} is negative</throws>
    <throws>MathIllegalArgumentException if the number of sample points{@code n} is not a power of two</throws>
  </javadoc>
  <method type="Complex[]" name="transform">
    <declaration type="double[]" name="data" />
  </method>
  <javadoc>
    <text>Returns the (forward, inverse) transform of the specified complex data set.</text>
    <param>f the complex data array to be transformed</param>
    <param>type the type of transform (forward, inverse) to be performed</param>
    <return>the complex transformed array</return>
    <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
  </javadoc>
  <method type="Complex[]" name="transform">
    <declaration type="double[][]" name="dataRI" />
  </method>
  <javadoc>
    <text>Performs a multi-dimensional Fourier transform on a given array. Use{@link #transform(Complex[],TransformType)} in a row-column
 * implementation in any number of dimensions with
 * O(N&amp;times;log(N)) complexity with
 * N = n&lt;sub&gt;1&lt;/sub&gt; &amp;times; n&lt;sub&gt;2&lt;/sub&gt; &amp;times;n&lt;sub&gt;3&lt;/sub&gt; &amp;times; ...
 * &amp;times; n&lt;sub&gt;d&lt;/sub&gt;, where n&lt;sub&gt;k&lt;/sub&gt; is the number of elements in
 * dimension k, and d is the total number of dimensions.</text>
    <param>mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}</param>
    <param>type the type of transform (forward, inverse) to be performed</param>
    <return>transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}</return>
    <throws>IllegalArgumentException if any dimension is not a power of two</throws>
    <deprecated>see MATH-736</deprecated>
  </javadoc>
  <method type="Object" name="mdfft">
    <declaration type="MultiDimensionalComplexMatrix" name="mdcm" />
    <declaration type="int[]" name="dimensionSize" />
    <scope />
    <comment>cycle through each dimension</comment>
  </method>
  <javadoc>
    <text>Performs one dimension of a multi-dimensional Fourier transform.</text>
    <param>mdcm input matrix</param>
    <param>type the type of transform (forward, inverse) to be performed</param>
    <param>d index of the dimension to process</param>
    <param>subVector recursion subvector</param>
    <throws>IllegalArgumentException if any dimension is not a power of two</throws>
    <deprecated>see MATH-736</deprecated>
  </javadoc>
  <method type="void" name="mdfft">
    <declaration type="int[]" name="dimensionSize" />
    <scope>
      <declaration type="Complex[]" name="temp" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="int[]" name="vector" />
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>if done</comment>
    <comment>fft along dimension d</comment>
    <comment>value is not important once the recursion is done.</comment>
    <comment>then an fft will be applied along the dimension d.</comment>
    <comment>further split along the next dimension</comment>
  </method>
  <javadoc>
    <text>Complex matrix implementation. Not designed for synchronized access may
 * eventually be replaced by jsr-83 of the java community process
 * http://jcp.org/en/jsr/detail?id=83
 * may require additional exception throws for other basic requirements.</text>
    <deprecated>see MATH-736</deprecated>
  </javadoc>
  <javadoc>
    <text>Size in all dimensions.</text>
  </javadoc>
  <declaration type="int[]" name="dimensionSize" />
  <javadoc>
    <text>Storage array.</text>
  </javadoc>
  <declaration type="Object" name="multiDimensionalComplexArray" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>multiDimensionalComplexArray array containing the matrix
 * elements</param>
  </javadoc>
  <method type="constructor" name="MultiDimensionalComplexMatrix">
    <declaration type="int" name="numOfDimensions" />
    <scope>
      <declaration type="Object[][]" name="array" />
    </scope>
    <scope>
      <declaration type="Object[][]" name="array" />
    </scope>
    <comment>count dimensions</comment>
    <comment>allocate array with exact count</comment>
    <comment>fill array</comment>
  </method>
  <javadoc>
    <text>Get a matrix element.</text>
    <param>vector indices of the element</param>
    <return>matrix element</return>
    <exception>DimensionMismatchException if dimensions do not match</exception>
  </javadoc>
  <method type="Complex" name="get">
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="Object" name="lastDimension" />
    <scope />
  </method>
  <javadoc>
    <text>Set a matrix element.</text>
    <param>magnitude magnitude of the element</param>
    <param>vector indices of the element</param>
    <return>the previous value</return>
    <exception>DimensionMismatchException if dimensions do not match</exception>
  </javadoc>
  <method type="Complex" name="set">
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="Object[][]" name="lastDimension" />
    <scope />
    <declaration type="Complex" name="lastValue" />
  </method>
  <javadoc>
    <text>Get the size in all dimensions.</text>
    <return>size in all dimensions</return>
  </javadoc>
  <method type="int[]" name="getDimensionSizes" />
  <javadoc>
    <text>Get the underlying storage array.</text>
    <return>underlying storage array</return>
  </javadoc>
  <method type="Object" name="getArray" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Object" name="clone">
    <declaration type="MultiDimensionalComplexMatrix" name="mdcm" />
  </method>
  <javadoc>
    <text>Copy contents of current array into mdcm.</text>
    <param>mdcm array where to copy data</param>
  </javadoc>
  <method type="void" name="clone">
    <declaration type="int[]" name="vector" />
    <declaration type="int" name="size" />
    <scope />
    <declaration type="int[][]" name="vectorList" />
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
