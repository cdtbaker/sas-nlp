<?xml version="1.0" encoding="UTF-8"?>
<class name="LegendreHighPrecisionRuleFactory">
  <javadoc>
    <text>Factory that creates Gauss-type quadrature rule using Legendre polynomials.
 * In this implementation, the lower and upper bounds of the natural interval
 * of integration are -1 and 1, respectively.
 * The Legendre polynomials are evaluated using the recurrence relation
 * presented in &lt;a href="http://en.wikipedia.org/wiki/Abramowitz_and_Stegun"
 * Abramowitz and Stegun, 1964&lt;/a&gt;.</text>
    <since>3.1</since>
    <version>$Id: LegendreHighPrecisionRuleFactory.java 1455194 2013-03-11 15:45:54Z luc $</version>
  </javadoc>
  <javadoc>
    <text>Settings for enhanced precision computations.</text>
  </javadoc>
  <declaration type="MathContext" name="mContext" />
  <javadoc>
    <text>The number {@code 2}.</text>
  </javadoc>
  <declaration type="BigDecimal" name="two" />
  <javadoc>
    <text>The number {@code -1}.</text>
  </javadoc>
  <declaration type="BigDecimal" name="minusOne" />
  <javadoc>
    <text>The number {@code 0.5}.</text>
  </javadoc>
  <declaration type="BigDecimal" name="oneHalf" />
  <javadoc>
    <text>Default precision is {@link MathContext#DECIMAL128 DECIMAL128}.</text>
  </javadoc>
  <method type="constructor" name="LegendreHighPrecisionRuleFactory" />
  <javadoc>
    <param>mContext Precision setting for computing the quadrature rules.</param>
  </javadoc>
  <method type="constructor" name="LegendreHighPrecisionRuleFactory" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Pair&lt;BigDecimal[],BigDecimal[]&gt;" name="computeRule">
    <scope />
    <declaration type="BigDecimal[]" name="previousPoints" />
    <declaration type="BigDecimal[]" name="points" />
    <declaration type="BigDecimal[]" name="weights" />
    <declaration type="int" name="iMax" />
    <scope>
      <declaration type="BigDecimal" name="a" />
      <declaration type="BigDecimal" name="b" />
      <declaration type="BigDecimal" name="pma" />
      <declaration type="BigDecimal" name="pa" />
      <declaration type="BigDecimal" name="pmb" />
      <declaration type="BigDecimal" name="pb" />
      <scope>
        <declaration type="BigDecimal" name="b_two_j_p_1" />
        <declaration type="BigDecimal" name="b_j" />
        <declaration type="BigDecimal" name="b_j_p_1" />
        <declaration type="BigDecimal" name="tmp1" />
        <declaration type="BigDecimal" name="tmp2" />
        <declaration type="BigDecimal" name="ppa" />
        <declaration type="BigDecimal" name="ppb" />
      </scope>
      <declaration type="BigDecimal" name="c" />
      <declaration type="BigDecimal" name="pmc" />
      <declaration type="BigDecimal" name="pc" />
      <declaration type="boolean" name="done" />
      <scope>
        <declaration type="BigDecimal" name="tmp1" />
        <declaration type="BigDecimal" name="tmp2" />
        <scope>
          <declaration type="BigDecimal" name="b_two_j_p_1" />
          <declaration type="BigDecimal" name="b_j" />
          <declaration type="BigDecimal" name="b_j_p_1" />
          <declaration type="BigDecimal" name="ppc" />
        </scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
      <declaration type="BigDecimal" name="nP" />
      <declaration type="BigDecimal" name="tmp1" />
      <declaration type="BigDecimal" name="tmp2" />
      <declaration type="int" name="idx" />
    </scope>
    <scope>
      <declaration type="BigDecimal" name="pmc" />
      <scope>
        <declaration type="BigDecimal" name="b_j" />
        <declaration type="BigDecimal" name="b_j_p_1" />
      </scope>
      <declaration type="BigDecimal" name="nP" />
      <declaration type="BigDecimal" name="tmp1" />
      <declaration type="BigDecimal" name="tmp2" />
    </scope>
    <comment>Break recursion.</comment>
    <comment>Get previous rule.</comment>
    <comment>If it has not been computed yet it will trigger a recursive call</comment>
    <comment>to this method.</comment>
    <comment>Compute next rule.</comment>
    <comment>Find i-th root of P[n+1] by bracketing.</comment>
    <comment>Lower-bound of the interval.</comment>
    <comment>Upper-bound of the interval.</comment>
    <comment>P[j-1](a)</comment>
    <comment>P[j](a)</comment>
    <comment>P[j-1](b)</comment>
    <comment>P[j](b)</comment>
    <comment>Compute P[j+1](a)</comment>
    <comment>ppa = ((2 * j + 1) * a * pa - j * pma) / (j + 1);</comment>
    <comment>P[j+1](a)</comment>
    <comment>Compute P[j+1](b)</comment>
    <comment>ppb = ((2 * j + 1) * b * pb - j * pmb) / (j + 1);</comment>
    <comment>P[j+1](b)</comment>
    <comment>Now pa = P[n+1](a), and pma = P[n](a). Same holds for b.</comment>
    <comment>Middle of the interval.</comment>
    <comment>P[j-1](c)</comment>
    <comment>P[j](c)</comment>
    <comment>Compute P[j+1](c)</comment>
    <comment>P[j+1](c)</comment>
    <comment>Now pc = P[n+1](c) and pmc = P[n](c).</comment>
    <comment>If "numberOfPoints" is odd, 0 is a root.</comment>
    <comment>Note: as written, the test for oddness will work for negative</comment>
    <comment>integers too (although it is not necessary here), preventing</comment>
    <comment>a FindBugs warning.</comment>
    <comment>pmc = -j * pmc / (j + 1);</comment>
    <comment>2 / pow(numberOfPoints * pmc, 2);</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
