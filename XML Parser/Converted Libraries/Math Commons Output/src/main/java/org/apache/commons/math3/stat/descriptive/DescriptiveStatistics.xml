<?xml version="1.0" encoding="UTF-8"?>
<class name="DescriptiveStatistics">
  <javadoc>
    <text>Maintains a dataset of values of a single variable and computes descriptive
 * statistics based on stored data. The {@link #getWindowSize() windowSize}property sets a limit on the number of values that can be stored in the
 * dataset.  The default value, INFINITE_WINDOW, puts no limit on the size of
 * the dataset.  This value should be used with caution, as the backing store
 * will grow without bound in this case.  For very large datasets,{@link SummaryStatistics}, which does not store the dataset, should be used
 * instead of this class. If &lt;code&gt;windowSize&lt;/code&gt; is not INFINITE_WINDOW and
 * more values are added than can be stored in the dataset, new values are
 * added in a "rolling" manner, with new values replacing the "oldest" values
 * in the dataset.
 * &lt;p&gt;Note: this class is not threadsafe.  Use{@link SynchronizedDescriptiveStatistics} if concurrent access from multiple
 * threads is required.&lt;/p&gt;</text>
    <version>$Id: DescriptiveStatistics.java 1422354 2012-12-15 20:59:01Z psteitz $</version>
  </javadoc>
  <javadoc>
    <text>Represents an infinite window size.  When the {@link #getWindowSize()}returns this value, there is no limit to the number of data values
 * that can be stored in the dataset.</text>
  </javadoc>
  <declaration type="int" name="INFINITE_WINDOW" />
  <javadoc>
    <text>Serialization UID</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Name of the setQuantile method.</text>
  </javadoc>
  <declaration type="String" name="SET_QUANTILE_METHOD_NAME" />
  <javadoc>
    <text>hold the window size</text>
  </javadoc>
  <declaration type="int" name="windowSize" />
  <javadoc>
    <text>Stored data values</text>
  </javadoc>
  <declaration type="ResizableDoubleArray" name="eDA" />
  <javadoc>
    <text>Mean statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="meanImpl" />
  <javadoc>
    <text>Geometric mean statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="geometricMeanImpl" />
  <javadoc>
    <text>Kurtosis statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="kurtosisImpl" />
  <javadoc>
    <text>Maximum statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="maxImpl" />
  <javadoc>
    <text>Minimum statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="minImpl" />
  <javadoc>
    <text>Percentile statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="percentileImpl" />
  <javadoc>
    <text>Skewness statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="skewnessImpl" />
  <javadoc>
    <text>Variance statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="varianceImpl" />
  <javadoc>
    <text>Sum of squares statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="sumsqImpl" />
  <javadoc>
    <text>Sum statistic implementation - can be reset by setter.</text>
  </javadoc>
  <declaration type="UnivariateStatistic" name="sumImpl" />
  <javadoc>
    <text>Construct a DescriptiveStatistics instance with an infinite window</text>
  </javadoc>
  <method type="constructor" name="DescriptiveStatistics" />
  <javadoc>
    <text>Construct a DescriptiveStatistics instance with the specified window</text>
    <param>window the window size.</param>
    <throws>MathIllegalArgumentException if window size is less than 1 but
 * not equal to {@link #INFINITE_WINDOW}</throws>
  </javadoc>
  <method type="constructor" name="DescriptiveStatistics" />
  <javadoc>
    <text>Construct a DescriptiveStatistics instance with an infinite window
 * and the initial data values in double[] initialDoubleArray.
 * If initialDoubleArray is null, then this constructor corresponds to
 * DescriptiveStatistics()</text>
    <param>initialDoubleArray the initial double[].</param>
  </javadoc>
  <method type="constructor" name="DescriptiveStatistics">
    <scope />
  </method>
  <javadoc>
    <text>Copy constructor.  Construct a new DescriptiveStatistics instance that
 * is a copy of original.</text>
    <param>original DescriptiveStatistics instance to copy</param>
    <throws>NullArgumentException if original is null</throws>
  </javadoc>
  <method type="constructor" name="DescriptiveStatistics" />
  <javadoc>
    <text>Adds the value to the dataset. If the dataset is at the maximum size
 * (i.e., the number of stored elements equals the currently configured
 * windowSize), the first (oldest) element in the dataset is discarded
 * to make room for the new value.</text>
    <param>v the value to be added</param>
  </javadoc>
  <method type="void" name="addValue">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>Removes the most recent value from the dataset.</text>
    <throws>MathIllegalStateException if there are no elements stored</throws>
  </javadoc>
  <method type="void" name="removeMostRecentValue">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Replaces the most recently stored value with the given value.
 * There must be at least one element stored to call this method.</text>
    <param>v the value to replace the most recent stored value</param>
    <return>replaced value</return>
    <throws>MathIllegalStateException if there are no elements stored</throws>
  </javadoc>
  <method type="double" name="replaceMostRecentValue" />
  <javadoc>
    <text>Returns the &lt;a href="http://www.xycoon.com/arithmetic_mean.htm"&gt;
 * arithmetic mean &lt;/a&gt; of the available values</text>
    <return>The mean or Double.NaN if no values have been added.</return>
  </javadoc>
  <method type="double" name="getMean" />
  <javadoc>
    <text>Returns the &lt;a href="http://www.xycoon.com/geometric_mean.htm"&gt;
 * geometric mean &lt;/a&gt; of the available values</text>
    <return>The geometricMean, Double.NaN if no values have been added,
 * or if the product of the available values is less than or equal to 0.</return>
  </javadoc>
  <method type="double" name="getGeometricMean" />
  <javadoc>
    <text>Returns the (sample) variance of the available values.
 * &lt;p&gt;This method returns the bias-corrected sample variance (using {@code n - 1} in
 * the denominator).  Use {@link #getPopulationVariance()} for the non-bias-corrected
 * population variance.&lt;/p&gt;</text>
    <return>The variance, Double.NaN if no values have been added
 * or 0.0 for a single value set.</return>
  </javadoc>
  <method type="double" name="getVariance" />
  <javadoc>
    <text>Returns the &lt;a href="http://en.wikibooks.org/wiki/Statistics/Summary/Variance"&gt;
 * population variance&lt;/a&gt; of the available values.</text>
    <return>The population variance, Double.NaN if no values have been added,
 * or 0.0 for a single value set.</return>
  </javadoc>
  <method type="double" name="getPopulationVariance" />
  <javadoc>
    <text>Returns the standard deviation of the available values.</text>
    <return>The standard deviation, Double.NaN if no values have been added
 * or 0.0 for a single value set.</return>
  </javadoc>
  <method type="double" name="getStandardDeviation">
    <declaration type="double" name="stdDev" />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the skewness of the available values. Skewness is a
 * measure of the asymmetry of a given distribution.</text>
    <return>The skewness, Double.NaN if no values have been added
 * or 0.0 for a value set &amp;lt;=2.</return>
  </javadoc>
  <method type="double" name="getSkewness" />
  <javadoc>
    <text>Returns the Kurtosis of the available values. Kurtosis is a
 * measure of the "peakedness" of a distribution</text>
    <return>The kurtosis, Double.NaN if no values have been added, or 0.0
 * for a value set &amp;lt;=3.</return>
  </javadoc>
  <method type="double" name="getKurtosis" />
  <javadoc>
    <text>Returns the maximum of the available values</text>
    <return>The max or Double.NaN if no values have been added.</return>
  </javadoc>
  <method type="double" name="getMax" />
  <javadoc>
    <text>Returns the minimum of the available values</text>
    <return>The min or Double.NaN if no values have been added.</return>
  </javadoc>
  <method type="double" name="getMin" />
  <javadoc>
    <text>Returns the number of available values</text>
    <return>The number of available values</return>
  </javadoc>
  <method type="long" name="getN" />
  <javadoc>
    <text>Returns the sum of the values that have been added to Univariate.</text>
    <return>The sum or Double.NaN if no values have been added</return>
  </javadoc>
  <method type="double" name="getSum" />
  <javadoc>
    <text>Returns the sum of the squares of the available values.</text>
    <return>The sum of the squares or Double.NaN if no
 * values have been added.</return>
  </javadoc>
  <method type="double" name="getSumsq" />
  <javadoc>
    <text>Resets all statistics and storage</text>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Returns the maximum number of values that can be stored in the
 * dataset, or INFINITE_WINDOW (-1) if there is no limit.</text>
    <return>The current window size or -1 if its Infinite.</return>
  </javadoc>
  <method type="int" name="getWindowSize" />
  <javadoc>
    <text>WindowSize controls the number of values that contribute to the
 * reported statistics.  For example, if windowSize is set to 3 and the
 * values {1,2,3,4,5} have been added &lt;strong&gt; in that order&lt;/strong&gt; then
 * the &lt;i&gt;available values&lt;/i&gt; are {3,4,5} and all reported statistics will
 * be based on these values. If {@code windowSize} is decreased as a result
 * of this call and there are more than the new value of elements in the
 * current dataset, values from the front of the array are discarded to
 * reduce the dataset to {@code windowSize} elements.</text>
    <param>windowSize sets the size of the window.</param>
    <throws>MathIllegalArgumentException if window size is less than 1 but
 * not equal to {@link #INFINITE_WINDOW}</throws>
  </javadoc>
  <method type="void" name="setWindowSize">
    <scope />
    <scope />
    <comment>We need to check to see if we need to discard elements</comment>
    <comment>from the front of the array.  If the windowSize is less than</comment>
    <comment>the current number of elements.</comment>
  </method>
  <javadoc>
    <text>Returns the current set of values in an array of double primitives.
 * The order of addition is preserved.  The returned array is a fresh
 * copy of the underlying data -- i.e., it is not a reference to the
 * stored data.</text>
    <return>returns the current set of numbers in the order in which they
 * were added to this set</return>
  </javadoc>
  <method type="double[]" name="getValues" />
  <javadoc>
    <text>Returns the current set of values in an array of double primitives,
 * sorted in ascending order.  The returned array is a fresh
 * copy of the underlying data -- i.e., it is not a reference to the
 * stored data.</text>
    <return>returns the current set of
 * numbers sorted in ascending order</return>
  </javadoc>
  <method type="double[]" name="getSortedValues">
    <declaration type="double[]" name="sort" />
  </method>
  <javadoc>
    <text>Returns the element at the specified index</text>
    <param>index The Index of the element</param>
    <return>return the element at the specified index</return>
  </javadoc>
  <method type="double" name="getElement" />
  <javadoc>
    <text>Returns an estimate for the pth percentile of the stored values.
 * &lt;p&gt;
 * The implementation provided here follows the first estimation procedure presented
 * &lt;a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm"&gt;here.&lt;/a&gt;
 * &lt;/p&gt;&lt;p&gt;
 * &lt;strong&gt;Preconditions&lt;/strong&gt;:&lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;0 &amp;lt; p &amp;le; 100&lt;/code&gt; (otherwise an
 * &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; is thrown)&lt;/li&gt;
 * &lt;li&gt;at least one value must be stored (returns &lt;code&gt;Double.NaN
 * &lt;/code&gt; otherwise)&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;</text>
    <param>p the requested percentile (scaled from 0 - 100)</param>
    <return>An estimate for the pth percentile of the stored data</return>
    <throws>MathIllegalStateException if percentile implementation has been
 * overridden and the supplied implementation does not support setQuantile</throws>
    <throws>MathIllegalArgumentException if p is not a valid quantile</throws>
  </javadoc>
  <method type="double" name="getPercentile">
    <scope />
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>Setter guard should prevent</comment>
  </method>
  <javadoc>
    <text>Generates a text report displaying univariate statistics from values
 * that have been added.  Each statistic is displayed on a separate
 * line.</text>
    <return>String with line feeds displaying statistics</return>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="StringBuilder" name="outBuffer" />
    <declaration type="String" name="endl" />
    <scope />
    <scope />
    <comment>No catch for MIAE because actual parameter is valid below</comment>
  </method>
  <javadoc>
    <text>Apply the given statistic to the data associated with this set of statistics.</text>
    <param>stat the statistic to apply</param>
    <return>the computed value of the statistic.</return>
  </javadoc>
  <method type="double" name="apply">
    <comment>No try-catch or advertised exception here because arguments are guaranteed valid</comment>
  </method>
  <javadoc>
    <text>Returns the currently configured mean implementation.</text>
    <return>the UnivariateStatistic implementing the mean</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getMeanImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the mean.&lt;/p&gt;</text>
    <param>meanImpl the UnivariateStatistic instance to use
 * for computing the mean</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setMeanImpl" />
  <javadoc>
    <text>Returns the currently configured geometric mean implementation.</text>
    <return>the UnivariateStatistic implementing the geometric mean</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getGeometricMeanImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the gemoetric mean.&lt;/p&gt;</text>
    <param>geometricMeanImpl the UnivariateStatistic instance to use
 * for computing the geometric mean</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setGeometricMeanImpl" />
  <javadoc>
    <text>Returns the currently configured kurtosis implementation.</text>
    <return>the UnivariateStatistic implementing the kurtosis</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getKurtosisImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the kurtosis.&lt;/p&gt;</text>
    <param>kurtosisImpl the UnivariateStatistic instance to use
 * for computing the kurtosis</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setKurtosisImpl" />
  <javadoc>
    <text>Returns the currently configured maximum implementation.</text>
    <return>the UnivariateStatistic implementing the maximum</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getMaxImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the maximum.&lt;/p&gt;</text>
    <param>maxImpl the UnivariateStatistic instance to use
 * for computing the maximum</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setMaxImpl" />
  <javadoc>
    <text>Returns the currently configured minimum implementation.</text>
    <return>the UnivariateStatistic implementing the minimum</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getMinImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the minimum.&lt;/p&gt;</text>
    <param>minImpl the UnivariateStatistic instance to use
 * for computing the minimum</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setMinImpl" />
  <javadoc>
    <text>Returns the currently configured percentile implementation.</text>
    <return>the UnivariateStatistic implementing the percentile</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getPercentileImpl" />
  <javadoc>
    <text>Sets the implementation to be used by {@link #getPercentile(double)}.
 * The supplied &lt;code&gt;UnivariateStatistic&lt;/code&gt; must provide a
 * &lt;code&gt;setQuantile(double)&lt;/code&gt; method; otherwise
 * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</text>
    <param>percentileImpl the percentileImpl to set</param>
    <throws>MathIllegalArgumentException if the supplied implementation does not
 * provide a &lt;code&gt;setQuantile&lt;/code&gt; method</throws>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setPercentileImpl">
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns the currently configured skewness implementation.</text>
    <return>the UnivariateStatistic implementing the skewness</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getSkewnessImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the skewness.&lt;/p&gt;</text>
    <param>skewnessImpl the UnivariateStatistic instance to use
 * for computing the skewness</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setSkewnessImpl" />
  <javadoc>
    <text>Returns the currently configured variance implementation.</text>
    <return>the UnivariateStatistic implementing the variance</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getVarianceImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the variance.&lt;/p&gt;</text>
    <param>varianceImpl the UnivariateStatistic instance to use
 * for computing the variance</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setVarianceImpl" />
  <javadoc>
    <text>Returns the currently configured sum of squares implementation.</text>
    <return>the UnivariateStatistic implementing the sum of squares</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getSumsqImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the sum of squares.&lt;/p&gt;</text>
    <param>sumsqImpl the UnivariateStatistic instance to use
 * for computing the sum of squares</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setSumsqImpl" />
  <javadoc>
    <text>Returns the currently configured sum implementation.</text>
    <return>the UnivariateStatistic implementing the sum</return>
    <since>1.2</since>
  </javadoc>
  <method type="UnivariateStatistic" name="getSumImpl" />
  <javadoc>
    <text>&lt;p&gt;Sets the implementation for the sum.&lt;/p&gt;</text>
    <param>sumImpl the UnivariateStatistic instance to use
 * for computing the sum</param>
    <since>1.2</since>
  </javadoc>
  <method type="void" name="setSumImpl" />
  <javadoc>
    <text>Returns a copy of this DescriptiveStatistics instance with the same internal state.</text>
    <return>a copy of this</return>
  </javadoc>
  <method type="DescriptiveStatistics" name="copy">
    <declaration type="DescriptiveStatistics" name="result" />
    <comment>No try-catch or advertised exception because parms are guaranteed valid</comment>
  </method>
  <javadoc>
    <text>Copies source to dest.
 * &lt;p&gt;Neither source nor dest can be null.&lt;/p&gt;</text>
    <param>source DescriptiveStatistics to copy</param>
    <param>dest DescriptiveStatistics to copy to</param>
    <throws>NullArgumentException if either source or dest is null</throws>
  </javadoc>
  <method type="void" name="copy">
    <comment>Copy data and window size</comment>
    <comment>Copy implementations</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>Implementation getters and setter</comment>
</class>
