<?xml version="1.0" encoding="UTF-8"?>
<class name="CycleCrossover">
  <javadoc>
    <text>Cycle Crossover [CX] builds offspring from &lt;b&gt;ordered&lt;/b&gt; chromosomes by identifying cycles
 * between two parent chromosomes. To form the children, the cycles are copied from the
 * respective parents.
 * &lt;p&gt;
 * To form a cycle the following procedure is applied:
 * &lt;ol&gt;
 * &lt;li&gt;start with the first gene of parent 1&lt;/li&gt;
 * &lt;li&gt;look at the gene at the same position of parent 2&lt;/li&gt;
 * &lt;li&gt;go to the position with the same gene in parent 1&lt;/li&gt;
 * &lt;li&gt;add this gene index to the cycle&lt;/li&gt;
 * &lt;li&gt;repeat the steps 2-5 until we arrive at the starting gene of this cycle&lt;/li&gt;
 * &lt;/ol&gt;
 * The indices that form a cycle are then used to form the children in alternating order, i.e.
 * in cycle 1, the genes of parent 1 are copied to child 1, while in cycle 2 the genes of parent 1
 * are copied to child 2, and so forth ...
 * &lt;/p&gt;
 * Example (zero-start cycle):
 * &lt;pre&gt;
 * p1 = (8 4 7 3 6 2 5 1 9 0)    X   c1 = (8 1 2 3 4 5 6 7 9 0)
 * p2 = (0 1 2 3 4 5 6 7 8 9)    X   c2 = (0 4 7 3 6 2 5 1 8 9)
 * cycle 1: 8 0 9
 * cycle 2: 4 1 7 2 5 6
 * cycle 3: 3
 * &lt;/pre&gt;
 * This policy works only on {@link AbstractListChromosome}, and therefore it
 * is parameterized by T. Moreover, the chromosomes must have same lengths.</text>
    <see>&lt;a href="http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx"&gt;
 * Cycle Crossover Operator&lt;/a&gt;</see>
    <param>&lt;T&gt;
 *  generic type of the {@link AbstractListChromosome}s for crossover</param>
    <since>3.1</since>
    <version>$Id: CycleCrossover.java 1385297 2012-09-16 16:05:57Z tn $</version>
  </javadoc>
  <javadoc>
    <text>If the start index shall be chosen randomly.</text>
  </javadoc>
  <declaration type="boolean" name="randomStart" />
  <javadoc>
    <text>Creates a new {@link CycleCrossover} policy.</text>
  </javadoc>
  <method type="constructor" name="CycleCrossover" />
  <javadoc>
    <text>Creates a new {@link CycleCrossover} policy using the given {@code randomStart} behavior.</text>
    <param>randomStart whether the start index shall be chosen randomly or be set to 0</param>
  </javadoc>
  <method type="constructor" name="CycleCrossover" />
  <javadoc>
    <text>Returns whether the starting index is chosen randomly or set to zero.</text>
    <return>{@code true} if the starting index is chosen randomly, {@code false} otherwise</return>
  </javadoc>
  <method type="boolean" name="isRandomStart" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>MathIllegalArgumentException if the chromosomes are not an instance of {@link AbstractListChromosome}</throws>
    <throws>DimensionMismatchException if the length of the two chromosomes is different</throws>
  </javadoc>
  <method type="ChromosomePair" name="crossover">
    <scope />
  </method>
  <javadoc>
    <text>Helper for {@link #crossover(Chromosome,Chromosome)}. Performs the actual crossover.</text>
    <param>first the first chromosome</param>
    <param>second the second chromosome</param>
    <return>the pair of new chromosomes that resulted from the crossover</return>
    <throws>DimensionMismatchException if the length of the two chromosomes is different</throws>
  </javadoc>
  <method type="ChromosomePair" name="mate">
    <declaration type="int" name="length" />
    <scope />
    <declaration type="List&lt;T&gt;" name="parent1Rep" />
    <declaration type="List&lt;T&gt;" name="parent2Rep" />
    <declaration type="List&lt;T&gt;" name="child1Rep" />
    <declaration type="List&lt;T&gt;" name="child2Rep" />
    <declaration type="Set&lt;Integer&gt;" name="visitedIndices" />
    <declaration type="List&lt;Integer&gt;" name="indices" />
    <declaration type="int" name="idx" />
    <declaration type="int" name="cycle" />
    <scope>
      <declaration type="T" name="item" />
      <scope />
      <scope>
        <scope>
          <declaration type="T" name="tmp" />
        </scope>
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>array representations of the parents</comment>
    <comment>and of the children: do a crossover copy to simplify the later processing</comment>
    <comment>the set of all visited indices so far</comment>
    <comment>the indices of the current cycle</comment>
    <comment>determine the starting index</comment>
    <comment>add that index to the cycle indices</comment>
    <comment>get the item in the second parent at that index</comment>
    <comment>get the index of that item in the first parent</comment>
    <comment>for even cycles: swap the child elements on the indices found in this cycle</comment>
    <comment>find next starting index: last one + 1 until we find an unvisited index</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
