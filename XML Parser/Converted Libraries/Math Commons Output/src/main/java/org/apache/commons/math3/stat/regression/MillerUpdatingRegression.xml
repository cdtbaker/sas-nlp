<?xml version="1.0" encoding="UTF-8"?>
<class name="MillerUpdatingRegression">
  <javadoc>
    <text>This class is a concrete implementation of the {@link UpdatingMultipleLinearRegression} interface.
 * &lt;p&gt;The algorithm is described in: &lt;pre&gt;
 * Algorithm AS 274: Least Squares Routines to Supplement Those of Gentleman
 * Author(s): Alan J. Miller
 * Source: Journal of the Royal Statistical Society.
 * Series C (Applied Statistics), Vol. 41, No. 2
 * (1992), pp. 458-478
 * Published by: Blackwell Publishing for the Royal Statistical Society
 * Stable URL: http://www.jstor.org/stable/2347583 &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;This method for multiple regression forms the solution to the OLS problem
 * by updating the QR decomposition as described by Gentleman.&lt;/p&gt;</text>
    <version>$Id: MillerUpdatingRegression.java 1392358 2012-10-01 14:41:55Z psteitz $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>number of variables in regression</text>
  </javadoc>
  <declaration type="int" name="nvars" />
  <javadoc>
    <text>diagonals of cross products matrix</text>
  </javadoc>
  <declaration type="double[]" name="d" />
  <javadoc>
    <text>the elements of the R`Y</text>
  </javadoc>
  <declaration type="double[]" name="rhs" />
  <javadoc>
    <text>the off diagonal portion of the R matrix</text>
  </javadoc>
  <declaration type="double[]" name="r" />
  <javadoc>
    <text>the tolerance for each of the variables</text>
  </javadoc>
  <declaration type="double[]" name="tol" />
  <javadoc>
    <text>residual sum of squares for all nested regressions</text>
  </javadoc>
  <declaration type="double[]" name="rss" />
  <javadoc>
    <text>order of the regressors</text>
  </javadoc>
  <declaration type="int[]" name="vorder" />
  <javadoc>
    <text>scratch space for tolerance calc</text>
  </javadoc>
  <declaration type="double[]" name="work_tolset" />
  <javadoc>
    <text>number of observations entered</text>
  </javadoc>
  <declaration type="long" name="nobs" />
  <javadoc>
    <text>sum of squared errors of largest regression</text>
  </javadoc>
  <declaration type="double" name="sserr" />
  <javadoc>
    <text>has rss been called?</text>
  </javadoc>
  <declaration type="boolean" name="rss_set" />
  <javadoc>
    <text>has the tolerance setting method been called</text>
  </javadoc>
  <declaration type="boolean" name="tol_set" />
  <javadoc>
    <text>flags for variables with linear dependency problems</text>
  </javadoc>
  <declaration type="boolean[]" name="lindep" />
  <javadoc>
    <text>singular x values</text>
  </javadoc>
  <declaration type="double[]" name="x_sing" />
  <javadoc>
    <text>workspace for singularity method</text>
  </javadoc>
  <declaration type="double[]" name="work_sing" />
  <javadoc>
    <text>summation of Y variable</text>
  </javadoc>
  <declaration type="double" name="sumy" />
  <javadoc>
    <text>summation of squared Y values</text>
  </javadoc>
  <declaration type="double" name="sumsqy" />
  <javadoc>
    <text>boolean flag whether a regression constant is added</text>
  </javadoc>
  <declaration type="boolean" name="hasIntercept" />
  <javadoc>
    <text>zero tolerance</text>
  </javadoc>
  <declaration type="double" name="epsilon" />
  <javadoc>
    <text>Set the default constructor to private access
 * to prevent inadvertent instantiation</text>
  </javadoc>
  <method type="constructor" name="MillerUpdatingRegression" />
  <javadoc>
    <text>This is the augmented constructor for the MillerUpdatingRegression class.</text>
    <param>numberOfVariables number of regressors to expect, not including constant</param>
    <param>includeConstant include a constant automatically</param>
    <param>errorTolerance  zero tolerance, how machine zero is determined</param>
    <throws>ModelSpecificationException if {@code numberOfVariables is less than 1}</throws>
  </javadoc>
  <method type="constructor" name="MillerUpdatingRegression">
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Primary constructor for the MillerUpdatingRegression.</text>
    <param>numberOfVariables maximum number of potential regressors</param>
    <param>includeConstant include a constant automatically</param>
    <throws>ModelSpecificationException if {@code numberOfVariables is less than 1}</throws>
  </javadoc>
  <method type="constructor" name="MillerUpdatingRegression" />
  <javadoc>
    <text>A getter method which determines whether a constant is included.</text>
    <return>true regression has an intercept, false no intercept</return>
  </javadoc>
  <method type="boolean" name="hasIntercept" />
  <javadoc>
    <text>Gets the number of observations added to the regression model.</text>
    <return>number of observations</return>
  </javadoc>
  <method type="long" name="getN" />
  <javadoc>
    <text>Adds an observation to the regression model.</text>
    <param>x the array with regressor values</param>
    <param>y  the value of dependent variable given these regressors</param>
    <exception>ModelSpecificationException if the length of {@code x} does not equal
 * the number of independent variables in the model</exception>
  </javadoc>
  <method type="void" name="addObservation">
    <scope />
    <scope />
    <scope>
      <declaration type="double[]" name="tmp" />
    </scope>
  </method>
  <javadoc>
    <text>Adds multiple observations to the model.</text>
    <param>x observations on the regressors</param>
    <param>y observations on the regressand</param>
    <throws>ModelSpecificationException if {@code x} is not rectangular, does not match
 * the length of {@code y} or does not contain sufficient data to estimate the model</throws>
  </javadoc>
  <method type="void" name="addObservations">
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>Must be no y data either</comment>
  </method>
  <javadoc>
    <text>The include method is where the QR decomposition occurs. This statement forms all
 * intermediate data which will be used for all derivative measures.
 * According to the miller paper, note that in the original implementation the x vector
 * is overwritten. In this implementation, the include method is passed a copy of the
 * original data vector so that there is no contamination of the data. Additionally,
 * this method differs slightly from Gentleman's method, in that the assumption is
 * of dense design matrices, there is some advantage in using the original gentleman algorithm
 * on sparse matrices.</text>
    <param>x observations on the regressors</param>
    <param>wi weight of the this observation (-1,1)</param>
    <param>yi observation on the regressand</param>
  </javadoc>
  <method type="void" name="include">
    <declaration type="int" name="nextr" />
    <declaration type="double" name="w" />
    <declaration type="double" name="y" />
    <declaration type="double" name="xi" />
    <declaration type="double" name="di" />
    <declaration type="double" name="wxi" />
    <declaration type="double" name="dpi" />
    <declaration type="double" name="xk" />
    <declaration type="double" name="_w" />
    <scope>
      <scope />
      <scope />
      <scope>
        <declaration type="double" name="tmp" />
        <scope />
      </scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Adds to number a and b such that the contamination due to
 * numerical smallness of one addend does not corrupt the sum.</text>
    <param>a - an addend</param>
    <param>b - an addend</param>
    <return>the sum of the a and b</return>
  </javadoc>
  <method type="double" name="smartAdd">
    <declaration type="double" name="_a" />
    <declaration type="double" name="_b" />
    <scope>
      <declaration type="double" name="eps" />
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="eps" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>As the name suggests,  clear wipes the internals and reorders everything in the
 * canonical order.</text>
  </javadoc>
  <method type="void" name="clear">
    <scope />
  </method>
  <javadoc>
    <text>This sets up tolerances for singularity testing.</text>
  </javadoc>
  <method type="void" name="tolset">
    <declaration type="int" name="pos" />
    <declaration type="double" name="total" />
    <declaration type="double" name="eps" />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>The regcf method conducts the linear regression and extracts the
 * parameter vector. Notice that the algorithm can do subset regression
 * with no alteration.</text>
    <param>nreq how many of the regressors to include (either in canonical
 * order, or in the current reordered state)</param>
    <return>an array with the estimated slope coefficients</return>
    <throws>ModelSpecificationException if {@code nreq} is less than 1
 * or greater than the number of independent variables</throws>
  </javadoc>
  <method type="double[]" name="regcf">
    <declaration type="int" name="nextr" />
    <scope />
    <scope />
    <scope />
    <declaration type="double[]" name="ret" />
    <declaration type="boolean" name="rankProblem" />
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>The method which checks for singularities and then eliminates the offending
 * columns.</text>
  </javadoc>
  <method type="void" name="singcheck">
    <declaration type="int" name="pos" />
    <scope />
    <scope>
      <declaration type="double" name="temp" />
      <scope>
        <scope />
      </scope>
      <scope>
        <scope>
          <declaration type="int" name="_pi" />
          <scope />
          <declaration type="double" name="y" />
          <declaration type="double" name="weight" />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>Set elements within R to zero if they are less than tol(col) in</comment>
    <comment>absolute value after being scaled by the square root of their row</comment>
    <comment>multiplier</comment>
    <comment>If diagonal element is near zero, set it to zero, set appropriate</comment>
    <comment>element of LINDEP, and use INCLUD to augment the projections in</comment>
    <comment>the lower rows of the orthogonalization.</comment>
  </method>
  <javadoc>
    <text>Calculates the sum of squared errors for the full regression
 * and all subsets in the following manner: &lt;pre&gt;
 * rss[] ={
 * ResidualSumOfSquares_allNvars,
 * ResidualSumOfSquares_FirstNvars-1,
 * ResidualSumOfSquares_FirstNvars-2,
 * ..., ResidualSumOfSquares_FirstVariable} &lt;/pre&gt;</text>
  </javadoc>
  <method type="void" name="ss">
    <declaration type="double" name="total" />
    <scope />
  </method>
  <javadoc>
    <text>Calculates the cov matrix assuming only the first nreq variables are
 * included in the calculation. The returned array contains a symmetric
 * matrix stored in lower triangular form. The matrix will have
 * ( nreq + 1 ) * nreq / 2 elements. For illustration &lt;pre&gt;
 * cov =
 * {
 * cov_00,
 * cov_10, cov_11,
 * cov_20, cov_21, cov22,
 * ...
 * } &lt;/pre&gt;</text>
    <param>nreq how many of the regressors to include (either in canonical
 * order, or in the current reordered state)</param>
    <return>an array with the variance covariance of the included
 * regressors in lower triangular form</return>
  </javadoc>
  <method type="double[]" name="cov">
    <scope />
    <declaration type="double" name="rnk" />
    <scope>
      <scope />
    </scope>
    <declaration type="double" name="var" />
    <declaration type="double[]" name="rinv" />
    <declaration type="double[]" name="covmat" />
    <declaration type="int" name="pos2" />
    <declaration type="int" name="pos1" />
    <declaration type="int" name="start" />
    <declaration type="double" name="total" />
    <scope>
      <scope>
        <scope>
          <scope>
            <scope />
            <scope />
            <scope>
              <scope />
            </scope>
          </scope>
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>This internal method calculates the inverse of the upper-triangular portion
 * of the R matrix.</text>
    <param>rinv  the storage for the inverse of r</param>
    <param>nreq how many of the regressors to include (either in canonical
 * order, or in the current reordered state)</param>
  </javadoc>
  <method type="void" name="inverse">
    <declaration type="int" name="pos" />
    <declaration type="int" name="pos1" />
    <declaration type="int" name="pos2" />
    <declaration type="double" name="total" />
    <scope>
      <scope>
        <declaration type="int" name="start" />
        <scope>
          <scope>
            <scope />
          </scope>
        </scope>
      </scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>In the original algorithm only the partial correlations of the regressors
 * is returned to the user. In this implementation, we have &lt;pre&gt;
 * corr =
 * {
 * corrxx - lower triangular
 * corrxy - bottom row of the matrix
 * }
 * Replaces subroutines PCORR and COR of:
 * ALGORITHM AS274  APPL. STATIST. (1992) VOL.41, NO. 2 &lt;/pre&gt;
 * &lt;p&gt;Calculate partial correlations after the variables in rows
 * 1, 2, ..., IN have been forced into the regression.
 * If IN = 1, and the first row of R represents a constant in the
 * model, then the usual simple correlations are returned.&lt;/p&gt;
 * &lt;p&gt;If IN = 0, the value returned in array CORMAT for the correlation
 * of variables Xi &amp; Xj is: &lt;pre&gt;
 * sum ( Xi.Xj ) / Sqrt ( sum (Xi^2) . sum (Xj^2) )&lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;On return, array CORMAT contains the upper triangle of the matrix of
 * partial correlations stored by rows, excluding the 1's on the diagonal.
 * e.g. if IN = 2, the consecutive elements returned are:
 * (3,4) (3,5) ... (3,ncol), (4,5) (4,6) ... (4,ncol), etc.
 * Array YCORR stores the partial correlations with the Y-variable
 * starting with YCORR(IN+1) = partial correlation with the variable in
 * position (IN+1). &lt;/p&gt;</text>
    <param>in how many of the regressors to include (either in canonical
 * order, or in the current reordered state)</param>
    <return>an array with the partial correlations of the remainder of
 * regressors with each other and the regressand, in lower triangular form</return>
  </javadoc>
  <method type="double[]" name="getPartialCorrelations">
    <declaration type="double[]" name="output" />
    <declaration type="int" name="pos" />
    <declaration type="int" name="pos1" />
    <declaration type="int" name="pos2" />
    <declaration type="int" name="rms_off" />
    <declaration type="int" name="wrk_off" />
    <declaration type="double[]" name="rms" />
    <declaration type="double[]" name="work" />
    <declaration type="double" name="sumxx" />
    <declaration type="double" name="sumxy" />
    <declaration type="double" name="sumyy" />
    <declaration type="int" name="offXX" />
    <scope />
    <declaration type="int" name="nvm" />
    <declaration type="int" name="base_pos" />
    <scope />
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <scope>
      <scope>
        <scope />
      </scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>ALGORITHM AS274 APPL. STATIST. (1992) VOL.41, NO. 2.
 * Move variable from position FROM to position TO in an
 * orthogonal reduction produced by AS75.1.</text>
    <param>from initial position</param>
    <param>to destination</param>
  </javadoc>
  <method type="void" name="vmove">
    <declaration type="double" name="d1" />
    <declaration type="double" name="d2" />
    <declaration type="double" name="X" />
    <declaration type="double" name="d1new" />
    <declaration type="double" name="d2new" />
    <declaration type="double" name="cbar" />
    <declaration type="double" name="sbar" />
    <declaration type="double" name="Y" />
    <declaration type="int" name="first" />
    <declaration type="int" name="inc" />
    <declaration type="int" name="m1" />
    <declaration type="int" name="m2" />
    <declaration type="int" name="mp1" />
    <declaration type="int" name="pos" />
    <declaration type="boolean" name="bSkipTo40" />
    <scope />
    <scope />
    <declaration type="int" name="count" />
    <scope />
    <scope />
    <declaration type="int" name="m" />
    <declaration type="int" name="idx" />
    <scope>
      <scope>
        <scope />
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Special cases.</comment>
    <comment>break;</comment>
    <comment>break;</comment>
    <comment>Adjust variable order (VORDER), the tolerances (TOL) and</comment>
    <comment>the vector of residual sums of squares (RSS).</comment>
  </method>
  <javadoc>
    <text>ALGORITHM AS274  APPL. STATIST. (1992) VOL.41, NO. 2
 * &lt;p&gt; Re-order the variables in an orthogonal reduction produced by
 * AS75.1 so that the N variables in LIST start at position POS1,
 * though will not necessarily be in the same order as in LIST.
 * Any variables in VORDER before position POS1 are not moved.
 * Auxiliary routine called: VMOVE. &lt;/p&gt;
 * &lt;p&gt;This internal method reorders the regressors.&lt;/p&gt;</text>
    <param>list the regressors to move</param>
    <param>pos1 where the list will be placed</param>
    <return>-1 error, 0 everything ok</return>
  </javadoc>
  <method type="int" name="reorderRegressors">
    <declaration type="int" name="next" />
    <declaration type="int" name="i" />
    <declaration type="int" name="l" />
    <scope />
    <scope>
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Gets the diagonal of the Hat matrix also known as the leverage matrix.</text>
    <param>row_data returns the diagonal of the hat matrix for this observation</param>
    <return>the diagonal element of the hatmatrix</return>
  </javadoc>
  <method type="double" name="getDiagonalOfHatMatrix">
    <declaration type="double[]" name="wk" />
    <declaration type="int" name="pos" />
    <declaration type="double" name="total" />
    <scope />
    <declaration type="double[]" name="xrow" />
    <scope />
    <scope />
    <declaration type="double" name="hii" />
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Gets the order of the regressors, useful if some type of reordering
 * has been called. Calling regress with int[]{} args will trigger
 * a reordering.</text>
    <return>int[] with the current order of the regressors</return>
  </javadoc>
  <method type="int[]" name="getOrderOfRegressors" />
  <javadoc>
    <text>Conducts a regression on the data in the model, using all regressors.</text>
    <return>RegressionResults the structure holding all regression results</return>
    <exception>ModelSpecificationException - thrown if number of observations is
 * less than the number of variables</exception>
  </javadoc>
  <method type="RegressionResults" name="regress" />
  <javadoc>
    <text>Conducts a regression on the data in the model, using a subset of regressors.</text>
    <param>numberOfRegressors many of the regressors to include (either in canonical
 * order, or in the current reordered state)</param>
    <return>RegressionResults the structure holding all regression results</return>
    <exception>ModelSpecificationException - thrown if number of observations is
 * less than the number of variables or number of regressors requested
 * is greater than the regressors in the model</exception>
  </javadoc>
  <method type="RegressionResults" name="regress">
    <scope />
    <scope />
    <declaration type="double[]" name="beta" />
    <declaration type="double[]" name="cov" />
    <declaration type="int" name="rnk" />
    <scope>
      <scope />
    </scope>
    <declaration type="boolean" name="needsReorder" />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="double[]" name="betaNew" />
      <declaration type="double[]" name="covNew" />
      <declaration type="int[]" name="newIndices" />
      <scope>
        <scope>
          <scope />
        </scope>
      </scope>
      <declaration type="int" name="idx1" />
      <declaration type="int" name="idx2" />
      <declaration type="int" name="_i" />
      <declaration type="int" name="_j" />
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Conducts a regression on the data in the model, using regressors in array
 * Calling this method will change the internal order of the regressors
 * and care is required in interpreting the hatmatrix.</text>
    <param>variablesToInclude array of variables to include in regression</param>
    <return>RegressionResults the structure holding all regression results</return>
    <exception>ModelSpecificationException - thrown if number of observations is
 * less than the number of variables, the number of regressors requested
 * is greater than the regressors in the model or a regressor index in
 * regressor array does not exist</exception>
  </javadoc>
  <method type="RegressionResults" name="regress">
    <scope />
    <scope />
    <declaration type="int" name="iExclude" />
    <scope>
      <scope />
      <scope />
    </scope>
    <declaration type="int[]" name="series" />
    <scope>
      <declaration type="int" name="j" />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <declaration type="double[]" name="beta" />
    <declaration type="double[]" name="cov" />
    <declaration type="int" name="rnk" />
    <scope>
      <scope />
    </scope>
    <declaration type="boolean" name="needsReorder" />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="double[]" name="betaNew" />
      <declaration type="int[]" name="newIndices" />
      <scope>
        <scope>
          <scope />
        </scope>
      </scope>
      <declaration type="double[]" name="covNew" />
      <declaration type="int" name="idx1" />
      <declaration type="int" name="idx2" />
      <declaration type="int" name="_i" />
      <declaration type="int" name="_j" />
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
