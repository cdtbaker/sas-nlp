<?xml version="1.0" encoding="UTF-8"?>
<class name="Frequency">
  <javadoc>
    <text>Maintains a frequency distribution.
 * &lt;p&gt;
 * Accepts int, long, char or Comparable values.  New values added must be
 * comparable to those that have been added, otherwise the add method will
 * throw an IllegalArgumentException.&lt;/p&gt;
 * &lt;p&gt;
 * Integer values (int, long, Integer, Long) are not distinguished by type --
 * i.e. &lt;code&gt;addValue(Long.valueOf(2)), addValue(2), addValue(2l)&lt;/code&gt; all have
 * the same effect (similarly for arguments to &lt;code&gt;getCount,&lt;/code&gt; etc.).&lt;/p&gt;
 * &lt;p&gt;
 * char values are converted by &lt;code&gt;addValue&lt;/code&gt; to Character instances.
 * As such, these values are not comparable to integral values, so attempts
 * to combine integral types with chars in a frequency distribution will fail.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The values are ordered using the default (natural order), unless a
 * &lt;code&gt;Comparator&lt;/code&gt; is supplied in the constructor.&lt;/p&gt;</text>
    <version>$Id: Frequency.java 1455703 2013-03-12 20:46:23Z tn $</version>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>underlying collection</text>
  </javadoc>
  <declaration type="TreeMap&lt;Comparable&lt;?&gt;,Long&gt;" name="freqTable" />
  <javadoc>
    <text>Default constructor.</text>
  </javadoc>
  <method type="constructor" name="Frequency" />
  <javadoc>
    <text>Constructor allowing values Comparator to be specified.</text>
    <param>comparator Comparator used to order values</param>
  </javadoc>
  <method type="constructor" name="Frequency">
    <comment>TODO is the cast OK?</comment>
  </method>
  <javadoc>
    <text>Return a string representation of this frequency
 * distribution.</text>
    <return>a string representation.</return>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="NumberFormat" name="nf" />
    <declaration type="StringBuilder" name="outBuffer" />
    <declaration type="Iterator&lt;Comparable&lt;?&gt;&gt;" name="iter" />
    <scope>
      <declaration type="Comparable&lt;?&gt;" name="value" />
    </scope>
  </method>
  <javadoc>
    <text>Adds 1 to the frequency count for v.
 * &lt;p&gt;
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * &lt;/p&gt;</text>
    <param>v the value to add.</param>
    <throws>MathIllegalArgumentException if &lt;code&gt;v&lt;/code&gt; is not comparable with previous entries</throws>
  </javadoc>
  <method type="void" name="addValue" />
  <javadoc>
    <text>Increments the frequency count for v.
 * &lt;p&gt;
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * &lt;/p&gt;</text>
    <param>v the value to add.</param>
    <param>increment the amount by which the value should be incremented</param>
    <throws>IllegalArgumentException if &lt;code&gt;v&lt;/code&gt; is not comparable with previous entries</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="incrementValue">
    <declaration type="Comparable&lt;?&gt;" name="obj" />
    <scope />
    <scope>
      <declaration type="Long" name="count" />
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>TreeMap will throw ClassCastException if v is not comparable</comment>
  </method>
  <javadoc>
    <text>Adds 1 to the frequency count for v.</text>
    <param>v the value to add.</param>
    <throws>MathIllegalArgumentException if the table contains entries not
 * comparable to Integer</throws>
  </javadoc>
  <method type="void" name="addValue" />
  <javadoc>
    <text>Adds 1 to the frequency count for v.</text>
    <param>v the value to add.</param>
    <throws>MathIllegalArgumentException if the table contains entries not
 * comparable to Long</throws>
  </javadoc>
  <method type="void" name="addValue" />
  <javadoc>
    <text>Adds 1 to the frequency count for v.</text>
    <param>v the value to add.</param>
    <throws>MathIllegalArgumentException if the table contains entries not
 * comparable to Char</throws>
  </javadoc>
  <method type="void" name="addValue" />
  <javadoc>
    <text>Clears the frequency table</text>
  </javadoc>
  <method type="void" name="clear" />
  <javadoc>
    <text>Returns an Iterator over the set of values that have been added.
 * &lt;p&gt;
 * If added values are integral (i.e., integers, longs, Integers, or Longs),
 * they are converted to Longs when they are added, so the objects returned
 * by the Iterator will in this case be Longs.&lt;/p&gt;</text>
    <return>values Iterator</return>
  </javadoc>
  <method type="Iterator&lt;Comparable&lt;?&gt;&gt;" name="valuesIterator" />
  <javadoc>
    <text>Return an Iterator over the set of keys and values that have been added.
 * Using the entry set to iterate is more efficient in the case where you
 * need to access respective counts as well as values, since it doesn't
 * require a "get" for every key...the value is provided in the Map.Entry.
 * &lt;p&gt;
 * If added values are integral (i.e., integers, longs, Integers, or Longs),
 * they are converted to Longs when they are added, so the values of the
 * map entries returned by the Iterator will in this case be Longs.&lt;/p&gt;</text>
    <return>entry set Iterator</return>
    <since>3.1</since>
  </javadoc>
  <method type="Iterator&lt;Map.Entry&lt;Comparable&lt;?&gt;,Long&gt;&gt;" name="entrySetIterator" />
  <javadoc>
    <text>Returns the sum of all frequencies.</text>
    <return>the total frequency count.</return>
  </javadoc>
  <method type="long" name="getSumFreq">
    <declaration type="long" name="result" />
    <declaration type="Iterator&lt;Long&gt;" name="iterator" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the number of values = v.
 * Returns 0 if the value is not comparable.</text>
    <param>v the value to lookup.</param>
    <return>the frequency of v.</return>
  </javadoc>
  <method type="long" name="getCount">
    <scope />
    <declaration type="long" name="result" />
    <scope>
      <declaration type="Long" name="count" />
      <scope />
    </scope>
    <scope />
    <comment>NOPMD</comment>
    <comment>ignore and return 0 -- ClassCastException will be thrown if value is not comparable</comment>
  </method>
  <javadoc>
    <text>Returns the number of values = v.</text>
    <param>v the value to lookup.</param>
    <return>the frequency of v.</return>
  </javadoc>
  <method type="long" name="getCount" />
  <javadoc>
    <text>Returns the number of values = v.</text>
    <param>v the value to lookup.</param>
    <return>the frequency of v.</return>
  </javadoc>
  <method type="long" name="getCount" />
  <javadoc>
    <text>Returns the number of values = v.</text>
    <param>v the value to lookup.</param>
    <return>the frequency of v.</return>
  </javadoc>
  <method type="long" name="getCount" />
  <javadoc>
    <text>Returns the number of values in the frequency table.</text>
    <return>the number of unique values that have been added to the frequency table.</return>
    <see>#valuesIterator()</see>
  </javadoc>
  <method type="int" name="getUniqueCount" />
  <javadoc>
    <text>Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).
 * &lt;p&gt;
 * Returns &lt;code&gt;Double.NaN&lt;/code&gt; if no values have been added.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="double" name="getPct">
    <declaration type="long" name="sumFreq" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="double" name="getPct" />
  <javadoc>
    <text>Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="double" name="getPct" />
  <javadoc>
    <text>Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="double" name="getPct" />
  <javadoc>
    <text>Returns the cumulative frequency of values less than or equal to v.
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup.</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="long" name="getCumFreq">
    <scope />
    <scope />
    <declaration type="Comparator&lt;Comparable&lt;?&gt;&gt;" name="c" />
    <scope />
    <declaration type="long" name="result" />
    <scope>
      <declaration type="Long" name="value" />
      <scope />
    </scope>
    <scope />
    <scope />
    <scope />
    <declaration type="Iterator&lt;Comparable&lt;?&gt;&gt;" name="values" />
    <scope>
      <declaration type="Comparable&lt;?&gt;" name="nextValue" />
      <scope />
      <scope />
    </scope>
    <comment>v is not comparable</comment>
    <comment>v is comparable, but less than first value</comment>
    <comment>v is comparable, but greater than the last value</comment>
  </method>
  <javadoc>
    <text>Returns the cumulative frequency of values less than or equal to v.
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="long" name="getCumFreq" />
  <javadoc>
    <text>Returns the cumulative frequency of values less than or equal to v.
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="long" name="getCumFreq" />
  <javadoc>
    <text>Returns the cumulative frequency of values less than or equal to v.
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values equal to v</return>
  </javadoc>
  <method type="long" name="getCumFreq" />
  <javadoc>
    <text>Returns the cumulative percentage of values less than or equal to v
 * (as a proportion between 0 and 1).
 * &lt;p&gt;
 * Returns &lt;code&gt;Double.NaN&lt;/code&gt; if no values have been added.
 * Returns 0 if at least one value has been added, but v is not comparable
 * to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values less than or equal to v</return>
  </javadoc>
  <method type="double" name="getCumPct">
    <declaration type="long" name="sumFreq" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the cumulative percentage of values less than or equal to v
 * (as a proportion between 0 and 1).
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values less than or equal to v</return>
  </javadoc>
  <method type="double" name="getCumPct" />
  <javadoc>
    <text>Returns the cumulative percentage of values less than or equal to v
 * (as a proportion between 0 and 1).
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values less than or equal to v</return>
  </javadoc>
  <method type="double" name="getCumPct" />
  <javadoc>
    <text>Returns the cumulative percentage of values less than or equal to v
 * (as a proportion between 0 and 1).
 * &lt;p&gt;
 * Returns 0 if v is not comparable to the values set.&lt;/p&gt;</text>
    <param>v the value to lookup</param>
    <return>the proportion of values less than or equal to v</return>
  </javadoc>
  <method type="double" name="getCumPct" />
  <javadoc>
    <text>Merge another Frequency object's counts into this instance.
 * This Frequency's counts will be incremented (or set when not already set)
 * by the counts represented by other.</text>
    <param>other the other {@link Frequency} object to be merged</param>
    <throws>NullArgumentException if {@code other} is null</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="merge">
    <declaration type="Iterator&lt;Map.Entry&lt;Comparable&lt;?&gt;,Long&gt;&gt;" name="iter" />
    <scope>
      <declaration type="Map.Entry&lt;Comparable&lt;?&gt;,Long&gt;" name="entry" />
    </scope>
  </method>
  <javadoc>
    <text>Merge a {@link Collection} of {@link Frequency} objects into this instance.
 * This Frequency's counts will be incremented (or set when not already set)
 * by the counts represented by each of the others.</text>
    <param>others the other {@link Frequency} objects to be merged</param>
    <throws>NullArgumentException if the collection is null</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="merge">
    <scope />
  </method>
  <javadoc>
    <text>A Comparator that compares comparable objects using the
 * natural order.  Copied from Commons Collections ComparableComparator.</text>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Compare the two {@link Comparable Comparable} arguments.
 * This method is equivalent to:
 * &lt;pre&gt;(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)&lt;/pre&gt;</text>
    <param>o1 the first object</param>
    <param>o2 the second object</param>
    <return>result of comparison</return>
    <throws>NullPointerException when &lt;i&gt;o1&lt;/i&gt; is &lt;code&gt;null&lt;/code&gt;,
 * or when &lt;code&gt;((Comparable)o1).compareTo(o2)&lt;/code&gt; does</throws>
    <throws>ClassCastException when &lt;i&gt;o1&lt;/i&gt; is not a {@link Comparable Comparable},
 * or when &lt;code&gt;((Comparable)o1).compareTo(o2)&lt;/code&gt; does</throws>
  </javadoc>
  <method type="int" name="compare">
    <comment>cast to (T) may throw ClassCastException, see Javadoc</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="hashCode">
    <declaration type="int" name="prime" />
    <declaration type="int" name="result" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <declaration type="Frequency" name="other" />
    <scope>
      <scope />
    </scope>
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>-------------------------------------------------------------------------</comment>
  <comment>-----------------------------------------------------------------------------------------</comment>
  <comment>----------------------------------------------------------------------------------------------</comment>
  <comment>----------------------------------------------------------------------------------------------</comment>
  <comment>----------------------------------------------------------------------------------------------</comment>
</class>
