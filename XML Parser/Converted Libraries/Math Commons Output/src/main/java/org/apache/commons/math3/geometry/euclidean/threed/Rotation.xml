<?xml version="1.0" encoding="UTF-8"?>
<class name="Rotation">
  <javadoc>
    <text>This class implements rotations in a three-dimensional space.
 * &lt;p&gt;Rotations can be represented by several different mathematical
 * entities (matrices, axe and angle, Cardan or Euler angles,
 * quaternions). This class presents an higher level abstraction, more
 * user-oriented and hiding this implementation details. Well, for the
 * curious, we use quaternions for the internal representation. The
 * user can build a rotation from any of these representations, and
 * any of these representations can be retrieved from a
 * &lt;code&gt;Rotation&lt;/code&gt; instance (see the various constructors and
 * getters). In addition, a rotation can also be built implicitly
 * from a set of vectors and their image.&lt;/p&gt;
 * &lt;p&gt;This implies that this class can be used to convert from one
 * representation to another one. For example, converting a rotation
 * matrix into a set of Cardan angles from can be done using the
 * following single line of code:&lt;/p&gt;
 * &lt;pre&gt;
 * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);
 * &lt;/pre&gt;
 * &lt;p&gt;Focus is oriented on what a rotation &lt;em&gt;do&lt;/em&gt; rather than on its
 * underlying representation. Once it has been built, and regardless of its
 * internal representation, a rotation is an &lt;em&gt;operator&lt;/em&gt; which basically
 * transforms three dimensional {@link Vector3D vectors} into other three
 * dimensional {@link Vector3D vectors}. Depending on the application, the
 * meaning of these vectors may vary and the semantics of the rotation also.&lt;/p&gt;
 * &lt;p&gt;For example in an spacecraft attitude simulation tool, users will often
 * consider the vectors are fixed (say the Earth direction for example) and the
 * frames change. The rotation transforms the coordinates of the vector in inertial
 * frame into the coordinates of the same vector in satellite frame. In this
 * case, the rotation implicitly defines the relation between the two frames.&lt;/p&gt;
 * &lt;p&gt;Another example could be a telescope control application, where the rotation
 * would transform the sighting direction at rest into the desired observing
 * direction when the telescope is pointed towards an object of interest. In this
 * case the rotation transforms the direction at rest in a topocentric frame
 * into the sighting direction in the same topocentric frame. This implies in this
 * case the frame is fixed and the vector moves.&lt;/p&gt;
 * &lt;p&gt;In many case, both approaches will be combined. In our telescope example,
 * we will probably also need to transform the observing direction in the topocentric
 * frame into the observing direction in inertial frame taking into account the observatory
 * location and the Earth rotation, which would essentially be an application of the
 * first approach.&lt;/p&gt;
 * &lt;p&gt;These examples show that a rotation is what the user wants it to be. This
 * class does not push the user towards one specific definition and hence does not
 * provide methods like &lt;code&gt;projectVectorIntoDestinationFrame&lt;/code&gt; or
 * &lt;code&gt;computeTransformedDirection&lt;/code&gt;. It provides simpler and more generic
 * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.&lt;/p&gt;
 * &lt;p&gt;Since a rotation is basically a vectorial operator, several rotations can be
 * composed together and the composite operation &lt;code&gt;r = r&lt;sub&gt;1&lt;/sub&gt; o
 * r&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; (which means that for each vector &lt;code&gt;u&lt;/code&gt;,
 * &lt;code&gt;r(u) = r&lt;sub&gt;1&lt;/sub&gt;(r&lt;sub&gt;2&lt;/sub&gt;(u))&lt;/code&gt;) is also a rotation. Hence
 * we can consider that in addition to vectors, a rotation can be applied to other
 * rotations as well (or to itself). With our previous notations, we would say we
 * can apply &lt;code&gt;r&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; to &lt;code&gt;r&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; and the result
 * we get is &lt;code&gt;r = r&lt;sub&gt;1&lt;/sub&gt; o r&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;. For this purpose, the
 * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and{@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.&lt;/p&gt;
 * &lt;p&gt;Rotations are guaranteed to be immutable objects.&lt;/p&gt;</text>
    <version>$Id: Rotation.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <see>Vector3D</see>
    <see>RotationOrder</see>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Identity rotation.</text>
  </javadoc>
  <declaration type="Rotation" name="IDENTITY" />
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Scalar coordinate of the quaternion.</text>
  </javadoc>
  <declaration type="double" name="q0" />
  <javadoc>
    <text>First coordinate of the vectorial part of the quaternion.</text>
  </javadoc>
  <declaration type="double" name="q1" />
  <javadoc>
    <text>Second coordinate of the vectorial part of the quaternion.</text>
  </javadoc>
  <declaration type="double" name="q2" />
  <javadoc>
    <text>Third coordinate of the vectorial part of the quaternion.</text>
  </javadoc>
  <declaration type="double" name="q3" />
  <javadoc>
    <text>Build a rotation from the quaternion coordinates.
 * &lt;p&gt;A rotation can be built from a &lt;em&gt;normalized&lt;/em&gt; quaternion,
 * i.e. a quaternion for which q&lt;sub&gt;0&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
 * q&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; + q&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
 * q&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. If the quaternion is not normalized,
 * the constructor can normalize it in a preprocessing step.&lt;/p&gt;
 * &lt;p&gt;Note that some conventions put the scalar part of the quaternion
 * as the 4&lt;sup&gt;th&lt;/sup&gt; component and the vector part as the first three
 * components. This is &lt;em&gt;not&lt;/em&gt; our convention. We put the scalar part
 * as the first component.&lt;/p&gt;</text>
    <param>q0 scalar part of the quaternion</param>
    <param>q1 first coordinate of the vectorial part of the quaternion</param>
    <param>q2 second coordinate of the vectorial part of the quaternion</param>
    <param>q3 third coordinate of the vectorial part of the quaternion</param>
    <param>needsNormalization if true, the coordinates are considered
 * not to be normalized, a normalization preprocessing step is performed
 * before using them</param>
  </javadoc>
  <method type="constructor" name="Rotation">
    <scope>
      <declaration type="double" name="inv" />
    </scope>
    <comment>normalization preprocessing</comment>
  </method>
  <javadoc>
    <text>Build a rotation from an axis and an angle.
 * &lt;p&gt;We use the convention that angles are oriented according to
 * the effect of the rotation on vectors around the axis. That means
 * that if (i, j, k) is a direct frame and if we first provide +k as
 * the axis and &amp;pi;/2 as the angle to this constructor, and then{@link #applyTo(Vector3D) apply} the instance to +i, we will get
 * +j.&lt;/p&gt;
 * &lt;p&gt;Another way to represent our convention is to say that a rotation
 * of angle &amp;theta; about the unit vector (x, y, z) is the same as the
 * rotation build from quaternion components { cos(-&amp;theta;/2),
 * x * sin(-&amp;theta;/2), y * sin(-&amp;theta;/2), z * sin(-&amp;theta;/2) }.
 * Note the minus sign on the angle!&lt;/p&gt;
 * &lt;p&gt;On the one hand this convention is consistent with a vectorial
 * perspective (moving vectors in fixed frames), on the other hand it
 * is different from conventions with a frame perspective (fixed vectors
 * viewed from different frames) like the ones used for example in spacecraft
 * attitude community or in the graphics community.&lt;/p&gt;</text>
    <param>axis axis around which to rotate</param>
    <param>angle rotation angle.</param>
    <exception>MathIllegalArgumentException if the axis norm is zero</exception>
  </javadoc>
  <method type="constructor" name="Rotation">
    <declaration type="double" name="norm" />
    <scope />
    <declaration type="double" name="halfAngle" />
    <declaration type="double" name="coeff" />
  </method>
  <javadoc>
    <text>Build a rotation from a 3X3 matrix.
 * &lt;p&gt;Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m&lt;sup&gt;T&lt;/sup&gt; = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.&lt;/p&gt;
 * &lt;p&gt;When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.&lt;p&gt;</text>
    <param>m rotation matrix</param>
    <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
    <exception>NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative</exception>
  </javadoc>
  <method type="constructor" name="Rotation">
    <scope />
    <declaration type="double[][]" name="ort" />
    <declaration type="double" name="det" />
    <scope />
    <declaration type="double[]" name="quat" />
    <comment>dimension check</comment>
    <comment>compute a "close" orthogonal matrix</comment>
    <comment>check the sign of the determinant</comment>
  </method>
  <javadoc>
    <text>Build the rotation that transforms a pair of vector into another pair.
 * &lt;p&gt;Except for possible scale factors, if the instance were applied to
 * the pair (u&lt;sub&gt;1&lt;/sub&gt;, u&lt;sub&gt;2&lt;/sub&gt;) it will produce the pair
 * (v&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;).&lt;/p&gt;
 * &lt;p&gt;If the angular separation between u&lt;sub&gt;1&lt;/sub&gt; and u&lt;sub&gt;2&lt;/sub&gt; is
 * not the same as the angular separation between v&lt;sub&gt;1&lt;/sub&gt; and
 * v&lt;sub&gt;2&lt;/sub&gt;, then a corrected v'&lt;sub&gt;2&lt;/sub&gt; will be used rather than
 * v&lt;sub&gt;2&lt;/sub&gt;, the corrected vector will be in the (v&lt;sub&gt;1&lt;/sub&gt;,
 * v&lt;sub&gt;2&lt;/sub&gt;) plane.&lt;/p&gt;</text>
    <param>u1 first vector of the origin pair</param>
    <param>u2 second vector of the origin pair</param>
    <param>v1 desired image of u1 by the rotation</param>
    <param>v2 desired image of u2 by the rotation</param>
    <exception>MathArithmeticException if the norm of one of the vectors is zero,
 * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)</exception>
  </javadoc>
  <method type="constructor" name="Rotation">
    <declaration type="Vector3D" name="u3" />
    <declaration type="Vector3D" name="v3" />
    <declaration type="double[][][]" name="m" />
    <declaration type="double[]" name="quat" />
    <comment>build orthonormalized base from u1, u2</comment>
    <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
    <comment>build an orthonormalized base from v1, v2</comment>
    <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
    <comment>buid a matrix transforming the first base into the second one</comment>
  </method>
  <javadoc>
    <text>Build one of the rotations that transform one vector into another one.
 * &lt;p&gt;Except for a possible scale factor, if the instance were
 * applied to the vector u it will produce the vector v. There is an
 * infinite number of such rotations, this constructor choose the
 * one with the smallest associated angle (i.e. the one whose axis
 * is orthogonal to the (u, v) plane). If u and v are colinear, an
 * arbitrary rotation axis is chosen.&lt;/p&gt;</text>
    <param>u origin vector</param>
    <param>v desired image of u by the rotation</param>
    <exception>MathArithmeticException if the norm of one of the vectors is zero</exception>
  </javadoc>
  <method type="constructor" name="Rotation">
    <declaration type="double" name="normProduct" />
    <scope />
    <declaration type="double" name="dot" />
    <scope>
      <declaration type="Vector3D" name="w" />
    </scope>
    <scope>
      <declaration type="double" name="coeff" />
      <declaration type="Vector3D" name="q" />
    </scope>
    <comment>special case u = -v: we select a PI angle rotation around</comment>
    <comment>an arbitrary vector orthogonal to u</comment>
    <comment>general case: (u, v) defines a plane, we select</comment>
    <comment>the shortest possible rotation: axis orthogonal to this plane</comment>
  </method>
  <javadoc>
    <text>Build a rotation from three Cardan or Euler elementary rotations.
 * &lt;p&gt;Cardan rotations are three successive rotations around the
 * canonical axes X, Y and Z, each axis being used once. There are
 * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
 * rotations are three successive rotations around the canonical
 * axes X, Y and Z, the first and last rotations being around the
 * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
 * YZY, ZXZ and ZYZ), the most popular one being ZXZ.&lt;/p&gt;
 * &lt;p&gt;Beware that many people routinely use the term Euler angles even
 * for what really are Cardan angles (this confusion is especially
 * widespread in the aerospace business where Roll, Pitch and Yaw angles
 * are often wrongly tagged as Euler angles).&lt;/p&gt;</text>
    <param>order order of rotations to use</param>
    <param>alpha1 angle of the first elementary rotation</param>
    <param>alpha2 angle of the second elementary rotation</param>
    <param>alpha3 angle of the third elementary rotation</param>
  </javadoc>
  <method type="constructor" name="Rotation">
    <declaration type="Rotation" name="r1" />
    <declaration type="Rotation" name="r2" />
    <declaration type="Rotation" name="r3" />
    <declaration type="Rotation" name="composed" />
  </method>
  <javadoc>
    <text>Convert an orthogonal rotation matrix to a quaternion.</text>
    <param>ort orthogonal rotation matrix</param>
    <return>quaternion corresponding to the matrix</return>
  </javadoc>
  <method type="double[]" name="mat2quat">
    <declaration type="double[]" name="quat" />
    <declaration type="double" name="s" />
    <scope>
      <declaration type="double" name="inv" />
    </scope>
    <scope>
      <scope>
        <declaration type="double" name="inv" />
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="inv" />
        </scope>
        <scope>
          <declaration type="double" name="inv" />
        </scope>
      </scope>
    </scope>
    <comment>There are different ways to compute the quaternions elements</comment>
    <comment>from the matrix. They all involve computing one element from</comment>
    <comment>the diagonal of the matrix, and computing the three other ones</comment>
    <comment>using a formula involving a division by the first element,</comment>
    <comment>which unfortunately can be zero. Since the norm of the</comment>
    <comment>quaternion is 1, we know at least one element has an absolute</comment>
    <comment>value greater or equal to 0.5, so it is always possible to</comment>
    <comment>select the right formula and avoid division by zero and even</comment>
    <comment>numerical inaccuracy. Checking the elements in turn and using</comment>
    <comment>the first one greater than 0.45 is safe (this leads to a simple</comment>
    <comment>test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)</comment>
    <comment>compute q0 and deduce q1, q2 and q3</comment>
    <comment>compute q1 and deduce q0, q2 and q3</comment>
    <comment>compute q2 and deduce q0, q1 and q3</comment>
    <comment>compute q3 and deduce q0, q1 and q2</comment>
  </method>
  <javadoc>
    <text>Revert a rotation.
 * Build a rotation which reverse the effect of another
 * rotation. This means that if r(u) = v, then r.revert(v) = u. The
 * instance is not changed.</text>
    <return>a new rotation whose effect is the reverse of the effect
 * of the instance</return>
  </javadoc>
  <method type="Rotation" name="revert" />
  <javadoc>
    <text>Get the scalar coordinate of the quaternion.</text>
    <return>scalar coordinate of the quaternion</return>
  </javadoc>
  <method type="double" name="getQ0" />
  <javadoc>
    <text>Get the first coordinate of the vectorial part of the quaternion.</text>
    <return>first coordinate of the vectorial part of the quaternion</return>
  </javadoc>
  <method type="double" name="getQ1" />
  <javadoc>
    <text>Get the second coordinate of the vectorial part of the quaternion.</text>
    <return>second coordinate of the vectorial part of the quaternion</return>
  </javadoc>
  <method type="double" name="getQ2" />
  <javadoc>
    <text>Get the third coordinate of the vectorial part of the quaternion.</text>
    <return>third coordinate of the vectorial part of the quaternion</return>
  </javadoc>
  <method type="double" name="getQ3" />
  <javadoc>
    <text>Get the normalized axis of the rotation.</text>
    <return>normalized axis of the rotation</return>
    <see>#Rotation(Vector3D,double)</see>
  </javadoc>
  <method type="Vector3D" name="getAxis">
    <declaration type="double" name="squaredSine" />
    <scope />
    <scope>
      <declaration type="double" name="inverse" />
    </scope>
    <declaration type="double" name="inverse" />
  </method>
  <javadoc>
    <text>Get the angle of the rotation.</text>
    <return>angle of the rotation (between 0 and &amp;pi;)</return>
    <see>#Rotation(Vector3D,double)</see>
  </javadoc>
  <method type="double" name="getAngle">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Get the Cardan or Euler angles corresponding to the instance.
 * &lt;p&gt;The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt; and a&lt;sub&gt;3&lt;/sub&gt; is the same as
 * the rotation defined by the angles &amp;pi; + a&lt;sub&gt;1&lt;/sub&gt;, &amp;pi;
 * - a&lt;sub&gt;2&lt;/sub&gt; and &amp;pi; + a&lt;sub&gt;3&lt;/sub&gt;. This method implements
 * the following arbitrary choices:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;for Cardan angles, the chosen set is the one for which the
 * second angle is between -&amp;pi;/2 and &amp;pi;/2 (i.e its cosine is
 * positive),&lt;/li&gt;
 * &lt;li&gt;for Euler angles, the chosen set is the one for which the
 * second angle is between 0 and &amp;pi; (i.e its sine is positive).&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * &lt;em&gt;nothing&lt;/em&gt; to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&amp;pi;/2 or +&amp;pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &amp;pi;, this implies that the identity
 * rotation is always singular for Euler angles!&lt;/p&gt;</text>
    <param>order rotation order to use</param>
    <return>an array of three angles, in the order specified by the set</return>
    <exception>CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified</exception>
  </javadoc>
  <method type="double[]" name="getAngles">
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <scope>
      <declaration type="Vector3D" name="v1" />
      <declaration type="Vector3D" name="v2" />
      <scope />
    </scope>
    <comment>r (Vector3D.plusK) coordinates are :</comment>
    <comment>sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)</comment>
    <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)</comment>
    <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (Vector3D.plusJ) coordinates are :</comment>
    <comment>-sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)</comment>
    <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)</comment>
    <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (Vector3D.plusK) coordinates are :</comment>
    <comment>cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)</comment>
    <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
    <comment>sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)</comment>
    <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)</comment>
    <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
    <comment>sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)</comment>
    <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (Vector3D.plusJ) coordinates are :</comment>
    <comment>-cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)</comment>
    <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
    <comment>-sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)</comment>
    <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)</comment>
    <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
    <comment>-sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)</comment>
    <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
    <comment>r (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)</comment>
    <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)</comment>
    <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
    <comment>r (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)</comment>
    <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
    <comment>cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)</comment>
    <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
    <comment>r (Vector3D.plusJ) coordinates are :</comment>
    <comment>sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)</comment>
    <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
    <comment>sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)</comment>
    <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
    <comment>r (Vector3D.plusJ) coordinates are :</comment>
    <comment>-cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)</comment>
    <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
    <comment>sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)</comment>
    <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
    <comment>r (Vector3D.plusK) coordinates are :</comment>
    <comment>sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)</comment>
    <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
    <comment>sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)</comment>
    <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
    <comment>last possibility is ZYZ</comment>
    <comment>r (Vector3D.plusK) coordinates are :</comment>
    <comment>cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)</comment>
    <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
    <comment>-sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)</comment>
    <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
  </method>
  <javadoc>
    <text>Get the 3X3 matrix corresponding to the instance</text>
    <return>the matrix corresponding to the instance</return>
  </javadoc>
  <method type="double[][]" name="getMatrix">
    <declaration type="double" name="q0q0" />
    <declaration type="double" name="q0q1" />
    <declaration type="double" name="q0q2" />
    <declaration type="double" name="q0q3" />
    <declaration type="double" name="q1q1" />
    <declaration type="double" name="q1q2" />
    <declaration type="double" name="q1q3" />
    <declaration type="double" name="q2q2" />
    <declaration type="double" name="q2q3" />
    <declaration type="double" name="q3q3" />
    <declaration type="double[][][]" name="m" />
    <comment>products</comment>
    <comment>create the matrix</comment>
  </method>
  <javadoc>
    <text>Apply the rotation to a vector.</text>
    <param>u vector to apply the rotation to</param>
    <return>a new vector which is the image of u by the rotation</return>
  </javadoc>
  <method type="Vector3D" name="applyTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="double" name="s" />
  </method>
  <javadoc>
    <text>Apply the rotation to a vector stored in an array.</text>
    <param>in an array with three items which stores vector to rotate</param>
    <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
  </javadoc>
  <method type="void" name="applyTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="double" name="s" />
  </method>
  <javadoc>
    <text>Apply the inverse of the rotation to a vector.</text>
    <param>u vector to apply the inverse of the rotation to</param>
    <return>a new vector which such that u is its image by the rotation</return>
  </javadoc>
  <method type="Vector3D" name="applyInverseTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="double" name="s" />
    <declaration type="double" name="m0" />
  </method>
  <javadoc>
    <text>Apply the inverse of the rotation to a vector stored in an array.</text>
    <param>in an array with three items which stores vector to rotate</param>
    <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
  </javadoc>
  <method type="void" name="applyInverseTo">
    <declaration type="double" name="x" />
    <declaration type="double" name="y" />
    <declaration type="double" name="z" />
    <declaration type="double" name="s" />
    <declaration type="double" name="m0" />
  </method>
  <javadoc>
    <text>Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).</text>
    <param>r rotation to apply the rotation to</param>
    <return>a new rotation which is the composition of r by the instance</return>
  </javadoc>
  <method type="Rotation" name="applyTo" />
  <javadoc>
    <text>Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).</text>
    <param>r rotation to apply the rotation to</param>
    <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
  </javadoc>
  <method type="Rotation" name="applyInverseTo" />
  <javadoc>
    <text>Perfect orthogonality on a 3X3 matrix.</text>
    <param>m initial matrix (not exactly orthogonal)</param>
    <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
    <return>an orthogonal matrix close to m</return>
    <exception>NotARotationMatrixException if the matrix cannot be
 * orthogonalized with the given threshold after 10 iterations</exception>
  </javadoc>
  <method type="double[][]" name="orthogonalizeMatrix">
    <declaration type="double[]" name="m0" />
    <declaration type="double[]" name="m1" />
    <declaration type="double[]" name="m2" />
    <declaration type="double" name="x00" />
    <declaration type="double" name="x01" />
    <declaration type="double" name="x02" />
    <declaration type="double" name="x10" />
    <declaration type="double" name="x11" />
    <declaration type="double" name="x12" />
    <declaration type="double" name="x20" />
    <declaration type="double" name="x21" />
    <declaration type="double" name="x22" />
    <declaration type="double" name="fn" />
    <declaration type="double" name="fn1" />
    <declaration type="double[][]" name="o" />
    <declaration type="double[]" name="o0" />
    <declaration type="double[]" name="o1" />
    <declaration type="double[]" name="o2" />
    <declaration type="int" name="i" />
    <scope>
      <declaration type="double" name="mx00" />
      <declaration type="double" name="mx10" />
      <declaration type="double" name="mx20" />
      <declaration type="double" name="mx01" />
      <declaration type="double" name="mx11" />
      <declaration type="double" name="mx21" />
      <declaration type="double" name="mx02" />
      <declaration type="double" name="mx12" />
      <declaration type="double" name="mx22" />
      <declaration type="double" name="corr00" />
      <declaration type="double" name="corr01" />
      <declaration type="double" name="corr02" />
      <declaration type="double" name="corr10" />
      <declaration type="double" name="corr11" />
      <declaration type="double" name="corr12" />
      <declaration type="double" name="corr20" />
      <declaration type="double" name="corr21" />
      <declaration type="double" name="corr22" />
      <scope />
    </scope>
    <comment>iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)</comment>
    <comment>Mt.Xn</comment>
    <comment>Xn+1</comment>
    <comment>correction on each elements</comment>
    <comment>Frobenius norm of the correction</comment>
    <comment>convergence test</comment>
    <comment>prepare next iteration</comment>
    <comment>the algorithm did not converge after 10 iterations</comment>
  </method>
  <javadoc>
    <text>Compute the &lt;i&gt;distance&lt;/i&gt; between two rotations.
 * &lt;p&gt;The &lt;i&gt;distance&lt;/i&gt; is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:&lt;/p&gt;
 * &lt;pre&gt;
 * r&lt;sub&gt;1&lt;/sub&gt;(r) = r&lt;sub&gt;2&lt;/sub&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;This distance is an angle between 0 and &amp;pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r&lt;sub&gt;1&lt;/sub&gt;(v)
 * and r&lt;sub&gt;2&lt;/sub&gt;(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.&lt;/p&gt;
 * &lt;p&gt;Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).&lt;/p&gt;</text>
    <param>r1 first rotation</param>
    <param>r2 second rotation</param>
    <return>&lt;i&gt;distance&lt;/i&gt; between r1 and r2</return>
  </javadoc>
  <method type="double" name="distance" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
