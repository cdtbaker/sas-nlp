<?xml version="1.0" encoding="UTF-8"?>
<class name="LoessInterpolator">
  <javadoc>
    <text>Implements the &lt;a href="http://en.wikipedia.org/wiki/Local_regression"&gt;
 * Local Regression Algorithm&lt;/a&gt; (also Loess, Lowess) for interpolation of
 * real univariate functions.
 * &lt;p/&gt;
 * For reference, see
 * &lt;a href="http://www.math.tau.ac.il/~yekutiel/MA seminar/Cleveland 1979.pdf"&gt;
 * William S. Cleveland - Robust Locally Weighted Regression and Smoothing
 * Scatterplots&lt;/a&gt;
 * &lt;p/&gt;
 * This class implements both the loess method and serves as an interpolation
 * adapter to it, allowing one to build a spline on the obtained loess fit.</text>
    <version>$Id: LoessInterpolator.java 1379904 2012-09-01 23:54:52Z erans $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Default value of the bandwidth parameter.</text>
  </javadoc>
  <declaration type="double" name="DEFAULT_BANDWIDTH" />
  <javadoc>
    <text>Default value of the number of robustness iterations.</text>
  </javadoc>
  <declaration type="int" name="DEFAULT_ROBUSTNESS_ITERS" />
  <javadoc>
    <text>Default value for accuracy.</text>
    <since>2.1</since>
  </javadoc>
  <declaration type="double" name="DEFAULT_ACCURACY" />
  <javadoc>
    <text>serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>The bandwidth parameter: when computing the loess fit at
 * a particular point, this fraction of source points closest
 * to the current point is taken into account for computing
 * a least-squares regression.
 * &lt;p/&gt;
 * A sensible value is usually 0.25 to 0.5.</text>
  </javadoc>
  <declaration type="double" name="bandwidth" />
  <javadoc>
    <text>The number of robustness iterations parameter: this many
 * robustness iterations are done.
 * &lt;p/&gt;
 * A sensible value is usually 0 (just the initial fit without any
 * robustness iterations) to 4.</text>
  </javadoc>
  <declaration type="int" name="robustnessIters" />
  <javadoc>
    <text>If the median residual at a certain robustness iteration
 * is less than this amount, no more iterations are done.</text>
  </javadoc>
  <declaration type="double" name="accuracy" />
  <javadoc>
    <text>Constructs a new {@link LoessInterpolator}with a bandwidth of {@link #DEFAULT_BANDWIDTH},{@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations
 * and an accuracy of {#link #DEFAULT_ACCURACY}.
 * See {@link #LoessInterpolator(double,int,double)} for an explanation of
 * the parameters.</text>
  </javadoc>
  <method type="constructor" name="LoessInterpolator" />
  <javadoc>
    <text>Construct a new {@link LoessInterpolator}with given bandwidth and number of robustness iterations.
 * &lt;p&gt;
 * Calling this constructor is equivalent to calling {link {@link #LoessInterpolator(double,int,double) LoessInterpolator(bandwidth,
 * robustnessIters, LoessInterpolator.DEFAULT_ACCURACY)}&lt;/p&gt;</text>
    <param>bandwidth  when computing the loess fit at
 * a particular point, this fraction of source points closest
 * to the current point is taken into account for computing
 * a least-squares regression.&lt;/br&gt;
 * A sensible value is usually 0.25 to 0.5, the default value is{@link #DEFAULT_BANDWIDTH}.</param>
    <param>robustnessIters This many robustness iterations are done.&lt;/br&gt;
 * A sensible value is usually 0 (just the initial fit without any
 * robustness iterations) to 4, the default value is{@link #DEFAULT_ROBUSTNESS_ITERS}.</param>
    <see>#LoessInterpolator(double,int,double)</see>
  </javadoc>
  <method type="constructor" name="LoessInterpolator" />
  <javadoc>
    <text>Construct a new {@link LoessInterpolator}with given bandwidth, number of robustness iterations and accuracy.</text>
    <param>bandwidth  when computing the loess fit at
 * a particular point, this fraction of source points closest
 * to the current point is taken into account for computing
 * a least-squares regression.&lt;/br&gt;
 * A sensible value is usually 0.25 to 0.5, the default value is{@link #DEFAULT_BANDWIDTH}.</param>
    <param>robustnessIters This many robustness iterations are done.&lt;/br&gt;
 * A sensible value is usually 0 (just the initial fit without any
 * robustness iterations) to 4, the default value is{@link #DEFAULT_ROBUSTNESS_ITERS}.</param>
    <param>accuracy If the median residual at a certain robustness iteration
 * is less than this amount, no more iterations are done.</param>
    <throws>OutOfRangeException if bandwidth does not lie in the interval [0,1].</throws>
    <throws>NotPositiveException if {@code robustnessIters} is negative.</throws>
    <see>#LoessInterpolator(double,int)</see>
    <since>2.1</since>
  </javadoc>
  <method type="constructor" name="LoessInterpolator">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compute an interpolating function by performing a loess fit
 * on the data at the original abscissae and then building a cubic spline
 * with a{@link org.apache.commons.math3.analysis.interpolation.SplineInterpolator}on the resulting fit.</text>
    <param>xval the arguments for the interpolation points</param>
    <param>yval the values for the interpolation points</param>
    <return>A cubic spline built upon a loess fit to the data at the original abscissae</return>
    <throws>NonMonotonicSequenceException if {@code xval} not sorted in
 * strictly increasing order.</throws>
    <throws>DimensionMismatchException if {@code xval} and {@code yval} have
 * different sizes.</throws>
    <throws>NoDataException if {@code xval} or {@code yval} has zero size.</throws>
    <throws>NotFiniteNumberException if any of the arguments and values are
 * not finite real numbers.</throws>
    <throws>NumberIsTooSmallException if the bandwidth is too small to
 * accomodate the size of the input data (i.e. the bandwidth must be
 * larger than 2/n).</throws>
  </javadoc>
  <method type="PolynomialSplineFunction" name="interpolate" />
  <javadoc>
    <text>Compute a weighted loess fit on the data at the original abscissae.</text>
    <param>xval Arguments for the interpolation points.</param>
    <param>yval Values for the interpolation points.</param>
    <param>weights point weights: coefficients by which the robustness weight
 * of a point is multiplied.</param>
    <return>the values of the loess fit at corresponding original abscissae.</return>
    <throws>NonMonotonicSequenceException if {@code xval} not sorted in
 * strictly increasing order.</throws>
    <throws>DimensionMismatchException if {@code xval} and {@code yval} have
 * different sizes.</throws>
    <throws>NoDataException if {@code xval} or {@code yval} has zero size.</throws>
    <throws>NotFiniteNumberException if any of the arguments and values are
 * not finite real numbers.</throws>
    <throws>NumberIsTooSmallException if the bandwidth is too small to
 * accomodate the size of the input data (i.e. the bandwidth must be
 * larger than 2/n).</throws>
    <since>2.1</since>
  </javadoc>
  <method type="double[]" name="smooth">
    <scope />
    <declaration type="int" name="n" />
    <scope />
    <scope />
    <scope />
    <declaration type="int" name="bandwidthInPoints" />
    <scope />
    <declaration type="double[]" name="res" />
    <declaration type="double[]" name="residuals" />
    <declaration type="double[]" name="sortedResiduals" />
    <declaration type="double[]" name="robustnessWeights" />
    <scope>
      <declaration type="int[]" name="bandwidthInterval" />
      <scope>
        <declaration type="double" name="x" />
        <scope />
        <declaration type="int" name="ileft" />
        <declaration type="int" name="iright" />
        <declaration type="int" name="edge" />
        <scope />
        <scope />
        <declaration type="double" name="sumWeights" />
        <declaration type="double" name="sumX" />
        <declaration type="double" name="sumXSquared" />
        <declaration type="double" name="sumY" />
        <declaration type="double" name="sumXY" />
        <declaration type="double" name="denom" />
        <scope>
          <declaration type="double" name="xk" />
          <declaration type="double" name="yk" />
          <declaration type="double" name="dist" />
          <declaration type="double" name="w" />
          <declaration type="double" name="xkw" />
        </scope>
        <declaration type="double" name="meanX" />
        <declaration type="double" name="meanY" />
        <declaration type="double" name="meanXY" />
        <declaration type="double" name="meanXSquared" />
        <declaration type="double" name="beta" />
        <scope />
        <scope />
        <declaration type="double" name="alpha" />
      </scope>
      <scope />
      <declaration type="double" name="medianResidual" />
      <scope />
      <scope>
        <declaration type="double" name="arg" />
        <scope />
        <scope>
          <declaration type="double" name="w" />
        </scope>
      </scope>
    </scope>
    <comment>Do an initial fit and 'robustnessIters' robustness iterations.</comment>
    <comment>This is equivalent to doing 'robustnessIters+1' robustness iterations</comment>
    <comment>starting with all robustness weights set to 1.</comment>
    <comment>At each x, compute a local weighted linear regression</comment>
    <comment>Find out the interval of source points on which</comment>
    <comment>a regression is to be made.</comment>
    <comment>Compute the point of the bandwidth interval that is</comment>
    <comment>farthest from x</comment>
    <comment>Compute a least-squares linear fit weighted by</comment>
    <comment>the product of robustness weights and the tricube</comment>
    <comment>weight function.</comment>
    <comment>See http:en.wikipedia.org/wiki/Linear_regression</comment>
    <comment>(section "Univariate linear case")</comment>
    <comment>and http:en.wikipedia.org/wiki/Weighted_least_squares</comment>
    <comment>(section "Weighted least squares")</comment>
    <comment>No need to recompute the robustness weights at the last</comment>
    <comment>iteration, they won't be needed anymore</comment>
    <comment>Recompute the robustness weights.</comment>
    <comment>Find the median residual.</comment>
    <comment>An arraycopy and a sort are completely tractable here,</comment>
    <comment>because the preceding loop is a lot more expensive</comment>
  </method>
  <javadoc>
    <text>Compute a loess fit on the data at the original abscissae.</text>
    <param>xval the arguments for the interpolation points</param>
    <param>yval the values for the interpolation points</param>
    <return>values of the loess fit at corresponding original abscissae</return>
    <throws>NonMonotonicSequenceException if {@code xval} not sorted in
 * strictly increasing order.</throws>
    <throws>DimensionMismatchException if {@code xval} and {@code yval} have
 * different sizes.</throws>
    <throws>NoDataException if {@code xval} or {@code yval} has zero size.</throws>
    <throws>NotFiniteNumberException if any of the arguments and values are
 * not finite real numbers.</throws>
    <throws>NumberIsTooSmallException if the bandwidth is too small to
 * accomodate the size of the input data (i.e. the bandwidth must be
 * larger than 2/n).</throws>
  </javadoc>
  <method type="double[]" name="smooth">
    <scope />
    <declaration type="double[]" name="unitWeights" />
  </method>
  <javadoc>
    <text>Given an index interval into xval that embraces a certain number of
 * points closest to {@code xval[i-1]}, update the interval so that it
 * embraces the same number of points closest to {@code xval[i]},
 * ignoring zero weights.</text>
    <param>xval Arguments array.</param>
    <param>weights Weights array.</param>
    <param>i Index around which the new interval should be computed.</param>
    <param>bandwidthInterval a two-element array {left, right} such that:{@code (left==0 or xval[i] - xval[left-1] &gt; xval[right] - xval[i])}and{@code (right==xval.length-1 or xval[right+1] - xval[i] &gt; xval[i] - xval[left])}.
 * The array will be updated.</param>
  </javadoc>
  <method type="void" name="updateBandwidthInterval">
    <declaration type="int" name="left" />
    <declaration type="int" name="right" />
    <declaration type="int" name="nextRight" />
    <scope>
      <declaration type="int" name="nextLeft" />
    </scope>
    <comment>The right edge should be adjusted if the next point to the right</comment>
    <comment>is closer to xval[i] than the leftmost point of the current interval</comment>
  </method>
  <javadoc>
    <text>Return the smallest index {@code j} such that{@code j &gt; i &amp;&amp; (j == weights.length || weights[j] != 0)}.</text>
    <param>weights Weights array.</param>
    <param>i Index from which to start search.</param>
    <return>the smallest compliant index.</return>
  </javadoc>
  <method type="int" name="nextNonzero">
    <declaration type="int" name="j" />
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://en.wikipedia.org/wiki/Local_regression#Weight_function"&gt;tricube&lt;/a&gt;
 * weight function</text>
    <param>x Argument.</param>
    <return>&lt;code&gt;(1 - |x|&lt;sup&gt;3&lt;/sup&gt;)&lt;sup&gt;3&lt;/sup&gt;&lt;/code&gt; for |x| &amp;lt; 1, 0 otherwise.</return>
  </javadoc>
  <method type="double" name="tricube">
    <declaration type="double" name="absX" />
    <scope />
    <declaration type="double" name="tmp" />
  </method>
  <javadoc>
    <text>Check that all elements of an array are finite real numbers.</text>
    <param>values Values array.</param>
    <throws>org.apache.commons.math3.exception.NotFiniteNumberExceptionif one of the values is not a finite real number.</throws>
  </javadoc>
  <method type="void" name="checkAllFiniteReal">
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
