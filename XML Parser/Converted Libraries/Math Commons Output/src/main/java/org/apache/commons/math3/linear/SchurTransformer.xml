<?xml version="1.0" encoding="UTF-8"?>
<class name="SchurTransformer">
  <javadoc>
    <text>Class transforming a general real matrix to Schur form.
 * &lt;p&gt;A m &amp;times; m matrix A can be written as the product of three matrices: A = P
 * &amp;times; T &amp;times; P&lt;sup&gt;T&lt;/sup&gt; with P an orthogonal matrix and T an quasi-triangular
 * matrix. Both P and T are m &amp;times; m matrices.&lt;/p&gt;
 * &lt;p&gt;Transformation to Schur form is often not a goal by itself, but it is an
 * intermediate step in more general decomposition algorithms like{@link EigenDecomposition eigen decomposition}. This class is therefore
 * intended for internal use by the library and is not public. As a consequence
 * of this explicitly limited scope, many methods directly returns references to
 * internal arrays, not copies.&lt;/p&gt;
 * &lt;p&gt;This class is based on the method hqr2 in class EigenvalueDecomposition
 * from the &lt;a href="http://math.nist.gov/javanumerics/jama/"&gt;JAMA&lt;/a&gt; library.&lt;/p&gt;</text>
    <see>&lt;a href="http://mathworld.wolfram.com/SchurDecomposition.html"&gt;Schur Decomposition - MathWorld&lt;/a&gt;</see>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Schur_decomposition"&gt;Schur Decomposition - Wikipedia&lt;/a&gt;</see>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Householder_transformation"&gt;Householder Transformations&lt;/a&gt;</see>
    <version>$Id: SchurTransformer.java 1389129 2012-09-23 19:34:02Z tn $</version>
    <since>3.1</since>
  </javadoc>
  <javadoc>
    <text>Maximum allowed iterations for convergence of the transformation.</text>
  </javadoc>
  <declaration type="int" name="MAX_ITERATIONS" />
  <javadoc>
    <text>P matrix.</text>
  </javadoc>
  <declaration type="double" name="matrixP" />
  <javadoc>
    <text>T matrix.</text>
  </javadoc>
  <declaration type="double" name="matrixT" />
  <javadoc>
    <text>Cached value of P.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedP" />
  <javadoc>
    <text>Cached value of T.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedT" />
  <javadoc>
    <text>Cached value of PT.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedPt" />
  <javadoc>
    <text>Epsilon criteria taken from JAMA code (originally was 2^-52).</text>
  </javadoc>
  <declaration type="double" name="epsilon" />
  <javadoc>
    <text>Build the transformation to Schur form of a general real matrix.</text>
    <param>matrix matrix to transform</param>
    <throws>NonSquareMatrixException if the matrix is not square</throws>
  </javadoc>
  <method type="constructor" name="SchurTransformer">
    <scope />
    <declaration type="HessenbergTransformer" name="transformer" />
    <comment>transform matrix</comment>
  </method>
  <javadoc>
    <text>Returns the matrix P of the transform.
 * &lt;p&gt;P is an orthogonal matrix, i.e. its inverse is also its transpose.&lt;/p&gt;</text>
    <return>the P matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getP">
    <scope />
  </method>
  <javadoc>
    <text>Returns the transpose of the matrix P of the transform.
 * &lt;p&gt;P is an orthogonal matrix, i.e. its inverse is also its transpose.&lt;/p&gt;</text>
    <return>the transpose of the P matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getPT">
    <scope />
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the quasi-triangular Schur matrix T of the transform.</text>
    <return>the T matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getT">
    <scope />
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Transform original matrix to Schur form.</text>
    <throws>MaxCountExceededException if the transformation does not converge</throws>
  </javadoc>
  <method type="void" name="transform">
    <declaration type="int" name="n" />
    <declaration type="double" name="norm" />
    <declaration type="ShiftInfo" name="shift" />
    <declaration type="int" name="iteration" />
    <declaration type="int" name="iu" />
    <scope>
      <declaration type="int" name="il" />
      <scope />
      <scope>
        <declaration type="double" name="p" />
        <declaration type="double" name="q" />
        <scope>
          <declaration type="double" name="z" />
          <scope />
          <scope />
          <declaration type="double" name="x" />
          <declaration type="double" name="s" />
          <declaration type="double" name="r" />
          <scope />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope />
        <declaration type="double[]" name="hVec" />
        <declaration type="int" name="im" />
      </scope>
    </scope>
    <comment>compute matrix norm</comment>
    <comment>shift information</comment>
    <comment>Outer loop over eigenvalue index</comment>
    <comment>Look for single small sub-diagonal element</comment>
    <comment>Check for convergence</comment>
    <comment>One root found</comment>
    <comment>Two roots found</comment>
    <comment>Row modification</comment>
    <comment>Column modification</comment>
    <comment>Accumulate transformations</comment>
    <comment>No convergence yet</comment>
    <comment>stop transformation after too many iterations</comment>
    <comment>the initial houseHolder vector for the QR step</comment>
  </method>
  <javadoc>
    <text>Computes the L1 norm of the (quasi-)triangular matrix T.</text>
    <return>the L1 norm of matrix T</return>
  </javadoc>
  <method type="double" name="getNorm">
    <declaration type="double" name="norm" />
    <scope>
      <scope />
    </scope>
    <comment>as matrix T is (quasi-)triangular, also take the sub-diagonal element into account</comment>
  </method>
  <javadoc>
    <text>Find the first small sub-diagonal element and returns its index.</text>
    <param>startIdx the starting index for the search</param>
    <param>norm the L1 norm of the matrix</param>
    <return>the index of the first small sub-diagonal element</return>
  </javadoc>
  <method type="int" name="findSmallSubDiagonalElement">
    <declaration type="int" name="l" />
    <scope>
      <declaration type="double" name="s" />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Compute the shift for the current iteration.</text>
    <param>l the index of the small sub-diagonal element</param>
    <param>idx the current eigenvalue index</param>
    <param>iteration the current iteration</param>
    <param>shift holder for shift information</param>
  </javadoc>
  <method type="void" name="computeShift">
    <scope />
    <scope>
      <scope />
      <declaration type="double" name="s" />
    </scope>
    <scope>
      <declaration type="double" name="s" />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>Form shift</comment>
    <comment>Wilkinson's original ad hoc shift</comment>
    <comment>MATLAB's new ad hoc shift</comment>
  </method>
  <javadoc>
    <text>Initialize the householder vectors for the QR step.</text>
    <param>il the index of the small sub-diagonal element</param>
    <param>iu the current eigenvalue index</param>
    <param>shift shift information holder</param>
    <param>hVec the initial houseHolder vector</param>
    <return>the start index for the QR step</return>
  </javadoc>
  <method type="int" name="initQRStep">
    <declaration type="int" name="im" />
    <scope>
      <declaration type="double" name="z" />
      <declaration type="double" name="r" />
      <declaration type="double" name="s" />
      <scope />
      <declaration type="double" name="lhs" />
      <declaration type="double" name="rhs" />
      <scope />
    </scope>
    <comment>Look for two consecutive small sub-diagonal elements</comment>
  </method>
  <javadoc>
    <text>Perform a double QR step involving rows l:idx and columns m:n</text>
    <param>il the index of the small sub-diagonal element</param>
    <param>im the start index for the QR step</param>
    <param>iu the current eigenvalue index</param>
    <param>shift shift information holder</param>
    <param>hVec the initial houseHolder vector</param>
  </javadoc>
  <method type="void" name="performDoubleQRStep">
    <declaration type="int" name="n" />
    <declaration type="double" name="p" />
    <declaration type="double" name="q" />
    <declaration type="double" name="r" />
    <scope>
      <declaration type="boolean" name="notlast" />
      <scope>
        <scope />
      </scope>
      <scope />
      <declaration type="double" name="s" />
      <scope />
      <scope>
        <scope />
        <scope />
        <declaration type="double" name="z" />
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
        <declaration type="int" name="high" />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>Row modification</comment>
    <comment>Column modification</comment>
    <comment>Accumulate transformations</comment>
    <comment>(s != 0)</comment>
    <comment>k loop</comment>
    <comment>clean up pollution due to round-off errors</comment>
  </method>
  <javadoc>
    <text>Internal data structure holding the current shift information.
 * Contains variable names as present in the original JAMA code.</text>
  </javadoc>
  <javadoc>
    <text>x shift info</text>
  </javadoc>
  <declaration type="double" name="x" />
  <javadoc>
    <text>y shift info</text>
  </javadoc>
  <declaration type="double" name="y" />
  <javadoc>
    <text>w shift info</text>
  </javadoc>
  <declaration type="double" name="w" />
  <javadoc>
    <text>Indicates an exceptional shift.</text>
  </javadoc>
  <declaration type="double" name="exShift" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>CHECKSTYLE: stop all</comment>
  <comment>CHECKSTYLE: resume all</comment>
</class>
