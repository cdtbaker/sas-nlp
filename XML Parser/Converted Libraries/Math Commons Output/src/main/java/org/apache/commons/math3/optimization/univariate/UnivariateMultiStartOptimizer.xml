<?xml version="1.0" encoding="UTF-8"?>
<class name="UnivariateMultiStartOptimizer">
  <javadoc>
    <text>Special implementation of the {@link UnivariateOptimizer} interface
 * adding multi-start features to an existing optimizer.
 * This class wraps a classical optimizer to use it several times in
 * turn with different starting points in order to avoid being trapped
 * into a local extremum when looking for a global one.</text>
    <param>&lt;FUNC&gt;
 *  Type of the objective function to be optimized.</param>
    <version>$Id: UnivariateMultiStartOptimizer.java 1422230 2012-12-15 12:11:13Z erans $</version>
    <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Underlying classical optimizer.</text>
  </javadoc>
  <declaration type="BaseUnivariateOptimizer&lt;FUNC&gt;" name="optimizer" />
  <javadoc>
    <text>Maximal number of evaluations allowed.</text>
  </javadoc>
  <declaration type="int" name="maxEvaluations" />
  <javadoc>
    <text>Number of evaluations already performed for all starts.</text>
  </javadoc>
  <declaration type="int" name="totalEvaluations" />
  <javadoc>
    <text>Number of starts to go.</text>
  </javadoc>
  <declaration type="int" name="starts" />
  <javadoc>
    <text>Random generator for multi-start.</text>
  </javadoc>
  <declaration type="RandomGenerator" name="generator" />
  <javadoc>
    <text>Found optima.</text>
  </javadoc>
  <declaration type="UnivariatePointValuePair[]" name="optima" />
  <javadoc>
    <text>Create a multi-start optimizer from a single-start optimizer.</text>
    <param>optimizer Single-start optimizer to wrap.</param>
    <param>starts Number of starts to perform. If {@code starts == 1},
 * the {@code optimize} methods will return the same solution as{@code optimizer} would.</param>
    <param>generator Random generator to use for restarts.</param>
    <throws>NullArgumentException if {@code optimizer} or {@code generator}is {@code null}.</throws>
    <throws>NotStrictlyPositiveException if {@code starts &lt; 1}.</throws>
  </javadoc>
  <method type="constructor" name="UnivariateMultiStartOptimizer">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="ConvergenceChecker&lt;UnivariatePointValuePair&gt;" name="getConvergenceChecker" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="getMaxEvaluations" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="getEvaluations" />
  <javadoc>
    <text>Get all the optima found during the last call to {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}.
 * The optimizer stores all the optima found during a set of
 * restarts. The {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}method returns the best point only. This method returns all the points
 * found at the end of each starts, including the best one already
 * returned by the {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}method.
 * &lt;br/&gt;
 * The returned array as one element for each start as specified
 * in the constructor. It is ordered with the results from the
 * runs that did converge first, sorted from best to worst
 * objective value (i.e in ascending order if minimizing and in
 * descending order if maximizing), followed by {@code null} elements
 * corresponding to the runs that did not converge. This means all
 * elements will be {@code null} if the {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}method did throw an exception.
 * This also means that if the first element is not {@code null}, it is
 * the best point found across all starts.</text>
    <return>an array containing the optima.</return>
    <throws>MathIllegalStateException if {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}has not been called.</throws>
  </javadoc>
  <method type="UnivariatePointValuePair[]" name="getOptima">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="UnivariatePointValuePair" name="optimize" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="UnivariatePointValuePair" name="optimize">
    <declaration type="RuntimeException" name="lastException" />
    <scope>
      <scope>
        <declaration type="double" name="s" />
      </scope>
      <scope />
    </scope>
    <scope />
    <comment>Multi-start loop.</comment>
    <comment>CHECKSTYLE: stop IllegalCatch</comment>
    <comment>CHECKSTYLE: resume IllegalCatch</comment>
    <comment>cannot be null if starts &gt;=1</comment>
    <comment>Return the point with the best objective function value.</comment>
  </method>
  <javadoc>
    <text>Sort the optima from best to worst, followed by {@code null} elements.</text>
    <param>goal Goal type.</param>
  </javadoc>
  <method type="void" name="sortPairs">
    <method type="int" name="compare">
      <scope />
      <scope />
      <declaration type="double" name="v1" />
      <declaration type="double" name="v2" />
    </method>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
