<?xml version="1.0" encoding="UTF-8"?>
<class name="CurveFitter">
  <javadoc>
    <text>Fitter for parametric univariate real functions y = f(x).
 * &lt;br/&gt;
 * When a univariate real function y = f(x) does depend on some
 * unknown parameters p&lt;sub&gt;0&lt;/sub&gt;, p&lt;sub&gt;1&lt;/sub&gt; ... p&lt;sub&gt;n-1&lt;/sub&gt;,
 * this class can be used to find these parameters. It does this
 * by &lt;em&gt;fitting&lt;/em&gt; the curve so it remains very close to a set of
 * observed points (x&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;0&lt;/sub&gt;), (x&lt;sub&gt;1&lt;/sub&gt;,
 * y&lt;sub&gt;1&lt;/sub&gt;) ... (x&lt;sub&gt;k-1&lt;/sub&gt;, y&lt;sub&gt;k-1&lt;/sub&gt;). This fitting
 * is done by finding the parameters values that minimizes the objective
 * function &amp;sum;(y&lt;sub&gt;i&lt;/sub&gt;-f(x&lt;sub&gt;i&lt;/sub&gt;))&lt;sup&gt;2&lt;/sup&gt;. This is
 * really a least squares problem.</text>
    <param>&lt;T&gt;
 *  Function to use for the fit.</param>
    <version>$Id: CurveFitter.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Optimizer to use for the fitting.</text>
  </javadoc>
  <declaration type="MultivariateVectorOptimizer" name="optimizer" />
  <javadoc>
    <text>Observed points.</text>
  </javadoc>
  <declaration type="List&lt;WeightedObservedPoint&gt;" name="observations" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>optimizer Optimizer to use for the fitting.</param>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="CurveFitter" />
  <javadoc>
    <text>Add an observed (x,y) point to the sample with unit weight.
 * &lt;p&gt;Calling this method is equivalent to call{@code addObservedPoint(1.0, x, y)}.&lt;/p&gt;</text>
    <param>x abscissa of the point</param>
    <param>y observed value of the point at x, after fitting we should
 * have f(x) as close as possible to this value</param>
    <see>#addObservedPoint(double,double,double)</see>
    <see>#addObservedPoint(WeightedObservedPoint)</see>
    <see>#getObservations()</see>
  </javadoc>
  <method type="void" name="addObservedPoint" />
  <javadoc>
    <text>Add an observed weighted (x,y) point to the sample.</text>
    <param>weight weight of the observed point in the fit</param>
    <param>x abscissa of the point</param>
    <param>y observed value of the point at x, after fitting we should
 * have f(x) as close as possible to this value</param>
    <see>#addObservedPoint(double,double)</see>
    <see>#addObservedPoint(WeightedObservedPoint)</see>
    <see>#getObservations()</see>
  </javadoc>
  <method type="void" name="addObservedPoint" />
  <javadoc>
    <text>Add an observed weighted (x,y) point to the sample.</text>
    <param>observed observed point to add</param>
    <see>#addObservedPoint(double,double)</see>
    <see>#addObservedPoint(double,double,double)</see>
    <see>#getObservations()</see>
  </javadoc>
  <method type="void" name="addObservedPoint" />
  <javadoc>
    <text>Get the observed points.</text>
    <return>observed points</return>
    <see>#addObservedPoint(double,double)</see>
    <see>#addObservedPoint(double,double,double)</see>
    <see>#addObservedPoint(WeightedObservedPoint)</see>
  </javadoc>
  <method type="WeightedObservedPoint[]" name="getObservations" />
  <javadoc>
    <text>Remove all observations.</text>
  </javadoc>
  <method type="void" name="clearObservations" />
  <javadoc>
    <text>Fit a curve.
 * This method compute the coefficients of the curve that best
 * fit the sample of observed points previously given through calls
 * to the {@link #addObservedPoint(WeightedObservedPoint)addObservedPoint} method.</text>
    <param>f parametric function to fit.</param>
    <param>initialGuess first guess of the function parameters.</param>
    <return>the fitted parameters.</return>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the start point dimension is wrong.</throws>
  </javadoc>
  <method type="double[]" name="fit" />
  <javadoc>
    <text>Fit a curve.
 * This method compute the coefficients of the curve that best
 * fit the sample of observed points previously given through calls
 * to the {@link #addObservedPoint(WeightedObservedPoint)addObservedPoint} method.</text>
    <param>f parametric function to fit.</param>
    <param>initialGuess first guess of the function parameters.</param>
    <param>maxEval Maximum number of function evaluations.</param>
    <return>the fitted parameters.</return>
    <throws>org.apache.commons.math3.exception.TooManyEvaluationsExceptionif the number of allowed evaluations is exceeded.</throws>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the start point dimension is wrong.</throws>
    <since>3.0</since>
  </javadoc>
  <method type="double[]" name="fit">
    <declaration type="double[]" name="target" />
    <declaration type="double[]" name="weights" />
    <declaration type="int" name="i" />
    <scope />
    <declaration type="TheoreticalValuesFunction" name="model" />
    <declaration type="PointVectorValuePair" name="optimum" />
    <comment>Prepare least squares problem.</comment>
    <comment>Input to the optimizer: the model and its Jacobian.</comment>
    <comment>Perform the fit.</comment>
    <comment>Extract the coefficients.</comment>
  </method>
  <javadoc>
    <text>Vectorial function computing function theoretical values.</text>
  </javadoc>
  <javadoc>
    <text>Function to fit.</text>
  </javadoc>
  <declaration type="ParametricUnivariateFunction" name="f" />
  <javadoc>
    <param>f function to fit.</param>
  </javadoc>
  <method type="constructor" name="TheoreticalValuesFunction" />
  <javadoc>
    <return>the model function values.</return>
  </javadoc>
  <method type="ModelFunction" name="getModelFunction">
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double[]" name="value">
      <declaration type="double[]" name="values" />
      <declaration type="int" name="i" />
      <scope />
    </method>
    <comment>compute the residuals</comment>
  </method>
  <javadoc>
    <return>the model function Jacobian.</return>
  </javadoc>
  <method type="ModelFunctionJacobian" name="getModelFunctionJacobian">
    <method type="double[][]" name="value">
      <declaration type="double[][][]" name="jacobian" />
      <declaration type="int" name="i" />
      <scope />
    </method>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
