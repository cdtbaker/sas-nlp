<?xml version="1.0" encoding="UTF-8"?>
<class name="FastHadamardTransformer">
  <javadoc>
    <text>Implements the &lt;a href="http://www.archive.chipcenter.com/dsp/DSP000517F1.html"&gt;Fast Hadamard Transform&lt;/a&gt; (FHT).
 * Transformation of an input vector x to the output vector y.
 * &lt;p&gt;
 * In addition to transformation of real vectors, the Hadamard transform can
 * transform integer vectors into integer vectors. However, this integer transform
 * cannot be inverted directly. Due to a scaling factor it may lead to rational results.
 * As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational
 * vector (1/2, -1/2, 0, 0).</text>
    <version>$Id: FastHadamardTransformer.java 1385310 2012-09-16 16:32:10Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>MathIllegalArgumentException if the length of the data array is
 * not a power of two</throws>
  </javadoc>
  <method type="double[]" name="transform">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif the lower bound is greater than, or equal to the upper bound</throws>
    <throws>org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points is negative</throws>
    <throws>MathIllegalArgumentException if the number of sample points is not a power of two</throws>
  </javadoc>
  <method type="double[]" name="transform" />
  <javadoc>
    <text>Returns the forward transform of the specified integer data set.The
 * integer transform cannot be inverted directly, due to a scaling factor
 * which may lead to double results.</text>
    <param>f the integer data array to be transformed (signal)</param>
    <return>the integer transformed array (spectrum)</return>
    <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
  </javadoc>
  <method type="int[]" name="transform" />
  <javadoc>
    <text>The FHT (Fast Hadamard Transformation) which uses only subtraction and
 * addition. Requires {@code N * log2(N) = n * 2^n} additions.
 * &lt;h3&gt;Short Table of manual calculation for N=8&lt;/h3&gt;
 * &lt;ol&gt;
 * &lt;li&gt;&lt;b&gt;x&lt;/b&gt; is the input vector to be transformed,&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;y&lt;/b&gt; is the output vector (Fast Hadamard transform of &lt;b&gt;x&lt;/b&gt;),&lt;/li&gt;
 * &lt;li&gt;a and b are helper rows.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;table align="center" border="1" cellpadding="3"&gt;
 * &lt;tbody align="center"&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;/th&gt;
 * &lt;th&gt;a&lt;/th&gt;
 * &lt;th&gt;b&lt;/th&gt;
 * &lt;th&gt;y&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;0&lt;/sub&gt; = x&lt;sub&gt;0&lt;/sub&gt; + x&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;0&lt;/sub&gt; + a&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;0&lt;/sub &gt;+ b&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;1&lt;/sub&gt; = x&lt;sub&gt;2&lt;/sub&gt; + x&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;2&lt;/sub&gt; + b&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;2&lt;/sub&gt; = x&lt;sub&gt;4&lt;/sub&gt; + x&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;4&lt;/sub&gt; + a&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;4&lt;/sub&gt; + b&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;3&lt;/sub&gt; = x&lt;sub&gt;6&lt;/sub&gt; + x&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;6&lt;/sub&gt; + a&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;6&lt;/sub&gt; + b&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;4&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;0&lt;/sub&gt; = x&lt;sub&gt;0&lt;/sub&gt; - x&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;0&lt;/sub&gt; - a&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;0&lt;/sub&gt; - b&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;5&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;1&lt;/sub&gt; = x&lt;sub&gt;2&lt;/sub&gt; - x&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;2&lt;/sub&gt; - a&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;2&lt;/sub&gt; - b&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;6&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;2&lt;/sub&gt; = x&lt;sub&gt;4&lt;/sub&gt; - x&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;4&lt;/sub&gt; - a&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;4&lt;/sub&gt; - b&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;x&lt;sub&gt;7&lt;/sub&gt;&lt;/th&gt;
 * &lt;td&gt;a&lt;sub&gt;3&lt;/sub&gt; = x&lt;sub&gt;6&lt;/sub&gt; - x&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;6&lt;/sub&gt; - a&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
 * &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;6&lt;/sub&gt; - b&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/tbody&gt;
 * &lt;/table&gt;
 * &lt;h3&gt;How it works&lt;/h3&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Construct a matrix with {@code N} rows and {@code n + 1} columns,{@code hadm[n+1][N]}.&lt;br/&gt;
 * &lt;em&gt;(If I use [x][y] it always means [row-offset][column-offset] of a
 * Matrix with n rows and m columns. Its entries go from M[0][0]
 * to M[n][N])&lt;/em&gt;&lt;/li&gt;
 * &lt;li&gt;Place the input vector {@code x[N]} in the first column of the
 * matrix {@code hadm}.&lt;/li&gt;
 * &lt;li&gt;The entries of the submatrix {@code D_top} are calculated as follows
 * &lt;ul&gt;
 * &lt;li&gt;{@code D_top} goes from entry {@code [0][1]} to{@code [N / 2 - 1][n + 1]},&lt;/li&gt;
 * &lt;li&gt;the columns of {@code D_top} are the pairwise mutually
 * exclusive sums of the previous column.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;The entries of the submatrix {@code D_bottom} are calculated as
 * follows
 * &lt;ul&gt;
 * &lt;li&gt;{@code D_bottom} goes from entry {@code [N / 2][1]} to{@code [N][n + 1]},&lt;/li&gt;
 * &lt;li&gt;the columns of {@code D_bottom} are the pairwise differences
 * of the previous column.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;The consputation of {@code D_top} and {@code D_bottom} are best
 * understood with the above example (for {@code N = 8}).
 * &lt;li&gt;The output vector {@code y} is now in the last column of{@code hadm}.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Algorithm from &lt;a href="http://www.archive.chipcenter.com/dsp/DSP000517F1.html"&gt;chipcenter&lt;/a&gt;.&lt;/em&gt;&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;h3&gt;Visually&lt;/h3&gt;
 * &lt;table border="1" align="center" cellpadding="3"&gt;
 * &lt;tbody align="center"&gt;
 * &lt;tr&gt;
 * &lt;td&gt;&lt;/td&gt;&lt;th&gt;0&lt;/th&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;th&gt;3&lt;/th&gt;
 * &lt;th&gt;&amp;hellip;&lt;/th&gt;
 * &lt;th&gt;n + 1&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;0&lt;/th&gt;
 * &lt;td&gt;x&lt;sub&gt;0&lt;/sub&gt;&lt;/td&gt;
 * &lt;td colspan="5" rowspan="5" align="center" valign="middle"&gt;
 * &amp;uarr;&lt;br/&gt;
 * &amp;larr; D&lt;sub&gt;top&lt;/sub&gt; &amp;rarr;&lt;br/&gt;
 * &amp;darr;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;&amp;hellip;&lt;/th&gt;&lt;td&gt;&amp;hellip;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;N / 2 - 1&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N/2-1&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th&gt;N / 2&lt;/th&gt;
 * &lt;td&gt;x&lt;sub&gt;N/2&lt;/sub&gt;&lt;/td&gt;
 * &lt;td colspan="5" rowspan="5" align="center" valign="middle"&gt;
 * &amp;uarr;&lt;br/&gt;
 * &amp;larr; D&lt;sub&gt;bottom&lt;/sub&gt; &amp;rarr;&lt;br/&gt;
 * &amp;darr;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;N / 2 + 1&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N/2+1&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;N / 2 + 2&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N/2+2&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;&amp;hellip;&lt;/th&gt;&lt;td&gt;&amp;hellip;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;N&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/tbody&gt;
 * &lt;/table&gt;</text>
    <param>x the real data array to be transformed</param>
    <return>the real transformed array, {@code y}</return>
    <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
  </javadoc>
  <method type="double[]" name="fht">
    <declaration type="int" name="n" />
    <declaration type="int" name="halfN" />
    <scope />
    <declaration type="double[]" name="yPrevious" />
    <declaration type="double[]" name="yCurrent" />
    <scope>
      <declaration type="double[]" name="yTmp" />
      <scope>
        <declaration type="int" name="twoI" />
      </scope>
      <scope>
        <declaration type="int" name="twoI" />
      </scope>
    </scope>
    <comment>Instead of creating a matrix with p+1 columns and n rows, we use two
 one dimension arrays which we are used in an alternating way.</comment>
    <comment>iterate from left to right (column)</comment>
    <comment>switch columns</comment>
    <comment>iterate from top to bottom (row)</comment>
    <comment>Dtop: the top part works with addition</comment>
    <comment>Dbottom: the bottom part works with subtraction</comment>
  </method>
  <javadoc>
    <text>Returns the forward transform of the specified integer data set. The FHT
 * (Fast Hadamard Transform) uses only subtraction and addition.</text>
    <param>x the integer data array to be transformed</param>
    <return>the integer transformed array, {@code y}</return>
    <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
  </javadoc>
  <method type="int[]" name="fht">
    <declaration type="int" name="n" />
    <declaration type="int" name="halfN" />
    <scope />
    <declaration type="int[]" name="yPrevious" />
    <declaration type="int[]" name="yCurrent" />
    <scope>
      <declaration type="int[]" name="yTmp" />
      <scope>
        <declaration type="int" name="twoI" />
      </scope>
      <scope>
        <declaration type="int" name="twoI" />
      </scope>
    </scope>
    <comment>Instead of creating a matrix with p+1 columns and n rows, we use two
 one dimension arrays which we are used in an alternating way.</comment>
    <comment>iterate from left to right (column)</comment>
    <comment>switch columns</comment>
    <comment>iterate from top to bottom (row)</comment>
    <comment>Dtop: the top part works with addition</comment>
    <comment>Dbottom: the bottom part works with subtraction</comment>
    <comment>return the last computed output vector y</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
