<?xml version="1.0" encoding="UTF-8"?>
<class name="BSPTree">
  <javadoc>
    <text>This class represent a Binary Space Partition tree.
 * &lt;p&gt;BSP trees are an efficient way to represent space partitions and
 * to associate attributes with each cell. Each node in a BSP tree
 * represents a convex region which is partitioned in two convex
 * sub-regions at each side of a cut hyperplane. The root tree
 * contains the complete space.&lt;/p&gt;
 * &lt;p&gt;The main use of such partitions is to use a boolean attribute to
 * define an inside/outside property, hence representing arbitrary
 * polytopes (line segments in 1D, polygons in 2D and polyhedrons in
 * 3D) and to operate on them.&lt;/p&gt;
 * &lt;p&gt;Another example would be to represent Voronoi tesselations, the
 * attribute of each cell holding the defining point of the cell.&lt;/p&gt;
 * &lt;p&gt;The application-defined attributes are shared among copied
 * instances and propagated to split parts. These attributes are not
 * used by the BSP-tree algorithms themselves, so the application can
 * use them for any purpose. Since the tree visiting method holds
 * internal and leaf nodes differently, it is possible to use
 * different classes for internal nodes attributes and leaf nodes
 * attributes. This should be used with care, though, because if the
 * tree is modified in any way after attributes have been set, some
 * internal nodes may become leaf nodes and some leaf nodes may become
 * internal nodes.&lt;/p&gt;
 * &lt;p&gt;One of the main sources for the development of this package was
 * Bruce Naylor, John Amanatides and William Thibault paper &lt;a
 * href="http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf"&gt;Merging
 * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph '90,
 * Computer Graphics 24(4), August 1990, pp 115-124, published by the
 * Association for Computing Machinery (ACM).&lt;/p&gt;</text>
    <param>&lt;S&gt;
 *  Type of the space.</param>
    <version>$Id: BSPTree.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Cut sub-hyperplane.</text>
  </javadoc>
  <declaration type="SubHyperplane&lt;S&gt;" name="cut" />
  <javadoc>
    <text>Tree at the plus side of the cut hyperplane.</text>
  </javadoc>
  <declaration type="BSPTree&lt;S&gt;" name="plus" />
  <javadoc>
    <text>Tree at the minus side of the cut hyperplane.</text>
  </javadoc>
  <declaration type="BSPTree&lt;S&gt;" name="minus" />
  <javadoc>
    <text>Parent tree.</text>
  </javadoc>
  <declaration type="BSPTree&lt;S&gt;" name="parent" />
  <javadoc>
    <text>Application-defined attribute.</text>
  </javadoc>
  <declaration type="Object" name="attribute" />
  <javadoc>
    <text>Build a tree having only one root cell representing the whole space.</text>
  </javadoc>
  <method type="constructor" name="BSPTree" />
  <javadoc>
    <text>Build a tree having only one root cell representing the whole space.</text>
    <param>attribute attribute of the tree (may be null)</param>
  </javadoc>
  <method type="constructor" name="BSPTree" />
  <javadoc>
    <text>Build a BSPTree from its underlying elements.
 * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; perform any verification on
 * consistency of its arguments, it should therefore be used only
 * when then caller knows what it is doing.&lt;/p&gt;
 * &lt;p&gt;This method is mainly useful kto build trees
 * bottom-up. Building trees top-down is realized with the help of
 * method {@link #insertCut insertCut}.&lt;/p&gt;</text>
    <param>cut cut sub-hyperplane for the tree</param>
    <param>plus plus side sub-tree</param>
    <param>minus minus side sub-tree</param>
    <param>attribute attribute associated with the node (may be null)</param>
    <see>#insertCut</see>
  </javadoc>
  <method type="constructor" name="BSPTree" />
  <javadoc>
    <text>Insert a cut sub-hyperplane in a node.
 * &lt;p&gt;The sub-tree starting at this node will be completely
 * overwritten. The new cut sub-hyperplane will be built from the
 * intersection of the provided hyperplane with the cell. If the
 * hyperplane does intersect the cell, the cell will have two
 * children cells with {@code null} attributes on each side of
 * the inserted cut sub-hyperplane. If the hyperplane does not
 * intersect the cell then &lt;em&gt;no&lt;/em&gt; cut hyperplane will be
 * inserted and the cell will be changed to a leaf cell. The
 * attribute of the node is never changed.&lt;/p&gt;
 * &lt;p&gt;This method is mainly useful when called on leaf nodes
 * (i.e. nodes for which {@link #getCut getCut} returns{@code null}), in this case it provides a way to build a
 * tree top-down (whereas the {@link #BSPTree(SubHyperplane,BSPTree,BSPTree,Object) 4 arguments constructor} is devoted to
 * build trees bottom-up).&lt;/p&gt;</text>
    <param>hyperplane hyperplane to insert, it will be chopped in
 * order to fit in the cell defined by the parent nodes of the
 * instance</param>
    <return>true if a cut sub-hyperplane has been inserted (i.e. if
 * the cell now has two leaf child nodes)</return>
    <see>#BSPTree(SubHyperplane,BSPTree,BSPTree,Object)</see>
  </javadoc>
  <method type="boolean" name="insertCut">
    <scope />
    <declaration type="SubHyperplane&lt;S&gt;" name="chopped" />
    <scope />
  </method>
  <javadoc>
    <text>Copy the instance.
 * &lt;p&gt;The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying objects are
 * shared (except for the nodes attributes and immutable
 * objects).&lt;/p&gt;</text>
    <return>a new tree, copy of the instance</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="copySelf">
    <scope />
  </method>
  <javadoc>
    <text>Get the cut sub-hyperplane.</text>
    <return>cut sub-hyperplane, null if this is a leaf tree</return>
  </javadoc>
  <method type="SubHyperplane&lt;S&gt;" name="getCut" />
  <javadoc>
    <text>Get the tree on the plus side of the cut hyperplane.</text>
    <return>tree on the plus side of the cut hyperplane, null if this
 * is a leaf tree</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="getPlus" />
  <javadoc>
    <text>Get the tree on the minus side of the cut hyperplane.</text>
    <return>tree on the minus side of the cut hyperplane, null if this
 * is a leaf tree</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="getMinus" />
  <javadoc>
    <text>Get the parent node.</text>
    <return>parent node, null if the node has no parents</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="getParent" />
  <javadoc>
    <text>Associate an attribute with the instance.</text>
    <param>attribute attribute to associate with the node</param>
    <see>#getAttribute</see>
  </javadoc>
  <method type="void" name="setAttribute" />
  <javadoc>
    <text>Get the attribute associated with the instance.</text>
    <return>attribute associated with the node or null if no
 * attribute has been explicitly set using the {@link #setAttributesetAttribute} method</return>
    <see>#setAttribute</see>
  </javadoc>
  <method type="Object" name="getAttribute" />
  <javadoc>
    <text>Visit the BSP tree nodes.</text>
    <param>visitor object visiting the tree nodes</param>
  </javadoc>
  <method type="void" name="visit">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Fit a sub-hyperplane inside the cell defined by the instance.
 * &lt;p&gt;Fitting is done by chopping off the parts of the
 * sub-hyperplane that lie outside of the cell using the
 * cut-hyperplanes of the parent nodes of the instance.&lt;/p&gt;</text>
    <param>sub sub-hyperplane to fit</param>
    <return>a new sub-hyperplane, guaranteed to have no part outside
 * of the instance cell</return>
  </javadoc>
  <method type="SubHyperplane&lt;S&gt;" name="fitToCell">
    <declaration type="SubHyperplane&lt;S&gt;" name="s" />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the cell to which a point belongs.
 * &lt;p&gt;If the returned cell is a leaf node the points belongs to the
 * interior of the node, if the cell is an internal node the points
 * belongs to the node cut sub-hyperplane.&lt;/p&gt;</text>
    <param>point point to check</param>
    <return>the tree cell to which the point belongs (can be</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="getCell">
    <scope />
    <declaration type="double" name="offset" />
    <scope />
    <scope />
    <scope />
    <comment>position of the point with respect to the cut hyperplane</comment>
    <comment>point is on the minus side of the cut hyperplane</comment>
    <comment>point is on the plus side of the cut hyperplane</comment>
  </method>
  <javadoc>
    <text>Perform condensation on a tree.
 * &lt;p&gt;The condensation operation is not recursive, it must be called
 * explicitely from leaves to root.&lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="condense">
    <scope />
  </method>
  <javadoc>
    <text>Merge a BSP tree with the instance.
 * &lt;p&gt;All trees are modified (parts of them are reused in the new
 * tree), it is the responsibility of the caller to ensure a copy
 * has been done before if any of the former tree should be
 * preserved, &lt;em&gt;no&lt;/em&gt; such copy is done here!&lt;/p&gt;
 * &lt;p&gt;The algorithm used here is directly derived from the one
 * described in the Naylor, Amanatides and Thibault paper (section
 * III, Binary Partitioning of a BSP Tree).&lt;/p&gt;</text>
    <param>tree other tree to merge with the instance (will be
 * &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
 * instance itself)</param>
    <param>leafMerger object implementing the final merging phase
 * (this is where the semantic of the operation occurs, generally
 * depending on the attribute of the leaf node)</param>
    <return>a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
 * tree&lt;/code&gt;, this value can be ignored if parentTree is not null
 * since all connections have already been established</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="merge" />
  <javadoc>
    <text>Merge a BSP tree with the instance.</text>
    <param>tree other tree to merge with the instance (will be
 * &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
 * instance itself)</param>
    <param>leafMerger object implementing the final merging phase
 * (this is where the semantic of the operation occurs, generally
 * depending on the attribute of the leaf node)</param>
    <param>parentTree parent tree to connect to (may be null)</param>
    <param>isPlusChild if true and if parentTree is not null, the
 * resulting tree should be the plus child of its parent, ignored if
 * parentTree is null</param>
    <return>a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
 * tree&lt;/code&gt;, this value can be ignored if parentTree is not null
 * since all connections have already been established</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="merge">
    <scope />
    <scope />
    <scope>
      <declaration type="BSPTree&lt;S&gt;" name="merged" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
    </scope>
    <comment>cell/tree operation</comment>
    <comment>tree/cell operation</comment>
    <comment>tree/tree operation</comment>
    <comment>merging phase</comment>
  </method>
  <javadoc>
    <text>This interface gather the merging operations between a BSP tree
 * leaf and another BSP tree.
 * &lt;p&gt;As explained in Bruce Naylor, John Amanatides and William
 * Thibault paper &lt;a
 * href="http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf"&gt;Merging
 * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt;,
 * the operations on {@link BSPTree BSP trees} can be expressed as a
 * generic recursive merging operation where only the final part,
 * when one of the operand is a leaf, is specific to the real
 * operation semantics. For example, a tree representing a region
 * using a boolean attribute to identify inside cells and outside
 * cells would use four different objects to implement the final
 * merging phase of the four set operations union, intersection,
 * difference and symmetric difference (exclusive or).&lt;/p&gt;</text>
    <param>&lt;S&gt;
 *  Type of the space.</param>
  </javadoc>
  <method name="merge" type="BSPTree&lt;S&gt;" />
  <javadoc>
    <text>Merge a leaf node and a tree node.
 * &lt;p&gt;This method is called at the end of a recursive merging
 * resulting from a {@code tree1.merge(tree2, leafMerger)}call, when one of the sub-trees involved is a leaf (i.e. when
 * its cut-hyperplane is null). This is the only place where the
 * precise semantics of the operation are required. For all upper
 * level nodes in the tree, the merging operation is only a
 * generic partitioning algorithm.&lt;/p&gt;
 * &lt;p&gt;Since the final operation may be non-commutative, it is
 * important to know if the leaf node comes from the instance tree
 * ({@code tree1}) or the argument tree
 * ({@code tree2}). The third argument of the method is
 * devoted to this. It can be ignored for commutative
 * operations.&lt;/p&gt;
 * &lt;p&gt;The {@link BSPTree#insertInTree BSPTree.insertInTree} method
 * may be useful to implement this method.&lt;/p&gt;</text>
    <param>leaf leaf node (its cut hyperplane is guaranteed to be
 * null)</param>
    <param>tree tree node (its cut hyperplane may be null or not)</param>
    <param>parentTree parent tree to connect to (may be null)</param>
    <param>isPlusChild if true and if parentTree is not null, the
 * resulting tree should be the plus child of its parent, ignored if
 * parentTree is null</param>
    <param>leafFromInstance if true, the leaf node comes from the
 * instance tree ({@code tree1}) and the tree node comes from
 * the argument tree ({@code tree2})</param>
    <return>the BSP tree resulting from the merging (may be one of
 * the arguments)</return>
  </javadoc>
  <javadoc>
    <text>Split a BSP tree by an external sub-hyperplane.
 * &lt;p&gt;Split a tree in two halves, on each side of the
 * sub-hyperplane. The instance is not modified.&lt;/p&gt;
 * &lt;p&gt;The tree returned is not upward-consistent: despite all of its
 * sub-trees cut sub-hyperplanes (including its own cut
 * sub-hyperplane) are bounded to the current cell, it is &lt;em&gt;not&lt;/em&gt;
 * attached to any parent tree yet. This tree is intended to be
 * later inserted into an higher level tree.&lt;/p&gt;
 * &lt;p&gt;The algorithm used here is the one given in Naylor, Amanatides
 * and Thibault paper (section III, Binary Partitioning of a BSP
 * Tree).&lt;/p&gt;</text>
    <param>sub partitioning sub-hyperplane, must be already clipped
 * to the convex region represented by the instance, will be used as
 * the cut sub-hyperplane of the returned tree</param>
    <return>a tree having the specified sub-hyperplane as its cut
 * sub-hyperplane, the two parts of the split instance as its two
 * sub-trees and a null parent</return>
  </javadoc>
  <method type="BSPTree&lt;S&gt;" name="split">
    <scope />
    <declaration type="Hyperplane&lt;S&gt;" name="cHyperplane" />
    <declaration type="Hyperplane&lt;S&gt;" name="sHyperplane" />
    <scope>
      <declaration type="BSPTree&lt;S&gt;" name="split" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="BSPTree&lt;S&gt;" name="split" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" name="cutParts" />
      <declaration type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" name="subParts" />
      <declaration type="BSPTree&lt;S&gt;" name="split" />
      <declaration type="BSPTree&lt;S&gt;" name="tmp" />
    </scope>
    <comment>the partitioning sub-hyperplane is entirely in the plus sub-tree</comment>
    <comment>the partitioning sub-hyperplane is entirely in the minus sub-tree</comment>
  </method>
  <javadoc>
    <text>Insert the instance into another tree.
 * &lt;p&gt;The instance itself is modified so its former parent should
 * not be used anymore.&lt;/p&gt;</text>
    <param>parentTree parent tree to connect to (may be null)</param>
    <param>isPlusChild if true and if parentTree is not null, the
 * resulting tree should be the plus child of its parent, ignored if
 * parentTree is null</param>
    <see>LeafMerger</see>
  </javadoc>
  <method type="void" name="insertInTree">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope>
        <declaration type="Hyperplane&lt;S&gt;" name="hyperplane" />
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>set up parent/child links</comment>
    <comment>make sure the inserted tree lies in the cell defined by its parent nodes</comment>
    <comment>explore the parent nodes from here towards tree root</comment>
    <comment>this is an hyperplane of some parent node</comment>
    <comment>chop off the parts of the inserted tree that extend</comment>
    <comment>on the wrong side of this parent hyperplane</comment>
    <comment>since we may have drop some parts of the inserted tree,</comment>
    <comment>perform a condensation pass to keep the tree structure simple</comment>
  </method>
  <javadoc>
    <text>Chop off parts of the tree.
 * &lt;p&gt;The instance is modified in place, all the parts that are on
 * the minus side of the chopping hyperplane are discarded, only the
 * parts on the plus side remain.&lt;/p&gt;</text>
    <param>hyperplane chopping hyperplane</param>
  </javadoc>
  <method type="void" name="chopOffMinus">
    <scope />
  </method>
  <javadoc>
    <text>Chop off parts of the tree.
 * &lt;p&gt;The instance is modified in place, all the parts that are on
 * the plus side of the chopping hyperplane are discarded, only the
 * parts on the minus side remain.&lt;/p&gt;</text>
    <param>hyperplane chopping hyperplane</param>
  </javadoc>
  <method type="void" name="chopOffPlus">
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
