<?xml version="1.0" encoding="UTF-8"?>
<class name="RealVector">
  <javadoc>
    <text>Class defining a real-valued vector with basic algebraic operations.
 * &lt;p&gt;
 * vector element indexing is 0-based -- e.g., {@code getEntry(0)}returns the first element of the vector.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The {@code code map} and {@code mapToSelf} methods operate
 * on vectors element-wise, i.e. they perform the same operation (adding a scalar,
 * applying a function ...) on each element in turn. The {@code map}versions create a new vector to hold the result and do not change the instance.
 * The {@code mapToSelf} version uses the instance itself to store the
 * results, so the instance is changed by this method. In all cases, the result
 * vector is returned by the methods, allowing the &lt;i&gt;fluent API&lt;/i&gt;
 * style, like this:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * RealVector result = v.mapAddToSelf(3.4).mapToSelf(new Tan()).mapToSelf(new Power(2.3));
 * &lt;/pre&gt;</text>
    <version>$Id: RealVector.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
    <since>2.1</since>
  </javadoc>
  <method name="getDimension" type="int" />
  <javadoc>
    <text>Returns the size of the vector.</text>
    <return>the size of this vector.</return>
  </javadoc>
  <method name="getEntry" type="double" />
  <javadoc>
    <text>Return the entry at the specified index.</text>
    <param>index Index location of entry to be fetched.</param>
    <return>the vector entry at {@code index}.</return>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <see>#setEntry(int,double)</see>
  </javadoc>
  <method name="setEntry" type="void" />
  <javadoc>
    <text>Set a single element.</text>
    <param>index element index.</param>
    <param>value new value for the element.</param>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <see>#getEntry(int)</see>
  </javadoc>
  <javadoc>
    <text>Change an entry at the specified index.</text>
    <param>index Index location of entry to be set.</param>
    <param>increment Value to add to the vector entry.</param>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <since>3.0</since>
  </javadoc>
  <method type="void" name="addToEntry" />
  <method name="append" type="RealVector" />
  <javadoc>
    <text>Construct a new vector by appending a vector to this vector.</text>
    <param>v vector to append to this one.</param>
    <return>a new vector.</return>
  </javadoc>
  <method name="append" type="RealVector" />
  <javadoc>
    <text>Construct a new vector by appending a double to this vector.</text>
    <param>d double to append.</param>
    <return>a new vector.</return>
  </javadoc>
  <method name="getSubVector" type="RealVector" />
  <javadoc>
    <text>Get a subvector from consecutive elements.</text>
    <param>index index of first element.</param>
    <param>n number of elements to be retrieved.</param>
    <return>a vector containing n elements.</return>
    <throws>OutOfRangeException if the index is not valid.</throws>
    <throws>NotPositiveException if the number of elements is not positive.</throws>
  </javadoc>
  <method name="setSubVector" type="void" />
  <javadoc>
    <text>Set a sequence of consecutive elements.</text>
    <param>index index of first element to be set.</param>
    <param>v vector containing the values to set.</param>
    <throws>OutOfRangeException if the index is not valid.</throws>
  </javadoc>
  <method name="isNaN" type="boolean" />
  <javadoc>
    <text>Check whether any coordinate of this vector is {@code NaN}.</text>
    <return>{@code true} if any coordinate of this vector is {@code NaN},{@code false} otherwise.</return>
  </javadoc>
  <method name="isInfinite" type="boolean" />
  <javadoc>
    <text>Check whether any coordinate of this vector is infinite and none are {@code NaN}.</text>
    <return>{@code true} if any coordinate of this vector is infinite and
 * none are {@code NaN}, {@code false} otherwise.</return>
  </javadoc>
  <javadoc>
    <text>Check if instance and specified vectors have the same dimension.</text>
    <param>v Vector to compare instance with.</param>
    <throws>DimensionMismatchException if the vectors do not
 * have the same dimension.</throws>
  </javadoc>
  <method type="void" name="checkVectorDimensions" />
  <javadoc>
    <text>Check if instance dimension is equal to some expected value.</text>
    <param>n Expected dimension.</param>
    <throws>DimensionMismatchException if the dimension is
 * inconsistent with the vector size.</throws>
  </javadoc>
  <method type="void" name="checkVectorDimensions">
    <declaration type="int" name="d" />
    <scope />
  </method>
  <javadoc>
    <text>Check if an index is valid.</text>
    <param>index Index to check.</param>
    <exception>OutOfRangeException if {@code index} is not valid.</exception>
  </javadoc>
  <method type="void" name="checkIndex">
    <scope />
  </method>
  <javadoc>
    <text>Checks that the indices of a subvector are valid.</text>
    <param>start the index of the first entry of the subvector</param>
    <param>end the index of the last entry of the subvector (inclusive)</param>
    <throws>OutOfRangeException if {@code start} of {@code end} are not valid</throws>
    <throws>NumberIsTooSmallException if {@code end &lt; start}</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkIndices">
    <declaration type="int" name="dim" />
    <scope />
    <scope />
    <scope />
    <comment>TODO Use more specific error message</comment>
  </method>
  <javadoc>
    <text>Compute the sum of this vector and {@code v}.
 * Returns a new vector. Does not change instance data.</text>
    <param>v Vector to be added.</param>
    <return>{@code this} + {@code v}.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
  </javadoc>
  <method type="RealVector" name="add">
    <declaration type="RealVector" name="result" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
      <declaration type="int" name="index" />
    </scope>
  </method>
  <javadoc>
    <text>Subtract {@code v} from this vector.
 * Returns a new vector. Does not change instance data.</text>
    <param>v Vector to be subtracted.</param>
    <return>{@code this} - {@code v}.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
  </javadoc>
  <method type="RealVector" name="subtract">
    <declaration type="RealVector" name="result" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
      <declaration type="int" name="index" />
    </scope>
  </method>
  <javadoc>
    <text>Add a value to each entry.
 * Returns a new vector. Does not change instance data.</text>
    <param>d Value to be added to each entry.</param>
    <return>{@code this} + {@code d}.</return>
  </javadoc>
  <method type="RealVector" name="mapAdd" />
  <javadoc>
    <text>Add a value to each entry.
 * The instance is changed in-place.</text>
    <param>d Value to be added to each entry.</param>
    <return>{@code this}.</return>
  </javadoc>
  <method type="RealVector" name="mapAddToSelf">
    <scope />
  </method>
  <method name="copy" type="RealVector" />
  <javadoc>
    <text>Returns a (deep) copy of this vector.</text>
    <return>a vector copy.</return>
  </javadoc>
  <javadoc>
    <text>Compute the dot product of this vector with {@code v}.</text>
    <param>v Vector with which dot product should be computed</param>
    <return>the scalar dot product between this instance and {@code v}.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
  </javadoc>
  <method type="double" name="dotProduct">
    <declaration type="double" name="d" />
    <declaration type="int" name="n" />
    <scope />
  </method>
  <javadoc>
    <text>Computes the cosine of the angle between this vector and the
 * argument.</text>
    <param>v Vector.</param>
    <return>the cosine of the angle between this vector and {@code v}.</return>
    <throws>MathArithmeticException if {@code this} or {@code v} is the null
 * vector</throws>
    <throws>DimensionMismatchException if the dimensions of {@code this} and{@code v} do not match</throws>
  </javadoc>
  <method type="double" name="cosine">
    <declaration type="double" name="norm" />
    <declaration type="double" name="vNorm" />
    <scope />
  </method>
  <method name="ebeDivide" type="RealVector" />
  <javadoc>
    <text>Element-by-element division.</text>
    <param>v Vector by which instance elements must be divided.</param>
    <return>a vector containing this[i] / v[i] for all i.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    <deprecated>As of version 3.1, this method is deprecated, and will be
 * removed in version 4.0. This decision follows the discussion reported in
 * &lt;a href="https://issues.apache.org/jira/browse/MATH-803?focusedCommentId=13399150#comment-13399150"&gt;MATH-803&lt;/a&gt;.
 * Uses of this method involving sparse implementations of{@link RealVector} might lead to wrong results. Since there is no
 * satisfactory correction to this bug, this method is deprecated. Users who
 * want to preserve this feature are advised to implement{@link RealVectorPreservingVisitor} (possibly ignoring corner cases for
 * the sake of efficiency).</deprecated>
  </javadoc>
  <method name="ebeMultiply" type="RealVector" />
  <javadoc>
    <text>Element-by-element multiplication.</text>
    <param>v Vector by which instance elements must be multiplied</param>
    <return>a vector containing this[i] * v[i] for all i.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    <deprecated>As of version 3.1, this method is deprecated, and will be
 * removed in version 4.0. This decision follows the discussion reported in
 * &lt;a href="https://issues.apache.org/jira/browse/MATH-803?focusedCommentId=13399150#comment-13399150"&gt;MATH-803&lt;/a&gt;.
 * Uses of this method involving sparse implementations of{@link RealVector} might lead to wrong results. Since there is no
 * satisfactory correction to this bug, this method is deprecated. Users who
 * want to preserve this feature are advised to implement{@link RealVectorPreservingVisitor} (possibly ignoring corner cases for
 * the sake of efficiency).</deprecated>
  </javadoc>
  <javadoc>
    <text>Distance between two vectors.
 * &lt;p&gt;This method computes the distance consistent with the
 * L&lt;sub&gt;2&lt;/sub&gt; norm, i.e. the square root of the sum of
 * element differences, or Euclidean distance.&lt;/p&gt;</text>
    <param>v Vector to which distance is requested.</param>
    <return>the distance between two vectors.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    <see>#getL1Distance(RealVector)</see>
    <see>#getLInfDistance(RealVector)</see>
    <see>#getNorm()</see>
  </javadoc>
  <method type="double" name="getDistance">
    <declaration type="double" name="d" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
      <declaration type="double" name="diff" />
    </scope>
  </method>
  <javadoc>
    <text>Returns the L&lt;sub&gt;2&lt;/sub&gt; norm of the vector.
 * &lt;p&gt;The L&lt;sub&gt;2&lt;/sub&gt; norm is the root of the sum of
 * the squared elements.&lt;/p&gt;</text>
    <return>the norm.</return>
    <see>#getL1Norm()</see>
    <see>#getLInfNorm()</see>
    <see>#getDistance(RealVector)</see>
  </javadoc>
  <method type="double" name="getNorm">
    <declaration type="double" name="sum" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
      <declaration type="double" name="value" />
    </scope>
  </method>
  <javadoc>
    <text>Returns the L&lt;sub&gt;1&lt;/sub&gt; norm of the vector.
 * &lt;p&gt;The L&lt;sub&gt;1&lt;/sub&gt; norm is the sum of the absolute
 * values of the elements.&lt;/p&gt;</text>
    <return>the norm.</return>
    <see>#getNorm()</see>
    <see>#getLInfNorm()</see>
    <see>#getL1Distance(RealVector)</see>
  </javadoc>
  <method type="double" name="getL1Norm">
    <declaration type="double" name="norm" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Returns the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm of the vector.
 * &lt;p&gt;The L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm is the max of the absolute
 * values of the elements.&lt;/p&gt;</text>
    <return>the norm.</return>
    <see>#getNorm()</see>
    <see>#getL1Norm()</see>
    <see>#getLInfDistance(RealVector)</see>
  </javadoc>
  <method type="double" name="getLInfNorm">
    <declaration type="double" name="norm" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Distance between two vectors.
 * &lt;p&gt;This method computes the distance consistent with
 * L&lt;sub&gt;1&lt;/sub&gt; norm, i.e. the sum of the absolute values of
 * the elements differences.&lt;/p&gt;</text>
    <param>v Vector to which distance is requested.</param>
    <return>the distance between two vectors.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
  </javadoc>
  <method type="double" name="getL1Distance">
    <declaration type="double" name="d" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Distance between two vectors.
 * &lt;p&gt;This method computes the distance consistent with
 * L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm, i.e. the max of the absolute values of
 * element differences.&lt;/p&gt;</text>
    <param>v Vector to which distance is requested.</param>
    <return>the distance between two vectors.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    <see>#getDistance(RealVector)</see>
    <see>#getL1Distance(RealVector)</see>
    <see>#getLInfNorm()</see>
  </javadoc>
  <method type="double" name="getLInfDistance">
    <declaration type="double" name="d" />
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Get the index of the minimum entry.</text>
    <return>the index of the minimum entry or -1 if vector length is 0
 * or all entries are {@code NaN}.</return>
  </javadoc>
  <method type="int" name="getMinIndex">
    <declaration type="int" name="minIndex" />
    <declaration type="double" name="minValue" />
    <declaration type="Iterator&lt;Entry&gt;" name="iterator" />
    <scope>
      <declaration type="Entry" name="entry" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the value of the minimum entry.</text>
    <return>the value of the minimum entry or {@code NaN} if all
 * entries are {@code NaN}.</return>
  </javadoc>
  <method type="double" name="getMinValue">
    <declaration type="int" name="minIndex" />
  </method>
  <javadoc>
    <text>Get the index of the maximum entry.</text>
    <return>the index of the maximum entry or -1 if vector length is 0
 * or all entries are {@code NaN}</return>
  </javadoc>
  <method type="int" name="getMaxIndex">
    <declaration type="int" name="maxIndex" />
    <declaration type="double" name="maxValue" />
    <declaration type="Iterator&lt;Entry&gt;" name="iterator" />
    <scope>
      <declaration type="Entry" name="entry" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the value of the maximum entry.</text>
    <return>the value of the maximum entry or {@code NaN} if all
 * entries are {@code NaN}.</return>
  </javadoc>
  <method type="double" name="getMaxValue">
    <declaration type="int" name="maxIndex" />
  </method>
  <javadoc>
    <text>Multiply each entry by the argument. Returns a new vector.
 * Does not change instance data.</text>
    <param>d Multiplication factor.</param>
    <return>{@code this} * {@code d}.</return>
  </javadoc>
  <method type="RealVector" name="mapMultiply" />
  <javadoc>
    <text>Multiply each entry.
 * The instance is changed in-place.</text>
    <param>d Multiplication factor.</param>
    <return>{@code this}.</return>
  </javadoc>
  <method type="RealVector" name="mapMultiplyToSelf" />
  <javadoc>
    <text>Subtract a value from each entry. Returns a new vector.
 * Does not change instance data.</text>
    <param>d Value to be subtracted.</param>
    <return>{@code this} - {@code d}.</return>
  </javadoc>
  <method type="RealVector" name="mapSubtract" />
  <javadoc>
    <text>Subtract a value from each entry.
 * The instance is changed in-place.</text>
    <param>d Value to be subtracted.</param>
    <return>{@code this}.</return>
  </javadoc>
  <method type="RealVector" name="mapSubtractToSelf" />
  <javadoc>
    <text>Divide each entry by the argument. Returns a new vector.
 * Does not change instance data.</text>
    <param>d Value to divide by.</param>
    <return>{@code this} / {@code d}.</return>
  </javadoc>
  <method type="RealVector" name="mapDivide" />
  <javadoc>
    <text>Divide each entry by the argument.
 * The instance is changed in-place.</text>
    <param>d Value to divide by.</param>
    <return>{@code this}.</return>
  </javadoc>
  <method type="RealVector" name="mapDivideToSelf" />
  <javadoc>
    <text>Compute the outer product.</text>
    <param>v Vector with which outer product should be computed.</param>
    <return>the matrix outer product between this instance and {@code v}.</return>
  </javadoc>
  <method type="RealMatrix" name="outerProduct">
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
    <declaration type="RealMatrix" name="product" />
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Find the orthogonal projection of this vector onto another vector.</text>
    <param>v vector onto which instance must be projected.</param>
    <return>projection of the instance onto {@code v}.</return>
    <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    <throws>MathArithmeticException if {@code this} or {@code v} is the null
 * vector</throws>
  </javadoc>
  <method type="RealVector" name="projection">
    <declaration type="double" name="norm2" />
    <scope />
  </method>
  <javadoc>
    <text>Set all elements to a single value.</text>
    <param>value Single value to set for all elements.</param>
  </javadoc>
  <method type="void" name="set">
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Convert the vector to an array of {@code double}s.
 * The array is independent from this vector data: the elements
 * are copied.</text>
    <return>an array containing a copy of the vector elements.</return>
  </javadoc>
  <method type="double[]" name="toArray">
    <declaration type="int" name="dim" />
    <declaration type="double[]" name="values" />
    <scope />
  </method>
  <javadoc>
    <text>Creates a unit vector pointing in the direction of this vector.
 * The instance is not changed by this method.</text>
    <return>a unit vector pointing in direction of this vector.</return>
    <throws>MathArithmeticException if the norm is zero.</throws>
  </javadoc>
  <method type="RealVector" name="unitVector">
    <declaration type="double" name="norm" />
    <scope />
  </method>
  <javadoc>
    <text>Converts this vector into a unit vector.
 * The instance itself is changed by this method.</text>
    <throws>MathArithmeticException if the norm is zero.</throws>
  </javadoc>
  <method type="void" name="unitize">
    <declaration type="double" name="norm" />
    <scope />
  </method>
  <javadoc>
    <text>Create a sparse iterator over the vector, which may omit some entries.
 * Specialized implementations may choose to not iterate over all
 * dimensions, either because those values are unset, or are equal
 * to defaultValue(), or are small enough to be ignored for the
 * purposes of iteration. No guarantees are made about order of iteration.
 * In dense implementations, this method will often delegate to{@link #iterator()}.
 * &lt;p&gt;Note: derived classes are required to return an {@link Iterator} that
 * returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}returns {@code true}.&lt;/p&gt;</text>
    <return>a sparse iterator.</return>
    <deprecated>As of 3.1, this method is deprecated, because its interface
 * is too confusing (see
 * &lt;a href="https://issues.apache.org/jira/browse/MATH-875"&gt;JIRA MATH-875&lt;/a&gt;).
 * This method will be completely removed in 4.0.</deprecated>
  </javadoc>
  <method type="Iterator&lt;Entry&gt;" name="sparseIterator" />
  <javadoc>
    <text>Generic dense iterator. Iteration is in increasing order
 * of the vector index.
 * &lt;p&gt;Note: derived classes are required to return an {@link Iterator} that
 * returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}returns {@code true}.&lt;/p&gt;</text>
    <return>a dense iterator.</return>
  </javadoc>
  <method type="Iterator&lt;Entry&gt;" name="iterator">
    <declaration type="int" name="dim" />
    <javadoc>
      <text>Current index.</text>
    </javadoc>
    <declaration type="int" name="i" />
    <javadoc>
      <text>Current entry.</text>
    </javadoc>
    <declaration type="Entry" name="e" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="hasNext" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="Entry" name="next">
      <scope />
      <scope />
    </method>
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all circumstances.</throws>
    </javadoc>
    <method type="void" name="remove" />
  </method>
  <javadoc>
    <text>Acts as if implemented as:
 * &lt;pre&gt;
 * return copy().mapToSelf(function);
 * &lt;/pre&gt;
 * Returns a new vector. Does not change instance data.</text>
    <param>function Function to apply to each entry.</param>
    <return>a new vector.</return>
  </javadoc>
  <method type="RealVector" name="map" />
  <javadoc>
    <text>Acts as if it is implemented as:
 * &lt;pre&gt;
 * Entry e = null;
 * for(Iterator&lt;Entry&gt; it = iterator(); it.hasNext(); e = it.next()) {
 * e.setValue(function.value(e.getValue()));
 * }
 * &lt;/pre&gt;
 * Entries of this vector are modified in-place by this method.</text>
    <param>function Function to apply to each entry.</param>
    <return>a reference to this vector.</return>
  </javadoc>
  <method type="RealVector" name="mapToSelf">
    <declaration type="Iterator&lt;Entry&gt;" name="it" />
    <scope>
      <declaration type="Entry" name="e" />
    </scope>
  </method>
  <javadoc>
    <text>Returns a new vector representing {@code a * this + b * y}, the linear
 * combination of {@code this} and {@code y}.
 * Returns a new vector. Does not change instance data.</text>
    <param>a Coefficient of {@code this}.</param>
    <param>b Coefficient of {@code y}.</param>
    <param>y Vector with which {@code this} is linearly combined.</param>
    <return>a vector containing {@code a * this[i] + b * y[i]} for all{@code i}.</return>
    <throws>DimensionMismatchException if {@code y} is not the same size as{@code this} vector.</throws>
  </javadoc>
  <method type="RealVector" name="combine" />
  <javadoc>
    <text>Updates {@code this} with the linear combination of {@code this} and{@code y}.</text>
    <param>a Weight of {@code this}.</param>
    <param>b Weight of {@code y}.</param>
    <param>y Vector with which {@code this} is linearly combined.</param>
    <return>{@code this}, with components equal to{@code a * this[i] + b * y[i]} for all {@code i}.</return>
    <throws>DimensionMismatchException if {@code y} is not the same size as{@code this} vector.</throws>
  </javadoc>
  <method type="RealVector" name="combineToSelf">
    <scope>
      <declaration type="double" name="xi" />
      <declaration type="double" name="yi" />
    </scope>
  </method>
  <javadoc>
    <text>Visits (but does not alter) all entries of this vector in default order
 * (increasing index).</text>
    <param>visitor the visitor to be used to process the entries of this
 * vector</param>
    <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInDefaultOrder">
    <declaration type="int" name="dim" />
    <scope />
  </method>
  <javadoc>
    <text>Visits (but does not alter) some entries of this vector in default order
 * (increasing index).</text>
    <param>visitor visitor to be used to process the entries of this vector</param>
    <param>start the index of the first entry to be visited</param>
    <param>end the index of the last entry to be visited (inclusive)</param>
    <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
    <throws>NumberIsTooSmallException if {@code end &lt; start}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInDefaultOrder">
    <scope />
  </method>
  <javadoc>
    <text>Visits (but does not alter) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
    <param>visitor the visitor to be used to process the entries of this
 * vector</param>
    <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInOptimizedOrder" />
  <javadoc>
    <text>Visits (but does not alter) some entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
    <param>visitor visitor to be used to process the entries of this vector</param>
    <param>start the index of the first entry to be visited</param>
    <param>end the index of the last entry to be visited (inclusive)</param>
    <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
    <throws>NumberIsTooSmallException if {@code end &lt; start}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInOptimizedOrder" />
  <javadoc>
    <text>Visits (and possibly alters) all entries of this vector in default order
 * (increasing index).</text>
    <param>visitor the visitor to be used to process and modify the entries
 * of this vector</param>
    <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInDefaultOrder">
    <declaration type="int" name="dim" />
    <scope />
  </method>
  <javadoc>
    <text>Visits (and possibly alters) some entries of this vector in default order
 * (increasing index).</text>
    <param>visitor visitor to be used to process the entries of this vector</param>
    <param>start the index of the first entry to be visited</param>
    <param>end the index of the last entry to be visited (inclusive)</param>
    <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
    <throws>NumberIsTooSmallException if {@code end &lt; start}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInDefaultOrder">
    <scope />
  </method>
  <javadoc>
    <text>Visits (and possibly alters) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
    <param>visitor the visitor to be used to process the entries of this
 * vector</param>
    <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInOptimizedOrder" />
  <javadoc>
    <text>Visits (and possibly change) some entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
    <param>visitor visitor to be used to process the entries of this vector</param>
    <param>start the index of the first entry to be visited</param>
    <param>end the index of the last entry to be visited (inclusive)</param>
    <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
    <throws>NumberIsTooSmallException if {@code end &lt; start}.</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="walkInOptimizedOrder" />
  <javadoc>
    <text>An entry in the vector.</text>
  </javadoc>
  <javadoc>
    <text>Index of this entry.</text>
  </javadoc>
  <declaration type="int" name="index" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="Entry" />
  <javadoc>
    <text>Get the value of the entry.</text>
    <return>the value of the entry.</return>
  </javadoc>
  <method type="double" name="getValue" />
  <javadoc>
    <text>Set the value of the entry.</text>
    <param>value New value for the entry.</param>
  </javadoc>
  <method type="void" name="setValue" />
  <javadoc>
    <text>Get the index of the entry.</text>
    <return>the index of the entry.</return>
  </javadoc>
  <method type="int" name="getIndex" />
  <javadoc>
    <text>Set the index of the entry.</text>
    <param>index New index for the entry.</param>
  </javadoc>
  <method type="void" name="setIndex" />
  <javadoc>
    <text>&lt;p&gt;
 * Test for the equality of two real vectors. If all coordinates of two real
 * vectors are exactly the same, and none are {@code NaN}, the two real
 * vectors are considered to be equal. {@code NaN} coordinates are
 * considered to affect globally the vector and be equals to each other -
 * i.e, if either (or all) coordinates of the real vector are equal to{@code NaN}, the real vector is equal to a vector with all {@code NaN}coordinates.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This method &lt;em&gt;must&lt;/em&gt; be overriden by concrete subclasses of{@link RealVector} (the current implementation throws an exception).
 * &lt;/p&gt;</text>
    <param>other Object to test for equality.</param>
    <return>{@code true} if two vector objects are equal, {@code false} if{@code other} is null, not an instance of {@code RealVector}, or
 * not equal to this {@code RealVector} instance.</return>
    <throws>MathUnsupportedOperationException if this method is not
 * overridden.</throws>
  </javadoc>
  <method type="boolean" name="equals" />
  <javadoc>
    <text>{@inheritDoc}. This method &lt;em&gt;must&lt;/em&gt; be overriden by concrete
 * subclasses of {@link RealVector} (current implementation throws an
 * exception).</text>
    <throws>MathUnsupportedOperationException if this method is not
 * overridden.</throws>
  </javadoc>
  <method type="int" name="hashCode" />
  <javadoc>
    <text>This class should rarely be used, but is here to provide
 * a default implementation of sparseIterator(), which is implemented
 * by walking over the entries, skipping those whose values are the default one.
 * Concrete subclasses which are SparseVector implementations should
 * make their own sparse iterator, rather than using this one.
 * This implementation might be useful for ArrayRealVector, when expensive
 * operations which preserve the default value are to be done on the entries,
 * and the fraction of non-default values is small (i.e. someone took a
 * SparseVector, and passed it into the copy-constructor of ArrayRealVector)</text>
    <deprecated>As of 3.1, this class is deprecated, see
 * &lt;a href="https://issues.apache.org/jira/browse/MATH-875"&gt;JIRA MATH-875&lt;/a&gt;.
 * This class will be completely removed in 4.0.</deprecated>
  </javadoc>
  <javadoc>
    <text>Dimension of the vector.</text>
  </javadoc>
  <declaration type="int" name="dim" />
  <javadoc>
    <text>Last entry returned by {@link #next()}.</text>
  </javadoc>
  <declaration type="Entry" name="current" />
  <javadoc>
    <text>Next entry for {@link #next()} to return.</text>
  </javadoc>
  <declaration type="Entry" name="next" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="SparseEntryIterator">
    <scope />
  </method>
  <javadoc>
    <text>Advance an entry up to the next nonzero one.</text>
    <param>e entry to advance.</param>
  </javadoc>
  <method type="void" name="advance">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="hasNext" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Entry" name="next">
    <declaration type="int" name="index" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>MathUnsupportedOperationException in all circumstances.</throws>
  </javadoc>
  <method type="void" name="remove" />
  <javadoc>
    <text>Returns an unmodifiable view of the specified vector.
 * The returned vector has read-only access. An attempt to modify it will
 * result in a {@link MathUnsupportedOperationException}. However, the
 * returned vector is &lt;em&gt;not&lt;/em&gt; immutable, since any modification of{@code v} will also change the returned view.
 * For example, in the following piece of code
 * &lt;pre&gt;
 * RealVector v = new ArrayRealVector(2);
 * RealVector w = RealVector.unmodifiableRealVector(v);
 * v.setEntry(0, 1.2);
 * v.setEntry(1, -3.4);
 * &lt;/pre&gt;
 * the changes will be seen in the {@code w} view of {@code v}.</text>
    <param>v Vector for which an unmodifiable view is to be returned.</param>
    <return>an unmodifiable view of {@code v}.</return>
  </javadoc>
  <method type="RealVector" name="unmodifiableRealVector">
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all circumstances.</throws>
    </javadoc>
    <method type="RealVector" name="mapToSelf" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="map" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="Iterator&lt;Entry&gt;" name="iterator">
      <declaration type="Iterator&lt;Entry&gt;" name="i" />
      <javadoc>
        <text>The current entry.</text>
      </javadoc>
      <declaration type="UnmodifiableEntry" name="e" />
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="boolean" name="hasNext" />
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="Entry" name="next" />
      <javadoc>
        <text>{@inheritDoc}</text>
        <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
      </javadoc>
      <method type="void" name="remove" />
    </method>
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="Iterator&lt;Entry&gt;" name="sparseIterator">
      <declaration type="Iterator&lt;Entry&gt;" name="i" />
      <javadoc>
        <text>The current entry.</text>
      </javadoc>
      <declaration type="UnmodifiableEntry" name="e" />
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="boolean" name="hasNext" />
      <javadoc>
        <text>{@inheritDoc}</text>
      </javadoc>
      <method type="Entry" name="next" />
      <javadoc>
        <text>{@inheritDoc}</text>
        <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
      </javadoc>
      <method type="void" name="remove" />
    </method>
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="copy" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="add" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="subtract" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="mapAdd" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="RealVector" name="mapAddToSelf" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="mapSubtract" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="RealVector" name="mapSubtractToSelf" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="mapMultiply" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="RealVector" name="mapMultiplyToSelf" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="mapDivide" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="RealVector" name="mapDivideToSelf" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="ebeMultiply" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="ebeDivide" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="dotProduct" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="cosine" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getNorm" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getL1Norm" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getLInfNorm" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getDistance" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getL1Distance" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getLInfDistance" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="unitVector" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="void" name="unitize" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealMatrix" name="outerProduct" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getEntry" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="void" name="setEntry" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="void" name="addToEntry" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="int" name="getDimension" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="append" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="append" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="getSubVector" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="void" name="setSubVector" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="void" name="set" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double[]" name="toArray" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isNaN" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isInfinite" />
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="RealVector" name="combine" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="RealVector" name="combineToSelf" />
    <javadoc>
      <text>An entry in the vector.</text>
    </javadoc>
    <javadoc>
      <text>{@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getValue" />
    <javadoc>
      <text>{@inheritDoc}</text>
      <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
    </javadoc>
    <method type="void" name="setValue" />
    <javadoc>
      <text>This anonymous class is an implementation of {@link RealVector}with read-only access.
 * It wraps any {@link RealVector}, and exposes all methods which
 * do not modify it. Invoking methods which should normally result
 * in the modification of the calling {@link RealVector} results in
 * a {@link MathUnsupportedOperationException}. It should be noted
 * that {@link UnmodifiableVector} is &lt;em&gt;not&lt;/em&gt; immutable.</text>
    </javadoc>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
