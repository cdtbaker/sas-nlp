<?xml version="1.0" encoding="UTF-8"?>
<class name="AdamsBashforthIntegrator">
  <javadoc>
    <text>This class implements explicit Adams-Bashforth integrators for Ordinary
 * Differential Equations.
 * &lt;p&gt;Adams-Bashforth methods (in fact due to Adams alone) are explicit
 * multistep ODE solvers. This implementation is a variation of the classical
 * one: it uses adaptive stepsize to implement error control, whereas
 * classical implementations are fixed step size. The value of state vector
 * at step n+1 is a simple combination of the value at step n and of the
 * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous
 * steps one wants to use for computing the next value, different formulas
 * are available:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;k = 1: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h y'&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;k = 2: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (3y'&lt;sub&gt;n&lt;/sub&gt;-y'&lt;sub&gt;n-1&lt;/sub&gt;)/2&lt;/li&gt;
 * &lt;li&gt;k = 3: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (23y'&lt;sub&gt;n&lt;/sub&gt;-16y'&lt;sub&gt;n-1&lt;/sub&gt;+5y'&lt;sub&gt;n-2&lt;/sub&gt;)/12&lt;/li&gt;
 * &lt;li&gt;k = 4: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (55y'&lt;sub&gt;n&lt;/sub&gt;-59y'&lt;sub&gt;n-1&lt;/sub&gt;+37y'&lt;sub&gt;n-2&lt;/sub&gt;-9y'&lt;sub&gt;n-3&lt;/sub&gt;)/24&lt;/li&gt;
 * &lt;li&gt;...&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;A k-steps Adams-Bashforth method is of order k.&lt;/p&gt;
 * &lt;h3&gt;Implementation details&lt;/h3&gt;
 * &lt;p&gt;We define scaled derivatives s&lt;sub&gt;i&lt;/sub&gt;(n) at step n as:
 * &lt;pre&gt;
 * s&lt;sub&gt;1&lt;/sub&gt;(n) = h y'&lt;sub&gt;n&lt;/sub&gt; for first derivative
 * s&lt;sub&gt;2&lt;/sub&gt;(n) = h&lt;sup&gt;2&lt;/sup&gt;/2 y''&lt;sub&gt;n&lt;/sub&gt; for second derivative
 * s&lt;sub&gt;3&lt;/sub&gt;(n) = h&lt;sup&gt;3&lt;/sup&gt;/6 y'''&lt;sub&gt;n&lt;/sub&gt; for third derivative
 * ...
 * s&lt;sub&gt;k&lt;/sub&gt;(n) = h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;&lt;sub&gt;n&lt;/sub&gt; for k&lt;sup&gt;th&lt;/sup&gt; derivative
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;The definitions above use the classical representation with several previous first
 * derivatives. Lets define
 * &lt;pre&gt;
 * q&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;1&lt;/sub&gt;(n-1) s&lt;sub&gt;1&lt;/sub&gt;(n-2) ... s&lt;sub&gt;1&lt;/sub&gt;(n-(k-1)) ]&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/pre&gt;
 * (we omit the k index in the notation for clarity). With these definitions,
 * Adams-Bashforth methods can be written:
 * &lt;ul&gt;
 * &lt;li&gt;k = 1: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n)&lt;/li&gt;
 * &lt;li&gt;k = 2: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 3/2 s&lt;sub&gt;1&lt;/sub&gt;(n) + [ -1/2 ] q&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;k = 3: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 23/12 s&lt;sub&gt;1&lt;/sub&gt;(n) + [ -16/12 5/12 ] q&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;k = 4: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 55/24 s&lt;sub&gt;1&lt;/sub&gt;(n) + [ -59/24 37/24 -9/24 ] q&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;...&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;Instead of using the classical representation with first derivatives only (y&lt;sub&gt;n&lt;/sub&gt;,
 * s&lt;sub&gt;1&lt;/sub&gt;(n) and q&lt;sub&gt;n&lt;/sub&gt;), our implementation uses the Nordsieck vector with
 * higher degrees scaled derivatives all taken at the same step (y&lt;sub&gt;n&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;(n)
 * and r&lt;sub&gt;n&lt;/sub&gt;) where r&lt;sub&gt;n&lt;/sub&gt; is defined as:
 * &lt;pre&gt;
 * r&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;2&lt;/sub&gt;(n), s&lt;sub&gt;3&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n) ]&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/pre&gt;
 * (here again we omit the k index in the notation for clarity)
 * &lt;/p&gt;
 * &lt;p&gt;Taylor series formulas show that for any index offset i, s&lt;sub&gt;1&lt;/sub&gt;(n-i) can be
 * computed from s&lt;sub&gt;1&lt;/sub&gt;(n), s&lt;sub&gt;2&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n), the formula being exact
 * for degree k polynomials.
 * &lt;pre&gt;
 * s&lt;sub&gt;1&lt;/sub&gt;(n-i) = s&lt;sub&gt;1&lt;/sub&gt;(n) + &amp;sum;&lt;sub&gt;j&lt;/sub&gt; j (-i)&lt;sup&gt;j-1&lt;/sup&gt; s&lt;sub&gt;j&lt;/sub&gt;(n)
 * &lt;/pre&gt;
 * The previous formula can be used with several values for i to compute the transform between
 * classical representation and Nordsieck vector. The transform between r&lt;sub&gt;n&lt;/sub&gt;
 * and q&lt;sub&gt;n&lt;/sub&gt; resulting from the Taylor series formulas above is:
 * &lt;pre&gt;
 * q&lt;sub&gt;n&lt;/sub&gt; = s&lt;sub&gt;1&lt;/sub&gt;(n) u + P r&lt;sub&gt;n&lt;/sub&gt;
 * &lt;/pre&gt;
 * where u is the [ 1 1 ... 1 ]&lt;sup&gt;T&lt;/sup&gt; vector and P is the (k-1)&amp;times;(k-1) matrix built
 * with the j (-i)&lt;sup&gt;j-1&lt;/sup&gt; terms:
 * &lt;pre&gt;
 * [  -2   3   -4    5  ... ]
 * [  -4  12  -32   80  ... ]
 * P =  [  -6  27 -108  405  ... ]
 * [  -8  48 -256 1280  ... ]
 * [          ...           ]
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;Using the Nordsieck vector has several advantages:
 * &lt;ul&gt;
 * &lt;li&gt;it greatly simplifies step interpolation as the interpolator mainly applies
 * Taylor series formulas,&lt;/li&gt;
 * &lt;li&gt;it simplifies step changes that occur when discrete events that truncate
 * the step are triggered,&lt;/li&gt;
 * &lt;li&gt;it allows to extend the methods in order to support adaptive stepsize.&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:
 * &lt;ul&gt;
 * &lt;li&gt;y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n) + u&lt;sup&gt;T&lt;/sup&gt; r&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;li&gt;s&lt;sub&gt;1&lt;/sub&gt;(n+1) = h f(t&lt;sub&gt;n+1&lt;/sub&gt;, y&lt;sub&gt;n+1&lt;/sub&gt;)&lt;/li&gt;
 * &lt;li&gt;r&lt;sub&gt;n+1&lt;/sub&gt; = (s&lt;sub&gt;1&lt;/sub&gt;(n) - s&lt;sub&gt;1&lt;/sub&gt;(n+1)) P&lt;sup&gt;-1&lt;/sup&gt; u + P&lt;sup&gt;-1&lt;/sup&gt; A P r&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * where A is a rows shifting matrix (the lower left part is an identity matrix):
 * &lt;pre&gt;
 * [ 0 0   ...  0 0 | 0 ]
 * [ ---------------+---]
 * [ 1 0   ...  0 0 | 0 ]
 * A = [ 0 1   ...  0 0 | 0 ]
 * [       ...      | 0 ]
 * [ 0 0   ...  1 0 | 0 ]
 * [ 0 0   ...  0 1 | 0 ]
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;The P&lt;sup&gt;-1&lt;/sup&gt;u vector and the P&lt;sup&gt;-1&lt;/sup&gt; A P matrix do not depend on the state,
 * they only depend on k and therefore are precomputed once for all.&lt;/p&gt;</text>
    <version>$Id: AdamsBashforthIntegrator.java 1463684 2013-04-02 19:04:13Z luc $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Integrator method name.</text>
  </javadoc>
  <declaration type="String" name="METHOD_NAME" />
  <javadoc>
    <text>Build an Adams-Bashforth integrator with the given order and step control parameters.</text>
    <param>nSteps number of steps of the method excluding the one being computed</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>scalAbsoluteTolerance allowed absolute error</param>
    <param>scalRelativeTolerance allowed relative error</param>
    <exception>NumberIsTooSmallException if order is 1 or less</exception>
  </javadoc>
  <method type="constructor" name="AdamsBashforthIntegrator" />
  <javadoc>
    <text>Build an Adams-Bashforth integrator with the given order and step control parameters.</text>
    <param>nSteps number of steps of the method excluding the one being computed</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>vecAbsoluteTolerance allowed absolute error</param>
    <param>vecRelativeTolerance allowed relative error</param>
    <exception>IllegalArgumentException if order is 1 or less</exception>
  </javadoc>
  <method type="constructor" name="AdamsBashforthIntegrator" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="integrate">
    <declaration type="boolean" name="forward" />
    <declaration type="double[]" name="y0" />
    <declaration type="double[]" name="y" />
    <declaration type="double[]" name="yDot" />
    <declaration type="NordsieckStepInterpolator" name="interpolator" />
    <declaration type="int" name="lastRow" />
    <declaration type="double" name="hNew" />
    <scope>
      <declaration type="double" name="error" />
      <scope>
        <scope>
          <declaration type="double" name="yScale" />
          <declaration type="double" name="tol" />
          <declaration type="double" name="ratio" />
        </scope>
        <scope>
          <declaration type="double" name="factor" />
        </scope>
      </scope>
      <declaration type="double" name="stepEnd" />
      <declaration type="ExpandableStatefulODE" name="expandable" />
      <declaration type="EquationsMapper" name="primary" />
      <declaration type="int" name="index" />
      <scope />
      <declaration type="double[]" name="predictedScaled" />
      <scope />
      <declaration type="Array2DRowRealMatrix" name="nordsieckTmp" />
      <scope>
        <scope />
        <declaration type="double" name="factor" />
        <declaration type="double" name="scaledH" />
        <declaration type="double" name="nextT" />
        <declaration type="boolean" name="nextIsLast" />
        <declaration type="double" name="filteredNextT" />
        <declaration type="boolean" name="filteredNextIsLast" />
        <scope />
      </scope>
    </scope>
    <comment>initialize working arrays</comment>
    <comment>set up an interpolator sharing the integrator arrays</comment>
    <comment>set up integration control objects</comment>
    <comment>compute the initial Nordsieck vector using the configured starter integrator</comment>
    <comment>reuse the step that was chosen by the starter integrator</comment>
    <comment>main integration loop</comment>
    <comment>evaluate error using the last term of the Taylor expansion</comment>
    <comment>reject the step and attempt to reduce error by stepsize control</comment>
    <comment>predict a first estimate of the state at step end</comment>
    <comment>evaluate the derivative</comment>
    <comment>update Nordsieck vector</comment>
    <comment>discrete events handling</comment>
    <comment>prepare next step</comment>
    <comment>some events handler has triggered changes that</comment>
    <comment>invalidate the derivatives, we need to restart from scratch</comment>
    <comment>stepsize control for next step</comment>
    <comment>dispatch results</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
