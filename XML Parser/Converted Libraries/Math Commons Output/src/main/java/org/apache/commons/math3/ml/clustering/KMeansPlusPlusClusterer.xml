<?xml version="1.0" encoding="UTF-8"?>
<class name="KMeansPlusPlusClusterer">
  <javadoc>
    <text>Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.</text>
    <param>&lt;T&gt;
 *  type of the points to cluster</param>
    <see>&lt;a href="http://en.wikipedia.org/wiki/K-means%2B%2B"&gt;K-means++ (wikipedia)&lt;/a&gt;</see>
    <version>$Id: KMeansPlusPlusClusterer.java 1461866 2013-03-27 21:54:36Z tn $</version>
    <since>3.2</since>
  </javadoc>
  <javadoc>
    <text>Strategies to use for replacing an empty cluster.</text>
  </javadoc>
  <javadoc>
    <text>Split the cluster with largest distance variance.</text>
  </javadoc>
  <javadoc>
    <text>Split the cluster with largest number of points.</text>
  </javadoc>
  <javadoc>
    <text>Create a cluster around the point farthest from its centroid.</text>
  </javadoc>
  <javadoc>
    <text>Generate an error.</text>
  </javadoc>
  <javadoc>
    <text>The number of clusters.</text>
  </javadoc>
  <declaration type="int" name="k" />
  <javadoc>
    <text>The maximum number of iterations.</text>
  </javadoc>
  <declaration type="int" name="maxIterations" />
  <javadoc>
    <text>Random generator for choosing initial centers.</text>
  </javadoc>
  <declaration type="RandomGenerator" name="random" />
  <javadoc>
    <text>Selected strategy for empty clusters.</text>
  </javadoc>
  <declaration type="EmptyClusterStrategy" name="emptyStrategy" />
  <javadoc>
    <text>Build a clusterer.
 * &lt;p&gt;
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.
 * &lt;p&gt;
 * The euclidean distance will be used as default distance measure.</text>
    <param>k the number of clusters to split the data into</param>
  </javadoc>
  <method type="constructor" name="KMeansPlusPlusClusterer" />
  <javadoc>
    <text>Build a clusterer.
 * &lt;p&gt;
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.
 * &lt;p&gt;
 * The euclidean distance will be used as default distance measure.</text>
    <param>k the number of clusters to split the data into</param>
    <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
  </javadoc>
  <method type="constructor" name="KMeansPlusPlusClusterer" />
  <javadoc>
    <text>Build a clusterer.
 * &lt;p&gt;
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.</text>
    <param>k the number of clusters to split the data into</param>
    <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
    <param>measure the distance measure to use</param>
  </javadoc>
  <method type="constructor" name="KMeansPlusPlusClusterer" />
  <javadoc>
    <text>Build a clusterer.
 * &lt;p&gt;
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.</text>
    <param>k the number of clusters to split the data into</param>
    <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
    <param>measure the distance measure to use</param>
    <param>random random generator to use for choosing initial centers</param>
  </javadoc>
  <method type="constructor" name="KMeansPlusPlusClusterer" />
  <javadoc>
    <text>Build a clusterer.</text>
    <param>k the number of clusters to split the data into</param>
    <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
    <param>measure the distance measure to use</param>
    <param>random random generator to use for choosing initial centers</param>
    <param>emptyStrategy strategy to use for handling empty clusters that
 * may appear during algorithm iterations</param>
  </javadoc>
  <method type="constructor" name="KMeansPlusPlusClusterer" />
  <javadoc>
    <text>Return the number of clusters this instance will use.</text>
    <return>the number of clusters</return>
  </javadoc>
  <method type="int" name="getK" />
  <javadoc>
    <text>Returns the maximum number of iterations this instance will use.</text>
    <return>the maximum number of iterations, or -1 if no maximum is set</return>
  </javadoc>
  <method type="int" name="getMaxIterations" />
  <javadoc>
    <text>Returns the random generator this instance will use.</text>
    <return>the random generator</return>
  </javadoc>
  <method type="RandomGenerator" name="getRandomGenerator" />
  <javadoc>
    <text>Returns the {@link EmptyClusterStrategy} used by this instance.</text>
    <return>the {@link EmptyClusterStrategy}</return>
  </javadoc>
  <method type="EmptyClusterStrategy" name="getEmptyClusterStrategy" />
  <javadoc>
    <text>Runs the K-means++ clustering algorithm.</text>
    <param>points the points to cluster</param>
    <return>a list of clusters containing the points</return>
    <throws>MathIllegalArgumentException if the data points are null or the number
 * of clusters is larger than the number of data points</throws>
    <throws>ConvergenceException if an empty cluster is encountered and the{@link #emptyStrategy} is set to {@code ERROR}</throws>
  </javadoc>
  <method type="List&lt;CentroidCluster&lt;T&gt;&gt;" name="cluster">
    <scope />
    <declaration type="List&lt;CentroidCluster&lt;T&gt;&gt;" name="clusters" />
    <declaration type="int[]" name="assignments" />
    <declaration type="int" name="max" />
    <scope>
      <declaration type="boolean" name="emptyCluster" />
      <declaration type="List&lt;CentroidCluster&lt;T&gt;&gt;" name="newClusters" />
      <scope>
        <declaration type="Clusterable" name="newCenter" />
        <scope />
        <scope />
      </scope>
      <declaration type="int" name="changes" />
      <scope />
    </scope>
    <comment>sanity checks</comment>
    <comment>number of clusters has to be smaller or equal the number of data points</comment>
    <comment>create the initial clusters</comment>
    <comment>create an array containing the latest assignment of a point to a cluster</comment>
    <comment>no need to initialize the array, as it will be filled with the first assignment</comment>
    <comment>iterate through updating the centers until we're done</comment>
    <comment>if there were no more changes in the point-to-cluster assignment</comment>
    <comment>and there are no empty clusters left, return the current clusters</comment>
  </method>
  <javadoc>
    <text>Adds the given points to the closest {@link Cluster}.</text>
    <param>clusters the {@link Cluster}s to add the points to</param>
    <param>points the points to add to the given {@link Cluster}s</param>
    <param>assignments points assignments to clusters</param>
    <return>the number of points assigned to different clusters as the iteration before</return>
  </javadoc>
  <method type="int" name="assignPointsToClusters">
    <declaration type="int" name="assignedDifferently" />
    <declaration type="int" name="pointIndex" />
    <scope>
      <declaration type="int" name="clusterIndex" />
      <scope />
      <declaration type="CentroidCluster&lt;T&gt;" name="cluster" />
    </scope>
  </method>
  <javadoc>
    <text>Use K-means++ to choose the initial centers.</text>
    <param>points the points to choose the initial centers from</param>
    <return>the initial centers</return>
  </javadoc>
  <method type="List&lt;CentroidCluster&lt;T&gt;&gt;" name="chooseInitialCenters">
    <declaration type="List&lt;T&gt;" name="pointList" />
    <declaration type="int" name="numPoints" />
    <declaration type="boolean[]" name="taken" />
    <declaration type="List&lt;CentroidCluster&lt;T&gt;&gt;" name="resultSet" />
    <declaration type="int" name="firstPointIndex" />
    <declaration type="T" name="firstPoint" />
    <declaration type="double[]" name="minDistSquared" />
    <scope>
      <scope>
        <declaration type="double" name="d" />
      </scope>
    </scope>
    <scope>
      <declaration type="double" name="distSqSum" />
      <scope>
        <scope />
      </scope>
      <declaration type="double" name="r" />
      <declaration type="int" name="nextPointIndex" />
      <declaration type="double" name="sum" />
      <scope>
        <scope>
          <scope />
        </scope>
      </scope>
      <scope>
        <scope>
          <scope />
        </scope>
      </scope>
      <scope>
        <declaration type="T" name="p" />
        <scope>
          <scope>
            <scope>
              <declaration type="double" name="d" />
              <declaration type="double" name="d2" />
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
      <scope />
    </scope>
    <comment>Convert to list for indexed access. Make it unmodifiable, since removal of items</comment>
    <comment>would screw up the logic of this method.</comment>
    <comment>The number of points in the list.</comment>
    <comment>Set the corresponding element in this array to indicate when</comment>
    <comment>elements of pointList are no longer available.</comment>
    <comment>The resulting list of initial centers.</comment>
    <comment>Choose one center uniformly at random from among the data points.</comment>
    <comment>Must mark it as taken</comment>
    <comment>To keep track of the minimum distance squared of elements of</comment>
    <comment>pointList to elements of resultSet.</comment>
    <comment>Initialize the elements.  Since the only point in resultSet is firstPoint,</comment>
    <comment>this is very easy.</comment>
    <comment>That point isn't considered</comment>
    <comment>Sum up the squared distances for the points in pointList not</comment>
    <comment>already taken.</comment>
    <comment>Add one new data point as a center. Each point x is chosen with</comment>
    <comment>probability proportional to D(x)2</comment>
    <comment>The index of the next point to be added to the resultSet.</comment>
    <comment>Sum through the squared min distances again, stopping when</comment>
    <comment>sum &gt;= r.</comment>
    <comment>If it's not set to &gt;= 0, the point wasn't found in the previous</comment>
    <comment>for loop, probably because distances are extremely small.  Just pick</comment>
    <comment>the last available point.</comment>
    <comment>We found one.</comment>
    <comment>Mark it as taken.</comment>
    <comment>Now update elements of minDistSquared.  We only have to compute</comment>
    <comment>the distance to the new center to do this.</comment>
    <comment>Only have to worry about the points still not taken.</comment>
    <comment>None found --</comment>
    <comment>Break from the while loop to prevent</comment>
    <comment>an infinite loop.</comment>
  </method>
  <javadoc>
    <text>Get a random point from the {@link Cluster} with the largest distance variance.</text>
    <param>clusters the {@link Cluster}s to search</param>
    <return>a random point from the selected cluster</return>
    <throws>ConvergenceException if clusters are all empty</throws>
  </javadoc>
  <method type="T" name="getPointFromLargestVarianceCluster">
    <declaration type="double" name="maxVariance" />
    <declaration type="Cluster&lt;T&gt;" name="selected" />
    <scope>
      <scope>
        <declaration type="Clusterable" name="center" />
        <declaration type="Variance" name="stat" />
        <scope />
        <declaration type="double" name="variance" />
        <scope />
      </scope>
    </scope>
    <scope />
    <declaration type="List&lt;T&gt;" name="selectedPoints" />
    <comment>compute the distance variance of the current cluster</comment>
    <comment>select the cluster with the largest variance</comment>
    <comment>did we find at least one non-empty cluster ?</comment>
    <comment>extract a random point from the cluster</comment>
  </method>
  <javadoc>
    <text>Get a random point from the {@link Cluster} with the largest number of points</text>
    <param>clusters the {@link Cluster}s to search</param>
    <return>a random point from the selected cluster</return>
    <throws>ConvergenceException if clusters are all empty</throws>
  </javadoc>
  <method type="T" name="getPointFromLargestNumberCluster">
    <declaration type="int" name="maxNumber" />
    <declaration type="Cluster&lt;T&gt;" name="selected" />
    <scope>
      <declaration type="int" name="number" />
      <scope />
    </scope>
    <scope />
    <declaration type="List&lt;T&gt;" name="selectedPoints" />
    <comment>get the number of points of the current cluster</comment>
    <comment>select the cluster with the largest number of points</comment>
    <comment>did we find at least one non-empty cluster ?</comment>
    <comment>extract a random point from the cluster</comment>
  </method>
  <javadoc>
    <text>Get the point farthest to its cluster center</text>
    <param>clusters the {@link Cluster}s to search</param>
    <return>point farthest to its cluster center</return>
    <throws>ConvergenceException if clusters are all empty</throws>
  </javadoc>
  <method type="T" name="getFarthestPoint">
    <declaration type="double" name="maxDistance" />
    <declaration type="Cluster&lt;T&gt;" name="selectedCluster" />
    <declaration type="int" name="selectedPoint" />
    <scope>
      <declaration type="Clusterable" name="center" />
      <declaration type="List&lt;T&gt;" name="points" />
      <scope>
        <declaration type="double" name="distance" />
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>get the farthest point</comment>
    <comment>did we find at least one non-empty cluster ?</comment>
  </method>
  <javadoc>
    <text>Returns the nearest {@link Cluster} to the given point</text>
    <param>clusters the {@link Cluster}s to search</param>
    <param>point the point to find the nearest {@link Cluster} for</param>
    <return>the index of the nearest {@link Cluster} to the given point</return>
  </javadoc>
  <method type="int" name="getNearestCluster">
    <declaration type="double" name="minDistance" />
    <declaration type="int" name="clusterIndex" />
    <declaration type="int" name="minCluster" />
    <scope>
      <declaration type="double" name="distance" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Computes the centroid for a set of points.</text>
    <param>points the set of points</param>
    <param>dimension the point dimension</param>
    <return>the computed centroid for the set of points</return>
  </javadoc>
  <method type="Clusterable" name="centroidOf">
    <declaration type="double[]" name="centroid" />
    <scope>
      <declaration type="double[]" name="point" />
      <scope />
    </scope>
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
