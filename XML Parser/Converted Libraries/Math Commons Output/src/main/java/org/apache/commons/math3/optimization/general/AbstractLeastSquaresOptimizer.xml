<?xml version="1.0" encoding="UTF-8"?>
<class name="AbstractLeastSquaresOptimizer">
  <javadoc>
    <text>Base class for implementing least squares optimizers.
 * It handles the boilerplate methods associated to thresholds settings,
 * Jacobian and error estimation.
 * &lt;br/&gt;
 * This class constructs the Jacobian matrix of the function argument in method{@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])optimize} and assumes that the rows of that matrix iterate on the model
 * functions while the columns iterate on the parameters; thus, the numbers
 * of rows is equal to the dimension of the{@link org.apache.commons.math3.optimization.Target Target} while
 * the number of columns is equal to the dimension of the{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}.</text>
    <version>$Id: AbstractLeastSquaresOptimizer.java 1426759 2012-12-29 13:26:44Z erans $</version>
    <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Singularity threshold (cf. {@link #getCovariances(double)}).</text>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <declaration type="double" name="DEFAULT_SINGULARITY_THRESHOLD" />
  <javadoc>
    <text>Jacobian matrix of the weighted residuals.
 * This matrix is in canonical form just after the calls to{@link #updateJacobian()}, but may be modified by the solver
 * in the derived class (the {@link LevenbergMarquardtOptimizerLevenberg-Marquardt optimizer} does this).</text>
    <deprecated>As of 3.1. To be removed in 4.0. Please use{@link #computeWeightedJacobian(double[])} instead.</deprecated>
  </javadoc>
  <declaration type="double[][]" name="weightedResidualJacobian" />
  <javadoc>
    <text>Number of columns of the jacobian matrix.</text>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <declaration type="int" name="cols" />
  <javadoc>
    <text>Number of rows of the jacobian matrix.</text>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <declaration type="int" name="rows" />
  <javadoc>
    <text>Current point.</text>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <declaration type="double[]" name="point" />
  <javadoc>
    <text>Current objective function value.</text>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <declaration type="double[]" name="objective" />
  <javadoc>
    <text>Weighted residuals</text>
    <deprecated>As of 3.1.</deprecated>
  </javadoc>
  <declaration type="double[]" name="weightedResiduals" />
  <javadoc>
    <text>Cost value (square root of the sum of the residuals).</text>
    <deprecated>As of 3.1. Field to become "private" in 4.0.
 * Please use {@link #setCost(double)}.</deprecated>
  </javadoc>
  <declaration type="double" name="cost" />
  <javadoc>
    <text>Objective function derivatives.</text>
  </javadoc>
  <declaration type="MultivariateDifferentiableVectorFunction" name="jF" />
  <javadoc>
    <text>Number of evaluations of the Jacobian.</text>
  </javadoc>
  <declaration type="int" name="jacobianEvaluations" />
  <javadoc>
    <text>Square-root of the weight matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="weightMatrixSqrt" />
  <javadoc>
    <text>Simple constructor with default settings.
 * The convergence check is set to a {@link org.apache.commons.math3.optimization.SimpleVectorValueChecker}.</text>
    <deprecated>See {@link org.apache.commons.math3.optimization.SimpleValueChecker#SimpleValueChecker()}</deprecated>
  </javadoc>
  <method type="constructor" name="AbstractLeastSquaresOptimizer" />
  <javadoc>
    <param>checker Convergence checker.</param>
  </javadoc>
  <method type="constructor" name="AbstractLeastSquaresOptimizer" />
  <javadoc>
    <return>the number of evaluations of the Jacobian function.</return>
  </javadoc>
  <method type="int" name="getJacobianEvaluations" />
  <javadoc>
    <text>Update the jacobian matrix.</text>
    <throws>DimensionMismatchException if the Jacobian dimension does not
 * match problem dimension.</throws>
    <deprecated>As of 3.1. Please use {@link #computeWeightedJacobian(double[])}instead.</deprecated>
  </javadoc>
  <method type="void" name="updateJacobian">
    <declaration type="RealMatrix" name="weightedJacobian" />
  </method>
  <javadoc>
    <text>Computes the Jacobian matrix.</text>
    <param>params Model parameters at which to compute the Jacobian.</param>
    <return>the weighted Jacobian: W&lt;sup&gt;1/2&lt;/sup&gt; J.</return>
    <throws>DimensionMismatchException if the Jacobian dimension does not
 * match problem dimension.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="RealMatrix" name="computeWeightedJacobian">
    <declaration type="DerivativeStructure[]" name="dsPoint" />
    <declaration type="int" name="nC" />
    <scope />
    <declaration type="DerivativeStructure[]" name="dsValue" />
    <declaration type="int" name="nR" />
    <scope />
    <declaration type="double[][]" name="jacobianData" />
    <scope>
      <declaration type="int[]" name="orders" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Update the residuals array and cost function value.</text>
    <throws>DimensionMismatchException if the dimension does not match the
 * problem dimension.</throws>
    <throws>org.apache.commons.math3.exception.TooManyEvaluationsExceptionif the maximal number of evaluations is exceeded.</throws>
    <deprecated>As of 3.1. Please use {@link #computeResiduals(double[])},{@link #computeObjectiveValue(double[])}, {@link #computeCost(double[])}and {@link #setCost(double)} instead.</deprecated>
  </javadoc>
  <method type="void" name="updateResidualsAndCost">
    <declaration type="double[]" name="res" />
    <declaration type="ArrayRealVector" name="residuals" />
    <comment>Compute cost.</comment>
    <comment>Compute weighted residuals.</comment>
  </method>
  <javadoc>
    <text>Computes the cost.</text>
    <param>residuals Residuals.</param>
    <return>the cost.</return>
    <see>#computeResiduals(double[])</see>
    <since>3.1</since>
  </javadoc>
  <method type="double" name="computeCost">
    <declaration type="ArrayRealVector" name="r" />
  </method>
  <javadoc>
    <text>Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * &lt;em&gt;c&lt;/em&gt; if the criterion, and &lt;em&gt;n&lt;/em&gt; is the number of
 * measurements, then the RMS is &lt;em&gt;sqrt (c/n)&lt;/em&gt;.</text>
    <return>RMS value</return>
  </javadoc>
  <method type="double" name="getRMS" />
  <javadoc>
    <text>Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.</text>
    <return>chi-square value</return>
  </javadoc>
  <method type="double" name="getChiSquare" />
  <javadoc>
    <text>Gets the square-root of the weight matrix.</text>
    <return>the square-root of the weight matrix.</return>
    <since>3.1</since>
  </javadoc>
  <method type="RealMatrix" name="getWeightSquareRoot" />
  <javadoc>
    <text>Sets the cost.</text>
    <param>cost Cost value.</param>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="setCost" />
  <javadoc>
    <text>Get the covariance matrix of the optimized parameters.</text>
    <return>the covariance matrix.</return>
    <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed (singular problem).</throws>
    <see>#getCovariances(double)</see>
    <deprecated>As of 3.1. Please use {@link #computeCovariances(double[],double)}instead.</deprecated>
  </javadoc>
  <method type="double[][]" name="getCovariances" />
  <javadoc>
    <text>Get the covariance matrix of the optimized parameters.
 * &lt;br/&gt;
 * Note that this operation involves the inversion of the
 * &lt;code&gt;J&lt;sup&gt;T&lt;/sup&gt;J&lt;/code&gt; matrix, where {@code J} is the
 * Jacobian matrix.
 * The {@code threshold} parameter is a way for the caller to specify
 * that the result of this computation should be considered meaningless,
 * and thus trigger an exception.</text>
    <param>threshold Singularity threshold.</param>
    <return>the covariance matrix.</return>
    <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed (singular problem).</throws>
    <deprecated>As of 3.1. Please use {@link #computeCovariances(double[],double)}instead.</deprecated>
  </javadoc>
  <method type="double[][]" name="getCovariances" />
  <javadoc>
    <text>Get the covariance matrix of the optimized parameters.
 * &lt;br/&gt;
 * Note that this operation involves the inversion of the
 * &lt;code&gt;J&lt;sup&gt;T&lt;/sup&gt;J&lt;/code&gt; matrix, where {@code J} is the
 * Jacobian matrix.
 * The {@code threshold} parameter is a way for the caller to specify
 * that the result of this computation should be considered meaningless,
 * and thus trigger an exception.</text>
    <param>params Model parameters.</param>
    <param>threshold Singularity threshold.</param>
    <return>the covariance matrix.</return>
    <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed (singular problem).</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[][]" name="computeCovariances">
    <declaration type="RealMatrix" name="j" />
    <declaration type="RealMatrix" name="jTj" />
    <declaration type="DecompositionSolver" name="solver" />
    <comment>Set up the Jacobian.</comment>
    <comment>Compute transpose(J)J.</comment>
    <comment>Compute the covariances matrix.</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns an estimate of the standard deviation of each parameter. The
 * returned values are the so-called (asymptotic) standard errors on the
 * parameters, defined as {@code sd(a[i]) = sqrt(S / (n - m) * C[i][i])},
 * where {@code a[i]} is the optimized value of the {@code i}-th parameter,{@code S} is the minimized value of the sum of squares objective function
 * (as returned by {@link #getChiSquare()}), {@code n} is the number of
 * observations, {@code m} is the number of parameters and {@code C} is the
 * covariance matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * See also
 * &lt;a href="http://en.wikipedia.org/wiki/Least_squares"&gt;Wikipedia&lt;/a&gt;,
 * or
 * &lt;a href="http://mathworld.wolfram.com/LeastSquaresFitting.html"&gt;MathWorld&lt;/a&gt;,
 * equations (34) and (35) for a particular case.
 * &lt;/p&gt;</text>
    <return>an estimate of the standard deviation of the optimized parameters</return>
    <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed.</throws>
    <throws>NumberIsTooSmallException if the number of degrees of freedom is not
 * positive, i.e. the number of measurements is less or equal to the number of
 * parameters.</throws>
    <deprecated>as of version 3.1, {@link #computeSigma(double[],double)} should be used
 * instead. It should be emphasized that {@code guessParametersErrors} and{@code computeSigma} are &lt;em&gt;not&lt;/em&gt; strictly equivalent.</deprecated>
  </javadoc>
  <method type="double[]" name="guessParametersErrors">
    <scope />
    <declaration type="double[]" name="errors" />
    <declaration type="double" name="c" />
    <declaration type="double[][]" name="covar" />
    <scope />
  </method>
  <javadoc>
    <text>Computes an estimate of the standard deviation of the parameters. The
 * returned values are the square root of the diagonal coefficients of the
 * covariance matrix, {@code sd(a[i]) ~= sqrt(C[i][i])}, where {@code a[i]}is the optimized value of the {@code i}-th parameter, and {@code C} is
 * the covariance matrix.</text>
    <param>params Model parameters.</param>
    <param>covarianceSingularityThreshold Singularity threshold (see{@link #computeCovariances(double[],double) computeCovariances}).</param>
    <return>an estimate of the standard deviation of the optimized parameters</return>
    <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="computeSigma">
    <declaration type="int" name="nC" />
    <declaration type="double[]" name="sig" />
    <declaration type="double[][]" name="cov" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
    <deprecated>As of 3.1. Please use{@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}instead.</deprecated>
  </javadoc>
  <method type="PointVectorValuePair" name="optimize" />
  <javadoc>
    <text>Optimize an objective function.
 * Optimization is considered to be a weighted least-squares minimization.
 * The cost function to be minimized is
 * &lt;code&gt;&amp;sum;weight&lt;sub&gt;i&lt;/sub&gt;(objective&lt;sub&gt;i&lt;/sub&gt; - target&lt;sub&gt;i&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;&lt;/code&gt;</text>
    <param>f Objective function.</param>
    <param>target Target value for the objective functions at optimum.</param>
    <param>weights Weights for the least squares cost computation.</param>
    <param>startPoint Start point for optimization.</param>
    <return>the point/value pair giving the optimal value for objective
 * function.</return>
    <param>maxEval Maximum number of function evaluations.</param>
    <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the start point dimension is wrong.</throws>
    <throws>org.apache.commons.math3.exception.TooManyEvaluationsExceptionif the maximal number of evaluations is exceeded.</throws>
    <throws>org.apache.commons.math3.exception.NullArgumentException if
 * any argument is {@code null}.</throws>
    <deprecated>As of 3.1. Please use{@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}instead.</deprecated>
  </javadoc>
  <method type="PointVectorValuePair" name="optimize" />
  <javadoc>
    <text>Optimize an objective function.
 * Optimization is considered to be a weighted least-squares minimization.
 * The cost function to be minimized is
 * &lt;code&gt;&amp;sum;weight&lt;sub&gt;i&lt;/sub&gt;(objective&lt;sub&gt;i&lt;/sub&gt; - target&lt;sub&gt;i&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;&lt;/code&gt;</text>
    <param>maxEval Allowed number of evaluations of the objective function.</param>
    <param>f Objective function.</param>
    <param>optData Optimization data. The following data will be looked for:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Target}&lt;/li&gt;
 * &lt;li&gt;{@link Weight}&lt;/li&gt;
 * &lt;li&gt;{@link InitialGuess}&lt;/li&gt;
 * &lt;/ul&gt;</param>
    <return>the point/value pair giving the optimal value of the objective
 * function.</return>
    <throws>org.apache.commons.math3.exception.TooManyEvaluationsException if
 * the maximal number of evaluations is exceeded.</throws>
    <throws>DimensionMismatchException if the target, and weight arguments
 * have inconsistent dimensions.</throws>
    <see>BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])</see>
    <since>3.1</since>
    <deprecated>As of 3.1. Override is necessary only until this class's generic
 * argument is changed to {@code MultivariateDifferentiableVectorFunction}.</deprecated>
  </javadoc>
  <method type="PointVectorValuePair" name="optimizeInternal">
    <comment>XXX Conversion will be removed when the generic argument of the</comment>
    <comment>base class becomes "MultivariateDifferentiableVectorFunction".</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setUp">
    <comment>Reset counter.</comment>
    <comment>Square-root of the weight matrix.</comment>
    <comment>Store least squares problem characteristics.</comment>
    <comment>XXX The conversion won't be necessary when the generic argument of</comment>
    <comment>the base class becomes "MultivariateDifferentiableVectorFunction".</comment>
    <comment>XXX "jF" is not strictly necessary anymore but is currently more</comment>
    <comment>efficient than converting the value returned from "getObjectiveFunction()"</comment>
    <comment>every time it is used.</comment>
    <comment>Arrays shared with "private" and "protected" methods.</comment>
  </method>
  <javadoc>
    <text>Computes the residuals.
 * The residual is the difference between the observed (target)
 * values and the model (objective function) value.
 * There is one residual for each element of the vector-valued
 * function.</text>
    <param>objectiveValue Value of the the objective function. This is
 * the value returned from a call to{@link #computeObjectiveValue(double[]) computeObjectiveValue}(whose array argument contains the model parameters).</param>
    <return>the residuals.</return>
    <throws>DimensionMismatchException if {@code params} has a wrong
 * length.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="computeResiduals">
    <declaration type="double[]" name="target" />
    <scope />
    <declaration type="double[]" name="residuals" />
    <scope />
  </method>
  <javadoc>
    <text>Computes the square-root of the weight matrix.</text>
    <param>m Symmetric, positive-definite (weight) matrix.</param>
    <return>the square-root of the weight matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="squareRoot">
    <scope>
      <declaration type="int" name="dim" />
      <declaration type="RealMatrix" name="sqrtM" />
      <scope />
    </scope>
    <scope>
      <declaration type="EigenDecomposition" name="dec" />
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
