<?xml version="1.0" encoding="UTF-8"?>
<class name="RandomDataGenerator">
  <javadoc>
    <text>Implements the {@link RandomData} interface using a {@link RandomGenerator}instance to generate non-secure data and a {@link java.security.SecureRandom}instance to provide data for the &lt;code&gt;nextSecureXxx&lt;/code&gt; methods. If no
 * &lt;code&gt;RandomGenerator&lt;/code&gt; is provided in the constructor, the default is
 * to use a {@link Well19937c} generator. To plug in a different
 * implementation, either implement &lt;code&gt;RandomGenerator&lt;/code&gt; directly or
 * extend {@link AbstractRandomGenerator}.
 * &lt;p&gt;
 * Supports reseeding the underlying pseudo-random number generator (PRNG). The
 * &lt;code&gt;SecurityProvider&lt;/code&gt; and &lt;code&gt;Algorithm&lt;/code&gt; used by the
 * &lt;code&gt;SecureRandom&lt;/code&gt; instance can also be reset.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For details on the default PRNGs, see {@link java.util.Random} and{@link java.security.SecureRandom}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Usage Notes&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Instance variables are used to maintain &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances used in data generation. Therefore, to
 * generate a random sequence of values or strings, you should use just
 * &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;RandomDataImpl&lt;/code&gt; instance repeatedly.&lt;/li&gt;
 * &lt;li&gt;
 * The "secure" methods are *much* slower. These should be used only when a
 * cryptographically secure random sequence is required. A secure random
 * sequence is a sequence of pseudo-random values which, in addition to being
 * well-dispersed (so no subsequence of values is an any more likely than other
 * subsequence of the the same length), also has the additional property that
 * knowledge of values generated up to any point in the sequence does not make
 * it any easier to predict subsequent values.&lt;/li&gt;
 * &lt;li&gt;
 * When a new &lt;code&gt;RandomDataImpl&lt;/code&gt; is created, the underlying random
 * number generators are &lt;strong&gt;not&lt;/strong&gt; initialized. If you do not
 * explicitly seed the default non-secure generator, it is seeded with the
 * current time in milliseconds plus the system identity hash code on first use.
 * The same holds for the secure generator. If you provide a &lt;code&gt;RandomGenerator&lt;/code&gt;
 * to the constructor, however, this generator is not reseeded by the constructor
 * nor is it reseeded on first use.&lt;/li&gt;
 * &lt;li&gt;
 * The &lt;code&gt;reSeed&lt;/code&gt; and &lt;code&gt;reSeedSecure&lt;/code&gt; methods delegate to the
 * corresponding methods on the underlying &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances. Therefore, &lt;code&gt;reSeed(long)&lt;/code&gt;
 * fully resets the initial state of the non-secure random number generator (so
 * that reseeding with a specific value always results in the same subsequent
 * random sequence); whereas reSeedSecure(long) does &lt;strong&gt;not&lt;/strong&gt;
 * reinitialize the secure random number generator (so secure sequences started
 * with calls to reseedSecure(long) won't be identical).&lt;/li&gt;
 * &lt;li&gt;
 * This implementation is not synchronized. The underlying &lt;code&gt;RandomGenerator&lt;/code&gt;
 * or &lt;code&gt;SecureRandom&lt;/code&gt; instances are not protected by synchronization and
 * are not guaranteed to be thread-safe.  Therefore, if an instance of this class
 * is concurrently utilized by multiple threads, it is the responsibility of
 * client code to synchronize access to seeding and data generation methods.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;</text>
    <since>3.1</since>
    <version>$Id: RandomDataGenerator.java 1462423 2013-03-29 07:25:18Z luc $</version>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>underlying random number generator</text>
  </javadoc>
  <declaration type="RandomGenerator" name="rand" />
  <javadoc>
    <text>underlying secure random number generator</text>
  </javadoc>
  <declaration type="SecureRandom" name="secRand" />
  <javadoc>
    <text>Construct a RandomDataGenerator, using a default random generator as the source
 * of randomness.
 * &lt;p&gt;The default generator is a {@link Well19937c} seeded
 * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.
 * The generator is initialized and seeded on first use.&lt;/p&gt;</text>
  </javadoc>
  <method type="constructor" name="RandomDataGenerator" />
  <javadoc>
    <text>Construct a RandomDataGenerator using the supplied {@link RandomGenerator} as
 * the source of (non-secure) random data.</text>
    <param>rand the source of (non-secure) random data
 * (may be null, resulting in the default generator)</param>
  </javadoc>
  <method type="constructor" name="RandomDataGenerator" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated using a
 * 2-step process.
 * &lt;ol&gt;
 * &lt;li&gt;{@code len / 2 + 1} binary bytes are generated using the underlying
 * Random&lt;/li&gt;
 * &lt;li&gt;Each binary byte is translated into 2 hex digits&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;</text>
    <param>len the desired string length.</param>
    <return>the random string.</return>
    <throws>NotStrictlyPositiveException if {@code len &lt;= 0}.</throws>
  </javadoc>
  <method type="String" name="nextHexString">
    <scope />
    <declaration type="RandomGenerator" name="ran" />
    <declaration type="StringBuilder" name="outBuffer" />
    <declaration type="byte[]" name="randomBytes" />
    <scope>
      <declaration type="Integer" name="c" />
      <declaration type="String" name="hex" />
      <scope />
    </scope>
    <comment>Get a random number generator</comment>
    <comment>Initialize output buffer</comment>
    <comment>Get int(len/2)+1 random bytes</comment>
    <comment>Convert each byte to 2 hex digits</comment>
    <comment>Add 128 to byte value to make interval 0-255 before doing hex
 conversion. This guarantees &lt;= 2 hex digits from toHexString()
 toHexString would otherwise add 2^32 to negative arguments.</comment>
    <comment>Make sure we add 2 hex digits for each byte</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="nextInt">
    <scope />
    <declaration type="int" name="max" />
    <scope>
      <declaration type="RandomGenerator" name="rng" />
      <scope>
        <declaration type="int" name="r" />
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>the range is too wide to fit in a positive int (larger than 2^31); as it covers</comment>
    <comment>more than half the integer range, we use directly a simple rejection method</comment>
    <comment>we can shift the range and generate directly a positive int</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="long" name="nextLong">
    <scope />
    <declaration type="long" name="max" />
    <scope>
      <declaration type="RandomGenerator" name="rng" />
      <scope>
        <declaration type="long" name="r" />
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <comment>the range is too wide to fit in a positive long (larger than 2^63); as it covers</comment>
    <comment>more than half the long range, we use directly a simple rejection method</comment>
    <comment>we can shift the range and generate directly a positive int</comment>
    <comment>we can shift the range and generate directly a positive long</comment>
  </method>
  <javadoc>
    <text>Returns a pseudorandom, uniformly distributed &lt;tt&gt;long&lt;/tt&gt; value
 * between 0 (inclusive) and the specified value (exclusive), drawn from
 * this random number generator's sequence.</text>
    <param>rng random generator to use</param>
    <param>n the bound on the random number to be returned.  Must be
 * positive.</param>
    <return>a pseudorandom, uniformly distributed &lt;tt&gt;long&lt;/tt&gt;
 * value between 0 (inclusive) and n (exclusive).</return>
    <throws>IllegalArgumentException  if n is not positive.</throws>
  </javadoc>
  <method type="long" name="nextLong">
    <scope>
      <declaration type="byte[]" name="byteArray" />
      <declaration type="long" name="bits" />
      <declaration type="long" name="val" />
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated in
 * 40-byte segments using a 3-step process.
 * &lt;ol&gt;
 * &lt;li&gt;
 * 20 random bytes are generated using the underlying
 * &lt;code&gt;SecureRandom&lt;/code&gt;.&lt;/li&gt;
 * &lt;li&gt;
 * SHA-1 hash is applied to yield a 20-byte binary digest.&lt;/li&gt;
 * &lt;li&gt;
 * Each byte of the binary digest is converted to 2 hex digits.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;</text>
    <throws>NotStrictlyPositiveException if {@code len &lt;= 0}</throws>
  </javadoc>
  <method type="String" name="nextSecureHexString">
    <scope />
    <declaration type="SecureRandom" name="secRan" />
    <declaration type="MessageDigest" name="alg" />
    <scope />
    <scope />
    <declaration type="int" name="numIter" />
    <declaration type="StringBuilder" name="outBuffer" />
    <scope>
      <declaration type="byte[]" name="randomBytes" />
      <declaration type="byte[]" name="hash" />
      <scope>
        <declaration type="Integer" name="c" />
        <declaration type="String" name="hex" />
        <scope />
      </scope>
    </scope>
    <comment>Get SecureRandom and setup Digest provider</comment>
    <comment>this should never happen</comment>
    <comment>Compute number of iterations required (40 bytes each)</comment>
    <comment>Compute hash -- will create 20-byte binary hash</comment>
    <comment>Loop over the hash, converting each byte to 2 hex digits</comment>
    <comment>Add 128 to byte value to make interval 0-255 This guarantees
 &lt;= 2 hex digits from toHexString() toHexString would
 otherwise add 2^32 to negative arguments</comment>
    <comment>Keep strings uniform length -- guarantees 40 bytes</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="nextSecureInt">
    <scope />
    <declaration type="int" name="max" />
    <scope>
      <declaration type="SecureRandom" name="rng" />
      <scope>
        <declaration type="int" name="r" />
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>the range is too wide to fit in a positive int (larger than 2^31); as it covers</comment>
    <comment>more than half the integer range, we use directly a simple rejection method</comment>
    <comment>we can shift the range and generate directly a positive int</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="long" name="nextSecureLong">
    <scope />
    <declaration type="long" name="max" />
    <scope>
      <declaration type="SecureRandom" name="rng" />
      <scope>
        <declaration type="long" name="r" />
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <comment>the range is too wide to fit in a positive long (larger than 2^63); as it covers</comment>
    <comment>more than half the long range, we use directly a simple rejection method</comment>
    <comment>we can shift the range and generate directly a positive int</comment>
    <comment>we can shift the range and generate directly a positive long</comment>
  </method>
  <javadoc>
    <text>Returns a pseudorandom, uniformly distributed &lt;tt&gt;long&lt;/tt&gt; value
 * between 0 (inclusive) and the specified value (exclusive), drawn from
 * this random number generator's sequence.</text>
    <param>rng random generator to use</param>
    <param>n the bound on the random number to be returned.  Must be
 * positive.</param>
    <return>a pseudorandom, uniformly distributed &lt;tt&gt;long&lt;/tt&gt;
 * value between 0 (inclusive) and n (exclusive).</return>
    <throws>IllegalArgumentException  if n is not positive.</throws>
  </javadoc>
  <method type="long" name="nextLong">
    <scope>
      <declaration type="byte[]" name="byteArray" />
      <declaration type="long" name="bits" />
      <declaration type="long" name="val" />
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;:
 * &lt;ul&gt;&lt;li&gt; For small means, uses simulation of a Poisson process
 * using Uniform deviates, as described
 * &lt;a href="http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm"&gt; here.&lt;/a&gt;
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.&lt;/li&gt;
 * &lt;li&gt; For large means, uses the rejection algorithm described in &lt;br/&gt;
 * Devroye, Luc. (1981).&lt;i&gt;The Computer Generation of Poisson Random Variables&lt;/i&gt;
 * &lt;strong&gt;Computing&lt;/strong&gt; vol. 26 pp. 197-207.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;</text>
    <throws>NotStrictlyPositiveException if {@code len &lt;= 0}</throws>
  </javadoc>
  <method type="long" name="nextPoisson" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="nextGaussian">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses the Algorithm SA (Ahrens)
 * from p. 876 in:
 * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for
 * sampling from the exponential and normal distributions.
 * Communications of the ACM, 15, 873-882.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="double" name="nextExponential" />
  <javadoc>
    <text>&lt;p&gt;Generates a random value from the{@link org.apache.commons.math3.distribution.GammaDistribution Gamma Distribution}.&lt;/p&gt;
 * &lt;p&gt;This implementation uses the following algorithms: &lt;/p&gt;
 * &lt;p&gt;For 0 &lt; shape &lt; 1: &lt;br/&gt;
 * Ahrens, J. H. and Dieter, U., &lt;i&gt;Computer methods for
 * sampling from gamma, beta, Poisson and binomial distributions.&lt;/i&gt;
 * Computing, 12, 223-246, 1974.&lt;/p&gt;
 * &lt;p&gt;For shape &gt;= 1: &lt;br/&gt;
 * Marsaglia and Tsang, &lt;i&gt;A Simple Method for Generating
 * Gamma Variables.&lt;/i&gt; ACM Transactions on Mathematical Software,
 * Volume 26 Issue 3, September, 2000.&lt;/p&gt;</text>
    <param>shape the median of the Gamma distribution</param>
    <param>scale the scale parameter of the Gamma distribution</param>
    <return>random value sampled from the Gamma(shape, scale) distribution</return>
    <throws>NotStrictlyPositiveException if {@code shape &lt;= 0} or{@code scale &lt;= 0}.</throws>
  </javadoc>
  <method type="double" name="nextGamma" />
  <javadoc>
    <text>Generates a random value from the {@link HypergeometricDistribution Hypergeometric Distribution}.</text>
    <param>populationSize the population size of the Hypergeometric distribution</param>
    <param>numberOfSuccesses number of successes in the population of the Hypergeometric distribution</param>
    <param>sampleSize the sample size of the Hypergeometric distribution</param>
    <return>random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution</return>
    <throws>NumberIsTooLargeException  if {@code numberOfSuccesses &gt; populationSize},
 * or {@code sampleSize &gt; populationSize}.</throws>
    <throws>NotStrictlyPositiveException if {@code populationSize &lt;= 0}.</throws>
    <throws>NotPositiveException  if {@code numberOfSuccesses &lt; 0}.</throws>
  </javadoc>
  <method type="int" name="nextHypergeometric" />
  <javadoc>
    <text>Generates a random value from the {@link PascalDistribution Pascal Distribution}.</text>
    <param>r the number of successes of the Pascal distribution</param>
    <param>p the probability of success of the Pascal distribution</param>
    <return>random value sampled from the Pascal(r, p) distribution</return>
    <throws>NotStrictlyPositiveException if the number of successes is not positive</throws>
    <throws>OutOfRangeException if the probability of success is not in the
 * range {@code [0, 1]}.</throws>
  </javadoc>
  <method type="int" name="nextPascal" />
  <javadoc>
    <text>Generates a random value from the {@link TDistribution T Distribution}.</text>
    <param>df the degrees of freedom of the T distribution</param>
    <return>random value from the T(df) distribution</return>
    <throws>NotStrictlyPositiveException if {@code df &lt;= 0}</throws>
  </javadoc>
  <method type="double" name="nextT" />
  <javadoc>
    <text>Generates a random value from the {@link WeibullDistribution Weibull Distribution}.</text>
    <param>shape the shape parameter of the Weibull distribution</param>
    <param>scale the scale parameter of the Weibull distribution</param>
    <return>random value sampled from the Weibull(shape, size) distribution</return>
    <throws>NotStrictlyPositiveException if {@code shape &lt;= 0} or{@code scale &lt;= 0}.</throws>
  </javadoc>
  <method type="double" name="nextWeibull" />
  <javadoc>
    <text>Generates a random value from the {@link ZipfDistribution Zipf Distribution}.</text>
    <param>numberOfElements the number of elements of the ZipfDistribution</param>
    <param>exponent the exponent of the ZipfDistribution</param>
    <return>random value sampled from the Zipf(numberOfElements, exponent) distribution</return>
    <exception>NotStrictlyPositiveException if {@code numberOfElements &lt;= 0}or {@code exponent &lt;= 0}.</exception>
  </javadoc>
  <method type="int" name="nextZipf" />
  <javadoc>
    <text>Generates a random value from the {@link BetaDistribution Beta Distribution}.</text>
    <param>alpha first distribution shape parameter</param>
    <param>beta second distribution shape parameter</param>
    <return>random value sampled from the beta(alpha, beta) distribution</return>
  </javadoc>
  <method type="double" name="nextBeta" />
  <javadoc>
    <text>Generates a random value from the {@link BinomialDistribution Binomial Distribution}.</text>
    <param>numberOfTrials number of trials of the Binomial distribution</param>
    <param>probabilityOfSuccess probability of success of the Binomial distribution</param>
    <return>random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution</return>
  </javadoc>
  <method type="int" name="nextBinomial" />
  <javadoc>
    <text>Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.</text>
    <param>median the median of the Cauchy distribution</param>
    <param>scale the scale parameter of the Cauchy distribution</param>
    <return>random value sampled from the Cauchy(median, scale) distribution</return>
  </javadoc>
  <method type="double" name="nextCauchy" />
  <javadoc>
    <text>Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.</text>
    <param>df the degrees of freedom of the ChiSquare distribution</param>
    <return>random value sampled from the ChiSquare(df) distribution</return>
  </javadoc>
  <method type="double" name="nextChiSquare" />
  <javadoc>
    <text>Generates a random value from the {@link FDistribution F Distribution}.</text>
    <param>numeratorDf the numerator degrees of freedom of the F distribution</param>
    <param>denominatorDf the denominator degrees of freedom of the F distribution</param>
    <return>random value sampled from the F(numeratorDf, denominatorDf) distribution</return>
    <throws>NotStrictlyPositiveException if{@code numeratorDf &lt;= 0} or {@code denominatorDf &lt;= 0}.</throws>
  </javadoc>
  <method type="double" name="nextF" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: scales the output of
 * Random.nextDouble(), but rejects 0 values (i.e., will generate another
 * random double if Random.nextDouble() returns 0). This is necessary to
 * provide a symmetric output interval (both endpoints excluded).
 * &lt;/p&gt;</text>
    <throws>NumberIsTooLargeException if {@code lower &gt;= upper}</throws>
    <throws>NotFiniteNumberException if one of the bounds is infinite</throws>
    <throws>NotANumberException if one of the bounds is NaN</throws>
  </javadoc>
  <method type="double" name="nextUniform" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: if the lower bound is excluded,
 * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,
 * will generate another random double if Random.nextDouble() returns 0).
 * This is necessary to provide a symmetric output interval (both
 * endpoints excluded).
 * &lt;/p&gt;</text>
    <throws>NumberIsTooLargeException if {@code lower &gt;= upper}</throws>
    <throws>NotFiniteNumberException if one of the bounds is infinite</throws>
    <throws>NotANumberException if one of the bounds is NaN</throws>
  </javadoc>
  <method type="double" name="nextUniform">
    <scope />
    <scope />
    <scope />
    <scope />
    <declaration type="RandomGenerator" name="generator" />
    <declaration type="double" name="u" />
    <scope />
    <comment>ensure nextDouble() isn't 0.0</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * Uses a 2-cycle permutation shuffle. The shuffling process is described &lt;a
 * href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html"&gt;
 * here&lt;/a&gt;.
 * &lt;/p&gt;</text>
    <throws>NumberIsTooLargeException if {@code k &gt; n}.</throws>
    <throws>NotStrictlyPositiveException if {@code k &lt;= 0}.</throws>
  </javadoc>
  <method type="int[]" name="nextPermutation">
    <scope />
    <scope />
    <declaration type="int[]" name="index" />
    <declaration type="int[]" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses a 2-cycle permutation
 * shuffle to generate a random permutation of &lt;code&gt;c.size()&lt;/code&gt; and
 * then returns the elements whose indexes correspond to the elements of the
 * generated permutation. This technique is described, and proven to
 * generate random samples &lt;a
 * href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html"&gt;
 * here&lt;/a&gt;
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="Object[]" name="nextSample">
    <declaration type="int" name="len" />
    <scope />
    <scope />
    <declaration type="Object[]" name="objects" />
    <declaration type="int[]" name="index" />
    <declaration type="Object[]" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>Reseeds the random number generator with the supplied seed.
 * &lt;p&gt;
 * Will create and initialize if null.
 * &lt;/p&gt;</text>
    <param>seed the seed value to use</param>
  </javadoc>
  <method type="void" name="reSeed" />
  <javadoc>
    <text>Reseeds the secure random number generator with the current time in
 * milliseconds.
 * &lt;p&gt;
 * Will create and initialize if null.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="reSeedSecure" />
  <javadoc>
    <text>Reseeds the secure random number generator with the supplied seed.
 * &lt;p&gt;
 * Will create and initialize if null.
 * &lt;/p&gt;</text>
    <param>seed the seed value to use</param>
  </javadoc>
  <method type="void" name="reSeedSecure" />
  <javadoc>
    <text>Reseeds the random number generator with{@code System.currentTimeMillis() + System.identityHashCode(this))}.</text>
  </javadoc>
  <method type="void" name="reSeed" />
  <javadoc>
    <text>Sets the PRNG algorithm for the underlying SecureRandom instance using
 * the Security Provider API. The Security Provider API is defined in &lt;a
 * href =
 * "http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA"&gt;
 * Java Cryptography Architecture API Specification &amp; Reference.&lt;/a&gt;
 * &lt;p&gt;
 * &lt;strong&gt;USAGE NOTE:&lt;/strong&gt; This method carries &lt;i&gt;significant&lt;/i&gt;
 * overhead and may take several seconds to execute.
 * &lt;/p&gt;</text>
    <param>algorithm the name of the PRNG algorithm</param>
    <param>provider the name of the provider</param>
    <throws>NoSuchAlgorithmException if the specified algorithm is not available</throws>
    <throws>NoSuchProviderException if the specified provider is not installed</throws>
  </javadoc>
  <method type="void" name="setSecureAlgorithm" />
  <javadoc>
    <text>Returns the RandomGenerator used to generate non-secure random data.
 * &lt;p&gt;
 * Creates and initializes a default generator if null. Uses a {@link Well19937c}generator with {@code System.currentTimeMillis() + System.identityHashCode(this))}as the default seed.
 * &lt;/p&gt;</text>
    <return>the Random used to generate random data</return>
    <since>3.2</since>
  </javadoc>
  <method type="RandomGenerator" name="getRandomGenerator">
    <scope />
  </method>
  <javadoc>
    <text>Sets the default generator to a {@link Well19937c} generator seeded with{@code System.currentTimeMillis() + System.identityHashCode(this))}.</text>
  </javadoc>
  <method type="void" name="initRan" />
  <javadoc>
    <text>Returns the SecureRandom used to generate secure random data.
 * &lt;p&gt;
 * Creates and initializes if null.  Uses{@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.
 * &lt;/p&gt;</text>
    <return>the SecureRandom used to generate secure random data</return>
  </javadoc>
  <method type="SecureRandom" name="getSecRan">
    <scope />
  </method>
  <javadoc>
    <text>Uses a 2-cycle permutation shuffle to randomly re-order the last elements
 * of list.</text>
    <param>list list to be shuffled</param>
    <param>end element past which shuffling begins</param>
  </javadoc>
  <method type="void" name="shuffle">
    <declaration type="int" name="target" />
    <scope>
      <scope />
      <scope />
      <declaration type="int" name="temp" />
    </scope>
    <comment>NumberIsTooLargeException cannot occur</comment>
  </method>
  <javadoc>
    <text>Returns an array representing n.</text>
    <param>n the natural number to represent</param>
    <return>array with entries = elements of n</return>
  </javadoc>
  <method type="int[]" name="getNatural">
    <declaration type="int[]" name="natural" />
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
