<?xml version="1.0" encoding="UTF-8"?>
<class name="IntervalsSet">
  <javadoc>
    <text>This class represents a 1D region: a set of intervals.</text>
    <version>$Id: IntervalsSet.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Build an intervals set representing the whole real line.</text>
  </javadoc>
  <method type="constructor" name="IntervalsSet" />
  <javadoc>
    <text>Build an intervals set corresponding to a single interval.</text>
    <param>lower lower bound of the interval, must be lesser or equal
 * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})</param>
    <param>upper upper bound of the interval, must be greater or equal
 * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})</param>
  </javadoc>
  <method type="constructor" name="IntervalsSet" />
  <javadoc>
    <text>Build an intervals set from an inside/outside BSP tree.
 * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;</text>
    <param>tree inside/outside BSP tree representing the intervals set</param>
  </javadoc>
  <method type="constructor" name="IntervalsSet" />
  <javadoc>
    <text>Build an intervals set from a Boundary REPresentation (B-rep).
 * &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.&lt;/p&gt;
 * &lt;p&gt;The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polygons with holes
 * or a set of disjoints polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
 * &lt;p&gt;If the boundary is empty, the region will represent the whole
 * space.&lt;/p&gt;</text>
    <param>boundary collection of boundary elements</param>
  </javadoc>
  <method type="constructor" name="IntervalsSet" />
  <javadoc>
    <text>Build an inside/outside tree representing a single interval.</text>
    <param>lower lower bound of the interval, must be lesser or equal
 * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})</param>
    <param>upper upper bound of the interval, must be greater or equal
 * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})</param>
    <return>the built tree</return>
  </javadoc>
  <method type="BSPTree&lt;Euclidean1D&gt;" name="buildTree">
    <scope>
      <scope />
      <declaration type="SubHyperplane&lt;Euclidean1D&gt;" name="upperCut" />
    </scope>
    <declaration type="SubHyperplane&lt;Euclidean1D&gt;" name="lowerCut" />
    <scope />
    <declaration type="SubHyperplane&lt;Euclidean1D&gt;" name="upperCut" />
    <comment>the tree must cover the whole real line</comment>
    <comment>the tree must be open on the negative infinity side</comment>
    <comment>the tree must be open on the positive infinity side</comment>
    <comment>the tree must be bounded on the two sides</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="IntervalsSet" name="buildNew" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="computeGeometricalProperties">
    <scope />
    <scope>
      <declaration type="double" name="size" />
      <declaration type="double" name="sum" />
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the lowest value belonging to the instance.</text>
    <return>lowest value belonging to the instance
 * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't
 * have any low bound, {@code Double.POSITIVE_INFINITY} if the
 * instance is empty)</return>
  </javadoc>
  <method type="double" name="getInf">
    <declaration type="BSPTree&lt;Euclidean1D&gt;" name="node" />
    <declaration type="double" name="inf" />
    <scope>
      <declaration type="OrientedPoint" name="op" />
    </scope>
  </method>
  <javadoc>
    <text>Get the highest value belonging to the instance.</text>
    <return>highest value belonging to the instance
 * ({@code Double.POSITIVE_INFINITY} if the instance doesn't
 * have any high bound, {@code Double.NEGATIVE_INFINITY} if the
 * instance is empty)</return>
  </javadoc>
  <method type="double" name="getSup">
    <declaration type="BSPTree&lt;Euclidean1D&gt;" name="node" />
    <declaration type="double" name="sup" />
    <scope>
      <declaration type="OrientedPoint" name="op" />
    </scope>
  </method>
  <javadoc>
    <text>Build an ordered list of intervals representing the instance.
 * &lt;p&gt;This method builds this intervals set as an ordered list of{@link Interval Interval} elements. If the intervals set has no
 * lower limit, the first interval will have its low bound equal to{@code Double.NEGATIVE_INFINITY}. If the intervals set has
 * no upper limit, the last interval will have its upper bound equal
 * to {@code Double.POSITIVE_INFINITY}. An empty tree will
 * build an empty list while a tree representing the whole real line
 * will build a one element list with both bounds beeing
 * infinite.&lt;/p&gt;</text>
    <return>a new ordered list containing {@link Interval Interval}elements</return>
  </javadoc>
  <method type="List&lt;Interval&gt;" name="asList">
    <declaration type="List&lt;Interval&gt;" name="list" />
  </method>
  <javadoc>
    <text>Update an intervals list.</text>
    <param>node current node</param>
    <param>list list to update</param>
    <param>lower lower bound of the current convex cell</param>
    <param>upper upper bound of the current convex cell</param>
  </javadoc>
  <method type="void" name="recurseList">
    <scope>
      <scope />
    </scope>
    <scope>
      <declaration type="OrientedPoint" name="op" />
      <declaration type="Vector1D" name="loc" />
      <declaration type="double" name="x" />
      <declaration type="BSPTree&lt;Euclidean1D&gt;" name="low" />
      <declaration type="BSPTree&lt;Euclidean1D&gt;" name="high" />
      <scope />
    </scope>
    <comment>this leaf cell is an inside cell: an interval</comment>
    <comment>make sure we explore the tree in increasing order</comment>
    <comment>merge the last interval added and the first one of the high sub-tree</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
