<?xml version="1.0" encoding="UTF-8"?>
<class name="Region">
  <javadoc>
    <text>This interface represents a region of a space as a partition.
 * &lt;p&gt;Region are subsets of a space, they can be infinite (whole
 * space, half space, infinite stripe ...) or finite (polygons in 2D,
 * polyhedrons in 3D ...). Their main characteristic is to separate
 * points that are considered to be &lt;em&gt;inside&lt;/em&gt; the region from
 * points considered to be &lt;em&gt;outside&lt;/em&gt; of it. In between, there
 * may be points on the &lt;em&gt;boundary&lt;/em&gt; of the region.&lt;/p&gt;
 * &lt;p&gt;This implementation is limited to regions for which the boundary
 * is composed of several {@link SubHyperplane sub-hyperplanes},
 * including regions with no boundary at all: the whole space and the
 * empty region. They are not necessarily finite and not necessarily
 * path-connected. They can contain holes.&lt;/p&gt;
 * &lt;p&gt;Regions can be combined using the traditional sets operations :
 * union, intersection, difference and symetric difference (exclusive
 * or) for the binary operations, complement for the unary
 * operation.&lt;/p&gt;</text>
    <param>&lt;S&gt;
 *  Type of the space.</param>
    <version>$Id: Region.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Enumerate for the location of a point with respect to the region.</text>
  </javadoc>
  <javadoc>
    <text>Code for points inside the partition.</text>
  </javadoc>
  <javadoc>
    <text>Code for points outside of the partition.</text>
  </javadoc>
  <javadoc>
    <text>Code for points on the partition boundary.</text>
  </javadoc>
  <method name="buildNew" type="Region&lt;S&gt;" />
  <javadoc>
    <text>Build a region using the instance as a prototype.
 * &lt;p&gt;This method allow to create new instances without knowing
 * exactly the type of the region. It is an application of the
 * prototype design pattern.&lt;/p&gt;
 * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
 * tree also &lt;em&gt;must&lt;/em&gt; have either null internal nodes or
 * internal nodes representing the boundary as specified in the{@link #getTree getTree} method).&lt;/p&gt;</text>
    <param>newTree inside/outside BSP tree representing the new region</param>
    <return>the built region</return>
  </javadoc>
  <method name="copySelf" type="Region&lt;S&gt;" />
  <javadoc>
    <text>Copy the instance.
 * &lt;p&gt;The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying objects are
 * shared (except for the underlying tree {@code Boolean}attributes and immutable objects).&lt;/p&gt;</text>
    <return>a new region, copy of the instance</return>
  </javadoc>
  <method name="isEmpty" type="boolean" />
  <javadoc>
    <text>Check if the instance is empty.</text>
    <return>true if the instance is empty</return>
  </javadoc>
  <method name="isEmpty" type="boolean" />
  <javadoc>
    <text>Check if the sub-tree starting at a given node is empty.</text>
    <param>node root node of the sub-tree (&lt;em&gt;must&lt;/em&gt; have {@link Region Region} tree semantics, i.e. the leaf nodes must have{@code Boolean} attributes representing an inside/outside
 * property)</param>
    <return>true if the sub-tree starting at the given node is empty</return>
  </javadoc>
  <method name="contains" type="boolean" />
  <javadoc>
    <text>Check if the instance entirely contains another region.</text>
    <param>region region to check against the instance</param>
    <return>true if the instance contains the specified tree</return>
  </javadoc>
  <method name="checkPoint" type="Location" />
  <javadoc>
    <text>Check a point with respect to the region.</text>
    <param>point point to check</param>
    <return>a code representing the point status: either {@link Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}</return>
  </javadoc>
  <method name="getTree" type="BSPTree&lt;S&gt;" />
  <javadoc>
    <text>Get the underlying BSP tree.
 * &lt;p&gt;Regions are represented by an underlying inside/outside BSP
 * tree whose leaf attributes are {@code Boolean} instances
 * representing inside leaf cells if the attribute value is{@code true} and outside leaf cells if the attribute is{@code false}. These leaf attributes are always present and
 * guaranteed to be non null.&lt;/p&gt;
 * &lt;p&gt;In addition to the leaf attributes, the internal nodes which
 * correspond to cells split by cut sub-hyperplanes may contain{@link BoundaryAttribute BoundaryAttribute} objects representing
 * the parts of the corresponding cut sub-hyperplane that belong to
 * the boundary. When the boundary attributes have been computed,
 * all internal nodes are guaranteed to have non-null
 * attributes, however some {@link BoundaryAttributeBoundaryAttribute} instances may have their {@link BoundaryAttribute#plusInside plusInside} and {@link BoundaryAttribute#plusOutside plusOutside} fields both null if
 * the corresponding cut sub-hyperplane does not have any parts
 * belonging to the boundary.&lt;/p&gt;
 * &lt;p&gt;Since computing the boundary is not always required and can be
 * time-consuming for large trees, these internal nodes attributes
 * are computed using lazy evaluation only when required by setting
 * the {@code includeBoundaryAttributes} argument to{@code true}. Once computed, these attributes remain in the
 * tree, which implies that in this case, further calls to the
 * method for the same region will always include these attributes
 * regardless of the value of the{@code includeBoundaryAttributes} argument.&lt;/p&gt;</text>
    <param>includeBoundaryAttributes if true, the boundary attributes
 * at internal nodes are guaranteed to be included (they may be
 * included even if the argument is false, if they have already been
 * computed due to a previous call)</param>
    <return>underlying BSP tree</return>
    <see>BoundaryAttribute</see>
  </javadoc>
  <method name="getBoundarySize" type="double" />
  <javadoc>
    <text>Get the size of the boundary.</text>
    <return>the size of the boundary (this is 0 in 1D, a length in
 * 2D, an area in 3D ...)</return>
  </javadoc>
  <method name="getSize" type="double" />
  <javadoc>
    <text>Get the size of the instance.</text>
    <return>the size of the instance (this is a length in 1D, an area
 * in 2D, a volume in 3D ...)</return>
  </javadoc>
  <method name="getBarycenter" type="Vector&lt;S&gt;" />
  <javadoc>
    <text>Get the barycenter of the instance.</text>
    <return>an object representing the barycenter</return>
  </javadoc>
  <method name="side" type="Side" />
  <javadoc>
    <text>Compute the relative position of the instance with respect to an
 * hyperplane.</text>
    <param>hyperplane reference hyperplane</param>
    <return>one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUSSide.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPERSide.HYPER} (the latter result can occur only if the tree
 * contains only one cut hyperplane)</return>
  </javadoc>
  <method name="intersection" type="SubHyperplane&lt;S&gt;" />
  <javadoc>
    <text>Get the parts of a sub-hyperplane that are contained in the region.
 * &lt;p&gt;The parts of the sub-hyperplane that belong to the boundary are
 * &lt;em&gt;not&lt;/em&gt; included in the resulting parts.&lt;/p&gt;</text>
    <param>sub sub-hyperplane traversing the region</param>
    <return>filtered sub-hyperplane</return>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
