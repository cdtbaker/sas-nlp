<?xml version="1.0" encoding="UTF-8"?>
<class name="RRQRDecomposition">
  <javadoc>
    <text>Calculates the rank-revealing QR-decomposition of a matrix, with column pivoting.
 * &lt;p&gt;The rank-revealing QR-decomposition of a matrix A consists of three matrices Q,
 * R and P such that AP=QR.  Q is orthogonal (Q&lt;sup&gt;T&lt;/sup&gt;Q = I), and R is upper triangular.
 * If A is m&amp;times;n, Q is m&amp;times;m and R is m&amp;times;n and P is n&amp;times;n.&lt;/p&gt;
 * &lt;p&gt;QR decomposition with column pivoting produces a rank-revealing QR
 * decomposition and the {@link #getRank(double)} method may be used to return the rank of the
 * input matrix A.&lt;/p&gt;
 * &lt;p&gt;This class compute the decomposition using Householder reflectors.&lt;/p&gt;
 * &lt;p&gt;For efficiency purposes, the decomposition in packed form is transposed.
 * This allows inner loop to iterate inside rows, which is much more cache-efficient
 * in Java.&lt;/p&gt;
 * &lt;p&gt;This class is based on the class with similar name from the
 * &lt;a href="http://math.nist.gov/javanumerics/jama/"&gt;JAMA&lt;/a&gt; library, with the
 * following changes:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;a {@link #getQT() getQT} method has been added,&lt;/li&gt;
 * &lt;li&gt;the {@code solve} and {@code isFullRank} methods have been replaced
 * by a {@link #getSolver() getSolver} method and the equivalent methods
 * provided by the returned {@link DecompositionSolver}.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <see>&lt;a href="http://mathworld.wolfram.com/QRDecomposition.html"&gt;MathWorld&lt;/a&gt;</see>
    <see>&lt;a href="http://en.wikipedia.org/wiki/QR_decomposition"&gt;Wikipedia&lt;/a&gt;</see>
    <version>$Id: RRQRDecomposition.java 1456956 2013-03-15 13:54:20Z luc $</version>
    <since>3.2</since>
  </javadoc>
  <javadoc>
    <text>An array to record the column pivoting for later creation of P.</text>
  </javadoc>
  <declaration type="int[]" name="p" />
  <javadoc>
    <text>Cached value of P.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedP" />
  <javadoc>
    <text>Calculates the QR-decomposition of the given matrix.
 * The singularity threshold defaults to zero.</text>
    <param>matrix The matrix to decompose.</param>
    <see>#RRQRDecomposition(RealMatrix,double)</see>
  </javadoc>
  <method type="constructor" name="RRQRDecomposition" />
  <javadoc>
    <text>Calculates the QR-decomposition of the given matrix.</text>
    <param>matrix The matrix to decompose.</param>
    <param>threshold Singularity threshold.</param>
    <see>#RRQRDecomposition(RealMatrix)</see>
  </javadoc>
  <method type="constructor" name="RRQRDecomposition" />
  <javadoc>
    <text>Decompose matrix.</text>
    <param>qrt transposed matrix</param>
  </javadoc>
  <method type="void" name="decompose">
    <scope />
  </method>
  <javadoc>
    <text>Perform Householder reflection for a minor A(minor, minor) of A.</text>
    <param>minor minor index</param>
    <param>qrt transposed matrix</param>
  </javadoc>
  <method type="void" name="performHouseholderReflection">
    <declaration type="double" name="l2NormSquaredMax" />
    <declaration type="int" name="l2NormSquaredMaxIndex" />
    <scope>
      <declaration type="double" name="l2NormSquared" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="double[]" name="tmp1" />
      <declaration type="int" name="tmp2" />
    </scope>
    <comment>Find the unreduced column with the greatest L2-Norm</comment>
    <comment>swap the current column with that with the greated L2-Norm and record in p</comment>
  </method>
  <javadoc>
    <text>Returns the pivot matrix, P, used in the QR Decomposition of matrix A such that AP = QR.
 * If no pivoting is used in this decomposition then P is equal to the identity matrix.</text>
    <return>a permutation matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="getP">
    <scope>
      <declaration type="int" name="n" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Return the effective numerical matrix rank.
 * &lt;p&gt;The effective numerical rank is the number of non-negligible
 * singular values.&lt;/p&gt;
 * &lt;p&gt;This implementation looks at Frobenius norms of the sequence of
 * bottom right submatrices.  When a large fall in norm is seen,
 * the rank is returned. The drop is computed as:&lt;/p&gt;
 * &lt;pre&gt;
 * (thisNorm/lastNorm) * rNorm &lt; dropThreshold
 * &lt;/pre&gt;
 * &lt;p&gt;
 * where thisNorm is the Frobenius norm of the current submatrix,
 * lastNorm is the Frobenius norm of the previous submatrix,
 * rNorm is is the Frobenius norm of the complete matrix
 * &lt;/p&gt;</text>
    <param>dropThreshold threshold triggering rank computation</param>
    <return>effective numerical matrix rank</return>
  </javadoc>
  <method type="int" name="getRank">
    <declaration type="RealMatrix" name="r" />
    <declaration type="int" name="rows" />
    <declaration type="int" name="columns" />
    <declaration type="int" name="rank" />
    <declaration type="double" name="lastNorm" />
    <declaration type="double" name="rNorm" />
    <scope>
      <declaration type="double" name="thisNorm" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get a solver for finding the A &amp;times; X = B solution in least square sense.</text>
    <return>a solver</return>
  </javadoc>
  <method type="DecompositionSolver" name="getSolver" />
  <javadoc>
    <text>Specialized solver.</text>
  </javadoc>
  <javadoc>
    <text>Upper level solver.</text>
  </javadoc>
  <declaration type="DecompositionSolver" name="upper" />
  <javadoc>
    <text>A permutation matrix for the pivots used in the QR decomposition</text>
  </javadoc>
  <declaration type="RealMatrix" name="p" />
  <javadoc>
    <text>Build a solver from decomposed matrix.</text>
    <param>upper upper level solver.</param>
    <param>p permutation matrix</param>
  </javadoc>
  <method type="constructor" name="Solver" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isNonSingular" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealVector" name="solve" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealMatrix" name="solve" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealMatrix" name="getInverse" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
