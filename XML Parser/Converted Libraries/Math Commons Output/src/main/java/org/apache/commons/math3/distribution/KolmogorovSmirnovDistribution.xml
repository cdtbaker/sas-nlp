<?xml version="1.0" encoding="UTF-8"?>
<class name="KolmogorovSmirnovDistribution">
  <javadoc>
    <text>Implementation of the Kolmogorov-Smirnov distribution.
 * &lt;p&gt;
 * Treats the distribution of the two-sided {@code P(D_n &lt; d)} where{@code D_n = sup_x |G(x) - G_n (x)|} for the theoretical cdf {@code G} and
 * the empirical cdf {@code G_n}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This implementation is based on [1] with certain quick decisions for extreme
 * values given in [2].
 * &lt;/p&gt;
 * &lt;p&gt;
 * In short, when wanting to evaluate {@code P(D_n &lt; d)}, the method in [1] is
 * to write {@code d = (k - h) / n} for positive integer {@code k} and{@code 0 &lt;= h &lt; 1}. Then {@code P(D_n &lt; d) = (n! / n^n) * t_kk}, where{@code t_kk} is the {@code (k, k)}'th entry in the special matrix{@code H^n}, i.e. {@code H} to the {@code n}'th power.
 * &lt;/p&gt;
 * &lt;p&gt;
 * References:
 * &lt;ul&gt;
 * &lt;li&gt;[1] &lt;a href="http://www.jstatsoft.org/v08/i18/"&gt;
 * Evaluating Kolmogorov's Distribution&lt;/a&gt; by George Marsaglia, Wai
 * Wan Tsang, and Jingbo Wang&lt;/li&gt;
 * &lt;li&gt;[2] &lt;a href="http://www.jstatsoft.org/v39/i11/"&gt;
 * Computing the Two-Sided Kolmogorov-Smirnov Distribution&lt;/a&gt; by Richard Simard
 * and Pierre L'Ecuyer&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that [1] contains an error in computing h, refer to
 * &lt;a href="https://issues.apache.org/jira/browse/MATH-437"&gt;MATH-437&lt;/a&gt; for details.
 * &lt;/p&gt;</text>
    <see>&lt;a href="http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test"&gt;
 * Kolmogorov-Smirnov test (Wikipedia)&lt;/a&gt;</see>
    <version>$Id: KolmogorovSmirnovDistribution.java 1416643 2012-12-03 19:37:14Z tn $</version>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Number of observations.</text>
  </javadoc>
  <declaration type="int" name="n" />
  <javadoc>
    <param>n Number of observations</param>
    <throws>NotStrictlyPositiveException if {@code n &lt;= 0}</throws>
  </javadoc>
  <method type="constructor" name="KolmogorovSmirnovDistribution">
    <scope />
  </method>
  <javadoc>
    <text>Calculates {@code P(D_n &lt; d)} using method described in [1] with quick
 * decisions for extreme values given in [2] (see above). The result is not
 * exact as with{@link KolmogorovSmirnovDistribution#cdfExact(double)} because
 * calculations are based on {@code double} rather than{@link org.apache.commons.math3.fraction.BigFraction}.</text>
    <param>d statistic</param>
    <return>the two-sided probability of {@code P(D_n &lt; d)}</return>
    <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 &lt;= h &lt; 1}.</throws>
  </javadoc>
  <method type="double" name="cdf" />
  <javadoc>
    <text>Calculates {@code P(D_n &lt; d)} using method described in [1] with quick
 * decisions for extreme values given in [2] (see above). The result is
 * exact in the sense that BigFraction/BigReal is used everywhere at the
 * expense of very slow execution time. Almost never choose this in real
 * applications unless you are very sure; this is almost solely for
 * verification purposes. Normally, you would choose{@link KolmogorovSmirnovDistribution#cdf(double)}</text>
    <param>d statistic</param>
    <return>the two-sided probability of {@code P(D_n &lt; d)}</return>
    <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 &lt;= h &lt; 1}.</throws>
  </javadoc>
  <method type="double" name="cdfExact" />
  <javadoc>
    <text>Calculates {@code P(D_n &lt; d)} using method described in [1] with quick
 * decisions for extreme values given in [2] (see above).</text>
    <param>d statistic</param>
    <param>exact whether the probability should be calculated exact using{@link org.apache.commons.math3.fraction.BigFraction} everywhere at the
 * expense of very slow execution time, or if {@code double} should be used
 * convenient places to gain speed. Almost never choose {@code true} in real
 * applications unless you are very sure; {@code true} is almost solely for
 * verification purposes.</param>
    <return>the two-sided probability of {@code P(D_n &lt; d)}</return>
    <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 &lt;= h &lt; 1}.</throws>
  </javadoc>
  <method type="double" name="cdf">
    <declaration type="double" name="ninv" />
    <declaration type="double" name="ninvhalf" />
    <scope />
    <scope>
      <declaration type="double" name="res" />
      <declaration type="double" name="f" />
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>n! f^n = n*f * (n-1)*f * ... * 1*x</comment>
  </method>
  <javadoc>
    <text>Calculates the exact value of {@code P(D_n &lt; d)} using method described
 * in [1] and {@link org.apache.commons.math3.fraction.BigFraction} (see
 * above).</text>
    <param>d statistic</param>
    <return>the two-sided probability of {@code P(D_n &lt; d)}</return>
    <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 &lt;= h &lt; 1}.</throws>
  </javadoc>
  <method type="double" name="exactK">
    <declaration type="int" name="k" />
    <declaration type="FieldMatrix&lt;BigFraction&gt;" name="H" />
    <declaration type="FieldMatrix&lt;BigFraction&gt;" name="Hpower" />
    <declaration type="BigFraction" name="pFrac" />
    <scope />
    <comment>BigFraction.doubleValue converts numerator to double and the
 denominator to double and divides afterwards. That gives NaN quite
 easy. This does not (scale is the number of digits):</comment>
  </method>
  <javadoc>
    <text>Calculates {@code P(D_n &lt; d)} using method described in [1] and doubles
 * (see above).</text>
    <param>d statistic</param>
    <return>the two-sided probability of {@code P(D_n &lt; d)}</return>
    <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 &lt;= h &lt; 1}.</throws>
  </javadoc>
  <method type="double" name="roundedK">
    <declaration type="int" name="k" />
    <declaration type="FieldMatrix&lt;BigFraction&gt;" name="HBigFraction" />
    <declaration type="int" name="m" />
    <declaration type="RealMatrix" name="H" />
    <scope>
      <scope />
    </scope>
    <declaration type="RealMatrix" name="Hpower" />
    <declaration type="double" name="pFrac" />
    <scope />
    <comment>Here the rounding part comes into play: use
 RealMatrix instead of FieldMatrix&lt;BigFraction&gt;</comment>
  </method>
  <javadoc>
    <text>Creates {@code H} of size {@code m x m} as described in [1] (see above).</text>
    <param>d statistic</param>
    <return>H matrix</return>
    <throws>NumberIsTooLargeException if fractional part is greater than 1</throws>
    <throws>FractionConversionException if algorithm fails to convert{@code h} to a {@link org.apache.commons.math3.fraction.BigFraction} in
 * expressing {@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 &lt;= h &lt; 1}.</throws>
  </javadoc>
  <method type="FieldMatrix&lt;BigFraction&gt;" name="createH">
    <declaration type="int" name="k" />
    <declaration type="int" name="m" />
    <declaration type="double" name="hDouble" />
    <scope />
    <declaration type="BigFraction" name="h" />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <declaration type="BigFraction[][]" name="Hdata" />
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <declaration type="BigFraction[]" name="hPowers" />
    <scope />
    <scope />
    <scope />
    <scope>
      <scope>
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>Start by filling everything with either 0 or 1.</comment>
    <comment>Setting up power-array to avoid calculating the same value twice:
 hPowers[0] = h^1 ... hPowers[m-1] = h^m</comment>
    <comment>First column and last row has special values (each other reversed).</comment>
    <comment>[1] states: "For 12 &lt; h &lt; 1 the bottom left element of the matrix
 should be (1 - 2h^m + (2h - 1)^m )m!" Since 0 &lt;= h &lt; 1, then if h &gt;
 12 is sufficient to check:</comment>
    <comment>Aside from the first column and last row, the (i, j)-th element is
 1(i - j + 1)! if i - j + 1 &gt;= 0, else 0. 1's and 0's are already
 put, so only division with (i - j + 1)! is needed in the elements
 that have 1's. There is no need to calculate (i - j + 1)! and then
 divide - small steps avoid overflows.

 Note that i - j + 1 &gt; 0 &lt;=&gt; i + 1 &gt; j instead of j'ing all the way to
 m. Also note that it is started at g = 2 because dividing by 1 isn't
 really necessary.</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
