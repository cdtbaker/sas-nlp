<?xml version="1.0" encoding="UTF-8"?>
<class name="Vector3D">
  <javadoc>
    <text>This class implements vectors in a three-dimensional space.
 * &lt;p&gt;Instance of this class are guaranteed to be immutable.&lt;/p&gt;</text>
    <version>$Id: Vector3D.java 1447259 2013-02-18 13:56:39Z luc $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Null vector (coordinates: 0, 0, 0).</text>
  </javadoc>
  <declaration type="Vector3D" name="ZERO" />
  <javadoc>
    <text>First canonical vector (coordinates: 1, 0, 0).</text>
  </javadoc>
  <declaration type="Vector3D" name="PLUS_I" />
  <javadoc>
    <text>Opposite of the first canonical vector (coordinates: -1, 0, 0).</text>
  </javadoc>
  <declaration type="Vector3D" name="MINUS_I" />
  <javadoc>
    <text>Second canonical vector (coordinates: 0, 1, 0).</text>
  </javadoc>
  <declaration type="Vector3D" name="PLUS_J" />
  <javadoc>
    <text>Opposite of the second canonical vector (coordinates: 0, -1, 0).</text>
  </javadoc>
  <declaration type="Vector3D" name="MINUS_J" />
  <javadoc>
    <text>Third canonical vector (coordinates: 0, 0, 1).</text>
  </javadoc>
  <declaration type="Vector3D" name="PLUS_K" />
  <javadoc>
    <text>Opposite of the third canonical vector (coordinates: 0, 0, -1).</text>
  </javadoc>
  <declaration type="Vector3D" name="MINUS_K" />
  <javadoc>
    <text>A vector with all coordinates set to NaN.</text>
  </javadoc>
  <declaration type="Vector3D" name="NaN" />
  <javadoc>
    <text>A vector with all coordinates set to positive infinity.</text>
  </javadoc>
  <declaration type="Vector3D" name="POSITIVE_INFINITY" />
  <javadoc>
    <text>A vector with all coordinates set to negative infinity.</text>
  </javadoc>
  <declaration type="Vector3D" name="NEGATIVE_INFINITY" />
  <javadoc>
    <text>Serializable version identifier.</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Abscissa.</text>
  </javadoc>
  <declaration type="double" name="x" />
  <javadoc>
    <text>Ordinate.</text>
  </javadoc>
  <declaration type="double" name="y" />
  <javadoc>
    <text>Height.</text>
  </javadoc>
  <declaration type="double" name="z" />
  <javadoc>
    <text>Simple constructor.
 * Build a vector from its coordinates</text>
    <param>x abscissa</param>
    <param>y ordinate</param>
    <param>z height</param>
    <see>#getX()</see>
    <see>#getY()</see>
    <see>#getZ()</see>
  </javadoc>
  <method type="constructor" name="Vector3D" />
  <javadoc>
    <text>Simple constructor.
 * Build a vector from its coordinates</text>
    <param>v coordinates array</param>
    <exception>DimensionMismatchException if array does not have 3 elements</exception>
    <see>#toArray()</see>
  </javadoc>
  <method type="constructor" name="Vector3D">
    <scope />
  </method>
  <javadoc>
    <text>Simple constructor.
 * Build a vector from its azimuthal coordinates</text>
    <param>alpha azimuth (&amp;alpha;) around Z
 * (0 is +X, &amp;pi;/2 is +Y, &amp;pi; is -X and 3&amp;pi;/2 is -Y)</param>
    <param>delta elevation (&amp;delta;) above (XY) plane, from -&amp;pi;/2 to +&amp;pi;/2</param>
    <see>#getAlpha()</see>
    <see>#getDelta()</see>
  </javadoc>
  <method type="constructor" name="Vector3D">
    <declaration type="double" name="cosDelta" />
  </method>
  <javadoc>
    <text>Multiplicative constructor
 * Build a vector from another one and a scale factor.
 * The vector built will be a * u</text>
    <param>a scale factor</param>
    <param>u base (unscaled) vector</param>
  </javadoc>
  <method type="constructor" name="Vector3D" />
  <javadoc>
    <text>Linear constructor
 * Build a vector from two other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2</text>
    <param>a1 first scale factor</param>
    <param>u1 first base (unscaled) vector</param>
    <param>a2 second scale factor</param>
    <param>u2 second base (unscaled) vector</param>
  </javadoc>
  <method type="constructor" name="Vector3D" />
  <javadoc>
    <text>Linear constructor
 * Build a vector from three other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3</text>
    <param>a1 first scale factor</param>
    <param>u1 first base (unscaled) vector</param>
    <param>a2 second scale factor</param>
    <param>u2 second base (unscaled) vector</param>
    <param>a3 third scale factor</param>
    <param>u3 third base (unscaled) vector</param>
  </javadoc>
  <method type="constructor" name="Vector3D" />
  <javadoc>
    <text>Linear constructor
 * Build a vector from four other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4</text>
    <param>a1 first scale factor</param>
    <param>u1 first base (unscaled) vector</param>
    <param>a2 second scale factor</param>
    <param>u2 second base (unscaled) vector</param>
    <param>a3 third scale factor</param>
    <param>u3 third base (unscaled) vector</param>
    <param>a4 fourth scale factor</param>
    <param>u4 fourth base (unscaled) vector</param>
  </javadoc>
  <method type="constructor" name="Vector3D" />
  <javadoc>
    <text>Get the abscissa of the vector.</text>
    <return>abscissa of the vector</return>
    <see>#Vector3D(double,double,double)</see>
  </javadoc>
  <method type="double" name="getX" />
  <javadoc>
    <text>Get the ordinate of the vector.</text>
    <return>ordinate of the vector</return>
    <see>#Vector3D(double,double,double)</see>
  </javadoc>
  <method type="double" name="getY" />
  <javadoc>
    <text>Get the height of the vector.</text>
    <return>height of the vector</return>
    <see>#Vector3D(double,double,double)</see>
  </javadoc>
  <method type="double" name="getZ" />
  <javadoc>
    <text>Get the vector coordinates as a dimension 3 array.</text>
    <return>vector coordinates</return>
    <see>#Vector3D(double[])</see>
  </javadoc>
  <method type="double[]" name="toArray" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Space" name="getSpace" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="getZero" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getNorm1" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getNorm">
    <comment>there are no cancellation problems here, so we use the straightforward formula</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getNormSq">
    <comment>there are no cancellation problems here, so we use the straightforward formula</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getNormInf" />
  <javadoc>
    <text>Get the azimuth of the vector.</text>
    <return>azimuth (&amp;alpha;) of the vector, between -&amp;pi; and +&amp;pi;</return>
    <see>#Vector3D(double,double)</see>
  </javadoc>
  <method type="double" name="getAlpha" />
  <javadoc>
    <text>Get the elevation of the vector.</text>
    <return>elevation (&amp;delta;) of the vector, between -&amp;pi;/2 and +&amp;pi;/2</return>
    <see>#Vector3D(double,double)</see>
  </javadoc>
  <method type="double" name="getDelta" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="add">
    <declaration type="Vector3D" name="v3" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="add" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="subtract">
    <declaration type="Vector3D" name="v3" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="subtract" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="normalize">
    <declaration type="double" name="s" />
    <scope />
  </method>
  <javadoc>
    <text>Get a vector orthogonal to the instance.
 * &lt;p&gt;There are an infinite number of normalized vectors orthogonal
 * to the instance. This method picks up one of them almost
 * arbitrarily. It is useful when one needs to compute a reference
 * frame with one of the axes in a predefined direction. The
 * following example shows how to build a frame having the k axis
 * aligned with the known vector u :
 * &lt;pre&gt;&lt;code&gt;
 * Vector3D k = u.normalize();
 * Vector3D i = k.orthogonal();
 * Vector3D j = Vector3D.crossProduct(k, i);
 * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</text>
    <return>a new normalized vector orthogonal to the instance</return>
    <exception>MathArithmeticException if the norm of the instance is null</exception>
  </javadoc>
  <method type="Vector3D" name="orthogonal">
    <declaration type="double" name="threshold" />
    <scope />
    <scope>
      <declaration type="double" name="inverse" />
    </scope>
    <scope>
      <declaration type="double" name="inverse" />
    </scope>
    <declaration type="double" name="inverse" />
  </method>
  <javadoc>
    <text>Compute the angular separation between two vectors.
 * &lt;p&gt;This method computes the angular separation between two
 * vectors using the dot product for well separated vectors and the
 * cross product for almost aligned vectors. This allows to have a
 * good accuracy in all cases, even for vectors very close to each
 * other.&lt;/p&gt;</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>angular separation between v1 and v2</return>
    <exception>MathArithmeticException if either vector has a null norm</exception>
  </javadoc>
  <method type="double" name="angle">
    <declaration type="double" name="normProduct" />
    <scope />
    <declaration type="double" name="dot" />
    <declaration type="double" name="threshold" />
    <scope>
      <declaration type="Vector3D" name="v3" />
      <scope />
    </scope>
    <comment>the vectors are almost aligned, compute using the sine</comment>
    <comment>the vectors are sufficiently separated to use the cosine</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="negate" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Vector3D" name="scalarMultiply" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isNaN" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isInfinite" />
  <javadoc>
    <text>Test for the equality of two 3D vectors.
 * &lt;p&gt;
 * If all coordinates of two 3D vectors are exactly the same, and none are
 * &lt;code&gt;Double.NaN&lt;/code&gt;, the two 3D vectors are considered to be equal.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;code&gt;NaN&lt;/code&gt; coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * 3D vector are equal to &lt;code&gt;Double.NaN&lt;/code&gt;, the 3D vector is equal to{@link #NaN}.
 * &lt;/p&gt;</text>
    <param>other Object to test for equality to this</param>
    <return>true if two 3D vector objects are equal, false if
 * object is null, not an instance of Vector3D, or
 * not equal to this Vector3D instance</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope>
      <declaration type="Vector3D" name="rhs" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get a hashCode for the 3D vector.
 * &lt;p&gt;
 * All NaN values have the same hash code.&lt;/p&gt;</text>
    <return>a hash code value for this object</return>
  </javadoc>
  <method type="int" name="hashCode">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * The implementation uses specific multiplication and addition
 * algorithms to preserve accuracy and reduce cancellation effects.
 * It should be very accurate even for nearly orthogonal vectors.
 * &lt;/p&gt;</text>
    <see>MathArrays#linearCombination(double,double,double,double,double,double)</see>
  </javadoc>
  <method type="double" name="dotProduct">
    <declaration type="Vector3D" name="v3" />
  </method>
  <javadoc>
    <text>Compute the cross-product of the instance with another vector.</text>
    <param>v other vector</param>
    <return>the cross product this ^ v as a new Vector3D</return>
  </javadoc>
  <method type="Vector3D" name="crossProduct">
    <declaration type="Vector3D" name="v3" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="distance1">
    <declaration type="Vector3D" name="v3" />
    <declaration type="double" name="dx" />
    <declaration type="double" name="dy" />
    <declaration type="double" name="dz" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="distance">
    <declaration type="Vector3D" name="v3" />
    <declaration type="double" name="dx" />
    <declaration type="double" name="dy" />
    <declaration type="double" name="dz" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="distanceInf">
    <declaration type="Vector3D" name="v3" />
    <declaration type="double" name="dx" />
    <declaration type="double" name="dy" />
    <declaration type="double" name="dz" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="distanceSq">
    <declaration type="Vector3D" name="v3" />
    <declaration type="double" name="dx" />
    <declaration type="double" name="dy" />
    <declaration type="double" name="dz" />
  </method>
  <javadoc>
    <text>Compute the dot-product of two vectors.</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>the dot product v1.v2</return>
  </javadoc>
  <method type="double" name="dotProduct" />
  <javadoc>
    <text>Compute the cross-product of two vectors.</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>the cross product v1 ^ v2 as a new Vector</return>
  </javadoc>
  <method type="Vector3D" name="crossProduct" />
  <javadoc>
    <text>Compute the distance between two vectors according to the L&lt;sub&gt;1&lt;/sub&gt; norm.
 * &lt;p&gt;Calling this method is equivalent to calling:
 * &lt;code&gt;v1.subtract(v2).getNorm1()&lt;/code&gt; except that no intermediate
 * vector is built&lt;/p&gt;</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>the distance between v1 and v2 according to the L&lt;sub&gt;1&lt;/sub&gt; norm</return>
  </javadoc>
  <method type="double" name="distance1" />
  <javadoc>
    <text>Compute the distance between two vectors according to the L&lt;sub&gt;2&lt;/sub&gt; norm.
 * &lt;p&gt;Calling this method is equivalent to calling:
 * &lt;code&gt;v1.subtract(v2).getNorm()&lt;/code&gt; except that no intermediate
 * vector is built&lt;/p&gt;</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>the distance between v1 and v2 according to the L&lt;sub&gt;2&lt;/sub&gt; norm</return>
  </javadoc>
  <method type="double" name="distance" />
  <javadoc>
    <text>Compute the distance between two vectors according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm.
 * &lt;p&gt;Calling this method is equivalent to calling:
 * &lt;code&gt;v1.subtract(v2).getNormInf()&lt;/code&gt; except that no intermediate
 * vector is built&lt;/p&gt;</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>the distance between v1 and v2 according to the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; norm</return>
  </javadoc>
  <method type="double" name="distanceInf" />
  <javadoc>
    <text>Compute the square of the distance between two vectors.
 * &lt;p&gt;Calling this method is equivalent to calling:
 * &lt;code&gt;v1.subtract(v2).getNormSq()&lt;/code&gt; except that no intermediate
 * vector is built&lt;/p&gt;</text>
    <param>v1 first vector</param>
    <param>v2 second vector</param>
    <return>the square of the distance between v1 and v2</return>
  </javadoc>
  <method type="double" name="distanceSq" />
  <javadoc>
    <text>Get a string representation of this vector.</text>
    <return>a string representation of this vector</return>
  </javadoc>
  <method type="String" name="toString" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="String" name="toString" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>CHECKSTYLE: stop ConstantName</comment>
  <comment>CHECKSTYLE: resume ConstantName</comment>
</class>
