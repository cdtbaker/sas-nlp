<?xml version="1.0" encoding="UTF-8"?>
<class name="MathArrays">
  <javadoc>
    <text>Arrays utilities.</text>
    <since>3.0</since>
    <version>$Id: MathArrays.java 1462423 2013-03-29 07:25:18Z luc $</version>
  </javadoc>
  <javadoc>
    <text>Factor used for splitting double numbers: n = 2^27 + 1 (i.e. {@value}).</text>
  </javadoc>
  <declaration type="int" name="SPLIT_FACTOR" />
  <javadoc>
    <text>Private constructor.</text>
  </javadoc>
  <method type="constructor" name="MathArrays" />
  <javadoc>
    <text>Real-valued function that operate on an array or a part of it.</text>
    <since>3.1</since>
  </javadoc>
  <method name="evaluate" type="double" />
  <javadoc>
    <text>Operates on an entire array.</text>
    <param>array Array to operate on.</param>
    <return>the result of the operation.</return>
  </javadoc>
  <method name="evaluate" type="double" />
  <javadoc>
    <param>array Array to operate on.</param>
    <param>startIndex Index of the first element to take into account.</param>
    <param>numElements Number of elements to take into account.</param>
    <return>the result of the operation.</return>
  </javadoc>
  <javadoc>
    <text>Create a copy of an array scaled by a value.</text>
    <param>arr Array to scale.</param>
    <param>val Scalar.</param>
    <return>scaled copy of array with each entry multiplied by val.</return>
    <since>3.2</since>
  </javadoc>
  <method type="double[]" name="scale">
    <declaration type="double[]" name="newArr" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Multiply each element of an array by a value.&lt;/p&gt;
 * &lt;p&gt;The array is modified in place (no copy is created).&lt;/p&gt;</text>
    <param>arr Array to scale</param>
    <param>val Scalar</param>
    <since>3.2</since>
  </javadoc>
  <method type="void" name="scaleInPlace">
    <scope />
  </method>
  <javadoc>
    <text>Creates an array whose contents will be the element-by-element
 * addition of the arguments.</text>
    <param>a First term of the addition.</param>
    <param>b Second term of the addition.</param>
    <return>a new array {@code r} where {@code r[i] = a[i] + b[i]}.</return>
    <throws>DimensionMismatchException if the array lengths differ.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="ebeAdd">
    <scope />
    <declaration type="double[]" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>Creates an array whose contents will be the element-by-element
 * subtraction of the second argument from the first.</text>
    <param>a First term.</param>
    <param>b Element to be subtracted.</param>
    <return>a new array {@code r} where {@code r[i] = a[i] - b[i]}.</return>
    <throws>DimensionMismatchException if the array lengths differ.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="ebeSubtract">
    <scope />
    <declaration type="double[]" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>Creates an array whose contents will be the element-by-element
 * multiplication of the arguments.</text>
    <param>a First factor of the multiplication.</param>
    <param>b Second factor of the multiplication.</param>
    <return>a new array {@code r} where {@code r[i] = a[i] * b[i]}.</return>
    <throws>DimensionMismatchException if the array lengths differ.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="ebeMultiply">
    <scope />
    <declaration type="double[]" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>Creates an array whose contents will be the element-by-element
 * division of the first argument by the second.</text>
    <param>a Numerator of the division.</param>
    <param>b Denominator of the division.</param>
    <return>a new array {@code r} where {@code r[i] = a[i] / b[i]}.</return>
    <throws>DimensionMismatchException if the array lengths differ.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="double[]" name="ebeDivide">
    <scope />
    <declaration type="double[]" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.</text>
    <param>p1 the first point</param>
    <param>p2 the second point</param>
    <return>the L&lt;sub&gt;1&lt;/sub&gt; distance between the two points</return>
  </javadoc>
  <method type="double" name="distance1">
    <declaration type="double" name="sum" />
    <scope />
  </method>
  <javadoc>
    <text>Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.</text>
    <param>p1 the first point</param>
    <param>p2 the second point</param>
    <return>the L&lt;sub&gt;1&lt;/sub&gt; distance between the two points</return>
  </javadoc>
  <method type="int" name="distance1">
    <declaration type="int" name="sum" />
    <scope />
  </method>
  <javadoc>
    <text>Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.</text>
    <param>p1 the first point</param>
    <param>p2 the second point</param>
    <return>the L&lt;sub&gt;2&lt;/sub&gt; distance between the two points</return>
  </javadoc>
  <method type="double" name="distance">
    <declaration type="double" name="sum" />
    <scope>
      <declaration type="double" name="dp" />
    </scope>
  </method>
  <javadoc>
    <text>Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.</text>
    <param>p1 the first point</param>
    <param>p2 the second point</param>
    <return>the L&lt;sub&gt;2&lt;/sub&gt; distance between the two points</return>
  </javadoc>
  <method type="double" name="distance">
    <declaration type="double" name="sum" />
    <scope>
      <declaration type="double" name="dp" />
    </scope>
  </method>
  <javadoc>
    <text>Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.</text>
    <param>p1 the first point</param>
    <param>p2 the second point</param>
    <return>the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; distance between the two points</return>
  </javadoc>
  <method type="double" name="distanceInf">
    <declaration type="double" name="max" />
    <scope />
  </method>
  <javadoc>
    <text>Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.</text>
    <param>p1 the first point</param>
    <param>p2 the second point</param>
    <return>the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; distance between the two points</return>
  </javadoc>
  <method type="int" name="distanceInf">
    <declaration type="int" name="max" />
    <scope />
  </method>
  <javadoc>
    <text>Specification of ordering direction.</text>
  </javadoc>
  <javadoc>
    <text>Constant for increasing direction.</text>
  </javadoc>
  <javadoc>
    <text>Constant for decreasing direction.</text>
  </javadoc>
  <javadoc>
    <text>Check that an array is monotonically increasing or decreasing.</text>
    <param>&lt;T&gt;
 *  the type of the elements in the specified array</param>
    <param>val Values.</param>
    <param>dir Ordering direction.</param>
    <param>strict Whether the order should be strict.</param>
    <return>{@code true} if sorted, {@code false} otherwise.</return>
  </javadoc>
  <method type="boolean" name="isMonotonic">
    <declaration type="T" name="previous" />
    <declaration type="int" name="max" />
    <scope>
      <declaration type="int" name="comp" />
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Should never happen.</comment>
  </method>
  <javadoc>
    <text>Check that an array is monotonically increasing or decreasing.</text>
    <param>val Values.</param>
    <param>dir Ordering direction.</param>
    <param>strict Whether the order should be strict.</param>
    <return>{@code true} if sorted, {@code false} otherwise.</return>
  </javadoc>
  <method type="boolean" name="isMonotonic" />
  <javadoc>
    <text>Check that the given array is sorted.</text>
    <param>val Values.</param>
    <param>dir Ordering direction.</param>
    <param>strict Whether the order should be strict.</param>
    <param>abort Whether to throw an exception if the check fails.</param>
    <return>{@code true} if the array is sorted.</return>
    <throws>NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.</throws>
  </javadoc>
  <method type="boolean" name="checkOrder">
    <declaration type="double" name="previous" />
    <declaration type="int" name="max" />
    <declaration type="int" name="index" />
    <scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <scope />
    <comment>Should never happen.</comment>
    <comment>Loop completed.</comment>
    <comment>Loop early exit means wrong ordering.</comment>
  </method>
  <javadoc>
    <text>Check that the given array is sorted.</text>
    <param>val Values.</param>
    <param>dir Ordering direction.</param>
    <param>strict Whether the order should be strict.</param>
    <throws>NonMonotonicSequenceException if the array is not sorted.</throws>
    <since>2.2</since>
  </javadoc>
  <method type="void" name="checkOrder" />
  <javadoc>
    <text>Check that the given array is sorted in strictly increasing order.</text>
    <param>val Values.</param>
    <throws>NonMonotonicSequenceException if the array is not sorted.</throws>
    <since>2.2</since>
  </javadoc>
  <method type="void" name="checkOrder" />
  <javadoc>
    <text>Throws DimensionMismatchException if the input array is not rectangular.</text>
    <param>in array to be tested</param>
    <throws>NullArgumentException if input array is null</throws>
    <throws>DimensionMismatchException if input array is not rectangular</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkRectangular">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Check that all entries of the input array are strictly positive.</text>
    <param>in Array to be tested</param>
    <throws>NotStrictlyPositiveException if any entries of the array are not
 * strictly positive.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkPositive">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Check that all entries of the input array are &gt;= 0.</text>
    <param>in Array to be tested</param>
    <throws>NotPositiveException if any array entries are less than 0.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkNonNegative">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Check all entries of the input array are &gt;= 0.</text>
    <param>in Array to be tested</param>
    <throws>NotPositiveException if any array entries are less than 0.</throws>
    <since>3.1</since>
  </javadoc>
  <method type="void" name="checkNonNegative">
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 * The redistribution policy for MINPACK is available
 * &lt;a href="http://www.netlib.org/minpack/disclaimer"&gt;here&lt;/a&gt;, for
 * convenience, it is reproduced below.&lt;/p&gt;
 * &lt;table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"&gt;
 * &lt;tr&gt;&lt;td&gt;
 * Minpack Copyright Notice (1999) University of Chicago.
 * All rights reserved
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * &lt;ol&gt;
 * &lt;li&gt;Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.&lt;/li&gt;
 * &lt;li&gt;Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.&lt;/li&gt;
 * &lt;li&gt;The end-user documentation included with the redistribution, if any,
 * must include the following acknowledgment:{@code This product includes software developed by the University of
 * Chicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself,
 * if and wherever such third-party acknowledgments normally appear.&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"
 * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 * BE CORRECTED.&lt;/strong&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 * POSSIBILITY OF SUCH LOSS OR DAMAGES.&lt;/strong&gt;&lt;/li&gt;
 * &lt;ol&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;</text>
    <param>v Vector of doubles.</param>
    <return>the 2-norm of the vector.</return>
    <since>2.2</since>
  </javadoc>
  <method type="double" name="safeNorm">
    <declaration type="double" name="rdwarf" />
    <declaration type="double" name="rgiant" />
    <declaration type="double" name="s1" />
    <declaration type="double" name="s2" />
    <declaration type="double" name="s3" />
    <declaration type="double" name="x1max" />
    <declaration type="double" name="x3max" />
    <declaration type="double" name="floatn" />
    <declaration type="double" name="agiant" />
    <scope>
      <declaration type="double" name="xabs" />
      <scope>
        <scope>
          <scope>
            <declaration type="double" name="r" />
          </scope>
          <scope>
            <declaration type="double" name="r" />
          </scope>
        </scope>
        <scope>
          <scope>
            <declaration type="double" name="r" />
          </scope>
          <scope>
            <scope>
              <declaration type="double" name="r" />
            </scope>
          </scope>
        </scope>
      </scope>
      <scope />
    </scope>
    <declaration type="double" name="norm" />
    <scope />
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Sort an array in ascending order in place and perform the same reordering
 * of entries on other arrays. For example, if{@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then{@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},{@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.</text>
    <param>x Array to be sorted and used as a pattern for permutation
 * of the other arrays.</param>
    <param>yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.</param>
    <throws>DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.</throws>
    <throws>NullArgumentException if {@code x} or any {@code y} is null.</throws>
    <since>3.0</since>
  </javadoc>
  <method type="void" name="sortInPlace" />
  <javadoc>
    <text>Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other{@link #sortInPlace(double[],double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}parameter.</text>
    <param>x Array to be sorted and used as a pattern for permutation
 * of the other arrays.</param>
    <param>dir Order direction.</param>
    <param>yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.</param>
    <throws>DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.</throws>
    <throws>NullArgumentException if {@code x} or any {@code y} is null</throws>
    <since>3.0</since>
  </javadoc>
  <method type="void" name="sortInPlace">
    <scope />
    <declaration type="int" name="len" />
    <declaration type="List&lt;Pair&lt;Double,double[]&gt;&gt;[]" name="list" />
    <declaration type="int" name="yListLen" />
    <scope>
      <declaration type="double[]" name="yValues" />
      <scope>
        <declaration type="double[]" name="y" />
        <scope />
        <scope />
      </scope>
    </scope>
    <declaration type="Comparator&lt;Pair&lt;Double,double[]&gt;&gt;[]" name="comp" />
    <method type="int" name="compare">
      <declaration type="int" name="val" />
    </method>
    <scope>
      <declaration type="Pair&lt;Double,double[]&gt;" name="e" />
      <declaration type="double[]" name="yValues" />
      <scope />
    </scope>
    <comment>Should never happen.</comment>
  </method>
  <javadoc>
    <text>Creates a copy of the {@code source} array.</text>
    <param>source Array to be copied.</param>
    <return>the copied array.</return>
  </javadoc>
  <method type="int[]" name="copyOf" />
  <javadoc>
    <text>Creates a copy of the {@code source} array.</text>
    <param>source Array to be copied.</param>
    <return>the copied array.</return>
  </javadoc>
  <method type="double[]" name="copyOf" />
  <javadoc>
    <text>Creates a copy of the {@code source} array.</text>
    <param>source Array to be copied.</param>
    <param>len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.</param>
    <return>the copied array.</return>
  </javadoc>
  <method type="int[]" name="copyOf">
    <declaration type="int[]" name="output" />
  </method>
  <javadoc>
    <text>Creates a copy of the {@code source} array.</text>
    <param>source Array to be copied.</param>
    <param>len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.</param>
    <return>the copied array.</return>
  </javadoc>
  <method type="double[]" name="copyOf">
    <declaration type="double[]" name="output" />
  </method>
  <javadoc>
    <text>Compute a linear combination accurately.
 * This method computes the sum of the products
 * &lt;code&gt;a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt; to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * &lt;br/&gt;
 * It is based on the 2005 paper
 * &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"&gt;
 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.</text>
    <param>a Factors.</param>
    <param>b Factors.</param>
    <return>&lt;code&gt;&amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.</return>
    <throws>DimensionMismatchException if arrays dimensions don't match</throws>
  </javadoc>
  <method type="double" name="linearCombination">
    <declaration type="int" name="len" />
    <scope />
    <declaration type="double[]" name="prodHigh" />
    <declaration type="double" name="prodLowSum" />
    <scope>
      <declaration type="double" name="ai" />
      <declaration type="double" name="ca" />
      <declaration type="double" name="aHigh" />
      <declaration type="double" name="aLow" />
      <declaration type="double" name="bi" />
      <declaration type="double" name="cb" />
      <declaration type="double" name="bHigh" />
      <declaration type="double" name="bLow" />
      <declaration type="double" name="prodLow" />
    </scope>
    <declaration type="double" name="prodHighCur" />
    <declaration type="double" name="prodHighNext" />
    <declaration type="double" name="sHighPrev" />
    <declaration type="double" name="sPrime" />
    <declaration type="double" name="sLowSum" />
    <declaration type="int" name="lenMinusOne" />
    <scope>
      <declaration type="double" name="sHighCur" />
    </scope>
    <declaration type="double" name="result" />
    <scope>
      <scope />
    </scope>
    <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
    <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
  </method>
  <javadoc>
    <text>Compute a linear combination accurately.
 * &lt;p&gt;
 * This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper &lt;a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"&gt;
 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * &lt;/p&gt;</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt;</return>
    <see>#linearCombination(double,double,double,double,double,double)</see>
    <see>#linearCombination(double,double,double,double,double,double,double,double)</see>
  </javadoc>
  <method type="double" name="linearCombination">
    <declaration type="double" name="ca1" />
    <declaration type="double" name="a1High" />
    <declaration type="double" name="a1Low" />
    <declaration type="double" name="cb1" />
    <declaration type="double" name="b1High" />
    <declaration type="double" name="b1Low" />
    <declaration type="double" name="prod1High" />
    <declaration type="double" name="prod1Low" />
    <declaration type="double" name="ca2" />
    <declaration type="double" name="a2High" />
    <declaration type="double" name="a2Low" />
    <declaration type="double" name="cb2" />
    <declaration type="double" name="b2High" />
    <declaration type="double" name="b2Low" />
    <declaration type="double" name="prod2High" />
    <declaration type="double" name="prod2Low" />
    <declaration type="double" name="s12High" />
    <declaration type="double" name="s12Prime" />
    <declaration type="double" name="s12Low" />
    <declaration type="double" name="result" />
    <scope />
    <comment>the code below is split in many additions/subtractions that may</comment>
    <comment>appear redundant. However, they should NOT be simplified, as they</comment>
    <comment>use IEEE754 floating point arithmetic rounding properties.</comment>
    <comment>as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1"</comment>
    <comment>The variable naming conventions are that xyzHigh contains the most significant</comment>
    <comment>bits of xyz and xyzLow contains its least significant bits. So theoretically</comment>
    <comment>xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot</comment>
    <comment>be represented in only one double precision number so we preserve two numbers</comment>
    <comment>to hold it as long as we can, combining the high and low order bits together</comment>
    <comment>only at the end, after cancellation may have occurred on high order bits</comment>
    <comment>split a1 and b1 as two 26 bits numbers</comment>
    <comment>accurate multiplication a1 * b1</comment>
    <comment>split a2 and b2 as two 26 bits numbers</comment>
    <comment>accurate multiplication a2 * b2</comment>
    <comment>accurate addition a1 * b1 + a2 * b2</comment>
    <comment>final rounding, s12 may have suffered many cancellations, we try</comment>
    <comment>to recover some bits from the extra words we have saved up to now</comment>
    <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
    <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
  </method>
  <javadoc>
    <text>Compute a linear combination accurately.
 * &lt;p&gt;
 * This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper &lt;a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"&gt;
 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * &lt;/p&gt;</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <param>a3 first factor of the third term</param>
    <param>b3 second factor of the third term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;</return>
    <see>#linearCombination(double,double,double,double)</see>
    <see>#linearCombination(double,double,double,double,double,double,double,double)</see>
  </javadoc>
  <method type="double" name="linearCombination">
    <declaration type="double" name="ca1" />
    <declaration type="double" name="a1High" />
    <declaration type="double" name="a1Low" />
    <declaration type="double" name="cb1" />
    <declaration type="double" name="b1High" />
    <declaration type="double" name="b1Low" />
    <declaration type="double" name="prod1High" />
    <declaration type="double" name="prod1Low" />
    <declaration type="double" name="ca2" />
    <declaration type="double" name="a2High" />
    <declaration type="double" name="a2Low" />
    <declaration type="double" name="cb2" />
    <declaration type="double" name="b2High" />
    <declaration type="double" name="b2Low" />
    <declaration type="double" name="prod2High" />
    <declaration type="double" name="prod2Low" />
    <declaration type="double" name="ca3" />
    <declaration type="double" name="a3High" />
    <declaration type="double" name="a3Low" />
    <declaration type="double" name="cb3" />
    <declaration type="double" name="b3High" />
    <declaration type="double" name="b3Low" />
    <declaration type="double" name="prod3High" />
    <declaration type="double" name="prod3Low" />
    <declaration type="double" name="s12High" />
    <declaration type="double" name="s12Prime" />
    <declaration type="double" name="s12Low" />
    <declaration type="double" name="s123High" />
    <declaration type="double" name="s123Prime" />
    <declaration type="double" name="s123Low" />
    <declaration type="double" name="result" />
    <scope />
    <comment>the code below is split in many additions/subtractions that may</comment>
    <comment>appear redundant. However, they should NOT be simplified, as they</comment>
    <comment>do use IEEE754 floating point arithmetic rounding properties.</comment>
    <comment>as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1"</comment>
    <comment>The variables naming conventions are that xyzHigh contains the most significant</comment>
    <comment>bits of xyz and xyzLow contains its least significant bits. So theoretically</comment>
    <comment>xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot</comment>
    <comment>be represented in only one double precision number so we preserve two numbers</comment>
    <comment>to hold it as long as we can, combining the high and low order bits together</comment>
    <comment>only at the end, after cancellation may have occurred on high order bits</comment>
    <comment>split a1 and b1 as two 26 bits numbers</comment>
    <comment>accurate multiplication a1 * b1</comment>
    <comment>split a2 and b2 as two 26 bits numbers</comment>
    <comment>accurate multiplication a2 * b2</comment>
    <comment>split a3 and b3 as two 26 bits numbers</comment>
    <comment>accurate multiplication a3 * b3</comment>
    <comment>accurate addition a1 * b1 + a2 * b2</comment>
    <comment>accurate addition a1 * b1 + a2 * b2 + a3 * b3</comment>
    <comment>final rounding, s123 may have suffered many cancellations, we try</comment>
    <comment>to recover some bits from the extra words we have saved up to now</comment>
    <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
    <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
  </method>
  <javadoc>
    <text>Compute a linear combination accurately.
 * &lt;p&gt;
 * This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
 * a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper &lt;a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"&gt;
 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * &lt;/p&gt;</text>
    <param>a1 first factor of the first term</param>
    <param>b1 second factor of the first term</param>
    <param>a2 first factor of the second term</param>
    <param>b2 second factor of the second term</param>
    <param>a3 first factor of the third term</param>
    <param>b3 second factor of the third term</param>
    <param>a4 first factor of the third term</param>
    <param>b4 second factor of the third term</param>
    <return>a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
 * a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;</return>
    <see>#linearCombination(double,double,double,double)</see>
    <see>#linearCombination(double,double,double,double,double,double)</see>
  </javadoc>
  <method type="double" name="linearCombination">
    <declaration type="double" name="ca1" />
    <declaration type="double" name="a1High" />
    <declaration type="double" name="a1Low" />
    <declaration type="double" name="cb1" />
    <declaration type="double" name="b1High" />
    <declaration type="double" name="b1Low" />
    <declaration type="double" name="prod1High" />
    <declaration type="double" name="prod1Low" />
    <declaration type="double" name="ca2" />
    <declaration type="double" name="a2High" />
    <declaration type="double" name="a2Low" />
    <declaration type="double" name="cb2" />
    <declaration type="double" name="b2High" />
    <declaration type="double" name="b2Low" />
    <declaration type="double" name="prod2High" />
    <declaration type="double" name="prod2Low" />
    <declaration type="double" name="ca3" />
    <declaration type="double" name="a3High" />
    <declaration type="double" name="a3Low" />
    <declaration type="double" name="cb3" />
    <declaration type="double" name="b3High" />
    <declaration type="double" name="b3Low" />
    <declaration type="double" name="prod3High" />
    <declaration type="double" name="prod3Low" />
    <declaration type="double" name="ca4" />
    <declaration type="double" name="a4High" />
    <declaration type="double" name="a4Low" />
    <declaration type="double" name="cb4" />
    <declaration type="double" name="b4High" />
    <declaration type="double" name="b4Low" />
    <declaration type="double" name="prod4High" />
    <declaration type="double" name="prod4Low" />
    <declaration type="double" name="s12High" />
    <declaration type="double" name="s12Prime" />
    <declaration type="double" name="s12Low" />
    <declaration type="double" name="s123High" />
    <declaration type="double" name="s123Prime" />
    <declaration type="double" name="s123Low" />
    <declaration type="double" name="s1234High" />
    <declaration type="double" name="s1234Prime" />
    <declaration type="double" name="s1234Low" />
    <declaration type="double" name="result" />
    <scope />
    <comment>the code below is split in many additions/subtractions that may</comment>
    <comment>appear redundant. However, they should NOT be simplified, as they</comment>
    <comment>do use IEEE754 floating point arithmetic rounding properties.</comment>
    <comment>as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1"</comment>
    <comment>The variables naming conventions are that xyzHigh contains the most significant</comment>
    <comment>bits of xyz and xyzLow contains its least significant bits. So theoretically</comment>
    <comment>xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot</comment>
    <comment>be represented in only one double precision number so we preserve two numbers</comment>
    <comment>to hold it as long as we can, combining the high and low order bits together</comment>
    <comment>only at the end, after cancellation may have occurred on high order bits</comment>
    <comment>split a1 and b1 as two 26 bits numbers</comment>
    <comment>accurate multiplication a1 * b1</comment>
    <comment>split a2 and b2 as two 26 bits numbers</comment>
    <comment>accurate multiplication a2 * b2</comment>
    <comment>split a3 and b3 as two 26 bits numbers</comment>
    <comment>accurate multiplication a3 * b3</comment>
    <comment>split a4 and b4 as two 26 bits numbers</comment>
    <comment>accurate multiplication a4 * b4</comment>
    <comment>accurate addition a1 * b1 + a2 * b2</comment>
    <comment>accurate addition a1 * b1 + a2 * b2 + a3 * b3</comment>
    <comment>accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4</comment>
    <comment>final rounding, s1234 may have suffered many cancellations, we try</comment>
    <comment>to recover some bits from the extra words we have saved up to now</comment>
    <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
    <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
  </method>
  <javadoc>
    <text>Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by{@link Precision#equals(float,float)}.</text>
    <param>x first array</param>
    <param>y second array</param>
    <return>true if the values are both null or have same dimension
 * and equal elements.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.</text>
    <param>x first array</param>
    <param>y second array</param>
    <return>true if the values are both null or have same dimension and
 * equal elements</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by{@link Precision#equals(double,double)}.</text>
    <param>x First array.</param>
    <param>y Second array.</param>
    <return>{@code true} if the values are both {@code null} or have same
 * dimension and equal elements.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.</text>
    <param>x First array.</param>
    <param>y Second array.</param>
    <return>{@code true} if the values are both {@code null} or have same
 * dimension and equal elements.</return>
    <since>2.2</since>
  </javadoc>
  <method type="boolean" name="equalsIncludingNaN">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation &lt;pre&gt;
 * x |-&gt; x * normalizedSum / sum
 * &lt;/pre&gt;
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.&lt;/p&gt;
 * &lt;p&gt;Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.&lt;/p&gt;
 * &lt;p&gt;Ignores (i.e., copies unchanged to the output array) NaNs in the input array.&lt;/p&gt;</text>
    <param>values Input array to be normalized</param>
    <param>normalizedSum Target sum for the normalized array</param>
    <return>the normalized array.</return>
    <throws>MathArithmeticException if the input array contains infinite
 * elements or sums to zero.</throws>
    <throws>MathIllegalArgumentException if the target sum is infinite or {@code NaN}.</throws>
    <since>2.1</since>
  </javadoc>
  <method type="double[]" name="normalizeArray">
    <scope />
    <scope />
    <declaration type="double" name="sum" />
    <declaration type="int" name="len" />
    <declaration type="double[]" name="out" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Build an array of elements.
 * &lt;p&gt;
 * Arrays are filled with field.getZero()
 * &lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>field field to which array elements belong</param>
    <param>length of the array</param>
    <return>a new array</return>
    <since>3.2</since>
  </javadoc>
  <method type="T[]" name="buildArray">
    <declaration type="T[][]" name="array" />
    <comment>OK because field must be correct class</comment>
  </method>
  <javadoc>
    <text>Build a double dimension  array of elements.
 * &lt;p&gt;
 * Arrays are filled with field.getZero()
 * &lt;/p&gt;</text>
    <param>&lt;T&gt;
 *  the type of the field elements</param>
    <param>field field to which array elements belong</param>
    <param>rows number of rows in the array</param>
    <param>columns number of columns (may be negative to build partial
 * arrays in the same way &lt;code&gt;new Field[rows][]&lt;/code&gt; works)</param>
    <return>a new array</return>
    <since>3.2</since>
  </javadoc>
  <method type="T[][]" name="buildArray">
    <declaration type="T[][]" name="array" />
    <scope>
      <declaration type="T[]" name="dummyRow" />
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
