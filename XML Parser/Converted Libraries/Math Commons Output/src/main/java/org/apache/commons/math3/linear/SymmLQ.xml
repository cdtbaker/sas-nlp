<?xml version="1.0" encoding="UTF-8"?>
<class name="SymmLQ">
  <javadoc>
    <text>&lt;p&gt;
 * Implementation of the SYMMLQ iterative linear solver proposed by &lt;a
 * href="#PAIG1975"&gt;Paige and Saunders (1975)&lt;/a&gt;. This implementation is
 * largely based on the FORTRAN code by Pr. Michael A. Saunders, available &lt;a
 * href="http://www.stanford.edu/group/SOL/software/symmlq/f77/"&gt;here&lt;/a&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * SYMMLQ is designed to solve the system of linear equations A &amp;middot; x = b
 * where A is an n &amp;times; n self-adjoint linear operator (defined as a{@link RealLinearOperator}), and b is a given vector. The operator A is not
 * required to be positive definite. If A is known to be definite, the method of
 * conjugate gradients might be preferred, since it will require about the same
 * number of iterations as SYMMLQ but slightly less work per iteration.
 * &lt;/p&gt;
 * &lt;p&gt;
 * SYMMLQ is designed to solve the system (A - shift &amp;middot; I) &amp;middot; x = b,
 * where shift is a specified scalar value. If shift and b are suitably chosen,
 * the computed vector x may approximate an (unnormalized) eigenvector of A, as
 * in the methods of inverse iteration and/or Rayleigh-quotient iteration.
 * Again, the linear operator (A - shift &amp;middot; I) need not be positive
 * definite (but &lt;em&gt;must&lt;/em&gt; be self-adjoint). The work per iteration is very
 * slightly less if shift = 0.
 * &lt;/p&gt;
 * &lt;h3&gt;Preconditioning&lt;/h3&gt;
 * &lt;p&gt;
 * Preconditioning may reduce the number of iterations required. The solver may
 * be provided with a positive definite preconditioner
 * M = P&lt;sup&gt;T&lt;/sup&gt; &amp;middot; P
 * that is known to approximate
 * (A - shift &amp;middot; I)&lt;sup&gt;-1&lt;/sup&gt; in some sense, where matrix-vector
 * products of the form M &amp;middot; y = x can be computed efficiently. Then
 * SYMMLQ will implicitly solve the system of equations
 * P &amp;middot; (A - shift &amp;middot; I) &amp;middot; P&lt;sup&gt;T&lt;/sup&gt; &amp;middot;
 * x&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; b, i.e.
 * A&lt;sub&gt;hat&lt;/sub&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt; = b&lt;sub&gt;hat&lt;/sub&gt;,
 * where
 * A&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; (A - shift &amp;middot; I) &amp;middot; P&lt;sup&gt;T&lt;/sup&gt;,
 * b&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; b,
 * and return the solution
 * x = P&lt;sup&gt;T&lt;/sup&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt;.
 * The associated residual is
 * r&lt;sub&gt;hat&lt;/sub&gt; = b&lt;sub&gt;hat&lt;/sub&gt; - A&lt;sub&gt;hat&lt;/sub&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt;
 * = P &amp;middot; [b - (A - shift &amp;middot; I) &amp;middot; x]
 * = P &amp;middot; r.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In the case of preconditioning, the {@link IterativeLinearSolverEvent}s that
 * this solver fires are such that{@link IterativeLinearSolverEvent#getNormOfResidual()} returns the norm of
 * the &lt;em&gt;preconditioned&lt;/em&gt;, updated residual, ||P &amp;middot; r||, not the norm
 * of the &lt;em&gt;true&lt;/em&gt; residual ||r||.
 * &lt;/p&gt;
 * &lt;h3&gt;&lt;a id="stopcrit"&gt;Default stopping criterion&lt;/a&gt;&lt;/h3&gt;
 * &lt;p&gt;
 * A default stopping criterion is implemented. The iterations stop when || rhat
 * || &amp;le; &amp;delta; || Ahat || || xhat ||, where xhat is the current estimate of
 * the solution of the transformed system, rhat the current estimate of the
 * corresponding residual, and &amp;delta; a user-specified tolerance.
 * &lt;/p&gt;
 * &lt;h3&gt;Iteration count&lt;/h3&gt;
 * &lt;p&gt;
 * In the present context, an iteration should be understood as one evaluation
 * of the matrix-vector product A &amp;middot; x. The initialization phase therefore
 * counts as one iteration. If the user requires checks on the symmetry of A,
 * this entails one further matrix-vector product in the initial phase. This
 * further product is &lt;em&gt;not&lt;/em&gt; accounted for in the iteration count. In
 * other words, the number of iterations required to reach convergence will be
 * identical, whether checks have been required or not.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The present definition of the iteration count differs from that adopted in
 * the original FOTRAN code, where the initialization phase was &lt;em&gt;not&lt;/em&gt;
 * taken into account.
 * &lt;/p&gt;
 * &lt;h3&gt;&lt;a id="initguess"&gt;Initial guess of the solution&lt;/a&gt;&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code x} parameter in
 * &lt;ul&gt;
 * &lt;li&gt;{@link #solve(RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
 * &lt;li&gt;{@link #solve(RealLinearOperator,RealLinearOperator,RealVector,RealVector)}},&lt;/li&gt;
 * &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
 * &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
 * &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealLinearOperator,RealVector,RealVector,boolean,double)},&lt;/li&gt;
 * &lt;/ul&gt;
 * should not be considered as an initial guess, as it is set to zero in the
 * initial phase. If x&lt;sub&gt;0&lt;/sub&gt; is known to be a good approximation to x, one
 * should compute r&lt;sub&gt;0&lt;/sub&gt; = b - A &amp;middot; x, solve A &amp;middot; dx = r0,
 * and set x = x&lt;sub&gt;0&lt;/sub&gt; + dx.
 * &lt;/p&gt;
 * &lt;h3&gt;&lt;a id="context"&gt;Exception context&lt;/a&gt;&lt;/h3&gt;
 * &lt;p&gt;
 * Besides standard {@link DimensionMismatchException}, this class might throw{@link NonSelfAdjointOperatorException} if the linear operator or the
 * preconditioner are not symmetric. In this case, the {@link ExceptionContext}provides more information
 * &lt;ul&gt;
 * &lt;li&gt;key {@code "operator"} points to the offending linear operator, say L,&lt;/li&gt;
 * &lt;li&gt;key {@code "vector1"} points to the first offending vector, say x,
 * &lt;li&gt;key {@code "vector2"} points to the second offending vector, say y, such
 * that x&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L &amp;middot; y &amp;ne; y&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L
 * &amp;middot; x (within a certain accuracy).&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;p&gt;{@link NonPositiveDefiniteOperatorException} might also be thrown in case the
 * preconditioner is not positive definite. The relevant keys to the{@link ExceptionContext} are
 * &lt;ul&gt;
 * &lt;li&gt;key {@code "operator"}, which points to the offending linear operator,
 * say L,&lt;/li&gt;
 * &lt;li&gt;key {@code "vector"}, which points to the offending vector, say x, such
 * that x&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L &amp;middot; x &lt; 0.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;h3&gt;References&lt;/h3&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;a id="PAIG1975"&gt;Paige and Saunders (1975)&lt;/a&gt;&lt;/dt&gt;
 * &lt;dd&gt;C. C. Paige and M. A. Saunders, &lt;a
 * href="http://www.stanford.edu/group/SOL/software/symmlq/PS75.pdf"&gt;&lt;em&gt;
 * Solution of Sparse Indefinite Systems of Linear Equations&lt;/em&gt;&lt;/a&gt;, SIAM
 * Journal on Numerical Analysis 12(4): 617-629, 1975&lt;/dd&gt;
 * &lt;/dl&gt;</text>
    <version>$Id: SymmLQ.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * A simple container holding the non-final variables used in the
 * iterations. Making the current state of the solver visible from the
 * outside is necessary, because during the iterations, {@code x} does not
 * &lt;em&gt;exactly&lt;/em&gt; hold the current estimate of the solution. Indeed,{@code x} needs in general to be moved from the LQ point to the CG point.
 * Besides, additional upudates must be carried out in case {@code goodb} is
 * set to {@code true}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In all subsequent comments, the description of the state variables refer
 * to their value after a call to {@link #update()}. In these comments, k is
 * the current number of evaluations of matrix-vector products.
 * &lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>The cubic root of {@link #MACH_PREC}.</text>
  </javadoc>
  <declaration type="double" name="CBRT_MACH_PREC" />
  <javadoc>
    <text>The machine precision.</text>
  </javadoc>
  <declaration type="double" name="MACH_PREC" />
  <javadoc>
    <text>Reference to the linear operator.</text>
  </javadoc>
  <declaration type="RealLinearOperator" name="a" />
  <javadoc>
    <text>Reference to the right-hand side vector.</text>
  </javadoc>
  <declaration type="RealVector" name="b" />
  <javadoc>
    <text>{@code true} if symmetry of matrix and conditioner must be checked.</text>
  </javadoc>
  <declaration type="boolean" name="check" />
  <javadoc>
    <text>The value of the custom tolerance &amp;delta; for the default stopping
 * criterion.</text>
  </javadoc>
  <declaration type="double" name="delta" />
  <javadoc>
    <text>The value of beta[k+1].</text>
  </javadoc>
  <declaration type="double" name="beta" />
  <javadoc>
    <text>The value of beta[1].</text>
  </javadoc>
  <declaration type="double" name="beta1" />
  <javadoc>
    <text>The value of bstep[k-1].</text>
  </javadoc>
  <declaration type="double" name="bstep" />
  <javadoc>
    <text>The estimate of the norm of P * rC[k].</text>
  </javadoc>
  <declaration type="double" name="cgnorm" />
  <javadoc>
    <text>The value of dbar[k+1] = -beta[k+1] * c[k-1].</text>
  </javadoc>
  <declaration type="double" name="dbar" />
  <javadoc>
    <text>The value of gamma[k] * zeta[k]. Was called {@code rhs1} in the
 * initial code.</text>
  </javadoc>
  <declaration type="double" name="gammaZeta" />
  <javadoc>
    <text>The value of gbar[k].</text>
  </javadoc>
  <declaration type="double" name="gbar" />
  <javadoc>
    <text>The value of max(|alpha[1]|, gamma[1], ..., gamma[k-1]).</text>
  </javadoc>
  <declaration type="double" name="gmax" />
  <javadoc>
    <text>The value of min(|alpha[1]|, gamma[1], ..., gamma[k-1]).</text>
  </javadoc>
  <declaration type="double" name="gmin" />
  <javadoc>
    <text>Copy of the {@code goodb} parameter.</text>
  </javadoc>
  <declaration type="boolean" name="goodb" />
  <javadoc>
    <text>{@code true} if the default convergence criterion is verified.</text>
  </javadoc>
  <declaration type="boolean" name="hasConverged" />
  <javadoc>
    <text>The estimate of the norm of P * rL[k-1].</text>
  </javadoc>
  <declaration type="double" name="lqnorm" />
  <javadoc>
    <text>Reference to the preconditioner, M.</text>
  </javadoc>
  <declaration type="RealLinearOperator" name="m" />
  <javadoc>
    <text>The value of (-eps[k+1] * zeta[k-1]). Was called {@code rhs2} in the
 * initial code.</text>
  </javadoc>
  <declaration type="double" name="minusEpsZeta" />
  <javadoc>
    <text>The value of M * b.</text>
  </javadoc>
  <declaration type="RealVector" name="mb" />
  <javadoc>
    <text>The value of beta[k].</text>
  </javadoc>
  <declaration type="double" name="oldb" />
  <javadoc>
    <text>The value of beta[k] * M^(-1) * P' * v[k].</text>
  </javadoc>
  <declaration type="RealVector" name="r1" />
  <javadoc>
    <text>The value of beta[k+1] * M^(-1) * P' * v[k+1].</text>
  </javadoc>
  <declaration type="RealVector" name="r2" />
  <javadoc>
    <text>The value of the updated, preconditioned residual P * r. This value is
 * given by {@code min(}{@link #cgnorm}{@code , }{@link #lqnorm}{@code )}.</text>
  </javadoc>
  <declaration type="double" name="rnorm" />
  <javadoc>
    <text>Copy of the {@code shift} parameter.</text>
  </javadoc>
  <declaration type="double" name="shift" />
  <javadoc>
    <text>The value of s[1] * ... * s[k-1].</text>
  </javadoc>
  <declaration type="double" name="snprod" />
  <javadoc>
    <text>An estimate of the square of the norm of A * V[k], based on Paige and
 * Saunders (1975), equation (3.3).</text>
  </javadoc>
  <declaration type="double" name="tnorm" />
  <javadoc>
    <text>The value of P' * wbar[k] or P' * (wbar[k] - s[1] * ... * s[k-1] 
 * v[1]) if {@code goodb} is {@code true}. Was called {@code w} in the
 * initial code.</text>
  </javadoc>
  <declaration type="RealVector" name="wbar" />
  <javadoc>
    <text>A reference to the vector to be updated with the solution. Contains
 * the value of xL[k-1] if {@code goodb} is {@code false}, (xL[k-1] -
 * bstep[k-1] * v[1]) otherwise.</text>
  </javadoc>
  <declaration type="RealVector" name="xL" />
  <javadoc>
    <text>The value of beta[k+1] * P' * v[k+1].</text>
  </javadoc>
  <declaration type="RealVector" name="y" />
  <javadoc>
    <text>The value of zeta[1]^2 + ... + zeta[k-1]^2.</text>
  </javadoc>
  <declaration type="double" name="ynorm2" />
  <javadoc>
    <text>The value of {@code b == 0} (exact floating-point equality).</text>
  </javadoc>
  <declaration type="boolean" name="bIsNull" />
  <scope />
  <javadoc>
    <text>Creates and inits to k = 1 a new instance of this class.</text>
    <param>a the linear operator A of the system</param>
    <param>m the preconditioner, M (can be {@code null})</param>
    <param>b the right-hand side vector</param>
    <param>goodb usually {@code false}, except if {@code x} is expected
 * to contain a large multiple of {@code b}</param>
    <param>shift the amount to be subtracted to all diagonal elements of
 * A</param>
    <param>delta the &amp;delta; parameter for the default stopping criterion</param>
    <param>check {@code true} if self-adjointedness of both matrix and
 * preconditioner should be checked</param>
  </javadoc>
  <method type="constructor" name="State" />
  <javadoc>
    <text>Performs a symmetry check on the specified linear operator, and throws an
 * exception in case this check fails. Given a linear operator L, and a
 * vector x, this method checks that
 * x' &amp;middot; L &amp;middot; y = y' &amp;middot; L &amp;middot; x
 * (within a given accuracy), where y = L &amp;middot; x.</text>
    <param>l the linear operator L</param>
    <param>x the candidate vector x</param>
    <param>y the candidate vector y = L &amp;middot; x</param>
    <param>z the vector z = L &amp;middot; y</param>
    <throws>NonSelfAdjointOperatorException when the test fails</throws>
  </javadoc>
  <method type="void" name="checkSymmetry">
    <declaration type="double" name="s" />
    <declaration type="double" name="t" />
    <declaration type="double" name="epsa" />
    <scope>
      <declaration type="NonSelfAdjointOperatorException" name="e" />
      <declaration type="ExceptionContext" name="context" />
    </scope>
  </method>
  <javadoc>
    <text>Throws a new {@link NonPositiveDefiniteOperatorException} with
 * appropriate context.</text>
    <param>l the offending linear operator</param>
    <param>v the offending vector</param>
    <throws>NonPositiveDefiniteOperatorException in any circumstances</throws>
  </javadoc>
  <method type="void" name="throwNPDLOException">
    <declaration type="NonPositiveDefiniteOperatorException" name="e" />
    <declaration type="ExceptionContext" name="context" />
  </method>
  <javadoc>
    <text>A clone of the BLAS {@code DAXPY} function, which carries out the
 * operation y &amp;larr; a &amp;middot; x + y. This is for internal use only: no
 * dimension checks are provided.</text>
    <param>a the scalar by which {@code x} is to be multiplied</param>
    <param>x the vector to be added to {@code y}</param>
    <param>y the vector to be incremented</param>
  </javadoc>
  <method type="void" name="daxpy">
    <declaration type="int" name="n" />
    <scope />
  </method>
  <javadoc>
    <text>A BLAS-like function, for the operation z &amp;larr; a &amp;middot; x + b
 * &amp;middot; y + z. This is for internal use only: no dimension checks are
 * provided.</text>
    <param>a the scalar by which {@code x} is to be multiplied</param>
    <param>x the first vector to be added to {@code z}</param>
    <param>b the scalar by which {@code y} is to be multiplied</param>
    <param>y the second vector to be added to {@code z}</param>
    <param>z the vector to be incremented</param>
  </javadoc>
  <method type="void" name="daxpbypz">
    <declaration type="int" name="n" />
    <scope>
      <declaration type="double" name="zi" />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Move to the CG point if it seems better. In this version of SYMMLQ,
 * the convergence tests involve only cgnorm, so we're unlikely to stop
 * at an LQ point, except if the iteration limit interferes.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Additional upudates are also carried out in case {@code goodb} is set
 * to {@code true}.
 * &lt;/p&gt;</text>
    <param>x the vector to be updated with the refined value of xL</param>
  </javadoc>
  <method type="void" name="refineSolution">
    <declaration type="int" name="n" />
    <scope>
      <scope />
      <scope>
        <declaration type="double" name="step" />
        <scope>
          <declaration type="double" name="bi" />
          <declaration type="double" name="xi" />
        </scope>
      </scope>
    </scope>
    <scope>
      <declaration type="double" name="anorm" />
      <declaration type="double" name="diag" />
      <declaration type="double" name="zbar" />
      <declaration type="double" name="step" />
      <scope>
        <scope>
          <declaration type="double" name="xi" />
          <declaration type="double" name="wi" />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="xi" />
          <declaration type="double" name="wi" />
          <declaration type="double" name="bi" />
        </scope>
      </scope>
    </scope>
    <comment>ynorm = FastMath.sqrt(ynorm2 + zbar * zbar);</comment>
  </method>
  <javadoc>
    <text>Performs the initial phase of the SYMMLQ algorithm. On return, the
 * value of the state variables of {@code this} object correspond to k =
 * 1.</text>
  </javadoc>
  <method type="void" name="init">
    <scope />
    <scope />
    <scope />
    <declaration type="RealVector" name="v" />
    <scope />
    <declaration type="double" name="alpha" />
    <declaration type="double" name="vty" />
    <declaration type="double" name="vtv" />
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>Set up y for the first Lanczos vector. y and beta1 will be zero
 if b = 0.</comment>
    <comment>If b = 0 exactly, stop with x = 0.</comment>
    <comment>At this point
   r1 = b,
   y = M  b,
   beta1 = beta[1].</comment>
    <comment>Set up y for the second Lanczos vector. y and beta will be zero
 or very small if b is an eigenvector.</comment>
    <comment>At this point
   alpha = alpha[1]
   y     = beta[2]  M^(-1)  P'  v[2]</comment>
    <comment>Make sure r2 will be orthogonal to the first v.</comment>
    <comment>At this point
   oldb = beta[1]
   beta = beta[2]
   y  = beta[2]  P'  v[2]
   r2 = beta[2]  M^(-1)  P'  v[2]</comment>
  </method>
  <javadoc>
    <text>Performs the next iteration of the algorithm. The iteration count
 * should be incremented prior to calling this method. On return, the
 * value of the state variables of {@code this} object correspond to the
 * current iteration count {@code k}.</text>
  </javadoc>
  <method type="void" name="update">
    <declaration type="RealVector" name="v" />
    <declaration type="double" name="alpha" />
    <scope />
    <scope />
    <declaration type="double" name="gamma" />
    <declaration type="double" name="c" />
    <declaration type="double" name="s" />
    <declaration type="double" name="deltak" />
    <declaration type="double" name="eps" />
    <declaration type="double" name="zeta" />
    <declaration type="double" name="zetaC" />
    <declaration type="double" name="zetaS" />
    <declaration type="int" name="n" />
    <scope>
      <declaration type="double" name="xi" />
      <declaration type="double" name="vi" />
      <declaration type="double" name="wi" />
    </scope>
    <comment>At this point
   v     = P'  v[k],
   y     = (A - shift  I)  P'  v[k] - beta[k]  M^(-1)  P'  v[k-1],
   alpha = v'[k]  P  (A - shift  I)  P'  v[k]
           - beta[k]  v[k]'  P  M^(-1)  P'  v[k-1]
         = v'[k]  P  (A - shift  I)  P'  v[k]
           - beta[k]  v[k]'  v[k-1]
         = alpha[k].</comment>
    <comment>At this point
   y = (A - shift  I)  P'  v[k] - alpha[k]  M^(-1)  P'  v[k]
       - beta[k]  M^(-1)  P'  v[k-1]
     = M^(-1)  P'  (P  (A - shift  I)  P'  v[k] -alpha[k]  v[k]
       - beta[k]  v[k-1])
     = beta[k+1]  M^(-1)  P'  v[k+1],
 from Paige and Saunders (1975), equation (3.2).

 WATCH-IT: the two following lines work only because y is no longer
 updated up to the end of the present iteration, and is
 reinitialized at the beginning of the next iteration.</comment>
    <comment>At this point
   r1 = beta[k]  M^(-1)  P'  v[k],
   r2 = beta[k+1]  M^(-1)  P'  v[k+1],
   y  = beta[k+1]  P'  v[k+1],
   oldb = beta[k],
   beta = beta[k+1].</comment>
    <comment>Compute the next plane rotation for Q. See Paige and Saunders
 (1975), equation (5.6), with
   gamma = gamma[k-1],
   c     = c[k-1],
   s     = s[k-1].</comment>
    <comment>The relations
   gbar[k] = s[k-1]  (-c[k-2]  beta[k]) - c[k-1]  alpha[k]
           = s[k-1]  dbar[k] - c[k-1]  alpha[k],
   delta[k] = c[k-1]  dbar[k] + s[k-1]  alpha[k],
 are not stated in Paige and Saunders (1975), but can be retrieved
 by expanding the (k, k-1) and (k, k) coefficients of the matrix in
 equation (5.5).</comment>
    <comment>At this point
   gbar   = gbar[k]
   deltak = delta[k]
   eps    = eps[k+1]
   dbar   = dbar[k+1]
   zeta   = zeta[k-1]</comment>
    <comment>At this point
   x = xL[k-1],
   ptwbar = P' wbar[k],
 see Paige and Saunders (1975), equations (5.9) and (5.10).</comment>
    <comment>At this point
   snprod       = s[1]  ...  s[k-1],
   gmax         = max(|alpha[1]|, gamma[1], ..., gamma[k-1]),
   gmin         = min(|alpha[1]|, gamma[1], ..., gamma[k-1]),
   ynorm2       = zeta[1]^2 + ... + zeta[k-1]^2,
   gammaZeta    = gamma[k]  zeta[k],
   minusEpsZeta = -eps[k+1]  zeta[k-1].
 The relation for gammaZeta can be retrieved from Paige and
 Saunders (1975), equation (5.4a), last line of the vector
 gbar[k]  zbar[k] = -eps[k]  zeta[k-2] - delta[k]  zeta[k-1].</comment>
  </method>
  <javadoc>
    <text>Computes the norms of the residuals, and checks for convergence.
 * Updates {@link #lqnorm} and {@link #cgnorm}.</text>
  </javadoc>
  <method type="void" name="updateNorms">
    <declaration type="double" name="anorm" />
    <declaration type="double" name="ynorm" />
    <declaration type="double" name="epsa" />
    <declaration type="double" name="epsx" />
    <declaration type="double" name="epsr" />
    <declaration type="double" name="diag" />
    <declaration type="double" name="qrnorm" />
    <declaration type="double" name="acond" />
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>Estimate cond(A). In this version we look at the diagonals of L
 in the factorization of the tridiagonal matrix, T = L  Q.
 Sometimes, T[k] can be misleadingly ill-conditioned when T[k+1]
 is not, so we must be careful not to overestimate acond.</comment>
    <comment>x has converged to an eigenvector of A corresponding to the
 eigenvalue shift.</comment>
  </method>
  <javadoc>
    <text>Returns {@code true} if the default stopping criterion is fulfilled.</text>
    <return>{@code true} if convergence of the iterations has occured</return>
  </javadoc>
  <method type="boolean" name="hasConverged" />
  <javadoc>
    <text>Returns {@code true} if the right-hand side vector is zero exactly.</text>
    <return>the boolean value of {@code b == 0}</return>
  </javadoc>
  <method type="boolean" name="bEqualsNullVector" />
  <javadoc>
    <text>Returns {@code true} if {@code beta} is essentially zero. This method
 * is used to check for early stop of the iterations.</text>
    <return>{@code true} if {@code beta &lt; }{@link #MACH_PREC}</return>
  </javadoc>
  <method type="boolean" name="betaEqualsZero" />
  <javadoc>
    <text>Returns the norm of the updated, preconditioned residual.</text>
    <return>the norm of the residual, ||P * r||</return>
  </javadoc>
  <method type="double" name="getNormOfResidual" />
  <javadoc>
    <text>Key for the exception context.</text>
  </javadoc>
  <declaration type="String" name="OPERATOR" />
  <javadoc>
    <text>Key for the exception context.</text>
  </javadoc>
  <declaration type="String" name="THRESHOLD" />
  <javadoc>
    <text>Key for the exception context.</text>
  </javadoc>
  <declaration type="String" name="VECTOR" />
  <javadoc>
    <text>Key for the exception context.</text>
  </javadoc>
  <declaration type="String" name="VECTOR1" />
  <javadoc>
    <text>Key for the exception context.</text>
  </javadoc>
  <declaration type="String" name="VECTOR2" />
  <javadoc>
    <text>{@code true} if symmetry of matrix and conditioner must be checked.</text>
  </javadoc>
  <declaration type="boolean" name="check" />
  <javadoc>
    <text>The value of the custom tolerance &amp;delta; for the default stopping
 * criterion.</text>
  </javadoc>
  <declaration type="double" name="delta" />
  <javadoc>
    <text>Creates a new instance of this class, with &lt;a href="#stopcrit"&gt;default
 * stopping criterion&lt;/a&gt;. Note that setting {@code check} to {@code true}entails an extra matrix-vector product in the initial phase.</text>
    <param>maxIterations the maximum number of iterations</param>
    <param>delta the &amp;delta; parameter for the default stopping criterion</param>
    <param>check {@code true} if self-adjointedness of both matrix and
 * preconditioner should be checked</param>
  </javadoc>
  <method type="constructor" name="SymmLQ" />
  <javadoc>
    <text>Creates a new instance of this class, with &lt;a href="#stopcrit"&gt;default
 * stopping criterion&lt;/a&gt; and custom iteration manager. Note that setting{@code check} to {@code true} entails an extra matrix-vector product in
 * the initial phase.</text>
    <param>manager the custom iteration manager</param>
    <param>delta the &amp;delta; parameter for the default stopping criterion</param>
    <param>check {@code true} if self-adjointedness of both matrix and
 * preconditioner should be checked</param>
  </javadoc>
  <method type="constructor" name="SymmLQ" />
  <javadoc>
    <text>Returns {@code true} if symmetry of the matrix, and symmetry as well as
 * positive definiteness of the preconditioner should be checked.</text>
    <return>{@code true} if the tests are to be performed</return>
  </javadoc>
  <method type="boolean" name="getCheck" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint</throws>
    <throws>NonPositiveDefiniteOperatorException if {@code m} is not
 * positive definite</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solve">
    <declaration type="RealVector" name="x" />
  </method>
  <javadoc>
    <text>Returns an estimate of the solution to the linear system (A - shift
 * &amp;middot; I) &amp;middot; x = b.
 * &lt;p&gt;
 * If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
 * achieved with {@code goodb} set to {@code true}; this however requires an
 * extra call to the preconditioner.
 * &lt;/p&gt;
 * &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
 * solved. Otherwise, it could be an approximation to an eigenvalue of A,
 * such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
 * (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
 * sufficiently like an eigenvector corresponding to an eigenvalue near
 * shift, then the computed x may have very large components. When
 * normalized, x may be closer to an eigenvector than b.
 * &lt;/p&gt;</text>
    <param>a the linear operator A of the system</param>
    <param>m the preconditioner, M (can be {@code null})</param>
    <param>b the right-hand side vector</param>
    <param>goodb usually {@code false}, except if {@code x} is expected to
 * contain a large multiple of {@code b}</param>
    <param>shift the amount to be subtracted to all diagonal elements of A</param>
    <return>a reference to {@code x} (shallow copy)</return>
    <throws>NullArgumentException if one of the parameters is {@code null}</throws>
    <throws>NonSquareOperatorException if {@code a} or {@code m} is not square</throws>
    <throws>DimensionMismatchException if {@code m} or {@code b} have dimensions
 * inconsistent with {@code a}</throws>
    <throws>MaxCountExceededException at exhaustion of the iteration count,
 * unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}</throws>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint</throws>
    <throws>NonPositiveDefiniteOperatorException if {@code m} is not
 * positive definite</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solve">
    <declaration type="RealVector" name="x" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>x not meaningful in this implementation; should not be considered
 * as an initial guess (&lt;a href="#initguess"&gt;more&lt;/a&gt;)</param>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint</throws>
    <throws>NonPositiveDefiniteOperatorException if {@code m} is not positive
 * definite</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solve" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solve">
    <declaration type="RealVector" name="x" />
  </method>
  <javadoc>
    <text>Returns the solution to the system (A - shift &amp;middot; I) &amp;middot; x = b.
 * &lt;p&gt;
 * If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
 * achieved with {@code goodb} set to {@code true}.
 * &lt;/p&gt;
 * &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
 * solved. Otherwise, it could be an approximation to an eigenvalue of A,
 * such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
 * (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
 * sufficiently like an eigenvector corresponding to an eigenvalue near
 * shift, then the computed x may have very large components. When
 * normalized, x may be closer to an eigenvector than b.
 * &lt;/p&gt;</text>
    <param>a the linear operator A of the system</param>
    <param>b the right-hand side vector</param>
    <param>goodb usually {@code false}, except if {@code x} is expected to
 * contain a large multiple of {@code b}</param>
    <param>shift the amount to be subtracted to all diagonal elements of A</param>
    <return>a reference to {@code x}</return>
    <throws>NullArgumentException if one of the parameters is {@code null}</throws>
    <throws>NonSquareOperatorException if {@code a} is not square</throws>
    <throws>DimensionMismatchException if {@code b} has dimensions
 * inconsistent with {@code a}</throws>
    <throws>MaxCountExceededException at exhaustion of the iteration count,
 * unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}</throws>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solve">
    <declaration type="RealVector" name="x" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>x not meaningful in this implementation; should not be considered
 * as an initial guess (&lt;a href="#initguess"&gt;more&lt;/a&gt;)</param>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solve" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>x the vector to be updated with the solution; {@code x} should
 * not be considered as an initial guess (&lt;a href="#initguess"&gt;more&lt;/a&gt;)</param>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint</throws>
    <throws>NonPositiveDefiniteOperatorException if {@code m} is not
 * positive definite</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solveInPlace" />
  <javadoc>
    <text>Returns an estimate of the solution to the linear system (A - shift
 * &amp;middot; I) &amp;middot; x = b. The solution is computed in-place.
 * &lt;p&gt;
 * If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
 * achieved with {@code goodb} set to {@code true}; this however requires an
 * extra call to the preconditioner.
 * &lt;/p&gt;
 * &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
 * solved. Otherwise, it could be an approximation to an eigenvalue of A,
 * such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
 * (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
 * sufficiently like an eigenvector corresponding to an eigenvalue near
 * shift, then the computed x may have very large components. When
 * normalized, x may be closer to an eigenvector than b.
 * &lt;/p&gt;</text>
    <param>a the linear operator A of the system</param>
    <param>m the preconditioner, M (can be {@code null})</param>
    <param>b the right-hand side vector</param>
    <param>x the vector to be updated with the solution; {@code x} should
 * not be considered as an initial guess (&lt;a href="#initguess"&gt;more&lt;/a&gt;)</param>
    <param>goodb usually {@code false}, except if {@code x} is expected to
 * contain a large multiple of {@code b}</param>
    <param>shift the amount to be subtracted to all diagonal elements of A</param>
    <return>a reference to {@code x} (shallow copy).</return>
    <throws>NullArgumentException if one of the parameters is {@code null}</throws>
    <throws>NonSquareOperatorException if {@code a} or {@code m} is not square</throws>
    <throws>DimensionMismatchException if {@code m}, {@code b} or {@code x}have dimensions inconsistent with {@code a}.</throws>
    <throws>MaxCountExceededException at exhaustion of the iteration count,
 * unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}</throws>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint</throws>
    <throws>NonPositiveDefiniteOperatorException if {@code m} is not positive
 * definite</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solveInPlace">
    <declaration type="IterationManager" name="manager" />
    <declaration type="State" name="state" />
    <declaration type="IterativeLinearSolverEvent" name="event" />
    <scope />
    <declaration type="boolean" name="earlyStop" />
    <scope>
      <scope />
    </scope>
    <comment>Initialization counts as an iteration.</comment>
    <comment>If b = 0 exactly, stop with x = 0.</comment>
    <comment>Cause termination if beta is essentially zero.</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>x the vector to be updated with the solution; {@code x} should
 * not be considered as an initial guess (&lt;a href="#initguess"&gt;more&lt;/a&gt;)</param>
    <throws>NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint</throws>
    <throws>IllConditionedOperatorException if {@code a} is ill-conditioned</throws>
  </javadoc>
  <method type="RealVector" name="solveInPlace" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>IMPLEMENTATION NOTES
 --------------------
 The implementation follows as closely as possible the notations of Paige
 and Saunders (1975). Attention must be paid to the fact that some
 quantities which are relevant to iteration k can only be computed in
 iteration (k+1). Therefore, minute attention must be paid to the index of
 each state variable of this algorithm.

 1. Preconditioning
    ---------------
 The Lanczos iterations associated with Ahat and bhat read
   beta[1] = ||P  b||
   v[1] = P  b  beta[1]
   beta[k+1]  v[k+1] = Ahat  v[k] - alpha[k]  v[k] - beta[k]  v[k-1]
                      = P  (A - shift  I)  P'  v[k] - alpha[k]  v[k]
                        - beta[k]  v[k-1]
 Multiplying both sides by P', we get
   beta[k+1]  (P'  v)[k+1] = M  (A - shift  I)  (P'  v)[k]
                               - alpha[k]  (P'  v)[k]
                               - beta[k]  (P'  v[k-1]),
 and
   alpha[k+1] = v[k+1]'  Ahat  v[k+1]
              = v[k+1]'  P  (A - shift  I)  P'  v[k+1]
              = (P'  v)[k+1]'  (A - shift  I)  (P'  v)[k+1].

 In other words, the Lanczos iterations are unchanged, except for the fact
 that we really compute (P'  v) instead of v. It can easily be checked
 that all other formulas are unchanged. It must be noted that P is never
 explicitly used, only matrix-vector products involving are invoked.

 2. Accounting for the shift parameter
    ----------------------------------
 Is trivial: each time A.operate(x) is invoked, one must subtract shift  x
 to the result.

 3. Accounting for the goodb flag
    -----------------------------
 When goodb is set to true, the component of xL along b is computed
 separately. From Paige and Saunders (1975), equation (5.9), we have
   wbar[k+1] = s[k]  wbar[k] - c[k]  v[k+1],
   wbar[1] = v[1].
 Introducing wbar2[k] = wbar[k] - s[1]  ...  s[k-1]  v[1], it can
 easily be verified by induction that wbar2 follows the same recursive
 relation
   wbar2[k+1] = s[k]  wbar2[k] - c[k]  v[k+1],
   wbar2[1] = 0,
 and we then have
   w[k] = c[k]  wbar2[k] + s[k]  v[k+1]
          + s[1]  ...  s[k-1]  c[k]  v[1].
 Introducing w2[k] = w[k] - s[1]  ...  s[k-1]  c[k]  v[1], we find,
 from (5.10)
   xL[k] = zeta[1]  w[1] + ... + zeta[k]  w[k]
         = zeta[1]  w2[1] + ... + zeta[k]  w2[k]
           + (s[1]  c[2]  zeta[2] + ...
           + s[1]  ...  s[k-1]  c[k]  zeta[k])  v[1]
         = xL2[k] + bstep[k]  v[1],
 where xL2[k] is defined by
   xL2[0] = 0,
   xL2[k+1] = xL2[k] + zeta[k+1]  w2[k+1],
 and bstep is defined by
   bstep[1] = 0,
   bstep[k] = bstep[k-1] + s[1]  ...  s[k-1]  c[k]  zeta[k].
 We also have, from (5.11)
   xC[k] = xL[k-1] + zbar[k]  wbar[k]
         = xL2[k-1] + zbar[k]  wbar2[k]
           + (bstep[k-1] + s[1]  ...  s[k-1]  zbar[k])  v[1].</comment>
</class>
