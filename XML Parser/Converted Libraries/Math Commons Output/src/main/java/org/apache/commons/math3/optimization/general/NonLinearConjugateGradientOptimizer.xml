<?xml version="1.0" encoding="UTF-8"?>
<class name="NonLinearConjugateGradientOptimizer">
  <javadoc>
    <text>Non-linear conjugate gradient optimizer.
 * &lt;p&gt;
 * This class supports both the Fletcher-Reeves and the Polak-Ribi&amp;egrave;re
 * update formulas for the conjugate search directions. It also supports
 * optional preconditioning.
 * &lt;/p&gt;</text>
    <version>$Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $</version>
    <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Update formula for the beta parameter.</text>
  </javadoc>
  <declaration type="ConjugateGradientFormula" name="updateFormula" />
  <javadoc>
    <text>Preconditioner (may be null).</text>
  </javadoc>
  <declaration type="Preconditioner" name="preconditioner" />
  <javadoc>
    <text>solver to use in the line search (may be null).</text>
  </javadoc>
  <declaration type="UnivariateSolver" name="solver" />
  <javadoc>
    <text>Initial step used to bracket the optimum in line search.</text>
  </javadoc>
  <declaration type="double" name="initialStep" />
  <javadoc>
    <text>Current point.</text>
  </javadoc>
  <declaration type="double[]" name="point" />
  <javadoc>
    <text>Constructor with default {@link SimpleValueChecker checker},{@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.</text>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
    <deprecated>See {@link SimpleValueChecker#SimpleValueChecker()}</deprecated>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <text>Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.</text>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
    <param>checker Convergence checker.</param>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <text>Constructor with default {@link IdentityPreconditioner preconditioner}.</text>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
    <param>checker Convergence checker.</param>
    <param>lineSearchSolver Solver to use during line search.</param>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <param>updateFormula formula to use for updating the &amp;beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
    <param>checker Convergence checker.</param>
    <param>lineSearchSolver Solver to use during line search.</param>
    <param>preconditioner Preconditioner.</param>
  </javadoc>
  <method type="constructor" name="NonLinearConjugateGradientOptimizer" />
  <javadoc>
    <text>Set the initial step used to bracket the optimum in line search.
 * &lt;p&gt;
 * The initial step is a factor with respect to the search direction,
 * which itself is roughly related to the gradient of the function
 * &lt;/p&gt;</text>
    <param>initialStep initial step used to bracket the optimum in line search,
 * if a non-positive value is used, the initial step is reset to its
 * default value of 1.0</param>
  </javadoc>
  <method type="void" name="setInitialStep">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PointValuePair" name="doOptimize">
    <declaration type="ConvergenceChecker&lt;PointValuePair&gt;" name="checker" />
    <declaration type="GoalType" name="goal" />
    <declaration type="int" name="n" />
    <declaration type="double[]" name="r" />
    <scope>
      <scope />
    </scope>
    <declaration type="double[]" name="steepestDescent" />
    <declaration type="double[]" name="searchDirection" />
    <declaration type="double" name="delta" />
    <scope />
    <declaration type="PointValuePair" name="current" />
    <declaration type="int" name="iter" />
    <declaration type="int" name="maxEval" />
    <scope>
      <declaration type="double" name="objective" />
      <declaration type="PointValuePair" name="previous" />
      <scope />
      <declaration type="UnivariateFunction" name="lsf" />
      <declaration type="double" name="uB" />
      <declaration type="double" name="step" />
      <scope />
      <scope>
        <scope />
      </scope>
      <declaration type="double" name="deltaOld" />
      <declaration type="double[]" name="newSteepestDescent" />
      <scope />
      <declaration type="double" name="beta" />
      <scope />
      <scope>
        <declaration type="double" name="deltaMid" />
        <scope />
      </scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Initial search direction.</comment>
    <comment>We have found an optimum.</comment>
    <comment>Find the optimal step in the search direction.</comment>
    <comment>XXX Last parameters is set to a value close to zero in order to</comment>
    <comment>work around the divergence problem in the "testCircleFitting"</comment>
    <comment>unit test (see MATH-439).</comment>
    <comment>Subtract used up evaluations.</comment>
    <comment>Validate new point.</comment>
    <comment>Compute beta.</comment>
    <comment>Compute conjugate search direction.</comment>
    <comment>Break conjugation: reset search direction.</comment>
    <comment>Compute new conjugate search direction.</comment>
  </method>
  <javadoc>
    <text>Find the upper bound b ensuring bracketing of a root between a and b.</text>
    <param>f function whose root must be bracketed.</param>
    <param>a lower bound of the interval.</param>
    <param>h initial step to try.</param>
    <return>b such that f(a) and f(b) have opposite signs.</return>
    <throws>MathIllegalStateException if no bracket can be found.</throws>
  </javadoc>
  <method type="double" name="findUpperBound">
    <declaration type="double" name="yA" />
    <declaration type="double" name="yB" />
    <scope>
      <declaration type="double" name="b" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Default identity preconditioner.</text>
  </javadoc>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double[]" name="precondition" />
  <javadoc>
    <text>Internal class for line search.
 * &lt;p&gt;
 * The function represented by this class is the dot product of
 * the objective function gradient and the search direction. Its
 * value is zero when the gradient is orthogonal to the search
 * direction, i.e. when the objective function value is a local
 * extremum along the search direction.
 * &lt;/p&gt;</text>
  </javadoc>
  <javadoc>
    <text>Search direction.</text>
  </javadoc>
  <declaration type="double[]" name="searchDirection" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>searchDirection search direction</param>
  </javadoc>
  <method type="constructor" name="LineSearchFunction" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="value">
    <declaration type="double[]" name="shiftedPoint" />
    <scope />
    <declaration type="double[]" name="gradient" />
    <declaration type="double" name="dotProduct" />
    <scope />
    <comment>current point in the search direction</comment>
    <comment>gradient of the objective function</comment>
    <comment>dot product with the search direction</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
