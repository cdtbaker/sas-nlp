<?xml version="1.0" encoding="UTF-8"?>
<class name="OpenIntToDoubleHashMap">
  <javadoc>
    <text>Open addressed map from int to double.
 * &lt;p&gt;This class provides a dedicated map from integers to doubles with a
 * much smaller memory overhead than standard &lt;code&gt;java.util.Map&lt;/code&gt;.&lt;/p&gt;
 * &lt;p&gt;This class is not synchronized. The specialized iterators returned by{@link #iterator()} are fail-fast: they throw a
 * &lt;code&gt;ConcurrentModificationException&lt;/code&gt; when they detect the map has been
 * modified during iteration.&lt;/p&gt;</text>
    <version>$Id: OpenIntToDoubleHashMap.java 1421448 2012-12-13 19:45:57Z tn $</version>
    <since>2.0</since>
  </javadoc>
  <javadoc>
    <text>Status indicator for free table entries.</text>
  </javadoc>
  <declaration type="byte" name="FREE" />
  <javadoc>
    <text>Status indicator for full table entries.</text>
  </javadoc>
  <declaration type="byte" name="FULL" />
  <javadoc>
    <text>Status indicator for removed table entries.</text>
  </javadoc>
  <declaration type="byte" name="REMOVED" />
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Load factor for the map.</text>
  </javadoc>
  <declaration type="float" name="LOAD_FACTOR" />
  <javadoc>
    <text>Default starting size.
 * &lt;p&gt;This must be a power of two for bit mask to work properly. &lt;/p&gt;</text>
  </javadoc>
  <declaration type="int" name="DEFAULT_EXPECTED_SIZE" />
  <javadoc>
    <text>Multiplier for size growth when map fills up.
 * &lt;p&gt;This must be a power of two for bit mask to work properly. &lt;/p&gt;</text>
  </javadoc>
  <declaration type="int" name="RESIZE_MULTIPLIER" />
  <javadoc>
    <text>Number of bits to perturb the index when probing for collision resolution.</text>
  </javadoc>
  <declaration type="int" name="PERTURB_SHIFT" />
  <javadoc>
    <text>Keys table.</text>
  </javadoc>
  <declaration type="int[]" name="keys" />
  <javadoc>
    <text>Values table.</text>
  </javadoc>
  <declaration type="double[]" name="values" />
  <javadoc>
    <text>States table.</text>
  </javadoc>
  <declaration type="byte[]" name="states" />
  <javadoc>
    <text>Return value for missing entries.</text>
  </javadoc>
  <declaration type="double" name="missingEntries" />
  <javadoc>
    <text>Current size of the map.</text>
  </javadoc>
  <declaration type="int" name="size" />
  <javadoc>
    <text>Bit mask for hash values.</text>
  </javadoc>
  <declaration type="int" name="mask" />
  <javadoc>
    <text>Modifications count.</text>
  </javadoc>
  <declaration type="int" name="count" />
  <javadoc>
    <text>Build an empty map with default size and using NaN for missing entries.</text>
  </javadoc>
  <method type="constructor" name="OpenIntToDoubleHashMap" />
  <javadoc>
    <text>Build an empty map with default size</text>
    <param>missingEntries value to return when a missing entry is fetched</param>
  </javadoc>
  <method type="constructor" name="OpenIntToDoubleHashMap" />
  <javadoc>
    <text>Build an empty map with specified size and using NaN for missing entries.</text>
    <param>expectedSize expected number of elements in the map</param>
  </javadoc>
  <method type="constructor" name="OpenIntToDoubleHashMap" />
  <javadoc>
    <text>Build an empty map with specified size.</text>
    <param>expectedSize expected number of elements in the map</param>
    <param>missingEntries value to return when a missing entry is fetched</param>
  </javadoc>
  <method type="constructor" name="OpenIntToDoubleHashMap">
    <declaration type="int" name="capacity" />
  </method>
  <javadoc>
    <text>Copy constructor.</text>
    <param>source map to copy</param>
  </javadoc>
  <method type="constructor" name="OpenIntToDoubleHashMap">
    <declaration type="int" name="length" />
  </method>
  <javadoc>
    <text>Compute the capacity needed for a given size.</text>
    <param>expectedSize expected size of the map</param>
    <return>capacity to use for the specified size</return>
  </javadoc>
  <method type="int" name="computeCapacity">
    <scope />
    <declaration type="int" name="capacity" />
    <declaration type="int" name="powerOfTwo" />
    <scope />
  </method>
  <javadoc>
    <text>Find the smallest power of two greater than the input value</text>
    <param>i input value</param>
    <return>smallest power of two greater than the input value</return>
  </javadoc>
  <method type="int" name="nextPowerOfTwo" />
  <javadoc>
    <text>Get the stored value associated with the given key</text>
    <param>key key associated with the data</param>
    <return>data associated with the key</return>
  </javadoc>
  <method type="double" name="get">
    <declaration type="int" name="hash" />
    <declaration type="int" name="index" />
    <scope />
    <scope />
    <declaration type="int" name="j" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Check if a value is associated with a key.</text>
    <param>key key to check</param>
    <return>true if a value is associated with key</return>
  </javadoc>
  <method type="boolean" name="containsKey">
    <declaration type="int" name="hash" />
    <declaration type="int" name="index" />
    <scope />
    <scope />
    <declaration type="int" name="j" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get an iterator over map elements.
 * &lt;p&gt;The specialized iterators returned are fail-fast: they throw a
 * &lt;code&gt;ConcurrentModificationException&lt;/code&gt; when they detect the map
 * has been modified during iteration.&lt;/p&gt;</text>
    <return>iterator over the map elements</return>
  </javadoc>
  <method type="Iterator" name="iterator" />
  <javadoc>
    <text>Perturb the hash for starting probing.</text>
    <param>hash initial hash</param>
    <return>perturbed hash</return>
  </javadoc>
  <method type="int" name="perturb" />
  <javadoc>
    <text>Find the index at which a key should be inserted</text>
    <param>key key to lookup</param>
    <return>index at which key should be inserted</return>
  </javadoc>
  <method type="int" name="findInsertionIndex" />
  <javadoc>
    <text>Find the index at which a key should be inserted</text>
    <param>keys keys table</param>
    <param>states states table</param>
    <param>key key to lookup</param>
    <param>mask bit mask for hash values</param>
    <return>index at which key should be inserted</return>
  </javadoc>
  <method type="int" name="findInsertionIndex">
    <declaration type="int" name="hash" />
    <declaration type="int" name="index" />
    <scope />
    <scope />
    <declaration type="int" name="perturb" />
    <declaration type="int" name="j" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <declaration type="int" name="firstRemoved" />
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>due to the loop exit condition,</comment>
    <comment>if (states[index] == FULL) then keys[index] == key</comment>
  </method>
  <javadoc>
    <text>Compute next probe for collision resolution</text>
    <param>perturb perturbed hash</param>
    <param>j previous probe</param>
    <return>next probe</return>
  </javadoc>
  <method type="int" name="probe" />
  <javadoc>
    <text>Change the index sign</text>
    <param>index initial index</param>
    <return>changed index</return>
  </javadoc>
  <method type="int" name="changeIndexSign" />
  <javadoc>
    <text>Get the number of elements stored in the map.</text>
    <return>number of elements stored in the map</return>
  </javadoc>
  <method type="int" name="size" />
  <javadoc>
    <text>Remove the value associated with a key.</text>
    <param>key key to which the value is associated</param>
    <return>removed value</return>
  </javadoc>
  <method type="double" name="remove">
    <declaration type="int" name="hash" />
    <declaration type="int" name="index" />
    <scope />
    <scope />
    <declaration type="int" name="j" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Check if the tables contain an element associated with specified key
 * at specified index.</text>
    <param>key key to check</param>
    <param>index index to check</param>
    <return>true if an element is associated with key at index</return>
  </javadoc>
  <method type="boolean" name="containsKey" />
  <javadoc>
    <text>Remove an element at specified index.</text>
    <param>index index of the element to remove</param>
    <return>removed value</return>
  </javadoc>
  <method type="double" name="doRemove">
    <declaration type="double" name="previous" />
  </method>
  <javadoc>
    <text>Put a value associated with a key in the map.</text>
    <param>key key to which value is associated</param>
    <param>value value to put in the map</param>
    <return>previous value associated with the key</return>
  </javadoc>
  <method type="double" name="put">
    <declaration type="int" name="index" />
    <declaration type="double" name="previous" />
    <declaration type="boolean" name="newMapping" />
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Grow the tables.</text>
  </javadoc>
  <method type="void" name="growTable">
    <declaration type="int" name="oldLength" />
    <declaration type="int[]" name="oldKeys" />
    <declaration type="double[]" name="oldValues" />
    <declaration type="byte[]" name="oldStates" />
    <declaration type="int" name="newLength" />
    <declaration type="int[]" name="newKeys" />
    <declaration type="double[]" name="newValues" />
    <declaration type="byte[]" name="newStates" />
    <declaration type="int" name="newMask" />
    <scope>
      <scope>
        <declaration type="int" name="key" />
        <declaration type="int" name="index" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Check if tables should grow due to increased size.</text>
    <return>true if  tables should grow</return>
  </javadoc>
  <method type="boolean" name="shouldGrowTable" />
  <javadoc>
    <text>Compute the hash value of a key</text>
    <param>key key to hash</param>
    <return>hash value of the key</return>
  </javadoc>
  <method type="int" name="hashOf">
    <declaration type="int" name="h" />
  </method>
  <javadoc>
    <text>Iterator class for the map.</text>
  </javadoc>
  <javadoc>
    <text>Reference modification count.</text>
  </javadoc>
  <declaration type="int" name="referenceCount" />
  <javadoc>
    <text>Index of current element.</text>
  </javadoc>
  <declaration type="int" name="current" />
  <javadoc>
    <text>Index of next element.</text>
  </javadoc>
  <declaration type="int" name="next" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="Iterator">
    <scope />
    <scope />
    <comment>preserve the modification count of the map to detect concurrent modifications later</comment>
    <comment>initialize current index</comment>
    <comment>NOPMD</comment>
    <comment>ignored</comment>
  </method>
  <javadoc>
    <text>Check if there is a next element in the map.</text>
    <return>true if there is a next element</return>
  </javadoc>
  <method type="boolean" name="hasNext" />
  <javadoc>
    <text>Get the key of current entry.</text>
    <return>key of current entry</return>
    <exception>ConcurrentModificationException if the map is modified during iteration</exception>
    <exception>NoSuchElementException if there is no element left in the map</exception>
  </javadoc>
  <method type="int" name="key">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Get the value of current entry.</text>
    <return>value of current entry</return>
    <exception>ConcurrentModificationException if the map is modified during iteration</exception>
    <exception>NoSuchElementException if there is no element left in the map</exception>
  </javadoc>
  <method type="double" name="value">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Advance iterator one step further.</text>
    <exception>ConcurrentModificationException if the map is modified during iteration</exception>
    <exception>NoSuchElementException if there is no element left in the map</exception>
  </javadoc>
  <method type="void" name="advance">
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>advance on step</comment>
    <comment>prepare next step</comment>
    <comment>NOPMD</comment>
    <comment>nothing to do</comment>
  </method>
  <javadoc>
    <text>Read a serialized object.</text>
    <param>stream input stream</param>
    <throws>IOException if object cannot be read</throws>
    <throws>ClassNotFoundException if the class corresponding
 * to the serialized object cannot be found</throws>
  </javadoc>
  <method type="void" name="readObject" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
