<?xml version="1.0" encoding="UTF-8"?>
<class name="StepInterpolator">
  <javadoc>
    <text>This interface represents an interpolator over the last step
 * during an ODE integration.
 * &lt;p&gt;The various ODE integrators provide objects implementing this
 * interface to the step handlers. These objects are often custom
 * objects tightly bound to the integrator internal algorithms. The
 * handlers can use these objects to retrieve the state vector at
 * intermediate times between the previous and the current grid points
 * (this feature is often called dense output).&lt;/p&gt;
 * &lt;p&gt;One important thing to note is that the step handlers may be so
 * tightly bound to the integrators that they often share some internal
 * state arrays. This imply that one should &lt;em&gt;never&lt;/em&gt; use a direct
 * reference to a step interpolator outside of the step handler, either
 * for future use or for use in another thread. If such a need arise, the
 * step interpolator &lt;em&gt;must&lt;/em&gt; be copied using the dedicated{@link #copy()} method.
 * &lt;/p&gt;</text>
    <see>org.apache.commons.math3.ode.FirstOrderIntegrator</see>
    <see>org.apache.commons.math3.ode.SecondOrderIntegrator</see>
    <see>StepHandler</see>
    <version>$Id: StepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <method name="getPreviousTime" type="double" />
  <javadoc>
    <text>Get the previous grid point time.</text>
    <return>previous grid point time</return>
  </javadoc>
  <method name="getCurrentTime" type="double" />
  <javadoc>
    <text>Get the current grid point time.</text>
    <return>current grid point time</return>
  </javadoc>
  <method name="getInterpolatedTime" type="double" />
  <javadoc>
    <text>Get the time of the interpolated point.
 * If {@link #setInterpolatedTime} has not been called, it returns
 * the current grid point time.</text>
    <return>interpolation point time</return>
  </javadoc>
  <method name="setInterpolatedTime" type="void" />
  <javadoc>
    <text>Set the time of the interpolated point.
 * &lt;p&gt;Setting the time outside of the current step is now allowed, but
 * should be used with care since the accuracy of the interpolator will
 * probably be very poor far from this step. This allowance has been
 * added to simplify implementation of search algorithms near the
 * step endpoints.&lt;/p&gt;
 * &lt;p&gt;Setting the time changes the instance internal state. If a
 * specific state must be preserved, a copy of the instance must be
 * created using {@link #copy()}.&lt;/p&gt;</text>
    <param>time time of the interpolated point</param>
  </javadoc>
  <method name="getInterpolatedState" type="double[]" />
  <javadoc>
    <text>Get the state vector of the interpolated point.
 * &lt;p&gt;The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.&lt;/p&gt;</text>
    <return>state vector at time {@link #getInterpolatedTime}</return>
    <see>#getInterpolatedDerivatives()</see>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method name="getInterpolatedDerivatives" type="double[]" />
  <javadoc>
    <text>Get the derivatives of the state vector of the interpolated point.
 * &lt;p&gt;The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.&lt;/p&gt;</text>
    <return>derivatives of the state vector at time {@link #getInterpolatedTime}</return>
    <see>#getInterpolatedState()</see>
    <since>2.0</since>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method name="getInterpolatedSecondaryState" type="double[]" />
  <javadoc>
    <text>Get the interpolated secondary state corresponding to the secondary equations.
 * &lt;p&gt;The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.&lt;/p&gt;</text>
    <param>index index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}</param>
    <return>interpolated secondary state at the current interpolation date</return>
    <see>#getInterpolatedState()</see>
    <see>#getInterpolatedDerivatives()</see>
    <see>#getInterpolatedSecondaryDerivatives(int)</see>
    <see>#setInterpolatedTime(double)</see>
    <since>3.0</since>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method name="getInterpolatedSecondaryDerivatives" type="double[]" />
  <javadoc>
    <text>Get the interpolated secondary derivatives corresponding to the secondary equations.
 * &lt;p&gt;The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.&lt;/p&gt;</text>
    <param>index index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}</param>
    <return>interpolated secondary derivatives at the current interpolation date</return>
    <see>#getInterpolatedState()</see>
    <see>#getInterpolatedDerivatives()</see>
    <see>#getInterpolatedSecondaryState(int)</see>
    <see>#setInterpolatedTime(double)</see>
    <since>3.0</since>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method name="isForward" type="boolean" />
  <javadoc>
    <text>Check if the natural integration direction is forward.
 * &lt;p&gt;This method provides the integration direction as specified by
 * the integrator itself, it avoid some nasty problems in
 * degenerated cases like null steps due to cancellation at step
 * initialization, step control or discrete events
 * triggering.&lt;/p&gt;</text>
    <return>true if the integration variable (time) increases during
 * integration</return>
  </javadoc>
  <method name="copy" type="StepInterpolator" />
  <javadoc>
    <text>Copy the instance.
 * &lt;p&gt;The copied instance is guaranteed to be independent from the
 * original one. Both can be used with different settings for
 * interpolated time without any side effect.&lt;/p&gt;</text>
    <return>a deep copy of the instance, which can be used independently.</return>
    <see>#setInterpolatedTime(double)</see>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded
 * during step finalization</exception>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
