<?xml version="1.0" encoding="UTF-8"?>
<class name="AbstractStepInterpolator">
  <javadoc>
    <text>This abstract class represents an interpolator over the last step
 * during an ODE integration.
 * &lt;p&gt;The various ODE integrators provide objects extending this class
 * to the step handlers. The handlers can use these objects to
 * retrieve the state vector at intermediate times between the
 * previous and the current grid points (dense output).&lt;/p&gt;</text>
    <see>org.apache.commons.math3.ode.FirstOrderIntegrator</see>
    <see>org.apache.commons.math3.ode.SecondOrderIntegrator</see>
    <see>StepHandler</see>
    <version>$Id: AbstractStepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>current time step</text>
  </javadoc>
  <declaration type="double" name="h" />
  <javadoc>
    <text>current state</text>
  </javadoc>
  <declaration type="double[]" name="currentState" />
  <javadoc>
    <text>interpolated time</text>
  </javadoc>
  <declaration type="double" name="interpolatedTime" />
  <javadoc>
    <text>interpolated state</text>
  </javadoc>
  <declaration type="double[]" name="interpolatedState" />
  <javadoc>
    <text>interpolated derivatives</text>
  </javadoc>
  <declaration type="double[]" name="interpolatedDerivatives" />
  <javadoc>
    <text>interpolated primary state</text>
  </javadoc>
  <declaration type="double[]" name="interpolatedPrimaryState" />
  <javadoc>
    <text>interpolated primary derivatives</text>
  </javadoc>
  <declaration type="double[]" name="interpolatedPrimaryDerivatives" />
  <javadoc>
    <text>interpolated secondary state</text>
  </javadoc>
  <declaration type="double[][]" name="interpolatedSecondaryState" />
  <javadoc>
    <text>interpolated secondary derivatives</text>
  </javadoc>
  <declaration type="double[][]" name="interpolatedSecondaryDerivatives" />
  <javadoc>
    <text>global previous time</text>
  </javadoc>
  <declaration type="double" name="globalPreviousTime" />
  <javadoc>
    <text>global current time</text>
  </javadoc>
  <declaration type="double" name="globalCurrentTime" />
  <javadoc>
    <text>soft previous time</text>
  </javadoc>
  <declaration type="double" name="softPreviousTime" />
  <javadoc>
    <text>soft current time</text>
  </javadoc>
  <declaration type="double" name="softCurrentTime" />
  <javadoc>
    <text>indicate if the step has been finalized or not.</text>
  </javadoc>
  <declaration type="boolean" name="finalized" />
  <javadoc>
    <text>integration direction.</text>
  </javadoc>
  <declaration type="boolean" name="forward" />
  <javadoc>
    <text>indicator for dirty state.</text>
  </javadoc>
  <declaration type="boolean" name="dirtyState" />
  <javadoc>
    <text>Equations mapper for the primary equations set.</text>
  </javadoc>
  <declaration type="EquationsMapper" name="primaryMapper" />
  <javadoc>
    <text>Equations mappers for the secondary equations sets.</text>
  </javadoc>
  <declaration type="EquationsMapper[]" name="secondaryMappers" />
  <javadoc>
    <text>Simple constructor.
 * This constructor builds an instance that is not usable yet, the{@link #reinitialize} method should be called before using the
 * instance in order to initialize the internal arrays. This
 * constructor is used only in order to delay the initialization in
 * some cases. As an example, the {@link org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator}class uses the prototyping design pattern to create the step
 * interpolators by cloning an uninitialized model and latter
 * initializing the copy.</text>
  </javadoc>
  <method type="constructor" name="AbstractStepInterpolator" />
  <javadoc>
    <text>Simple constructor.</text>
    <param>y reference to the integrator array holding the state at
 * the end of the step</param>
    <param>forward integration direction indicator</param>
    <param>primaryMapper equations mapper for the primary equations set</param>
    <param>secondaryMappers equations mappers for the secondary equations sets</param>
  </javadoc>
  <method type="constructor" name="AbstractStepInterpolator" />
  <javadoc>
    <text>Copy constructor.
 * &lt;p&gt;The copied interpolator should have been finalized before the
 * copy, otherwise the copy will not be able to perform correctly
 * any derivative computation and will throw a {@link NullPointerException} later. Since we don't want this constructor
 * to throw the exceptions finalization may involve and since we
 * don't want this method to modify the state of the copied
 * interpolator, finalization is &lt;strong&gt;not&lt;/strong&gt; done
 * automatically, it remains under user control.&lt;/p&gt;
 * &lt;p&gt;The copy is a deep copy: its arrays are separated from the
 * original arrays of the instance.&lt;/p&gt;</text>
    <param>interpolator interpolator to copy from.</param>
  </javadoc>
  <method type="constructor" name="AbstractStepInterpolator">
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Allocate the various interpolated states arrays.</text>
    <param>dimension total dimension (negative if arrays should be set to null)</param>
  </javadoc>
  <method type="void" name="allocateInterpolatedArrays">
    <scope />
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Reinitialize the instance</text>
    <param>y reference to the integrator array holding the state at the end of the step</param>
    <param>isForward integration direction indicator</param>
    <param>primary equations mapper for the primary equations set</param>
    <param>secondary equations mappers for the secondary equations sets</param>
  </javadoc>
  <method type="void" name="reinitialize" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="StepInterpolator" name="copy">
    <comment>finalize the step before performing copy</comment>
    <comment>create the new independent instance</comment>
  </method>
  <method name="doCopy" type="StepInterpolator" />
  <javadoc>
    <text>Really copy the finalized instance.
 * &lt;p&gt;This method is called by {@link #copy()} after the
 * step has been finalized. It must perform a deep copy
 * to have an new instance completely independent for the
 * original instance.</text>
    <return>a copy of the finalized instance</return>
  </javadoc>
  <javadoc>
    <text>Shift one step forward.
 * Copy the current time into the previous time, hence preparing the
 * interpolator for future calls to {@link #storeTime storeTime}</text>
  </javadoc>
  <method type="void" name="shift" />
  <javadoc>
    <text>Store the current step time.</text>
    <param>t current time</param>
  </javadoc>
  <method type="void" name="storeTime">
    <comment>the step is not finalized anymore</comment>
  </method>
  <javadoc>
    <text>Restrict step range to a limited part of the global step.
 * &lt;p&gt;
 * This method can be used to restrict a step and make it appear
 * as if the original step was smaller. Calling this method
 * &lt;em&gt;only&lt;/em&gt; changes the value returned by {@link #getPreviousTime()},
 * it does not change any other property
 * &lt;/p&gt;</text>
    <param>softPreviousTime start of the restricted step</param>
    <since>2.2</since>
  </javadoc>
  <method type="void" name="setSoftPreviousTime" />
  <javadoc>
    <text>Restrict step range to a limited part of the global step.
 * &lt;p&gt;
 * This method can be used to restrict a step and make it appear
 * as if the original step was smaller. Calling this method
 * &lt;em&gt;only&lt;/em&gt; changes the value returned by {@link #getCurrentTime()},
 * it does not change any other property
 * &lt;/p&gt;</text>
    <param>softCurrentTime end of the restricted step</param>
    <since>2.2</since>
  </javadoc>
  <method type="void" name="setSoftCurrentTime" />
  <javadoc>
    <text>Get the previous global grid point time.</text>
    <return>previous global grid point time</return>
  </javadoc>
  <method type="double" name="getGlobalPreviousTime" />
  <javadoc>
    <text>Get the current global grid point time.</text>
    <return>current global grid point time</return>
  </javadoc>
  <method type="double" name="getGlobalCurrentTime" />
  <javadoc>
    <text>Get the previous soft grid point time.</text>
    <return>previous soft grid point time</return>
    <see>#setSoftPreviousTime(double)</see>
  </javadoc>
  <method type="double" name="getPreviousTime" />
  <javadoc>
    <text>Get the current soft grid point time.</text>
    <return>current soft grid point time</return>
    <see>#setSoftCurrentTime(double)</see>
  </javadoc>
  <method type="double" name="getCurrentTime" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getInterpolatedTime" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="setInterpolatedTime" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isForward" />
  <method name="computeInterpolatedStateAndDerivatives" type="void" />
  <javadoc>
    <text>Compute the state and derivatives at the interpolated time.
 * This is the main processing method that should be implemented by
 * the derived classes to perform the interpolation.</text>
    <param>theta normalized interpolation abscissa within the step
 * (theta is zero at the previous time step and one at the current time step)</param>
    <param>oneMinusThetaH time gap between the interpolated time and
 * the current time</param>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <javadoc>
    <text>Lazy evaluation of complete interpolated state.</text>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method type="void" name="evaluateCompleteInterpolatedState">
    <scope>
      <declaration type="double" name="oneMinusThetaH" />
      <declaration type="double" name="theta" />
    </scope>
    <comment>lazy evaluation of the state</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double[]" name="getInterpolatedState" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double[]" name="getInterpolatedDerivatives" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double[]" name="getInterpolatedSecondaryState" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double[]" name="getInterpolatedSecondaryDerivatives" />
  <javadoc>
    <text>Finalize the step.
 * &lt;p&gt;Some embedded Runge-Kutta integrators need fewer functions
 * evaluations than their counterpart step interpolators. These
 * interpolators should perform the last evaluations they need by
 * themselves only if they need them. This method triggers these
 * extra evaluations. It can be called directly by the user step
 * handler and it is called automatically if {@link #setInterpolatedTime} is called.&lt;/p&gt;
 * &lt;p&gt;Once this method has been called, &lt;strong&gt;no&lt;/strong&gt; other
 * evaluation will be performed on this step. If there is a need to
 * have some side effects between the step handler and the
 * differential equations (for example update some data in the
 * equations once the step has been done), it is advised to call
 * this method explicitly from the step handler before these side
 * effects are set up. If the step handler induces no side effect,
 * then this method can safely be ignored, it will be called
 * transparently as needed.&lt;/p&gt;
 * &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: since the step interpolator provided
 * to the step handler as a parameter of the {@link StepHandler#handleStep handleStep} is valid only for the duration
 * of the {@link StepHandler#handleStep handleStep} call, one cannot
 * simply store a reference and reuse it later. One should first
 * finalize the instance, then copy this finalized instance into a
 * new object that can be kept.&lt;/p&gt;
 * &lt;p&gt;This method calls the protected &lt;code&gt;doFinalize&lt;/code&gt; method
 * if it has never been called during this step and set a flag
 * indicating that it has been called once. It is the &lt;code&gt;
 * doFinalize&lt;/code&gt; method which should perform the evaluations.
 * This wrapping prevents from calling &lt;code&gt;doFinalize&lt;/code&gt; several
 * times and hence evaluating the differential equations too often.
 * Therefore, subclasses are not allowed not reimplement it, they
 * should rather reimplement &lt;code&gt;doFinalize&lt;/code&gt;.&lt;/p&gt;</text>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method type="void" name="finalizeStep">
    <scope />
  </method>
  <javadoc>
    <text>Really finalize the step.
 * The default implementation of this method does nothing.</text>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method type="void" name="doFinalize" />
  <method name="writeExternal" type="void" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method name="readExternal" type="void" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <javadoc>
    <text>Save the base state of the instance.
 * This method performs step finalization if it has not been done
 * before.</text>
    <param>out stream where to save the state</param>
    <exception>IOException in case of write error</exception>
  </javadoc>
  <method type="void" name="writeBaseExternal">
    <scope />
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="IOException" name="ioe" />
    </scope>
    <comment>we do not store the interpolated state,</comment>
    <comment>it will be recomputed as needed after reading</comment>
    <comment>finalize the step (and don't bother saving the now true flag)</comment>
  </method>
  <javadoc>
    <text>Read the base state of the instance.
 * This method does &lt;strong&gt;neither&lt;/strong&gt; set the interpolated
 * time nor state. It is up to the derived class to reset it
 * properly calling the {@link #setInterpolatedTime} method later,
 * once all rest of the object state has been set up properly.</text>
    <param>in stream where to read the state from</param>
    <return>interpolated time to be set later by the caller</return>
    <exception>IOException in case of read error</exception>
    <exception>ClassNotFoundException if an equation mapper class
 * cannot be found</exception>
  </javadoc>
  <method type="double" name="readBaseExternal">
    <declaration type="int" name="dimension" />
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <comment>we do NOT handle the interpolated time and state here</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
