<?xml version="1.0" encoding="UTF-8"?>
<class name="NaturalRanking">
  <javadoc>
    <text>&lt;p&gt; Ranking based on the natural ordering on doubles.&lt;/p&gt;
 * &lt;p&gt;NaNs are treated according to the configured {@link NaNStrategy} and ties
 * are handled using the selected {@link TiesStrategy}.
 * Configuration settings are supplied in optional constructor arguments.
 * Defaults are {@link NaNStrategy#FAILED} and {@link TiesStrategy#AVERAGE},
 * respectively. When using {@link TiesStrategy#RANDOM}, a{@link RandomGenerator} may be supplied as a constructor argument.&lt;/p&gt;
 * &lt;p&gt;Examples:
 * &lt;table border="1" cellpadding="3"&gt;
 * &lt;tr&gt;&lt;th colspan="3"&gt;
 * Input data: (20, 17, 30, 42.3, 17, 50, Double.NaN, Double.NEGATIVE_INFINITY, 17)
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;NaNStrategy&lt;/th&gt;&lt;th&gt;TiesStrategy&lt;/th&gt;
 * &lt;th&gt;&lt;code&gt;rank(data)&lt;/code&gt;&lt;/th&gt;
 * &lt;tr&gt;
 * &lt;td&gt;default (NaNs maximal)&lt;/td&gt;
 * &lt;td&gt;default (ties averaged)&lt;/td&gt;
 * &lt;td&gt;(5, 3, 6, 7, 3, 8, 9, 1, 3)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;default (NaNs maximal)&lt;/td&gt;
 * &lt;td&gt;MINIMUM&lt;/td&gt;
 * &lt;td&gt;(5, 2, 6, 7, 2, 8, 9, 1, 2)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;MINIMAL&lt;/td&gt;
 * &lt;td&gt;default (ties averaged)&lt;/td&gt;
 * &lt;td&gt;(6, 4, 7, 8, 4, 9, 1.5, 1.5, 4)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;REMOVED&lt;/td&gt;
 * &lt;td&gt;SEQUENTIAL&lt;/td&gt;
 * &lt;td&gt;(5, 2, 6, 7, 3, 8, 1, 4)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;MINIMAL&lt;/td&gt;
 * &lt;td&gt;MAXIMUM&lt;/td&gt;
 * &lt;td&gt;(6, 5, 7, 8, 5, 9, 2, 2, 5)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;</text>
    <since>2.0</since>
    <version>$Id: NaturalRanking.java 1454897 2013-03-10 19:02:54Z luc $</version>
  </javadoc>
  <javadoc>
    <text>default NaN strategy</text>
  </javadoc>
  <declaration type="NaNStrategy" name="DEFAULT_NAN_STRATEGY" />
  <javadoc>
    <text>default ties strategy</text>
  </javadoc>
  <declaration type="TiesStrategy" name="DEFAULT_TIES_STRATEGY" />
  <javadoc>
    <text>NaN strategy - defaults to NaNs maximal</text>
  </javadoc>
  <declaration type="NaNStrategy" name="nanStrategy" />
  <javadoc>
    <text>Ties strategy - defaults to ties averaged</text>
  </javadoc>
  <declaration type="TiesStrategy" name="tiesStrategy" />
  <javadoc>
    <text>Source of random data - used only when ties strategy is RANDOM</text>
  </javadoc>
  <declaration type="RandomDataGenerator" name="randomData" />
  <javadoc>
    <text>Create a NaturalRanking with default strategies for handling ties and NaNs.</text>
  </javadoc>
  <method type="constructor" name="NaturalRanking" />
  <javadoc>
    <text>Create a NaturalRanking with the given TiesStrategy.</text>
    <param>tiesStrategy the TiesStrategy to use</param>
  </javadoc>
  <method type="constructor" name="NaturalRanking" />
  <javadoc>
    <text>Create a NaturalRanking with the given NaNStrategy.</text>
    <param>nanStrategy the NaNStrategy to use</param>
  </javadoc>
  <method type="constructor" name="NaturalRanking" />
  <javadoc>
    <text>Create a NaturalRanking with the given NaNStrategy and TiesStrategy.</text>
    <param>nanStrategy NaNStrategy to use</param>
    <param>tiesStrategy TiesStrategy to use</param>
  </javadoc>
  <method type="constructor" name="NaturalRanking" />
  <javadoc>
    <text>Create a NaturalRanking with TiesStrategy.RANDOM and the given
 * RandomGenerator as the source of random data.</text>
    <param>randomGenerator source of random data</param>
  </javadoc>
  <method type="constructor" name="NaturalRanking" />
  <javadoc>
    <text>Create a NaturalRanking with the given NaNStrategy, TiesStrategy.RANDOM
 * and the given source of random data.</text>
    <param>nanStrategy NaNStrategy to use</param>
    <param>randomGenerator source of random data</param>
  </javadoc>
  <method type="constructor" name="NaturalRanking" />
  <javadoc>
    <text>Return the NaNStrategy</text>
    <return>returns the NaNStrategy</return>
  </javadoc>
  <method type="NaNStrategy" name="getNanStrategy" />
  <javadoc>
    <text>Return the TiesStrategy</text>
    <return>the TiesStrategy</return>
  </javadoc>
  <method type="TiesStrategy" name="getTiesStrategy" />
  <javadoc>
    <text>Rank &lt;code&gt;data&lt;/code&gt; using the natural ordering on Doubles, with
 * NaN values handled according to &lt;code&gt;nanStrategy&lt;/code&gt; and ties
 * resolved using &lt;code&gt;tiesStrategy.&lt;/code&gt;</text>
    <param>data array to be ranked</param>
    <return>array of ranks</return>
    <throws>NotANumberException if the selected {@link NaNStrategy} is {@code FAILED}and a {@link Double#NaN} is encountered in the input data</throws>
  </javadoc>
  <method type="double[]" name="rank">
    <declaration type="IntDoublePair[]" name="ranks" />
    <scope />
    <declaration type="List&lt;Integer&gt;" name="nanPositions" />
    <scope />
    <declaration type="double[]" name="out" />
    <declaration type="int" name="pos" />
    <declaration type="List&lt;Integer&gt;" name="tiesTrace" />
    <scope>
      <scope>
        <scope />
      </scope>
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>Array recording initial positions of data to be ranked</comment>
    <comment>Recode, remove or record positions of NaNs</comment>
    <comment>Replace NaNs with +INFs</comment>
    <comment>Replace NaNs with -INFs</comment>
    <comment>Drop NaNs from data</comment>
    <comment>Record positions of NaNs</comment>
    <comment>this should not happen unless NaNStrategy enum is changed</comment>
    <comment>Sort the IntDoublePairs</comment>
    <comment>Walk the sorted array, filling output array using sorted positions,</comment>
    <comment>resolving ties as we go</comment>
    <comment>position in sorted array</comment>
    <comment>tie sequence has ended (or had length 1)</comment>
    <comment>if seq is nontrivial, resolve</comment>
    <comment>tie sequence continues</comment>
    <comment>handle tie sequence at end</comment>
  </method>
  <javadoc>
    <text>Returns an array that is a copy of the input array with IntDoublePairs
 * having NaN values removed.</text>
    <param>ranks input array</param>
    <return>array with NaN-valued entries removed</return>
  </javadoc>
  <method type="IntDoublePair[]" name="removeNaNs">
    <scope />
    <declaration type="IntDoublePair[]" name="outRanks" />
    <declaration type="int" name="j" />
    <scope>
      <scope>
        <scope />
      </scope>
      <scope />
    </scope>
    <declaration type="IntDoublePair[]" name="returnRanks" />
    <comment>drop, but adjust original ranks of later elements</comment>
  </method>
  <javadoc>
    <text>Recodes NaN values to the given value.</text>
    <param>ranks array to recode</param>
    <param>value the value to replace NaNs with</param>
  </javadoc>
  <method type="void" name="recodeNaNs">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Checks for presence of NaNs in &lt;code&gt;ranks.&lt;/code&gt;</text>
    <param>ranks array to be searched for NaNs</param>
    <return>true iff ranks contains one or more NaNs</return>
  </javadoc>
  <method type="boolean" name="containsNaNs">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Resolve a sequence of ties, using the configured {@link TiesStrategy}.
 * The input &lt;code&gt;ranks&lt;/code&gt; array is expected to take the same value
 * for all indices in &lt;code&gt;tiesTrace&lt;/code&gt;.  The common value is recoded
 * according to the tiesStrategy. For example, if ranks = &lt;5,8,2,6,2,7,1,2&gt;,
 * tiesTrace = &lt;2,4,7&gt; and tiesStrategy is MINIMUM, ranks will be unchanged.
 * The same array and trace with tiesStrategy AVERAGE will come out
 * &lt;5,8,3,6,3,7,1,3&gt;.</text>
    <param>ranks array of ranks</param>
    <param>tiesTrace list of indices where &lt;code&gt;ranks&lt;/code&gt; is constant
 * -- that is, for any i and j in TiesTrace, &lt;code&gt; ranks[i] == ranks[j]
 * &lt;/code&gt;</param>
  </javadoc>
  <method type="void" name="resolveTie">
    <declaration type="double" name="c" />
    <declaration type="int" name="length" />
    <declaration type="Iterator&lt;Integer&gt;" name="iterator" />
    <declaration type="long" name="f" />
    <scope />
    <declaration type="int" name="i" />
    <scope />
    <comment>constant value of ranks over tiesTrace</comment>
    <comment>length of sequence of tied ranks</comment>
    <comment>Replace ranks with average</comment>
    <comment>Replace ranks with maximum values</comment>
    <comment>Replace ties with minimum</comment>
    <comment>Fill with random integral values in [c, c + length - 1]</comment>
    <comment>No advertised exception because args are guaranteed valid</comment>
    <comment>Fill sequentially from c to c + length - 1</comment>
    <comment>walk and fill</comment>
    <comment>this should not happen unless TiesStrategy enum is changed</comment>
  </method>
  <javadoc>
    <text>Sets&lt;code&gt;data[i] = value&lt;/code&gt; for each i in &lt;code&gt;tiesTrace.&lt;/code&gt;</text>
    <param>data array to modify</param>
    <param>tiesTrace list of index values to set</param>
    <param>value value to set</param>
  </javadoc>
  <method type="void" name="fill">
    <declaration type="Iterator&lt;Integer&gt;" name="iterator" />
    <scope />
  </method>
  <javadoc>
    <text>Set &lt;code&gt;ranks[i] = Double.NaN&lt;/code&gt; for each i in &lt;code&gt;nanPositions.&lt;/code&gt;</text>
    <param>ranks array to modify</param>
    <param>nanPositions list of index values to set to &lt;code&gt;Double.NaN&lt;/code&gt;</param>
  </javadoc>
  <method type="void" name="restoreNaNs">
    <scope />
    <declaration type="Iterator&lt;Integer&gt;" name="iterator" />
    <scope />
  </method>
  <javadoc>
    <text>Returns a list of indexes where &lt;code&gt;ranks&lt;/code&gt; is &lt;code&gt;NaN.&lt;/code&gt;</text>
    <param>ranks array to search for &lt;code&gt;NaNs&lt;/code&gt;</param>
    <return>list of indexes i such that &lt;code&gt;ranks[i] = NaN&lt;/code&gt;</return>
  </javadoc>
  <method type="List&lt;Integer&gt;" name="getNanPositions">
    <declaration type="ArrayList&lt;Integer&gt;" name="out" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Represents the position of a double value in an ordering.
 * Comparable interface is implemented so Arrays.sort can be used
 * to sort an array of IntDoublePairs by value.  Note that the
 * implicitly defined natural ordering is NOT consistent with equals.</text>
  </javadoc>
  <javadoc>
    <text>Value of the pair</text>
  </javadoc>
  <declaration type="double" name="value" />
  <javadoc>
    <text>Original position of the pair</text>
  </javadoc>
  <declaration type="int" name="position" />
  <javadoc>
    <text>Construct an IntDoublePair with the given value and position.</text>
    <param>value the value of the pair</param>
    <param>position the original position</param>
  </javadoc>
  <method type="constructor" name="IntDoublePair" />
  <javadoc>
    <text>Compare this IntDoublePair to another pair.
 * Only the &lt;strong&gt;values&lt;/strong&gt; are compared.</text>
    <param>other the other pair to compare this to</param>
    <return>result of &lt;code&gt;Double.compare(value, other.value)&lt;/code&gt;</return>
  </javadoc>
  <method type="int" name="compareTo" />
  <javadoc>
    <text>Returns the value of the pair.</text>
    <return>value</return>
  </javadoc>
  <method type="double" name="getValue" />
  <javadoc>
    <text>Returns the original position of the pair.</text>
    <return>position</return>
  </javadoc>
  <method type="int" name="getPosition" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>N.B. equals() and hashCode() are not implemented; see MATH-610 for discussion.</comment>
</class>
