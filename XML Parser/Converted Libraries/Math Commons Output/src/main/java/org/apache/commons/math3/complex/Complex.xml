<?xml version="1.0" encoding="UTF-8"?>
<class name="Complex">
  <javadoc>
    <text>Representation of a Complex number, i.e. a number which has both a
 * real and imaginary part.
 * &lt;br/&gt;
 * Implementations of arithmetic operations handle {@code NaN} and
 * infinite values according to the rules for {@link java.lang.Double}, i.e.{@link #equals} is an equivalence relation for all instances that have
 * a {@code NaN} in either real or imaginary part, e.g. the following are
 * considered equal:
 * &lt;ul&gt;
 * &lt;li&gt;{@code 1 + NaNi}&lt;/li&gt;
 * &lt;li&gt;{@code NaN + i}&lt;/li&gt;
 * &lt;li&gt;{@code NaN + NaNi}&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that this is in contradiction with the IEEE-754 standard for floating
 * point numbers (according to which the test {@code x == x} must fail if{@code x} is {@code NaN}). The method{@link org.apache.commons.math3.util.Precision#equals(double,double,int)equals for primitive double} in {@link org.apache.commons.math3.util.Precision}conforms with IEEE-754 while this class conforms with the standard behavior
 * for Java object types.
 * &lt;br/&gt;
 * Implements Serializable since 2.0</text>
    <version>$Id: Complex.java 1459927 2013-03-22 18:55:58Z luc $</version>
  </javadoc>
  <javadoc>
    <text>The square root of -1. A number representing "0.0 + 1.0i"</text>
  </javadoc>
  <declaration type="Complex" name="I" />
  <javadoc>
    <text>A complex number representing "NaN + NaNi"</text>
  </javadoc>
  <declaration type="Complex" name="NaN" />
  <javadoc>
    <text>A complex number representing "+INF + INFi"</text>
  </javadoc>
  <declaration type="Complex" name="INF" />
  <javadoc>
    <text>A complex number representing "1.0 + 0.0i"</text>
  </javadoc>
  <declaration type="Complex" name="ONE" />
  <javadoc>
    <text>A complex number representing "0.0 + 0.0i"</text>
  </javadoc>
  <declaration type="Complex" name="ZERO" />
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>The imaginary part.</text>
  </javadoc>
  <declaration type="double" name="imaginary" />
  <javadoc>
    <text>The real part.</text>
  </javadoc>
  <declaration type="double" name="real" />
  <javadoc>
    <text>Record whether this complex number is equal to NaN.</text>
  </javadoc>
  <declaration type="boolean" name="isNaN" />
  <javadoc>
    <text>Record whether this complex number is infinite.</text>
  </javadoc>
  <declaration type="boolean" name="isInfinite" />
  <javadoc>
    <text>Create a complex number given only the real part.</text>
    <param>real Real part.</param>
  </javadoc>
  <method type="constructor" name="Complex" />
  <javadoc>
    <text>Create a complex number given the real and imaginary parts.</text>
    <param>real Real part.</param>
    <param>imaginary Imaginary part.</param>
  </javadoc>
  <method type="constructor" name="Complex" />
  <javadoc>
    <text>Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.</text>
    <return>the absolute value.</return>
  </javadoc>
  <method type="double" name="abs">
    <scope />
    <scope />
    <scope>
      <scope />
      <declaration type="double" name="q" />
    </scope>
    <scope>
      <scope />
      <declaration type="double" name="q" />
    </scope>
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is{@code (this + addend)}.
 * Uses the definitional formula
 * &lt;pre&gt;
 * &lt;code&gt;
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * &lt;br/&gt;
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.</text>
    <param>addend Value to be added to this {@code Complex}.</param>
    <return>{@code this + addend}.</return>
    <throws>NullArgumentException if {@code addend} is {@code null}.</throws>
  </javadoc>
  <method type="Complex" name="add">
    <scope />
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.</text>
    <param>addend Value to be added to this {@code Complex}.</param>
    <return>{@code this + addend}.</return>
    <see>#add(Complex)</see>
  </javadoc>
  <method type="Complex" name="add">
    <scope />
  </method>
  <javadoc>
    <text>Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * &lt;br/&gt;{@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * &lt;br/&gt;
 * If the imaginary part is infinite, and the real part is not{@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of{@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.</text>
    <return>the conjugate of this Complex object.</return>
  </javadoc>
  <method type="Complex" name="conjugate">
    <scope />
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is{@code (this / divisor)}.
 * Implements the definitional formula
 * &lt;pre&gt;
 * &lt;code&gt;
 * a + bi          ac + bd + (bc - ad)i
 * ----------- = -------------------------
 * c + di         c&lt;sup&gt;2&lt;/sup&gt; + d&lt;sup&gt;2&lt;/sup&gt;
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * but uses
 * &lt;a href="http://doi.acm.org/10.1145/1039813.1039814"&gt;
 * prescaling of operands&lt;/a&gt; to limit the effects of overflows and
 * underflows in the computation.
 * &lt;br/&gt;{@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * &lt;ul&gt;
 * &lt;li&gt;If either {@code this} or {@code divisor} has a {@code NaN} value
 * in either part, {@link #NaN} is returned.
 * &lt;/li&gt;
 * &lt;li&gt;If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
 * &lt;/li&gt;
 * &lt;li&gt;If {@code this} and {@code divisor} are both infinite,{@link #NaN} is returned.
 * &lt;/li&gt;
 * &lt;li&gt;If {@code this} is finite (i.e., has no {@code Infinite} or{@code NaN} parts) and {@code divisor} is infinite (one or both parts
 * infinite), {@link #ZERO} is returned.
 * &lt;/li&gt;
 * &lt;li&gt;If {@code this} is infinite and {@code divisor} is finite,{@code NaN} values are returned in the parts of the result if the{@link java.lang.Double} rules applied to the definitional formula
 * force {@code NaN} results.
 * &lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>divisor Value by which this {@code Complex} is to be divided.</param>
    <return>{@code this / divisor}.</return>
    <throws>NullArgumentException if {@code divisor} is {@code null}.</throws>
  </javadoc>
  <method type="Complex" name="divide">
    <scope />
    <declaration type="double" name="c" />
    <declaration type="double" name="d" />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="q" />
      <declaration type="double" name="denominator" />
    </scope>
    <scope>
      <declaration type="double" name="q" />
      <declaration type="double" name="denominator" />
    </scope>
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.</text>
    <param>divisor Value by which this {@code Complex} is to be divided.</param>
    <return>{@code this / divisor}.</return>
    <see>#divide(Complex)</see>
  </javadoc>
  <method type="Complex" name="divide">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Complex" name="reciprocal">
    <scope />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="q" />
      <declaration type="double" name="scale" />
    </scope>
    <scope>
      <declaration type="double" name="q" />
      <declaration type="double" name="scale" />
    </scope>
  </method>
  <javadoc>
    <text>Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to{@code NaN}.</text>
    <param>other Object to test for equality to this</param>
    <return>true if two Complex objects are equal, false if object is{@code null}, not an instance of Complex, or not equal to this Complex
 * instance.</return>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope>
      <declaration type="Complex" name="c" />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.</text>
    <return>a hash code value for this object.</return>
  </javadoc>
  <method type="int" name="hashCode">
    <scope />
  </method>
  <javadoc>
    <text>Access the imaginary part.</text>
    <return>the imaginary part.</return>
  </javadoc>
  <method type="double" name="getImaginary" />
  <javadoc>
    <text>Access the real part.</text>
    <return>the real part.</return>
  </javadoc>
  <method type="double" name="getReal" />
  <javadoc>
    <text>Checks whether either or both parts of this complex number is{@code NaN}.</text>
    <return>true if either or both parts of this complex number is{@code NaN}; false otherwise.</return>
  </javadoc>
  <method type="boolean" name="isNaN" />
  <javadoc>
    <text>Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or{@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.</text>
    <return>true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.</return>
  </javadoc>
  <method type="boolean" name="isInfinite" />
  <javadoc>
    <text>Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * &lt;br/&gt;
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * &lt;br/&gt;
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.</text>
    <param>factor value to be multiplied by this {@code Complex}.</param>
    <return>{@code this * factor}.</return>
    <throws>NullArgumentException if {@code factor} is {@code null}.</throws>
  </javadoc>
  <method type="Complex" name="multiply">
    <scope />
    <scope />
    <comment>we don't use isInfinite() to avoid testing for NaN again</comment>
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}interpreted as a integer number.</text>
    <param>factor value to be multiplied by this {@code Complex}.</param>
    <return>{@code this * factor}.</return>
    <see>#multiply(Complex)</see>
  </javadoc>
  <method type="Complex" name="multiply">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}interpreted as a real number.</text>
    <param>factor value to be multiplied by this {@code Complex}.</param>
    <return>{@code this * factor}.</return>
    <see>#multiply(Complex)</see>
  </javadoc>
  <method type="Complex" name="multiply">
    <scope />
    <scope />
    <comment>we don't use isInfinite() to avoid testing for NaN again</comment>
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is {@code (-this)}.
 * Returns {@code NaN} if either real or imaginary
 * part of this Complex number equals {@code Double.NaN}.</text>
    <return>{@code -this}.</return>
  </javadoc>
  <method type="Complex" name="negate">
    <scope />
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is{@code (this - subtrahend)}.
 * Uses the definitional formula
 * &lt;pre&gt;
 * &lt;code&gt;
 * (a + bi) - (c + di) = (a-c) + (b-d)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,{@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for{@link java.lang.Double} arithmetic.</text>
    <param>subtrahend value to be subtracted from this {@code Complex}.</param>
    <return>{@code this - subtrahend}.</return>
    <throws>NullArgumentException if {@code subtrahend} is {@code null}.</throws>
  </javadoc>
  <method type="Complex" name="subtract">
    <scope />
  </method>
  <javadoc>
    <text>Returns a {@code Complex} whose value is{@code (this - subtrahend)}.</text>
    <param>subtrahend value to be subtracted from this {@code Complex}.</param>
    <return>{@code this - subtrahend}.</return>
    <see>#subtract(Complex)</see>
  </javadoc>
  <method type="Complex" name="subtract">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/InverseCosine.html" TARGET="_top"&gt;
 * inverse cosine&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * acos(z) = -i (log(z + i (sqrt(1 - z&lt;sup&gt;2&lt;/sup&gt;))))
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.</text>
    <return>the inverse cosine of this complex number.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="acos">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/InverseSine.html" TARGET="_top"&gt;
 * inverse sine&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * asin(z) = -i (log(sqrt(1 - z&lt;sup&gt;2&lt;/sup&gt;) + iz))
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.</text>
    <return>the inverse sine of this complex number.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="asin">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/InverseTangent.html" TARGET="_top"&gt;
 * inverse tangent&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * atan(z) = (i/2) log((i + z)/(i - z))
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.</text>
    <return>the inverse tangent of this complex number</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="atan">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/Cosine.html" TARGET="_top"&gt;
 * cosine&lt;/a&gt;
 * of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * cos(1 &amp;plusmn; INFINITY i) = 1 &amp;#x2213; INFINITY i
 * cos(&amp;plusmn;INFINITY + i) = NaN + NaN i
 * cos(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the cosine of this complex number.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="cos">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/HyperbolicCosine.html" TARGET="_top"&gt;
 * hyperbolic cosine&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * cosh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
 * cosh(&amp;plusmn;INFINITY + i) = INFINITY &amp;plusmn; INFINITY i
 * cosh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the hyperbolic cosine of this complex number.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="cosh">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/ExponentialFunction.html" TARGET="_top"&gt;
 * exponential function&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and{@link java.lang.Math#sin}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * exp(1 &amp;plusmn; INFINITY i) = NaN + NaN i
 * exp(INFINITY + i) = INFINITY + INFINITY i
 * exp(-INFINITY + i) = 0 + 0i
 * exp(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>&lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;this&lt;/sup&gt;&lt;/code&gt;.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="exp">
    <scope />
    <declaration type="double" name="expReal" />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/NaturalLogarithm.html" TARGET="_top"&gt;
 * natural logarithm&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * log(a + bi) = ln(|a + bi|) + arg(a + bi)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where ln on the right hand side is {@link java.lang.Math#log},{@code |a + bi|} is the modulus, {@link Complex#abs},  and{@code arg(a + bi) = }{@link java.lang.Math#atan2}(b, a).
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * log(1 &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (&amp;pi;/2)i
 * log(INFINITY + i) = INFINITY + 0i
 * log(-INFINITY + i) = INFINITY + &amp;pi;i
 * log(INFINITY &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (&amp;pi;/4)i
 * log(-INFINITY &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (3&amp;pi;/4)i
 * log(0 + 0i) = -INFINITY + 0i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the value &lt;code&gt;ln &amp;nbsp; this&lt;/code&gt;, the natural logarithm
 * of {@code this}.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="log">
    <scope />
  </method>
  <javadoc>
    <text>Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * y&lt;sup&gt;x&lt;/sup&gt; = exp(x&amp;middot;log(y))
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where {@code exp} and {@code log} are {@link #exp} and{@link #log}, respectively.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}equals {@link Complex#ZERO}.</text>
    <param>x exponent to which this {@code Complex} is to be raised.</param>
    <return>&lt;code&gt; this&lt;sup&gt;{@code x}&lt;/sup&gt;&lt;/code&gt;.</return>
    <throws>NullArgumentException if x is {@code null}.</throws>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="pow" />
  <javadoc>
    <text>Returns of value of this complex number raised to the power of {@code x}.</text>
    <param>x exponent to which this {@code Complex} is to be raised.</param>
    <return>&lt;code&gt;this&lt;sup&gt;x&lt;/sup&gt;&lt;/code&gt;.</return>
    <see>#pow(Complex)</see>
  </javadoc>
  <method type="Complex" name="pow" />
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/Sine.html" TARGET="_top"&gt;
 * sine&lt;/a&gt;
 * of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or {@code NaN} values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * sin(1 &amp;plusmn; INFINITY i) = 1 &amp;plusmn; INFINITY i
 * sin(&amp;plusmn;INFINITY + i) = NaN + NaN i
 * sin(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the sine of this complex number.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="sin">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/HyperbolicSine.html" TARGET="_top"&gt;
 * hyperbolic sine&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * sinh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
 * sinh(&amp;plusmn;INFINITY + i) = &amp;plusmn; INFINITY + INFINITY i
 * sinh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the hyperbolic sine of {@code this}.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="sinh">
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top"&gt;
 * square root&lt;/a&gt; of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * &lt;ol&gt;&lt;li&gt;Let {@code t = sqrt((|a| + |a + bi|) / 2)}&lt;/li&gt;
 * &lt;li&gt;&lt;pre&gt;if {@code  a &amp;#8805; 0} return {@code t + (b/2t)i}else return {@code |b|/2t + sign(b)t i }&lt;/pre&gt;&lt;/li&gt;
 * &lt;/ol&gt;
 * where &lt;ul&gt;
 * &lt;li&gt;{@code |a| = }{@link Math#abs}(a)&lt;/li&gt;
 * &lt;li&gt;{@code |a + bi| = }{@link Complex#abs}(a + bi)&lt;/li&gt;
 * &lt;li&gt;{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}&lt;/ul&gt;
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * sqrt(1 &amp;plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(INFINITY + i) = INFINITY + 0i
 * sqrt(-INFINITY + i) = 0 + INFINITY i
 * sqrt(INFINITY &amp;plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(-INFINITY &amp;plusmn; INFINITY i) = NaN &amp;plusmn; INFINITY i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the square root of {@code this}.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="sqrt">
    <scope />
    <scope />
    <declaration type="double" name="t" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top"&gt;
 * square root&lt;/a&gt; of &lt;code&gt;1 - this&lt;sup&gt;2&lt;/sup&gt;&lt;/code&gt; for this complex
 * number.
 * Computes the result directly as{@code sqrt(ONE.subtract(z.multiply(z)))}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.</text>
    <return>the square root of &lt;code&gt;1 - this&lt;sup&gt;2&lt;/sup&gt;&lt;/code&gt;.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="sqrt1z" />
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/Tangent.html" TARGET="_top"&gt;
 * tangent&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and{@link FastMath#sinh}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * tan(a &amp;plusmn; INFINITY i) = 0 &amp;plusmn; i
 * tan(&amp;plusmn;INFINITY + bi) = NaN + NaN i
 * tan(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * tan(&amp;plusmn;&amp;pi;/2 + 0 i) = &amp;plusmn;INFINITY + NaN i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the tangent of {@code this}.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="tan">
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="real2" />
    <declaration type="double" name="imaginary2" />
    <declaration type="double" name="d" />
  </method>
  <javadoc>
    <text>Compute the
 * &lt;a href="http://mathworld.wolfram.com/HyperbolicTangent.html" TARGET="_top"&gt;
 * hyperbolic tangent&lt;/a&gt; of this complex number.
 * Implements the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and{@link FastMath#sinh}.
 * &lt;br/&gt;
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * &lt;br/&gt;
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * &lt;pre&gt;
 * Examples:
 * &lt;code&gt;
 * tanh(a &amp;plusmn; INFINITY i) = NaN + NaN i
 * tanh(&amp;plusmn;INFINITY + bi) = &amp;plusmn;1 + 0 i
 * tanh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&amp;pi;/2)i) = NaN + INFINITY i
 * &lt;/code&gt;
 * &lt;/pre&gt;</text>
    <return>the hyperbolic tangent of {@code this}.</return>
    <since>1.2</since>
  </javadoc>
  <method type="Complex" name="tanh">
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="real2" />
    <declaration type="double" name="imaginary2" />
    <declaration type="double" name="d" />
  </method>
  <javadoc>
    <text>Compute the argument of this complex number.
 * The argument is the angle phi between the positive real axis and
 * the point representing this number in the complex plane.
 * The value returned is between -PI (not inclusive)
 * and PI (inclusive), with negative values returned for numbers with
 * negative imaginary parts.
 * &lt;br/&gt;
 * If either real or imaginary part (or both) is NaN, NaN is returned.
 * Infinite parts are handled as {@code Math.atan2} handles them,
 * essentially treating finite parts as zero in the presence of an
 * infinite coordinate and returning a multiple of pi/4 depending on
 * the signs of the infinite parts.
 * See the javadoc for {@code Math.atan2} for full details.</text>
    <return>the argument of {@code this}.</return>
  </javadoc>
  <method type="double" name="getArgument" />
  <javadoc>
    <text>Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * &lt;pre&gt;
 * &lt;code&gt;
 * z&lt;sub&gt;k&lt;/sub&gt; = abs&lt;sup&gt;1/n&lt;/sup&gt; (cos(phi + 2&amp;pi;k/n) + i (sin(phi + 2&amp;pi;k/n))
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * for &lt;i&gt;{@code k=0, 1, ..., n-1}&lt;/i&gt;, where {@code abs} and {@code phi}are respectively the {@link #abs() modulus} and{@link #getArgument() argument} of this complex number.
 * &lt;br/&gt;
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.</text>
    <param>n Degree of root.</param>
    <return>a List&lt;Complex&gt; of all {@code n}-th roots of {@code this}.</return>
    <throws>NotPositiveException if {@code n &lt;= 0}.</throws>
    <since>2.0</since>
  </javadoc>
  <method type="List&lt;Complex&gt;" name="nthRoot">
    <scope />
    <declaration type="List&lt;Complex&gt;" name="result" />
    <scope />
    <scope />
    <declaration type="double" name="nthRootOfAbs" />
    <declaration type="double" name="nthPhi" />
    <declaration type="double" name="slice" />
    <declaration type="double" name="innerPart" />
    <scope>
      <declaration type="double" name="realPart" />
      <declaration type="double" name="imaginaryPart" />
    </scope>
    <comment>nth root of abs -- faster / more accurate to use a solver here?</comment>
    <comment>Compute nth roots of complex number with k = 0, 1, ... n-1</comment>
    <comment>inner part</comment>
  </method>
  <javadoc>
    <text>Create a complex number given the real and imaginary parts.</text>
    <param>realPart Real part.</param>
    <param>imaginaryPart Imaginary part.</param>
    <return>a new complex number instance.</return>
    <since>1.2</since>
    <see>#valueOf(double,double)</see>
  </javadoc>
  <method type="Complex" name="createComplex" />
  <javadoc>
    <text>Create a complex number given the real and imaginary parts.</text>
    <param>realPart Real part.</param>
    <param>imaginaryPart Imaginary part.</param>
    <return>a Complex instance.</return>
  </javadoc>
  <method type="Complex" name="valueOf">
    <scope />
  </method>
  <javadoc>
    <text>Create a complex number given only the real part.</text>
    <param>realPart Real part.</param>
    <return>a Complex instance.</return>
  </javadoc>
  <method type="Complex" name="valueOf">
    <scope />
  </method>
  <javadoc>
    <text>Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.</text>
    <return>A Complex instance with all fields resolved.</return>
    <since>2.0</since>
  </javadoc>
  <method type="Object" name="readResolve" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="ComplexField" name="getField" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="String" name="toString" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>CHECKSTYLE: stop ConstantName</comment>
  <comment>CHECKSTYLE: resume ConstantName</comment>
</class>
