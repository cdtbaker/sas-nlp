<?xml version="1.0" encoding="UTF-8"?>
<class name="PolygonsSet">
  <javadoc>
    <text>This class represents a 2D region: a set of polygons.</text>
    <version>$Id: PolygonsSet.java 1422195 2012-12-15 06:45:18Z psteitz $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Vertices organized as boundary loops.</text>
  </javadoc>
  <declaration type="Vector2D[][]" name="vertices" />
  <javadoc>
    <text>Build a polygons set representing the whole real line.</text>
  </javadoc>
  <method type="constructor" name="PolygonsSet" />
  <javadoc>
    <text>Build a polygons set from a BSP tree.
 * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;</text>
    <param>tree inside/outside BSP tree representing the region</param>
  </javadoc>
  <method type="constructor" name="PolygonsSet" />
  <javadoc>
    <text>Build a polygons set from a Boundary REPresentation (B-rep).
 * &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.&lt;/p&gt;
 * &lt;p&gt;The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polygons with holes
 * or a set of disjoint polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
 * &lt;p&gt;If the boundary is empty, the region will represent the whole
 * space.&lt;/p&gt;</text>
    <param>boundary collection of boundary elements, as a
 * collection of {@link SubHyperplane SubHyperplane} objects</param>
  </javadoc>
  <method type="constructor" name="PolygonsSet" />
  <javadoc>
    <text>Build a parallellepipedic box.</text>
    <param>xMin low bound along the x direction</param>
    <param>xMax high bound along the x direction</param>
    <param>yMin low bound along the y direction</param>
    <param>yMax high bound along the y direction</param>
  </javadoc>
  <method type="constructor" name="PolygonsSet" />
  <javadoc>
    <text>Build a polygon from a simple list of vertices.
 * &lt;p&gt;The boundary is provided as a list of points considering to
 * represent the vertices of a simple loop. The interior part of the
 * region is on the left side of this path and the exterior is on its
 * right side.&lt;/p&gt;
 * &lt;p&gt;This constructor does not handle polygons with a boundary
 * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
 * &lt;p&gt;For cases where this simple constructor applies, it is expected to
 * be numerically more robust than the {@link #PolygonsSet(Collection) general
 * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
 * &lt;p&gt;If the list is empty, the region will represent the whole
 * space.&lt;/p&gt;
 * &lt;p&gt;
 * Polygons with thin pikes or dents are inherently difficult to handle because
 * they involve lines with almost opposite directions at some vertices. Polygons
 * whose vertices come from some physical measurement with noise are also
 * difficult because an edge that should be straight may be broken in lots of
 * different pieces with almost equal directions. In both cases, computing the
 * lines intersections is not numerically robust due to the almost 0 or almost
 * &amp;pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}parameter. A too small value would often lead to completely wrong polygons
 * with large area wrongly identified as inside or outside. Large values are
 * often much safer. As a rule of thumb, a value slightly below the size of the
 * most accurate detail needed is a good value for the {@code hyperplaneThickness}parameter.
 * &lt;/p&gt;</text>
    <param>hyperplaneThickness tolerance below which points are considered to
 * belong to the hyperplane (which is therefore more a slab)</param>
    <param>vertices vertices of the simple loop boundary</param>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="PolygonsSet" />
  <javadoc>
    <text>Create a list of hyperplanes representing the boundary of a box.</text>
    <param>xMin low bound along the x direction</param>
    <param>xMax high bound along the x direction</param>
    <param>yMin low bound along the y direction</param>
    <param>yMax high bound along the y direction</param>
    <return>boundary of the box</return>
  </javadoc>
  <method type="Line[]" name="boxBoundary">
    <declaration type="Vector2D" name="minMin" />
    <declaration type="Vector2D" name="minMax" />
    <declaration type="Vector2D" name="maxMin" />
    <declaration type="Vector2D" name="maxMax" />
  </method>
  <javadoc>
    <text>Build the BSP tree of a polygons set from a simple list of vertices.
 * &lt;p&gt;The boundary is provided as a list of points considering to
 * represent the vertices of a simple loop. The interior part of the
 * region is on the left side of this path and the exterior is on its
 * right side.&lt;/p&gt;
 * &lt;p&gt;This constructor does not handle polygons with a boundary
 * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
 * &lt;p&gt;For cases where this simple constructor applies, it is expected to
 * be numerically more robust than the {@link #PolygonsSet(Collection) general
 * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;</text>
    <param>hyperplaneThickness tolerance below which points are consider to
 * belong to the hyperplane (which is therefore more a slab)</param>
    <param>vertices vertices of the simple loop boundary</param>
    <return>the BSP tree of the input vertices</return>
  </javadoc>
  <method type="BSPTree&lt;Euclidean2D&gt;" name="verticesToTree">
    <declaration type="int" name="n" />
    <scope />
    <declaration type="Vertex[]" name="vArray" />
    <scope />
    <declaration type="List&lt;Edge&gt;" name="edges" />
    <scope>
      <declaration type="Vertex" name="start" />
      <declaration type="Vertex" name="end" />
      <declaration type="Line" name="line" />
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
    <declaration type="BSPTree&lt;Euclidean2D&gt;" name="tree" />
    <comment>the tree represents the whole space</comment>
    <comment>build the vertices</comment>
    <comment>build the edges</comment>
    <comment>get the endpoints of the edge</comment>
    <comment>get the line supporting the edge, taking care not to recreate it</comment>
    <comment>if it was already created earlier due to another edge being aligned</comment>
    <comment>with the current one</comment>
    <comment>create the edge and store it</comment>
    <comment>check if another vertex also happens to be on this line</comment>
    <comment>build the tree top-down</comment>
  </method>
  <javadoc>
    <text>Recursively build a tree by inserting cut sub-hyperplanes.</text>
    <param>hyperplaneThickness tolerance below which points are consider to
 * belong to the hyperplane (which is therefore more a slab)</param>
    <param>node current tree node (it is a leaf node at the beginning
 * of the call)</param>
    <param>edges list of edges to insert in the cell defined by this node
 * (excluding edges not belonging to the cell defined by this node)</param>
  </javadoc>
  <method type="void" name="insertEdges">
    <declaration type="int" name="index" />
    <declaration type="Edge" name="inserted" />
    <scope>
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
    </scope>
    <scope>
      <declaration type="BSPTree&lt;Euclidean2D&gt;" name="parent" />
      <scope />
      <scope />
    </scope>
    <declaration type="List&lt;Edge&gt;" name="plusList" />
    <declaration type="List&lt;Edge&gt;" name="minusList" />
    <scope>
      <scope>
        <declaration type="double" name="startOffset" />
        <declaration type="double" name="endOffset" />
        <declaration type="Side" name="startSide" />
        <declaration type="Side" name="endSide" />
        <scope>
          <declaration type="Vertex" name="splitPoint" />
        </scope>
        <scope />
        <scope>
          <declaration type="Vertex" name="splitPoint" />
        </scope>
        <scope />
        <scope />
        <scope />
      </scope>
    </scope>
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>find an edge with an hyperplane that can be inserted in the node</comment>
    <comment>no suitable edge was found, the node remains a leaf node</comment>
    <comment>we need to set its inside/outside boolean indicator</comment>
    <comment>we have split the node by inserted an edge as a cut sub-hyperplane</comment>
    <comment>distribute the remaining edges in the two sub-trees</comment>
    <comment>we need to insert a split point on the hyperplane</comment>
    <comment>we need to insert a split point on the hyperplane</comment>
    <comment>recurse through lower levels</comment>
  </method>
  <javadoc>
    <text>Internal class for holding vertices while they are processed to build a BSP tree.</text>
  </javadoc>
  <javadoc>
    <text>Vertex location.</text>
  </javadoc>
  <declaration type="Vector2D" name="location" />
  <javadoc>
    <text>Incoming edge.</text>
  </javadoc>
  <declaration type="Edge" name="incoming" />
  <javadoc>
    <text>Outgoing edge.</text>
  </javadoc>
  <declaration type="Edge" name="outgoing" />
  <javadoc>
    <text>Lines bound with this vertex.</text>
  </javadoc>
  <declaration type="List&lt;Line&gt;" name="lines" />
  <javadoc>
    <text>Build a non-processed vertex not owned by any node yet.</text>
    <param>location vertex location</param>
  </javadoc>
  <method type="constructor" name="Vertex" />
  <javadoc>
    <text>Get Vertex location.</text>
    <return>vertex location</return>
  </javadoc>
  <method type="Vector2D" name="getLocation" />
  <javadoc>
    <text>Bind a line considered to contain this vertex.</text>
    <param>line line to bind with this vertex</param>
  </javadoc>
  <method type="void" name="bindWith" />
  <javadoc>
    <text>Get the common line bound with both the instance and another vertex, if any.
 * &lt;p&gt;
 * When two vertices are both bound to the same line, this means they are
 * already handled by node associated with this line, so there is no need
 * to create a cut hyperplane for them.
 * &lt;/p&gt;</text>
    <param>vertex other vertex to check instance against</param>
    <return>line bound with both the instance and another vertex, or null if the
 * two vertices do not share a line yet</return>
  </javadoc>
  <method type="Line" name="sharedLineWith">
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Set incoming edge.
 * &lt;p&gt;
 * The line supporting the incoming edge is automatically bound
 * with the instance.
 * &lt;/p&gt;</text>
    <param>incoming incoming edge</param>
  </javadoc>
  <method type="void" name="setIncoming" />
  <javadoc>
    <text>Get incoming edge.</text>
    <return>incoming edge</return>
  </javadoc>
  <method type="Edge" name="getIncoming" />
  <javadoc>
    <text>Set outgoing edge.
 * &lt;p&gt;
 * The line supporting the outgoing edge is automatically bound
 * with the instance.
 * &lt;/p&gt;</text>
    <param>outgoing outgoing edge</param>
  </javadoc>
  <method type="void" name="setOutgoing" />
  <javadoc>
    <text>Get outgoing edge.</text>
    <return>outgoing edge</return>
  </javadoc>
  <method type="Edge" name="getOutgoing" />
  <javadoc>
    <text>Internal class for holding edges while they are processed to build a BSP tree.</text>
  </javadoc>
  <javadoc>
    <text>Start vertex.</text>
  </javadoc>
  <declaration type="Vertex" name="start" />
  <javadoc>
    <text>End vertex.</text>
  </javadoc>
  <declaration type="Vertex" name="end" />
  <javadoc>
    <text>Line supporting the edge.</text>
  </javadoc>
  <declaration type="Line" name="line" />
  <javadoc>
    <text>Node whose cut hyperplane contains this edge.</text>
  </javadoc>
  <declaration type="BSPTree&lt;Euclidean2D&gt;" name="node" />
  <javadoc>
    <text>Build an edge not contained in any node yet.</text>
    <param>start start vertex</param>
    <param>end end vertex</param>
    <param>line line supporting the edge</param>
  </javadoc>
  <method type="constructor" name="Edge">
    <comment>connect the vertices back to the edge</comment>
  </method>
  <javadoc>
    <text>Get start vertex.</text>
    <return>start vertex</return>
  </javadoc>
  <method type="Vertex" name="getStart" />
  <javadoc>
    <text>Get end vertex.</text>
    <return>end vertex</return>
  </javadoc>
  <method type="Vertex" name="getEnd" />
  <javadoc>
    <text>Get the line supporting this edge.</text>
    <return>line supporting this edge</return>
  </javadoc>
  <method type="Line" name="getLine" />
  <javadoc>
    <text>Set the node whose cut hyperplane contains this edge.</text>
    <param>node node whose cut hyperplane contains this edge</param>
  </javadoc>
  <method type="void" name="setNode" />
  <javadoc>
    <text>Get the node whose cut hyperplane contains this edge.</text>
    <return>node whose cut hyperplane contains this edge
 * (null if edge has not yet been inserted into the BSP tree)</return>
  </javadoc>
  <method type="BSPTree&lt;Euclidean2D&gt;" name="getNode" />
  <javadoc>
    <text>Split the edge.
 * &lt;p&gt;
 * Once split, this edge is not referenced anymore by the vertices,
 * it is replaced by the two half-edges and an intermediate splitting
 * vertex is introduced to connect these two halves.
 * &lt;/p&gt;</text>
    <param>splitLine line splitting the edge in two halves</param>
    <return>split vertex (its incoming and outgoing edges are the two halves)</return>
  </javadoc>
  <method type="Vertex" name="split">
    <declaration type="Vertex" name="splitVertex" />
    <declaration type="Edge" name="startHalf" />
    <declaration type="Edge" name="endHalf" />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PolygonsSet" name="buildNew" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="computeGeometricalProperties">
    <declaration type="Vector2D[][]" name="v" />
    <scope>
      <declaration type="BSPTree&lt;Euclidean2D&gt;" name="tree" />
      <scope />
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="double" name="sum" />
      <declaration type="double" name="sumX" />
      <declaration type="double" name="sumY" />
      <scope>
        <declaration type="double" name="x1" />
        <declaration type="double" name="y1" />
        <scope>
          <declaration type="double" name="x0" />
          <declaration type="double" name="y0" />
          <declaration type="double" name="factor" />
        </scope>
      </scope>
      <scope />
      <scope />
    </scope>
    <comment>the instance covers the whole space</comment>
    <comment>there is at least one open-loop: the polygon is infinite</comment>
    <comment>all loops are closed, we compute some integrals around the shape</comment>
    <comment>the polygon as a finite outside surrounded by an infinite inside</comment>
  </method>
  <javadoc>
    <text>Get the vertices of the polygon.
 * &lt;p&gt;The polygon boundary can be represented as an array of loops,
 * each loop being itself an array of vertices.&lt;/p&gt;
 * &lt;p&gt;In order to identify open loops which start and end by
 * infinite edges, the open loops arrays start with a null point. In
 * this case, the first non null point and the last point of the
 * array do not represent real vertices, they are dummy points
 * intended only to get the direction of the first and last edge. An
 * open loop consisting of a single infinite line will therefore be
 * represented by a three elements array with one null point
 * followed by two dummy points. The open loops are always the first
 * ones in the loops array.&lt;/p&gt;
 * &lt;p&gt;If the polygon has no boundary at all, a zero length loop
 * array will be returned.&lt;/p&gt;
 * &lt;p&gt;All line segments in the various loops have the inside of the
 * region on their left side and the outside on their right side
 * when moving in the underlying line direction. This means that
 * closed loops surrounding finite areas obey the direct
 * trigonometric orientation.&lt;/p&gt;</text>
    <return>vertices of the polygon, organized as oriented boundary
 * loops with the open loops first (the returned value is guaranteed
 * to be non-null)</return>
  </javadoc>
  <method type="Vector2D[][]" name="getVertices">
    <scope>
      <scope />
      <scope>
        <declaration type="SegmentsBuilder" name="visitor" />
        <declaration type="AVLTree&lt;ComparableSegment&gt;" name="sorted" />
        <declaration type="ArrayList&lt;List&lt;ComparableSegment&gt;&gt;" name="loops" />
        <scope>
          <declaration type="AVLTree&lt;ComparableSegment&gt;.Node" name="node" />
          <declaration type="List&lt;ComparableSegment&gt;" name="loop" />
          <scope />
        </scope>
        <declaration type="int" name="i" />
        <scope>
          <scope>
            <declaration type="Line" name="line" />
          </scope>
          <scope>
            <declaration type="Vector2D[]" name="array" />
            <declaration type="int" name="j" />
            <scope>
              <scope>
                <declaration type="double" name="x" />
              </scope>
              <scope />
              <scope>
                <declaration type="double" name="x" />
              </scope>
            </scope>
          </scope>
          <scope>
            <declaration type="Vector2D[]" name="array" />
            <declaration type="int" name="j" />
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>sort the segments according to their start point</comment>
    <comment>identify the loops, starting from the open ones</comment>
    <comment>(their start segments are naturally at the sorted set beginning)</comment>
    <comment>tranform the loops in an array of arrays of points</comment>
    <comment>single infinite line</comment>
    <comment>open loop with at least one real point</comment>
    <comment>null point and first dummy point</comment>
    <comment>current point</comment>
    <comment>last dummy point</comment>
  </method>
  <javadoc>
    <text>Follow a boundary loop.</text>
    <param>node node containing the segment starting the loop</param>
    <param>sorted set of segments belonging to the boundary, sorted by
 * start points (contains {@code node})</param>
    <return>a list of connected sub-hyperplanes starting at{@code node}</return>
  </javadoc>
  <method type="List&lt;ComparableSegment&gt;" name="followLoop">
    <declaration type="ArrayList&lt;ComparableSegment&gt;" name="loop" />
    <declaration type="ComparableSegment" name="segment" />
    <declaration type="Vector2D" name="globalStart" />
    <declaration type="Vector2D" name="end" />
    <declaration type="boolean" name="open" />
    <scope>
      <declaration type="AVLTree&lt;ComparableSegment&gt;.Node" name="selectedNode" />
      <declaration type="ComparableSegment" name="selectedSegment" />
      <declaration type="double" name="selectedDistance" />
      <declaration type="ComparableSegment" name="lowerLeft" />
      <declaration type="ComparableSegment" name="upperRight" />
      <scope>
        <declaration type="double" name="distance" />
        <scope />
      </scope>
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>is this an open or a closed loop ?</comment>
    <comment>search the sub-hyperplane starting where the previous one ended</comment>
    <comment>this is a degenerated loop, it probably comes from a very</comment>
    <comment>tiny region with some segments smaller than the threshold, we</comment>
    <comment>simply ignore it</comment>
    <comment>this is a degenerated infinitely thin loop, we simply ignore it</comment>
  </method>
  <javadoc>
    <text>Private extension of Segment allowing comparison.</text>
  </javadoc>
  <javadoc>
    <text>Sorting key.</text>
  </javadoc>
  <declaration type="OrderedTuple" name="sortingKey" />
  <javadoc>
    <text>Build a segment.</text>
    <param>start start point of the segment</param>
    <param>end end point of the segment</param>
    <param>line line containing the segment</param>
  </javadoc>
  <method type="constructor" name="ComparableSegment" />
  <javadoc>
    <text>Build a dummy segment.
 * &lt;p&gt;
 * The object built is not a real segment, only the sorting key is used to
 * allow searching in the neighborhood of a point. This is an horrible hack ...
 * &lt;/p&gt;</text>
    <param>start start point of the segment</param>
    <param>dx abscissa offset from the start point</param>
    <param>dy ordinate offset from the start point</param>
  </javadoc>
  <method type="constructor" name="ComparableSegment" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="compareTo" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="hashCode" />
  <javadoc>
    <text>Visitor building segments.</text>
  </javadoc>
  <javadoc>
    <text>Sorted segments.</text>
  </javadoc>
  <declaration type="AVLTree&lt;ComparableSegment&gt;" name="sorted" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="SegmentsBuilder" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Order" name="visitOrder" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitInternalNode">
    <declaration type="BoundaryAttribute&lt;Euclidean2D&gt;" name="attribute" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="visitLeafNode" />
  <javadoc>
    <text>Add he contribution of a boundary facet.</text>
    <param>sub boundary facet</param>
    <param>reversed if true, the facet has the inside on its plus side</param>
  </javadoc>
  <method type="void" name="addContribution">
    <declaration type="AbstractSubHyperplane&lt;Euclidean2D,Euclidean1D&gt;" name="absSub" />
    <declaration type="Line" name="line" />
    <declaration type="List&lt;Interval&gt;" name="intervals" />
    <scope>
      <declaration type="Vector2D" name="start" />
      <declaration type="Vector2D" name="end" />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Get the sorted segments.</text>
    <return>sorted segments</return>
  </javadoc>
  <method type="AVLTree&lt;ComparableSegment&gt;" name="getSorted" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
