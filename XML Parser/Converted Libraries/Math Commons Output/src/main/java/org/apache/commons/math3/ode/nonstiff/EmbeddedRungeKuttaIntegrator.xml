<?xml version="1.0" encoding="UTF-8"?>
<class name="EmbeddedRungeKuttaIntegrator">
  <javadoc>
    <text>This class implements the common part of all embedded Runge-Kutta
 * integrators for Ordinary Differential Equations.
 * &lt;p&gt;These methods are embedded explicit Runge-Kutta methods with two
 * sets of coefficients allowing to estimate the error, their Butcher
 * arrays are as follows :
 * &lt;pre&gt;
 * 0  |
 * c2  | a21
 * c3  | a31  a32
 * ... |        ...
 * cs  | as1  as2  ...  ass-1
 * |--------------------------
 * |  b1   b2  ...   bs-1  bs
 * |  b'1  b'2 ...   b's-1 b's
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;In fact, we rather use the array defined by ej = bj - b'j to
 * compute directly the error rather than computing two estimates and
 * then comparing them.&lt;/p&gt;
 * &lt;p&gt;Some methods are qualified as &lt;i&gt;fsal&lt;/i&gt; (first same as last)
 * methods. This means the last evaluation of the derivatives in one
 * step is the same as the first in the next step. Then, this
 * evaluation can be reused from one step to the next one and the cost
 * of such a method is really s-1 evaluations despite the method still
 * has s stages. This behaviour is true only for successful steps, if
 * the step is rejected after the error estimation phase, no
 * evaluation is saved. For an &lt;i&gt;fsal&lt;/i&gt; method, we have cs = 1 and
 * asi = bi for all i.&lt;/p&gt;</text>
    <version>$Id: EmbeddedRungeKuttaIntegrator.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Indicator for &lt;i&gt;fsal&lt;/i&gt; methods.</text>
  </javadoc>
  <declaration type="boolean" name="fsal" />
  <javadoc>
    <text>Time steps from Butcher array (without the first zero).</text>
  </javadoc>
  <declaration type="double[]" name="c" />
  <javadoc>
    <text>Internal weights from Butcher array (without the first empty row).</text>
  </javadoc>
  <declaration type="double[][]" name="a" />
  <javadoc>
    <text>External weights for the high order method from Butcher array.</text>
  </javadoc>
  <declaration type="double[]" name="b" />
  <javadoc>
    <text>Prototype of the step interpolator.</text>
  </javadoc>
  <declaration type="RungeKuttaStepInterpolator" name="prototype" />
  <javadoc>
    <text>Stepsize control exponent.</text>
  </javadoc>
  <declaration type="double" name="exp" />
  <javadoc>
    <text>Safety factor for stepsize control.</text>
  </javadoc>
  <declaration type="double" name="safety" />
  <javadoc>
    <text>Minimal reduction factor for stepsize control.</text>
  </javadoc>
  <declaration type="double" name="minReduction" />
  <javadoc>
    <text>Maximal growth factor for stepsize control.</text>
  </javadoc>
  <declaration type="double" name="maxGrowth" />
  <javadoc>
    <text>Build a Runge-Kutta integrator with the given Butcher array.</text>
    <param>name name of the method</param>
    <param>fsal indicate that the method is an &lt;i&gt;fsal&lt;/i&gt;</param>
    <param>c time steps from Butcher array (without the first zero)</param>
    <param>a internal weights from Butcher array (without the first empty row)</param>
    <param>b propagation weights for the high order method from Butcher array</param>
    <param>prototype prototype of the step interpolator to use</param>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>scalAbsoluteTolerance allowed absolute error</param>
    <param>scalRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="EmbeddedRungeKuttaIntegrator">
    <comment>set the default values of the algorithm control parameters</comment>
  </method>
  <javadoc>
    <text>Build a Runge-Kutta integrator with the given Butcher array.</text>
    <param>name name of the method</param>
    <param>fsal indicate that the method is an &lt;i&gt;fsal&lt;/i&gt;</param>
    <param>c time steps from Butcher array (without the first zero)</param>
    <param>a internal weights from Butcher array (without the first empty row)</param>
    <param>b propagation weights for the high order method from Butcher array</param>
    <param>prototype prototype of the step interpolator to use</param>
    <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
    <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
    <param>vecAbsoluteTolerance allowed absolute error</param>
    <param>vecRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="EmbeddedRungeKuttaIntegrator">
    <comment>set the default values of the algorithm control parameters</comment>
  </method>
  <method name="getOrder" type="int" />
  <javadoc>
    <text>Get the order of the method.</text>
    <return>order of the method</return>
  </javadoc>
  <javadoc>
    <text>Get the safety factor for stepsize control.</text>
    <return>safety factor</return>
  </javadoc>
  <method type="double" name="getSafety" />
  <javadoc>
    <text>Set the safety factor for stepsize control.</text>
    <param>safety safety factor</param>
  </javadoc>
  <method type="void" name="setSafety" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="integrate">
    <declaration type="boolean" name="forward" />
    <declaration type="double[]" name="y0" />
    <declaration type="double[]" name="y" />
    <declaration type="int" name="stages" />
    <declaration type="double[][]" name="yDotK" />
    <declaration type="double[]" name="yTmp" />
    <declaration type="double[]" name="yDotTmp" />
    <declaration type="RungeKuttaStepInterpolator" name="interpolator" />
    <declaration type="double" name="hNew" />
    <declaration type="boolean" name="firstTime" />
    <scope>
      <declaration type="double" name="error" />
      <scope>
        <scope />
        <scope>
          <declaration type="double[]" name="scale" />
          <scope>
            <scope />
          </scope>
          <scope>
            <scope />
          </scope>
        </scope>
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
        <scope>
          <scope>
            <declaration type="double" name="sum" />
            <scope />
          </scope>
        </scope>
        <scope>
          <declaration type="double" name="sum" />
          <scope />
        </scope>
        <scope>
          <declaration type="double" name="factor" />
        </scope>
      </scope>
      <scope>
        <scope />
        <declaration type="double" name="factor" />
        <declaration type="double" name="scaledH" />
        <declaration type="double" name="nextT" />
        <declaration type="boolean" name="nextIsLast" />
        <declaration type="double" name="filteredNextT" />
        <declaration type="boolean" name="filteredNextIsLast" />
        <scope />
      </scope>
    </scope>
    <comment>create some internal working arrays</comment>
    <comment>set up an interpolator sharing the integrator arrays</comment>
    <comment>set up integration control objects</comment>
    <comment>main integration loop</comment>
    <comment>iterate over step size, ensuring local normalized error is smaller than 1</comment>
    <comment>first stage</comment>
    <comment>next stages</comment>
    <comment>estimate the state at the end of the step</comment>
    <comment>estimate the error at the end of the step</comment>
    <comment>reject the step and attempt to reduce error by stepsize control</comment>
    <comment>local error is small enough: accept the step, trigger events and step handlers</comment>
    <comment>prepare next step</comment>
    <comment>save the last evaluation for the next step</comment>
    <comment>stepsize control for next step</comment>
    <comment>dispatch results</comment>
  </method>
  <javadoc>
    <text>Get the minimal reduction factor for stepsize control.</text>
    <return>minimal reduction factor</return>
  </javadoc>
  <method type="double" name="getMinReduction" />
  <javadoc>
    <text>Set the minimal reduction factor for stepsize control.</text>
    <param>minReduction minimal reduction factor</param>
  </javadoc>
  <method type="void" name="setMinReduction" />
  <javadoc>
    <text>Get the maximal growth factor for stepsize control.</text>
    <return>maximal growth factor</return>
  </javadoc>
  <method type="double" name="getMaxGrowth" />
  <javadoc>
    <text>Set the maximal growth factor for stepsize control.</text>
    <param>maxGrowth maximal growth factor</param>
  </javadoc>
  <method type="void" name="setMaxGrowth" />
  <method name="estimateError" type="double" />
  <javadoc>
    <text>Compute the error ratio.</text>
    <param>yDotK derivatives computed during the first stages</param>
    <param>y0 estimate of the step at the start of the step</param>
    <param>y1 estimate of the step at the end of the step</param>
    <param>h  current step</param>
    <return>error ratio, greater than 1 if step should be rejected</return>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
