<?xml version="1.0" encoding="UTF-8"?>
<class name="Variance">
  <javadoc>
    <text>Computes the variance of the available values.  By default, the unbiased
 * "sample variance" definitional formula is used:
 * &lt;p&gt;
 * variance = sum((x_i - mean)^2) / (n - 1) &lt;/p&gt;
 * &lt;p&gt;
 * where mean is the {@link Mean} and &lt;code&gt;n&lt;/code&gt; is the number
 * of sample observations.&lt;/p&gt;
 * &lt;p&gt;
 * The definitional formula does not have good numerical properties, so
 * this implementation does not compute the statistic using the definitional
 * formula. &lt;ul&gt;
 * &lt;li&gt; The &lt;code&gt;getResult&lt;/code&gt; method computes the variance using
 * updating formulas based on West's algorithm, as described in
 * &lt;a href="http://doi.acm.org/10.1145/359146.359152"&gt; Chan, T. F. and
 * J. G. Lewis 1979, &lt;i&gt;Communications of the ACM&lt;/i&gt;,
 * vol. 22 no. 9, pp. 526-531.&lt;/a&gt;&lt;/li&gt;
 * &lt;li&gt; The &lt;code&gt;evaluate&lt;/code&gt; methods leverage the fact that they have the
 * full array of values in memory to execute a two-pass algorithm.
 * Specifically, these methods use the "corrected two-pass algorithm" from
 * Chan, Golub, Levesque, &lt;i&gt;Algorithms for Computing the Sample Variance&lt;/i&gt;,
 * American Statistician, vol. 37, no. 3 (1983) pp. 242-247.&lt;/li&gt;&lt;/ul&gt;
 * Note that adding values using &lt;code&gt;increment&lt;/code&gt; or
 * &lt;code&gt;incrementAll&lt;/code&gt; and then executing &lt;code&gt;getResult&lt;/code&gt; will
 * sometimes give a different, less accurate, result than executing
 * &lt;code&gt;evaluate&lt;/code&gt; with the full array of values. The former approach
 * should only be used when the full array of values is not available.&lt;/p&gt;
 * &lt;p&gt;
 * The "population variance"  ( sum((x_i - mean)^2) / n ) can also
 * be computed using this statistic.  The &lt;code&gt;isBiasCorrected&lt;/code&gt;
 * property determines whether the "population" or "sample" value is
 * returned by the &lt;code&gt;evaluate&lt;/code&gt; and &lt;code&gt;getResult&lt;/code&gt; methods.
 * To compute population variances, set this property to &lt;code&gt;false.&lt;/code&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; If
 * multiple threads access an instance of this class concurrently, and at least
 * one of the threads invokes the &lt;code&gt;increment()&lt;/code&gt; or
 * &lt;code&gt;clear()&lt;/code&gt; method, it must be synchronized externally.&lt;/p&gt;</text>
    <version>$Id: Variance.java 1416643 2012-12-03 19:37:14Z tn $</version>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>SecondMoment is used in incremental calculation of Variance</text>
  </javadoc>
  <declaration type="SecondMoment" name="moment" />
  <javadoc>
    <text>Whether or not {@link #increment(double)} should increment
 * the internal second moment. When a Variance is constructed with an
 * external SecondMoment as a constructor parameter, this property is
 * set to false and increments must be applied to the second moment
 * directly.</text>
  </javadoc>
  <declaration type="boolean" name="incMoment" />
  <javadoc>
    <text>Whether or not bias correction is applied when computing the
 * value of the statistic. True means that bias is corrected.  See{@link Variance} for details on the formula.</text>
  </javadoc>
  <declaration type="boolean" name="isBiasCorrected" />
  <javadoc>
    <text>Constructs a Variance with default (true) &lt;code&gt;isBiasCorrected&lt;/code&gt;
 * property.</text>
  </javadoc>
  <method type="constructor" name="Variance" />
  <javadoc>
    <text>Constructs a Variance based on an external second moment.
 * When this constructor is used, the statistic may only be
 * incremented via the moment, i.e., {@link #increment(double)}does nothing; whereas {@code m2.increment(value)} increments
 * both {@code m2} and the Variance instance constructed from it.</text>
    <param>m2 the SecondMoment (Third or Fourth moments work
 * here as well.)</param>
  </javadoc>
  <method type="constructor" name="Variance" />
  <javadoc>
    <text>Constructs a Variance with the specified &lt;code&gt;isBiasCorrected&lt;/code&gt;
 * property</text>
    <param>isBiasCorrected  setting for bias correction - true means
 * bias will be corrected and is equivalent to using the argumentless
 * constructor</param>
  </javadoc>
  <method type="constructor" name="Variance" />
  <javadoc>
    <text>Constructs a Variance with the specified &lt;code&gt;isBiasCorrected&lt;/code&gt;
 * property and the supplied external second moment.</text>
    <param>isBiasCorrected  setting for bias correction - true means
 * bias will be corrected</param>
    <param>m2 the SecondMoment (Third or Fourth moments work
 * here as well.)</param>
  </javadoc>
  <method type="constructor" name="Variance" />
  <javadoc>
    <text>Copy constructor, creates a new {@code Variance} identical
 * to the {@code original}</text>
    <param>original the {@code Variance} instance to copy</param>
    <throws>NullArgumentException if original is null</throws>
  </javadoc>
  <method type="constructor" name="Variance" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;If all values are available, it is more accurate to use{@link #evaluate(double[])} rather than adding values one at a time
 * using this method and then executing {@link #getResult}, since
 * &lt;code&gt;evaluate&lt;/code&gt; leverages the fact that is has the full
 * list of values together to execute a two-pass algorithm.
 * See {@link Variance}.&lt;/p&gt;
 * &lt;p&gt;Note also that when {@link #Variance(SecondMoment)} is used to
 * create a Variance, this method does nothing. In that case, the
 * SecondMoment should be incremented directly.&lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="increment">
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="getResult">
    <scope />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="long" name="getN" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="clear">
    <scope />
  </method>
  <javadoc>
    <text>Returns the variance of the entries in the input array, or
 * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
 * &lt;p&gt;
 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;</text>
    <param>values the input array</param>
    <return>the variance of the values or Double.NaN if length = 0</return>
    <throws>MathIllegalArgumentException if the array is null</throws>
  </javadoc>
  <method type="double" name="evaluate">
    <scope />
  </method>
  <javadoc>
    <text>Returns the variance of the entries in the specified portion of
 * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
 * is empty.
 * &lt;p&gt;
 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>begin index of the first array element to include</param>
    <param>length the number of elements to include</param>
    <return>the variance of the values or Double.NaN if length = 0</return>
    <throws>MathIllegalArgumentException if the array is null or the array index
 * parameters are not valid</throws>
  </javadoc>
  <method type="double" name="evaluate">
    <declaration type="double" name="var" />
    <scope>
      <scope />
      <scope>
        <declaration type="Mean" name="mean" />
        <declaration type="double" name="m" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;Returns the weighted variance of the entries in the specified portion of
 * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
 * is empty.&lt;/p&gt;
 * &lt;p&gt;
 * Uses the formula &lt;pre&gt;
 * &amp;Sigma;(weights[i]*(values[i] - weightedMean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
 * &lt;/pre&gt;
 * where weightedMean is the weighted mean&lt;/p&gt;
 * &lt;p&gt;
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length)); &lt;/code&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if any of the following are true:
 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
 * &lt;li&gt;the weights array is null&lt;/li&gt;
 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
 * &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if either array is null.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>weights the weights array</param>
    <param>begin index of the first array element to include</param>
    <param>length the number of elements to include</param>
    <return>the weighted variance of the values or Double.NaN if length = 0</return>
    <throws>MathIllegalArgumentException if the parameters are not valid</throws>
    <since>2.1</since>
  </javadoc>
  <method type="double" name="evaluate">
    <declaration type="double" name="var" />
    <scope>
      <scope />
      <scope>
        <declaration type="Mean" name="mean" />
        <declaration type="double" name="m" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the weighted variance of the entries in the the input array.&lt;/p&gt;
 * &lt;p&gt;
 * Uses the formula &lt;pre&gt;
 * &amp;Sigma;(weights[i]*(values[i] - weightedMean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
 * &lt;/pre&gt;
 * where weightedMean is the weighted mean&lt;/p&gt;
 * &lt;p&gt;
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length)); &lt;/code&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
 * &lt;li&gt;the weights array is null&lt;/li&gt;
 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if either array is null.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>weights the weights array</param>
    <return>the weighted variance of the values</return>
    <throws>MathIllegalArgumentException if the parameters are not valid</throws>
    <since>2.1</since>
  </javadoc>
  <method type="double" name="evaluate" />
  <javadoc>
    <text>Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
 * &lt;p&gt;
 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
 * &lt;p&gt;
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.&lt;/p&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>mean the precomputed mean value</param>
    <param>begin index of the first array element to include</param>
    <param>length the number of elements to include</param>
    <return>the variance of the values or Double.NaN if length = 0</return>
    <throws>MathIllegalArgumentException if the array is null or the array index
 * parameters are not valid</throws>
  </javadoc>
  <method type="double" name="evaluate">
    <declaration type="double" name="var" />
    <scope>
      <scope />
      <scope>
        <declaration type="double" name="accum" />
        <declaration type="double" name="dev" />
        <declaration type="double" name="accum2" />
        <scope />
        <declaration type="double" name="len" />
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Returns the variance of the entries in the input array, using the
 * precomputed mean value.  Returns &lt;code&gt;Double.NaN&lt;/code&gt; if the array
 * is empty.
 * &lt;p&gt;
 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
 * &lt;p&gt;
 * If &lt;code&gt;isBiasCorrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the formula used
 * assumes that the supplied mean value is the arithmetic mean of the
 * sample data, not a known population parameter.  If the mean is a known
 * population parameter, or if the "population" version of the variance is
 * desired, set &lt;code&gt;isBiasCorrected&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; before
 * invoking this method.&lt;/p&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>mean the precomputed mean value</param>
    <return>the variance of the values or Double.NaN if the array is empty</return>
    <throws>MathIllegalArgumentException if the array is null</throws>
  </javadoc>
  <method type="double" name="evaluate" />
  <javadoc>
    <text>Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
 * &lt;p&gt;
 * Uses the formula &lt;pre&gt;
 * &amp;Sigma;(weights[i]*(values[i] - mean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.&lt;/p&gt;
 * &lt;p&gt;
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); &lt;/code&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
 * &lt;li&gt;the weights array is null&lt;/li&gt;
 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
 * &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>weights the weights array</param>
    <param>mean the precomputed weighted mean value</param>
    <param>begin index of the first array element to include</param>
    <param>length the number of elements to include</param>
    <return>the variance of the values or Double.NaN if length = 0</return>
    <throws>MathIllegalArgumentException if the parameters are not valid</throws>
    <since>2.1</since>
  </javadoc>
  <method type="double" name="evaluate">
    <declaration type="double" name="var" />
    <scope>
      <scope />
      <scope>
        <declaration type="double" name="accum" />
        <declaration type="double" name="dev" />
        <declaration type="double" name="accum2" />
        <scope />
        <declaration type="double" name="sumWts" />
        <scope />
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.&lt;/p&gt;
 * &lt;p&gt;
 * Uses the formula &lt;pre&gt;
 * &amp;Sigma;(weights[i]*(values[i] - mean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
 * &lt;/pre&gt;&lt;/p&gt;
 * &lt;p&gt;
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.&lt;/p&gt;
 * &lt;p&gt;
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); &lt;/code&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
 * &lt;p&gt;
 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
 * &lt;li&gt;the weights array is null&lt;/li&gt;
 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * &lt;p&gt;
 * Does not change the internal state of the statistic.&lt;/p&gt;</text>
    <param>values the input array</param>
    <param>weights the weights array</param>
    <param>mean the precomputed weighted mean value</param>
    <return>the variance of the values or Double.NaN if length = 0</return>
    <throws>MathIllegalArgumentException if the parameters are not valid</throws>
    <since>2.1</since>
  </javadoc>
  <method type="double" name="evaluate" />
  <javadoc>
    <return>Returns the isBiasCorrected.</return>
  </javadoc>
  <method type="boolean" name="isBiasCorrected" />
  <javadoc>
    <param>biasCorrected The isBiasCorrected to set.</param>
  </javadoc>
  <method type="void" name="setBiasCorrected" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="Variance" name="copy">
    <declaration type="Variance" name="result" />
    <comment>No try-catch or advertised exception because parameters are guaranteed non-null</comment>
  </method>
  <javadoc>
    <text>Copies source to dest.
 * &lt;p&gt;Neither source nor dest can be null.&lt;/p&gt;</text>
    <param>source Variance to copy</param>
    <param>dest Variance to copy to</param>
    <throws>NullArgumentException if either source or dest is null</throws>
  </javadoc>
  <method type="void" name="copy" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
