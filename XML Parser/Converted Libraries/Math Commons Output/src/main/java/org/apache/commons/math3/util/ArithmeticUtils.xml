<?xml version="1.0" encoding="UTF-8"?>
<class name="ArithmeticUtils">
  <javadoc>
    <text>Some useful, arithmetics related, additions to the built-in functions in{@link Math}.</text>
    <version>$Id: ArithmeticUtils.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
  </javadoc>
  <javadoc>
    <text>All long-representable factorials</text>
  </javadoc>
  <declaration type="long[]" name="FACTORIALS" />
  <javadoc>
    <text>Stirling numbers of the second kind.</text>
  </javadoc>
  <declaration type="AtomicReference&lt;long[][]&gt;" name="STIRLING_S2" />
  <javadoc>
    <text>Private constructor.</text>
  </javadoc>
  <method type="constructor" name="ArithmeticUtils" />
  <javadoc>
    <text>Add two integers, checking for overflow.</text>
    <param>x an addend</param>
    <param>y an addend</param>
    <return>the sum {@code x+y}</return>
    <throws>MathArithmeticException if the result can not be represented
 * as an {@code int}.</throws>
    <since>1.1</since>
  </javadoc>
  <method type="int" name="addAndCheck">
    <declaration type="long" name="s" />
    <scope />
  </method>
  <javadoc>
    <text>Add two long integers, checking for overflow.</text>
    <param>a an addend</param>
    <param>b an addend</param>
    <return>the sum {@code a+b}</return>
    <throws>MathArithmeticException if the result can not be represented as an
 * long</throws>
    <since>1.2</since>
  </javadoc>
  <method type="long" name="addAndCheck" />
  <javadoc>
    <text>Returns an exact representation of the &lt;a
 * href="http://mathworld.wolfram.com/BinomialCoefficient.html"&gt; Binomial
 * Coefficient&lt;/a&gt;, "{@code n choose k}", the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
 * &lt;p&gt;
 * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
 * &lt;li&gt; The result is small enough to fit into a {@code long}. The
 * largest value of {@code n} for which all coefficients are{@code  &lt; Long.MAX_VALUE} is 66. If the computed value exceeds{@code Long.MAX_VALUE} an {@code ArithMeticException} is
 * thrown.&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;</text>
    <param>n the size of the set</param>
    <param>k the size of the subsets to be counted</param>
    <return>{@code n choose k}</return>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
    <throws>NumberIsTooLargeException if {@code k &gt; n}.</throws>
    <throws>MathArithmeticException if the result is too large to be
 * represented by a long integer.</throws>
  </javadoc>
  <method type="long" name="binomialCoefficient">
    <scope />
    <scope />
    <scope />
    <declaration type="long" name="result" />
    <scope>
      <declaration type="int" name="i" />
      <scope />
    </scope>
    <scope>
      <declaration type="int" name="i" />
      <scope>
        <declaration type="long" name="d" />
      </scope>
    </scope>
    <scope>
      <declaration type="int" name="i" />
      <scope>
        <declaration type="long" name="d" />
      </scope>
    </scope>
    <comment>Use symmetry for large k</comment>
    <comment>We use the formula</comment>
    <comment>(n choose k) = n! / (n-k)! / k!</comment>
    <comment>(n choose k) == ((n-k+1)*...*n) / (1*...*k)</comment>
    <comment>which could be written</comment>
    <comment>(n choose k) == (n-1 choose k-1) * n / k</comment>
    <comment>For n &lt;= 61, the naive implementation cannot overflow.</comment>
    <comment>For n &gt; 61 but n &lt;= 66, the result cannot overflow,</comment>
    <comment>but we must take care not to overflow intermediate values.</comment>
    <comment>We know that (result * i) is divisible by j,</comment>
    <comment>but (result * i) may overflow, so we split j:</comment>
    <comment>Filter out the gcd, d, so j/d and i/d are integer.</comment>
    <comment>result is divisible by (j/d) because (j/d)</comment>
    <comment>is relative prime to (i/d) and is a divisor of</comment>
    <comment>result * (i/d).</comment>
    <comment>For n &gt; 66, a result overflow might occur, so we check</comment>
    <comment>the multiplication, taking care to not overflow</comment>
    <comment>unnecessary.</comment>
  </method>
  <javadoc>
    <text>Returns a {@code double} representation of the &lt;a
 * href="http://mathworld.wolfram.com/BinomialCoefficient.html"&gt; Binomial
 * Coefficient&lt;/a&gt;, "{@code n choose k}", the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
 * &lt;p&gt;
 * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
 * &lt;li&gt; The result is small enough to fit into a {@code double}. The
 * largest value of {@code n} for which all coefficients are &lt;
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;</text>
    <param>n the size of the set</param>
    <param>k the size of the subsets to be counted</param>
    <return>{@code n choose k}</return>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
    <throws>NumberIsTooLargeException if {@code k &gt; n}.</throws>
    <throws>MathArithmeticException if the result is too large to be
 * represented by a long integer.</throws>
  </javadoc>
  <method type="double" name="binomialCoefficientDouble">
    <scope />
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="result" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the natural {@code log} of the &lt;a
 * href="http://mathworld.wolfram.com/BinomialCoefficient.html"&gt; Binomial
 * Coefficient&lt;/a&gt;, "{@code n choose k}", the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
 * &lt;p&gt;
 * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;</text>
    <param>n the size of the set</param>
    <param>k the size of the subsets to be counted</param>
    <return>{@code n choose k}</return>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
    <throws>NumberIsTooLargeException if {@code k &gt; n}.</throws>
    <throws>MathArithmeticException if the result is too large to be
 * represented by a long integer.</throws>
  </javadoc>
  <method type="double" name="binomialCoefficientLog">
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <declaration type="double" name="logSum" />
    <scope />
    <scope />
    <comment>For values small enough to do exact integer computation,
 return the log of the exact value</comment>
    <comment>Return the log of binomialCoefficientDouble for values that will not
 overflow binomialCoefficientDouble</comment>
    <comment>Sum logs for values that could overflow</comment>
    <comment>n!/(n-k)!</comment>
    <comment>divide by k!</comment>
  </method>
  <javadoc>
    <text>Returns n!. Shorthand for {@code n} &lt;a
 * href="http://mathworld.wolfram.com/Factorial.html"&gt; Factorial&lt;/a&gt;, the
 * product of the numbers {@code 1,...,n}.
 * &lt;p&gt;
 * &lt;Strong&gt;Preconditions&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt; {@code n &gt;= 0} (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
 * &lt;li&gt; The result is small enough to fit into a {@code long}. The
 * largest value of {@code n} for which {@code n!} &lt;
 * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}an {@code ArithMeticException } is thrown.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;</text>
    <param>n argument</param>
    <return>{@code n!}</return>
    <throws>MathArithmeticException if the result is too large to be represented
 * by a {@code long}.</throws>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
    <throws>MathArithmeticException if {@code n &gt; 20}: The factorial value is too
 * large to fit in a {@code long}.</throws>
  </javadoc>
  <method type="long" name="factorial">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compute n!, the&lt;a href="http://mathworld.wolfram.com/Factorial.html"&gt;
 * factorial&lt;/a&gt; of {@code n} (the product of the numbers 1 to n), as a{@code double}.
 * The result should be small enough to fit into a {@code double}: The
 * largest {@code n} for which {@code n! &lt; Double.MAX_VALUE} is 170.
 * If the computed value exceeds {@code Double.MAX_VALUE},{@code Double.POSITIVE_INFINITY} is returned.</text>
    <param>n Argument.</param>
    <return>{@code n!}</return>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
  </javadoc>
  <method type="double" name="factorialDouble">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Compute the natural logarithm of the factorial of {@code n}.</text>
    <param>n Argument.</param>
    <return>{@code n!}</return>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
  </javadoc>
  <method type="double" name="factorialLog">
    <scope />
    <scope />
    <declaration type="double" name="logSum" />
    <scope />
  </method>
  <javadoc>
    <text>Computes the greatest common divisor of the absolute value of two
 * numbers, using a modified version of the "binary gcd" method.
 * See Knuth 4.5.2 algorithm B.
 * The algorithm is due to Josef Stein (1961).
 * &lt;br/&gt;
 * Special cases:
 * &lt;ul&gt;
 * &lt;li&gt;The invocations{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},{@code gcd(Integer.MIN_VALUE, 0)} and{@code gcd(0, Integer.MIN_VALUE)} throw an{@code ArithmeticException}, because the result would be 2^31, which
 * is too large for an int value.&lt;/li&gt;
 * &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0, x)} and{@code gcd(x, 0)} is the absolute value of {@code x}, except
 * for the special cases above.&lt;/li&gt;
 * &lt;li&gt;The invocation {@code gcd(0, 0)} is the only one which returns{@code 0}.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>p Number.</param>
    <param>q Number.</param>
    <return>the greatest common divisor (never negative).</return>
    <throws>MathArithmeticException if the result cannot be represented as
 * a non-negative {@code int} value.</throws>
    <since>1.1</since>
  </javadoc>
  <method type="int" name="gcd">
    <declaration type="int" name="a" />
    <declaration type="int" name="b" />
    <scope>
      <scope />
    </scope>
    <declaration type="long" name="al" />
    <declaration type="long" name="bl" />
    <declaration type="boolean" name="useLong" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <declaration type="long" name="blbu" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>Now "al" and "bl" fit in an "int".</comment>
  </method>
  <javadoc>
    <text>Computes the greatest common divisor of two &lt;em&gt;positive&lt;/em&gt; numbers
 * (this precondition is &lt;em&gt;not&lt;/em&gt; checked and the result is undefined
 * if not fulfilled) using the "binary gcd" method which avoids division
 * and modulo operations.
 * See Knuth 4.5.2 algorithm B.
 * The algorithm is due to Josef Stein (1961).
 * &lt;br/&gt;
 * Special cases:
 * &lt;ul&gt;
 * &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0, x)} and{@code gcd(x, 0)} is the value of {@code x}.&lt;/li&gt;
 * &lt;li&gt;The invocation {@code gcd(0, 0)} is the only one which returns{@code 0}.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>a Positive number.</param>
    <param>b Positive number.</param>
    <return>the greatest common divisor.</return>
  </javadoc>
  <method type="int" name="gcdPositive">
    <scope />
    <scope />
    <declaration type="int" name="aTwos" />
    <declaration type="int" name="bTwos" />
    <declaration type="int" name="shift" />
    <scope>
      <declaration type="int" name="delta" />
    </scope>
    <comment>Make "a" and "b" odd, keeping track of common power of 2.</comment>
    <comment>"a" and "b" are positive.</comment>
    <comment>If a &gt; b then "gdc(a, b)" is equal to "gcd(a - b, b)".</comment>
    <comment>If a &lt; b then "gcd(a, b)" is equal to "gcd(b - a, a)".</comment>
    <comment>Hence, in the successive iterations:</comment>
    <comment>"a" becomes the absolute difference of the current values,</comment>
    <comment>"b" becomes the minimum of the current values.</comment>
    <comment>Remove any power of 2 in "a" ("b" is guaranteed to be odd).</comment>
    <comment>Recover the common power of 2.</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the "binary gcd" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * &lt;/p&gt;
 * Special cases:
 * &lt;ul&gt;
 * &lt;li&gt;The invocations{@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},{@code gcd(Long.MIN_VALUE, 0L)} and{@code gcd(0L, Long.MIN_VALUE)} throw an{@code ArithmeticException}, because the result would be 2^63, which
 * is too large for a long value.&lt;/li&gt;
 * &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and{@code gcd(x, 0L)} is the absolute value of {@code x}, except
 * for the special cases above.
 * &lt;li&gt;The invocation {@code gcd(0L, 0L)} is the only one which returns{@code 0L}.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <param>p Number.</param>
    <param>q Number.</param>
    <return>the greatest common divisor, never negative.</return>
    <throws>MathArithmeticException if the result cannot be represented as
 * a non-negative {@code long} value.</throws>
    <since>2.1</since>
  </javadoc>
  <method type="long" name="gcd">
    <declaration type="long" name="u" />
    <declaration type="long" name="v" />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope />
    <declaration type="int" name="k" />
    <scope />
    <scope />
    <declaration type="long" name="t" />
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>keep u and v negative, as negative integers range down to</comment>
    <comment>-2^63, while positive numbers can only be as large as 2^63-1</comment>
    <comment>(i.e. we can't necessarily negate a negative number without</comment>
    <comment>overflow)</comment>
    <comment>assert u!=0 &amp;&amp; v!=0;</comment>
    <comment>make u negative</comment>
    <comment>make v negative</comment>
    <comment>B1. [Find power of 2]</comment>
    <comment>while u and v are</comment>
    <comment>both even...</comment>
    <comment>cast out twos.</comment>
    <comment>B2. Initialize: u and v have been divided by 2^k and at least</comment>
    <comment>one is odd.</comment>
    <comment>long t = ((u &amp; 1) == 1) ? v : -(u  2) B3 ;</comment>
    <comment>t negative: u was odd, v may be even (t replaces v)</comment>
    <comment>t positive: u was even, v is odd (t replaces u)</comment>
    <comment>assert u&lt;0 &amp;&amp; v&lt;0;</comment>
    <comment>B4/B3: cast out twos from t.</comment>
    <comment>while t is even..</comment>
    <comment>cast out twos</comment>
    <comment>B5 [reset max(u,v)]</comment>
    <comment>B6/B3. at this point both u and v should be odd.</comment>
    <comment>|u| larger: t positive (replace u)</comment>
    <comment>|v| larger: t negative (replace v)</comment>
    <comment>gcd is u*2^k</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.
 * &lt;/p&gt;
 * Special cases:
 * &lt;ul&gt;
 * &lt;li&gt;The invocations {@code lcm(Integer.MIN_VALUE, n)} and{@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a
 * power of 2, throw an {@code ArithmeticException}, because the result
 * would be 2^31, which is too large for an int value.&lt;/li&gt;
 * &lt;li&gt;The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is{@code 0} for any {@code x}.
 * &lt;/ul&gt;</text>
    <param>a Number.</param>
    <param>b Number.</param>
    <return>the least common multiple, never negative.</return>
    <throws>MathArithmeticException if the result cannot be represented as
 * a non-negative {@code int} value.</throws>
    <since>1.1</since>
  </javadoc>
  <method type="int" name="lcm">
    <scope />
    <declaration type="int" name="lcm" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.
 * &lt;/p&gt;
 * Special cases:
 * &lt;ul&gt;
 * &lt;li&gt;The invocations {@code lcm(Long.MIN_VALUE, n)} and{@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a
 * power of 2, throw an {@code ArithmeticException}, because the result
 * would be 2^63, which is too large for an int value.&lt;/li&gt;
 * &lt;li&gt;The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is{@code 0L} for any {@code x}.
 * &lt;/ul&gt;</text>
    <param>a Number.</param>
    <param>b Number.</param>
    <return>the least common multiple, never negative.</return>
    <throws>MathArithmeticException if the result cannot be represented
 * as a non-negative {@code long} value.</throws>
    <since>2.1</since>
  </javadoc>
  <method type="long" name="lcm">
    <scope />
    <declaration type="long" name="lcm" />
    <scope />
  </method>
  <javadoc>
    <text>Multiply two integers, checking for overflow.</text>
    <param>x Factor.</param>
    <param>y Factor.</param>
    <return>the product {@code x * y}.</return>
    <throws>MathArithmeticException if the result can not be
 * represented as an {@code int}.</throws>
    <since>1.1</since>
  </javadoc>
  <method type="int" name="mulAndCheck">
    <declaration type="long" name="m" />
    <scope />
  </method>
  <javadoc>
    <text>Multiply two long integers, checking for overflow.</text>
    <param>a Factor.</param>
    <param>b Factor.</param>
    <return>the product {@code a * b}.</return>
    <throws>MathArithmeticException if the result can not be represented
 * as a {@code long}.</throws>
    <since>1.2</since>
  </javadoc>
  <method type="long" name="mulAndCheck">
    <declaration type="long" name="ret" />
    <scope />
    <scope>
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
    </scope>
    <comment>use symmetry to reduce boundary cases</comment>
    <comment>check for positive overflow with negative a, negative b</comment>
    <comment>check for negative overflow with negative a, positive b</comment>
    <comment>assert b == 0</comment>
    <comment>assert a &gt; 0</comment>
    <comment>assert b &gt; 0</comment>
    <comment>check for positive overflow with positive a, positive b</comment>
    <comment>assert a == 0</comment>
  </method>
  <javadoc>
    <text>Subtract two integers, checking for overflow.</text>
    <param>x Minuend.</param>
    <param>y Subtrahend.</param>
    <return>the difference {@code x - y}.</return>
    <throws>MathArithmeticException if the result can not be represented
 * as an {@code int}.</throws>
    <since>1.1</since>
  </javadoc>
  <method type="int" name="subAndCheck">
    <declaration type="long" name="s" />
    <scope />
  </method>
  <javadoc>
    <text>Subtract two long integers, checking for overflow.</text>
    <param>a Value.</param>
    <param>b Value.</param>
    <return>the difference {@code a - b}.</return>
    <throws>MathArithmeticException if the result can not be represented as a{@code long}.</throws>
    <since>1.2</since>
  </javadoc>
  <method type="long" name="subAndCheck">
    <declaration type="long" name="ret" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>use additive inverse</comment>
  </method>
  <javadoc>
    <text>Raise an int to an int power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="int" name="pow">
    <scope />
    <declaration type="int" name="result" />
    <declaration type="int" name="k2p" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Raise an int to a long power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="int" name="pow">
    <scope />
    <declaration type="int" name="result" />
    <declaration type="int" name="k2p" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Raise a long to an int power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="long" name="pow">
    <scope />
    <declaration type="long" name="result" />
    <declaration type="long" name="k2p" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Raise a long to a long power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="long" name="pow">
    <scope />
    <declaration type="long" name="result" />
    <declaration type="long" name="k2p" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Raise a BigInteger to an int power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="BigInteger" name="pow">
    <scope />
  </method>
  <javadoc>
    <text>Raise a BigInteger to a long power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="BigInteger" name="pow">
    <scope />
    <declaration type="BigInteger" name="result" />
    <declaration type="BigInteger" name="k2p" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Raise a BigInteger to a BigInteger power.</text>
    <param>k Number to raise.</param>
    <param>e Exponent (must be positive or zero).</param>
    <return>k&lt;sup&gt;e&lt;/sup&gt;</return>
    <throws>NotPositiveException if {@code e &lt; 0}.</throws>
  </javadoc>
  <method type="BigInteger" name="pow">
    <scope />
    <declaration type="BigInteger" name="result" />
    <declaration type="BigInteger" name="k2p" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the &lt;a
 * href="http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html"&gt;
 * Stirling number of the second kind&lt;/a&gt;, "{@code S(n,k)}", the number of
 * ways of partitioning an {@code n}-element set into {@code k} non-empty
 * subsets.
 * &lt;p&gt;
 * The preconditions are {@code 0 &lt;= k &lt;= n } (otherwise{@code NotPositiveException} is thrown)
 * &lt;/p&gt;</text>
    <param>n the size of the set</param>
    <param>k the number of non-empty subsets</param>
    <return>{@code S(n,k)}</return>
    <throws>NotPositiveException if {@code k &lt; 0}.</throws>
    <throws>NumberIsTooLargeException if {@code k &gt; n}.</throws>
    <throws>MathArithmeticException if some overflow happens, typically for n exceeding 25 and
 * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)</throws>
    <since>3.1</since>
  </javadoc>
  <method type="long" name="stirlingS2">
    <scope />
    <scope />
    <declaration type="long[][]" name="stirlingS2" />
    <scope>
      <declaration type="int" name="maxIndex" />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
      <scope>
        <declaration type="long" name="sum" />
        <declaration type="long" name="sign" />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>the cache has never been initialized, compute the first numbers</comment>
    <comment>by direct recurrence relation</comment>
    <comment>as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE</comment>
    <comment>we must stop computation at row 26</comment>
    <comment>atomically save the cache</comment>
    <comment>the number is in the small cache</comment>
    <comment>use explicit formula to compute the number without caching it</comment>
    <comment>definition formula: note that this may trigger some overflow</comment>
    <comment>there was an overflow somewhere</comment>
  </method>
  <javadoc>
    <text>Add two long integers, checking for overflow.</text>
    <param>a Addend.</param>
    <param>b Addend.</param>
    <param>pattern Pattern to use for any thrown exception.</param>
    <return>the sum {@code a + b}.</return>
    <throws>MathArithmeticException if the result cannot be represented
 * as a {@code long}.</throws>
    <since>1.2</since>
  </javadoc>
  <method type="long" name="addAndCheck">
    <declaration type="long" name="ret" />
    <scope />
    <scope>
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
      </scope>
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>use symmetry to reduce boundary cases</comment>
    <comment>assert a &lt;= b</comment>
    <comment>check for negative overflow</comment>
    <comment>opposite sign addition is always safe</comment>
    <comment>assert a &gt;= 0</comment>
    <comment>assert b &gt;= 0</comment>
    <comment>check for positive overflow</comment>
  </method>
  <javadoc>
    <text>Check binomial preconditions.</text>
    <param>n Size of the set.</param>
    <param>k Size of the subsets to be counted.</param>
    <throws>NotPositiveException if {@code n &lt; 0}.</throws>
    <throws>NumberIsTooLargeException if {@code k &gt; n}.</throws>
  </javadoc>
  <method type="void" name="checkBinomial">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns true if the argument is a power of two.</text>
    <param>n the number to test</param>
    <return>true if the argument is a power of two</return>
  </javadoc>
  <method type="boolean" name="isPowerOfTwo" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
