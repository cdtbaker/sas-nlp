<?xml version="1.0" encoding="UTF-8"?>
<class name="QRDecomposition">
  <javadoc>
    <text>Calculates the QR-decomposition of a matrix.
 * &lt;p&gt;The QR-decomposition of a matrix A consists of two matrices Q and R
 * that satisfy: A = QR, Q is orthogonal (Q&lt;sup&gt;T&lt;/sup&gt;Q = I), and R is
 * upper triangular. If A is m&amp;times;n, Q is m&amp;times;m and R m&amp;times;n.&lt;/p&gt;
 * &lt;p&gt;This class compute the decomposition using Householder reflectors.&lt;/p&gt;
 * &lt;p&gt;For efficiency purposes, the decomposition in packed form is transposed.
 * This allows inner loop to iterate inside rows, which is much more cache-efficient
 * in Java.&lt;/p&gt;
 * &lt;p&gt;This class is based on the class with similar name from the
 * &lt;a href="http://math.nist.gov/javanumerics/jama/"&gt;JAMA&lt;/a&gt; library, with the
 * following changes:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;a {@link #getQT() getQT} method has been added,&lt;/li&gt;
 * &lt;li&gt;the {@code solve} and {@code isFullRank} methods have been replaced
 * by a {@link #getSolver() getSolver} method and the equivalent methods
 * provided by the returned {@link DecompositionSolver}.&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <see>&lt;a href="http://mathworld.wolfram.com/QRDecomposition.html"&gt;MathWorld&lt;/a&gt;</see>
    <see>&lt;a href="http://en.wikipedia.org/wiki/QR_decomposition"&gt;Wikipedia&lt;/a&gt;</see>
    <version>$Id: QRDecomposition.java 1462423 2013-03-29 07:25:18Z luc $</version>
    <since>1.2 (changed to concrete class in 3.0)</since>
  </javadoc>
  <javadoc>
    <text>A packed TRANSPOSED representation of the QR decomposition.
 * &lt;p&gt;The elements BELOW the diagonal are the elements of the UPPER triangular
 * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors
 * from which an explicit form of Q can be recomputed if desired.&lt;/p&gt;</text>
  </javadoc>
  <declaration type="double[][]" name="qrt" />
  <javadoc>
    <text>The diagonal elements of R.</text>
  </javadoc>
  <declaration type="double[]" name="rDiag" />
  <javadoc>
    <text>Cached value of Q.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedQ" />
  <javadoc>
    <text>Cached value of QT.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedQT" />
  <javadoc>
    <text>Cached value of R.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedR" />
  <javadoc>
    <text>Cached value of H.</text>
  </javadoc>
  <declaration type="RealMatrix" name="cachedH" />
  <javadoc>
    <text>Singularity threshold.</text>
  </javadoc>
  <declaration type="double" name="threshold" />
  <javadoc>
    <text>Calculates the QR-decomposition of the given matrix.
 * The singularity threshold defaults to zero.</text>
    <param>matrix The matrix to decompose.</param>
    <see>#QRDecomposition(RealMatrix,double)</see>
  </javadoc>
  <method type="constructor" name="QRDecomposition" />
  <javadoc>
    <text>Calculates the QR-decomposition of the given matrix.</text>
    <param>matrix The matrix to decompose.</param>
    <param>threshold Singularity threshold.</param>
  </javadoc>
  <method type="constructor" name="QRDecomposition">
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
  </method>
  <javadoc>
    <text>Decompose matrix.</text>
    <param>matrix transposed matrix</param>
    <since>3.2</since>
  </javadoc>
  <method type="void" name="decompose">
    <scope />
  </method>
  <javadoc>
    <text>Perform Householder reflection for a minor A(minor, minor) of A.</text>
    <param>minor minor index</param>
    <param>matrix transposed matrix</param>
    <since>3.2</since>
  </javadoc>
  <method type="void" name="performHouseholderReflection">
    <declaration type="double[]" name="qrtMinor" />
    <declaration type="double" name="xNormSqr" />
    <scope>
      <declaration type="double" name="c" />
    </scope>
    <declaration type="double" name="a" />
    <scope>
      <scope>
        <declaration type="double[]" name="qrtCol" />
        <declaration type="double" name="alpha" />
        <scope />
        <scope />
      </scope>
    </scope>
    <comment>Let x be the first column of the minor, and a^2 = |x|^2.
 x will be in the positions qr[minor][minor] through qr[m][minor].
 The first column of the transformed minor will be (a,0,0,..)'
 The sign of a is chosen to be opposite to the sign of the first
 component of x. Let's find a:</comment>
    <comment>Calculate the normalized reflection vector v and transform
 the first column. We know the norm of v beforehand: v = x-ae
 so |v|^2 = &lt;x-ae,x-ae&gt; = &lt;x,x&gt;-2a&lt;x,e&gt;+a^2&lt;e,e&gt; =
 a^2+a^2-2a&lt;x,e&gt; = 2a(a - &lt;x,e&gt;).
 Here &lt;x, e&gt; is now qr[minor][minor].
 v = x-ae is stored in the column at qr:</comment>
    <comment>now |v|^2 = -2a*(qr[minor][minor])</comment>
    <comment>Transform the rest of the columns of the minor:
 They will be transformed by the matrix H = I-2vv'|v|^2.
 If x is a column vector of the minor, then
 Hx = (I-2vv'|v|^2)x = x-2vv'x|v|^2 = x - 2&lt;x,v&gt;|v|^2 v.
 Therefore the transformation is easily calculated by
 subtracting the column vector (2&lt;x,v&gt;|v|^2)v from x.

 Let 2&lt;x,v&gt;|v|^2 = alpha. From above we have
 |v|^2 = -2a(qr[minor][minor]), so
 alpha = -&lt;x,v&gt;(aqr[minor][minor])</comment>
    <comment>Subtract the column vector alpha*v from x.</comment>
  </method>
  <javadoc>
    <text>Returns the matrix R of the decomposition.
 * &lt;p&gt;R is an upper-triangular matrix&lt;/p&gt;</text>
    <return>the R matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getR">
    <scope>
      <declaration type="int" name="n" />
      <declaration type="int" name="m" />
      <declaration type="double[][]" name="ra" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>R is supposed to be m x n</comment>
    <comment>copy the diagonal from rDiag and the upper triangle of qr</comment>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the matrix Q of the decomposition.
 * &lt;p&gt;Q is an orthogonal matrix&lt;/p&gt;</text>
    <return>the Q matrix</return>
  </javadoc>
  <method type="RealMatrix" name="getQ">
    <scope />
  </method>
  <javadoc>
    <text>Returns the transpose of the matrix Q of the decomposition.
 * &lt;p&gt;Q is an orthogonal matrix&lt;/p&gt;</text>
    <return>the transpose of the Q matrix, Q&lt;sup&gt;T&lt;/sup&gt;</return>
  </javadoc>
  <method type="RealMatrix" name="getQT">
    <scope>
      <declaration type="int" name="n" />
      <declaration type="int" name="m" />
      <declaration type="double[][]" name="qta" />
      <scope />
      <scope>
        <declaration type="double[]" name="qrtMinor" />
        <scope>
          <scope>
            <declaration type="double" name="alpha" />
            <scope />
            <scope />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>QT is supposed to be m x m</comment>
    <comment>Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then
 applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in
 succession to the result</comment>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Returns the Householder reflector vectors.
 * &lt;p&gt;H is a lower trapezoidal matrix whose columns represent
 * each successive Householder reflector vector. This matrix is used
 * to compute Q.&lt;/p&gt;</text>
    <return>a matrix containing the Householder reflector vectors</return>
  </javadoc>
  <method type="RealMatrix" name="getH">
    <scope>
      <declaration type="int" name="n" />
      <declaration type="int" name="m" />
      <declaration type="double[][]" name="ha" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>return the cached matrix</comment>
  </method>
  <javadoc>
    <text>Get a solver for finding the A &amp;times; X = B solution in least square sense.</text>
    <return>a solver</return>
  </javadoc>
  <method type="DecompositionSolver" name="getSolver" />
  <javadoc>
    <text>Specialized solver.</text>
  </javadoc>
  <javadoc>
    <text>A packed TRANSPOSED representation of the QR decomposition.
 * &lt;p&gt;The elements BELOW the diagonal are the elements of the UPPER triangular
 * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors
 * from which an explicit form of Q can be recomputed if desired.&lt;/p&gt;</text>
  </javadoc>
  <declaration type="double[][]" name="qrt" />
  <javadoc>
    <text>The diagonal elements of R.</text>
  </javadoc>
  <declaration type="double[]" name="rDiag" />
  <javadoc>
    <text>Singularity threshold.</text>
  </javadoc>
  <declaration type="double" name="threshold" />
  <javadoc>
    <text>Build a solver from decomposed matrix.</text>
    <param>qrt Packed TRANSPOSED representation of the QR decomposition.</param>
    <param>rDiag Diagonal elements of R.</param>
    <param>threshold Singularity threshold.</param>
  </javadoc>
  <method type="constructor" name="Solver" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="isNonSingular">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealVector" name="solve">
    <declaration type="int" name="n" />
    <declaration type="int" name="m" />
    <scope />
    <scope />
    <declaration type="double[]" name="x" />
    <declaration type="double[]" name="y" />
    <scope>
      <declaration type="double[]" name="qrtMinor" />
      <declaration type="double" name="dotProduct" />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="double" name="yRow" />
      <declaration type="double[]" name="qrtRow" />
      <scope />
    </scope>
    <comment>apply Householder transforms to solve Q.y = b</comment>
    <comment>solve triangular system R.x = y</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealMatrix" name="solve">
    <declaration type="int" name="n" />
    <declaration type="int" name="m" />
    <scope />
    <scope />
    <declaration type="int" name="columns" />
    <declaration type="int" name="blockSize" />
    <declaration type="int" name="cBlocks" />
    <declaration type="double[][]" name="xBlocks" />
    <declaration type="double[][]" name="y" />
    <declaration type="double[]" name="alpha" />
    <scope>
      <declaration type="int" name="kStart" />
      <declaration type="int" name="kEnd" />
      <declaration type="int" name="kWidth" />
      <scope>
        <declaration type="double[]" name="qrtMinor" />
        <declaration type="double" name="factor" />
        <scope>
          <declaration type="double" name="d" />
          <declaration type="double[]" name="yRow" />
          <scope />
        </scope>
        <scope />
        <scope>
          <declaration type="double" name="d" />
          <declaration type="double[]" name="yRow" />
          <scope />
        </scope>
      </scope>
      <scope>
        <declaration type="int" name="jBlock" />
        <declaration type="int" name="jStart" />
        <declaration type="double" name="factor" />
        <declaration type="double[]" name="yJ" />
        <declaration type="double[]" name="xBlock" />
        <declaration type="int" name="index" />
        <scope />
        <declaration type="double[]" name="qrtJ" />
        <scope>
          <declaration type="double" name="rIJ" />
          <declaration type="double[]" name="yI" />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>get the right hand side vector</comment>
    <comment>apply Householder transforms to solve Q.y = b</comment>
    <comment>solve triangular system R.x = y</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="RealMatrix" name="getInverse" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
