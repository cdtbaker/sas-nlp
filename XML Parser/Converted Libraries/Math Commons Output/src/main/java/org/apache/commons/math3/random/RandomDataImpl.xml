<?xml version="1.0" encoding="UTF-8"?>
<class name="RandomDataImpl">
  <javadoc>
    <text>Generates random deviates and other random data using a {@link RandomGenerator}instance to generate non-secure data and a {@link java.security.SecureRandom}instance to provide data for the &lt;code&gt;nextSecureXxx&lt;/code&gt; methods. If no
 * &lt;code&gt;RandomGenerator&lt;/code&gt; is provided in the constructor, the default is
 * to use a {@link Well19937c} generator. To plug in a different
 * implementation, either implement &lt;code&gt;RandomGenerator&lt;/code&gt; directly or
 * extend {@link AbstractRandomGenerator}.
 * &lt;p&gt;
 * Supports reseeding the underlying pseudo-random number generator (PRNG). The
 * &lt;code&gt;SecurityProvider&lt;/code&gt; and &lt;code&gt;Algorithm&lt;/code&gt; used by the
 * &lt;code&gt;SecureRandom&lt;/code&gt; instance can also be reset.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For details on the default PRNGs, see {@link java.util.Random} and{@link java.security.SecureRandom}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Usage Notes&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Instance variables are used to maintain &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances used in data generation. Therefore, to
 * generate a random sequence of values or strings, you should use just
 * &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;RandomDataGenerator&lt;/code&gt; instance repeatedly.&lt;/li&gt;
 * &lt;li&gt;
 * The "secure" methods are *much* slower. These should be used only when a
 * cryptographically secure random sequence is required. A secure random
 * sequence is a sequence of pseudo-random values which, in addition to being
 * well-dispersed (so no subsequence of values is an any more likely than other
 * subsequence of the the same length), also has the additional property that
 * knowledge of values generated up to any point in the sequence does not make
 * it any easier to predict subsequent values.&lt;/li&gt;
 * &lt;li&gt;
 * When a new &lt;code&gt;RandomDataGenerator&lt;/code&gt; is created, the underlying random
 * number generators are &lt;strong&gt;not&lt;/strong&gt; initialized. If you do not
 * explicitly seed the default non-secure generator, it is seeded with the
 * current time in milliseconds plus the system identity hash code on first use.
 * The same holds for the secure generator. If you provide a &lt;code&gt;RandomGenerator&lt;/code&gt;
 * to the constructor, however, this generator is not reseeded by the constructor
 * nor is it reseeded on first use.&lt;/li&gt;
 * &lt;li&gt;
 * The &lt;code&gt;reSeed&lt;/code&gt; and &lt;code&gt;reSeedSecure&lt;/code&gt; methods delegate to the
 * corresponding methods on the underlying &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances. Therefore, &lt;code&gt;reSeed(long)&lt;/code&gt;
 * fully resets the initial state of the non-secure random number generator (so
 * that reseeding with a specific value always results in the same subsequent
 * random sequence); whereas reSeedSecure(long) does &lt;strong&gt;not&lt;/strong&gt;
 * reinitialize the secure random number generator (so secure sequences started
 * with calls to reseedSecure(long) won't be identical).&lt;/li&gt;
 * &lt;li&gt;
 * This implementation is not synchronized. The underlying &lt;code&gt;RandomGenerator&lt;/code&gt;
 * or &lt;code&gt;SecureRandom&lt;/code&gt; instances are not protected by synchronization and
 * are not guaranteed to be thread-safe.  Therefore, if an instance of this class
 * is concurrently utilized by multiple threads, it is the responsibility of
 * client code to synchronize access to seeding and data generation methods.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;</text>
    <deprecated>to be removed in 4.0.  Use {@link RandomDataGenerator} instead</deprecated>
    <version>$Id: RandomDataImpl.java 1421917 2012-12-14 15:05:18Z erans $</version>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>RandomDataGenerator delegate</text>
  </javadoc>
  <declaration type="RandomDataGenerator" name="delegate" />
  <javadoc>
    <text>Construct a RandomDataImpl, using a default random generator as the source
 * of randomness.
 * &lt;p&gt;The default generator is a {@link Well19937c} seeded
 * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.
 * The generator is initialized and seeded on first use.&lt;/p&gt;</text>
  </javadoc>
  <method type="constructor" name="RandomDataImpl" />
  <javadoc>
    <text>Construct a RandomDataImpl using the supplied {@link RandomGenerator} as
 * the source of (non-secure) random data.</text>
    <param>rand the source of (non-secure) random data
 * (may be null, resulting in the default generator)</param>
    <since>1.1</since>
  </javadoc>
  <method type="constructor" name="RandomDataImpl" />
  <javadoc>
    <return>the delegate object.</return>
    <deprecated>To be removed in 4.0.</deprecated>
  </javadoc>
  <method type="RandomDataGenerator" name="getDelegate" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated using a
 * 2-step process.
 * &lt;ol&gt;
 * &lt;li&gt;{@code len / 2 + 1} binary bytes are generated using the underlying
 * Random&lt;/li&gt;
 * &lt;li&gt;Each binary byte is translated into 2 hex digits&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;</text>
    <param>len the desired string length.</param>
    <return>the random string.</return>
    <throws>NotStrictlyPositiveException if {@code len &lt;= 0}.</throws>
  </javadoc>
  <method type="String" name="nextHexString" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="nextInt" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="long" name="nextLong" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated in
 * 40-byte segments using a 3-step process.
 * &lt;ol&gt;
 * &lt;li&gt;
 * 20 random bytes are generated using the underlying
 * &lt;code&gt;SecureRandom&lt;/code&gt;.&lt;/li&gt;
 * &lt;li&gt;
 * SHA-1 hash is applied to yield a 20-byte binary digest.&lt;/li&gt;
 * &lt;li&gt;
 * Each byte of the binary digest is converted to 2 hex digits.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="String" name="nextSecureHexString" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="nextSecureInt" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="long" name="nextSecureLong" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;:
 * &lt;ul&gt;&lt;li&gt; For small means, uses simulation of a Poisson process
 * using Uniform deviates, as described
 * &lt;a href="http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm"&gt; here.&lt;/a&gt;
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.&lt;/li&gt;
 * &lt;li&gt; For large means, uses the rejection algorithm described in &lt;br/&gt;
 * Devroye, Luc. (1981).&lt;i&gt;The Computer Generation of Poisson Random Variables&lt;/i&gt;
 * &lt;strong&gt;Computing&lt;/strong&gt; vol. 26 pp. 197-207.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;</text>
  </javadoc>
  <method type="long" name="nextPoisson" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="double" name="nextGaussian" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses the Algorithm SA (Ahrens)
 * from p. 876 in:
 * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for
 * sampling from the exponential and normal distributions.
 * Communications of the ACM, 15, 873-882.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="double" name="nextExponential" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: scales the output of
 * Random.nextDouble(), but rejects 0 values (i.e., will generate another
 * random double if Random.nextDouble() returns 0). This is necessary to
 * provide a symmetric output interval (both endpoints excluded).
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="double" name="nextUniform" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: if the lower bound is excluded,
 * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,
 * will generate another random double if Random.nextDouble() returns 0).
 * This is necessary to provide a symmetric output interval (both
 * endpoints excluded).
 * &lt;/p&gt;</text>
    <since>3.0</since>
  </javadoc>
  <method type="double" name="nextUniform" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.BetaDistribution Beta Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>alpha first distribution shape parameter</param>
    <param>beta second distribution shape parameter</param>
    <return>random value sampled from the beta(alpha, beta) distribution</return>
    <since>2.2</since>
  </javadoc>
  <method type="double" name="nextBeta" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.BinomialDistribution Binomial Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>numberOfTrials number of trials of the Binomial distribution</param>
    <param>probabilityOfSuccess probability of success of the Binomial distribution</param>
    <return>random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution</return>
    <since>2.2</since>
  </javadoc>
  <method type="int" name="nextBinomial" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.CauchyDistribution Cauchy Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>median the median of the Cauchy distribution</param>
    <param>scale the scale parameter of the Cauchy distribution</param>
    <return>random value sampled from the Cauchy(median, scale) distribution</return>
    <since>2.2</since>
  </javadoc>
  <method type="double" name="nextCauchy" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.ChiSquaredDistribution ChiSquare Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>df the degrees of freedom of the ChiSquare distribution</param>
    <return>random value sampled from the ChiSquare(df) distribution</return>
    <since>2.2</since>
  </javadoc>
  <method type="double" name="nextChiSquare" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.FDistribution F Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>numeratorDf the numerator degrees of freedom of the F distribution</param>
    <param>denominatorDf the denominator degrees of freedom of the F distribution</param>
    <return>random value sampled from the F(numeratorDf, denominatorDf) distribution</return>
    <throws>NotStrictlyPositiveException if{@code numeratorDf &lt;= 0} or {@code denominatorDf &lt;= 0}.</throws>
    <since>2.2</since>
  </javadoc>
  <method type="double" name="nextF" />
  <javadoc>
    <text>&lt;p&gt;Generates a random value from the{@link org.apache.commons.math3.distribution.GammaDistribution Gamma Distribution}.&lt;/p&gt;
 * &lt;p&gt;This implementation uses the following algorithms: &lt;/p&gt;
 * &lt;p&gt;For 0 &lt; shape &lt; 1: &lt;br/&gt;
 * Ahrens, J. H. and Dieter, U., &lt;i&gt;Computer methods for
 * sampling from gamma, beta, Poisson and binomial distributions.&lt;/i&gt;
 * Computing, 12, 223-246, 1974.&lt;/p&gt;
 * &lt;p&gt;For shape &gt;= 1: &lt;br/&gt;
 * Marsaglia and Tsang, &lt;i&gt;A Simple Method for Generating
 * Gamma Variables.&lt;/i&gt; ACM Transactions on Mathematical Software,
 * Volume 26 Issue 3, September, 2000.&lt;/p&gt;</text>
    <param>shape the median of the Gamma distribution</param>
    <param>scale the scale parameter of the Gamma distribution</param>
    <return>random value sampled from the Gamma(shape, scale) distribution</return>
    <throws>NotStrictlyPositiveException if {@code shape &lt;= 0} or{@code scale &lt;= 0}.</throws>
    <since>2.2</since>
  </javadoc>
  <method type="double" name="nextGamma" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.HypergeometricDistribution Hypergeometric Distribution}.
 * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}to generate random values.</text>
    <param>populationSize the population size of the Hypergeometric distribution</param>
    <param>numberOfSuccesses number of successes in the population of the Hypergeometric distribution</param>
    <param>sampleSize the sample size of the Hypergeometric distribution</param>
    <return>random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution</return>
    <throws>NumberIsTooLargeException  if {@code numberOfSuccesses &gt; populationSize},
 * or {@code sampleSize &gt; populationSize}.</throws>
    <throws>NotStrictlyPositiveException if {@code populationSize &lt;= 0}.</throws>
    <throws>NotPositiveException  if {@code numberOfSuccesses &lt; 0}.</throws>
    <since>2.2</since>
  </javadoc>
  <method type="int" name="nextHypergeometric" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.PascalDistribution Pascal Distribution}.
 * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}to generate random values.</text>
    <param>r the number of successes of the Pascal distribution</param>
    <param>p the probability of success of the Pascal distribution</param>
    <return>random value sampled from the Pascal(r, p) distribution</return>
    <since>2.2</since>
    <throws>NotStrictlyPositiveException if the number of successes is not positive</throws>
    <throws>OutOfRangeException if the probability of success is not in the
 * range {@code [0, 1]}.</throws>
  </javadoc>
  <method type="int" name="nextPascal" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.TDistribution T Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>df the degrees of freedom of the T distribution</param>
    <return>random value from the T(df) distribution</return>
    <since>2.2</since>
    <throws>NotStrictlyPositiveException if {@code df &lt;= 0}</throws>
  </javadoc>
  <method type="double" name="nextT" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.WeibullDistribution Weibull Distribution}.
 * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}to generate random values.</text>
    <param>shape the shape parameter of the Weibull distribution</param>
    <param>scale the scale parameter of the Weibull distribution</param>
    <return>random value sampled from the Weibull(shape, size) distribution</return>
    <since>2.2</since>
    <throws>NotStrictlyPositiveException if {@code shape &lt;= 0} or{@code scale &lt;= 0}.</throws>
  </javadoc>
  <method type="double" name="nextWeibull" />
  <javadoc>
    <text>Generates a random value from the {@link org.apache.commons.math3.distribution.ZipfDistribution Zipf Distribution}.
 * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}to generate random values.</text>
    <param>numberOfElements the number of elements of the ZipfDistribution</param>
    <param>exponent the exponent of the ZipfDistribution</param>
    <return>random value sampled from the Zipf(numberOfElements, exponent) distribution</return>
    <since>2.2</since>
    <exception>NotStrictlyPositiveException if {@code numberOfElements &lt;= 0}or {@code exponent &lt;= 0}.</exception>
  </javadoc>
  <method type="int" name="nextZipf" />
  <javadoc>
    <text>Reseeds the random number generator with the supplied seed.
 * &lt;p&gt;
 * Will create and initialize if null.
 * &lt;/p&gt;</text>
    <param>seedthe seed value to use</param>
  </javadoc>
  <method type="void" name="reSeed" />
  <javadoc>
    <text>Reseeds the secure random number generator with the current time in
 * milliseconds.
 * &lt;p&gt;
 * Will create and initialize if null.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="reSeedSecure" />
  <javadoc>
    <text>Reseeds the secure random number generator with the supplied seed.
 * &lt;p&gt;
 * Will create and initialize if null.
 * &lt;/p&gt;</text>
    <param>seedthe seed value to use</param>
  </javadoc>
  <method type="void" name="reSeedSecure" />
  <javadoc>
    <text>Reseeds the random number generator with{@code System.currentTimeMillis() + System.identityHashCode(this))}.</text>
  </javadoc>
  <method type="void" name="reSeed" />
  <javadoc>
    <text>Sets the PRNG algorithm for the underlying SecureRandom instance using
 * the Security Provider API. The Security Provider API is defined in &lt;a
 * href =
 * "http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA"&gt;
 * Java Cryptography Architecture API Specification &amp; Reference.&lt;/a&gt;
 * &lt;p&gt;
 * &lt;strong&gt;USAGE NOTE:&lt;/strong&gt; This method carries &lt;i&gt;significant&lt;/i&gt;
 * overhead and may take several seconds to execute.
 * &lt;/p&gt;</text>
    <param>algorithmthe name of the PRNG algorithm</param>
    <param>providerthe name of the provider</param>
    <throws>NoSuchAlgorithmExceptionif the specified algorithm is not available</throws>
    <throws>NoSuchProviderExceptionif the specified provider is not installed</throws>
  </javadoc>
  <method type="void" name="setSecureAlgorithm" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * Uses a 2-cycle permutation shuffle. The shuffling process is described &lt;a
 * href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html"&gt;
 * here&lt;/a&gt;.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="int[]" name="nextPermutation" />
  <javadoc>
    <text>{@inheritDoc}&lt;p&gt;
 * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses a 2-cycle permutation
 * shuffle to generate a random permutation of &lt;code&gt;c.size()&lt;/code&gt; and
 * then returns the elements whose indexes correspond to the elements of the
 * generated permutation. This technique is described, and proven to
 * generate random samples &lt;a
 * href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html"&gt;
 * here&lt;/a&gt;
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="Object[]" name="nextSample" />
  <javadoc>
    <text>Generate a random deviate from the given distribution using the
 * &lt;a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling"&gt; inversion method.&lt;/a&gt;</text>
    <param>distribution Continuous distribution to generate a random value from</param>
    <return>a random value sampled from the given distribution</return>
    <throws>MathIllegalArgumentException if the underlynig distribution throws one</throws>
    <since>2.2</since>
    <deprecated>use the distribution's sample() method</deprecated>
  </javadoc>
  <method type="double" name="nextInversionDeviate" />
  <javadoc>
    <text>Generate a random deviate from the given distribution using the
 * &lt;a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling"&gt; inversion method.&lt;/a&gt;</text>
    <param>distribution Integer distribution to generate a random value from</param>
    <return>a random value sampled from the given distribution</return>
    <throws>MathIllegalArgumentException if the underlynig distribution throws one</throws>
    <since>2.2</since>
    <deprecated>use the distribution's sample() method</deprecated>
  </javadoc>
  <method type="int" name="nextInversionDeviate" />
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
