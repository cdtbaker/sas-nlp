<?xml version="1.0" encoding="UTF-8"?>
<class name="ContinuousOutputModel">
  <javadoc>
    <text>This class stores all information provided by an ODE integrator
 * during the integration process and build a continuous model of the
 * solution from this.
 * &lt;p&gt;This class act as a step handler from the integrator point of
 * view. It is called iteratively during the integration process and
 * stores a copy of all steps information in a sorted collection for
 * later use. Once the integration process is over, the user can use
 * the {@link #setInterpolatedTime setInterpolatedTime} and {@link #getInterpolatedState getInterpolatedState} to retrieve this
 * information at any time. It is important to wait for the
 * integration to be over before attempting to call {@link #setInterpolatedTime setInterpolatedTime} because some internal
 * variables are set only once the last step has been handled.&lt;/p&gt;
 * &lt;p&gt;This is useful for example if the main loop of the user
 * application should remain independent from the integration process
 * or if one needs to mimic the behaviour of an analytical model
 * despite a numerical model is used (i.e. one needs the ability to
 * get the model value at any time or to navigate through the
 * data).&lt;/p&gt;
 * &lt;p&gt;If problem modeling is done with several separate
 * integration phases for contiguous intervals, the same
 * ContinuousOutputModel can be used as step handler for all
 * integration phases as long as they are performed in order and in
 * the same direction. As an example, one can extrapolate the
 * trajectory of a satellite with one model (i.e. one set of
 * differential equations) up to the beginning of a maneuver, use
 * another more complex model including thrusters modeling and
 * accurate attitude control during the maneuver, and revert to the
 * first model after the end of the maneuver. If the same continuous
 * output model handles the steps of all integration phases, the user
 * do not need to bother when the maneuver begins or ends, he has all
 * the data available in a transparent manner.&lt;/p&gt;
 * &lt;p&gt;An important feature of this class is that it implements the
 * &lt;code&gt;Serializable&lt;/code&gt; interface. This means that the result of
 * an integration can be serialized and reused later (if stored into a
 * persistent medium like a filesystem or a database) or elsewhere (if
 * sent to another application). Only the result of the integration is
 * stored, there is no reference to the integrated problem by
 * itself.&lt;/p&gt;
 * &lt;p&gt;One should be aware that the amount of data stored in a
 * ContinuousOutputModel instance can be important if the state vector
 * is large, if the integration interval is long or if the steps are
 * small (which can result from small tolerance settings in {@link org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator adaptive
 * step size integrators}).&lt;/p&gt;</text>
    <see>StepHandler</see>
    <see>StepInterpolator</see>
    <version>$Id: ContinuousOutputModel.java 1463684 2013-04-02 19:04:13Z luc $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Serializable version identifier</text>
  </javadoc>
  <declaration type="long" name="serialVersionUID" />
  <javadoc>
    <text>Initial integration time.</text>
  </javadoc>
  <declaration type="double" name="initialTime" />
  <javadoc>
    <text>Final integration time.</text>
  </javadoc>
  <declaration type="double" name="finalTime" />
  <javadoc>
    <text>Integration direction indicator.</text>
  </javadoc>
  <declaration type="boolean" name="forward" />
  <javadoc>
    <text>Current interpolator index.</text>
  </javadoc>
  <declaration type="int" name="index" />
  <javadoc>
    <text>Steps table.</text>
  </javadoc>
  <declaration type="List&lt;StepInterpolator&gt;" name="steps" />
  <javadoc>
    <text>Simple constructor.
 * Build an empty continuous output model.</text>
  </javadoc>
  <method type="constructor" name="ContinuousOutputModel" />
  <javadoc>
    <text>Append another model at the end of the instance.</text>
    <param>model model to add at the end of the instance</param>
    <exception>MathIllegalArgumentException if the model to append is not
 * compatible with the instance (dimension of the state vector,
 * propagation direction, hole between the dates)</exception>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded
 * during step finalization</exception>
  </javadoc>
  <method type="void" name="append">
    <scope />
    <scope />
    <scope>
      <scope />
      <scope />
      <declaration type="StepInterpolator" name="lastInterpolator" />
      <declaration type="double" name="current" />
      <declaration type="double" name="previous" />
      <declaration type="double" name="step" />
      <declaration type="double" name="gap" />
      <scope />
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="init" />
  <javadoc>
    <text>Handle the last accepted step.
 * A copy of the information provided by the last step is stored in
 * the instance for later use.</text>
    <param>interpolator interpolator for the last accepted step.</param>
    <param>isLast true if the step is the last one</param>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded
 * during step finalization</exception>
  </javadoc>
  <method type="void" name="handleStep">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Get the initial integration time.</text>
    <return>initial integration time</return>
  </javadoc>
  <method type="double" name="getInitialTime" />
  <javadoc>
    <text>Get the final integration time.</text>
    <return>final integration time</return>
  </javadoc>
  <method type="double" name="getFinalTime" />
  <javadoc>
    <text>Get the time of the interpolated point.
 * If {@link #setInterpolatedTime} has not been called, it returns
 * the final integration time.</text>
    <return>interpolation point time</return>
  </javadoc>
  <method type="double" name="getInterpolatedTime" />
  <javadoc>
    <text>Set the time of the interpolated point.
 * &lt;p&gt;This method should &lt;strong&gt;not&lt;/strong&gt; be called before the
 * integration is over because some internal variables are set only
 * once the last step has been handled.&lt;/p&gt;
 * &lt;p&gt;Setting the time outside of the integration interval is now
 * allowed (it was not allowed up to version 5.9 of Mantissa), but
 * should be used with care since the accuracy of the interpolator
 * will probably be very poor far from this interval. This allowance
 * has been added to simplify implementation of search algorithms
 * near the interval endpoints.&lt;/p&gt;</text>
    <param>time time of the interpolated point</param>
  </javadoc>
  <method type="void" name="setInterpolatedTime">
    <declaration type="int" name="iMin" />
    <declaration type="StepInterpolator" name="sMin" />
    <declaration type="double" name="tMin" />
    <declaration type="int" name="iMax" />
    <declaration type="StepInterpolator" name="sMax" />
    <declaration type="double" name="tMax" />
    <scope />
    <scope />
    <scope>
      <declaration type="StepInterpolator" name="si" />
      <declaration type="int" name="location" />
      <scope />
      <scope />
      <scope />
      <declaration type="int" name="iMed" />
      <declaration type="StepInterpolator" name="sMed" />
      <declaration type="double" name="tMed" />
      <scope />
      <scope>
        <declaration type="double" name="d12" />
        <declaration type="double" name="d23" />
        <declaration type="double" name="d13" />
        <declaration type="double" name="dt1" />
        <declaration type="double" name="dt2" />
        <declaration type="double" name="dt3" />
        <declaration type="double" name="iLagrange" />
      </scope>
      <declaration type="int" name="low" />
      <declaration type="int" name="high" />
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>initialize the search with the complete steps table</comment>
    <comment>handle points outside of the integration interval</comment>
    <comment>or in the first and last step</comment>
    <comment>reduction of the table slice size</comment>
    <comment>use the last estimated index as the splitting index</comment>
    <comment>we have found the target step, no need to continue searching</comment>
    <comment>compute a new estimate of the index in the reduced table slice</comment>
    <comment>too close to the bounds, we estimate using a simple dichotomy</comment>
    <comment>estimate the index using a reverse quadratic polynom</comment>
    <comment>(reverse means we have i = P(t), thus allowing to simply</comment>
    <comment>compute index = P(time) rather than solving a quadratic equation)</comment>
    <comment>force the next size reduction to be at least one tenth</comment>
    <comment>now the table slice is very small, we perform an iterative search</comment>
  </method>
  <javadoc>
    <text>Get the state vector of the interpolated point.</text>
    <return>state vector at time {@link #getInterpolatedTime}</return>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    <see>#getInterpolatedSecondaryState(int)</see>
  </javadoc>
  <method type="double[]" name="getInterpolatedState" />
  <javadoc>
    <text>Get the interpolated secondary state corresponding to the secondary equations.</text>
    <param>secondaryStateIndex index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}</param>
    <return>interpolated secondary state at the current interpolation date</return>
    <see>#getInterpolatedState()</see>
    <since>3.2</since>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
  </javadoc>
  <method type="double[]" name="getInterpolatedSecondaryState" />
  <javadoc>
    <text>Compare a step interval and a double.</text>
    <param>time point to locate</param>
    <param>interval step interval</param>
    <return>-1 if the double is before the interval, 0 if it is in
 * the interval, and +1 if it is after the interval, according to
 * the interval direction</return>
  </javadoc>
  <method type="int" name="locatePoint">
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <scope />
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
