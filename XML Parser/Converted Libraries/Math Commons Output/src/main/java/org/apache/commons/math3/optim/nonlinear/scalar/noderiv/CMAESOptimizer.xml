<?xml version="1.0" encoding="UTF-8"?>
<class name="CMAESOptimizer">
  <javadoc>
    <text>&lt;p&gt;An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES)
 * for non-linear, non-convex, non-smooth, global function minimization.
 * The CMA-Evolution Strategy (CMA-ES) is a reliable stochastic optimization method
 * which should be applied if derivative-based methods, e.g. quasi-Newton BFGS or
 * conjugate gradient, fail due to a rugged search landscape (e.g. noise, local
 * optima, outlier, etc.) of the objective function. Like a
 * quasi-Newton method, the CMA-ES learns and applies a variable metric
 * on the underlying search space. Unlike a quasi-Newton method, the
 * CMA-ES neither estimates nor uses gradients, making it considerably more
 * reliable in terms of finding a good, or even close to optimal, solution.&lt;/p&gt;
 * &lt;p&gt;In general, on smooth objective functions the CMA-ES is roughly ten times
 * slower than BFGS (counting objective function evaluations, no gradients provided).
 * For up to &lt;math&gt;N=10&lt;/math&gt; variables also the derivative-free simplex
 * direct search method (Nelder and Mead) can be faster, but it is
 * far less reliable than CMA-ES.&lt;/p&gt;
 * &lt;p&gt;The CMA-ES is particularly well suited for non-separable
 * and/or badly conditioned problems. To observe the advantage of CMA compared
 * to a conventional evolution strategy, it will usually take about
 * &lt;math&gt;30 N&lt;/math&gt; function evaluations. On difficult problems the complete
 * optimization (a single run) is expected to take &lt;em&gt;roughly&lt;/em&gt; between
 * &lt;math&gt;30 N&lt;/math&gt; and &lt;math&gt;300 N&lt;sup&gt;2&lt;/sup&gt;&lt;/math&gt;
 * function evaluations.&lt;/p&gt;
 * &lt;p&gt;This implementation is translated and adapted from the Matlab version
 * of the CMA-ES algorithm as implemented in module {@code cmaes.m} version 3.51.&lt;/p&gt;
 * For more information, please refer to the following links:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href="http://www.lri.fr/~hansen/cmaes.m"&gt;Matlab code&lt;/a&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;a href="http://www.lri.fr/~hansen/cmaesintro.html"&gt;Introduction to CMA-ES&lt;/a&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/CMA-ES"&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
 * &lt;/ul&gt;</text>
    <version>$Id: CMAESOptimizer.java 1462503 2013-03-29 15:48:27Z luc $</version>
    <since>3.0</since>
  </javadoc>
  <javadoc>
    <text>Population size, offspring number. The primary strategy parameter to play
 * with, which can be increased from its default value. Increasing the
 * population size improves global search properties in exchange to speed.
 * Speed decreases, as a rule, at most linearly with increasing population
 * size. It is advisable to begin with the default small population size.</text>
  </javadoc>
  <declaration type="int" name="lambda" />
  <javadoc>
    <text>Covariance update mechanism, default is active CMA. isActiveCMA = true
 * turns on "active CMA" with a negative update of the covariance matrix and
 * checks for positive definiteness. OPTS.CMA.active = 2 does not check for
 * pos. def. and is numerically faster. Active CMA usually speeds up the
 * adaptation.</text>
  </javadoc>
  <declaration type="boolean" name="isActiveCMA" />
  <javadoc>
    <text>Determines how often a new random offspring is generated in case it is
 * not feasible / beyond the defined limits, default is 0.</text>
  </javadoc>
  <declaration type="int" name="checkFeasableCount" />
  <javadoc>
    <see>Sigma</see>
  </javadoc>
  <declaration type="double[]" name="inputSigma" />
  <javadoc>
    <text>Number of objective variables/problem dimension</text>
  </javadoc>
  <declaration type="int" name="dimension" />
  <javadoc>
    <text>Defines the number of initial iterations, where the covariance matrix
 * remains diagonal and the algorithm has internally linear time complexity.
 * diagonalOnly = 1 means keeping the covariance matrix always diagonal and
 * this setting also exhibits linear space complexity. This can be
 * particularly useful for dimension &gt; 100.</text>
    <see>&lt;a href="http://hal.archives-ouvertes.fr/inria-00287367/en"&gt;A Simple Modification in CMA-ES&lt;/a&gt;</see>
  </javadoc>
  <declaration type="int" name="diagonalOnly" />
  <javadoc>
    <text>Number of objective variables/problem dimension</text>
  </javadoc>
  <declaration type="boolean" name="isMinimize" />
  <javadoc>
    <text>Indicates whether statistic data is collected.</text>
  </javadoc>
  <declaration type="boolean" name="generateStatistics" />
  <javadoc>
    <text>Maximal number of iterations allowed.</text>
  </javadoc>
  <declaration type="int" name="maxIterations" />
  <javadoc>
    <text>Limit for fitness value.</text>
  </javadoc>
  <declaration type="double" name="stopFitness" />
  <javadoc>
    <text>Stop if x-changes larger stopTolUpX.</text>
  </javadoc>
  <declaration type="double" name="stopTolUpX" />
  <javadoc>
    <text>Stop if x-change smaller stopTolX.</text>
  </javadoc>
  <declaration type="double" name="stopTolX" />
  <javadoc>
    <text>Stop if fun-changes smaller stopTolFun.</text>
  </javadoc>
  <declaration type="double" name="stopTolFun" />
  <javadoc>
    <text>Stop if back fun-changes smaller stopTolHistFun.</text>
  </javadoc>
  <declaration type="double" name="stopTolHistFun" />
  <javadoc>
    <text>Number of parents/points for recombination.</text>
  </javadoc>
  <declaration type="int" name="mu" />
  <javadoc>
    <text>log(mu + 0.5), stored for efficiency.</text>
  </javadoc>
  <declaration type="double" name="logMu2" />
  <javadoc>
    <text>Array for weighted recombination.</text>
  </javadoc>
  <declaration type="RealMatrix" name="weights" />
  <javadoc>
    <text>Variance-effectiveness of sum w_i x_i.</text>
  </javadoc>
  <declaration type="double" name="mueff" />
  <javadoc>
    <text>Overall standard deviation - search volume.</text>
  </javadoc>
  <declaration type="double" name="sigma" />
  <javadoc>
    <text>Cumulation constant.</text>
  </javadoc>
  <declaration type="double" name="cc" />
  <javadoc>
    <text>Cumulation constant for step-size.</text>
  </javadoc>
  <declaration type="double" name="cs" />
  <javadoc>
    <text>Damping for step-size.</text>
  </javadoc>
  <declaration type="double" name="damps" />
  <javadoc>
    <text>Learning rate for rank-one update.</text>
  </javadoc>
  <declaration type="double" name="ccov1" />
  <javadoc>
    <text>Learning rate for rank-mu update'</text>
  </javadoc>
  <declaration type="double" name="ccovmu" />
  <javadoc>
    <text>Expectation of ||N(0,I)|| == norm(randn(N,1)).</text>
  </javadoc>
  <declaration type="double" name="chiN" />
  <javadoc>
    <text>Learning rate for rank-one update - diagonalOnly</text>
  </javadoc>
  <declaration type="double" name="ccov1Sep" />
  <javadoc>
    <text>Learning rate for rank-mu update - diagonalOnly</text>
  </javadoc>
  <declaration type="double" name="ccovmuSep" />
  <javadoc>
    <text>Objective variables.</text>
  </javadoc>
  <declaration type="RealMatrix" name="xmean" />
  <javadoc>
    <text>Evolution path.</text>
  </javadoc>
  <declaration type="RealMatrix" name="pc" />
  <javadoc>
    <text>Evolution path for sigma.</text>
  </javadoc>
  <declaration type="RealMatrix" name="ps" />
  <javadoc>
    <text>Norm of ps, stored for efficiency.</text>
  </javadoc>
  <declaration type="double" name="normps" />
  <javadoc>
    <text>Coordinate system.</text>
  </javadoc>
  <declaration type="RealMatrix" name="B" />
  <javadoc>
    <text>Scaling.</text>
  </javadoc>
  <declaration type="RealMatrix" name="D" />
  <javadoc>
    <text>B*D, stored for efficiency.</text>
  </javadoc>
  <declaration type="RealMatrix" name="BD" />
  <javadoc>
    <text>Diagonal of sqrt(D), stored for efficiency.</text>
  </javadoc>
  <declaration type="RealMatrix" name="diagD" />
  <javadoc>
    <text>Covariance matrix.</text>
  </javadoc>
  <declaration type="RealMatrix" name="C" />
  <javadoc>
    <text>Diagonal of C, used for diagonalOnly.</text>
  </javadoc>
  <declaration type="RealMatrix" name="diagC" />
  <javadoc>
    <text>Number of iterations already performed.</text>
  </javadoc>
  <declaration type="int" name="iterations" />
  <javadoc>
    <text>History queue of best values.</text>
  </javadoc>
  <declaration type="double[]" name="fitnessHistory" />
  <javadoc>
    <text>Size of history queue of best values.</text>
  </javadoc>
  <declaration type="int" name="historySize" />
  <javadoc>
    <text>Random generator.</text>
  </javadoc>
  <declaration type="RandomGenerator" name="random" />
  <javadoc>
    <text>History of sigma values.</text>
  </javadoc>
  <declaration type="List&lt;Double&gt;" name="statisticsSigmaHistory" />
  <javadoc>
    <text>History of mean matrix.</text>
  </javadoc>
  <declaration type="List&lt;RealMatrix&gt;" name="statisticsMeanHistory" />
  <javadoc>
    <text>History of fitness values.</text>
  </javadoc>
  <declaration type="List&lt;Double&gt;" name="statisticsFitnessHistory" />
  <javadoc>
    <text>History of D matrix.</text>
  </javadoc>
  <declaration type="List&lt;RealMatrix&gt;" name="statisticsDHistory" />
  <javadoc>
    <param>maxIterations Maximal number of iterations.</param>
    <param>stopFitness Whether to stop if objective function value is smaller than{@code stopFitness}.</param>
    <param>isActiveCMA Chooses the covariance matrix update method.</param>
    <param>diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.</param>
    <param>checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.</param>
    <param>random Random generator.</param>
    <param>generateStatistics Whether statistic data is collected.</param>
    <param>checker Convergence checker.</param>
    <since>3.1</since>
  </javadoc>
  <method type="constructor" name="CMAESOptimizer" />
  <javadoc>
    <return>History of sigma values.</return>
  </javadoc>
  <method type="List&lt;Double&gt;" name="getStatisticsSigmaHistory" />
  <javadoc>
    <return>History of mean matrix.</return>
  </javadoc>
  <method type="List&lt;RealMatrix&gt;" name="getStatisticsMeanHistory" />
  <javadoc>
    <return>History of fitness values.</return>
  </javadoc>
  <method type="List&lt;Double&gt;" name="getStatisticsFitnessHistory" />
  <javadoc>
    <return>History of D matrix.</return>
  </javadoc>
  <method type="List&lt;RealMatrix&gt;" name="getStatisticsDHistory" />
  <javadoc>
    <text>Input sigma values.
 * They define the initial coordinate-wise standard deviations for
 * sampling new search points around the initial guess.
 * It is suggested to set them to the estimated distance from the
 * initial to the desired optimum.
 * Small values induce the search to be more local (and very small
 * values are more likely to find a local optimum close to the initial
 * guess).
 * Too small values might however lead to early termination.</text>
  </javadoc>
  <javadoc>
    <text>Sigma values.</text>
  </javadoc>
  <declaration type="double[]" name="sigma" />
  <javadoc>
    <param>s Sigma values.</param>
    <throws>NotPositiveException if any of the array entries is smaller
 * than zero.</throws>
  </javadoc>
  <method type="constructor" name="Sigma">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <return>the sigma values.</return>
  </javadoc>
  <method type="double[]" name="getSigma" />
  <javadoc>
    <text>Population size.
 * The number of offspring is the primary strategy parameter.
 * In the absence of better clues, a good default could be an
 * integer close to {@code 4 + 3 ln(n)}, where {@code n} is the
 * number of optimized parameters.
 * Increasing the population size improves global search properties
 * at the expense of speed (which in general decreases at most
 * linearly with increasing population size).</text>
  </javadoc>
  <javadoc>
    <text>Population size.</text>
  </javadoc>
  <declaration type="int" name="lambda" />
  <javadoc>
    <param>size Population size.</param>
    <throws>NotStrictlyPositiveException if {@code size &lt;= 0}.</throws>
  </javadoc>
  <method type="constructor" name="PopulationSize">
    <scope />
  </method>
  <javadoc>
    <return>the population size.</return>
  </javadoc>
  <method type="int" name="getPopulationSize" />
  <javadoc>
    <text>{@inheritDoc}</text>
    <param>optData Optimization data. In addition to those documented in{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])MultivariateOptimizer}, this method will register the following data:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Sigma}&lt;/li&gt;
 * &lt;li&gt;{@link PopulationSize}&lt;/li&gt;
 * &lt;/ul&gt;</param>
    <return>{@inheritDoc}</return>
    <throws>TooManyEvaluationsException if the maximal number of
 * evaluations is exceeded.</throws>
    <throws>DimensionMismatchException if the initial guess, target, and weight
 * arguments have inconsistent dimensions.</throws>
  </javadoc>
  <method type="PointValuePair" name="optimize">
    <comment>Set up base class and perform computation.</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="PointValuePair" name="doOptimize">
    <declaration type="FitnessFunction" name="fitfun" />
    <declaration type="double[]" name="guess" />
    <declaration type="double" name="bestValue" />
    <declaration type="PointValuePair" name="optimum" />
    <declaration type="PointValuePair" name="lastResult" />
    <scope>
      <declaration type="RealMatrix" name="arz" />
      <declaration type="RealMatrix" name="arx" />
      <declaration type="double[]" name="fitness" />
      <scope>
        <declaration type="RealMatrix" name="arxk" />
        <scope>
          <scope />
          <scope />
          <scope />
        </scope>
        <scope />
        <scope />
      </scope>
      <declaration type="int[]" name="arindex" />
      <declaration type="RealMatrix" name="xold" />
      <declaration type="RealMatrix" name="bestArx" />
      <declaration type="RealMatrix" name="bestArz" />
      <declaration type="RealMatrix" name="zmean" />
      <declaration type="boolean" name="hsig" />
      <scope />
      <scope />
      <declaration type="double" name="bestFitness" />
      <declaration type="double" name="worstFitness" />
      <scope>
        <scope />
      </scope>
      <scope />
      <declaration type="double[]" name="sqrtDiagC" />
      <declaration type="double[]" name="pcCol" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
      <declaration type="double" name="historyBest" />
      <declaration type="double" name="historyWorst" />
      <scope />
      <scope />
      <scope />
      <scope>
        <declaration type="PointValuePair" name="current" />
        <scope />
      </scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>-------------------- Initialization --------------------------------</comment>
    <comment>number of objective variables/problem dimension</comment>
    <comment>-------------------- Generation Loop --------------------------------</comment>
    <comment>Generate and evaluate lambda offspring</comment>
    <comment>generate random offspring</comment>
    <comment>m + sig * Normal(0,C)</comment>
    <comment>regenerate random arguments for row</comment>
    <comment>compute fitness</comment>
    <comment>Sort by fitness and compute weighted mean into xmean</comment>
    <comment>Calculate new xmean, this is selection and recombination</comment>
    <comment>for speed up of Eq. (2) and (3)</comment>
    <comment>Adapt step size sigma - Eq. (5)</comment>
    <comment>handle termination criteria</comment>
    <comment>Break, if fitness is good enough</comment>
    <comment>condition number of the covariance matrix exceeds 1e14</comment>
    <comment>user defined termination</comment>
    <comment>Adjust step size in case of equal function values (flat fitness)</comment>
    <comment>store best in history</comment>
  </method>
  <javadoc>
    <text>Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
    <param>optData Optimization data. The following data will be looked for:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Sigma}&lt;/li&gt;
 * &lt;li&gt;{@link PopulationSize}&lt;/li&gt;
 * &lt;/ul&gt;</param>
  </javadoc>
  <method type="void" name="parseOptimizationData">
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>Allow base class to register its own data.</comment>
    <comment>The existing values (as set by the previous call) are reused if</comment>
    <comment>not provided in the argument list.</comment>
  </method>
  <javadoc>
    <text>Checks dimensions and values of boundaries and inputSigma if defined.</text>
  </javadoc>
  <method type="void" name="checkParameters">
    <declaration type="double[]" name="init" />
    <declaration type="double[]" name="lB" />
    <declaration type="double[]" name="uB" />
    <scope>
      <scope />
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Initialization of the dynamic search parameters</text>
    <param>guess Initial guess for the arguments of the fitness function.</param>
  </javadoc>
  <method type="void" name="initializeCMA">
    <scope />
    <declaration type="double[][]" name="sigmaArray" />
    <scope />
    <declaration type="RealMatrix" name="insigma" />
    <declaration type="double" name="sumw" />
    <declaration type="double" name="sumwq" />
    <scope>
      <declaration type="double" name="w" />
    </scope>
    <scope />
    <comment>initialize sigma</comment>
    <comment>overall standard deviation</comment>
    <comment>initialize termination criteria</comment>
    <comment>initialize selection strategy parameters</comment>
    <comment>number of parents/points for recombination</comment>
    <comment>variance-effectiveness of sum w_i x_i</comment>
    <comment>initialize dynamic strategy parameters and constants</comment>
    <comment>minor increment</comment>
    <comment>intialize CMA internal values - updated each generation</comment>
    <comment>objective variables</comment>
    <comment>evolution paths for C and sigma</comment>
    <comment>B defines the coordinate system</comment>
    <comment>diagonal D defines the scaling</comment>
    <comment>covariance</comment>
    <comment>history of fitness values</comment>
  </method>
  <javadoc>
    <text>Update of the evolution paths ps and pc.</text>
    <param>zmean Weighted row matrix of the gaussian random numbers generating
 * the current offspring.</param>
    <param>xold xmean matrix of the previous generation.</param>
    <return>hsig flag indicating a small correction.</return>
  </javadoc>
  <method type="boolean" name="updateEvolutionPaths">
    <declaration type="boolean" name="hsig" />
    <scope />
  </method>
  <javadoc>
    <text>Update of the covariance matrix C for diagonalOnly &gt; 0</text>
    <param>hsig Flag indicating a small correction.</param>
    <param>bestArz Fitness-sorted matrix of the gaussian random values of the
 * current offspring.</param>
  </javadoc>
  <method type="void" name="updateCovarianceDiagonalOnly">
    <declaration type="double" name="oldFac" />
    <scope />
    <comment>minor correction if hsig==false</comment>
    <comment>regard old matrix</comment>
    <comment>plus rank one update</comment>
    <comment>plus rank mu update</comment>
    <comment>replaces eig(C)</comment>
    <comment>full covariance matrix from now on</comment>
  </method>
  <javadoc>
    <text>Update of the covariance matrix C.</text>
    <param>hsig Flag indicating a small correction.</param>
    <param>bestArx Fitness-sorted matrix of the argument vectors producing the
 * current offspring.</param>
    <param>arz Unsorted matrix containing the gaussian random values of the
 * current offspring.</param>
    <param>arindex Indices indicating the fitness-order of the current offspring.</param>
    <param>xold xmean matrix of the previous generation.</param>
  </javadoc>
  <method type="void" name="updateCovariance">
    <declaration type="double" name="negccov" />
    <scope>
      <declaration type="RealMatrix" name="arpos" />
      <declaration type="RealMatrix" name="roneu" />
      <declaration type="double" name="oldFac" />
      <scope>
        <declaration type="double" name="negminresidualvariance" />
        <declaration type="double" name="negalphaold" />
        <declaration type="int[]" name="arReverseIndex" />
        <declaration type="RealMatrix" name="arzneg" />
        <declaration type="RealMatrix" name="arnorms" />
        <declaration type="int[]" name="idxnorms" />
        <declaration type="RealMatrix" name="arnormsSorted" />
        <declaration type="int[]" name="idxReverse" />
        <declaration type="RealMatrix" name="arnormsReverse" />
        <declaration type="int[]" name="idxInv" />
        <declaration type="RealMatrix" name="arnormsInv" />
        <declaration type="double" name="negcovMax" />
        <scope />
        <declaration type="RealMatrix" name="artmp" />
        <declaration type="RealMatrix" name="Cneg" />
      </scope>
      <scope />
    </scope>
    <comment>mu difference vectors</comment>
    <comment>rank one update</comment>
    <comment>minor correction if hsig==false</comment>
    <comment>Adapt covariance matrix C active CMA</comment>
    <comment>keep at least 0.66 in all directions, small popsize are most</comment>
    <comment>critical</comment>
    <comment>where to make up for the variance loss</comment>
    <comment>prepare vectors, compute negative updating matrix Cneg</comment>
    <comment>check and set learning rate negccov</comment>
    <comment>regard old matrix</comment>
    <comment>plus rank one update</comment>
    <comment>plus rank mu update</comment>
    <comment>Adapt covariance matrix C - nonactive</comment>
    <comment>regard old matrix</comment>
    <comment>plus rank one update</comment>
    <comment>plus rank mu update</comment>
  </method>
  <javadoc>
    <text>Update B and D from C.</text>
    <param>negccov Negative covariance factor.</param>
  </javadoc>
  <method type="void" name="updateBD">
    <scope>
      <declaration type="EigenDecomposition" name="eig" />
      <scope>
        <scope>
          <scope />
        </scope>
        <declaration type="double" name="tfac" />
      </scope>
      <scope>
        <declaration type="double" name="tfac" />
      </scope>
    </scope>
    <comment>to achieve O(N^2)</comment>
    <comment>enforce symmetry to prevent complex numbers</comment>
    <comment>eigen decomposition, B==normalized eigenvectors</comment>
    <comment>D contains standard deviations now</comment>
    <comment>O(n^2)</comment>
  </method>
  <javadoc>
    <text>Pushes the current best fitness value in a history queue.</text>
    <param>vals History queue.</param>
    <param>val Current best fitness value.</param>
  </javadoc>
  <method type="void" name="push">
    <scope />
  </method>
  <javadoc>
    <text>Sorts fitness values.</text>
    <param>doubles Array of values to be sorted.</param>
    <return>a sorted array of indices pointing into doubles.</return>
  </javadoc>
  <method type="int[]" name="sortedIndices">
    <declaration type="DoubleIndex[]" name="dis" />
    <scope />
    <declaration type="int[]" name="indices" />
    <scope />
  </method>
  <javadoc>
    <text>Used to sort fitness values. Sorting is always in lower value first
 * order.</text>
  </javadoc>
  <javadoc>
    <text>Value to compare.</text>
  </javadoc>
  <declaration type="double" name="value" />
  <javadoc>
    <text>Index into sorted array.</text>
  </javadoc>
  <declaration type="int" name="index" />
  <javadoc>
    <param>value Value to compare.</param>
    <param>index Index into sorted array.</param>
  </javadoc>
  <method type="constructor" name="DoubleIndex" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="compareTo" />
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="boolean" name="equals">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="int" name="hashCode">
    <declaration type="long" name="bits" />
  </method>
  <javadoc>
    <text>Normalizes fitness values to the range [0,1]. Adds a penalty to the
 * fitness value if out of range. The penalty is adjusted by calling
 * setValueRange().</text>
  </javadoc>
  <javadoc>
    <text>Determines the penalty for boundary violations</text>
  </javadoc>
  <declaration type="double" name="valueRange" />
  <javadoc>
    <text>Flag indicating whether the objective variables are forced into their
 * bounds if defined</text>
  </javadoc>
  <declaration type="boolean" name="isRepairMode" />
  <javadoc>
    <text>Simple constructor.</text>
  </javadoc>
  <method type="constructor" name="FitnessFunction" />
  <javadoc>
    <param>point Normalized objective variables.</param>
    <return>the objective value + penalty for violated bounds.</return>
  </javadoc>
  <method type="double" name="value">
    <declaration type="double" name="value" />
    <scope>
      <declaration type="double[]" name="repaired" />
    </scope>
    <scope />
  </method>
  <javadoc>
    <param>x Normalized objective variables.</param>
    <return>{@code true} if in bounds.</return>
  </javadoc>
  <method type="boolean" name="isFeasible">
    <declaration type="double[]" name="lB" />
    <declaration type="double[]" name="uB" />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>valueRange Adjusts the penalty computation.</param>
  </javadoc>
  <method type="void" name="setValueRange" />
  <javadoc>
    <param>x Normalized objective variables.</param>
    <return>the repaired (i.e. all in bounds) objective variables.</return>
  </javadoc>
  <method type="double[]" name="repair">
    <declaration type="double[]" name="lB" />
    <declaration type="double[]" name="uB" />
    <declaration type="double[]" name="repaired" />
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>x Normalized objective variables.</param>
    <param>repaired Repaired objective variables.</param>
    <return>Penalty value according to the violation of the bounds.</return>
  </javadoc>
  <method type="double" name="penalty">
    <declaration type="double" name="penalty" />
    <scope>
      <declaration type="double" name="diff" />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix</param>
    <return>Matrix representing the element-wise logarithm of m.</return>
  </javadoc>
  <method type="RealMatrix" name="log">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <return>Matrix representing the element-wise square root of m.</return>
  </javadoc>
  <method type="RealMatrix" name="sqrt">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <return>Matrix representing the element-wise square of m.</return>
  </javadoc>
  <method type="RealMatrix" name="square">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope>
        <declaration type="double" name="e" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix 1.</param>
    <param>n Input matrix 2.</param>
    <return>the matrix where the elements of m and n are element-wise multiplied.</return>
  </javadoc>
  <method type="RealMatrix" name="times">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix 1.</param>
    <param>n Input matrix 2.</param>
    <return>Matrix where the elements of m and n are element-wise divided.</return>
  </javadoc>
  <method type="RealMatrix" name="divide">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <param>cols Columns to select.</param>
    <return>Matrix representing the selected columns.</return>
  </javadoc>
  <method type="RealMatrix" name="selectColumns">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <param>k Diagonal position.</param>
    <return>Upper triangular part of matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="triu">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <return>Row matrix representing the sums of the rows.</return>
  </javadoc>
  <method type="RealMatrix" name="sumRows">
    <declaration type="double[][]" name="d" />
    <scope>
      <declaration type="double" name="sum" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <return>the diagonal n-by-n matrix if m is a column matrix or the column
 * matrix representing the diagonal if m is a n-by-n matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="diag">
    <scope>
      <declaration type="double[][]" name="d" />
      <scope />
    </scope>
    <scope>
      <declaration type="double[][]" name="d" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Copies a column from m1 to m2.</text>
    <param>m1 Source matrix.</param>
    <param>col1 Source column.</param>
    <param>m2 Target matrix.</param>
    <param>col2 Target column.</param>
  </javadoc>
  <method type="void" name="copyColumn">
    <scope />
  </method>
  <javadoc>
    <param>n Number of rows.</param>
    <param>m Number of columns.</param>
    <return>n-by-m matrix filled with 1.</return>
  </javadoc>
  <method type="RealMatrix" name="ones">
    <declaration type="double[][]" name="d" />
    <scope />
  </method>
  <javadoc>
    <param>n Number of rows.</param>
    <param>m Number of columns.</param>
    <return>n-by-m matrix of 0 values out of diagonal, and 1 values on
 * the diagonal.</return>
  </javadoc>
  <method type="RealMatrix" name="eye">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>n Number of rows.</param>
    <param>m Number of columns.</param>
    <return>n-by-m matrix of zero values.</return>
  </javadoc>
  <method type="RealMatrix" name="zeros" />
  <javadoc>
    <param>mat Input matrix.</param>
    <param>n Number of row replicates.</param>
    <param>m Number of column replicates.</param>
    <return>a matrix which replicates the input matrix in both directions.</return>
  </javadoc>
  <method type="RealMatrix" name="repmat">
    <declaration type="int" name="rd" />
    <declaration type="int" name="cd" />
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>start Start value.</param>
    <param>end End value.</param>
    <param>step Step size.</param>
    <return>a sequence as column matrix.</return>
  </javadoc>
  <method type="RealMatrix" name="sequence">
    <declaration type="int" name="size" />
    <declaration type="double[][]" name="d" />
    <declaration type="double" name="value" />
    <scope />
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <return>the maximum of the matrix element values.</return>
  </javadoc>
  <method type="double" name="max">
    <declaration type="double" name="max" />
    <scope>
      <scope>
        <declaration type="double" name="e" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <param>m Input matrix.</param>
    <return>the minimum of the matrix element values.</return>
  </javadoc>
  <method type="double" name="min">
    <declaration type="double" name="min" />
    <scope>
      <scope>
        <declaration type="double" name="e" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <param>m Input array.</param>
    <return>the maximum of the array values.</return>
  </javadoc>
  <method type="double" name="max">
    <declaration type="double" name="max" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>m Input array.</param>
    <return>the minimum of the array values.</return>
  </javadoc>
  <method type="double" name="min">
    <declaration type="double" name="min" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <param>indices Input index array.</param>
    <return>the inverse of the mapping defined by indices.</return>
  </javadoc>
  <method type="int[]" name="inverse">
    <declaration type="int[]" name="inverse" />
    <scope />
  </method>
  <javadoc>
    <param>indices Input index array.</param>
    <return>the indices in inverse order (last is first).</return>
  </javadoc>
  <method type="int[]" name="reverse">
    <declaration type="int[]" name="reverse" />
    <scope />
  </method>
  <javadoc>
    <param>size Length of random array.</param>
    <return>an array of Gaussian random numbers.</return>
  </javadoc>
  <method type="double[]" name="randn">
    <declaration type="double[]" name="randn" />
    <scope />
  </method>
  <javadoc>
    <param>size Number of rows.</param>
    <param>popSize Population size.</param>
    <return>a 2-dimensional matrix of Gaussian random numbers.</return>
  </javadoc>
  <method type="RealMatrix" name="randn1">
    <declaration type="double[][]" name="d" />
    <scope>
      <scope />
    </scope>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>global search parameters</comment>
  <comment>population size</comment>
  <comment>termination criteria</comment>
  <comment>selection strategy parameters</comment>
  <comment />
  <comment />
  <comment>dynamic strategy parameters and constants</comment>
  <comment>CMA internal values - updated each generation</comment>
  <comment>-----Matrix utility functions similar to the Matlab build in functions------</comment>
</class>
