<?xml version="1.0" encoding="UTF-8"?>
<class name="GraggBulirschStoerIntegrator">
  <javadoc>
    <text>This class implements a Gragg-Bulirsch-Stoer integrator for
 * Ordinary Differential Equations.
 * &lt;p&gt;The Gragg-Bulirsch-Stoer algorithm is one of the most efficient
 * ones currently available for smooth problems. It uses Richardson
 * extrapolation to estimate what would be the solution if the step
 * size could be decreased down to zero.&lt;/p&gt;
 * &lt;p&gt;
 * This method changes both the step size and the order during
 * integration, in order to minimize computation cost. It is
 * particularly well suited when a very high precision is needed. The
 * limit where this method becomes more efficient than high-order
 * embedded Runge-Kutta methods like {@link DormandPrince853IntegratorDormand-Prince 8(5,3)} depends on the problem. Results given in the
 * Hairer, Norsett and Wanner book show for example that this limit
 * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz
 * equations (the authors note this problem is &lt;i&gt;extremely sensitive
 * to the errors in the first integration steps&lt;/i&gt;), and around 1e-11
 * for a two dimensional celestial mechanics problems with seven
 * bodies (pleiades problem, involving quasi-collisions for which
 * &lt;i&gt;automatic step size control is essential&lt;/i&gt;).
 * &lt;/p&gt;
 * &lt;p&gt;
 * This implementation is basically a reimplementation in Java of the
 * &lt;a
 * href="http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f"&gt;odex&lt;/a&gt;
 * fortran code by E. Hairer and G. Wanner. The redistribution policy
 * for this code is available &lt;a
 * href="http://www.unige.ch/~hairer/prog/licence.txt"&gt;here&lt;/a&gt;, for
 * convenience, it is reproduced below.&lt;/p&gt;
 * &lt;/p&gt;
 * &lt;table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"&gt;
 * &lt;tr&gt;&lt;td&gt;Copyright (c) 2004, Ernst Hairer&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * &lt;ul&gt;
 * &lt;li&gt;Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.&lt;/li&gt;
 * &lt;li&gt;Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.&lt;/li&gt;
 * &lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;strong&gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;</text>
    <version>$Id: GraggBulirschStoerIntegrator.java 1416643 2012-12-03 19:37:14Z tn $</version>
    <since>1.2</since>
  </javadoc>
  <javadoc>
    <text>Integrator method name.</text>
  </javadoc>
  <declaration type="String" name="METHOD_NAME" />
  <javadoc>
    <text>maximal order.</text>
  </javadoc>
  <declaration type="int" name="maxOrder" />
  <javadoc>
    <text>step size sequence.</text>
  </javadoc>
  <declaration type="int[]" name="sequence" />
  <javadoc>
    <text>overall cost of applying step reduction up to iteration k+1, in number of calls.</text>
  </javadoc>
  <declaration type="int[]" name="costPerStep" />
  <javadoc>
    <text>cost per unit step.</text>
  </javadoc>
  <declaration type="double[]" name="costPerTimeUnit" />
  <javadoc>
    <text>optimal steps for each order.</text>
  </javadoc>
  <declaration type="double[]" name="optimalStep" />
  <javadoc>
    <text>extrapolation coefficients.</text>
  </javadoc>
  <declaration type="double[][]" name="coeff" />
  <javadoc>
    <text>stability check enabling parameter.</text>
  </javadoc>
  <declaration type="boolean" name="performTest" />
  <javadoc>
    <text>maximal number of checks for each iteration.</text>
  </javadoc>
  <declaration type="int" name="maxChecks" />
  <javadoc>
    <text>maximal number of iterations for which checks are performed.</text>
  </javadoc>
  <declaration type="int" name="maxIter" />
  <javadoc>
    <text>stepsize reduction factor in case of stability check failure.</text>
  </javadoc>
  <declaration type="double" name="stabilityReduction" />
  <javadoc>
    <text>first stepsize control factor.</text>
  </javadoc>
  <declaration type="double" name="stepControl1" />
  <javadoc>
    <text>second stepsize control factor.</text>
  </javadoc>
  <declaration type="double" name="stepControl2" />
  <javadoc>
    <text>third stepsize control factor.</text>
  </javadoc>
  <declaration type="double" name="stepControl3" />
  <javadoc>
    <text>fourth stepsize control factor.</text>
  </javadoc>
  <declaration type="double" name="stepControl4" />
  <javadoc>
    <text>first order control factor.</text>
  </javadoc>
  <declaration type="double" name="orderControl1" />
  <javadoc>
    <text>second order control factor.</text>
  </javadoc>
  <declaration type="double" name="orderControl2" />
  <javadoc>
    <text>use interpolation error in stepsize control.</text>
  </javadoc>
  <declaration type="boolean" name="useInterpolationError" />
  <javadoc>
    <text>interpolation order control parameter.</text>
  </javadoc>
  <declaration type="int" name="mudif" />
  <javadoc>
    <text>Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.</text>
    <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
    <param>scalAbsoluteTolerance allowed absolute error</param>
    <param>scalRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="GraggBulirschStoerIntegrator" />
  <javadoc>
    <text>Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.</text>
    <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
    <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
    <param>vecAbsoluteTolerance allowed absolute error</param>
    <param>vecRelativeTolerance allowed relative error</param>
  </javadoc>
  <method type="constructor" name="GraggBulirschStoerIntegrator" />
  <javadoc>
    <text>Set the stability check controls.
 * &lt;p&gt;The stability check is performed on the first few iterations of
 * the extrapolation scheme. If this test fails, the step is rejected
 * and the stepsize is reduced.&lt;/p&gt;
 * &lt;p&gt;By default, the test is performed, at most during two
 * iterations at each step, and at most once for each of these
 * iterations. The default stepsize reduction factor is 0.5.&lt;/p&gt;</text>
    <param>performStabilityCheck if true, stability check will be performed,
 * if false, the check will be skipped</param>
    <param>maxNumIter maximal number of iterations for which checks are
 * performed (the number of iterations is reset to default if negative
 * or null)</param>
    <param>maxNumChecks maximal number of checks for each iteration
 * (the number of checks is reset to default if negative or null)</param>
    <param>stepsizeReductionFactor stepsize reduction factor in case of
 * failure (the factor is reset to default if lower than 0.0001 or
 * greater than 0.9999)</param>
  </javadoc>
  <method type="void" name="setStabilityCheck">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Set the step size control factors.
 * &lt;p&gt;The new step size hNew is computed from the old one h by:
 * &lt;pre&gt;
 * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))
 * &lt;/pre&gt;
 * where err is the scaled error and k the iteration number of the
 * extrapolation scheme (counting from 0). The default values are
 * 0.65 for stepControl1 and 0.94 for stepControl2.&lt;/p&gt;
 * &lt;p&gt;The step size is subject to the restriction:
 * &lt;pre&gt;
 * stepControl3^(1/(2k+1))/stepControl4 &lt;= hNew/h &lt;= 1/stepControl3^(1/(2k+1))
 * &lt;/pre&gt;
 * The default values are 0.02 for stepControl3 and 4.0 for
 * stepControl4.&lt;/p&gt;</text>
    <param>control1 first stepsize control factor (the factor is
 * reset to default if lower than 0.0001 or greater than 0.9999)</param>
    <param>control2 second stepsize control factor (the factor
 * is reset to default if lower than 0.0001 or greater than 0.9999)</param>
    <param>control3 third stepsize control factor (the factor is
 * reset to default if lower than 0.0001 or greater than 0.9999)</param>
    <param>control4 fourth stepsize control factor (the factor
 * is reset to default if lower than 1.0001 or greater than 999.9)</param>
  </javadoc>
  <method type="void" name="setControlFactors">
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Set the order control parameters.
 * &lt;p&gt;The Gragg-Bulirsch-Stoer method changes both the step size and
 * the order during integration, in order to minimize computation
 * cost. Each extrapolation step increases the order by 2, so the
 * maximal order that will be used is always even, it is twice the
 * maximal number of columns in the extrapolation table.&lt;/p&gt;
 * &lt;pre&gt;
 * order is decreased if w(k-1) &lt;= w(k)   * orderControl1
 * order is increased if w(k)   &lt;= w(k-1) * orderControl2
 * &lt;/pre&gt;
 * &lt;p&gt;where w is the table of work per unit step for each order
 * (number of function calls divided by the step length), and k is
 * the current order.&lt;/p&gt;
 * &lt;p&gt;The default maximal order after construction is 18 (i.e. the
 * maximal number of columns is 9). The default values are 0.8 for
 * orderControl1 and 0.9 for orderControl2.&lt;/p&gt;</text>
    <param>maximalOrder maximal order in the extrapolation table (the
 * maximal order is reset to default if order &lt;= 6 or odd)</param>
    <param>control1 first order control factor (the factor is
 * reset to default if lower than 0.0001 or greater than 0.9999)</param>
    <param>control2 second order control factor (the factor
 * is reset to default if lower than 0.0001 or greater than 0.9999)</param>
  </javadoc>
  <method type="void" name="setOrderControl">
    <scope />
    <scope />
    <scope />
    <scope />
    <scope />
    <comment>reinitialize the arrays</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="addStepHandler">
    <comment>reinitialize the arrays</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="addEventHandler">
    <comment>reinitialize the arrays</comment>
  </method>
  <javadoc>
    <text>Initialize the integrator internal arrays.</text>
  </javadoc>
  <method type="void" name="initializeArrays">
    <declaration type="int" name="size" />
    <scope />
    <scope />
    <scope />
    <scope>
      <scope>
        <declaration type="double" name="ratio" />
      </scope>
    </scope>
    <comment>all arrays should be reallocated with the right size</comment>
    <comment>step size sequence: 2, 6, 10, 14, ...</comment>
    <comment>initialize the order selection cost array</comment>
    <comment>(number of function calls for each column of the extrapolation table)</comment>
    <comment>initialize the extrapolation tables</comment>
  </method>
  <javadoc>
    <text>Set the interpolation order control parameter.
 * The interpolation order for dense output is 2k - mudif + 1. The
 * default value for mudif is 4 and the interpolation error is used
 * in stepsize control by default.</text>
    <param>useInterpolationErrorForControl if true, interpolation error is used
 * for stepsize control</param>
    <param>mudifControlParameter interpolation order control parameter (the parameter
 * is reset to default if &lt;= 0 or &gt;= 7)</param>
  </javadoc>
  <method type="void" name="setInterpolationControl">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Update scaling array.</text>
    <param>y1 first state vector to use for scaling</param>
    <param>y2 second state vector to use for scaling</param>
    <param>scale scaling array to update (can be shorter than state)</param>
  </javadoc>
  <method type="void" name="rescale">
    <scope>
      <scope>
        <declaration type="double" name="yi" />
      </scope>
    </scope>
    <scope>
      <scope>
        <declaration type="double" name="yi" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Perform integration over one step using substeps of a modified
 * midpoint method.</text>
    <param>t0 initial time</param>
    <param>y0 initial value of the state vector at t0</param>
    <param>step global step</param>
    <param>k iteration number (from 0 to sequence.length - 1)</param>
    <param>scale scaling array (can be shorter than state)</param>
    <param>f placeholder where to put the state vector derivatives at each substep
 * (element 0 already contains initial derivative)</param>
    <param>yMiddle placeholder where to put the state vector at the middle of the step</param>
    <param>yEnd placeholder where to put the state vector at the end</param>
    <param>yTmp placeholder for one state vector</param>
    <return>true if computation was done properly,
 * false if stability check failed before end of computation</return>
    <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    <exception>DimensionMismatchException if arrays dimensions do not match equations settings</exception>
  </javadoc>
  <method type="boolean" name="tryStep">
    <declaration type="int" name="n" />
    <declaration type="double" name="subStep" />
    <declaration type="double" name="subStep2" />
    <declaration type="double" name="t" />
    <scope />
    <scope>
      <scope />
      <scope>
        <declaration type="double" name="middle" />
      </scope>
      <scope>
        <declaration type="double" name="initialNorm" />
        <scope>
          <declaration type="double" name="ratio" />
        </scope>
        <declaration type="double" name="deltaNorm" />
        <scope>
          <declaration type="double" name="ratio" />
        </scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>first substep</comment>
    <comment>other substeps</comment>
    <comment>save the point at the middle of the step</comment>
    <comment>stability check</comment>
    <comment>correction of the last substep (at t0 + step)</comment>
  </method>
  <javadoc>
    <text>Extrapolate a vector.</text>
    <param>offset offset to use in the coefficients table</param>
    <param>k index of the last updated point</param>
    <param>diag working diagonal of the Aitken-Neville's
 * triangle, without the last element</param>
    <param>last last element</param>
  </javadoc>
  <method type="void" name="extrapolate">
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>update the diagonal</comment>
    <comment>Aitken-Neville's recursive formula</comment>
    <comment>update the last element</comment>
    <comment>Aitken-Neville's recursive formula</comment>
  </method>
  <javadoc>
    <text>{@inheritDoc}</text>
  </javadoc>
  <method type="void" name="integrate">
    <declaration type="boolean" name="forward" />
    <declaration type="double[]" name="y0" />
    <declaration type="double[]" name="y" />
    <declaration type="double[]" name="yDot0" />
    <declaration type="double[]" name="y1" />
    <declaration type="double[]" name="yTmp" />
    <declaration type="double[]" name="yTmpDot" />
    <declaration type="double[][][]" name="diagonal" />
    <declaration type="double[][][]" name="y1Diag" />
    <scope />
    <declaration type="double[][][][]" name="fk" />
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="double[]" name="yDot1" />
    <declaration type="double[][]" name="yMidDots" />
    <declaration type="double[]" name="scale" />
    <declaration type="double" name="tol" />
    <declaration type="double" name="log10R" />
    <declaration type="int" name="targetIter" />
    <declaration type="AbstractStepInterpolator" name="interpolator" />
    <declaration type="double" name="hNew" />
    <declaration type="double" name="maxError" />
    <declaration type="boolean" name="previousRejected" />
    <declaration type="boolean" name="firstTime" />
    <declaration type="boolean" name="newStep" />
    <declaration type="boolean" name="firstStepAlreadyComputed" />
    <scope>
      <declaration type="double" name="error" />
      <declaration type="boolean" name="reject" />
      <scope>
        <scope />
        <scope />
      </scope>
      <scope />
      <declaration type="double" name="nextT" />
      <declaration type="int" name="k" />
      <scope>
        <scope />
        <scope>
          <scope>
            <scope>
              <declaration type="double" name="e" />
            </scope>
            <scope />
            <scope>
              <declaration type="double" name="exp" />
              <declaration type="double" name="fac" />
              <declaration type="double" name="pow" />
              <scope>
                <scope />
                <scope>
                  <declaration type="double" name="ratio" />
                  <scope>
                    <scope />
                  </scope>
                </scope>
              </scope>
              <scope />
              <scope>
                <declaration type="double" name="ratio" />
                <scope>
                  <scope />
                </scope>
              </scope>
              <scope>
                <scope />
              </scope>
              <scope />
            </scope>
          </scope>
        </scope>
      </scope>
      <scope />
      <declaration type="double" name="hInt" />
      <scope>
        <scope />
        <declaration type="int" name="mu" />
        <scope>
          <declaration type="int" name="l2" />
          <declaration type="double" name="factor" />
          <declaration type="int" name="middleIndex" />
          <scope />
          <scope>
            <scope />
          </scope>
          <scope />
          <scope>
            <scope>
              <scope />
            </scope>
          </scope>
        </scope>
        <scope>
          <declaration type="GraggBulirschStoerStepInterpolator" name="gbsInterpolator" />
          <scope>
            <declaration type="double" name="interpError" />
            <scope />
          </scope>
        </scope>
      </scope>
      <scope>
        <declaration type="int" name="optimalIter" />
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope>
          <scope />
          <scope />
        </scope>
        <scope />
        <scope>
          <scope />
          <scope>
            <scope />
            <scope />
          </scope>
        </scope>
      </scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>create some internal working arrays</comment>
    <comment>all substeps start at the same point, so share the first array</comment>
    <comment>initial scaling</comment>
    <comment>initial order selection</comment>
    <comment>set up an interpolator sharing the integrator arrays</comment>
    <comment>first evaluation, at the beginning of the step</comment>
    <comment>step adjustment near bounds</comment>
    <comment>iterate over several substep sizes</comment>
    <comment>modified midpoint integration with the current substep</comment>
    <comment>the stability check failed, we reduce the global step</comment>
    <comment>the substep was computed successfully</comment>
    <comment>extrapolate the state at the end of the step</comment>
    <comment>using last iteration data</comment>
    <comment>estimate the error at the end of the step.</comment>
    <comment>error is too big, we reduce the global step</comment>
    <comment>compute optimal stepsize for this order</comment>
    <comment>check convergence</comment>
    <comment>check if we can stop iterations now</comment>
    <comment>convergence have been reached just before targetIter</comment>
    <comment>estimate if there is a chance convergence will</comment>
    <comment>be reached on next iteration, using the</comment>
    <comment>asymptotic evolution of error</comment>
    <comment>we don't expect to converge on next iteration</comment>
    <comment>we reject the step immediately and reduce order</comment>
    <comment>convergence has been reached exactly at targetIter</comment>
    <comment>estimate if there is a chance convergence will</comment>
    <comment>be reached on next iteration, using the</comment>
    <comment>asymptotic evolution of error</comment>
    <comment>we don't expect to converge on next iteration</comment>
    <comment>we reject the step immediately</comment>
    <comment>derivatives at end of step</comment>
    <comment>dense output handling</comment>
    <comment>extrapolate state at middle point of the step</comment>
    <comment>derivative at middle point of the step</comment>
    <comment>compute centered differences to evaluate next derivatives</comment>
    <comment>estimate the dense output coefficients</comment>
    <comment>use the interpolation error to limit stepsize</comment>
    <comment>Discrete events handling</comment>
    <comment>prepare next step</comment>
    <comment>after a rejected step neither order nor stepsize</comment>
    <comment>should increase</comment>
    <comment>stepsize control</comment>
    <comment>dispatch results</comment>
  </method>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
