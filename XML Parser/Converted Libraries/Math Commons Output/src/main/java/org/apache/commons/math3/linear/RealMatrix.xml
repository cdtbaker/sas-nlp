<?xml version="1.0" encoding="UTF-8"?>
<class name="RealMatrix">
  <javadoc>
    <text>Interface defining a real-valued matrix with basic algebraic operations.
 * &lt;p&gt;
 * Matrix element indexing is 0-based -- e.g., &lt;code&gt;getEntry(0, 0)&lt;/code&gt;
 * returns the element in the first row, first column of the matrix.&lt;/p&gt;</text>
    <version>$Id: RealMatrix.java 1416643 2012-12-03 19:37:14Z tn $</version>
  </javadoc>
  <method name="createMatrix" type="RealMatrix" />
  <javadoc>
    <text>Create a new RealMatrix of the same type as the instance with the
 * supplied
 * row and column dimensions.</text>
    <param>rowDimension the number of rows in the new matrix</param>
    <param>columnDimension the number of columns in the new matrix</param>
    <return>a new matrix of the same type as the instance</return>
    <throws>NotStrictlyPositiveException if row or column dimension is not
 * positive.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="copy" type="RealMatrix" />
  <javadoc>
    <text>Returns a (deep) copy of this.</text>
    <return>matrix copy</return>
  </javadoc>
  <method name="add" type="RealMatrix" />
  <javadoc>
    <text>Returns the sum of {@code this} and {@code m}.</text>
    <param>m matrix to be added</param>
    <return>{@code this + m}</return>
    <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this}.</throws>
  </javadoc>
  <method name="subtract" type="RealMatrix" />
  <javadoc>
    <text>Returns {@code this} minus {@code m}.</text>
    <param>m matrix to be subtracted</param>
    <return>{@code this - m}</return>
    <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this}.</throws>
  </javadoc>
  <method name="scalarAdd" type="RealMatrix" />
  <javadoc>
    <text>Returns the result of adding {@code d} to each entry of {@code this}.</text>
    <param>d value to be added to each entry</param>
    <return>{@code d + this}</return>
  </javadoc>
  <method name="scalarMultiply" type="RealMatrix" />
  <javadoc>
    <text>Returns the result of multiplying each entry of {@code this} by{@code d}.</text>
    <param>d value to multiply all entries by</param>
    <return>{@code d * this}</return>
  </javadoc>
  <method name="multiply" type="RealMatrix" />
  <javadoc>
    <text>Returns the result of postmultiplying {@code this} by {@code m}.</text>
    <param>m matrix to postmultiply by</param>
    <return>{@code this * m}</return>
    <throws>DimensionMismatchException if{@code columnDimension(this) != rowDimension(m)}</throws>
  </javadoc>
  <method name="preMultiply" type="RealMatrix" />
  <javadoc>
    <text>Returns the result of premultiplying {@code this} by {@code m}.</text>
    <param>m matrix to premultiply by</param>
    <return>{@code m * this}</return>
    <throws>DimensionMismatchException if{@code rowDimension(this) != columnDimension(m)}</throws>
  </javadoc>
  <method name="power" type="RealMatrix" />
  <javadoc>
    <text>Returns the result of multiplying {@code this} with itself {@code p}times. Depending on the underlying storage, instability for high powers
 * might occur.</text>
    <param>p raise {@code this} to power {@code p}</param>
    <return>{@code this^p}</return>
    <throws>NotPositiveException if {@code p &lt; 0}</throws>
    <throws>NonSquareMatrixException if the matrix is not square</throws>
  </javadoc>
  <method name="getData" type="double[][]" />
  <javadoc>
    <text>Returns matrix entries as a two-dimensional array.</text>
    <return>2-dimensional array of entries</return>
  </javadoc>
  <method name="getNorm" type="double" />
  <javadoc>
    <text>Returns the &lt;a href="http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html"&gt;
 * maximum absolute row sum norm&lt;/a&gt; of the matrix.</text>
    <return>norm</return>
  </javadoc>
  <method name="getFrobeniusNorm" type="double" />
  <javadoc>
    <text>Returns the &lt;a href="http://mathworld.wolfram.com/FrobeniusNorm.html"&gt;
 * Frobenius norm&lt;/a&gt; of the matrix.</text>
    <return>norm</return>
  </javadoc>
  <method name="getSubMatrix" type="RealMatrix" />
  <javadoc>
    <text>Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.</text>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <return>The subMatrix containing the data of the
 * specified rows and columns.</return>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
  </javadoc>
  <method name="getSubMatrix" type="RealMatrix" />
  <javadoc>
    <text>Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.</text>
    <param>selectedRows Array of row indices.</param>
    <param>selectedColumns Array of column indices.</param>
    <return>The subMatrix containing the data in the specified rows and
 * columns</return>
    <throws>NullArgumentException if the row or column selections are{@code null}</throws>
    <throws>NoDataException if the row or column selections are empty (zero
 * length).</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
  </javadoc>
  <method name="copySubMatrix" type="void" />
  <javadoc>
    <text>Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.</text>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <param>destination The arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be
 * used)</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <throws>MatrixDimensionMismatchException if the destination array is too
 * small.</throws>
  </javadoc>
  <method name="copySubMatrix" type="void" />
  <javadoc>
    <text>Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.</text>
    <param>selectedRows Array of row indices.</param>
    <param>selectedColumns Array of column indices.</param>
    <param>destination The arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be
 * used)</param>
    <throws>NullArgumentException if the row or column selections are{@code null}</throws>
    <throws>NoDataException if the row or column selections are empty (zero
 * length).</throws>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>MatrixDimensionMismatchException if the destination array is too
 * small.</throws>
  </javadoc>
  <method name="setSubMatrix" type="void" />
  <javadoc>
    <text>Replace the submatrix starting at {@code row, column} using data in the
 * input {@code subMatrix} array. Indexes are 0-based.
 * &lt;p&gt;
 * Example:&lt;br&gt;
 * Starting with &lt;pre&gt;
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * &lt;/pre&gt;
 * and &lt;code&gt;subMatrix = {{3, 4} {5,6}}&lt;/code&gt;, invoking{@code setSubMatrix(subMatrix,1,1))} will result in &lt;pre&gt;
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * &lt;/pre&gt;&lt;/p&gt;</text>
    <param>subMatrix  array containing the submatrix replacement data</param>
    <param>row  row coordinate of the top, left element to be replaced</param>
    <param>column  column coordinate of the top, left element to be replaced</param>
    <throws>NoDataException if {@code subMatrix} is empty.</throws>
    <throws>OutOfRangeException if {@code subMatrix} does not fit into
 * this matrix from element in {@code (row, column)}.</throws>
    <throws>DimensionMismatchException if {@code subMatrix} is not rectangular
 * (not all rows have the same length) or empty.</throws>
    <throws>NullArgumentException if {@code subMatrix} is {@code null}.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="getRowMatrix" type="RealMatrix" />
  <javadoc>
    <text>Get the entries at the given row index as a row matrix.  Row indices start
 * at 0.</text>
    <param>row Row to be fetched.</param>
    <return>row Matrix.</return>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
  </javadoc>
  <method name="setRowMatrix" type="void" />
  <javadoc>
    <text>Sets the specified {@code row} of {@code this} matrix to the entries of
 * the specified row {@code matrix}. Row indices start at 0.</text>
    <param>row Row to be set.</param>
    <param>matrix Row matrix to be copied (must have one row and the same
 * number of columns as the instance).</param>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the row dimension of the{@code matrix} is not {@code 1}, or the column dimensions of {@code this}and {@code matrix} do not match.</throws>
  </javadoc>
  <method name="getColumnMatrix" type="RealMatrix" />
  <javadoc>
    <text>Get the entries at the given column index as a column matrix. Column
 * indices start at 0.</text>
    <param>column Column to be fetched.</param>
    <return>column Matrix.</return>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
  </javadoc>
  <method name="setColumnMatrix" type="void" />
  <javadoc>
    <text>Sets the specified {@code column} of {@code this} matrix to the entries
 * of the specified column {@code matrix}. Column indices start at 0.</text>
    <param>column Column to be set.</param>
    <param>matrix Column matrix to be copied (must have one column and the
 * same number of rows as the instance).</param>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the column dimension of the{@code matrix} is not {@code 1}, or the row dimensions of {@code this}and {@code matrix} do not match.</throws>
  </javadoc>
  <method name="getRowVector" type="RealVector" />
  <javadoc>
    <text>Returns the entries in row number {@code row} as a vector. Row indices
 * start at 0.</text>
    <param>row Row to be fetched.</param>
    <return>a row vector.</return>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
  </javadoc>
  <method name="setRowVector" type="void" />
  <javadoc>
    <text>Sets the specified {@code row} of {@code this} matrix to the entries of
 * the specified {@code vector}. Row indices start at 0.</text>
    <param>row Row to be set.</param>
    <param>vector row vector to be copied (must have the same number of
 * column as the instance).</param>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the {@code vector} dimension
 * does not match the column dimension of {@code this} matrix.</throws>
  </javadoc>
  <method name="getColumnVector" type="RealVector" />
  <javadoc>
    <text>Get the entries at the given column index as a vector. Column indices
 * start at 0.</text>
    <param>column Column to be fetched.</param>
    <return>a column vector.</return>
    <throws>OutOfRangeException if the specified column index is invalid</throws>
  </javadoc>
  <method name="setColumnVector" type="void" />
  <javadoc>
    <text>Sets the specified {@code column} of {@code this} matrix to the entries
 * of the specified {@code vector}. Column indices start at 0.</text>
    <param>column Column to be set.</param>
    <param>vector column vector to be copied (must have the same number of
 * rows as the instance).</param>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the {@code vector} dimension
 * does not match the row dimension of {@code this} matrix.</throws>
  </javadoc>
  <method name="getRow" type="double[]" />
  <javadoc>
    <text>Get the entries at the given row index. Row indices start at 0.</text>
    <param>row Row to be fetched.</param>
    <return>the array of entries in the row.</return>
    <throws>OutOfRangeException if the specified row index is not valid.</throws>
  </javadoc>
  <method name="setRow" type="void" />
  <javadoc>
    <text>Sets the specified {@code row} of {@code this} matrix to the entries
 * of the specified {@code array}. Row indices start at 0.</text>
    <param>row Row to be set.</param>
    <param>array Row matrix to be copied (must have the same number of
 * columns as the instance)</param>
    <throws>OutOfRangeException if the specified row index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the {@code array} length does
 * not match the column dimension of {@code this} matrix.</throws>
  </javadoc>
  <method name="getColumn" type="double[]" />
  <javadoc>
    <text>Get the entries at the given column index as an array. Column indices
 * start at 0.</text>
    <param>column Column to be fetched.</param>
    <return>the array of entries in the column.</return>
    <throws>OutOfRangeException if the specified column index is not valid.</throws>
  </javadoc>
  <method name="setColumn" type="void" />
  <javadoc>
    <text>Sets the specified {@code column} of {@code this} matrix to the entries
 * of the specified {@code array}. Column indices start at 0.</text>
    <param>column Column to be set.</param>
    <param>array Column array to be copied (must have the same number of
 * rows as the instance).</param>
    <throws>OutOfRangeException if the specified column index is invalid.</throws>
    <throws>MatrixDimensionMismatchException if the {@code array} length does
 * not match the row dimension of {@code this} matrix.</throws>
  </javadoc>
  <method name="getEntry" type="double" />
  <javadoc>
    <text>Get the entry in the specified row and column. Row and column indices
 * start at 0.</text>
    <param>row Row index of entry to be fetched.</param>
    <param>column Column index of entry to be fetched.</param>
    <return>the matrix entry at {@code (row, column)}.</return>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
  </javadoc>
  <method name="setEntry" type="void" />
  <javadoc>
    <text>Set the entry in the specified row and column. Row and column indices
 * start at 0.</text>
    <param>row Row index of entry to be set.</param>
    <param>column Column index of entry to be set.</param>
    <param>value the new value of the entry.</param>
    <throws>OutOfRangeException if the row or column index is not valid</throws>
    <since>2.0</since>
  </javadoc>
  <method name="addToEntry" type="void" />
  <javadoc>
    <text>Adds (in place) the specified value to the specified entry of{@code this} matrix. Row and column indices start at 0.</text>
    <param>row Row index of the entry to be modified.</param>
    <param>column Column index of the entry to be modified.</param>
    <param>increment value to add to the matrix entry.</param>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="multiplyEntry" type="void" />
  <javadoc>
    <text>Multiplies (in place) the specified entry of {@code this} matrix by the
 * specified value. Row and column indices start at 0.</text>
    <param>row Row index of the entry to be modified.</param>
    <param>column Column index of the entry to be modified.</param>
    <param>factor Multiplication factor for the matrix entry.</param>
    <throws>OutOfRangeException if the row or column index is not valid.</throws>
    <since>2.0</since>
  </javadoc>
  <method name="transpose" type="RealMatrix" />
  <javadoc>
    <text>Returns the transpose of this matrix.</text>
    <return>transpose matrix</return>
  </javadoc>
  <method name="getTrace" type="double" />
  <javadoc>
    <text>Returns the &lt;a href="http://mathworld.wolfram.com/MatrixTrace.html"&gt;
 * trace&lt;/a&gt; of the matrix (the sum of the elements on the main diagonal).</text>
    <return>the trace.</return>
    <throws>NonSquareMatrixException if the matrix is not square.</throws>
  </javadoc>
  <method name="operate" type="double[]" />
  <javadoc>
    <text>Returns the result of multiplying this by the vector {@code v}.</text>
    <param>v the vector to operate on</param>
    <return>{@code this * v}</return>
    <throws>DimensionMismatchException if the length of {@code v} does not
 * match the column dimension of {@code this}.</throws>
  </javadoc>
  <method name="operate" type="RealVector" />
  <javadoc>
    <text>Returns the result of multiplying this by the vector {@code v}.</text>
    <param>v the vector to operate on</param>
    <return>{@code this * v}</return>
    <throws>DimensionMismatchException if the dimension of {@code v} does not
 * match the column dimension of {@code this}.</throws>
  </javadoc>
  <method name="preMultiply" type="double[]" />
  <javadoc>
    <text>Returns the (row) vector result of premultiplying this by the vector {@code v}.</text>
    <param>v the row vector to premultiply by</param>
    <return>{@code v * this}</return>
    <throws>DimensionMismatchException if the length of {@code v} does not
 * match the row dimension of {@code this}.</throws>
  </javadoc>
  <method name="preMultiply" type="RealVector" />
  <javadoc>
    <text>Returns the (row) vector result of premultiplying this by the vector {@code v}.</text>
    <param>v the row vector to premultiply by</param>
    <return>{@code v * this}</return>
    <throws>DimensionMismatchException if the dimension of {@code v} does not
 * match the row dimension of {@code this}.</throws>
  </javadoc>
  <method name="walkInRowOrder" type="double" />
  <javadoc>
    <text>Visit (and possibly change) all matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInRowOrder" type="double" />
  <javadoc>
    <text>Visit (but don't change) all matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInRowOrder" type="double" />
  <javadoc>
    <text>Visit (and possibly change) some matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInRowOrder" type="double" />
  <javadoc>
    <text>Visit (but don't change) some matrix entries in row order.
 * &lt;p&gt;Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="double" />
  <javadoc>
    <text>Visit (and possibly change) all matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="double" />
  <javadoc>
    <text>Visit (but don't change) all matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="double" />
  <javadoc>
    <text>Visit (and possibly change) some matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInColumnOrder" type="double" />
  <javadoc>
    <text>Visit (but don't change) some matrix entries in column order.
 * &lt;p&gt;Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="double" />
  <javadoc>
    <text>Visit (and possibly change) all matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="double" />
  <javadoc>
    <text>Visit (but don't change) all matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="double" />
  <javadoc>
    <text>Visit (and possibly change) some matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <method name="walkInOptimizedOrder" type="double" />
  <javadoc>
    <text>Visit (but don't change) some matrix entries using the fastest possible order.
 * &lt;p&gt;The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.&lt;/p&gt;</text>
    <param>visitor visitor used to process all matrix entries</param>
    <param>startRow Initial row index</param>
    <param>endRow Final row index (inclusive)</param>
    <param>startColumn Initial column index</param>
    <param>endColumn Final column index (inclusive)</param>
    <throws>OutOfRangeException if the indices are not valid.</throws>
    <throws>NumberIsTooSmallException if {@code endRow &lt; startRow} or{@code endColumn &lt; startColumn}.</throws>
    <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
    <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
    <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
  </javadoc>
  <comment>Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
