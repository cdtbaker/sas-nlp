<?xml version="1.0" encoding="UTF-8"?>
<class name="MatrixVectorMult">
  <javadoc>
    <text>&lt;p&gt;
 * This class contains various types of matrix vector multiplcation operations for {@link DenseMatrix64F}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If a matrix has only one column or row then it is a vector.  There are faster algorithms
 * that can be used to multiply matrices by vectors.  Strangely, even though the operations
 * count smaller, the difference between this and a regular matrix multiply is insignificant
 * for large matrices.  The smaller matrices there is about a 40% speed improvement.  In
 * practice the speed improvement for smaller matrices is not noticeable unless 10s of millions
 * of matrix multiplications are being performed.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix vector multiply.&lt;br&gt;
 * &lt;br&gt;
 * c = A * b &lt;br&gt;
 * and&lt;br&gt;
 * c = A * b&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;i&lt;/sub&gt; = Sum{ j=1:n, a&lt;sub&gt;ij&lt;/sub&gt; * b&lt;sub&gt;j&lt;/sub&gt;}&lt;br&gt;
 * &lt;br&gt;
 * where A is a matrix, b is a column or transposed row vector, and c is a column vector.
 * &lt;/p&gt;</text>
    <param>a A matrix that is m by n. Not modified.</param>
    <param>b A vector that has length n. Not modified.</param>
    <param>c A column vector that has length m. Modified.</param>
  </javadoc>
  <method type="void" name="mult">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="int" name="indexA" />
    <declaration type="int" name="cIndex" />
    <declaration type="double" name="b0" />
    <scope>
      <declaration type="double" name="total" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix vector multiply.&lt;br&gt;
 * &lt;br&gt;
 * C = C + A * B &lt;br&gt;
 * or&lt;br&gt;
 * C = C + A * B&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;i&lt;/sub&gt; = Sum{ j=1:n, c&lt;sub&gt;i&lt;/sub&gt; + a&lt;sub&gt;ij&lt;/sub&gt; * b&lt;sub&gt;j&lt;/sub&gt;}&lt;br&gt;
 * &lt;br&gt;
 * where A is a matrix, B is a column or transposed row vector, and C is a column vector.
 * &lt;/p&gt;</text>
    <param>A A matrix that is m by n. Not modified.</param>
    <param>B A vector that has length n. Not modified.</param>
    <param>C A column vector that has length m. Modified.</param>
  </javadoc>
  <method type="void" name="multAdd">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="int" name="indexA" />
    <declaration type="int" name="cIndex" />
    <scope>
      <declaration type="double" name="total" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix vector multiply.&lt;br&gt;
 * &lt;br&gt;
 * C = A&lt;sup&gt;T&lt;/sup&gt; * B &lt;br&gt;
 * where B is a column vector.&lt;br&gt;
 * or&lt;br&gt;
 * C = A&lt;sup&gt;T&lt;/sup&gt; * B&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * where B is a row vector. &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;i&lt;/sub&gt; = Sum{ j=1:n, a&lt;sub&gt;ji&lt;/sub&gt; * b&lt;sub&gt;j&lt;/sub&gt;}&lt;br&gt;
 * &lt;br&gt;
 * where A is a matrix, B is a column or transposed row vector, and C is a column vector.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This implementation is optimal for small matrices.  There is a huge performance hit when
 * used on large matrices due to CPU cache issues.
 * &lt;/p&gt;</text>
    <param>A A matrix that is m by n. Not modified.</param>
    <param>B A that has length m and is a column. Not modified.</param>
    <param>C A column vector that has length n. Modified.</param>
  </javadoc>
  <method type="void" name="multTransA_small">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="int" name="cIndex" />
    <scope>
      <declaration type="double" name="total" />
      <declaration type="int" name="indexA" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>An alternative implementation of {@link #multTransA_small} that performs well on large
 * matrices.  There is a relative performance hit when used on small matrices.</text>
    <param>A A matrix that is m by n. Not modified.</param>
    <param>B A Vector that has length m. Not modified.</param>
    <param>C A column vector that has length n. Modified.</param>
  </javadoc>
  <method type="void" name="multTransA_reorder">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="double" name="B_val" />
    <scope />
    <declaration type="int" name="indexA" />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix vector multiply.&lt;br&gt;
 * &lt;br&gt;
 * C = C + A&lt;sup&gt;T&lt;/sup&gt; * B &lt;br&gt;
 * or&lt;br&gt;
 * C = C&lt;sup&gt;T&lt;/sup&gt; + A&lt;sup&gt;T&lt;/sup&gt; * B&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;i&lt;/sub&gt; = Sum{ j=1:n, c&lt;sub&gt;i&lt;/sub&gt; + a&lt;sub&gt;ji&lt;/sub&gt; * b&lt;sub&gt;j&lt;/sub&gt;}&lt;br&gt;
 * &lt;br&gt;
 * where A is a matrix, B is a column or transposed row vector, and C is a column vector.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This implementation is optimal for small matrices.  There is a huge performance hit when
 * used on large matrices due to CPU cache issues.
 * &lt;/p&gt;</text>
    <param>A A matrix that is m by n. Not modified.</param>
    <param>B A vector that has length m. Not modified.</param>
    <param>C A column vector that has length n. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransA_small">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="int" name="cIndex" />
    <scope>
      <declaration type="double" name="total" />
      <declaration type="int" name="indexA" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>An alternative implementation of {@link #multAddTransA_small} that performs well on large
 * matrices.  There is a relative performance hit when used on small matrices.</text>
    <param>A A matrix that is m by n. Not modified.</param>
    <param>B A vector that has length m. Not modified.</param>
    <param>C A column vector that has length n. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransA_reorder">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <scope />
    <declaration type="int" name="indexA" />
    <scope>
      <declaration type="double" name="B_val" />
      <scope />
    </scope>
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
