<?xml version="1.0" encoding="UTF-8"?>
<class name="QRDecompositionHouseholderTran">
  <javadoc>
    <text>&lt;p&gt;
 * Householder QR decomposition is rich in operations along the columns of the matrix.  This can be
 * taken advantage of by solving for the Q matrix in a column major format to reduce the number
 * of CPU cache misses and the number of copies that are performed.
 * &lt;/p&gt;</text>
    <see>QRDecompositionHouseholder</see>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>Where the Q and R matrices are stored.  For speed reasons
 * this is transposed</text>
  </javadoc>
  <declaration type="DenseMatrix64F" name="QR" />
  <declaration type="double" name="v" />
  <declaration type="int" name="numCols" />
  <declaration type="int" name="numRows" />
  <declaration type="int" name="minLength" />
  <declaration type="double" name="gammas" />
  <declaration type="double" name="gamma" />
  <declaration type="double" name="tau" />
  <declaration type="boolean" name="error" />
  <method type="void" name="setExpectedMaxSize">
    <declaration type="int" name="maxLength" />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Inner matrix that stores the decomposition</text>
  </javadoc>
  <method type="DenseMatrix64F" name="getQR" />
  <javadoc>
    <text>Computes the Q matrix from the information stored in the QR matrix.  This
 * operation requires about 4(m&lt;sup2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.</text>
    <param>Q The orthogonal Q matrix.</param>
  </javadoc>
  <method type="DenseMatrix64F" name="getQ">
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="int" name="diagIndex" />
      <declaration type="double" name="before" />
    </scope>
    <comment>Unlike applyQ() this takes advantage of zeros in the identity matrix</comment>
    <comment>by not multiplying across all rows.</comment>
  </method>
  <javadoc>
    <text>A = Q*A</text>
    <param>A Matrix that is being multiplied by Q.  Is modified.</param>
  </javadoc>
  <method type="void" name="applyQ">
    <scope>
      <declaration type="int" name="diagIndex" />
      <declaration type="double" name="before" />
    </scope>
  </method>
  <javadoc>
    <text>A = Q&lt;sup&gt;T&lt;/sup&gt;*A</text>
    <param>A Matrix that is being multiplied by Q&lt;sup&gt;T&lt;/sup&gt;.  Is modified.</param>
  </javadoc>
  <method type="void" name="applyTranQ">
    <scope>
      <declaration type="int" name="diagIndex" />
      <declaration type="double" name="before" />
    </scope>
  </method>
  <javadoc>
    <text>Returns an upper triangular matrix which is the R in the QR decomposition.</text>
    <param>R An upper triangular matrix.</param>
    <param>compact</param>
  </javadoc>
  <method type="DenseMatrix64F" name="getR">
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
      <scope>
        <declaration type="int" name="min" />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * To decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="boolean" name="decompose">
    <scope />
  </method>
  <method type="boolean" name="inputModified" />
  <javadoc>
    <text>&lt;p&gt;
 * Computes the householder vector "u" for the first column of submatrix j.  Note this is
 * a specialized householder for this problem.  There is some protection against
 * overflow and underflow.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * This function finds the values of 'u' and '&amp;gamma;'.
 * &lt;/p&gt;</text>
    <param>j Which submatrix to work off of.</param>
  </javadoc>
  <method type="void" name="householder">
    <declaration type="int" name="startQR" />
    <declaration type="int" name="endQR" />
    <declaration type="double" name="max" />
    <scope />
    <scope>
      <declaration type="double" name="u_0" />
    </scope>
    <comment>computes tau and normalizes u by max</comment>
    <comment>divide u by u_0</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Takes the results from the householder computation and updates the 'A' matrix.&lt;br&gt;
 * &lt;br&gt;
 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)A
 * &lt;/p&gt;</text>
    <param>w The submatrix.</param>
  </javadoc>
  <method type="void" name="updateA">
    <declaration type="double[]" name="data" />
    <declaration type="int" name="rowW" />
    <declaration type="int" name="rowJ" />
    <declaration type="int" name="rowJEnd" />
    <declaration type="int" name="indexWEnd" />
    <scope>
      <declaration type="double" name="val" />
      <declaration type="int" name="indexW" />
      <declaration type="int" name="indexJ" />
      <scope />
      <scope />
    </scope>
    <comment>int rowW = w*numRows;</comment>
    <comment>int rowJ = rowW + numRows;</comment>
    <comment />
    <comment>for( int j = w+1; j &lt; numCols; j++ , rowJ += numRows) {</comment>
    <comment>double val = QR.data[rowJ + w];</comment>
    <comment />
    <comment>val = gamma*u^T * A</comment>
    <comment>for( int k = w+1; k &lt; numRows; k++ ) {</comment>
    <comment>val += QR.data[rowW + k]*QR.data[rowJ + k];</comment>
    <comment>}</comment>
    <comment>val *= gamma;</comment>
    <comment />
    <comment>A - val*u</comment>
    <comment>QR.data[rowJ + w] -= val;</comment>
    <comment>for( int i = w+1; i &lt; numRows; i++ ) {</comment>
    <comment>QR.data[rowJ + i] -= QR.data[rowW + i]*val;</comment>
    <comment>}</comment>
    <comment>}</comment>
    <comment>assume the first element in u is 1</comment>
  </method>
  <method type="double[]" name="getGammas" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>TODO remove QR Col and replace with this one?</comment>
  <comment>-- On small matrices col seems to be about 10% faster</comment>
  <comment>used internally to store temporary data</comment>
  <comment>dimension of the decomposed matrices</comment>
  <comment>this is 'n'</comment>
  <comment>this is 'm'</comment>
  <comment>the computed gamma for Q_k matrix</comment>
  <comment>local variables</comment>
  <comment>did it encounter an error?</comment>
</class>
