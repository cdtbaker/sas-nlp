<?xml version="1.0" encoding="UTF-8"?>
<class name="QRDecompositionHouseholder">
  <javadoc>
    <text>&lt;p&gt;
 * This variation of QR decomposition uses reflections to compute the Q matrix.
 * Each reflection uses a householder operations, hence its name.  To provide a meaningful solution
 * the original matrix must have full rank.  This is intended for processing of small to medium matrices.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Both Q and R are stored in the same m by n matrix.  Q is not stored directly, instead the u from
 * Q&lt;sub&gt;k&lt;/sub&gt;=(I-&amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;) is stored.  Decomposition requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
 * &lt;/p&gt;
 * &lt;p&gt;
 * See the QR reflections algorithm described in:&lt;br&gt;
 * David S. Watkins, "Fundamentals of Matrix Computations" 2nd Edition, 2002
 * &lt;/p&gt;
 * &lt;p&gt;
 * For the most part this is a straight forward implementation.  To improve performance on large matrices a column is writen to an array and the order
 * of some of the loops has been changed.  This will degrade performance noticeably on small matrices.  Since
 * it is unlikely that the QR decomposition would be a bottle neck when small matrices are involved only
 * one implementation is provided.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>Where the Q and R matrices are stored.  R is stored in the
 * upper triangular portion and Q on the lower bit.  Lower columns
 * are where u is stored.  Q_k = (I - gamma_k*u_k*u_k^T).</text>
  </javadoc>
  <declaration type="DenseMatrix64F" name="QR" />
  <declaration type="double" name="u" />
  <declaration type="int" name="numCols" />
  <declaration type="int" name="numRows" />
  <declaration type="int" name="minLength" />
  <declaration type="double" name="dataQR" />
  <declaration type="double" name="gammas" />
  <declaration type="double" name="gamma" />
  <declaration type="double" name="tau" />
  <declaration type="boolean" name="error" />
  <method type="void" name="setExpectedMaxSize">
    <declaration type="int" name="maxLength" />
    <scope />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns a single matrix which contains the combined values of Q and R.  This
 * is possible since Q is symmetric and R is upper triangular.</text>
    <return>The combined Q R matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getQR" />
  <javadoc>
    <text>Computes the Q matrix from the imformation stored in the QR matrix.  This
 * operation requires about 4(m&lt;sup&gt;2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.</text>
    <param>Q The orthogonal Q matrix.</param>
  </javadoc>
  <method type="DenseMatrix64F" name="getQ">
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns an upper triangular matrix which is the R in the QR decomposition.</text>
    <param>R An upper triangular matrix.</param>
    <param>compact</param>
  </javadoc>
  <method type="DenseMatrix64F" name="getR">
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
      <scope>
        <declaration type="int" name="min" />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <declaration type="double" name="val" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * In order to decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="boolean" name="decompose">
    <scope />
  </method>
  <method type="boolean" name="inputModified" />
  <javadoc>
    <text>&lt;p&gt;
 * Computes the householder vector "u" for the first column of submatrix j.  Note this is
 * a specialized householder for this problem.  There is some protection against
 * overflow and underflow.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * This function finds the values of 'u' and '&amp;gamma;'.
 * &lt;/p&gt;</text>
    <param>j Which submatrix to work off of.</param>
  </javadoc>
  <method type="void" name="householder">
    <declaration type="int" name="index" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="double" name="d" />
      <scope />
    </scope>
    <scope />
    <scope>
      <scope>
        <declaration type="double" name="d" />
      </scope>
      <declaration type="double" name="u_0" />
      <scope />
    </scope>
    <comment>find the element with the largest absolute value in the column and make a copy</comment>
    <comment>absolute value of d</comment>
    <comment>compute the norm2 of the matrix, with each element</comment>
    <comment>normalized by the max value to avoid overflow problems</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Takes the results from the householder computation and updates the 'A' matrix.&lt;br&gt;
 * &lt;br&gt;
 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)A
 * &lt;/p&gt;</text>
    <param>w The submatrix.</param>
  </javadoc>
  <method type="void" name="updateA">
    <scope />
    <scope>
      <declaration type="int" name="indexQR" />
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="double" name="valU" />
      <declaration type="int" name="indexQR" />
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>much of the code below is equivalent to the rank1Update function</comment>
    <comment>however, since &amp;tau; has already been computed there is no need to</comment>
    <comment>recompute it, saving a few multiplication operations</comment>
    <comment>for( int i = w+1; i &lt; numCols; i++ ) {</comment>
    <comment>double val = 0;</comment>
    <comment />
    <comment>for( int k = w; k &lt; numRows; k++ ) {</comment>
    <comment>val += u[k]*dataQR[k*numCols +i];</comment>
    <comment>}</comment>
    <comment>v[i] = gamma*val;</comment>
    <comment>}</comment>
    <comment>This is functionally the same as the above code but the order has been changed</comment>
    <comment>to avoid jumping the cpu cache</comment>
    <comment>v[i] += u[k]*dataQR[k*numCols +i];</comment>
    <comment>end of reordered code</comment>
    <comment>dataQR[i*numCols+j] -= valU*v[j];</comment>
    <comment>save the Q matrix in the lower portion of QR</comment>
  </method>
  <javadoc>
    <text>This function performs sanity check on the input for decompose and sets up the QR matrix.</text>
    <param>A</param>
  </javadoc>
  <method type="void" name="commonSetup" />
  <method type="double[]" name="getGammas" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>used internally to store temporary data</comment>
  <comment>dimension of the decomposed matrices</comment>
  <comment>this is 'n'</comment>
  <comment>this is 'm'</comment>
  <comment>the computed gamma for Q_k matrix</comment>
  <comment>local variables</comment>
  <comment>did it encounter an error?</comment>
</class>
