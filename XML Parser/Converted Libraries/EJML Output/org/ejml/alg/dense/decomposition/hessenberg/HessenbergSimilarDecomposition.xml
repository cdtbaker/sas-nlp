<?xml version="1.0" encoding="UTF-8"?>
<class name="HessenbergSimilarDecomposition">
  <javadoc>
    <text>&lt;p&gt;
 * Finds the decomposition of a matrix in the form of:&lt;br&gt;
 * &lt;br&gt;
 * A = OHO&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * &lt;br&gt;
 * where A is an m by m matrix, O is an orthogonal matrix, and H is an upper Hessenberg matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A matrix is upper Hessenberg if a&lt;sup&gt;ij&lt;/sup&gt; = 0 for all i &gt; j+1. For example, the following matrix
 * is upper Hessenberg.&lt;br&gt;
 * &lt;br&gt;
 * WRITE IT OUT USING A TABLE
 * &lt;/p&gt;
 * &lt;p&gt;
 * This decomposition is primarily used as a step for computing the eigenvalue decomposition of a matrix.
 * The basic algorithm comes from David S. Watkins, "Fundamentals of MatrixComputations" Second Edition.
 * &lt;/p&gt;</text>
  </javadoc>
  <declaration type="DenseMatrix64F" name="QH" />
  <declaration type="int" name="N" />
  <declaration type="double" name="gammas" />
  <declaration type="double" name="b" />
  <declaration type="double" name="u" />
  <javadoc>
    <text>Creates a decomposition that won't need to allocate new memory if it is passed matrices up to
 * the specified size.</text>
    <param>initialSize Expected size of the matrices it will decompose.</param>
  </javadoc>
  <method type="constructor" name="HessenbergSimilarDecomposition" />
  <method type="constructor" name="HessenbergSimilarDecomposition" />
  <javadoc>
    <text>Computes the decomposition of the provided matrix.  If no errors are detected then true is returned,
 * false otherwise.</text>
    <param>A  The matrix that is being decomposed.  Not modified.</param>
    <return>If it detects any errors or not.</return>
  </javadoc>
  <method type="boolean" name="decompose">
    <scope />
  </method>
  <method type="boolean" name="inputModified" />
  <javadoc>
    <text>The raw QH matrix that is stored internally.</text>
    <return>QH matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getQH" />
  <javadoc>
    <text>An upper Hessenberg matrix from the decompostion.</text>
    <param>H If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted H matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getH">
    <scope />
    <scope>
      <scope />
    </scope>
    <comment>copy the first row</comment>
  </method>
  <javadoc>
    <text>An orthogonal matrix that has the following property: H = Q&lt;sup&gt;T&lt;/sup&gt;AQ</text>
    <param>Q If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted Q matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getQ">
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Internal function for computing the decomposition.</text>
  </javadoc>
  <method type="boolean" name="_decompose">
    <declaration type="double[]" name="h" />
    <scope>
      <declaration type="double" name="max" />
      <scope>
        <declaration type="double" name="val" />
      </scope>
      <scope>
        <declaration type="double" name="tau" />
        <scope>
          <declaration type="double" name="val" />
        </scope>
        <declaration type="double" name="nu" />
        <scope />
        <declaration type="double" name="gamma" />
      </scope>
      <scope />
    </scope>
    <comment>find the largest value in this column</comment>
    <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    <comment>copy the householder vector to vector outside of the matrix to reduce caching issues</comment>
    <comment>big improvement on larger matrices and a relatively small performance hit on small matrices.</comment>
    <comment>-------- set up the reflector Q_k</comment>
    <comment>normalize to reduce overflow/underflow</comment>
    <comment>and compute tau for the reflector</comment>
    <comment>write the reflector into the lower left column of the matrix</comment>
    <comment>---------- multiply on the left by Q_k</comment>
    <comment>---------- multiply on the right by Q_k</comment>
    <comment>since the first element in the householder vector is known to be 1</comment>
    <comment>store the full upper hessenberg</comment>
  </method>
  <method type="double[]" name="getGammas" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>TODO create a column based one similar to what was done for QR decomposition?</comment>
  <comment>A combined matrix that stores te upper Hessenberg matrix and the orthogonal matrix.</comment>
  <comment>number of rows and columns of the matrix being decompose</comment>
  <comment>the first element in the orthogonal vectors</comment>
  <comment>temporary storage</comment>
</class>
