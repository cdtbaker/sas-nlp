<?xml version="1.0" encoding="UTF-8"?>
<class name="SvdImplicitQrDecompose">
  <javadoc>
    <text>&lt;p&gt;
 * Computes the Singular value decomposition of a matrix using the implicit QR algorithm
 * for singular value decomposition.  It works by first by transforming the matrix
 * to a bidiagonal A=U*B*V&lt;sup&gt;T&lt;/sup&gt; form, then it implicitly computing the eigenvalues of the B&lt;sup&gt;T&lt;/sup&gt;B matrix,
 * which are the same as the singular values in the original A matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Based off of the description provided in:&lt;br&gt;
 * &lt;br&gt;
 * David S. Watkins, "Fundamentals of Matrix Computations," Second Edition. Page 404-411
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="int" name="numRows" />
  <declaration type="int" name="numCols" />
  <declaration type="int" name="numRowsT" />
  <declaration type="int" name="numColsT" />
  <declaration type="boolean" name="canUseTallBidiagonal" />
  <declaration type="BidiagonalDecomposition&lt;DenseMatrix64F&gt;" name="bidiag" />
  <declaration type="SvdImplicitQrAlgorithm" name="qralg" />
  <declaration type="double" name="diag" />
  <declaration type="double" name="off" />
  <declaration type="DenseMatrix64F" name="Ut" />
  <declaration type="DenseMatrix64F" name="Vt" />
  <declaration type="double" name="singularValues" />
  <declaration type="int" name="numSingular" />
  <declaration type="boolean" name="compact" />
  <declaration type="boolean" name="computeU" />
  <declaration type="boolean" name="computeV" />
  <declaration type="boolean" name="prefComputeU" />
  <declaration type="boolean" name="prefComputeV" />
  <declaration type="boolean" name="transposed" />
  <declaration type="DenseMatrix64F" name="A_mod" />
  <javadoc>
    <text>Configures the class</text>
    <param>compact Compute a compact SVD</param>
    <param>computeU If true it will compute the U matrix</param>
    <param>computeV If true it will compute the V matrix</param>
    <param>canUseTallBidiagonal If true then it can choose to use a tall Bidiagonal decomposition to improve runtime performance.</param>
  </javadoc>
  <method type="constructor" name="SvdImplicitQrDecompose" />
  <method type="double[]" name="getSingularValues" />
  <method type="int" name="numberOfSingularValues" />
  <method type="boolean" name="isCompact" />
  <method type="DenseMatrix64F" name="getU">
    <scope />
    <scope />
  </method>
  <method type="DenseMatrix64F" name="getV">
    <scope />
    <scope />
  </method>
  <method type="DenseMatrix64F" name="getW">
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
    <scope />
    <scope />
  </method>
  <method type="boolean" name="decompose">
    <comment>make sure all the singular values or positive</comment>
    <comment>if transposed undo the transposition</comment>
  </method>
  <method type="boolean" name="inputModified" />
  <method type="boolean" name="bidiagonalization">
    <scope />
    <scope />
    <comment>change the matrix to bidiagonal form</comment>
  </method>
  <javadoc>
    <text>If the transpose was computed instead do some additional computations</text>
  </javadoc>
  <method type="void" name="undoTranspose">
    <scope>
      <declaration type="DenseMatrix64F" name="temp" />
    </scope>
  </method>
  <javadoc>
    <text>Compute singular values and U and V at the same time</text>
  </javadoc>
  <method type="boolean" name="computeUWV">
    <declaration type="boolean" name="ret" />
    <comment>long pointA = System.currentTimeMillis();</comment>
    <comment>compute U and V matrices</comment>
    <comment>long pointB = System.currentTimeMillis();</comment>
    <comment>long pointC = System.currentTimeMillis();</comment>
    <comment>System.out.println("  compute UV "+(pointB-pointA)+"  QR = "+(pointC-pointB));</comment>
  </method>
  <method type="void" name="setup">
    <scope />
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>flag what should be computed and what should not be computed</comment>
    <comment>if it is a tall matrix and U is not needed then there is faster decomposition algorithm</comment>
  </method>
  <javadoc>
    <text>With the QR algorithm it is possible for the found singular values to be negative.  This
 * makes them all positive by multiplying it by a diagonal matrix that has</text>
  </javadoc>
  <method type="void" name="makeSingularPositive">
    <scope>
      <declaration type="double" name="val" />
      <scope>
        <scope>
          <declaration type="int" name="start" />
          <declaration type="int" name="stop" />
          <scope />
        </scope>
      </scope>
      <scope />
    </scope>
    <comment>compute the results of multiplying it by an element of -1 at this location in</comment>
    <comment>a diagonal matrix.</comment>
  </method>
  <method type="int" name="numRows" />
  <method type="int" name="numCols" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>dimensions of transposed matrix</comment>
  <comment>if true then it can use the special Bidiagonal decomposition</comment>
  <comment>If U is not being computed and the input matrix is 'tall' then a special bidiagonal decomposition</comment>
  <comment>can be used which is faster.</comment>
  <comment>compute a compact SVD</comment>
  <comment>What is actually computed</comment>
  <comment>What the user requested to be computed</comment>
  <comment>If the transpose is computed instead then what is actually computed is swapped</comment>
  <comment>Should it compute the transpose instead</comment>
  <comment>Either a copy of the input matrix or a copy of it transposed</comment>
</class>
