<?xml version="1.0" encoding="UTF-8"?>
<class name="EigenPowerMethod">
  <javadoc>
    <text>&lt;p&gt;
 * The power method is an iterative method that can be used to find dominant eigen vector in
 * a matrix.  Computing &lt;b&gt;A&lt;sup&gt;n&lt;/sup&gt;q&lt;/b&gt; for larger and larger values of n, where q is a vector.  Eventually the
 * dominant (if there is any) eigen vector will "win".
 * &lt;p&gt;
 * &lt;p&gt;
 * Shift implementations find the eigen value of the matrix B=A-pI instead.  This matrix has the
 * same eigen vectors, but can converge much faster if p is chosen wisely.
 * &lt;/p&gt;
 * &lt;p&gt;
 * See section 5.3 in "Fundamentals of Matrix Computations" Second Edition, David S. Watkins.
 * &lt;/p&gt;
 * &lt;p&gt;
 * WARNING:  These functions have well known conditions where they will not converge or converge
 * very slowly and are only used in special situations in practice.  I have also seen it converge
 * to none dominant eigen vectors.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="double" name="tol" />
  <declaration type="DenseMatrix64F" name="q0" />
  <declaration type="int" name="maxIterations" />
  <declaration type="DenseMatrix64F" name="B" />
  <declaration type="DenseMatrix64F" name="seed" />
  <javadoc>
    <param>size The size of the matrix which can be processed.</param>
  </javadoc>
  <method type="constructor" name="EigenPowerMethod" />
  <javadoc>
    <text>Sets the value of the vector to use in the start of the iterations.</text>
    <param>seed The initial seed vector in the iteration.</param>
  </javadoc>
  <method type="void" name="setSeed" />
  <javadoc>
    <param>maxIterations</param>
    <param>tolerance</param>
  </javadoc>
  <method type="void" name="setOptions" />
  <javadoc>
    <text>This method computes the eigen vector with the largest eigen value by using the
 * direct power method. This technique is the easiest to implement, but the slowest to converge.
 * Works only if all the eigenvalues are real.</text>
    <param>A The matrix. Not modified.</param>
    <return>If it converged or not.</return>
  </javadoc>
  <method type="boolean" name="computeDirect">
    <declaration type="boolean" name="converged" />
    <scope>
      <declaration type="double" name="s" />
    </scope>
    <comment>q0.print();</comment>
  </method>
  <method type="void" name="initPower">
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Test for convergence by seeing if the element with the largest change
 * is smaller than the tolerance.  In some test cases it alternated between
 * the + and - values of the eigen vector.  When this happens it seems to have "converged"
 * to a non-dominant eigen vector.    At least in the case I looked at.  I haven't devoted
 * a lot of time into this issue...</text>
  </javadoc>
  <method type="boolean" name="checkConverged">
    <declaration type="double" name="worst" />
    <declaration type="double" name="worst2" />
    <scope>
      <declaration type="double" name="val" />
    </scope>
    <declaration type="DenseMatrix64F" name="temp" />
    <comment>swap vectors</comment>
  </method>
  <javadoc>
    <text>Computes the most dominant eigen vector of A using a shifted matrix.
 * The shifted matrix is defined as &lt;b&gt;B = A - &amp;alpha;I&lt;/b&gt; and can converge faster
 * if &amp;alpha; is chosen wisely.  In general it is easier to choose a value for &amp;alpha;
 * that will converge faster with the shift-invert strategy than this one.</text>
    <param>A The matrix.</param>
    <param>alpha Shifting factor.</param>
    <return>If it converged or not.</return>
  </javadoc>
  <method type="boolean" name="computeShiftDirect" />
  <javadoc>
    <text>Computes the most dominant eigen vector of A using an inverted shifted matrix.
 * The inverted shifted matrix is defined as &lt;b&gt;B = (A - &amp;alpha;I)&lt;sup&gt;-1&lt;/sup&gt;&lt;/b&gt; and
 * can converge faster if &amp;alpha; is chosen wisely.</text>
    <param>A An invertible square matrix matrix.</param>
    <param>alpha Shifting factor.</param>
    <return>If it converged or not.</return>
  </javadoc>
  <method type="boolean" name="computeShiftInvert">
    <declaration type="LinearSolver" name="solver" />
    <declaration type="boolean" name="converged" />
    <scope>
      <declaration type="double" name="s" />
    </scope>
  </method>
  <method type="DenseMatrix64F" name="getEigenVector" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>used to determine convergence</comment>
</class>
