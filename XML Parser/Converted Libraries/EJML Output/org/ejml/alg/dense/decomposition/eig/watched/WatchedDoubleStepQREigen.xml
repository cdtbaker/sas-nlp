<?xml version="1.0" encoding="UTF-8"?>
<class name="WatchedDoubleStepQREigen">
  <javadoc>
    <text>&lt;p&gt;
 * The double step implicit Eigenvalue decomposition algorithm is fairly complicated and needs to be designed so that
 * it can handle several special cases.  To aid in development and debugging this class was created.  It allows
 * individual components to be tested and to print out their results.  This shows how each step is performed.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Do not use this class to compute the eigenvalues since it is much slower than a non-debug implementation.
 * &lt;/p&gt;</text>
  </javadoc>
  <declaration type="Random" name="rand" />
  <declaration type="int" name="N" />
  <declaration type="DenseMatrix64F" name="A" />
  <declaration type="DenseMatrix64F" name="u" />
  <declaration type="double" name="gamma" />
  <declaration type="DenseMatrix64F" name="_temp" />
  <declaration type="int" name="numStepsFind" />
  <declaration type="int" name="steps" />
  <declaration type="Complex64F" name="eigenvalues" />
  <declaration type="int" name="numEigen" />
  <declaration type="EigenvalueSmall" name="valueSmall" />
  <declaration type="double" name="temp" />
  <declaration type="boolean" name="printHumps" />
  <declaration type="boolean" name="checkHessenberg" />
  <declaration type="boolean" name="checkOrthogonal" />
  <declaration type="boolean" name="checkUncountable" />
  <declaration type="boolean" name="useStandardEq" />
  <declaration type="boolean" name="useCareful2x2" />
  <declaration type="boolean" name="normalize" />
  <declaration type="int" name="lastExceptional" />
  <declaration type="int" name="numExceptional" />
  <declaration type="int" name="exceptionalThreshold" />
  <declaration type="int" name="maxIterations" />
  <declaration type="boolean" name="createR" />
  <declaration type="DenseMatrix64F" name="Q" />
  <method type="void" name="incrementSteps" />
  <method type="void" name="setQ" />
  <method type="void" name="addEigenvalue" />
  <method type="void" name="addEigenvalue" />
  <method type="void" name="setChecks" />
  <method type="boolean" name="isZero">
    <declaration type="double" name="target" />
    <declaration type="double" name="above" />
    <declaration type="double" name="right" />
    <comment>this provides a relative threshold for when dealing with very large/small numbers</comment>
    <comment>according to Matrix Computations page 352 this is what is done in Eispack</comment>
  </method>
  <method type="void" name="setup">
    <scope />
    <scope />
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>zero all the off numbers that should be zero for a hessenberg matrix</comment>
  </method>
  <javadoc>
    <text>Perform a shift in a random direction that is of the same magnitude as the elements in the matrix.</text>
  </javadoc>
  <method type="void" name="exceptionalShift">
    <declaration type="double" name="val" />
    <declaration type="double" name="p" />
    <comment>perform a random shift that is of the same magnitude as the matrix</comment>
    <comment>the closer the value is the better it handles identical eigenvalues cases</comment>
  </method>
  <javadoc>
    <text>Performs an implicit double step using the values contained in the lower right hand side
 * of the submatrix for the estimated eigenvector values.</text>
    <param>x1</param>
    <param>x2</param>
  </javadoc>
  <method type="void" name="implicitDoubleStep">
    <declaration type="double" name="z11" />
    <declaration type="double" name="z12" />
    <declaration type="double" name="z21" />
    <declaration type="double" name="z22" />
    <declaration type="double" name="a11" />
    <declaration type="double" name="a21" />
    <declaration type="double" name="a12" />
    <declaration type="double" name="a22" />
    <declaration type="double" name="a32" />
    <scope>
      <declaration type="double" name="max" />
      <scope />
    </scope>
    <declaration type="double" name="b11" />
    <scope />
    <scope />
    <comment>compute the wilkinson shift</comment>
    <comment>these equations are derived when the eigenvalues are extracted from the lower right</comment>
    <comment>2 by 2 matrix.  See page 388 of Fundamentals of Matrix Computations 2nd ed for details.</comment>
    <comment>this is different from the version in the book and seems in my testing to be more resilient to</comment>
    <comment>over flow issues</comment>
  </method>
  <javadoc>
    <text>Performs an implicit double step given the set of two imaginary eigenvalues provided.
 * Since one eigenvalue is the complex conjugate of the other only one set of real and imaginary
 * numbers is needed.</text>
    <param>x1 upper index of submatrix.</param>
    <param>x2 lower index of submatrix.</param>
    <param>real Real component of each of the eigenvalues.</param>
    <param>img Imaginary component of one of the eigenvalues.</param>
  </javadoc>
  <method type="void" name="performImplicitDoubleStep">
    <declaration type="double" name="a11" />
    <declaration type="double" name="a21" />
    <declaration type="double" name="a12" />
    <declaration type="double" name="a22" />
    <declaration type="double" name="a32" />
    <declaration type="double" name="p_plus_t" />
    <declaration type="double" name="p_times_t" />
    <declaration type="double" name="b11" />
    <scope />
    <scope />
    <comment>this is different from the version in the book and seems in my testing to be more resilient to</comment>
    <comment>over flow issues</comment>
  </method>
  <method type="void" name="performImplicitDoubleStep">
    <scope>
      <scope />
    </scope>
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <scope />
    <comment>get rid of the bump</comment>
    <comment>perform double steps</comment>
    <comment>the last one has to be a single step</comment>
    <comment>A.print("%12.3e");</comment>
  </method>
  <method type="void" name="performImplicitSingleStep">
    <scope />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <comment>get rid of the bump</comment>
    <comment>perform simple steps</comment>
  </method>
  <method type="boolean" name="createBulgeSingleStep">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b21" />
    <declaration type="double" name="threshold" />
  </method>
  <method type="boolean" name="bulgeDoubleStepQn">
    <declaration type="double" name="a11" />
    <declaration type="double" name="a21" />
    <declaration type="double" name="a31" />
    <declaration type="double" name="threshold" />
  </method>
  <method type="boolean" name="bulgeDoubleStepQn">
    <declaration type="double" name="max" />
    <scope>
      <declaration type="double" name="absA11" />
      <declaration type="double" name="absA21" />
      <declaration type="double" name="absA31" />
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <declaration type="double" name="tau" />
    <declaration type="double" name="div" />
    <scope />
    <scope />
    <scope />
    <comment>if( max &lt;= Math.abs(A.get(i,i))*UtilEjml.EPS ) {</comment>
    <comment>compute the reflector using the b's above</comment>
    <comment>compute A_1 = Q_1^T * A * Q_1</comment>
    <comment>apply Q*A  - just do the 3 rows</comment>
    <comment>apply A*Q - just the three things</comment>
    <comment>System.out.println("  after Q*A*Q ");</comment>
    <comment>A.print();</comment>
  </method>
  <method type="boolean" name="bulgeSingleStepQn">
    <declaration type="double" name="a11" />
    <declaration type="double" name="a21" />
    <declaration type="double" name="threshold" />
  </method>
  <method type="boolean" name="bulgeSingleStepQn">
    <declaration type="double" name="max" />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope />
    <declaration type="double" name="tau" />
    <declaration type="double" name="div" />
    <scope />
    <scope />
    <comment>if( max &lt;= Math.abs(A.get(i,i))*UtilEjml.EPS ) {</comment>
    <comment>System.out.println("i = "+i);</comment>
    <comment>A.print();</comment>
    <comment>compute the reflector using the b's above</comment>
    <comment>compute A_1 = Q_1^T * A * Q_1</comment>
    <comment>apply Q*A  - just do the 3 rows</comment>
    <comment>apply A*Q - just the three things</comment>
  </method>
  <method type="void" name="eigen2by2_scale">
    <declaration type="double" name="abs11" />
    <declaration type="double" name="abs22" />
    <declaration type="double" name="abs12" />
    <declaration type="double" name="abs21" />
    <declaration type="double" name="max" />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>System.out.printf("eigen (%6.3f , %6.3f) (%6.3f , %6.3f)\n",p0_real,p0_img,p1_real,p1_img);</comment>
  </method>
  <method type="int" name="getNumberOfEigenvalues" />
  <method type="Complex64F[]" name="getEigenvalues" />
  <method type="void" name="addComputedEigen2x2">
    <scope />
  </method>
  <method type="boolean" name="isReal2x2" />
  <method type="void" name="addEigenAt" />
  <method type="void" name="printSteps">
    <scope />
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>TODO make rank1UpdateMultR efficient once again by setting 0 to x1 and creating a new one that updates all the rows</comment>
  <comment>TODO option of modifying original matrix</comment>
  <comment>how many steps did it take to find the eigenvalue</comment>
  <comment>computes eigenvalues for 2 by 2 submatrices</comment>
</class>
