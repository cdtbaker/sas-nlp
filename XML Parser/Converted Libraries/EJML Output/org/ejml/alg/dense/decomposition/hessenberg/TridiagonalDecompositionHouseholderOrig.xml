<?xml version="1.0" encoding="UTF-8"?>
<class name="TridiagonalDecompositionHouseholderOrig">
  <javadoc>
    <text>&lt;p&gt;
 * A straight forward implementation from "Fundamentals of Matrix Computations," Second Edition.&lt;br&gt;
 * &lt;br&gt;
 * This is only saved to provide a point of reference in benchmarks.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>Internal storage of decomposed matrix.  The tridiagonal matrix is stored in the
 * upper tridiagonal portion of the matrix.  The householder vectors are stored
 * in the upper rows.</text>
  </javadoc>
  <declaration type="DenseMatrix64F" name="QT" />
  <declaration type="int" name="N" />
  <declaration type="double" name="w" />
  <declaration type="double" name="gammas" />
  <declaration type="double" name="b" />
  <method type="constructor" name="TridiagonalDecompositionHouseholderOrig" />
  <javadoc>
    <text>Returns the interal matrix where the decomposed results are stored.</text>
    <return />
  </javadoc>
  <method type="DenseMatrix64F" name="getQT" />
  <javadoc>
    <text>Extracts the tridiagonal matrix found in the decomposition.</text>
    <param>T If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted T matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getT">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>An orthogonal matrix that has the following property: T = Q&lt;sup&gt;T&lt;/sup&gt;AQ</text>
    <param>Q If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted Q matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getQ">
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>Q.print();</comment>
  </method>
  <javadoc>
    <text>Decomposes the provided symmetric matrix.</text>
    <param>A Symmetric matrix that is going to be decomposed.  Not modified.</param>
  </javadoc>
  <method type="void" name="decompose">
    <scope />
    <comment>System.out.println("k=="+k);</comment>
    <comment>QT.print();</comment>
  </method>
  <javadoc>
    <text>Computes and performs the similar a transform for submatrix k.</text>
  </javadoc>
  <method type="void" name="similarTransform">
    <declaration type="double[]" name="t" />
    <declaration type="double" name="max" />
    <declaration type="int" name="rowU" />
    <scope>
      <declaration type="double" name="val" />
    </scope>
    <scope>
      <declaration type="double" name="tau" />
      <scope>
        <declaration type="double" name="val" />
      </scope>
      <declaration type="double" name="nu" />
      <scope />
      <declaration type="double" name="gamma" />
    </scope>
    <scope />
    <comment>find the largest value in this column</comment>
    <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    <comment>-------- set up the reflector Q_k</comment>
    <comment>normalize to reduce overflow/underflow</comment>
    <comment>and compute tau for the reflector</comment>
    <comment>write the reflector into the lower left column of the matrix</comment>
    <comment>---------- Specialized householder that takes advantage of the symmetry</comment>
    <comment>since the first element in the householder vector is known to be 1</comment>
    <comment>store the full upper hessenberg</comment>
  </method>
  <javadoc>
    <text>Performs the householder operations on left and right and side of the matrix.  Q&lt;sup&gt;T&lt;/sup&gt;AQ</text>
    <param>row Specifies the submatrix.</param>
    <param>gamma The gamma for the householder operation</param>
  </javadoc>
  <method type="void" name="householderSymmetric">
    <declaration type="int" name="startU" />
    <scope>
      <declaration type="double" name="total" />
      <scope />
    </scope>
    <declaration type="double" name="alpha" />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="ww" />
      <declaration type="double" name="uu" />
      <scope />
    </scope>
    <comment>compute v = -gamma*A*u</comment>
    <comment>System.out.println("y["+i+"] = "+w[i]);</comment>
    <comment>alpha = -0.5*gamma*u^T*v</comment>
    <comment>w = v + alpha*u</comment>
    <comment>System.out.println("w["+i+"] = "+w[i]);</comment>
    <comment>A = A + w*u^T + u*w^T</comment>
    <comment>System.out.println("u["+i+"] = "+uu);</comment>
  </method>
  <javadoc>
    <text>If needed declares and sets up internal data structures.</text>
    <param>A Matrix being decomposed.</param>
  </javadoc>
  <method type="void" name="init">
    <scope>
      <scope />
    </scope>
    <comment>just copy the top right triangle</comment>
  </method>
  <method type="double" name="getGamma" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>The size of the matrix</comment>
  <comment>temporary storage</comment>
  <comment>gammas for the householder operations</comment>
  <comment>temporary storage</comment>
</class>
