<?xml version="1.0" encoding="UTF-8"?>
<class name="WatchedDoubleStepQREigenvector">
  <javadoc>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="WatchedDoubleStepQREigen" name="implicit" />
  <declaration type="DenseMatrix64F" name="Q" />
  <declaration type="DenseMatrix64F" name="eigenvectors" />
  <declaration type="DenseMatrix64F" name="eigenvectorTemp" />
  <declaration type="LinearSolver" name="solver" />
  <declaration type="Complex64F" name="origEigenvalues" />
  <declaration type="int" name="N" />
  <declaration type="int" name="splits" />
  <declaration type="int" name="numSplits" />
  <declaration type="int" name="x1" />
  <declaration type="int" name="indexVal" />
  <declaration type="boolean" name="onscript" />
  <method type="boolean" name="process">
    <scope />
    <scope />
    <comment>UtilEjml.setnull(eigenvectors);</comment>
    <comment>System.out.println("Orig A");</comment>
    <comment>A.print("%12.10f");</comment>
  </method>
  <method type="boolean" name="extractVectors">
    <declaration type="boolean" name="triangular" />
    <scope>
      <declaration type="Complex64F" name="c" />
      <scope />
    </scope>
    <scope>
      <declaration type="DenseMatrix64F" name="temp" />
      <scope>
        <declaration type="DenseMatrix64F" name="v" />
        <scope />
      </scope>
    </scope>
    <comment>extract eigenvectors from the shur matrix</comment>
    <comment>start at the top left corner of the matrix</comment>
    <comment>translate the eigenvectors into the frame of the original matrix</comment>
  </method>
  <method type="void" name="solveEigenvectorDuplicateEigenvalue">
    <declaration type="double" name="scale" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="Complex64F" name="c" />
      <scope>
        <declaration type="DenseMatrix64F" name="v" />
      </scope>
    </scope>
  </method>
  <method type="void" name="solveUsingTriangle">
    <scope />
    <scope />
  </method>
  <method type="void" name="solveWithLU">
    <declaration type="DenseMatrix64F" name="A" />
    <scope />
    <comment>TODO this must be very inefficient</comment>
  </method>
  <method type="boolean" name="findQandR">
    <scope>
      <scope />
    </scope>
    <comment>use the already computed eigenvalues to recompute the Q and R matrices</comment>
    <comment>Q.print("%1.10f");</comment>
    <comment />
    <comment>implicit.A.print("%1.10f");</comment>
  </method>
  <method type="boolean" name="findNextEigenvalue">
    <declaration type="boolean" name="foundEigen" />
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
      <scope />
    </scope>
    <comment>implicit.A.print();</comment>
    <comment>implicit.A.print("%e");</comment>
    <comment>System.err.println("If it needs to do an exceptional shift then something went very bad.");</comment>
    <comment>return false;</comment>
    <comment>check for convergence</comment>
  </method>
  <method type="void" name="checkSplitPerformImplicit">
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
      <scope>
        <declaration type="Complex64F" name="a" />
        <scope />
        <scope />
        <scope />
      </scope>
    </scope>
    <scope />
    <comment>check for splits</comment>
    <comment>reduce the scope of what it is looking at</comment>
    <comment>first try using known eigenvalues in the same order they were originally found</comment>
    <comment>if no splits are found perform an implicit step</comment>
    <comment>that didn't work so try a modified order</comment>
  </method>
  <method type="void" name="moveToNextSplit">
    <scope />
    <scope />
  </method>
  <method type="DenseMatrix64F" name="getQ" />
  <method type="WatchedDoubleStepQREigen" name="getImplicit" />
  <method type="DenseMatrix64F[]" name="getEigenvectors" />
  <method type="Complex64F[]" name="getEigenvalues" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>Q matrix from double step QR</comment>
</class>
