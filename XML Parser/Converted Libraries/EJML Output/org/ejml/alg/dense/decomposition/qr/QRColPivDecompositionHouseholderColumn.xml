<?xml version="1.0" encoding="UTF-8"?>
<class name="QRColPivDecompositionHouseholderColumn">
  <javadoc>
    <text>&lt;p&gt;
 * Performs QR decomposition with column pivoting.  To prevent overflow/underflow the whole matrix
 * is normalized by the max value, but columns are not normalized individually any more. To enable
 * code reuse it extends {@link QRDecompositionHouseholderColumn} and functions from that class
 * are used whenever possible.  Columns are transposed into single arrays, which allow for
 * fast pivots.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Decomposition: A*P = Q*R
 * &lt;/p&gt;
 * &lt;p&gt;
 * Based off the description in "Fundamentals of Matrix Computations", 2nd by David S. Watkins.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="int" name="pivots" />
  <declaration type="double" name="normsCol" />
  <declaration type="double" name="singularThreshold" />
  <declaration type="int" name="rank" />
  <javadoc>
    <text>Configure parameters.</text>
    <param>singularThreshold The singular threshold.</param>
  </javadoc>
  <method type="constructor" name="QRColPivDecompositionHouseholderColumn" />
  <method type="constructor" name="QRColPivDecompositionHouseholderColumn" />
  <method type="void" name="setSingularThreshold" />
  <method type="void" name="setExpectedMaxSize">
    <scope />
  </method>
  <javadoc>
    <text>Computes the Q matrix from the information stored in the QR matrix.  This
 * operation requires about 4(m&lt;sup&gt;2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.</text>
    <param>Q The orthogonal Q matrix.</param>
  </javadoc>
  <method type="DenseMatrix64F" name="getQ">
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <declaration type="double[]" name="u" />
      <declaration type="double" name="vv" />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * To decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="boolean" name="decompose">
    <scope />
    <comment>initialize pivot variables</comment>
    <comment>go through each column and perform the decomposition</comment>
    <comment>if its degenerate stop processing</comment>
  </method>
  <javadoc>
    <text>Sets the initial pivot ordering and compute the F-norm squared for each column</text>
  </javadoc>
  <method type="void" name="setupPivotInfo">
    <scope>
      <declaration type="double[]" name="c" />
      <declaration type="double" name="norm" />
      <scope>
        <declaration type="double" name="element" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Performs an efficient update of each columns' norm</text>
  </javadoc>
  <method type="void" name="updateNorms">
    <declaration type="boolean" name="foundNegative" />
    <scope>
      <declaration type="double" name="e" />
      <scope />
    </scope>
    <scope>
      <scope>
        <declaration type="double[]" name="u" />
        <declaration type="double" name="actual" />
        <scope>
          <declaration type="double" name="v" />
        </scope>
      </scope>
    </scope>
    <comment>if a negative sum has been found then clearly too much precision has been last</comment>
    <comment>and it should recompute the column norms from scratch</comment>
  </method>
  <javadoc>
    <text>Finds the column with the largest normal and makes that the first column</text>
    <param>j Current column being inspected</param>
  </javadoc>
  <method type="void" name="swapColumns">
    <declaration type="int" name="largestIndex" />
    <declaration type="double" name="largestNorm" />
    <scope>
      <declaration type="double" name="n" />
      <scope />
    </scope>
    <declaration type="double[]" name="tempC" />
    <declaration type="double" name="tempN" />
    <declaration type="int" name="tempP" />
    <comment>find the column with the largest norm</comment>
    <comment>swap the columns</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the householder vector "u" for the first column of submatrix j. The already computed
 * norm is used and checks to see if the matrix is singular at this point.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * This function finds the values of 'u' and '&amp;gamma;'.
 * &lt;/p&gt;</text>
    <param>j Which submatrix to work off of.</param>
    <return>false if it is degenerate</return>
  </javadoc>
  <method type="boolean" name="householderPivot">
    <declaration type="double[]" name="u" />
    <declaration type="double" name="max" />
    <scope />
    <scope>
      <declaration type="double" name="u_0" />
      <scope />
    </scope>
    <comment>find the largest value in this column</comment>
    <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    <comment>computes tau and normalizes u by max</comment>
    <comment>divide u by u_0</comment>
  </method>
  <method type="int" name="getRank" />
  <method type="int[]" name="getPivots" />
  <method type="DenseMatrix64F" name="getPivotMatrix">
    <scope />
    <scope />
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>the ordering of each column, the current column i is the original column pivots[i]</comment>
  <comment>F-norm  squared for each column</comment>
  <comment>threshold used to determine when a column is considered to be singular</comment>
  <comment>Threshold is relative to the maxAbs</comment>
  <comment>the matrix's rank</comment>
</class>
