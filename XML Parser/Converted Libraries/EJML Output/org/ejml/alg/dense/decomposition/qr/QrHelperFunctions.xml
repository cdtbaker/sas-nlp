<?xml version="1.0" encoding="UTF-8"?>
<class name="QrHelperFunctions">
  <javadoc>
    <text>&lt;p&gt;
 * Contains different functions that are useful for computing the QR decomposition of a matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Two different families of functions are provided for help in computing reflectors.  Internally
 * both of these functions switch between normalization by division or multiplication.  Multiplication
 * is most often significantly faster than division (2 or 3 times) but produces less accurate results
 * on very small numbers.  It checks to see if round off error is significant and decides which
 * one it should do.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Tests were done using the stability benchmark in jmatbench and there doesn't seem to be
 * any advantage to always dividing by the max instead of checking and deciding.  The most
 * noticeable difference between the two methods is with very small numbers.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <method type="double" name="findMax">
    <declaration type="double" name="max" />
    <declaration type="int" name="index" />
    <declaration type="int" name="stopIndex" />
    <scope>
      <declaration type="double" name="val" />
    </scope>
  </method>
  <method type="void" name="divideElements">
    <scope />
    <comment>double div_u = 1.0/u_0;</comment>
    <comment />
    <comment>if( Double.isInfinite(div_u)) {</comment>
    <comment>} else {</comment>
    <comment>for( int i = j; i &lt; numRows; i++ ) {</comment>
    <comment>u[i] *= div_u;</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <method type="void" name="divideElements">
    <scope />
    <comment>double div_u = 1.0/u_0;</comment>
    <comment />
    <comment>if( Double.isInfinite(div_u)) {</comment>
    <comment>} else {</comment>
    <comment>for( int i = j; i &lt; numRows; i++ ) {</comment>
    <comment>u[i+startU] *= div_u;</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <method type="void" name="divideElements_Brow">
    <scope />
    <comment>double div_u = 1.0/u_0;</comment>
    <comment />
    <comment>if( Double.isInfinite(div_u)) {</comment>
    <comment>} else {</comment>
    <comment>for( int i = j; i &lt; numRows; i++ ) {</comment>
    <comment>u[i] = b[i+startB] *= div_u;</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <method type="void" name="divideElements_Bcol">
    <declaration type="int" name="indexB" />
    <scope />
    <comment>double div_u = 1.0/u_0;</comment>
    <comment />
    <comment>if( Double.isInfinite(div_u)) {</comment>
    <comment>} else {</comment>
    <comment>int indexB = j*numCols+startB;</comment>
    <comment>for( int i = j; i &lt; numRows; i++ , indexB += numCols ) {</comment>
    <comment>b[indexB] = u[i] *= div_u;</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <method type="double" name="computeTauAndDivide">
    <declaration type="double" name="tau" />
    <scope>
      <declaration type="double" name="d" />
    </scope>
    <comment>compute the norm2 of the matrix, with each element</comment>
    <comment>normalized by the max value to avoid overflow problems</comment>
    <comment>double div_max = 1.0/max;</comment>
    <comment>if( Double.isInfinite(div_max)) {</comment>
    <comment>more accurate</comment>
    <comment>} else {</comment>
    <comment>faster</comment>
    <comment>for( int i = j; i &lt; numRows; i++ ) {</comment>
    <comment>double d = u[startU+i] *= div_max;</comment>
    <comment>tau += d*d;</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <javadoc>
    <text>Normalizes elements in 'u' by dividing by max and computes the norm2 of the normalized
 * array u.  Adjust the sign of the returned value depending on the size of the first
 * element in 'u'. Normalization is done to avoid overflow.
 * &lt;pre&gt;
 * for i=j:numRows
 * u[i] = u[i] / max
 * tau = tau + u[i]*u[i]
 * end
 * tau = sqrt(tau)
 * if( u[j] &lt; 0 )
 * tau = -tau;
 * &lt;/pre&gt;</text>
    <param>j Element in 'u' that it starts at.</param>
    <param>numRows Element in 'u' that it stops at.</param>
    <param>u Array</param>
    <param>max Max value in 'u' that is used to normalize it.</param>
    <return>norm2 of 'u'</return>
  </javadoc>
  <method type="double" name="computeTauAndDivide">
    <declaration type="double" name="tau" />
    <scope>
      <declaration type="double" name="d" />
    </scope>
    <comment>double div_max = 1.0/max;</comment>
    <comment>if( Double.isInfinite(div_max)) {</comment>
    <comment>} else {</comment>
    <comment>for( int i = j; i &lt; numRows; i++ ) {</comment>
    <comment>double d = u[i] *= div_max;</comment>
    <comment>tau += d*d;</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a rank-1 update operation on the submatrix specified by w with the multiply on the right.&lt;br&gt;
 * &lt;br&gt;
 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)*A&lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * The order that matrix multiplies are performed has been carefully selected
 * to minimize the number of operations.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Before this can become a truly generic operation the submatrix specification needs
 * to be made more generic.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="rank1UpdateMultR">
    <scope />
    <scope>
      <declaration type="int" name="indexA" />
      <declaration type="double" name="valU" />
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="double" name="valU" />
      <declaration type="int" name="indexA" />
      <scope />
    </scope>
    <comment>for( int i = colA0; i &lt; A.numCols; i++ ) {</comment>
    <comment>double val = 0;</comment>
    <comment />
    <comment>for( int k = w0; k &lt; w1; k++ ) {</comment>
    <comment>val += u[k]*A.data[k*A.numCols +i];</comment>
    <comment>}</comment>
    <comment>_temp[i] = gamma*val;</comment>
    <comment>}</comment>
    <comment>reordered to reduce cpu cache issues</comment>
    <comment>end of reorder</comment>
  </method>
  <method type="void" name="rank1UpdateMultR">
    <scope />
    <scope>
      <declaration type="int" name="indexA" />
      <declaration type="double" name="valU" />
      <scope />
    </scope>
    <scope />
    <scope>
      <declaration type="double" name="valU" />
      <declaration type="int" name="indexA" />
      <scope />
    </scope>
    <comment>for( int i = colA0; i &lt; A.numCols; i++ ) {</comment>
    <comment>double val = 0;</comment>
    <comment />
    <comment>for( int k = w0; k &lt; w1; k++ ) {</comment>
    <comment>val += u[k+offsetU]*A.data[k*A.numCols +i];</comment>
    <comment>}</comment>
    <comment>_temp[i] = gamma*val;</comment>
    <comment>}</comment>
    <comment>reordered to reduce cpu cache issues</comment>
    <comment>end of reorder</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a rank-1 update operation on the submatrix specified by w with the multiply on the left.&lt;br&gt;
 * &lt;br&gt;
 * A = A(I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)&lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * The order that matrix multiplies are performed has been carefully selected
 * to minimize the number of operations.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Before this can become a truly generic operation the submatrix specification needs
 * to be made more generic.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="rank1UpdateMultL">
    <scope>
      <declaration type="int" name="startIndex" />
      <declaration type="double" name="sum" />
      <declaration type="int" name="rowIndex" />
      <scope />
      <scope />
    </scope>
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
