<?xml version="1.0" encoding="UTF-8"?>
<class name="SvdImplicitQrAlgorithm">
  <javadoc>
    <text>&lt;p&gt;
 * Computes the QR decomposition of a bidiagonal matrix.  Internally this matrix is stored as
 * two arrays.  Shifts can either be provided to it or it can generate the shifts on its own.
 * It optionally computes the U and V matrices.  This comparability allows it to be used to
 * compute singular values and associated matrices efficiently.&lt;br&gt;
 * &lt;br&gt;
 * A = U*S*V&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * where A is the original m by n matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Based off of the outline provided in:&lt;br&gt;
 * &lt;br&gt;
 * David S. Watkins, "Fundamentals of Matrix Computations," Second Edition. Page 404-411
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note: To watch it process the matrix step by step uncomment commented out code.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="Random" name="rand" />
  <declaration type="DenseMatrix64F" name="Ut" />
  <declaration type="DenseMatrix64F" name="Vt" />
  <declaration type="int" name="totalSteps" />
  <declaration type="double" name="maxValue" />
  <declaration type="int" name="N" />
  <declaration type="EigenvalueSmall" name="eigenSmall" />
  <declaration type="int" name="numExceptional" />
  <declaration type="int" name="nextExceptional" />
  <declaration type="double" name="diag" />
  <declaration type="double" name="off" />
  <declaration type="double" name="bulge" />
  <declaration type="int" name="x1" />
  <declaration type="int" name="x2" />
  <declaration type="int" name="steps" />
  <declaration type="int" name="splits" />
  <declaration type="int" name="numSplits" />
  <declaration type="int" name="exceptionalThresh" />
  <declaration type="int" name="maxIterations" />
  <declaration type="boolean" name="followScript" />
  <declaration type="int" name="giveUpOnKnown" />
  <declaration type="double" name="values" />
  <declaration type="boolean" name="fastValues" />
  <declaration type="boolean" name="findingZeros" />
  <declaration type="double" name="c" />
  <method type="constructor" name="SvdImplicitQrAlgorithm" />
  <method type="constructor" name="SvdImplicitQrAlgorithm" />
  <method type="DenseMatrix64F" name="getUt" />
  <method type="void" name="setUt" />
  <method type="DenseMatrix64F" name="getVt" />
  <method type="void" name="setVt" />
  <javadoc />
  <method type="void" name="setMatrix">
    <scope>
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <scope />
      <scope />
    </scope>
  </method>
  <method type="double[]" name="swapDiag">
    <declaration type="double[]" name="ret" />
  </method>
  <method type="double[]" name="swapOff">
    <declaration type="double[]" name="ret" />
  </method>
  <method type="void" name="setMaxValue" />
  <method type="void" name="initParam">
    <scope />
  </method>
  <method type="boolean" name="process" />
  <javadoc>
    <text>Perform a sequence of steps based off of the singular values provided.</text>
    <param>values</param>
    <return />
  </javadoc>
  <method type="boolean" name="process" />
  <method type="boolean" name="_process">
    <scope>
      <scope />
      <scope />
      <scope />
      <scope />
      <scope>
        <scope>
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>it is a zero matrix</comment>
    <comment>if it has cycled too many times give up</comment>
    <comment>System.out.println("steps = "+steps+"  script = "+followScript+" at "+x1);</comment>
    <comment>System.out.println("Split");</comment>
    <comment>see if it is done processing this submatrix</comment>
    <comment>There are analytical solutions to this case. Just compute them directly.</comment>
    <comment>perform a step</comment>
    <comment>printMatrix();</comment>
  </method>
  <javadoc>
    <text>Here the lambda in the implicit step is determined dynamically.  At first
 * it selects zeros to quickly reveal singular values that are zero or close to zero.
 * Then it computes it using a Wilkinson shift.</text>
  </javadoc>
  <method type="void" name="performDynamicStep">
    <scope>
      <scope />
      <scope>
        <declaration type="double" name="scale" />
      </scope>
    </scope>
    <scope>
      <declaration type="double" name="scale" />
      <declaration type="double" name="lambda" />
    </scope>
    <comment>initially look for singular values of zero</comment>
    <comment>For very large and very small numbers the only way to prevent overflow/underflow</comment>
    <comment>is to have a common scale between the wilkinson shift and the implicit single step</comment>
    <comment>What happens if you don't is that when the wilkinson shift returns the value it</comment>
    <comment>computed it multiplies it by the scale twice, which will cause an overflow</comment>
    <comment>use the wilkinson shift to perform a step</comment>
  </method>
  <javadoc>
    <text>Shifts are performed based upon singular values computed previously.  If it does not converge
 * using one of those singular values it uses a Wilkinson shift instead.</text>
  </javadoc>
  <method type="void" name="performScriptedStep">
    <declaration type="double" name="scale" />
    <scope />
    <scope>
      <declaration type="double" name="s" />
    </scope>
    <comment>give up on the script</comment>
    <comment>use previous singular value to step</comment>
  </method>
  <method type="void" name="incrementSteps" />
  <method type="boolean" name="isOffZero">
    <declaration type="double" name="bottom" />
  </method>
  <method type="boolean" name="isDiagonalZero">
    <declaration type="double" name="bottom" />
    <comment>return Math.abs(diag[i]) &lt;= maxValue* UtilEjml.EPS;</comment>
  </method>
  <method type="void" name="resetSteps" />
  <javadoc>
    <text>Tells it to process the submatrix at the next split.  Should be called after the
 * current submatrix has been processed.</text>
  </javadoc>
  <method type="boolean" name="nextSplit" />
  <javadoc>
    <text>Given the lambda value perform an implicit QR step on the matrix.
 * B^T*B-lambda*I</text>
    <param>lambda Stepping factor.</param>
  </javadoc>
  <method type="void" name="performImplicitSingleStep">
    <scope />
  </method>
  <javadoc>
    <text>Multiplied a transpose orthogonal matrix Q by the specified rotator.  This is used
 * to update the U and V matrices.  Updating the transpose of the matrix is faster
 * since it only modifies the rows.</text>
    <param>Q Orthogonal matrix</param>
    <param>m Coordinate of rotator.</param>
    <param>n Coordinate of rotator.</param>
    <param>c cosine of rotator.</param>
    <param>s sine of rotator.</param>
  </javadoc>
  <method type="void" name="updateRotator">
    <declaration type="int" name="rowA" />
    <declaration type="int" name="rowB" />
    <declaration type="int" name="endA" />
    <scope>
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
    </scope>
    <comment>for( int i = 0; i &lt; Q.numCols; i++ ) {</comment>
    <comment>double a = Q.get(rowA+i);</comment>
    <comment>double b = Q.get(rowB+i);</comment>
    <comment>Q.set( rowA+i, c*a + s*b);</comment>
    <comment>Q.set( rowB+i, -s*a + c*b);</comment>
    <comment>}</comment>
    <comment>System.out.println("------ AFter Update Rotator "+m+" "+n);</comment>
    <comment>Q.print();</comment>
    <comment>System.out.println();</comment>
  </method>
  <method type="double" name="computeBulgeScale">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b12" />
    <comment />
    <comment>double b22 = diag[x1+1];</comment>
    <comment />
    <comment>double scale = Math.max( Math.abs(b11) , Math.abs(b12));</comment>
    <comment />
    <comment>return Math.max(scale,Math.abs(b22));</comment>
  </method>
  <javadoc>
    <text>Performs a similar transform on B&lt;sup&gt;T&lt;/sup&gt;B-pI</text>
  </javadoc>
  <method type="void" name="createBulge">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b12" />
    <declaration type="double" name="b22" />
    <scope />
    <scope>
      <declaration type="double" name="u1" />
      <declaration type="double" name="u2" />
      <declaration type="double" name="gamma" />
    </scope>
    <scope />
    <comment>normalize to improve resistance to overflow/underflow</comment>
    <comment>multiply the rotator on the top left.</comment>
    <comment>SimpleMatrix Q = createQ(x1, c, s, false);</comment>
    <comment>B=B.mult(Q);</comment>
    <comment />
    <comment>B.print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("  bulge = "+bulge);</comment>
    <comment>SimpleMatrix.wrap(Ut).mult(B).mult(SimpleMatrix.wrap(Vt).transpose()).print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
  </method>
  <javadoc>
    <text>Computes a rotator that will set run to zero (?)</text>
  </javadoc>
  <method type="void" name="computeRotator">
    <scope>
      <declaration type="double" name="k" />
      <declaration type="double" name="bottom" />
    </scope>
    <scope>
      <declaration type="double" name="t" />
      <declaration type="double" name="bottom" />
    </scope>
    <comment>double gamma = Math.sqrt(rise*rise + run*run);</comment>
    <comment />
    <comment>c = rise/gamma;</comment>
    <comment>s = run/gamma;</comment>
    <comment>See page 384 of Fundamentals of Matrix Computations 2nd</comment>
  </method>
  <method type="void" name="removeBulgeLeft">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b12" />
    <declaration type="double" name="b22" />
    <scope>
      <declaration type="double" name="b23" />
    </scope>
    <scope />
    <comment>apply rotator on the left</comment>
    <comment>SimpleMatrix Q = createQ(x1, c, s, true);</comment>
    <comment>B=Q.mult(B);</comment>
    <comment />
    <comment>B.print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("  bulge = "+bulge);</comment>
    <comment>SimpleMatrix.wrap(Ut).mult(B).mult(SimpleMatrix.wrap(Vt).transpose()).print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
  </method>
  <method type="void" name="removeBulgeRight">
    <declaration type="double" name="b12" />
    <declaration type="double" name="b22" />
    <declaration type="double" name="b23" />
    <declaration type="double" name="b33" />
    <scope />
    <comment>apply rotator on the right</comment>
    <comment>SimpleMatrix Q = createQ(x1+1, c, s, false);</comment>
    <comment>B=B.mult(Q);</comment>
    <comment />
    <comment>B.print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("  bulge = "+bulge);</comment>
    <comment>SimpleMatrix.wrap(Ut).mult(B).mult(SimpleMatrix.wrap(Vt).transpose()).print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
  </method>
  <method type="void" name="setSubmatrix" />
  <javadoc>
    <text>Selects the Wilkinson's shift for B&lt;sup&gt;T&lt;/sup&gt;B.  See page 410.  It is guaranteed to converge
 * and converges fast in practice.</text>
    <param>scale Scale factor used to help prevent overflow/underflow</param>
    <return>Shifting factor lambda/(scale*scale)</return>
  </javadoc>
  <method type="double" name="selectWilkinsonShift">
    <declaration type="double" name="a11" />
    <scope>
      <declaration type="double" name="d1" />
      <declaration type="double" name="o1" />
      <declaration type="double" name="d2" />
      <declaration type="double" name="o2" />
    </scope>
    <scope>
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="c" />
    </scope>
    <declaration type="double" name="diff0" />
    <declaration type="double" name="diff1" />
    <comment>return the eigenvalue closest to a22</comment>
  </method>
  <javadoc>
    <text>Computes the eigenvalue of the 2 by 2 matrix B&lt;sup&gt;T&lt;/sup&gt;B</text>
  </javadoc>
  <method type="void" name="eigenBB_2x2">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b12" />
    <declaration type="double" name="b22" />
    <declaration type="double" name="absA" />
    <declaration type="double" name="absB" />
    <declaration type="double" name="absC" />
    <declaration type="double" name="scale" />
    <declaration type="double" name="sgn" />
    <comment>normalize to reduce overflow</comment>
    <comment>see if it is a pathological case.  the diagonal must already be zero</comment>
    <comment>and the eigenvalues are all zero.  so just return</comment>
  </method>
  <javadoc>
    <text>Checks to see if either the diagonal element or off diagonal element is zero.  If one is
 * then it performs a split or pushes it off the matrix.</text>
    <return>True if there was a zero.</return>
  </javadoc>
  <method type="boolean" name="checkForAndHandleZeros">
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>check for zeros along off diagonal</comment>
    <comment>System.out.println("steps at split = "+steps);</comment>
    <comment>check for zeros along diagonal</comment>
    <comment>System.out.println("steps at split = "+steps);</comment>
  </method>
  <javadoc>
    <text>If there is a zero on the diagonal element, the off diagonal element needs pushed
 * off so that all the algorithms assumptions are two and so that it can split the matrix.</text>
  </javadoc>
  <method type="void" name="pushRight">
    <declaration type="int" name="end" />
    <scope />
    <comment>B = createB();</comment>
    <comment>B.print();</comment>
    <comment>}</comment>
  </method>
  <javadoc>
    <text>Start pushing the element off to the right.</text>
  </javadoc>
  <method type="void" name="rotatorPushRight">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b21" />
    <scope>
      <declaration type="double" name="b22" />
    </scope>
    <scope />
    <scope />
    <comment>apply rotator on the right</comment>
    <comment>SimpleMatrix Q = createQ(m,m+1, c, s, true);</comment>
    <comment>B=Q.mult(B);</comment>
    <comment />
    <comment>B.print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("  bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
    <comment>SimpleMatrix.wrap(Ut).mult(B).mult(SimpleMatrix.wrap(Vt).transpose()).print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
  </method>
  <javadoc>
    <text>Used to finish up pushing the bulge off the matrix.</text>
  </javadoc>
  <method type="void" name="rotatorPushRight2">
    <declaration type="double" name="b11" />
    <declaration type="double" name="b12" />
    <scope>
      <declaration type="double" name="b22" />
    </scope>
    <scope />
    <comment>SimpleMatrix Q = createQ(m,m+offset, c, s, true);</comment>
    <comment>B=Q.mult(B);</comment>
    <comment />
    <comment>B.print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("  bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
    <comment>SimpleMatrix.wrap(Ut).mult(B).mult(SimpleMatrix.wrap(Vt).transpose()).print();</comment>
    <comment>printMatrix();</comment>
    <comment>System.out.println("bulge = "+bulge);</comment>
    <comment>System.out.println();</comment>
  </method>
  <javadoc>
    <text>It is possible for the QR algorithm to get stuck in a loop because of symmetries.  This happens
 * more often with larger matrices.  By taking a random step it can break the symmetry and finish.</text>
  </javadoc>
  <method type="void" name="exceptionShift">
    <declaration type="double" name="mag" />
    <declaration type="double" name="angle" />
    <comment>allow more convergence time</comment>
    <comment>(numExceptional+1)*</comment>
  </method>
  <javadoc>
    <text>Creates a Q matrix for debugging purposes.</text>
  </javadoc>
  <method type="SimpleMatrix" name="createQ" />
  <javadoc>
    <text>Creates a Q matrix for debugging purposes.</text>
  </javadoc>
  <method type="SimpleMatrix" name="createQ">
    <declaration type="SimpleMatrix" name="Q" />
    <scope />
    <scope />
  </method>
  <method type="SimpleMatrix" name="createB">
    <declaration type="SimpleMatrix" name="B" />
    <scope />
  </method>
  <method type="void" name="printMatrix">
    <scope />
    <scope />
  </method>
  <method type="int" name="getNumberOfSingularValues" />
  <method type="double" name="getSingularValue" />
  <method type="void" name="setFastValues" />
  <method type="double[]" name="getSingularValues" />
  <method type="double[]" name="getDiag" />
  <method type="double[]" name="getOff" />
  <method type="double" name="getMaxValue" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>used in exceptional shifts</comment>
  <comment>U and V matrices in singular value decomposition.  Stored in the transpose</comment>
  <comment>to reduce cache jumps</comment>
  <comment>number of times it has performed an implicit step, the most costly part of the</comment>
  <comment>algorithm</comment>
  <comment>max value in original matrix.  used to test for zeros</comment>
  <comment>matrix's size</comment>
  <comment>used to compute eigenvalues directly</comment>
  <comment>how many exception shifts has it performed</comment>
  <comment>the step number of the last exception shift</comment>
  <comment>diagonal elements in the matrix</comment>
  <comment>the off diagonal elements</comment>
  <comment>value of the bulge</comment>
  <comment>the submatrix its working on</comment>
  <comment>how many cycles has it run through looking for the current singular value</comment>
  <comment>where splits are performed</comment>
  <comment>After this many iterations it will perform an exceptional</comment>
  <comment>should the steps use a sequence of predefined lambdas?</comment>
  <comment>--------- variables for scripted step</comment>
  <comment>if following a sequence of steps, this is the point at which it decides its</comment>
  <comment>going no where and needs to use a different step</comment>
  <comment>can it compute singularvalues directly</comment>
  <comment>if not in scripted mode is it looking for new zeros first?</comment>
  <comment>for debugging</comment>
  <comment>SimpleMatrix B;</comment>
</class>
