<?xml version="1.0" encoding="UTF-8"?>
<class name="CholeskyDecompositionBlock">
  <javadoc>
    <text>This is an implementation of Cholesky that processes internal submatrices as blocks.  This is
 * done to reduce the number of cache issues.</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="int" name="blockWidth" />
  <declaration type="DenseMatrix64F" name="B" />
  <declaration type="CholeskyBlockHelper" name="chol" />
  <javadoc>
    <text>Creates a CholeksyDecomposition capable of decomposing a matrix that is
 * n by n, where n is the width.</text>
    <param>blockWidth The width of a block.</param>
  </javadoc>
  <method type="constructor" name="CholeskyDecompositionBlock" />
  <javadoc>
    <text>Declares additional internal data structures.</text>
  </javadoc>
  <method type="void" name="setExpectedMaxSize">
    <comment>if the matrix that is being decomposed is smaller than the block we really don't</comment>
    <comment>see the B matrix.</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs Choleksy decomposition on the provided matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the matrix is not positive definite then this function will return
 * false since it can't complete its computations.  Not all errors will be
 * found.
 * &lt;/p&gt;</text>
    <return>True if it was able to finish the decomposition.</return>
  </javadoc>
  <method type="boolean" name="decomposeLower">
    <declaration type="int" name="numBlocks" />
    <declaration type="int" name="remainder" />
    <scope />
    <scope>
      <scope>
        <declaration type="int" name="indexSrc" />
        <declaration type="int" name="indexDst" />
        <declaration type="int" name="indexL" />
      </scope>
      <scope>
        <declaration type="int" name="width" />
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>apply cholesky to the current block</comment>
    <comment>B = L^(-1) * B</comment>
    <comment>c = c - a^T*a</comment>
    <comment>zero the top right corner.</comment>
  </method>
  <method type="boolean" name="decomposeUpper" />
  <javadoc>
    <text>This is a variation on the {@link org.ejml.alg.dense.decomposition.TriangularSolver#solveL} function.
 * It grabs the input from the top right row rectangle of the source matrix then writes the results
 * to the lower bottom column rectangle.  The rectangle matrices just matrices are submatrices
 * of the matrix that is being decomposed.  The results are also written to B.</text>
    <param>L A lower triangular matrix.</param>
    <param>b_src matrix with the vectors that are to be solved for</param>
    <param>indexSrc First index of the submatrix where the inputs are coming from.</param>
    <param>indexDst First index of the submatrix where the results are going to.</param>
    <param>B</param>
  </javadoc>
  <method type="void" name="solveL_special">
    <declaration type="double[]" name="dataSrc" />
    <declaration type="double[]" name="b" />
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
    <declaration type="int" name="widthL" />
    <scope>
      <declaration type="int" name="indexb" />
      <declaration type="int" name="rowL" />
      <scope>
        <declaration type="double" name="sum" />
        <declaration type="int" name="indexL" />
        <declaration type="int" name="endL" />
        <declaration type="int" name="indexB" />
        <scope />
        <declaration type="double" name="val" />
      </scope>
    </scope>
    <comment>for( int j = 0; j &lt; n; j++ ) {</comment>
    <comment>for( int i = 0; i &lt; widthL; i++ ) {</comment>
    <comment>double sum = dataSrc[indexSrc+i*b_src.numCols+j];</comment>
    <comment>for( int k=0; k&lt;i; k++ ) {</comment>
    <comment>sum -= L[i*widthL+k]* b[k*n+j];</comment>
    <comment>}</comment>
    <comment>double val = sum / L[i*widthL+i];</comment>
    <comment>dataSrc[indexDst+j*b_src.numCols+i] = val;</comment>
    <comment>b[i*n+j] = val;</comment>
    <comment>}</comment>
    <comment>}</comment>
    <comment>for( int i = 0; i &lt; widthL; i++</comment>
    <comment>for( int k=0; k&lt;i; k++ ) {</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs this operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c - a&lt;sup&gt;T&lt;/sup&gt;a &lt;br&gt;
 * where c is a submatrix.
 * &lt;/p&gt;
 * Only the upper triangle is updated.</text>
    <param>a A matrix.</param>
    <param>c A matrix.</param>
    <param>startIndexC start of the submatrix in c.</param>
  </javadoc>
  <method type="void" name="symmRankTranA_sub">
    <declaration type="double[]" name="dataA" />
    <declaration type="double[]" name="dataC" />
    <declaration type="int" name="strideC" />
    <scope>
      <declaration type="int" name="indexA" />
      <declaration type="int" name="endR" />
      <scope>
        <declaration type="int" name="indexC" />
        <declaration type="double" name="valA" />
        <declaration type="int" name="indexR" />
        <scope />
      </scope>
    </scope>
    <comment>TODO update so that it doesn't modify/read parts that it shouldn't</comment>
    <comment>for( int i = 0; i &lt; a.numCols; i++ ) {</comment>
    <comment>for( int k = 0; k &lt; a.numRows; k++ ) {</comment>
    <comment>double valA = dataA[k*a.numCols+i];</comment>
    <comment />
    <comment>for( int j = i; j &lt; a.numCols; j++ ) {</comment>
    <comment>dataC[startIndexC+i*c.numCols+j] -= valA * dataA[k*a.numCols+j];</comment>
    <comment>}</comment>
    <comment>}</comment>
    <comment>}</comment>
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>how wide the blocks should be</comment>
  <comment>row rectangular matrix</comment>
</class>
