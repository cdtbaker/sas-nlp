<?xml version="1.0" encoding="UTF-8"?>
<class name="QrUpdate">
  <javadoc>
    <text>&lt;p&gt;
 * The effects of adding and removing rows from the A matrix in a QR decomposition can
 * be computed much faster than simply recomputing the whole decomposition.  There are many real
 * world situations where this is useful.  For example, when computing a rolling solution to
 * the most recent N measurements.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Definitions: A &amp;isin; &amp;real; &lt;sup&gt;m &amp;times; n&lt;/sup&gt;, m &amp;ge; n, rank(A) = n and that A = QR, where
 * Q &amp;isin; &amp;real; &lt;sup&gt;m &amp;times; m&lt;/sup&gt; is orthogonal, and R &amp;isin; &amp;real; &lt;sup&gt;m &amp;times; n&lt;/sup&gt; is
 * upper triangular.
 * &lt;/p&gt;
 * &lt;p&gt;
 * ** IMPORTANT USAGE NOTE ** If auto grow is set to true then the internal data structures will grow automatically
 * to accommodate the matrices passed in.  When adding elements to the decomposition the matrices must have enough
 * data elements to grow before hand.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For more information see David S. Watkins, "Fundamentals of Matrix Computations" 2nd edition, pages 249-259.
 * It is also possible to add and remove columns efficiently, but this is less common and is not supported at
 * this time.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="DenseMatrix64F" name="Q" />
  <declaration type="DenseMatrix64F" name="U_tran" />
  <declaration type="DenseMatrix64F" name="Qm" />
  <declaration type="double" name="r_row" />
  <declaration type="int" name="maxCols" />
  <declaration type="int" name="maxRows" />
  <declaration type="int" name="m" />
  <declaration type="int" name="m_m" />
  <declaration type="boolean" name="autoGrow" />
  <javadoc>
    <text>Creates an update which can decompose matrices up to the specified size.  Autogrow
 * is set to false.</text>
    <param>maxRows</param>
    <param>maxCols</param>
  </javadoc>
  <method type="constructor" name="QrUpdate" />
  <javadoc>
    <text>Creates an update which can decompose matrices up to the specified size.  Autogrow
 * is configurable.</text>
    <param>maxRows</param>
    <param>maxCols</param>
    <param>autoGrow</param>
  </javadoc>
  <method type="constructor" name="QrUpdate" />
  <javadoc>
    <text>Does not predeclare data and it will autogrow.</text>
  </javadoc>
  <method type="constructor" name="QrUpdate" />
  <javadoc>
    <text>Declares the internal data structures so that it can process matrices up to the specified size.</text>
    <param>maxRows</param>
    <param>maxCols</param>
  </javadoc>
  <method type="void" name="declareInternalData" />
  <javadoc>
    <text>&lt;p&gt;
 * Adjusts the values of the Q and R matrices to take in account the effects of inserting
 * a row to the 'A' matrix at the specified location.  This operation requires about 6mn + O(n) flops.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If Q and/or R does not have enough data elements to grow then an exception is thrown.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The adjustment done is by computing a series of planar Givens rotations that make the adjusted R
 * matrix upper triangular again.  This is then used to modify the Q matrix.
 * &lt;/p&gt;</text>
    <param>Q The Q matrix which is to be modified, must be big enough to grow.  Must be n by n..  Is modified.</param>
    <param>R The R matrix which is to be modified, must be big enough to grow.  Must be m by n.  Is modified.</param>
    <param>row The row being inserted.  Not modified.</param>
    <param>rowIndex Which row index it is to be inserted at.</param>
    <param>resizeR Should the number of rows in R be changed?  The additional rows are all zero.</param>
  </javadoc>
  <method type="void" name="addRow">
    <comment>memory management and check precoditions</comment>
    <comment>apply givens rotation to the first two rows of the augmented R matrix</comment>
    <comment>compute new Q matrix</comment>
    <comment>discard the reference since it is no longer needed</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Adjusts the values of the Q and R matrices to take in account the effects of removing
 * a row from the 'A' matrix at the specified location.  This operation requires about 6mn + O(n) flops.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The adjustment is done by computing a series of planar Givens rotations that make the removed row in Q
 * equal to [1 0 ... 0].
 * &lt;/p&gt;</text>
    <param>Q The Q matrix.  Is modified.</param>
    <param>R The R matrix.  Is modified.</param>
    <param>rowIndex Which index of the row that is being removed.</param>
    <param>resizeR should the shape of R be adjusted?</param>
  </javadoc>
  <method type="void" name="deleteRow">
    <scope />
    <comment>discard the reference since it is no longer needed</comment>
  </method>
  <javadoc>
    <text>Provides the results of a QR decomposition.  These will be modified by adding or removing
 * rows from the original 'A' matrix.</text>
    <param>Q The Q matrix which is to be modified.  Is modified later and reference saved.</param>
    <param>R The R matrix which is to be modified.  Is modified later and reference saved.</param>
  </javadoc>
  <method type="void" name="setQR">
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Updates the Q matrix to take in account the inserted matrix.</text>
    <param>rowIndex where the matrix has been inserted.</param>
  </javadoc>
  <method type="void" name="updateInsertQ">
    <scope>
      <scope>
        <declaration type="double" name="sum" />
        <scope />
      </scope>
    </scope>
    <scope />
    <scope>
      <scope>
        <declaration type="double" name="sum" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Updates the Q matrix to take inaccount the row that was removed by only multiplying e
 * lements that need to be.  There is still some room for improvement here...</text>
    <param>rowIndex</param>
  </javadoc>
  <method type="void" name="updateRemoveQ">
    <scope>
      <scope>
        <declaration type="double" name="sum" />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <declaration type="double" name="sum" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Updates the R matrix to take in account the removed row.</text>
  </javadoc>
  <method type="void" name="updateRemoveR">
    <scope>
      <scope>
        <declaration type="double" name="sum" />
        <scope />
      </scope>
    </scope>
  </method>
  <method type="void" name="applyFirstGivens">
    <declaration type="double" name="c" />
    <declaration type="double" name="xi" />
    <declaration type="double" name="xj" />
    <declaration type="double" name="r" />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="vali" />
      <declaration type="double" name="valj" />
    </scope>
    <comment>set U to its initial values</comment>
  </method>
  <method type="void" name="applyLaterGivens">
    <scope>
      <declaration type="double" name="c" />
      <declaration type="double" name="xi" />
      <declaration type="double" name="xj" />
      <declaration type="double" name="r" />
      <scope />
      <scope />
      <scope>
        <declaration type="double" name="vali" />
        <declaration type="double" name="valj" />
      </scope>
      <scope>
        <declaration type="double" name="q1" />
        <declaration type="double" name="q2" />
      </scope>
    </scope>
    <comment>first compute the rotation</comment>
    <comment>update R matrix</comment>
    <comment>compute U^T = U^T_(x+1) * U^T_x</comment>
  </method>
  <method type="void" name="computeRemoveGivens">
    <declaration type="double" name="xj" />
    <scope>
      <declaration type="double" name="c" />
      <declaration type="double" name="xi" />
      <declaration type="double" name="r" />
      <scope />
      <scope />
      <scope>
        <declaration type="double" name="q1" />
        <declaration type="double" name="q2" />
      </scope>
    </scope>
    <comment>first compute the rotation</comment>
    <comment>in the next iteration xj is r</comment>
    <comment>compute U^T = U^T_(x+1) * U^T_x</comment>
  </method>
  <method type="DenseMatrix64F" name="getU_tran" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>the decomposition that is being adjusted</comment>
  <comment>product of planar multiplications</comment>
  <comment>using transpose of U reduces cache misses</comment>
  <comment>used to temporarially store data</comment>
  <comment>it can process matrices up to this size</comment>
  <comment>number of rows and columns in the original A matrix that was decomposed</comment>
  <comment>number of rows in the adjusted matrices</comment>
  <comment>should it declare new internal data when what currently exists is too small or throw</comment>
  <comment>and exception.</comment>
</class>
