<?xml version="1.0" encoding="UTF-8"?>
<class name="TridiagonalDecompositionHouseholder">
  <javadoc>
    <text>&lt;p&gt;
 * Performs a {@link TridiagonalSimilarDecomposition similar tridiagonal decomposition} on a square symmetric input matrix.
 * Householder vectors perform the similar operation and the symmetry is taken advantage
 * of for good performance.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Finds the decomposition of a matrix in the form of:&lt;br&gt;
 * &lt;br&gt;
 * A = O*T*O&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * &lt;br&gt;
 * where A is a symmetric m by m matrix, O is an orthogonal matrix, and T is a tridiagonal matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This implementation is based off of the algorithm described in:&lt;br&gt;
 * &lt;br&gt;
 * David S. Watkins, "Fundamentals of Matrix Computations," Second Edition.  Page 349-355
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>Only the upper right triangle is used.  The Tridiagonal portion stores
 * the tridiagonal matrix.  The rows store householder vectors.</text>
  </javadoc>
  <declaration type="DenseMatrix64F" name="QT" />
  <declaration type="int" name="N" />
  <declaration type="double" name="w" />
  <declaration type="double" name="gammas" />
  <declaration type="double" name="b" />
  <method type="constructor" name="TridiagonalDecompositionHouseholder" />
  <javadoc>
    <text>Returns the internal matrix where the decomposed results are stored.</text>
    <return />
  </javadoc>
  <method type="DenseMatrix64F" name="getQT" />
  <method type="void" name="getDiagonal">
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Extracts the tridiagonal matrix found in the decomposition.</text>
    <param>T If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted T matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getT">
    <scope />
    <scope>
      <declaration type="double" name="a" />
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>An orthogonal matrix that has the following property: T = Q&lt;sup&gt;T&lt;/sup&gt;AQ</text>
    <param>Q If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted Q matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getQ">
    <scope />
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Decomposes the provided symmetric matrix.</text>
    <param>A Symmetric matrix that is going to be decomposed.  Not modified.</param>
  </javadoc>
  <method type="boolean" name="decompose">
    <scope />
  </method>
  <javadoc>
    <text>Computes and performs the similar a transform for submatrix k.</text>
  </javadoc>
  <method type="void" name="similarTransform">
    <declaration type="double[]" name="t" />
    <declaration type="double" name="max" />
    <declaration type="int" name="rowU" />
    <scope>
      <declaration type="double" name="val" />
    </scope>
    <scope>
      <declaration type="double" name="tau" />
      <declaration type="double" name="nu" />
      <declaration type="double" name="gamma" />
    </scope>
    <scope />
    <comment>find the largest value in this column</comment>
    <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    <comment>-------- set up the reflector Q_k</comment>
    <comment>write the reflector into the lower left column of the matrix</comment>
    <comment>---------- Specialized householder that takes advantage of the symmetry</comment>
    <comment>since the first element in the householder vector is known to be 1</comment>
    <comment>store the full upper hessenberg</comment>
  </method>
  <javadoc>
    <text>Performs the householder operations on left and right and side of the matrix.  Q&lt;sup&gt;T&lt;/sup&gt;AQ</text>
    <param>row Specifies the submatrix.</param>
    <param>gamma The gamma for the householder operation</param>
  </javadoc>
  <method type="void" name="householderSymmetric">
    <declaration type="int" name="startU" />
    <scope>
      <declaration type="double" name="total" />
      <scope />
      <scope />
    </scope>
    <declaration type="double" name="alpha" />
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="ww" />
      <declaration type="double" name="uu" />
      <declaration type="int" name="rowA" />
      <scope />
    </scope>
    <comment>compute v = -gamma*A*u</comment>
    <comment>the lower triangle is not written to so it needs to traverse upwards</comment>
    <comment>to get the information.  Reduces the number of matrix writes need</comment>
    <comment>improving large matrix performance</comment>
    <comment>alpha = -0.5*gamma*u^T*v</comment>
    <comment>w = v + alpha*u</comment>
    <comment>A = A + w*u^T + u*w^T</comment>
    <comment>only write to the upper portion of the matrix</comment>
    <comment>this reduces the number of cache misses</comment>
  </method>
  <javadoc>
    <text>If needed declares and sets up internal data structures.</text>
    <param>A Matrix being decomposed.</param>
  </javadoc>
  <method type="void" name="init">
    <scope>
      <scope />
    </scope>
  </method>
  <method type="boolean" name="inputModified" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>The size of the matrix</comment>
  <comment>temporary storage</comment>
  <comment>gammas for the householder operations</comment>
  <comment>temporary storage</comment>
</class>
