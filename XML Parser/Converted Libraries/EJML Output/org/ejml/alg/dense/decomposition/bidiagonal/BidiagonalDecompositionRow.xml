<?xml version="1.0" encoding="UTF-8"?>
<class name="BidiagonalDecompositionRow">
  <javadoc>
    <text>&lt;p&gt;
 * Performs a {@link org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecomposition} using
 * householder reflectors.  This is efficient on wide or square matrices.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="DenseMatrix64F" name="UBV" />
  <declaration type="int" name="m" />
  <declaration type="int" name="n" />
  <declaration type="int" name="min" />
  <declaration type="double" name="gammasU" />
  <declaration type="double" name="gammasV" />
  <declaration type="double" name="b" />
  <declaration type="double" name="u" />
  <javadoc>
    <text>Creates a decompose that defines the specified amount of memory.</text>
    <param>numElements number of elements in the matrix.</param>
  </javadoc>
  <method type="constructor" name="BidiagonalDecompositionRow" />
  <method type="constructor" name="BidiagonalDecompositionRow" />
  <javadoc>
    <text>Computes the decomposition of the provided matrix.  If no errors are detected then true is returned,
 * false otherwise.</text>
    <param>A  The matrix that is being decomposed.  Not modified.</param>
    <return>If it detects any errors or not.</return>
  </javadoc>
  <method type="boolean" name="decompose" />
  <javadoc>
    <text>Sets up internal data structures and creates a copy of the input matrix.</text>
    <param>A The input matrix.  Not modified.</param>
  </javadoc>
  <method type="void" name="init">
    <declaration type="int" name="max" />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>The raw UBV matrix that is stored internally.</text>
    <return>UBV matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getUBV" />
  <method type="void" name="getDiagonal">
    <scope />
  </method>
  <javadoc>
    <text>Returns the bidiagonal matrix.</text>
    <param>B If not null the results are stored here, if null a new matrix is created.</param>
    <return>The bidiagonal matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getB">
    <scope />
    <comment>System.arraycopy(UBV.data, 0, B.data, 0, UBV.getNumElements());</comment>
  </method>
  <method type="DenseMatrix64F" name="handleB">
    <declaration type="int" name="w" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Returns the orthogonal U matrix.</text>
    <param>U If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted Q matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getU">
    <scope>
      <scope />
    </scope>
  </method>
  <method type="DenseMatrix64F" name="handleU">
    <scope>
      <scope>
        <scope />
      </scope>
      <scope />
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>Returns the orthogonal V matrix.</text>
    <param>V If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
    <return>The extracted Q matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getV">
    <scope>
      <scope />
    </scope>
    <comment>UBV.print();</comment>
    <comment>todo the very first multiplication can be avoided by setting to the rank1update output</comment>
  </method>
  <method type="DenseMatrix64F" name="handleV">
    <declaration type="int" name="w" />
    <scope>
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Internal function for computing the decomposition.</text>
  </javadoc>
  <method type="boolean" name="_decompose">
    <scope />
    <comment>UBV.print();</comment>
    <comment>System.out.println("--- after U");</comment>
    <comment>UBV.print();</comment>
    <comment>System.out.println("--- after V");</comment>
    <comment>UBV.print();</comment>
  </method>
  <method type="void" name="computeU">
    <declaration type="double[]" name="b" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="double" name="val" />
    </scope>
    <scope>
      <declaration type="double" name="tau" />
      <declaration type="double" name="nu" />
      <declaration type="double" name="gamma" />
    </scope>
    <scope />
    <comment>find the largest value in this column</comment>
    <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    <comment>copy the householder vector to vector outside of the matrix to reduce caching issues</comment>
    <comment>big improvement on larger matrices and a relatively small performance hit on small matrices.</comment>
    <comment>-------- set up the reflector Q_k</comment>
    <comment>write the reflector into the lower left column of the matrix</comment>
    <comment>while dividing u by nu</comment>
    <comment>---------- multiply on the left by Q_k</comment>
  </method>
  <method type="void" name="computeV">
    <declaration type="double[]" name="b" />
    <declaration type="int" name="row" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="double" name="tau" />
      <declaration type="double" name="nu" />
      <declaration type="double" name="gamma" />
    </scope>
    <scope />
    <comment>find the largest value in this column</comment>
    <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    <comment>-------- set up the reflector Q_k</comment>
    <comment>write the reflector into the lower left column of the matrix</comment>
    <comment>writing to u could be avoided by working directly with b.</comment>
    <comment>requires writing a custom rank1Update function</comment>
    <comment>---------- multiply on the left by Q_k</comment>
  </method>
  <javadoc>
    <text>Returns gammas from the householder operations for the U matrix.</text>
    <return>gammas for householder operations</return>
  </javadoc>
  <method type="double[]" name="getGammasU" />
  <javadoc>
    <text>Returns gammas from the householder operations for the V matrix.</text>
    <return>gammas for householder operations</return>
  </javadoc>
  <method type="double[]" name="getGammasV" />
  <method type="boolean" name="inputModified" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>A combined matrix that stores te upper Hessenberg matrix and the orthogonal matrix.</comment>
  <comment>number of rows</comment>
  <comment>number of columns</comment>
  <comment>the smaller of m or n</comment>
  <comment>the first element in the orthogonal vectors</comment>
  <comment>temporary storage</comment>
</class>
