<?xml version="1.0" encoding="UTF-8"?>
<class name="SymmetricQREigenHelper">
  <javadoc>
    <text>A helper class for the symmetric matrix implicit QR algorithm for eigenvalue decomposition.
 * Performs most of the basic operations needed to extract eigenvalues and eigenvectors.</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="Random" name="rand" />
  <declaration type="int" name="steps" />
  <declaration type="int" name="numExceptional" />
  <declaration type="int" name="lastExceptional" />
  <declaration type="EigenvalueSmall" name="eigenSmall" />
  <declaration type="DenseMatrix64F" name="Q" />
  <declaration type="int" name="N" />
  <declaration type="double" name="diag" />
  <declaration type="double" name="off" />
  <declaration type="int" name="x1" />
  <declaration type="int" name="x2" />
  <declaration type="int" name="splits" />
  <declaration type="int" name="numSplits" />
  <declaration type="double" name="bulge" />
  <declaration type="double" name="c" />
  <method type="constructor" name="SymmetricQREigenHelper" />
  <method type="void" name="printMatrix">
    <scope />
    <scope />
  </method>
  <method type="void" name="setQ" />
  <method type="void" name="incrementSteps" />
  <javadoc>
    <text>Sets up and declares internal data structures.</text>
    <param>diag Diagonal elements from tridiagonal matrix. Modified.</param>
    <param>off Off diagonal elements from tridiagonal matrix. Modified.</param>
    <param>numCols number of columns (and rows) in the matrix.</param>
  </javadoc>
  <method type="void" name="init" />
  <javadoc>
    <text>Exchanges the internal array of the diagonal elements for the provided one.</text>
  </javadoc>
  <method type="double[]" name="swapDiag">
    <declaration type="double[]" name="ret" />
  </method>
  <javadoc>
    <text>Exchanges the internal array of the off diagonal elements for the provided one.</text>
  </javadoc>
  <method type="double[]" name="swapOff">
    <declaration type="double[]" name="ret" />
  </method>
  <javadoc>
    <text>Sets the size of the matrix being decomposed, declares new memory if needed,
 * and sets all helper functions to their initial value.</text>
  </javadoc>
  <method type="void" name="reset">
    <scope />
  </method>
  <method type="double[]" name="copyDiag">
    <scope />
  </method>
  <method type="double[]" name="copyOff">
    <scope />
  </method>
  <method type="double[]" name="copyEigenvalues">
    <scope />
  </method>
  <javadoc>
    <text>Sets which submatrix is being processed.</text>
    <param>x1 Lower bound, inclusive.</param>
    <param>x2 Upper bound, inclusive.</param>
  </javadoc>
  <method type="void" name="setSubmatrix" />
  <javadoc>
    <text>Checks to see if the specified off diagonal element is zero using a relative metric.</text>
  </javadoc>
  <method type="boolean" name="isZero">
    <declaration type="double" name="bottom" />
  </method>
  <method type="void" name="performImplicitSingleStep">
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <method type="void" name="updateQ">
    <declaration type="int" name="rowA" />
    <declaration type="int" name="rowB" />
    <declaration type="int" name="endA" />
    <scope>
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
    </scope>
    <comment>for( int i = 0; i &lt; N; i++ ) {</comment>
    <comment>double a = Q.data[rowA+i];</comment>
    <comment>double b = Q.data[rowB+i];</comment>
    <comment>Q.data[rowA+i] = c*a + s*b;</comment>
    <comment>Q.data[rowB+i] = -s*a + c*b;</comment>
    <comment>}</comment>
  </method>
  <javadoc>
    <text>Performs a similar transform on A-pI</text>
  </javadoc>
  <method type="void" name="createBulge">
    <declaration type="double" name="a11" />
    <declaration type="double" name="a22" />
    <declaration type="double" name="a12" />
    <declaration type="double" name="a23" />
    <scope />
    <scope />
    <comment>multiply the rotator on the top left.</comment>
  </method>
  <method type="void" name="createBulge2by2">
    <declaration type="double" name="a11" />
    <declaration type="double" name="a22" />
    <declaration type="double" name="a12" />
    <scope />
    <scope />
    <comment>multiply the rotator on the top left.</comment>
  </method>
  <javadoc>
    <text>Computes the rotation and stores it in (c,s)</text>
  </javadoc>
  <method type="void" name="computeRotation">
    <scope>
      <declaration type="double" name="k" />
      <declaration type="double" name="bottom" />
      <declaration type="double" name="bottom_sq" />
    </scope>
    <scope>
      <declaration type="double" name="t" />
      <declaration type="double" name="bottom" />
      <declaration type="double" name="bottom_sq" />
    </scope>
    <comment>double alpha = Math.sqrt(run*run + rise*rise);</comment>
    <comment>c = run/alpha;</comment>
    <comment>s = rise/alpha;</comment>
  </method>
  <method type="void" name="removeBulge">
    <declaration type="double" name="a22" />
    <declaration type="double" name="a33" />
    <declaration type="double" name="a12" />
    <declaration type="double" name="a23" />
    <declaration type="double" name="a34" />
    <comment>multiply the rotator on the top left.</comment>
  </method>
  <javadoc>
    <text>Rotator to remove the bulge</text>
  </javadoc>
  <method type="void" name="removeBulgeEnd">
    <declaration type="double" name="a22" />
    <declaration type="double" name="a12" />
    <declaration type="double" name="a23" />
    <declaration type="double" name="a33" />
    <comment>multiply the rotator on the top left.</comment>
  </method>
  <javadoc>
    <text>Computes the eigenvalue of the 2 by 2 matrix.</text>
  </javadoc>
  <method type="void" name="eigenvalue2by2">
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <declaration type="double" name="c" />
    <declaration type="double" name="absA" />
    <declaration type="double" name="absB" />
    <declaration type="double" name="absC" />
    <declaration type="double" name="scale" />
    <scope />
    <comment>normalize to reduce overflow</comment>
    <comment>see if it is a pathological case.  the diagonal must already be zero</comment>
    <comment>and the eigenvalues are all zero.  so just return</comment>
  </method>
  <javadoc>
    <text>Perform a shift in a random direction that is of the same magnitude as the elements in the matrix.</text>
  </javadoc>
  <method type="void" name="exceptionalShift">
    <declaration type="double" name="mag" />
    <declaration type="double" name="theta" />
    <comment>rotating by a random angle handles at least one case using a random lambda</comment>
    <comment>does not handle well:</comment>
    <comment>- two identical eigenvalues are next to each other and a very small diagonal element</comment>
  </method>
  <javadoc>
    <text>Tells it to process the submatrix at the next split.  Should be called after the
 * current submatrix has been processed.</text>
  </javadoc>
  <method type="boolean" name="nextSplit" />
  <method type="double" name="computeShift" />
  <method type="double" name="computeWilkinsonShift">
    <declaration type="double" name="a" />
    <declaration type="double" name="b" />
    <declaration type="double" name="c" />
    <declaration type="double" name="absA" />
    <declaration type="double" name="absB" />
    <declaration type="double" name="absC" />
    <declaration type="double" name="scale" />
    <scope />
    <declaration type="double" name="diff0" />
    <declaration type="double" name="diff1" />
    <comment>normalize to reduce overflow</comment>
    <comment>TODO see 385</comment>
    <comment>return the eigenvalue closest to c</comment>
  </method>
  <method type="int" name="getMatrixSize" />
  <method type="void" name="resetSteps" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>used in exceptional shifts</comment>
  <comment>how many steps has it taken</comment>
  <comment>how many exception shifts has it performed</comment>
  <comment>the step number of the last exception shift</comment>
  <comment>used to compute eigenvalues directly</comment>
  <comment>orthogonal matrix used in similar transform.  optional</comment>
  <comment>size of the matrix being processed</comment>
  <comment>diagonal elements in the matrix</comment>
  <comment>the off diagonal elements</comment>
  <comment>which submatrix is being processed</comment>
  <comment>where splits are performed</comment>
  <comment>current value of the bulge</comment>
  <comment>local helper functions</comment>
</class>
