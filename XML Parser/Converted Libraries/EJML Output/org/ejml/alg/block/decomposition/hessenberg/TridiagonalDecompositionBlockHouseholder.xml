<?xml version="1.0" encoding="UTF-8"?>
<class name="TridiagonalDecompositionBlockHouseholder">
  <javadoc>
    <text>&lt;p&gt;
 * Tridiagonal similar decomposition for block matrices.  Orthogonal matrices are computed using
 * householder vectors.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Based off algorithm in section 2 of J. J. Dongarra, D. C. Sorensen, S. J. Hammarling,
 * "Block Reduction of Matrices to Condensed Forms for Eigenvalue Computations" Journal of
 * Computations and Applied Mathematics 27 (1989) 215-227&lt;b&gt;
 * &lt;br&gt;
 * Computations of Householder reflectors has been modified from what is presented in that paper to how 
 * it is performed in "Fundamentals of Matrix Computations" 2nd ed. by David S. Watkins.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="BlockMatrix64F" name="A" />
  <declaration type="BlockMatrix64F" name="V" />
  <declaration type="BlockMatrix64F" name="tmp" />
  <declaration type="double" name="gammas" />
  <declaration type="DenseMatrix64F" name="zerosM" />
  <method type="BlockMatrix64F" name="getT">
    <scope />
    <scope />
    <scope>
      <declaration type="double" name="d" />
    </scope>
  </method>
  <method type="BlockMatrix64F" name="getQ">
    <declaration type="int" name="height" />
    <declaration type="D1Submatrix64F" name="subQ" />
    <declaration type="D1Submatrix64F" name="subU" />
    <declaration type="D1Submatrix64F" name="subW" />
    <declaration type="D1Submatrix64F" name="tmp" />
    <declaration type="int" name="N" />
    <declaration type="int" name="start" />
    <scope>
      <declaration type="int" name="blockSize" />
      <scope />
      <scope />
    </scope>
    <comment>(Q1^T * (Q2^T * (Q3^t * A)))</comment>
    <comment>zeros and ones are saved and overwritten in U so that standard matrix multiplication can be used</comment>
    <comment>compute W for Q(i) = ( I + W*Y^T)</comment>
    <comment>Apply the Qi to Q</comment>
    <comment>Qi = I + W*U^T</comment>
    <comment>Note that U and V are really row vectors.  but standard notation assumed they are column vectors.</comment>
    <comment>which is why the functions called don't match the math above</comment>
    <comment>(I + W*U^T)*Q</comment>
    <comment>F=U^T*Q(i)</comment>
    <comment>Q(i+1) = Q(i) + W*F</comment>
  </method>
  <method type="void" name="copyZeros">
    <declaration type="int" name="N" />
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>save the zeros</comment>
    <comment>save the one</comment>
  </method>
  <method type="void" name="replaceZeros">
    <declaration type="int" name="N" />
    <scope>
      <scope />
      <scope />
    </scope>
    <comment>save the zeros</comment>
    <comment>save the one</comment>
  </method>
  <method type="void" name="getDiagonal">
    <scope />
  </method>
  <method type="boolean" name="decompose">
    <declaration type="D1Submatrix64F" name="subA" />
    <declaration type="D1Submatrix64F" name="subV" />
    <declaration type="D1Submatrix64F" name="subU" />
    <declaration type="int" name="N" />
    <scope>
      <declaration type="int" name="height" />
      <scope>
        <declaration type="double" name="before" />
      </scope>
    </scope>
    <comment>System.out.println("-------- triag i "+i);</comment>
    <comment>bidiagonalize the top row</comment>
    <comment>apply Householder reflectors to the lower portion using block multiplication</comment>
    <comment>take in account the 1 in the last row.  The others are skipped over.</comment>
    <comment>A = A + U*V^T + V*U^T</comment>
  </method>
  <javadoc>
    <text>C = C + A^T*B</text>
    <param>blockLength</param>
    <param>A row block vector</param>
    <param>B row block vector</param>
    <param>C</param>
  </javadoc>
  <method type="void" name="multPlusTransA">
    <declaration type="int" name="heightA" />
    <scope>
      <declaration type="int" name="heightC" />
      <declaration type="int" name="indexA" />
      <scope>
        <declaration type="int" name="widthC" />
        <declaration type="int" name="indexC" />
        <declaration type="int" name="indexB" />
      </scope>
    </scope>
  </method>
  <method type="void" name="init">
    <declaration type="int" name="height" />
  </method>
  <method type="boolean" name="inputModified" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>matrix which is being decomposed</comment>
  <comment>householder vectors are stored along the upper triangle rows</comment>
  <comment>temporary storage for block computations</comment>
  <comment>stores intermediate results in matrix multiplication</comment>
  <comment>temporary storage for zeros and ones in U</comment>
</class>
