<?xml version="1.0" encoding="UTF-8"?>
<class name="BlockHouseHolder">
  <javadoc>
    <text>&lt;p&gt;
 * Contains various helper functions for performing a block matrix QR decomposition.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Assumptions:
 * &lt;ul&gt;
 * &lt;le&gt; All submatrices are aligned along the inner blocks of the {@link org.ejml.data.BlockMatrix64F}.
 * &lt;le&gt; Some times vectors are assumed to have leading zeros and a one.
 * &lt;/ul&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>Performs a standard QR decomposition on the specified submatrix that is one block wide.</text>
    <param>blockLength</param>
    <param>Y</param>
    <param>gamma</param>
  </javadoc>
  <method type="boolean" name="decomposeQR_block_col">
    <declaration type="int" name="width" />
    <declaration type="int" name="height" />
    <declaration type="int" name="min" />
    <scope />
    <comment>compute the householder vector</comment>
    <comment>apply to rest of the columns in the block</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the householder vector that is used to create reflector for the column.
 * The results are stored in the original matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The householder vector 'u' is computed as follows:&lt;br&gt;
 * &lt;br&gt;
 * u(1) = 1 &lt;br&gt;
 * u(i) = x(i)/(&amp;tau; + x(1))&lt;br&gt;
 * &lt;/p&gt;
 * The first element is implicitly assumed to be one and not written.</text>
    <return>If there was any problems or not. true = no problem.</return>
  </javadoc>
  <method type="boolean" name="computeHouseHolderCol">
    <declaration type="double" name="max" />
    <scope />
    <scope>
      <declaration type="double" name="tau" />
      <declaration type="double" name="u_0" />
    </scope>
    <comment>computes tau and normalizes u by max</comment>
    <comment>divide u by u_0</comment>
    <comment>after the reflector is applied the column would be all zeros but be -tau in the first element</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the householder vector from the specified row
 * &lt;/p&gt;
 * &lt;p&gt;
 * The householder vector 'u' is computed as follows:&lt;br&gt;
 * &lt;br&gt;
 * u(1) = 1 &lt;br&gt;
 * u(i) = x(i)/(&amp;tau; + x(1))&lt;br&gt;
 * &lt;/p&gt;
 * The first element is implicitly assumed to be one and not written.</text>
    <return>If there was any problems or not. true = no problem.</return>
  </javadoc>
  <method type="boolean" name="computeHouseHolderRow">
    <declaration type="double" name="max" />
    <scope />
    <scope>
      <declaration type="double" name="tau" />
      <declaration type="double" name="u_0" />
    </scope>
    <comment>computes tau and normalizes u by max</comment>
    <comment>divide u by u_0</comment>
    <comment>after the reflector is applied the column would be all zeros but be -tau in the first element</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Applies a householder reflector stored in column 'col' to the remainder of the columns
 * in the block after it.  Takes in account leading zeros and one.&lt;br&gt;
 * &lt;br&gt;
 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)*A&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>A submatrix that is at most one block wide and aligned along inner blocks</param>
    <param>col The column in A containing 'u'</param>
  </javadoc>
  <method type="void" name="rank1UpdateMultR_Col">
    <declaration type="int" name="width" />
    <declaration type="double[]" name="dataA" />
    <scope>
      <declaration type="double" name="total" />
      <scope>
        <declaration type="int" name="height" />
        <declaration type="int" name="indexU" />
        <declaration type="int" name="indexA" />
        <scope>
          <scope />
        </scope>
        <scope>
          <declaration type="int" name="endU" />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>total = U^T * A(:,j)</comment>
    <comment>A(:,j) - gamma*U*total</comment>
    <comment>for( int k = 0; k &lt; height; k++</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Applies a householder reflector stored in column 'col' to the top block row (excluding
 * the first column) of A.  Takes in account leading zeros and one.&lt;br&gt;
 * &lt;br&gt;
 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)*A&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>A submatrix that is at most one block wide and aligned along inner blocks</param>
    <param>col The column in A containing 'u'</param>
  </javadoc>
  <method type="void" name="rank1UpdateMultR_TopRow">
    <declaration type="double[]" name="dataA" />
    <declaration type="int" name="widthCol" />
    <scope>
      <declaration type="int" name="widthJ" />
      <scope>
        <declaration type="double" name="total" />
        <declaration type="int" name="i" />
        <declaration type="int" name="height" />
        <declaration type="int" name="indexU" />
        <declaration type="int" name="indexA" />
        <scope />
      </scope>
    </scope>
    <comment>step through columns in top block, skipping over the first block</comment>
    <comment>total = U^T * A(:,j) * gamma</comment>
    <comment>A(:,j) - gamma*U*total</comment>
    <comment>just update the top most block</comment>
    <comment>take in account zeros and one</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Applies a householder reflector stored in row 'row' to the remainder of the row
 * in the block after it.  Takes in account leading zeros and one.&lt;br&gt;
 * &lt;br&gt;
 * A = A*(I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>A submatrix that is block aligned</param>
    <param>row The row in A containing 'u'</param>
    <param>colStart First index in 'u' that the reflector starts at</param>
  </javadoc>
  <method type="void" name="rank1UpdateMultL_Row">
    <declaration type="int" name="height" />
    <declaration type="double[]" name="dataA" />
    <declaration type="int" name="zeroOffset" />
    <scope>
      <declaration type="double" name="total" />
      <scope>
        <declaration type="int" name="width" />
        <declaration type="int" name="indexU" />
        <declaration type="int" name="indexA" />
        <scope>
          <scope />
        </scope>
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>total = U^T * A(i,:)</comment>
    <comment>A(i,:) - gamma*U*total</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Applies a householder reflector stored in row 'row' to the left column block.
 * Takes in account leading zeros and one.&lt;br&gt;
 * &lt;br&gt;
 * A = A*(I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>A submatrix that is block aligned</param>
    <param>row The row in A containing 'u'</param>
    <param>zeroOffset How far off the diagonal is the first element in 'u'</param>
  </javadoc>
  <method type="void" name="rank1UpdateMultL_LeftCol">
    <declaration type="int" name="heightU" />
    <declaration type="int" name="width" />
    <declaration type="double[]" name="data" />
    <scope>
      <declaration type="int" name="heightA" />
      <scope>
        <declaration type="double" name="total" />
        <declaration type="int" name="indexU" />
        <declaration type="int" name="indexA" />
        <scope />
      </scope>
    </scope>
    <comment>total = U^T * A(i,:)</comment>
    <comment>A(i,:) - gamma*U*total</comment>
    <comment>plusScale_row(blockLength,);</comment>
    <comment>skip over zeros and assume first element in U is 1</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the inner product of column vector 'colA' against column vector 'colB' while taking account leading zeros and one.&lt;br&gt;
 * &lt;br&gt;
 * ret = a&lt;sup&gt;T*b
 * &lt;/p&gt;
 * &lt;p&gt;
 * Column A is assumed to be a householder vector.  Element at 'colA' is one and previous ones are zero.
 * &lt;/p&gt;</text>
    <param>blockLength</param>
    <param>A block aligned submatrix.</param>
    <param>colA Column inside the block of first column vector.</param>
    <param>widthA how wide the column block that colA is inside of.</param>
    <param>colB Column inside the block of second column vector.</param>
    <param>widthB how wide the column block that colB is inside of.</param>
    <return>dot product of the two vectors.</return>
  </javadoc>
  <method type="double" name="innerProdCol">
    <declaration type="double" name="total" />
    <declaration type="double[]" name="data" />
    <declaration type="int" name="colBlockA" />
    <declaration type="int" name="colBlockB" />
    <scope>
      <declaration type="int" name="height" />
      <declaration type="int" name="indexA" />
      <declaration type="int" name="indexB" />
      <scope>
        <declaration type="int" name="endA" />
        <scope />
      </scope>
      <scope>
        <declaration type="int" name="endA" />
        <scope />
      </scope>
    </scope>
    <comment>first column in the blocks</comment>
    <comment>compute dot product down column vectors</comment>
    <comment>handle leading zeros</comment>
    <comment>handle leading one</comment>
    <comment>standard vector dot product</comment>
    <comment>for( int k = col+1; k &lt; height; k++ , indexU += width, indexA += width ) {</comment>
    <comment>standard vector dot product</comment>
    <comment>for( int k = 0; k &lt; height; k++ ) {</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the inner product of row vector 'rowA' against row vector 'rowB' while taking account leading zeros and one.&lt;br&gt;
 * &lt;br&gt;
 * ret = a&lt;sup&gt;T&lt;/sup&gt;*b
 * &lt;/p&gt;
 * &lt;p&gt;
 * Row A is assumed to be a householder vector.  Element at 'colStartA' is one and previous elements are zero.
 * &lt;/p&gt;</text>
    <param>blockLength</param>
    <param>A block aligned submatrix.</param>
    <param>rowA Row index inside the sub-matrix of first row vector has zeros and ones..</param>
    <param>rowB Row index inside the sub-matrix of second row vector.</param>
    <return>dot product of the two vectors.</return>
  </javadoc>
  <method type="double" name="innerProdRow">
    <declaration type="int" name="offset" />
    <declaration type="double" name="total" />
    <comment>take in account the one in 'A'</comment>
  </method>
  <method type="void" name="add_row">
    <declaration type="int" name="offset" />
    <comment>handle leading one</comment>
  </method>
  <javadoc>
    <text>Divides the elements at the specified column by 'val'.  Takes in account
 * leading zeros and one.</text>
  </javadoc>
  <method type="void" name="divideElementsCol">
    <declaration type="int" name="width" />
    <declaration type="double[]" name="dataY" />
    <scope>
      <declaration type="int" name="height" />
      <declaration type="int" name="index" />
      <scope>
        <scope />
      </scope>
      <scope>
        <declaration type="int" name="endIndex" />
        <scope />
      </scope>
    </scope>
    <comment>for( int k = 0; k &lt; height; k++</comment>
  </method>
  <javadoc>
    <text>Scales the elements in the specified row starting at element colStart by 'val'.&lt;br&gt;
 * W = val*Y
 * Takes in account zeros and leading one automatically.</text>
    <param>zeroOffset How far off the diagonal is the first element in the vector.</param>
  </javadoc>
  <method type="void" name="scale_row">
    <declaration type="int" name="offset" />
    <comment>handle the one</comment>
    <comment>scale rest of the vector</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * From the specified column of Y tau is computed and each element is divided by 'max'.
 * See code below:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * for i=col:Y.numRows
 * Y[i][col] = u[i][col] / max
 * tau = tau + u[i][col]*u[i][col]
 * end
 * tau = sqrt(tau)
 * if( Y[col][col] &lt; 0 )
 * tau = -tau;
 * &lt;/pre&gt;</text>
  </javadoc>
  <method type="double" name="computeTauAndDivideCol">
    <declaration type="int" name="width" />
    <declaration type="double[]" name="dataY" />
    <declaration type="double" name="top" />
    <declaration type="double" name="norm2" />
    <scope>
      <declaration type="int" name="height" />
      <declaration type="int" name="index" />
      <scope>
        <scope>
          <declaration type="double" name="val" />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="val" />
        </scope>
      </scope>
    </scope>
    <comment>save this value so that the sign can be determined later on</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * From the specified row of Y tau is computed and each element is divided by 'max'.
 * See code below:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * for j=row:Y.numCols
 * Y[row][j] = u[row][j] / max
 * tau = tau + u[row][j]*u[row][j]
 * end
 * tau = sqrt(tau)
 * if( Y[row][row] &lt; 0 )
 * tau = -tau;
 * &lt;/pre&gt;</text>
    <param>row Which row in the block will be processed</param>
    <param>colStart The first column that computation of tau will start at</param>
    <param>max used to normalize and prevent buffer over flow</param>
  </javadoc>
  <method type="double" name="computeTauAndDivideRow">
    <declaration type="int" name="height" />
    <declaration type="double[]" name="dataY" />
    <declaration type="double" name="top" />
    <declaration type="double" name="norm2" />
    <declaration type="int" name="startJ" />
    <scope>
      <declaration type="int" name="width" />
      <declaration type="int" name="index" />
      <scope>
        <scope>
          <declaration type="double" name="val" />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="val" />
        </scope>
      </scope>
    </scope>
    <comment>save this value so that the sign can be determined later on</comment>
  </method>
  <javadoc>
    <text>Finds the element in the column with the largest absolute value. The offset
 * from zero is automatically taken in account based on the column.</text>
  </javadoc>
  <method type="double" name="findMaxCol">
    <declaration type="int" name="width" />
    <declaration type="double[]" name="dataY" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="int" name="height" />
      <declaration type="int" name="index" />
      <scope>
        <scope>
          <declaration type="double" name="v" />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="v" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Finds the element in the column with the largest absolute value. The offset
 * from zero is automatically taken in account based on the column.</text>
  </javadoc>
  <method type="double" name="findMaxRow">
    <declaration type="int" name="height" />
    <declaration type="double[]" name="dataY" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="int" name="width" />
      <declaration type="int" name="index" />
      <scope>
        <scope>
          <declaration type="double" name="v" />
          <scope />
        </scope>
      </scope>
      <scope>
        <scope>
          <declaration type="double" name="v" />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes W from the householder reflectors stored in the columns of the column block
 * submatrix Y.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Y = v&lt;sup&gt;(1)&lt;/sup&gt;&lt;br&gt;
 * W = -&amp;beta;&lt;sub&gt;1&lt;/sub&gt;v&lt;sup&gt;(1)&lt;/sup&gt;&lt;br&gt;
 * for j=2:r&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;z = -&amp;beta;(I +WY&lt;sup&gt;T&lt;/sup&gt;)v&lt;sup&gt;(j)&lt;/sup&gt; &lt;br&gt;
 * &amp;nbsp;&amp;nbsp;W = [W z]&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;Y = [Y v&lt;sup&gt;(j)&lt;/sup&gt;]&lt;br&gt;
 * end&lt;br&gt;
 * &lt;br&gt;
 * where v&lt;sup&gt;(.)&lt;/sup&gt; are the house holder vectors, and r is the block length.  Note that
 * Y already contains the householder vectors so it does not need to be modified.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Y and W are assumed to have the same number of rows and columns.
 * &lt;/p&gt;</text>
    <param>Y Input matrix containing householder vectors.  Not modified.</param>
    <param>W Resulting W matrix. Modified.</param>
    <param>temp Used internally.  Must have W.numCols elements.</param>
    <param>beta Beta's for householder vectors.</param>
    <param>betaIndex Index of first relevant beta.</param>
  </javadoc>
  <method type="void" name="computeW_Column">
    <declaration type="int" name="widthB" />
    <declaration type="int" name="min" />
    <scope />
    <comment>set the first column in W</comment>
    <comment>set up rest of the columns</comment>
    <comment>compute the z vector and insert it into W</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Sets W to its initial value using the first column of 'y' and the value of 'b':
 * &lt;br&gt;
 * W = -&amp;beta;v&lt;br&gt;
 * &lt;br&gt;
 * where v = Y(:,0).
 * &lt;/p&gt;</text>
    <param>blockLength size of the inner block</param>
    <param>W Submatrix being initialized.</param>
    <param>Y Contains householder vector</param>
    <param>widthB How wide the W block matrix is.</param>
    <param>b beta</param>
  </javadoc>
  <method type="void" name="initializeW">
    <declaration type="double[]" name="dataW" />
    <declaration type="double[]" name="dataY" />
    <scope>
      <declaration type="int" name="heightW" />
      <declaration type="int" name="indexW" />
      <declaration type="int" name="indexY" />
      <scope>
        <scope />
      </scope>
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>take in account the first element in V being 1</comment>
  </method>
  <javadoc>
    <text>Computes the vector z and inserts it into 'W':&lt;br&gt;
 * &lt;br&gt;
 * z = - &amp;beta;&lt;sub&gt;j&lt;/sub&gt;*(V&lt;sup&gt;j&lt;/sup&gt; + W*h)&lt;br&gt;
 * &lt;br&gt;
 * where h is a vector of length 'col' and was computed using {@link #computeY_t_V}.
 * V is a column in the Y matrix. Z is a column in the W matrix.  Both Z and V are
 * column 'col'.</text>
  </javadoc>
  <method type="void" name="computeZ">
    <declaration type="int" name="width" />
    <declaration type="double[]" name="dataW" />
    <declaration type="double[]" name="dataY" />
    <declaration type="int" name="colsW" />
    <declaration type="double" name="beta_neg" />
    <scope>
      <declaration type="int" name="heightW" />
      <declaration type="int" name="indexW" />
      <declaration type="int" name="indexZ" />
      <declaration type="int" name="indexV" />
      <scope>
        <scope>
          <declaration type="double" name="total" />
          <scope />
          <scope />
          <scope />
          <scope />
        </scope>
      </scope>
      <scope>
        <declaration type="int" name="endZ" />
        <scope>
          <declaration type="double" name="total" />
          <scope />
        </scope>
      </scope>
    </scope>
    <comment>handle the triangular portion with the leading zeros and the one</comment>
    <comment>compute the rows of W * h</comment>
    <comment>add the two vectors together and multiply by -beta</comment>
    <comment>zeros</comment>
    <comment>one</comment>
    <comment>normal data</comment>
    <comment>for( int k = 0; k &lt; heightW; k++ ,</comment>
    <comment>compute the rows of W * h</comment>
    <comment>add the two vectors together and multiply by -beta</comment>
  </method>
  <javadoc>
    <text>Computes Y&lt;sup&gt;T&lt;/sup&gt;v&lt;sup&gt;(j)&lt;/sup&gt;.  Where Y are the columns before 'col' and v is the column
 * at 'col'.  The zeros and ones are taken in account.  The solution is a vector with 'col' elements.
 * width of Y must be along the block of original matrix A</text>
    <param>temp Temporary storage of least length 'col'</param>
  </javadoc>
  <method type="void" name="computeY_t_V">
    <declaration type="int" name="widthB" />
    <scope />
  </method>
  <javadoc>
    <text>Special multiplication that takes in account the zeros and one in Y, which
 * is the matrix that stores the householder vectors.</text>
  </javadoc>
  <method type="void" name="multAdd_zeros">
    <declaration type="int" name="widthY" />
    <scope>
      <declaration type="int" name="heightY" />
      <scope>
        <declaration type="int" name="widthB" />
        <declaration type="int" name="indexC" />
        <scope>
          <declaration type="int" name="indexY" />
          <declaration type="int" name="indexB" />
          <scope />
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Inner block mult add operation that takes in account the zeros and on in dataA,
 * which is the top part of the Y block vector that has the householder vectors.&lt;br&gt;
 * &lt;br&gt;
 * C = C + A * B
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="multBlockAdd_zerosone">
    <scope>
      <scope>
        <declaration type="double" name="val" />
        <declaration type="int" name="end" />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix multiplication on the block aligned submatrices.  A is
 * assumed to be block column vector that is lower triangular with diagonal elements set to 1.&lt;br&gt;
 * &lt;br&gt;
 * C = A^T * B
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="multTransA_vecCol">
    <declaration type="int" name="widthA" />
    <scope>
      <declaration type="int" name="widthB" />
      <declaration type="int" name="indexC" />
      <scope>
        <declaration type="int" name="heightA" />
        <declaration type="int" name="indexA" />
        <declaration type="int" name="indexB" />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>Performs a matrix multiplication on an single inner block where A is assumed to be lower triangular with diagonal
 * elements equal to 1.&lt;br&gt;
 * &lt;br&gt;
 * C = A^T * B</text>
  </javadoc>
  <method type="void" name="multTransABlockSet_lowerTriag">
    <scope>
      <scope>
        <declaration type="double" name="val" />
        <scope />
      </scope>
    </scope>
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
