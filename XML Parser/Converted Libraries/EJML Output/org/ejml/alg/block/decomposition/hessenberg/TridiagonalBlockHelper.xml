<?xml version="1.0" encoding="UTF-8"?>
<class name="TridiagonalBlockHelper">
  <javadoc>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a tridiagonal decomposition on the upper row only.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For each row 'a' in 'A':
 * Compute 'u' the householder reflector.
 * y(:) = A*u
 * v(i) = y - (1/2)*(y^T*u)*u
 * a(i+1) = a(i) - u*&amp;gamma;*v^T - v*u^t
 * &lt;/p&gt;</text>
    <param>blockLength Size of a block</param>
    <param>A is the row block being decomposed.  Modified.</param>
    <param>gammas Householder gammas.</param>
    <param>V Where computed 'v' are stored in a row block.  Modified.</param>
  </javadoc>
  <method type="void" name="tridiagUpperRow">
    <declaration type="int" name="blockHeight" />
    <declaration type="int" name="width" />
    <declaration type="int" name="num" />
    <declaration type="int" name="applyIndex" />
    <scope>
      <declaration type="double" name="gamma" />
      <scope />
    </scope>
    <comment>step through rows in the block</comment>
    <comment>compute the new reflector and save it in a row in 'A'</comment>
    <comment>compute y</comment>
    <comment>compute v from y</comment>
    <comment>Apply the reflectors to the next row in 'A' only</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes W from the householder reflectors stored in the columns of the row block
 * submatrix Y.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Y = v&lt;sup&gt;(1)&lt;/sup&gt;&lt;br&gt;
 * W = -&amp;beta;&lt;sub&gt;1&lt;/sub&gt;v&lt;sup&gt;(1)&lt;/sup&gt;&lt;br&gt;
 * for j=2:r&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;z = -&amp;beta;(I +WY&lt;sup&gt;T&lt;/sup&gt;)v&lt;sup&gt;(j)&lt;/sup&gt; &lt;br&gt;
 * &amp;nbsp;&amp;nbsp;W = [W z]&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;Y = [Y v&lt;sup&gt;(j)&lt;/sup&gt;]&lt;br&gt;
 * end&lt;br&gt;
 * &lt;br&gt;
 * where v&lt;sup&gt;(.)&lt;/sup&gt; are the house holder vectors, and r is the block length.  Note that
 * Y already contains the householder vectors so it does not need to be modified.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Y and W are assumed to have the same number of rows and columns.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="computeW_row">
    <declaration type="int" name="heightY" />
    <declaration type="int" name="min" />
    <scope>
      <declaration type="double" name="b" />
      <scope>
        <declaration type="double" name="yv" />
      </scope>
    </scope>
    <comment>W = -beta*v(1)</comment>
    <comment>set up rest of the rows</comment>
    <comment>w=-beta*(I + W*Y^T)*u</comment>
    <comment>w = w -beta*W*(Y^T*u)</comment>
    <comment>w=w -beta*u + stuff above</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Given an already computed tridiagonal decomposition, compute the V row block vector.&lt;br&gt;
 * &lt;br&gt;
 * y(:) = A*u&lt;br&gt;
 * v(i) = y - (1/2)*&amp;gamma;*(y^T*u)*u
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="computeV_blockVector">
    <declaration type="int" name="blockHeight" />
    <declaration type="int" name="width" />
    <declaration type="int" name="num" />
    <scope>
      <declaration type="double" name="gamma" />
    </scope>
    <comment>compute y</comment>
    <comment>compute v from y</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Applies the reflectors that have been computed previously to the specified row.
 * &lt;br&gt;
 * A = A + u*v^T + v*u^T only along the specified row in A.
 * &lt;/p&gt;</text>
    <param>blockLength</param>
    <param>A Contains the reflectors and the row being updated.</param>
    <param>V Contains previously computed 'v' vectors.</param>
    <param>row The row of 'A' that is to be updated.</param>
  </javadoc>
  <method type="void" name="applyReflectorsToRow">
    <declaration type="int" name="height" />
    <declaration type="double[]" name="dataA" />
    <declaration type="double[]" name="dataV" />
    <declaration type="int" name="indexU" />
    <scope>
      <declaration type="int" name="width" />
      <declaration type="double" name="u_row" />
      <declaration type="double" name="v_row" />
      <declaration type="double" name="before" />
    </scope>
    <comment>for each previously computed reflector</comment>
    <comment>take in account the leading one</comment>
    <comment>grab only the relevant row from A = A + u*v^T + v*u^T</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the 'y' vector and stores the result in 'v'&lt;br&gt;
 * &lt;br&gt;
 * y = -&amp;gamma;(A + U*V^T + V*U^T)u
 * &lt;/p&gt;</text>
    <param>blockLength</param>
    <param>A Contains the reflectors and the row being updated.</param>
    <param>V Contains previously computed 'v' vectors.</param>
    <param>row The row of 'A' that is to be updated.</param>
  </javadoc>
  <method type="void" name="computeY">
    <scope>
      <declaration type="double" name="dot_v_u" />
      <declaration type="double" name="dot_u_u" />
    </scope>
    <comment>Elements in 'y' before 'row' are known to be zero and the element at 'row'</comment>
    <comment>is not used. Thus only elements after row and after are computed.</comment>
    <comment>y = A*u</comment>
    <comment>y = y + u_i*v_i^t*u + v_i*u_i^t*u</comment>
    <comment>v_i^t*u</comment>
    <comment>u_i^t*u</comment>
    <comment>y = y + u_i*(v_i^t*u)</comment>
    <comment>the ones in these 'u' are skipped over since the next submatrix of A</comment>
    <comment>is only updated</comment>
    <comment>y = y + v_i*(u_i^t*u)</comment>
    <comment>the 1 in U is taken account above</comment>
    <comment>y = -gamma*y</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Multiples the appropriate submatrix of A by the specified reflector and stores
 * the result ('y') in V.&lt;br&gt;
 * &lt;br&gt;
 * y = A*u&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>blockLength</param>
    <param>A Contains the 'A' matrix and 'u' vector.</param>
    <param>V Where resulting 'y' row vectors are stored.</param>
    <param>row row in matrix 'A' that 'u' vector and the row in 'V' that 'y' is stored in.</param>
  </javadoc>
  <method type="void" name="multA_u">
    <declaration type="int" name="heightMatA" />
    <scope>
      <declaration type="double" name="val" />
    </scope>
  </method>
  <method type="double" name="innerProdRowSymm">
    <declaration type="int" name="offset" />
    <scope>
      <declaration type="double" name="total" />
    </scope>
    <scope>
      <declaration type="double" name="total" />
    </scope>
    <comment>take in account the one in 'A'</comment>
    <comment>take in account the one in 'A'</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Final computation for a single row of 'v':&lt;br&gt;
 * &lt;br&gt;
 * v = y -(1/2)&amp;gamma;(y^T*u)*u
 * &lt;/p&gt;</text>
    <param>blockLength</param>
    <param>A</param>
    <param>V</param>
    <param>row</param>
    <param>gamma</param>
  </javadoc>
  <method type="void" name="computeRowOfV">
    <declaration type="double" name="val" />
    <declaration type="double" name="before" />
    <comment>val=(y^T*u)</comment>
    <comment>take in account the one</comment>
    <comment>v = y - (1/2)gamma*val * u</comment>
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
