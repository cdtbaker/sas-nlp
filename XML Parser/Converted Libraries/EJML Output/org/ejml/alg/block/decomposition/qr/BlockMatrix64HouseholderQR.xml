<?xml version="1.0" encoding="UTF-8"?>
<class name="BlockMatrix64HouseholderQR">
  <javadoc>
    <text>&lt;p&gt;
 * QR decomposition for {@link BlockMatrix64F} using householder reflectors.  The decomposition is
 * performed by computing a QR decomposition for each block column as is normally done, see {@link org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholder}.
 * The reflectors are then combined and applied to the remainder of the matrix.  This process is repeated
 * until all the block columns have been processed
 * &lt;/p&gt;
 * &lt;p&gt;
 * The input matrix is modified and used to store the decomposition.  Reflectors are stored in the lower triangle
 * columns.  The first element of the reflector is implicitly assumed to be one.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Each iteration can be sketched as follows:
 * &lt;pre&gt;
 * QR_Decomposition( A(:,i-r to i) )
 * W=computeW( A(:,i-r to i) )
 * A(:,i:n) = (I + W*Y&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A(:,i:n)
 * &lt;/pre&gt;
 * Where r is the block size, i is the submatrix being considered, A is the input matrix,
 * Y is a matrix containing the reflectors just computed,
 * and W is computed using {@link BlockHouseHolder#computeW_Column}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Based upon "Block Householder QR Factorization" pg 255 in "Matrix Computations"
 * 3rd Ed. 1996 by Gene H. Golub and Charles F. Van Loan.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <declaration type="BlockMatrix64F" name="dataA" />
  <declaration type="BlockMatrix64F" name="dataW" />
  <declaration type="BlockMatrix64F" name="dataWTA" />
  <declaration type="int" name="blockLength" />
  <declaration type="D1Submatrix64F" name="A" />
  <declaration type="D1Submatrix64F" name="Y" />
  <declaration type="D1Submatrix64F" name="W" />
  <declaration type="D1Submatrix64F" name="WTA" />
  <declaration type="double" name="temp" />
  <declaration type="double" name="gammas" />
  <declaration type="boolean" name="saveW" />
  <javadoc>
    <text>This is the input matrix after it has been overwritten with the decomposition.</text>
    <return>Internal matrix used to store decomposition.</return>
  </javadoc>
  <method type="BlockMatrix64F" name="getQR" />
  <javadoc>
    <text>&lt;p&gt;
 * Sets if it should internally save the W matrix before performing the decomposition.  Must
 * be set before decomposition the matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Saving W can result in about a 5% savings when solving systems around a height of 5k.  The
 * price is that it needs to save a matrix the size of the input matrix.
 * &lt;/p&gt;</text>
    <param>saveW If the W matrix should be saved or not.</param>
  </javadoc>
  <method type="void" name="setSaveW" />
  <javadoc>
    <inheritDoc />
  </javadoc>
  <method type="BlockMatrix64F" name="getQ" />
  <javadoc>
    <text>Sanity checks the input or declares a new matrix.  Return matrix is an identity matrix.</text>
  </javadoc>
  <method type="BlockMatrix64F" name="initializeQ">
    <declaration type="int" name="minLength" />
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
    <scope>
      <scope />
      <scope>
        <scope />
        <scope />
      </scope>
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Multiplies the provided matrix by Q using householder reflectors.  This is more
 * efficient that computing Q then applying it to the matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * B = Q * B
 * &lt;/p&gt;</text>
    <param>B Matrix which Q is applied to.  Modified.</param>
  </javadoc>
  <method type="void" name="applyQ" />
  <javadoc>
    <text>Specialized version of applyQ() that allows the zeros in an identity matrix
 * to be taken advantage of depending on if isIdentity is true or not.</text>
    <param>B</param>
    <param>isIdentity If B is an identity matrix.</param>
  </javadoc>
  <method type="void" name="applyQ">
    <declaration type="int" name="minDimen" />
    <declaration type="D1Submatrix64F" name="subB" />
    <declaration type="int" name="start" />
    <scope />
    <comment>(Q1^T * (Q2^T * (Q3^t * A)))</comment>
    <comment>Compute W matrix from reflectors stored in Y</comment>
    <comment>Apply the Qi to Q</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Multiplies the provided matrix by Q&lt;sup&gt;T&lt;/sup&gt; using householder reflectors.  This is more
 * efficient that computing Q then applying it to the matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Q = Q*(I - &amp;gamma; W*Y^T)&lt;br&gt;
 * QR = A =&gt; R = Q^T*A  = (Q3^T * (Q2^T * (Q1^t * A)))
 * &lt;/p&gt;</text>
    <param>B Matrix which Q is applied to.  Modified.</param>
  </javadoc>
  <method type="void" name="applyQTran">
    <declaration type="int" name="minDimen" />
    <declaration type="D1Submatrix64F" name="subB" />
    <scope />
    <comment>(Q3^T * (Q2^T * (Q1^t * A)))</comment>
    <comment>subB.row1 = B.numRows;</comment>
    <comment>subB.col0 = 0;</comment>
    <comment>subB.col1 = B.numCols;</comment>
    <comment>W.original.reshape(W.row1,W.col1,false);</comment>
    <comment>Compute W matrix from reflectors stored in Y</comment>
    <comment>Apply the Qi to Q</comment>
  </method>
  <javadoc>
    <inheritDoc />
  </javadoc>
  <method type="BlockMatrix64F" name="getR">
    <declaration type="int" name="min" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope>
        <scope />
      </scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <inheritDoc />
  </javadoc>
  <method type="boolean" name="decompose">
    <declaration type="int" name="m" />
    <scope>
      <scope />
    </scope>
    <comment>process the matrix one column block at a time and overwrite the input matrix</comment>
    <comment>compute the QR decomposition of the left most block column</comment>
    <comment>this overwrites the original input matrix</comment>
    <comment>Update the remainder of the matrix using the reflectors just computed</comment>
  </method>
  <javadoc>
    <text>Adjust submatrices and helper data structures for the input matrix.  Must be called
 * before the decomposition can be computed.</text>
    <param>orig</param>
  </javadoc>
  <method type="void" name="setup">
    <declaration type="int" name="l" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * A = (I + W Y&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A&lt;BR&gt;
 * A = A + Y (W&lt;sup&gt;T&lt;/sup&gt;A)&lt;BR&gt;
 * &lt;br&gt;
 * where A is a submatrix of the input matrix.
 * &lt;/p&gt;</text>
  </javadoc>
  <method type="void" name="updateA">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Sets the submatrix of W up give Y is already configured and if it is being cached or not.</text>
  </javadoc>
  <method type="void" name="setW">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>The input matrix is always modified.</text>
    <return>Returns true since the input matrix is modified.</return>
  </javadoc>
  <method type="boolean" name="inputModified" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>the input matrix which is overwritten with the decomposition.</comment>
  <comment>Reflectors are stored in the lower triangular portion. The R matrix is stored</comment>
  <comment>in the upper triangle portion</comment>
  <comment>where the computed W matrix is stored</comment>
  <comment>Matrix used to store an intermediate calculation</comment>
  <comment>size of the inner matrix block.</comment>
  <comment>The submatrices which are being manipulated in each iteration</comment>
  <comment>stores the computed gammas</comment>
  <comment>save the W matrix the first time it is computed in the decomposition</comment>
</class>
