<?xml version="1.0" encoding="UTF-8"?>
<class name="SimpleBase">
  <javadoc>
    <text>Parent of {@link SimpleMatrix} implements all the standard matrix operations and uses
 * generics to allow the returned matrix type to be changed.  This class should be extended
 * instead of SimpleMatrix.</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>Internal matrix which this is a wrapper around.</text>
  </javadoc>
  <declaration type="DenseMatrix64F" name="mat" />
  <method type="constructor" name="SimpleBase" />
  <method type="constructor" name="SimpleBase" />
  <method name="createMatrix" type="T" />
  <javadoc>
    <text>Used internally for creating new instances of SimpleMatrix.  If SimpleMatrix is extended
 * by another class this function should be overridden so that the returned matrices are
 * of the correct type.</text>
    <param>numRows number of rows in the new matrix.</param>
    <param>numCols number of columns in the new matrix.</param>
    <return>A new matrix.</return>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * Returns a reference to the matrix that it uses internally.  This is useful
 * when an operation is needed that is not provided by this class.
 * &lt;/p&gt;</text>
    <return>Reference to the internal DenseMatrix64F.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="getMatrix" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns the transpose of this matrix.&lt;br&gt;
 * a&lt;sup&gt;T&lt;/sup&gt;
 * &lt;/p&gt;</text>
    <see>org.ejml.ops.CommonOps#transpose(DenseMatrix64F,DenseMatrix64F)</see>
    <return>A matrix that is n by m.</return>
  </javadoc>
  <method type="T" name="transpose">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns a matrix which is the result of matrix multiplication:&lt;br&gt;
 * &lt;br&gt;
 * c = a * b &lt;br&gt;
 * &lt;br&gt;
 * where c is the returned matrix, a is this matrix, and b is the passed in matrix.
 * &lt;/p&gt;</text>
    <see>CommonOps#mult(org.ejml.data.RowD1Matrix64F,org.ejml.data.RowD1Matrix64F,org.ejml.data.RowD1Matrix64F)</see>
    <param>b A matrix that is n by bn. Not modified.</param>
    <return>The results of this operation.</return>
  </javadoc>
  <method type="T" name="mult">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the Kronecker product between this matrix and the provided B matrix:&lt;br&gt;
 * &lt;br&gt;
 * C = kron(A,B)
 * &lt;/p&gt;</text>
    <see>CommonOps#kron(DenseMatrix64F,DenseMatrix64F,DenseMatrix64F)</see>
    <param>B The right matrix in the operation. Not modified.</param>
    <return>Kronecker product between this matrix and B.</return>
  </javadoc>
  <method type="T" name="kron">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the result of matrix addition:&lt;br&gt;
 * &lt;br&gt;
 * c = a + b &lt;br&gt;
 * &lt;br&gt;
 * where c is the returned matrix, a is this matrix, and b is the passed in matrix.
 * &lt;/p&gt;</text>
    <see>CommonOps#mult(org.ejml.data.RowD1Matrix64F,org.ejml.data.RowD1Matrix64F,org.ejml.data.RowD1Matrix64F)</see>
    <param>b m by n matrix. Not modified.</param>
    <return>The results of this operation.</return>
  </javadoc>
  <method type="T" name="plus">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the result of matrix subtraction:&lt;br&gt;
 * &lt;br&gt;
 * c = a - b &lt;br&gt;
 * &lt;br&gt;
 * where c is the returned matrix, a is this matrix, and b is the passed in matrix.
 * &lt;/p&gt;</text>
    <see>CommonOps#sub(org.ejml.data.D1Matrix64F,org.ejml.data.D1Matrix64F,org.ejml.data.D1Matrix64F)</see>
    <param>b m by n matrix. Not modified.</param>
    <return>The results of this operation.</return>
  </javadoc>
  <method type="T" name="minus">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix addition and scale operation.&lt;br&gt;
 * &lt;br&gt;
 * c = a + &amp;beta;*b &lt;br&gt;
 * &lt;br&gt;
 * where c is the returned matrix, a is this matrix, and b is the passed in matrix.
 * &lt;/p&gt;</text>
    <see>CommonOps#add(org.ejml.data.D1Matrix64F,double,org.ejml.data.D1Matrix64F,org.ejml.data.D1Matrix64F)</see>
    <param>b m by n matrix. Not modified.</param>
    <return>A matrix that contains the results.</return>
  </javadoc>
  <method type="T" name="plus">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>Computes the dot product (a.k.a. inner product) between this vector and vector 'v'.</text>
    <param>v The second vector in the dot product.  Not modified.</param>
    <return>dot product</return>
  </javadoc>
  <method type="double" name="dot">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Returns true if this matrix is a vector.  A vector is defined as a matrix
 * that has either one row or column.</text>
    <return>Returns true for vectors and false otherwise.</return>
  </javadoc>
  <method type="boolean" name="isVector" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns the result of scaling each element by 'val':&lt;br&gt;
 * b&lt;sub&gt;i,j&lt;/sub&gt; = val*a&lt;sub&gt;i,j&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <see>CommonOps#scale(double,org.ejml.data.D1Matrix64F)</see>
    <param>val The multiplication factor.</param>
    <return>The scaled matrix.</return>
  </javadoc>
  <method type="T" name="scale">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the result of dividing each element by 'val':
 * b&lt;sub&gt;i,j&lt;/sub&gt; = a&lt;sub&gt;i,j&lt;/sub&gt;/val
 * &lt;/p&gt;</text>
    <see>CommonOps#divide(double,org.ejml.data.D1Matrix64F)</see>
    <param>val Divisor.</param>
    <return>Matrix with its elements divided by the specified value.</return>
  </javadoc>
  <method type="T" name="divide">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the inverse of this matrix.&lt;br&gt;
 * &lt;br&gt;
 * b = a&lt;sup&gt;-1&lt;sup&gt;&lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the matrix could not be inverted then SingularMatrixException is thrown.  Even
 * if no exception is thrown the matrix could still be singular or nearly singular.
 * &lt;/p&gt;</text>
    <see>CommonOps#invert(DenseMatrix64F,DenseMatrix64F)</see>
    <throws>org.ejml.factory.SingularMatrixException</throws>
    <return>The inverse of this matrix.</return>
  </javadoc>
  <method type="T" name="invert">
    <declaration type="T" name="ret" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the Moore-Penrose pseudo-inverse
 * &lt;/p&gt;</text>
    <return>inverse computed using the pseudo inverse.</return>
  </javadoc>
  <method type="T" name="pseudoInverse">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Solves for X in the following equation:&lt;br&gt;
 * &lt;br&gt;
 * x = a&lt;sup&gt;-1&lt;/sup&gt;b&lt;br&gt;
 * &lt;br&gt;
 * where 'a' is this matrix and 'b' is an n by p matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the system could not be solved then SingularMatrixException is thrown.  Even
 * if no exception is thrown 'a' could still be singular or nearly singular.
 * &lt;/p&gt;</text>
    <see>CommonOps#solve(DenseMatrix64F,DenseMatrix64F,DenseMatrix64F)</see>
    <throws>SingularMatrixException</throws>
    <param>b n by p matrix. Not modified.</param>
    <return>The solution for 'x' that is n by p.</return>
  </javadoc>
  <method type="T" name="solve">
    <declaration type="T" name="x" />
  </method>
  <javadoc>
    <text>Sets the elements in this matrix to be equal to the elements in the passed in matrix.
 * Both matrix must have the same dimension.</text>
    <param>a The matrix whose value this matrix is being set to.</param>
  </javadoc>
  <method type="void" name="set" />
  <javadoc>
    <text>&lt;p&gt;
 * Sets all the elements in this matrix equal to the specified value.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = val&lt;br&gt;
 * &lt;/p&gt;</text>
    <see>CommonOps#fill(org.ejml.data.D1Matrix64F,double)</see>
    <param>val The value each element is set to.</param>
  </javadoc>
  <method type="void" name="set" />
  <javadoc>
    <text>Sets all the elements in the matrix equal to zero.</text>
    <see>CommonOps#fill(org.ejml.data.D1Matrix64F,double)</see>
  </javadoc>
  <method type="void" name="zero" />
  <javadoc>
    <text>&lt;p&gt;
 * Computes the Frobenius normal of the matrix:&lt;br&gt;
 * &lt;br&gt;
 * normF = Sqrt{  &amp;sum;&lt;sub&gt;i=1:m&lt;/sub&gt; &amp;sum;&lt;sub&gt;j=1:n&lt;/sub&gt; { a&lt;sub&gt;ij&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;}   }
 * &lt;/p&gt;</text>
    <see>org.ejml.ops.NormOps#normF(org.ejml.data.D1Matrix64F)</see>
    <return>The matrix's Frobenius normal.</return>
  </javadoc>
  <method type="double" name="normF" />
  <javadoc>
    <text>&lt;p&gt;
 * The condition p = 2 number of a matrix is used to measure the sensitivity of the linear
 * system &lt;b&gt;Ax=b&lt;/b&gt;.  A value near one indicates that it is a well conditioned matrix.
 * &lt;/p&gt;</text>
    <see>NormOps#conditionP2(DenseMatrix64F)</see>
    <return>The condition number.</return>
  </javadoc>
  <method type="double" name="conditionP2" />
  <javadoc>
    <text>Computes the determinant of the matrix.</text>
    <see>CommonOps#det(DenseMatrix64F)</see>
    <return>The determinant.</return>
  </javadoc>
  <method type="double" name="determinant" />
  <javadoc>
    <text>&lt;p&gt;
 * Computes the trace of the matrix.
 * &lt;/p&gt;</text>
    <see>CommonOps#trace(org.ejml.data.RowD1Matrix64F)</see>
    <return>The trace of the matrix.</return>
  </javadoc>
  <method type="double" name="trace" />
  <javadoc>
    <text>&lt;p&gt;
 * Reshapes the matrix to the specified number of rows and columns.  If the total number of elements
 * is &lt;= number of elements it had before the data is saved.  Otherwise a new internal array is
 * declared and the old data lost.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This is equivalent to calling A.getMatrix().reshape(numRows,numCols,false).
 * &lt;/p&gt;</text>
    <see>org.ejml.data.ReshapeMatrix64F#reshape(int,int,boolean)</see>
    <param>numRows The new number of rows in the matrix.</param>
    <param>numCols The new number of columns in the matrix.</param>
  </javadoc>
  <method type="void" name="reshape" />
  <javadoc>
    <text>Assigns the element in the Matrix to the specified value.  Performs a bounds check to make sure
 * the requested element is part of the matrix.</text>
    <param>row The row of the element.</param>
    <param>col The column of the element.</param>
    <param>value The element's new value.</param>
  </javadoc>
  <method type="void" name="set" />
  <javadoc>
    <text>Assigns an element a value based on its index in the internal array..</text>
    <param>index The matrix element that is being assigned a value.</param>
    <param>value The element's new value.</param>
  </javadoc>
  <method type="void" name="set" />
  <javadoc>
    <text>&lt;p&gt;
 * Assigns consecutive elements inside a row to the provided array.&lt;br&gt;
 * &lt;br&gt;
 * A(row,offset:(offset + values.length)) = values
 * &lt;/p&gt;</text>
    <param>row The row that the array is to be written to.</param>
    <param>offset The initial column that the array is written to.</param>
    <param>values Values which are to be written to the row in a matrix.</param>
  </javadoc>
  <method type="void" name="setRow">
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Assigns consecutive elements inside a column to the provided array.&lt;br&gt;
 * &lt;br&gt;
 * A(offset:(offset + values.length),column) = values
 * &lt;/p&gt;</text>
    <param>column The column that the array is to be written to.</param>
    <param>offset The initial column that the array is written to.</param>
    <param>values Values which are to be written to the row in a matrix.</param>
  </javadoc>
  <method type="void" name="setColumn">
    <scope />
  </method>
  <javadoc>
    <text>Returns the value of the specified matrix element.  Performs a bounds check to make sure
 * the requested element is part of the matrix.</text>
    <param>row The row of the element.</param>
    <param>col The column of the element.</param>
    <return>The value of the element.</return>
  </javadoc>
  <method type="double" name="get" />
  <javadoc>
    <text>Returns the value of the matrix at the specified index of the 1D row major array.</text>
    <see>org.ejml.data.DenseMatrix64F#get(int)</see>
    <param>index The element's index whose value is to be returned</param>
    <return>The value of the specified element.</return>
  </javadoc>
  <method type="double" name="get" />
  <javadoc>
    <text>Returns the index in the matrix's array.</text>
    <see>org.ejml.data.DenseMatrix64F#getIndex(int,int)</see>
    <param>row The row number.</param>
    <param>col The column number.</param>
    <return>The index of the specified element.</return>
  </javadoc>
  <method type="int" name="getIndex" />
  <javadoc>
    <text>Creates a new iterator for traversing through a submatrix inside this matrix.  It can be traversed
 * by row or by column.  Range of elements is inclusive, e.g. minRow = 0 and maxRow = 1 will include rows
 * 0 and 1.  The iteration starts at (minRow,minCol) and ends at (maxRow,maxCol)</text>
    <param>rowMajor true means it will traverse through the submatrix by row first, false by columns.</param>
    <param>minRow first row it will start at.</param>
    <param>minCol first column it will start at.</param>
    <param>maxRow last row it will stop at.</param>
    <param>maxCol last column it will stop at.</param>
    <return>A new MatrixIterator</return>
  </javadoc>
  <method type="MatrixIterator" name="iterator" />
  <javadoc>
    <text>Creates and returns a matrix which is idential to this one.</text>
    <return>A new identical matrix.</return>
  </javadoc>
  <method type="T" name="copy">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>Returns the number of rows in this matrix.</text>
    <return>number of rows.</return>
  </javadoc>
  <method type="int" name="numRows" />
  <javadoc>
    <text>Returns the number of columns in this matrix.</text>
    <return>number of columns.</return>
  </javadoc>
  <method type="int" name="numCols" />
  <javadoc>
    <text>Returns the number of elements in this matrix, which is equal to
 * the number of rows times the number of columns.</text>
    <return>The number of elements in the matrix.</return>
  </javadoc>
  <method type="int" name="getNumElements" />
  <javadoc>
    <text>Prints the matrix to standard out.</text>
  </javadoc>
  <method type="void" name="print" />
  <javadoc>
    <text>Prints the matrix to standard out with the specified precision.</text>
  </javadoc>
  <method type="void" name="print" />
  <javadoc>
    <text>&lt;p&gt;
 * Prints the matrix to standard out given a {@link java.io.PrintStream#printf) style floating point format,
 * e.g. print("%f").
 * &lt;/p&gt;}</text>
  </javadoc>
  <method type="void" name="print" />
  <javadoc>
    <text>&lt;p&gt;
 * Converts the array into a string format for display purposes.
 * The conversion is done using {@link MatrixIO#print(java.io.PrintStream,org.ejml.data.ReshapeMatrix64F)}.
 * &lt;/p&gt;</text>
    <return>String representation of the matrix.</return>
  </javadoc>
  <method type="String" name="toString">
    <declaration type="ByteArrayOutputStream" name="stream" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Creates a new SimpleMatrix which is a submatrix of this matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * s&lt;sub&gt;i-y0 , j-x0&lt;/sub&gt; = o&lt;sub&gt;ij&lt;/sub&gt; for all y0 &amp;le; i &lt; y1 and x0 &amp;le; j &lt; x1&lt;br&gt;
 * &lt;br&gt;
 * where 's&lt;sub&gt;ij&lt;/sub&gt;' is an element in the submatrix and 'o&lt;sub&gt;ij&lt;/sub&gt;' is an element in the
 * original matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If any of the inputs are set to T.END then it will be set to the last row
 * or column in the matrix.
 * &lt;/p&gt;</text>
    <param>x0 Start column.</param>
    <param>x1 Stop column.</param>
    <param>y0 Start row.</param>
    <param>y1 Stop row.</param>
    <return>The submatrix.</return>
  </javadoc>
  <method type="T" name="extractMatrix">
    <declaration type="T" name="ret" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Extracts a row or column from this matrix. The returned vector will either be a row
 * or column vector depending on the input type.
 * &lt;/p&gt;</text>
    <param>extractRow If true a row will be extracted.</param>
    <param>element The row or column the vector is contained in.</param>
    <return>Extracted vector.</return>
  </javadoc>
  <method type="T" name="extractVector">
    <declaration type="int" name="length" />
    <declaration type="T" name="ret" />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Extracts the diagonal from this matrix and returns them inside a column vector.
 * &lt;/p&gt;</text>
    <see>org.ejml.ops.CommonOps#extractDiag(DenseMatrix64F,DenseMatrix64F)</see>
    <return>Diagonal elements inside a column vector.</return>
  </javadoc>
  <method type="T" name="extractDiag">
    <declaration type="int" name="N" />
    <declaration type="T" name="diag" />
  </method>
  <javadoc>
    <text>Checks to see if matrix 'a' is the same as this matrix within the specified
 * tolerance.</text>
    <param>a The matrix it is being compared against.</param>
    <param>tol How similar they must be to be equals.</param>
    <return>If they are equal within tolerance of each other.</return>
  </javadoc>
  <method type="boolean" name="isIdentical" />
  <javadoc>
    <text>Checks to see if any of the elements in this matrix are either NaN or infinite.</text>
    <return>True of an element is NaN or infinite.  False otherwise.</return>
  </javadoc>
  <method type="boolean" name="hasUncountable" />
  <javadoc>
    <text>Computes a full Singular Value Decomposition (SVD) of this matrix with the
 * eigenvalues ordered from largest to smallest.</text>
    <return>SVD</return>
  </javadoc>
  <method type="SimpleSVD" name="svd" />
  <javadoc>
    <text>Computes the SVD in either  compact format or full format.</text>
    <return>SVD of this matrix.</return>
  </javadoc>
  <method type="SimpleSVD" name="svd" />
  <javadoc>
    <text>Returns the Eigen Value Decomposition (EVD) of this matrix.</text>
  </javadoc>
  <method type="SimpleEVD" name="eig" />
  <javadoc>
    <text>Copy matrix B into this matrix at location (insertRow, insertCol).</text>
    <param>insertRow First row the matrix is to be inserted into.</param>
    <param>insertCol First column the matrix is to be inserted into.</param>
    <param>B The matrix that is being inserted.</param>
  </javadoc>
  <method type="void" name="insertIntoThis" />
  <javadoc>
    <text>&lt;p&gt;
 * Creates a new matrix that is a combination of this matrix and matrix B.  B is
 * written into A at the specified location if needed the size of A is increased by
 * growing it.  A is grown by padding the new area with zeros.
 * &lt;/p&gt;
 * &lt;p&gt;
 * While useful when adding data to a matrix which will be solved for it is also much
 * less efficient than predeclaring a matrix and inserting data into it.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If insertRow or insertCol is set to SimpleMatrix.END then it will be combined
 * at the last row or column respectively.
 * &lt;p&gt;</text>
    <param>insertRow Row where matrix B is written in to.</param>
    <param>insertCol Column where matrix B is written in to.</param>
    <param>B The matrix that is written into A.</param>
    <return>A new combined matrix.</return>
  </javadoc>
  <method type="T" name="combine">
    <scope />
    <scope />
    <declaration type="int" name="maxRow" />
    <declaration type="int" name="maxCol" />
    <declaration type="T" name="ret" />
    <scope>
      <declaration type="int" name="M" />
      <declaration type="int" name="N" />
    </scope>
    <scope />
  </method>
  <javadoc>
    <text>Returns the maximum absolute value of all the elements in this matrix.  This is
 * equivalent the the infinite p-norm of the matrix.</text>
    <return>Largest absolute value of any element.</return>
  </javadoc>
  <method type="double" name="elementMaxAbs" />
  <javadoc>
    <text>Computes the sum of all the elements in the matrix.</text>
    <return>Sum of all the elements.</return>
  </javadoc>
  <method type="double" name="elementSum" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns a matrix which is the result of an element by element multiplication of 'this' and 'b':
 * c&lt;sub&gt;i,j&lt;/sub&gt; = a&lt;sub&gt;i,j&lt;/sub&gt;*b&lt;sub&gt;i,j&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <param>b A simple matrix.</param>
    <return>The element by element multiplication of 'this' and 'b'.</return>
  </javadoc>
  <method type="T" name="elementMult">
    <declaration type="T" name="c" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns a new matrix whose elements are the negative of 'this' matrix's elements.&lt;br&gt;
 * &lt;br&gt;
 * b&lt;sub&gt;ij&lt;/sub&gt; = -a&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <return>A matrix that is the negative of the original.</return>
  </javadoc>
  <method type="T" name="negative">
    <declaration type="T" name="A" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Saves this matrix to a file as a serialized binary object.
 * &lt;/p&gt;</text>
    <see>MatrixIO#saveBin(org.ejml.data.ReshapeMatrix64F,String)</see>
    <param>fileName</param>
    <throws>java.io.IOException</throws>
  </javadoc>
  <method type="void" name="saveToFileBinary" />
  <javadoc>
    <text>&lt;p&gt;
 * Loads a new matrix from a serialized binary file.
 * &lt;/p&gt;</text>
    <see>MatrixIO#loadBin(String)</see>
    <param>fileName File which is to be loaded.</param>
    <return>The matrix.</return>
    <throws>IOException</throws>
  </javadoc>
  <method type="SimpleMatrix" name="loadBinary">
    <declaration type="ReshapeMatrix64F" name="mat" />
    <scope />
    <scope />
    <comment>see if its a DenseMatrix64F</comment>
    <comment>if not convert it into one and wrap it</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Saves this matrix to a file in a CSV format.  For the file format see {@link MatrixIO}.
 * &lt;/p&gt;</text>
    <see>MatrixIO#saveBin(org.ejml.data.ReshapeMatrix64F,String)</see>
    <param>fileName</param>
    <throws>java.io.IOException</throws>
  </javadoc>
  <method type="void" name="saveToFileCSV" />
  <javadoc>
    <text>&lt;p&gt;
 * Loads a new matrix from a CSV file.  For the file format see {@link MatrixIO}.
 * &lt;/p&gt;</text>
    <see>MatrixIO#loadCSV(String)</see>
    <param>fileName File which is to be loaded.</param>
    <return>The matrix.</return>
    <throws>IOException</throws>
  </javadoc>
  <method type="SimpleMatrix" name="loadCSV">
    <declaration type="ReshapeMatrix64F" name="mat" />
    <scope />
    <scope />
    <comment>see if its a DenseMatrix64F</comment>
    <comment>if not convert it into one and wrap it</comment>
  </method>
  <javadoc>
    <text>Returns true of the specified matrix element is valid element inside this matrix.</text>
    <param>row Row index.</param>
    <param>col Column index.</param>
    <return>true if it is a valid element in the matrix.</return>
  </javadoc>
  <method type="boolean" name="isInBounds" />
  <javadoc>
    <text>Prints the number of rows and column in this matrix.</text>
  </javadoc>
  <method type="void" name="printDimensions" />
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
