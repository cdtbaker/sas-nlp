<?xml version="1.0" encoding="UTF-8"?>
<class name="LUDecomposition">
  <javadoc>
    <text>&lt;p&gt;
 * LU Decomposition refactors the original matrix such that:&lt;br&gt;
 * &lt;div align=center&gt; P&lt;sup&gt;T&lt;/sup&gt;*L*U = A&lt;/div&gt;
 * where P is a pivot matrix, L is a lower triangular matrix, U is an upper triangular matrix and A is
 * the original matrix.
 * &lt;/p&gt;
 * &lt;p&gt;
 * LU Decomposition is useful since once the decomposition has been performed linear
 * equations can be quickly solved and the original matrix A inverted.  Different algorithms
 * can be selected to perform the decomposition, all will have the same end result.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To use this class first specify the size of the matrix that will be decomposed by it in
 * the constructor.  Only square m by m matrices can be decomposed.  Then to decompose a matrix
 * call {@link #decompose}.  If it encounters any problems an exception will be thrown.  After
 * that all the other functions will be available for solving and inverting matrices.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <method name="getLower" type="T" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns the L matrix from the decomposition.  Should only
 * be called after {@link #decompose(org.ejml.data.Matrix64F)} has
 * been called.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If parameter 'lower' is not null, then that matrix is used to store the L matrix.  Otherwise
 * a new matrix is created.
 * &lt;/p&gt;</text>
    <param>lower Storage for T matrix. If null then a new matrix is returned.  Modified.</param>
    <return>The L matrix.</return>
  </javadoc>
  <method name="getUpper" type="T" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns the U matrix from the decomposition.  Should only
 * be called after {@link #decompose(org.ejml.data.Matrix64F)}  has
 * been called.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If parameter 'upper' is not null, then that matrix is used to store the U matrix.  Otherwise
 * a new matrix is created.
 * &lt;/p&gt;</text>
    <param>upper Storage for U matrix. If null then a new matrix is returned. Modified.</param>
    <return>The U matrix.</return>
  </javadoc>
  <method name="getPivot" type="T" />
  <javadoc>
    <text>&lt;p&gt;
 * For numerical stability there are often row interchanges.  This computes
 * a pivot matrix that will undo those changes.
 * &lt;/p&gt;</text>
    <param>pivot Storage for the pivot matrix. If null then a new matrix is returned. Modified.</param>
    <return>The pivot matrix.</return>
  </javadoc>
  <method name="isSingular" type="boolean">
    <comment>TODO Remove?  If singular decomposition will fail.</comment>
  </method>
  <javadoc>
    <text>Returns true if the decomposition detected a singular matrix.  This check
 * will not work 100% of the time due to machine precision issues.</text>
    <return>True if the matrix is singular and false if it is not.</return>
  </javadoc>
  <method name="computeDeterminant" type="double" />
  <javadoc>
    <text>Computes the matrix's determinant using the LU decomposition.</text>
    <return>The determinant.</return>
  </javadoc>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
