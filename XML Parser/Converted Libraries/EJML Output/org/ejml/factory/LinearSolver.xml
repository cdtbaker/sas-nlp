<?xml version="1.0" encoding="UTF-8"?>
<class name="LinearSolver">
  <javadoc>
    <text>&lt;p&gt;
 * An implementation of LinearSolver solves a linear system or inverts a matrix.  It masks more complex
 * implementation details, while giving the programmer control over memory management and performance.
 * To quickly detect nearly singular matrices without computing the SVD the {@link #quality()}function is provided.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A linear system is defined as:
 * A*X = B.&lt;br&gt;
 * where A &amp;isin; &amp;real; &lt;sup&gt;m &amp;times; n&lt;/sup&gt;, X &amp;isin; &amp;real; &lt;sup&gt;n &amp;times; p&lt;/sup&gt;,
 * B &amp;isin; &amp;real; &lt;sup&gt;m &amp;times; p&lt;/sup&gt;.  Different implementations can solve different
 * types and shapes in input matrices and have different memory and runtime performance.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To solve a system:&lt;br&gt;
 * &lt;ol&gt;
 * &lt;li&gt; Call {@link #setA(org.ejml.data.Matrix64F)}&lt;li&gt; Call {@link #solve(org.ejml.data.Matrix64F,org.ejml.data.Matrix64F)}.
 * &lt;/ol&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * To invert a matrix:&lt;br&gt;
 * &lt;ol&gt;
 * &lt;li&gt; Call {@link #setA(org.ejml.data.Matrix64F)}&lt;li&gt; Call {@link #invert(org.ejml.data.Matrix64F)}.
 * &lt;/ol&gt;
 * A matrix can also be inverted by passing in an identity matrix to solve, but this will be
 * slower and more memory intensive than the specialized invert() function.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;IMPORTANT:&lt;/b&gt; Depending upon the implementation, input matrices might be overwritten by
 * the solver.  This
 * reduces memory and computational requirements and give more control to the programmer.  If
 * the input matrices need to be not modified then {@link org.ejml.alg.dense.linsol.LinearSolverSafe} can be used.  The
 * functions {@link #modifiesA()} and {@link #modifiesB()} specify which input matrices are being
 * modified.
 * &lt;/p&gt;</text>
    <author>Peter Abeles</author>
  </javadoc>
  <method name="setA" type="boolean" />
  <javadoc>
    <text>&lt;p&gt;
 * Specifies the A matrix in the linear equation.  A reference might be saved
 * and it might also be modified depending on the implementation.  If it is modified
 * then {@link #modifiesA()} will return true.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If this value returns true that does not guarantee a valid solution was generated.  This
 * is because some decompositions don't detect singular matrices.
 * &lt;/p&gt;</text>
    <param>A The 'A' matrix in the linear equation. Might be modified or save the reference.</param>
    <return>true if it can be processed.</return>
  </javadoc>
  <method name="quality" type="double" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns a very quick to compute measure of how singular the system is.  This measure will
 * be invariant to the scale of the matrix and always be positive, with larger values
 * indicating it is less singular.  If not supported by the solver then the runtime
 * exception IllegalArgumentException is thrown.  This is NOT the matrix's condition.
 * &lt;p&gt;
 * &lt;p&gt;
 * How this function is implemented is not specified.  One possible implementation is the following:
 * In many decompositions a triangular matrix
 * is extracted.  The determinant of a triangular matrix is easily computed and once normalized
 * to be scale invariant and its absolute value taken it will provide functionality described above.
 * &lt;/p&gt;</text>
    <return>The quality of the linear system.</return>
  </javadoc>
  <method name="solve" type="void" />
  <javadoc>
    <text>&lt;p&gt;
 * Solves for X in the linear system, A*X=B.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In some implementations 'B' and 'X' can be the same instance of a variable.  Call{@link #modifiesB()} to determine if 'B' is modified.
 * &lt;/p&gt;</text>
    <param>B A matrix &amp;real; &lt;sup&gt;m &amp;times; p&lt;/sup&gt;.  Might be modified.</param>
    <param>X A matrix &amp;real; &lt;sup&gt;n &amp;times; p&lt;/sup&gt;, where the solution is written to.  Modified.</param>
  </javadoc>
  <method name="invert" type="void" />
  <javadoc>
    <text>Computes the inverse of of the 'A' matrix passed into {@link #setA(org.ejml.data.Matrix64F)}and writes the results to the provided matrix.  If 'A_inv' needs to be different from 'A'
 * is implementation dependent.</text>
    <param>A_inv Where the inverted matrix saved. Modified.</param>
  </javadoc>
  <method name="modifiesA" type="boolean" />
  <javadoc>
    <text>Returns true if the passed in matrix to {@link #setA(org.ejml.data.Matrix64F)}is modified.</text>
    <return>true if A is modified in setA().</return>
  </javadoc>
  <method name="modifiesB" type="boolean" />
  <javadoc>
    <text>Returns true if the passed in 'B' matrix to {@link #solve(org.ejml.data.Matrix64F,org.ejml.data.Matrix64F)}is modified.</text>
    <return>true if B is modified in solve(B,X).</return>
  </javadoc>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
