<?xml version="1.0" encoding="UTF-8"?>
<class name="CommonOps">
  <javadoc>
    <text>&lt;p&gt;
 * Common matrix operations are contained here.  Which specific underlying algorithm is used
 * is not specified just the out come of the operation.  Nor should calls to these functions
 * reply on the underlying implementation.  Which algorithm is used can depend on the matrix
 * being passed in.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For more exotic and specialized generic operations see {@link org.ejml.ops.SpecializedOps}.
 * &lt;/p&gt;</text>
    <see>org.ejml.alg.dense.mult.MatrixMatrixMult</see>
    <see>org.ejml.alg.dense.mult.MatrixVectorMult</see>
    <see>org.ejml.ops.SpecializedOps</see>
    <see>org.ejml.ops.MatrixFeatures</see>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a * b &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="mult">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = &amp;alpha; * a * b &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha; &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { * a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha Scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="mult">
    <scope />
    <scope />
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a&lt;sup&gt;T&lt;/sup&gt; * b &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multTransA">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>todo check a.numCols == 1 and do inner product?</comment>
    <comment>there are significantly faster algorithms when dealing with vectors</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = &amp;alpha; * a&lt;sup&gt;T&lt;/sup&gt; * b &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha; &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha Scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multTransA">
    <scope />
    <scope />
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a * b&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multTransB">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c =  &amp;alpha; * a * b&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha; &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; {  a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha Scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multTransB">
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a&lt;sup&gt;T&lt;/sup&gt; * b&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multTransAB">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>there are significantly faster algorithms when dealing with vectors</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = &amp;alpha; * a&lt;sup&gt;T&lt;/sup&gt; * b&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha; &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha Scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multTransAB">
    <scope />
    <scope />
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;Computes the matrix multiplication inner product:&lt;br&gt;
 * &lt;br&gt;
 * c = a&lt;sup&gt;T&lt;/sup&gt; * a &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * a&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;
 * &lt;p&gt;
 * Is faster than using a generic matrix multiplication by taking advantage of symmetry.  For
 * vectors there is an even faster option, see {@link org.ejml.alg.dense.mult.VectorVectorMult#innerProd(org.ejml.data.D1Matrix64F,org.ejml.data.D1Matrix64F)}&lt;/p&gt;</text>
    <param>a The matrix being multiplied. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multInner">
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Computes the matrix multiplication outer product:&lt;br&gt;
 * &lt;br&gt;
 * c = a * a&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=1:m&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * a&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;
 * &lt;p&gt;
 * Is faster than using a generic matrix multiplication by taking advantage of symmetry.
 * &lt;/p&gt;</text>
    <param>a The matrix being multiplied. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multOuter" />
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + a * b&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; + &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAdd">
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + &amp;alpha; * a * b&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; +  &amp;alpha; * &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAdd">
    <scope />
    <scope />
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + a&lt;sup&gt;T&lt;/sup&gt; * b&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; + &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransA">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + &amp;alpha; * a&lt;sup&gt;T&lt;/sup&gt; * b&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; =c&lt;sub&gt;ij&lt;/sub&gt; +  &amp;alpha; * &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;kj&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha scaling factor</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransA">
    <scope />
    <scope />
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + a * b&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; + &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransB" />
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + &amp;alpha; * a * b&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; + &amp;alpha; * &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ik&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha Scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransB">
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + a&lt;sup&gt;T&lt;/sup&gt; * b&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; + &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not Modified.</param>
    <param>b The right matrix in the multiplication operation. Not Modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransAB">
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
    <scope />
    <comment>there are significantly faster algorithms when dealing with vectors</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = c + &amp;alpha; * a&lt;sup&gt;T&lt;/sup&gt; * b&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = c&lt;sub&gt;ij&lt;/sub&gt; + &amp;alpha; * &amp;sum;&lt;sub&gt;k=1:n&lt;/sub&gt; { a&lt;sub&gt;ki&lt;/sub&gt; * b&lt;sub&gt;jk&lt;/sub&gt;}
 * &lt;/p&gt;</text>
    <param>alpha Scaling factor.</param>
    <param>a The left matrix in the multiplication operation. Not Modified.</param>
    <param>b The right matrix in the multiplication operation. Not Modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="multAddTransAB">
    <scope />
    <scope />
    <comment>TODO add a matrix vectory multiply here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Solves for x in the following equation:&lt;br&gt;
 * &lt;br&gt;
 * A*x = b
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the system could not be solved then false is returned.  If it returns true
 * that just means the algorithm finished operating, but the results could still be bad
 * because 'A' is singular or nearly singular.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If repeat calls to solve are being made then one should consider using {@link LinearSolverFactory}instead.
 * &lt;/p&gt;
 * &lt;p&gt;
 * It is ok for 'b' and 'x' to be the same matrix.
 * &lt;/p&gt;</text>
    <param>a A matrix that is m by m. Not modified.</param>
    <param>b A matrix that is m by n. Not modified.</param>
    <param>x A matrix that is m by n. Modified.</param>
    <return>true if it could invert the matrix false if it could not.</return>
  </javadoc>
  <method type="boolean" name="solve">
    <declaration type="LinearSolver&lt;DenseMatrix64F&gt;" name="solver" />
    <comment>make sure the inputs 'a' and 'b' are not modified</comment>
  </method>
  <javadoc>
    <text>Performs an in-place transpose.  This algorithm is only efficient for square
 * matrices.</text>
    <param>mat The matrix that is to be transposed. Modified.</param>
  </javadoc>
  <method type="void" name="transpose">
    <scope />
    <scope>
      <declaration type="DenseMatrix64F" name="b" />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Transposes matrix 'a' and stores the results in 'b':&lt;br&gt;
 * &lt;br&gt;
 * b&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ji&lt;/sub&gt;&lt;br&gt;
 * where 'b' is the transpose of 'a'.
 * &lt;/p&gt;</text>
    <param>A The original matrix.  Not modified.</param>
    <param>A_tran Where the transpose is stored. If null a new matrix is created. Modified.</param>
    <return>The transposed matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="transpose">
    <scope />
    <scope>
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * This computes the trace of the matrix:&lt;br&gt;
 * &lt;br&gt;
 * trace = &amp;sum;&lt;sub&gt;i=1:n&lt;/sub&gt; { a&lt;sub&gt;ii&lt;/sub&gt; }
 * &lt;/p&gt;
 * &lt;p&gt;
 * The trace is only defined for square matrices.
 * &lt;/p&gt;</text>
    <param>a A square matrix.  Not modified.</param>
  </javadoc>
  <method type="double" name="trace">
    <scope />
    <declaration type="double" name="sum" />
    <declaration type="int" name="index" />
    <scope />
  </method>
  <javadoc>
    <text>Returns the determinant of the matrix.  If the inverse of the matrix is also
 * needed, then using {@link org.ejml.alg.dense.decomposition.lu.LUDecompositionAlt} directly (or any
 * similar algorithm) can be more efficient.</text>
    <param>mat The matrix whose determinant is to be computed.  Not modified.</param>
    <return>The determinant.</return>
  </javadoc>
  <method type="double" name="det">
    <declaration type="int" name="numCol" />
    <declaration type="int" name="numRow" />
    <scope />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="LUDecompositionAlt" name="alg" />
      <scope />
    </scope>
    <comment>slight performance boost overall by doing it this way</comment>
    <comment>when it was the case statement the VM did some strange optimization</comment>
    <comment>and made case 2 about 1/2 the speed</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix inversion operation on the specified matrix and stores the results
 * in the same matrix.&lt;br&gt;
 * &lt;br&gt;
 * a = a&lt;sup&gt;-1&lt;sup&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the algorithm could not invert the matrix then false is returned.  If it returns true
 * that just means the algorithm finished.  The results could still be bad
 * because the matrix is singular or nearly singular.
 * &lt;/p&gt;</text>
    <param>mat The matrix that is to be inverted.  Results are stored here.  Modified.</param>
    <return>true if it could invert the matrix false if it could not.</return>
  </javadoc>
  <method type="boolean" name="invert">
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="LUDecompositionAlt" name="alg" />
      <declaration type="LinearSolverLu" name="solver" />
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs a matrix inversion operation that does not modify the original
 * and stores the results in another matrix.  The two matrices must have the
 * same dimension.&lt;br&gt;
 * &lt;br&gt;
 * b = a&lt;sup&gt;-1&lt;sup&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * If the algorithm could not invert the matrix then false is returned.  If it returns true
 * that just means the algorithm finished.  The results could still be bad
 * because the matrix is singular or nearly singular.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For medium to large matrices there might be a slight performance boost to using{@link LinearSolverFactory} instead.
 * &lt;/p&gt;</text>
    <param>mat The matrix that is to be inverted. Not modified.</param>
    <param>result Where the inverse matrix is stored.  Modified.</param>
    <return>true if it could invert the matrix false if it could not.</return>
  </javadoc>
  <method type="boolean" name="invert">
    <scope>
      <scope />
      <scope />
      <scope />
    </scope>
    <scope>
      <declaration type="LUDecompositionAlt" name="alg" />
      <declaration type="LinearSolverLu" name="solver" />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the Moore-Penrose pseudo-inverse:&lt;br&gt;
 * &lt;br&gt;
 * pinv(A) = (A&lt;sup&gt;T&lt;/sup&gt;A)&lt;sup&gt;-1&lt;/sup&gt; A&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
 * or&lt;br&gt;
 * pinv(A) = A&lt;sup&gt;T&lt;/sup&gt;(AA&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;-1&lt;/sup&gt;&lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Internally it uses {@link org.ejml.alg.dense.linsol.svd.SolvePseudoInverseSvd} to compute the inverse.  For performance reasons, this should only
 * be used when a matrix is singular or nearly singular.
 * &lt;/p&gt;</text>
    <param>A  A m by n Matrix.  Not modified.</param>
    <param>invA Where the computed pseudo inverse is stored. n by m.  Modified.</param>
    <return />
  </javadoc>
  <method type="void" name="pinv">
    <declaration type="LinearSolver&lt;DenseMatrix64F&gt;" name="solver" />
  </method>
  <javadoc>
    <text>Converts the columns in a matrix into a set of vectors.</text>
    <param>A Matrix.  Not modified.</param>
    <param>v</param>
    <return>An array of vectors.</return>
  </javadoc>
  <method type="DenseMatrix64F[]" name="columnsToVector">
    <declaration type="DenseMatrix64F[]" name="ret" />
    <scope />
    <scope />
    <scope>
      <scope />
      <scope />
      <declaration type="DenseMatrix64F" name="u" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Converts the rows in a matrix into a set of vectors.</text>
    <param>A Matrix.  Not modified.</param>
    <param>v</param>
    <return>An array of vectors.</return>
  </javadoc>
  <method type="DenseMatrix64F[]" name="rowsToVector">
    <declaration type="DenseMatrix64F[]" name="ret" />
    <scope />
    <scope />
    <scope>
      <scope />
      <scope />
      <declaration type="DenseMatrix64F" name="u" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>Sets all the diagonal elements equal to one and everything else equal to zero.
 * If this is a square matrix then it will be an identity matrix.</text>
    <see>#identity(int)</see>
    <param>mat A square matrix.</param>
  </javadoc>
  <method type="void" name="setIdentity">
    <declaration type="int" name="width" />
    <declaration type="int" name="length" />
    <scope />
    <declaration type="int" name="index" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Creates an identity matrix of the specified size.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = 0   if i &amp;ne; j&lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = 1   if i = j&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>width The width and height of the identity matrix.</param>
    <return>A new instance of an identity matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="identity">
    <declaration type="DenseMatrix64F" name="ret" />
    <scope />
  </method>
  <javadoc>
    <text>Creates a rectangular matrix which is zero except along the diagonals.</text>
    <param>numRows Number of rows in the matrix.</param>
    <param>numCols NUmber of columns in the matrix.</param>
    <return>A matrix with diagonal elements equal to one.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="identity">
    <declaration type="DenseMatrix64F" name="ret" />
    <declaration type="int" name="small" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Creates a new square matrix whose diagonal elements are specified by diagEl and all
 * the other elements are zero.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = 0         if i &amp;le; j&lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = diag[i]   if i = j&lt;br&gt;
 * &lt;/p&gt;</text>
    <see>#diagR</see>
    <param>diagEl Contains the values of the diagonal elements of the resulting matrix.</param>
    <return>A new matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="diag" />
  <method type="DenseMatrix64F" name="diag">
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Creates a new rectangular matrix whose diagonal elements are specified by diagEl and all
 * the other elements are zero.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = 0         if i &amp;le; j&lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = diag[i]   if i = j&lt;br&gt;
 * &lt;/p&gt;</text>
    <see>#diag</see>
    <param>numRows Number of rows in the matrix.</param>
    <param>numCols Number of columns in the matrix.</param>
    <param>diagEl Contains the values of the diagonal elements of the resulting matrix.</param>
    <return>A new matrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="diagR">
    <declaration type="DenseMatrix64F" name="ret" />
    <declaration type="int" name="o" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * The Kronecker product of two matrices is defined as:&lt;br&gt;
 * C&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt;B&lt;br&gt;
 * where C&lt;sub&gt;ij&lt;/sub&gt; is a sub matrix inside of C &amp;isin; &amp;real; &lt;sup&gt;m*k &amp;times; n*l&lt;/sup&gt;,
 * A &amp;isin; &amp;real; &lt;sup&gt;m &amp;times; n&lt;/sup&gt;, and B &amp;isin; &amp;real; &lt;sup&gt;k &amp;times; l&lt;/sup&gt;.
 * &lt;/p&gt;</text>
    <param>A The left matrix in the operation. Not modified.</param>
    <param>B The right matrix in the operation. Not modified.</param>
    <param>C Where the results of the operation are stored. Modified.</param>
    <return>The results of the operation.</return>
  </javadoc>
  <method type="void" name="kron">
    <declaration type="int" name="numColsC" />
    <declaration type="int" name="numRowsC" />
    <scope />
    <scope>
      <scope>
        <declaration type="double" name="a" />
        <scope>
          <scope>
            <declaration type="double" name="val" />
          </scope>
        </scope>
      </scope>
    </scope>
    <comment>TODO see comment below</comment>
    <comment>this will work well for small matrices</comment>
    <comment>but an alternative version should be made for large matrices</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Extracts a submatrix from 'src' and inserts it in a submatrix in 'dst'.
 * &lt;/p&gt;
 * &lt;p&gt;
 * s&lt;sub&gt;i-y0 , j-x0&lt;/sub&gt; = o&lt;sub&gt;ij&lt;/sub&gt; for all y0 &amp;le; i &lt; y1 and x0 &amp;le; j &lt; x1 &lt;br&gt;
 * &lt;br&gt;
 * where 's&lt;sub&gt;ij&lt;/sub&gt;' is an element in the submatrix and 'o&lt;sub&gt;ij&lt;/sub&gt;' is an element in the
 * original matrix.
 * &lt;/p&gt;</text>
    <param>src The original matrix which is to be copied.  Not modified.</param>
    <param>srcX0 Start column.</param>
    <param>srcX1 Stop column+1.</param>
    <param>srcY0 Start row.</param>
    <param>srcY1 Stop row+1.</param>
    <param>dst Where the submatrix are stored.  Modified.</param>
    <param>dstY0 Start row in dst.</param>
    <param>dstX0 start column in dst.</param>
  </javadoc>
  <method type="void" name="extract">
    <declaration type="int" name="w" />
    <declaration type="int" name="h" />
    <scope />
    <scope />
    <comment>interestingly, the performance is only different for small matrices but identical for larger ones</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Creates a new matrix which is the specified submatrix of 'src'
 * &lt;/p&gt;
 * &lt;p&gt;
 * s&lt;sub&gt;i-y0 , j-x0&lt;/sub&gt; = o&lt;sub&gt;ij&lt;/sub&gt; for all y0 &amp;le; i &lt; y1 and x0 &amp;le; j &lt; x1 &lt;br&gt;
 * &lt;br&gt;
 * where 's&lt;sub&gt;ij&lt;/sub&gt;' is an element in the submatrix and 'o&lt;sub&gt;ij&lt;/sub&gt;' is an element in the
 * original matrix.
 * &lt;/p&gt;</text>
    <param>src The original matrix which is to be copied.  Not modified.</param>
    <param>srcX0 Start column.</param>
    <param>srcX1 Stop column+1.</param>
    <param>srcY0 Start row.</param>
    <param>srcY1 Stop row+1.</param>
    <return>Extracted submatrix.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="extract">
    <declaration type="int" name="w" />
    <declaration type="int" name="h" />
    <declaration type="DenseMatrix64F" name="dst" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Extracts the diagonal elements 'src' write it to the 'dst' vector.  'dst'
 * can either be a row or column vector.
 * &lt;p&gt;</text>
    <param>src Matrix whose diagonal elements are being extracted. Not modified.</param>
    <param>dst A vector the results will be written into. Modified.</param>
  </javadoc>
  <method type="void" name="extractDiag">
    <declaration type="int" name="N" />
    <scope />
    <scope />
    <scope />
  </method>
  <javadoc>
    <text>Inserts matrix 'src' into matrix 'dest' with the (0,0) of src at (row,col) in dest.
 * This is equivalent to calling extract(src,0,src.numRows,0,src.numCols,dest,destY0,destX0).</text>
    <param>src matrix that is being copied into dest. Not modified.</param>
    <param>dest Where src is being copied into. Modified.</param>
    <param>destY0 Start row for the copy into dest.</param>
    <param>destX0 Start column for the copy into dest.</param>
  </javadoc>
  <method type="void" name="insert" />
  <javadoc>
    <text>&lt;p&gt;
 * Returns the value of the element in the matrix that has the largest value.&lt;br&gt;
 * &lt;br&gt;
 * Max{ a&lt;sub&gt;ij&lt;/sub&gt; } for all i and j&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix. Not modified.</param>
    <return>The max element value of the matrix.</return>
  </javadoc>
  <method type="double" name="elementMax">
    <declaration type="int" name="size" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="double" name="val" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the absolute value of the element in the matrix that has the largest absolute value.&lt;br&gt;
 * &lt;br&gt;
 * Max{ |a&lt;sub&gt;ij&lt;/sub&gt;| } for all i and j&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix. Not modified.</param>
    <return>The max abs element value of the matrix.</return>
  </javadoc>
  <method type="double" name="elementMaxAbs">
    <declaration type="int" name="size" />
    <declaration type="double" name="max" />
    <scope>
      <declaration type="double" name="val" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the value of the element in the matrix that has the minimum value.&lt;br&gt;
 * &lt;br&gt;
 * Min{ a&lt;sub&gt;ij&lt;/sub&gt; } for all i and j&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix. Not modified.</param>
    <return>The value of element in the matrix with the minimum value.</return>
  </javadoc>
  <method type="double" name="elementMin">
    <declaration type="int" name="size" />
    <declaration type="double" name="min" />
    <scope>
      <declaration type="double" name="val" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the absolute value of the element in the matrix that has the smallest absolute value.&lt;br&gt;
 * &lt;br&gt;
 * Min{ |a&lt;sub&gt;ij&lt;/sub&gt;| } for all i and j&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix. Not modified.</param>
    <return>The max element value of the matrix.</return>
  </javadoc>
  <method type="double" name="elementMinAbs">
    <declaration type="int" name="size" />
    <declaration type="double" name="min" />
    <scope>
      <declaration type="double" name="val" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the an element by element multiplication operation:&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; * b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
  </javadoc>
  <method type="void" name="elementMult">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the an element by element multiplication operation:&lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; * b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a The left matrix in the multiplication operation. Not modified.</param>
    <param>b The right matrix in the multiplication operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="elementMult">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the an element by element division operation:&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; / b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a The left matrix in the division operation. Modified.</param>
    <param>b The right matrix in the division operation. Not modified.</param>
  </javadoc>
  <method type="void" name="elementDiv">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the an element by element division operation:&lt;br&gt;
 * &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; / b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a The left matrix in the division operation. Not modified.</param>
    <param>b The right matrix in the division operation. Not modified.</param>
    <param>c Where the results of the operation are stored. Modified.</param>
  </javadoc>
  <method type="void" name="elementDiv">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the sum of all the elements in the matrix:&lt;br&gt;
 * &lt;br&gt;
 * sum(i=1:m , j=1:n ; a&lt;sub&gt;ij&lt;/sub&gt;)
 * &lt;p&gt;</text>
    <param>mat An m by n matrix. Not modified.</param>
    <return>The sum of the elements.</return>
  </javadoc>
  <method type="double" name="elementSum">
    <declaration type="double" name="total" />
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the sum of the absolute value all the elements in the matrix:&lt;br&gt;
 * &lt;br&gt;
 * sum(i=1:m , j=1:n ; |a&lt;sub&gt;ij&lt;/sub&gt;|)
 * &lt;p&gt;</text>
    <param>mat An m by n matrix. Not modified.</param>
    <return>The sum of the absolute value of each element.</return>
  </javadoc>
  <method type="double" name="elementSumAbs">
    <declaration type="double" name="total" />
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the sum of each row in the input matrix and returns the results in a vector:&lt;br&gt;
 * &lt;br&gt;
 * b&lt;sub&gt;j&lt;/sub&gt; = sum(i=1:n ; |a&lt;sub&gt;ji&lt;/sub&gt;|)
 * &lt;/p&gt;</text>
    <param>input INput matrix whose rows are summed.</param>
    <param>output Optional storage for output.  Must be a vector. If null a row vector is returned. Modified.</param>
    <return>Vector containing the sum of each row in the input.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="sumRows">
    <scope />
    <scope>
      <declaration type="double" name="total" />
      <declaration type="int" name="end" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the sum of each column in the input matrix and returns the results in a vector:&lt;br&gt;
 * &lt;br&gt;
 * b&lt;sub&gt;j&lt;/sub&gt; = sum(i=1:m ; |a&lt;sub&gt;ij&lt;/sub&gt;|)
 * &lt;/p&gt;</text>
    <param>input INput matrix whose rows are summed.</param>
    <param>output Optional storage for output.  Must be a vector. If null a column vector is returned. Modified.</param>
    <return>Vector containing the sum of each row in the input.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="sumCols">
    <scope />
    <scope>
      <declaration type="double" name="total" />
      <declaration type="int" name="index" />
      <declaration type="int" name="end" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * a = a + b &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; + b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A Matrix. Modified.</param>
    <param>b A Matrix. Not modified.</param>
  </javadoc>
  <method type="void" name="addEquals">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * a = a +  &amp;beta; * b  &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; + &amp;beta; * b&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <param>beta The number that matrix 'b' is multiplied by.</param>
    <param>a A Matrix. Modified.</param>
    <param>b A Matrix. Not modified.</param>
  </javadoc>
  <method type="void" name="addEquals">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a + b &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; + b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Matrix C can be the same instance as Matrix A and/or B.
 * &lt;/p&gt;</text>
    <param>a A Matrix. Not modified.</param>
    <param>b A Matrix. Not modified.</param>
    <param>c A Matrix where the results are stored. Modified.</param>
  </javadoc>
  <method type="void" name="add">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a + &amp;beta; * b &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; + &amp;beta; * b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Matrix C can be the same instance as Matrix A and/or B.
 * &lt;/p&gt;</text>
    <param>a A Matrix. Not modified.</param>
    <param>beta Scaling factor for matrix b.</param>
    <param>b A Matrix. Not modified.</param>
    <param>c A Matrix where the results are stored. Modified.</param>
  </javadoc>
  <method type="void" name="add">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = &amp;alpha; * a + &amp;beta; * b &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha; * a&lt;sub&gt;ij&lt;/sub&gt; + &amp;beta; * b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Matrix C can be the same instance as Matrix A and/or B.
 * &lt;/p&gt;</text>
    <param>alpha A scaling factor for matrix a.</param>
    <param>a A Matrix. Not modified.</param>
    <param>beta A scaling factor for matrix b.</param>
    <param>b A Matrix. Not modified.</param>
    <param>c A Matrix where the results are stored. Modified.</param>
  </javadoc>
  <method type="void" name="add">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following operation:&lt;br&gt;
 * &lt;br&gt;
 * c = &amp;alpha; * a + b &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha; * a&lt;sub&gt;ij&lt;/sub&gt; + b&lt;sub&gt;ij&lt;/sub&gt; &lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Matrix C can be the same instance as Matrix A and/or B.
 * &lt;/p&gt;</text>
    <param>alpha A scaling factor for matrix a.</param>
    <param>a A Matrix. Not modified.</param>
    <param>b A Matrix. Not modified.</param>
    <param>c A Matrix where the results are stored. Modified.</param>
  </javadoc>
  <method type="void" name="add">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs an in-place scalar addition:&lt;br&gt;
 * &lt;br&gt;
 * a = a + val&lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; + val&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix.  Modified.</param>
    <param>val The value that's added to each element.</param>
  </javadoc>
  <method type="void" name="add">
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs scalar addition:&lt;br&gt;
 * &lt;br&gt;
 * c = a + val&lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; + val&lt;br&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix. Not modified.</param>
    <param>c A matrix. Modified.</param>
    <param>val The value that's added to each element.</param>
  </javadoc>
  <method type="void" name="add">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following subtraction operation:&lt;br&gt;
 * &lt;br&gt;
 * a = a - b  &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; - b&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <param>a A Matrix. Modified.</param>
    <param>b A Matrix. Not modified.</param>
  </javadoc>
  <method type="void" name="subEquals">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;Performs the following subtraction operation:&lt;br&gt;
 * &lt;br&gt;
 * c = a - b  &lt;br&gt;
 * c&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt; - b&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Matrix C can be the same instance as Matrix A and/or B.
 * &lt;/p&gt;</text>
    <param>a A Matrix. Not modified.</param>
    <param>b A Matrix. Not modified.</param>
    <param>c A Matrix. Modified.</param>
  </javadoc>
  <method type="void" name="sub">
    <scope />
    <declaration type="int" name="length" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs an in-place element by element scalar multiplication.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha;*a&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <param>a The matrix that is to be scaled.  Modified.</param>
    <param>alpha the amount each element is multiplied by.</param>
  </javadoc>
  <method type="void" name="scale">
    <declaration type="int" name="size" />
    <scope />
    <comment>on very small matrices (2 by 2) the call to getNumElements() can slow it down</comment>
    <comment>slightly compared to other libraries since it involves an extra multiplication.</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs an element by element scalar multiplication.&lt;br&gt;
 * &lt;br&gt;
 * b&lt;sub&gt;ij&lt;/sub&gt; = &amp;alpha;*a&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <param>alpha the amount each element is multiplied by.</param>
    <param>a The matrix that is to be scaled.  Not modified.</param>
    <param>b Where the scaled matrix is stored. Modified.</param>
  </javadoc>
  <method type="void" name="scale">
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs an in-place element by element scalar division.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;ij&lt;/sub&gt;/&amp;alpha;
 * &lt;/p&gt;</text>
    <param>a The matrix whose elements are to be divided.  Modified.</param>
    <param>alpha the amount each element is divided by.</param>
  </javadoc>
  <method type="void" name="divide">
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Performs an element by element scalar division.&lt;br&gt;
 * &lt;br&gt;
 * b&lt;sub&gt;ij&lt;/sub&gt; = *a&lt;sub&gt;ij&lt;/sub&gt; /&amp;alpha;
 * &lt;/p&gt;</text>
    <param>alpha the amount each element is divided by.</param>
    <param>a The matrix whose elements are to be divided.  Not modified.</param>
    <param>b Where the results are stored. Modified.</param>
  </javadoc>
  <method type="void" name="divide">
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Changes the sign of every element in the matrix.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = -a&lt;sub&gt;ij&lt;/sub&gt;
 * &lt;/p&gt;</text>
    <param>a A matrix. Modified.</param>
  </javadoc>
  <method type="void" name="changeSign">
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Sets every element in the matrix to the specified value.&lt;br&gt;
 * &lt;br&gt;
 * a&lt;sub&gt;ij&lt;/sub&gt; = value
 * &lt;p&gt;</text>
    <param>a A matrix whose elements are about to be set. Modified.</param>
    <param>value The value each element will have.</param>
  </javadoc>
  <method type="void" name="fill">
    <declaration type="int" name="size" />
    <scope />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Puts the augmented system matrix into reduced row echelon form (RREF).  A matrix is said to be in
 * RREF is the following conditions are true:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;If a row has non-zero entries, then the first non-zero entry is 1.  This is known as the leading one.&lt;/li&gt;
 * &lt;li&gt;If a column contains a leading one then all other entries in that column are zero.&lt;/li&gt;
 * &lt;li&gt;If a row contains a leading 1, then each row above contains a leading 1 further to the left.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * [1] Page 19 in, Otter Bretscherm "Linear Algebra with Applications" Prentice-Hall Inc, 1997
 * &lt;/p&gt;</text>
    <param>A Input matrix.  Unmodified.</param>
    <param>numUnknowns Number of unknowns/columns that are reduced. Set to -1 to default to
 * Math.min(A.numRows,A.numCols), which works for most systems.</param>
    <param>reduced Storage for reduced echelon matrix. If null then a new matrix is returned. Modified.</param>
    <return>Reduced echelon form of A</return>
  </javadoc>
  <method type="DenseMatrix64F" name="rref">
    <scope />
    <declaration type="ReducedRowEchelonForm&lt;DenseMatrix64F&gt;" name="alg" />
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
