<?xml version="1.0" encoding="UTF-8"?>
<class name="EigenOps">
  <javadoc>
    <text>Additional functions related to eigenvalues and eigenvectors of a matrix.</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * Given matrix A and an eigen vector of A, compute the corresponding eigen value.  This is
 * the Rayleigh quotient.&lt;br&gt;
 * &lt;br&gt;
 * x&lt;sup&gt;T&lt;/sup&gt;Ax / x&lt;sup&gt;T&lt;/sup&gt;x
 * &lt;/p&gt;</text>
    <param>A Matrix. Not modified.</param>
    <param>eigenVector An eigen vector of A. Not modified.</param>
    <return>The corresponding eigen value.</return>
  </javadoc>
  <method type="double" name="computeEigenValue">
    <declaration type="double" name="bottom" />
    <declaration type="double" name="top" />
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Given an eigenvalue it computes an eigenvector using inverse iteration:
 * &lt;br&gt;
 * for i=1:MAX {&lt;br&gt;
 * (A - &amp;mu;I)z&lt;sup&gt;(i)&lt;/sup&gt; = q&lt;sup&gt;(i-1)&lt;/sup&gt;&lt;br&gt;
 * q&lt;sup&gt;(i)&lt;/sup&gt; = z&lt;sup&gt;(i)&lt;/sup&gt; / ||z&lt;sup&gt;(i)&lt;/sup&gt;||&lt;br&gt;
 * &amp;lambda;&lt;sup&gt;(i)&lt;/sup&gt; =  q&lt;sup&gt;(i)&lt;/sup&gt;&lt;sup&gt;T&lt;/sup&gt; A  q&lt;sup&gt;(i)&lt;/sup&gt;&lt;br&gt;
 * }&lt;br&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * NOTE: If there is another eigenvalue that is very similar to the provided one then there
 * is a chance of it converging towards that one instead.  The larger a matrix is the more
 * likely this is to happen.
 * &lt;/p&gt;</text>
    <param>A Matrix whose eigenvector is being computed.  Not modified.</param>
    <param>eigenvalue The eigenvalue in the eigen pair.</param>
    <return>The eigenvector or null if none could be found.</return>
  </javadoc>
  <method type="Eigenpair" name="computeEigenVector">
    <declaration type="DenseMatrix64F" name="M" />
    <declaration type="DenseMatrix64F" name="x" />
    <declaration type="DenseMatrix64F" name="b" />
    <declaration type="double" name="origEigenvalue" />
    <declaration type="double" name="threshold" />
    <declaration type="double" name="prevError" />
    <declaration type="boolean" name="hasWorked" />
    <declaration type="LinearSolver&lt;DenseMatrix64F&gt;" name="solver" />
    <declaration type="double" name="perp" />
    <scope>
      <declaration type="boolean" name="failed" />
      <scope />
      <scope />
      <scope />
      <scope>
        <scope>
          <declaration type="double" name="val" />
        </scope>
        <scope />
      </scope>
      <scope>
        <declaration type="double" name="error" />
        <scope>
          <declaration type="double" name="val" />
        </scope>
        <scope />
      </scope>
    </scope>
    <comment>perturb the eigenvalue slightly so that its not an exact solution the first time</comment>
    <comment>eigenvalue -= eigenvalue*UtilEjml.EPS*10;</comment>
    <comment>if the matrix is singular then the eigenvalue is within machine precision</comment>
    <comment>of the true value, meaning that x must also be.</comment>
    <comment>see if solve silently failed</comment>
    <comment>if it failed on the first trial try perturbing it some more</comment>
    <comment>maybe this should be turn into a parameter allowing the user</comment>
    <comment>to configure the wise of each step</comment>
    <comment>otherwise assume that it was so accurate that the matrix was singular</comment>
    <comment>and return that result</comment>
    <comment>compute the residual</comment>
    <comment>if the error increased it is probably converging towards a different</comment>
    <comment>eigenvalue</comment>
    <comment>CommonOps.set(b,1);</comment>
    <comment>see if it has converged</comment>
    <comment>update everything</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Computes the dominant eigen vector for a matrix.  The dominant eigen vector is an
 * eigen vector associated with the largest eigen value.
 * &lt;/p&gt;
 * &lt;p&gt;
 * WARNING: This function uses the power method.  There are known cases where it will not converge.
 * It also seems to converge to non-dominant eigen vectors some times.  Use at your own risk.
 * &lt;/p&gt;</text>
    <param>A A matrix.  Not modified.</param>
  </javadoc>
  <method type="Eigenpair" name="dominantEigenpair">
    <declaration type="EigenPowerMethod" name="power" />
    <comment>TODO maybe do the regular power method, estimate the eigenvalue, then shift invert?</comment>
    <comment>eh maybe 0.1 is a good value.  who knows.</comment>
    <comment>power.getEigenVector();</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Generates a bound for the largest eigen value of the provided matrix using Perron-Frobenius
 * theorem.   This function only applies to non-negative real matrices.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For "stochastic" matrices (Markov process) this should return one for the upper and lower bound.
 * &lt;/p&gt;</text>
    <param>A Square matrix with positive elements.  Not modified.</param>
    <param>bound Where the results are stored.  If null then a matrix will be declared. Modified.</param>
    <return>Lower and upper bound in the first and second elements respectively.</return>
  </javadoc>
  <method type="double[]" name="boundLargestEigenValue">
    <declaration type="double" name="min" />
    <declaration type="double" name="max" />
    <declaration type="int" name="n" />
    <scope>
      <declaration type="double" name="total" />
      <scope>
        <declaration type="double" name="v" />
      </scope>
      <scope />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * A diagonal matrix where real diagonal element contains a real eigenvalue.  If an eigenvalue
 * is imaginary then zero is stored in its place.
 * &lt;/p&gt;</text>
    <param>eig An eigenvalue decomposition which has already decomposed a matrix.</param>
    <return>A diagonal matrix containing the eigenvalues.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="createMatrixD">
    <declaration type="int" name="N" />
    <declaration type="DenseMatrix64F" name="D" />
    <scope>
      <declaration type="Complex64F" name="c" />
      <scope />
    </scope>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Puts all the real eigenvectors into the columns of a matrix.  If an eigenvalue is imaginary
 * then the corresponding eigenvector will have zeros in its column.
 * &lt;/p&gt;</text>
    <param>eig An eigenvalue decomposition which has already decomposed a matrix.</param>
    <return>An m by m matrix containing eigenvectors in its columns.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="createMatrixV">
    <declaration type="int" name="N" />
    <declaration type="DenseMatrix64F" name="V" />
    <scope>
      <declaration type="Complex64F" name="c" />
      <scope>
        <declaration type="DenseMatrix64F" name="v" />
        <scope>
          <scope />
        </scope>
      </scope>
    </scope>
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
</class>
