<?xml version="1.0" encoding="UTF-8"?>
<class name="SingularOps">
  <javadoc>
    <text>Operations related to singular value decomposition.</text>
    <author>Peter Abeles</author>
  </javadoc>
  <javadoc>
    <text>&lt;p&gt;
 * Adjusts the matrices so that the singular values are in descending order.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In most implementations of SVD the singular values are automatically arranged in in descending
 * order.  In EJML this is not the case since it is often not needed and some computations can
 * be saved by not doing that.
 * &lt;/p&gt;</text>
    <param>U Matrix. Modified.</param>
    <param>tranU is U transposed or not.</param>
    <param>W Diagonal matrix with singular values. Modified.</param>
    <param>V Matrix. Modified.</param>
    <param>tranV is V transposed or not.</param>
  </javadoc>
  <method type="void" name="descendingOrder">
    <declaration type="int" name="numSingular" />
    <scope>
      <declaration type="double" name="bigValue" />
      <declaration type="int" name="bigIndex" />
      <scope>
        <declaration type="double" name="v" />
        <scope />
      </scope>
      <scope />
      <declaration type="double" name="tmp" />
      <scope />
      <scope />
    </scope>
    <comment>find the smallest singular value in the submatrix</comment>
    <comment>only swap if the current index is not the smallest</comment>
    <comment>there is at least one uncountable singular value.  just stop here</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Similar to {@link #descendingOrder(org.ejml.data.DenseMatrix64F,boolean,org.ejml.data.DenseMatrix64F,org.ejml.data.DenseMatrix64F,boolean)}but takes in an array of singular values instead.
 * &lt;/p&gt;</text>
    <param>U Matrix. Modified.</param>
    <param>tranU is U transposed or not.</param>
    <param>singularValues Array of singular values. Modified.</param>
    <param>numSingularValues Number of elements in singularValues array</param>
    <param>V Matrix. Modified.</param>
    <param>tranV is V transposed or not.</param>
  </javadoc>
  <method type="void" name="descendingOrder">
    <scope>
      <declaration type="double" name="bigValue" />
      <declaration type="int" name="bigIndex" />
      <scope>
        <declaration type="double" name="v" />
        <scope />
      </scope>
      <scope />
      <declaration type="double" name="tmp" />
      <scope />
      <scope />
    </scope>
    <comment>checkSvdMatrixSize(U, tranU, W, V, tranV);</comment>
    <comment>find the smallest singular value in the submatrix</comment>
    <comment>only swap if the current index is not the smallest</comment>
    <comment>there is at least one uncountable singular value.  just stop here</comment>
  </method>
  <javadoc>
    <text>Checks to see if all the provided matrices are the expected size for an SVD.  If an error is encountered
 * then an exception is thrown.  This automatically handles compact and non-compact formats</text>
  </javadoc>
  <method type="void" name="checkSvdMatrixSize">
    <declaration type="int" name="numSingular" />
    <declaration type="boolean" name="compact" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope />
  </method>
  <method type="void" name="swapRowOrCol">
    <declaration type="double" name="tmp" />
    <scope>
      <scope />
    </scope>
    <scope>
      <scope />
    </scope>
    <comment>swap the rows</comment>
    <comment>swap the columns</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * Returns the null-space from the singular value decomposition. The null space is a set of non-zero vectors that
 * when multiplied by the original matrix return zero.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The null space is found by extracting the columns in V that are associated singular values less than
 * or equal to the threshold. In some situations a non-compact SVD is required.
 * &lt;/p&gt;</text>
    <param>svd A precomputed decomposition.  Not modified.</param>
    <param>nullSpace Storage for null space.  Will be reshaped as needed.  Modified.</param>
    <param>tol Threshold for selecting singular values.  Try UtilEjml.EPS.</param>
    <return>The null space.</return>
  </javadoc>
  <method type="DenseMatrix64F" name="nullSpace">
    <declaration type="int" name="N" />
    <declaration type="double[]" name="s" />
    <declaration type="DenseMatrix64F" name="V" />
    <scope />
    <declaration type="int" name="numVectors" />
    <scope>
      <scope />
    </scope>
    <scope />
    <scope />
    <declaration type="int" name="count" />
    <scope>
      <scope />
    </scope>
    <scope />
    <comment>first determine the size of the null space</comment>
    <comment>declare output data</comment>
    <comment>now extract the vectors</comment>
  </method>
  <javadoc>
    <text>&lt;p&gt;
 * The vector associated will the smallest singular value is returned as the null space
 * of the decomposed system.  A right null space is returned if 'isRight' is set to true,
 * and a left null space if false.
 * &lt;/p&gt;</text>
    <param>svd A precomputed decomposition.  Not modified.</param>
    <param>isRight true for right null space and false for left null space.  Right is more commonly used.</param>
    <param>nullVector Optional storage for a vector for the null space.  Modified.</param>
    <return>Vector in V associated with smallest singular value..</return>
  </javadoc>
  <method type="DenseMatrix64F" name="nullVector">
    <declaration type="int" name="N" />
    <declaration type="double[]" name="s" />
    <declaration type="DenseMatrix64F" name="A" />
    <scope>
      <scope />
      <scope />
    </scope>
    <scope>
      <scope />
      <scope />
    </scope>
    <declaration type="int" name="smallestIndex" />
    <scope>
      <declaration type="double" name="smallestValue" />
      <scope>
        <scope />
      </scope>
    </scope>
    <comment>find the smallest singular value</comment>
    <comment>extract the null space</comment>
  </method>
  <javadoc>
    <text>Extracts the rank of a matrix using a preexisting decomposition.</text>
    <param>svd A precomputed decomposition.  Not modified.</param>
    <param>threshold Tolerance used to determine of a singular value is singular.</param>
    <return>The rank of the decomposed matrix.</return>
  </javadoc>
  <method type="int" name="rank">
    <declaration type="int" name="numRank" />
    <declaration type="double[]" name="w" />
    <declaration type="int" name="N" />
    <scope />
  </method>
  <javadoc>
    <text>Extracts the nullity of a matrix using a preexisting decomposition.</text>
    <param>svd A precomputed decomposition.  Not modified.</param>
    <param>threshold Tolerance used to determine of a singular value is singular.</param>
    <return>The nullity of the decomposed matrix.</return>
  </javadoc>
  <method type="int" name="nullity">
    <declaration type="int" name="ret" />
    <declaration type="double[]" name="w" />
    <declaration type="int" name="N" />
    <declaration type="int" name="numCol" />
    <scope />
  </method>
  <comment>Copyright (c) 2009-2013, Peter Abeles. All Rights Reserved.

 This file is part of Efficient Java Matrix Library (EJML).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http:www.apache.orglicensesLICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</comment>
  <comment>TODO the number of copies can probably be reduced here</comment>
</class>
