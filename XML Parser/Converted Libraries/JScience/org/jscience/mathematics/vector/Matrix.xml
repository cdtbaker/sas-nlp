<?xml version="1.0" encoding="UTF-8"?>
<source package="org.jscience.mathematics.vector">
  <import name="java.util.Comparator" />
  <import name="javolution.context.StackContext" />
  <import name="javolution.lang.MathLib" />
  <import name="javolution.lang.Realtime" />
  <import name="javolution.lang.ValueType" />
  <import name="javolution.text.Text" />
  <import name="javolution.text.TextBuilder" />
  <import name="javolution.xml.XMLFormat" />
  <import name="javolution.xml.stream.XMLStreamException" />
  <import name="org.jscience.mathematics.structure.Field" />
  <import name="org.jscience.mathematics.structure.Ring" />
  <import name="org.jscience.mathematics.structure.VectorSpace" />
  <class name="Matrix" startLine="26">
    <implements name="VectorSpace<Matrix<F>,F>" />
    <implements name="Ring<Matrix<F>>" />
    <implements name="ValueType" />
    <implements name="Realtime" />
    <javadoc>
      <text>* <p> This class represents a rectangular table of elements of a ring-like 
 * algebraic structure.</p>
 * <p> Instances of this class can be used to resolve system of linear equations
 * involving <i>any kind</i> of {@link Field Field} elements
 * (e.g. {@link org.jscience.mathematics.number.Real Real}, {@link org.jscience.mathematics.number.Complex Complex}, {@link org.jscience.physics.amount.Amount Amount&lt;?&gt;},{@link org.jscience.mathematics.function.Function Function}, etc).
 * For example:[code]
 * // Creates a dense matrix (2x2) of Rational numbers.
 * DenseMatrix<Rational> M = DenseMatrix.valueOf(
 * { Rational.valueOf(23, 45), Rational.valueOf(33, 75) },
 * { Rational.valueOf(15, 31), Rational.valueOf(-20, 45)});
 * // Creates a sparse matrix (16x2) of Real numbers.
 * SparseMatrix<Real> M = SparseMatrix.valueOf(
 * SparseVector.valueOf(16, Real.ZERO, 0, Real.valueOf(5)),
 * SparseVector.valueOf(16, Real.ZERO, 15, Real.valueOf(-3)));
 * // Creates a floating-point (64 bits) matrix (3x2).
 * Float64Matrix M = Float64Matrix.valueOf(
 * {{ 1.0, 2.0, 3.0}, { 4.0, 5.0, 6.0}});
 * // Creates a complex single column matrix (1x2).
 * ComplexMatrix M = ComplexMatrix.valueOf(
 * {{ Complex.valueOf(1.0, 2.0), Complex.valueOf(4.0, 5.0)}}).transpose();
 * // Creates an identity matrix (2x2) for modulo integer.
 * SparseMatrix<ModuloInteger> IDENTITY = SparseMatrix.valueOf(
 * DenseVector.valueOf(ModuloInteger.ONE, ModuloInteger.ONE), ModuloInteger.ZERO);
 * [/code]</p>
 * <p> Non-commutative field multiplication is supported. Invertible square 
 * matrices may form a non-commutative field (also called a division
 * ring). In which case this class may be used to resolve system of linear
 * equations with matrix coefficients.</p>
 * <p> Implementation Note: Matrices may use {@link javolution.context.StackContext StackContext} and {@link javolution.context.ConcurrentContext ConcurrentContext} in order to 
 * minimize heap allocation and accelerate calculations on multi-core 
 * systems.</p></text>
      <author><a href="mailto:jean-marie@dautelle.com">Jean-Marie Dautelle</a></author>
      <version>3.3, December 24, 2006</version>
      <see><a href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">
 *      Wikipedia: Matrix (mathematics)</a></see>
    </javadoc>
    <javadoc>
      <text>* Holds the default XML representation for matrices. For example:[code]
 * <DenseMatrix rows="2" columns="2">
 * <Complex real="1.0" imaginary="0.0" />
 * <Complex real="0.0" imaginary="1.0" />
 * <Complex real="0.0" imaginary="0.4" />
 * <Complex real="-5.0" imaginary="-1.0" />
 * </DenseMatrix>[/code]</text>
    </javadoc>
    <method type="void" name="read" startLine="93" endLine="95">
      <comment>Nothing to do.</comment>
    </method>
    <method type="void" name="write" startLine="99" endLine="109">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="104" endLine="108">
        <scope startLine="105" endLine="107" />
      </scope>
    </method>
    <declaration type="XMLFormat<Matrix>" name="XML" />
    <javadoc>
      <text>* Default constructor (for sub-classes).</text>
    </javadoc>
    <method type="constructor" name="Matrix" startLine="115" endLine="116" />
    <method name="getNumberOfRows" type="int" startLine="118" endLine="123" />
    <javadoc>
      <text>* Returns the number of rows <code>m</code> for this matrix.</text>
      <return>m, the number of rows.</return>
    </javadoc>
    <method name="getNumberOfColumns" type="int" startLine="125" endLine="130" />
    <javadoc>
      <text>* Returns the number of columns <code>n</code> for this matrix.</text>
      <return>n, the number of columns.</return>
    </javadoc>
    <method name="get" type="F" startLine="132" endLine="141" />
    <javadoc>
      <text>* Returns a single element from this matrix.</text>
      <param>i the row index (range [0..m[).</param>
      <param>j the column index (range [0..n[).</param>
      <return>the element read at [i,j].</return>
      <throws>IndexOutOfBoundsException <code>
 * ((i < 0) || (i >= m)) || ((j < 0) || (j >= n))</code></throws>
    </javadoc>
    <method name="getRow" type="Vector<F>" startLine="143" endLine="150" />
    <javadoc>
      <text>* Returns the row identified by the specified index in this matrix.</text>
      <param>i the row index (range [0..m[).</param>
      <return>the vector holding the specified row.</return>
      <throws>IndexOutOfBoundsException <code>(i < 0) || (i >= m)</code></throws>
    </javadoc>
    <method name="getColumn" type="Vector<F>" startLine="152" endLine="159" />
    <javadoc>
      <text>* Returns the column identified by the specified index in this matrix.</text>
      <param>j the column index (range [0..n[).</param>
      <return>the vector holding the specified column.</return>
      <throws>IndexOutOfBoundsException <code>(j < 0) || (j >= n)</code></throws>
    </javadoc>
    <method name="getDiagonal" type="Vector<F>" startLine="161" endLine="166" />
    <javadoc>
      <text>* Returns the diagonal vector.</text>
      <return>the vector holding the diagonal elements.</return>
    </javadoc>
    <method name="opposite" type="Matrix<F>" startLine="168" endLine="173" />
    <javadoc>
      <text>* Returns the negation of this matrix.</text>
      <return><code>-this</code>.</return>
    </javadoc>
    <method name="plus" type="Matrix<F>" startLine="175" endLine="182" />
    <javadoc>
      <text>* Returns the sum of this matrix with the one specified.</text>
      <param>that the matrix to be added.</param>
      <return><code>this + that</code>.</return>
      <throws>DimensionException matrices's dimensions are different.</throws>
    </javadoc>
    <javadoc>
      <text>* Returns the difference between this matrix and the one specified.</text>
      <param>that the matrix to be subtracted.</param>
      <return><code>this - that</code>.</return>
      <throws>DimensionException matrices's dimensions are different.</throws>
    </javadoc>
    <method type="Matrix<F>" name="minus" startLine="191" endLine="193" />
    <method name="times" type="Matrix<F>" startLine="195" endLine="201" />
    <javadoc>
      <text>* Returns the product of this matrix by the specified factor.</text>
      <param>k the coefficient multiplier.</param>
      <return><code>this · k</code></return>
    </javadoc>
    <method name="times" type="Vector<F>" startLine="203" endLine="211" />
    <javadoc>
      <text>* Returns the product of this matrix by the specified vector.</text>
      <param>v the vector.</param>
      <return><code>this · v</code></return>
      <throws>DimensionException if <code>
 * v.getDimension() != this.getNumberOfColumns()<code></throws>
    </javadoc>
    <method name="times" type="Matrix<F>" startLine="213" endLine="221" />
    <javadoc>
      <text>* Returns the product of this matrix with the one specified.</text>
      <param>that the matrix multiplier.</param>
      <return><code>this · that</code>.</return>
      <throws>DimensionException if <code>
 * this.getNumberOfColumns() != that.getNumberOfRows()</code>.</throws>
    </javadoc>
    <method name="inverse" type="Matrix<F>" startLine="223" endLine="229" />
    <javadoc>
      <text>* Returns the inverse of this matrix (must be square).</text>
      <return><code>1 / this</code></return>
      <throws>DimensionException if this matrix is not square.</throws>
    </javadoc>
    <javadoc>
      <text>* Returns this matrix divided by the one specified.</text>
      <param>that the matrix divisor.</param>
      <return><code>this / that</code>.</return>
      <throws>DimensionException if that matrix is not square or dimensions 
 * do not match.</throws>
    </javadoc>
    <method type="Matrix<F>" name="divide" startLine="239" endLine="241" />
    <javadoc>
      <text>* Returns the inverse or pseudo-inverse if this matrix if not square.
 * <p> Note: To resolve the equation <code>A * X = B</code>,
 * it is usually faster to calculate <code>A.lu().solve(B)</code>
 * rather than <code>A.inverse().times(B)</code>.</p></text>
      <return>the inverse or pseudo-inverse of this matrix.</return>
    </javadoc>
    <method type="Matrix<F>" name="pseudoInverse" startLine="252" endLine="257">
      <declaration type="Matrix<F>" name="thisTranspose" />
    </method>
    <method name="determinant" type="F" startLine="259" endLine="265" />
    <javadoc>
      <text>* Returns the determinant of this matrix.</text>
      <return>this matrix determinant.</return>
      <throws>DimensionException if this matrix is not square.</throws>
    </javadoc>
    <method name="transpose" type="Matrix<F>" startLine="267" endLine="272" />
    <javadoc>
      <text>* Returns the transpose of this matrix.</text>
      <return><code>A'</code>.</return>
    </javadoc>
    <method name="cofactor" type="F" startLine="274" endLine="285" />
    <javadoc>
      <text>* Returns the cofactor of an element in this matrix. It is the value
 * obtained by evaluating the determinant formed by the elements not in
 * that particular row or column.</text>
      <param>i the row index.</param>
      <param>j the column index.</param>
      <return>the cofactor of <code>THIS[i,j]</code>.</return>
      <throws>DimensionException matrix is not square or its dimension
 * is less than 2.</throws>
    </javadoc>
    <method name="adjoint" type="Matrix<F>" startLine="287" endLine="297" />
    <javadoc>
      <text>* Returns the adjoint of this matrix. It is obtained by replacing each
 * element in this matrix with its cofactor and applying a + or - sign
 * according (-1)**(i+j), and then finding the transpose of the resulting
 * matrix.</text>
      <return>the adjoint of this matrix.</return>
      <throws>DimensionException if this matrix is not square or if
 * its dimension is less than 2.</throws>
    </javadoc>
    <javadoc>
      <text>* Indicates if this matrix is square.</text>
      <return><code>getNumberOfRows() == getNumberOfColumns()</code></return>
    </javadoc>
    <method type="boolean" name="isSquare" startLine="304" endLine="306" />
    <javadoc>
      <text>* Solves this matrix for the specified vector (returns <code>x</code>
 * such as <code>this · x = y</code>).</text>
      <param>y the vector for which the solution is calculated.</param>
      <return><code>x</code> such as <code>this · x = y</code></return>
      <throws>DimensionException if that matrix is not square or dimensions 
 * do not match.</throws>
    </javadoc>
    <method type="Vector<F>" name="solve" startLine="317" endLine="321">
      <declaration type="DenseMatrix<F>" name="M" />
    </method>
    <javadoc>
      <text>* Solves this matrix for the specified matrix (returns <code>x</code>
 * such as <code>this · x = y</code>).</text>
      <param>y the matrix for which the solution is calculated.</param>
      <return><code>x</code> such as <code>this · x = y</code></return>
      <throws>DimensionException if that matrix is not square or dimensions 
 * do not match.</throws>
    </javadoc>
    <method type="Matrix<F>" name="solve" startLine="332" endLine="334">
      <comment>Default implementation.</comment>
    </method>
    <javadoc>
      <text>* Returns this matrix raised at the specified exponent.</text>
      <param>exp the exponent.</param>
      <return><code>this<sup>exp</sup></code></return>
      <throws>DimensionException if this matrix is not square.</throws>
    </javadoc>
    <method type="Matrix<F>" name="pow" startLine="343" endLine="365">
      <scope startLine="344" endLine="360">
        <scope startLine="346" endLine="357">
          <declaration type="Matrix<F>" name="pow2" />
          <declaration type="Matrix<F>" name="result" />
          <scope startLine="349" endLine="355">
            <scope startLine="350" endLine="352" />
          </scope>
        </scope>
        <scope startLine="357" endLine="359" />
        <comment>Iteration.</comment>
      </scope>
      <scope startLine="360" endLine="362">
        <comment>Identity.</comment>
      </scope>
      <scope startLine="362" endLine="364" />
    </method>
    <javadoc>
      <text>* Returns the trace of this matrix.</text>
      <return>the sum of the diagonal elements.</return>
    </javadoc>
    <method type="F" name="trace" startLine="372" endLine="378">
      <declaration type="F" name="sum" />
      <scope startLine="374" endLine="376" />
    </method>
    <method name="tensor" type="Matrix<F>" startLine="380" endLine="390" />
    <javadoc>
      <text>* Returns the linear algebraic matrix tensor product of this matrix
 * and another (Kronecker product). The default implementation returns
 * a {@link DenseMatrix}.</text>
      <param>that the second matrix.</param>
      <return><code>this &otimes; that</code></return>
      <see><a href="http://en.wikipedia.org/wiki/Kronecker_product">
     *         Wikipedia: Kronecker Product</a></see>
    </javadoc>
    <method name="vectorization" type="Vector<F>" startLine="392" endLine="402" />
    <javadoc>
      <text>* Returns the vectorization of this matrix. The vectorization of 
 * a matrix is the column vector obtain by stacking the columns of the
 * matrix on top of one another. The default implementation returns 
 * a {@link DenseVector}.</text>
      <return>the vectorization of this matrix.</return>
      <see><a href="http://en.wikipedia.org/wiki/Vectorization_%28mathematics%29">
     *         Wikipedia: Vectorization.</a></see>
    </javadoc>
    <javadoc>
      <text>* Returns the text representation of this matrix.</text>
      <return>the text representation of this matrix.</return>
    </javadoc>
    <method type="Text" name="toText" startLine="409" endLine="431">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="TextBuilder" name="tmp" />
      <scope startLine="414" endLine="426">
        <scope startLine="416" endLine="421">
          <scope startLine="418" endLine="420" />
        </scope>
        <scope startLine="423" endLine="425" />
      </scope>
      <declaration type="Text" name="txt" />
    </method>
    <javadoc>
      <text>* Returns the text representation of this matrix as a 
 * <code>java.lang.String</code>.</text>
      <return><code>toText().toString()</code></return>
    </javadoc>
    <method type="String" name="toString" startLine="439" endLine="441" />
    <javadoc>
      <text>* Indicates if this matrix can be considered equals to the one 
 * specified using the specified comparator when testing for 
 * element equality. The specified comparator may allow for some 
 * tolerance in the difference between the matrix elements.</text>
      <param>that the matrix to compare for equality.</param>
      <param>cmp the comparator to use when testing for element equality.</param>
      <return><code>true</code> if this matrix and the specified matrix are
 * both matrices with equal elements according to the specified
 * comparator; <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="455" endLine="469">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="462" endLine="467">
        <scope startLine="463" endLine="466" />
      </scope>
    </method>
    <javadoc>
      <text>* Indicates if this matrix is strictly equal to the object specified.</text>
      <param>that the object to compare for equality.</param>
      <return><code>true</code> if this matrix and the specified object are
 * both matrices with equal elements; <code>false</code> otherwise.</return>
      <see>#equals(Matrix,Comparator)</see>
    </javadoc>
    <method type="boolean" name="equals" startLine="479" endLine="496">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="Matrix<?>" name="M" />
      <scope startLine="489" endLine="494">
        <scope startLine="490" endLine="493" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a hash code value for this matrix.
 * Equals objects have equal hash codes.</text>
      <return>this matrix hash code value.</return>
      <see>#equals</see>
    </javadoc>
    <method type="int" name="hashCode" startLine="505" endLine="515">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="code" />
      <scope startLine="509" endLine="513">
        <scope startLine="510" endLine="512" />
      </scope>
    </method>
    <method name="copy" type="Matrix<F>" startLine="517" endLine="524" />
    <javadoc>
      <text>* Returns a copy of this matrix {@link javolution.context.AllocatorContext allocated} 
 * by the calling thread (possibly on the stack).</text>
      <return>an identical and independant copy of this matrix.</return>
    </javadoc>
  </class>
</source>
