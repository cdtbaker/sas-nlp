<?xml version="1.0" encoding="UTF-8"?>
<source package="org.jscience.mathematics.number">
  <import name="java.io.IOException" />
  <import name="javolution.context.ArrayFactory" />
  <import name="javolution.context.ConcurrentContext" />
  <import name="javolution.context.ObjectFactory" />
  <import name="javolution.context.StackContext" />
  <import name="javolution.lang.Configurable" />
  <import name="javolution.lang.MathLib" />
  <import name="javolution.text.Text" />
  <import name="javolution.text.TextBuilder" />
  <import name="javolution.text.TextFormat" />
  <import name="javolution.text.TypeFormat" />
  <import name="javolution.text.TextFormat.Cursor" />
  <import name="javolution.xml.XMLFormat" />
  <import name="javolution.xml.stream.XMLStreamException" />
  <import name="static org.jscience.mathematics.number.Calculus.*" />
  <class name="LargeInteger" extends="Number<LargeInteger>" startLine="28">
    <javadoc>
      <text>* <p> This class represents an immutable integer number of arbitrary size.</p>
 * <p> It has the following advantages over the 
 * <code>java.math.BigInteger</code> class:
 * <ul>
 * <li> Optimized for 64 bits architectures. But still runs significantly 
 * faster on 32 bits processors.</li>
 * <li> Real-time compliant for improved performance and predictability
 * (no garbage generated when executing in {@link javolution.context.StackContext StackContext}).</li>
 * <li> Improved algorithms (e.g. Concurrent Karabutsa multiplication in 
 * O(n<sup>Log3</sup>) instead of O(n<sup>2</sup>).</li>
 * </ul></p>
 * <p> <b>Note:</b> This class uses {@link ConcurrentContext ConcurrentContext}to accelerate calculations on multi-cores systems.</p></text>
      <author><a href="mailto:jean-marie@dautelle.com">Jean-Marie Dautelle</a></author>
      <version>3.3, January 14, 2007</version>
      <see><a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">
 *      Wikipedia: Arbitrary-precision Arithmetic</a></see>
    </javadoc>
    <javadoc>
      <text>* Holds the certainty required when testing for primality
 * (default <code>100</code>, the probability for a composite to
 * pass the primality test is less than <code>2<sup>-100</sup></code>).</text>
    </javadoc>
    <declaration type="Configurable<Integer>" name="PRIME_CERTAINTY" />
    <javadoc>
      <text>* Holds the format for large integers (decimal representation by default).</text>
      <see>#parse(CharSequence,int,TextFormat.Cursor)</see>
      <see>#format(LargeInteger,int,Appendable)</see>
    </javadoc>
    <method type="Appendable" name="format" startLine="72" endLine="74" />
    <method type="LargeInteger" name="parse" startLine="77" endLine="79" />
    <declaration type="TextFormat<LargeInteger>" name="DECIMAL_FORMAT" />
    <scope startLine="81" endLine="83" />
    <javadoc>
      <text>* Holds factory for LargeInteger with variable size arrays.</text>
    </javadoc>
    <method type="LargeInteger" name="create" startLine="91" endLine="93" />
    <declaration type="ArrayFactory<LargeInteger>" name="ARRAY_FACTORY" />
    <javadoc>
      <text>* Holds the factory for LargeInteger with no intrinsic array (wrapper instances).</text>
    </javadoc>
    <method type="LargeInteger" name="create" startLine="103" endLine="105" />
    <declaration type="ObjectFactory<LargeInteger>" name="NO_ARRAY_FACTORY" />
    <javadoc>
      <text>* Holds the default XML representation for large integers.
 * This representation consists of a simple <code>value</code> attribute
 * holding the {@link #toText() textual} representation.</text>
    </javadoc>
    <method type="LargeInteger" name="newInstance" startLine="119" endLine="121" />
    <method type="void" name="write" startLine="124" endLine="126" />
    <method type="void" name="read" startLine="128" endLine="130">
      <comment>Nothing to do, immutable.</comment>
    </method>
    <declaration type="XMLFormat<LargeInteger>" name="XML" />
    <javadoc>
      <text>* The large integer representing the additive identity.</text>
    </javadoc>
    <declaration type="LargeInteger" name="ZERO" />
    <javadoc>
      <text>* The large integer representing the multiplicative identity.</text>
    </javadoc>
    <declaration type="LargeInteger" name="ONE" />
    <scope startLine="142" endLine="145" />
    <javadoc>
      <text>* Holds Long.MIN_VALUE</text>
    </javadoc>
    <declaration type="LargeInteger" name="LONG_MIN_VALUE" />
    <scope startLine="151" endLine="155" />
    <javadoc>
      <text>* Holds five.</text>
    </javadoc>
    <declaration type="LargeInteger" name="FIVE" />
    <scope startLine="161" endLine="164" />
    <javadoc>
      <text>* Holds the remainder after a {@link #divide} operation.</text>
    </javadoc>
    <declaration type="LargeInteger" name="_remainder" />
    <javadoc>
      <text>* Indicates if this large integer is negative.</text>
    </javadoc>
    <declaration type="boolean" name="_isNegative" />
    <javadoc>
      <text>* The size of this large integer in words. 
 * The most significand word different from 0 is at index: _size-1</text>
    </javadoc>
    <declaration type="int" name="_size" />
    <javadoc>
      <text>* This large integer positive words (63 bits). 
 * Least significant word first (index 0).</text>
    </javadoc>
    <declaration type="long[]" name="_words" />
    <javadoc>
      <text>* Default constructor (no words array).</text>
    </javadoc>
    <method type="constructor" name="LargeInteger" startLine="191" endLine="192" />
    <javadoc>
      <text>* Creates a large integer with the specified 63 bits word capacity.</text>
      <link>wordLength the internal positive <code>long</code> array length.</link>
    </javadoc>
    <method type="constructor" name="LargeInteger" startLine="199" endLine="201" />
    <javadoc>
      <text>* Returns the large integer of specified <code>long</code> value.</text>
      <param>value the <code>long</code> value.</param>
      <return>the corresponding large integer number.</return>
    </javadoc>
    <method type="LargeInteger" name="valueOf" startLine="209" endLine="219">
      <declaration type="LargeInteger" name="li" />
      <declaration type="boolean" name="negative" />
    </method>
    <javadoc>
      <text>* Returns the large integer of specified two's-complement binary
 * representation. The input array is assumed to be in <i>big-endian</i>
 * byte-order: the most significant byte is at the offset position.</text>
      <param>bytes the binary representation (two's-complement).</param>
      <param>offset the offset at which to start reading the bytes.</param>
      <param>length the maximum number of bytes to read.</param>
      <return>the corresponding large integer number.</return>
      <throws>IndexOutOfBoundsException 
 * if <code>offset + length > bytes.length</code></throws>
      <see>#toByteArray</see>
    </javadoc>
    <method type="LargeInteger" name="valueOf" startLine="234" endLine="267">
      <declaration type="LargeInteger" name="li" />
      <declaration type="boolean" name="isNegative" />
      <declaration type="int" name="wordIndex" />
      <declaration type="int" name="bitIndex" />
      <scope startLine="242" endLine="251">
        <declaration type="long" name="bits" />
        <scope startLine="244" endLine="246" />
        <scope startLine="246" endLine="250" />
        <comment>End of word reached.</comment>
        <comment>In range [-8..-1]</comment>
      </scope>
      <scope startLine="253" endLine="256" />
      <scope startLine="262" endLine="265">
        <comment>Adds ONE.</comment>
      </scope>
      <comment>Ensures result is large enough (takes into account potential</comment>
      <comment>extra bits during negative to positive conversion).</comment>
      <comment>Calculates size.</comment>
      <comment>special case for -1</comment>
      <comment>Converts one's-complement to two's-complement if negative.</comment>
    </method>
    <javadoc>
      <text>* Returns the two's-complement binary representation of this 
 * large integer. The output array is in <i>big-endian</i>
 * byte-order: the most significant byte is at the offset position.</text>
      <param>bytes the bytes to hold the binary representation 
 * (two's-complement) of this large integer.</param>
      <param>offset the offset at which to start writing the bytes.</param>
      <return>the number of bytes written.</return>
      <throws>IndexOutOfBoundsException 
 * if <code>bytes.length < (bitLength() >> 3) + 1</code></throws>
      <see>#valueOf(byte[],int,int)</see>
      <see>#bitLength</see>
    </javadoc>
    <method type="int" name="toByteArray" startLine="283" endLine="326">
      <declaration type="int" name="bytesLength" />
      <declaration type="int" name="wordIndex" />
      <declaration type="int" name="bitIndex" />
      <scope startLine="287" endLine="306">
        <declaration type="long" name="word" />
        <declaration type="long" name="borrow" />
        <scope startLine="291" endLine="305">
          <scope startLine="292" endLine="295" />
          <scope startLine="295" endLine="304">
            <declaration type="byte" name="bits" />
          </scope>
        </scope>
        <comment>-1 if borrow</comment>
        <comment>End of word reached.</comment>
        <comment>-1 if borrow</comment>
        <comment>In range [-8..-1]</comment>
      </scope>
      <scope startLine="306" endLine="324">
        <scope startLine="307" endLine="321">
          <declaration type="long" name="word" />
          <scope startLine="309" endLine="320">
            <scope startLine="310" endLine="313" />
            <scope startLine="313" endLine="319">
              <declaration type="byte" name="bits" />
            </scope>
          </scope>
        </scope>
        <scope startLine="321" endLine="323" />
        <comment>End of word reached.</comment>
        <comment>In range [-8..-1]</comment>
        <comment>ZERO</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the large integer for the specified character sequence 
 * using the current {@link TextFormat#getInstance(Class) format}.</text>
      <param>csq the character sequence to parse.</param>
      <return><code>TextFormat.getInstance(LargeInteger.class).parse(csq)</code></return>
      <throws>NumberFormatException if error when parsing.</throws>
    </javadoc>
    <method type="LargeInteger" name="valueOf" startLine="336" endLine="338" />
    <javadoc>
      <text>* Returns the large integer for the specified character sequence in
 * the specified radix.</text>
      <param>csq the character sequence to parse.</param>
      <param>radix the radix of the representation.</param>
      <return><code>LargeInteger.parse(csq, radix, cursor)</code></return>
      <throws>NumberFormatException if error when parsing.</throws>
    </javadoc>
    <method type="LargeInteger" name="valueOf" startLine="349" endLine="359">
      <declaration type="Cursor" name="cursor" />
      <scope startLine="351" endLine="353" />
      <scope startLine="353" endLine="358" />
    </method>
    <javadoc>
      <text>* Returns the large integer corresponding to the specified 
 * <code>java.math.BigInteger</code> instance.</text>
      <param>bigInteger the big integer instance.</param>
      <return>the large integer having the same value.</return>
    </javadoc>
    <method type="LargeInteger" name="valueOf" startLine="368" endLine="371">
      <declaration type="byte[]" name="bytes" />
    </method>
    <javadoc>
      <text>* Indicates if this large integer is greater than {@link #ZERO}({@link #ZERO}is not included).</text>
      <return><code>this > ZERO</code></return>
    </javadoc>
    <method type="boolean" name="isPositive" startLine="379" endLine="381" />
    <javadoc>
      <text>* Indicates if this large integer is less than {@link #ZERO}.</text>
      <return><code>this < ZERO</code></return>
    </javadoc>
    <method type="boolean" name="isNegative" startLine="388" endLine="390" />
    <javadoc>
      <text>* Indicates if this large integer is equal to {@link #ZERO}.</text>
      <return><code>this == ZERO</code></return>
    </javadoc>
    <method type="boolean" name="isZero" startLine="397" endLine="399" />
    <javadoc>
      <text>* Indicates if this large integer is an even number.</text>
      <return><code>(this & 1) == ZERO</code></return>
    </javadoc>
    <method type="boolean" name="isEven" startLine="406" endLine="408" />
    <javadoc>
      <text>* Indicates if this large integer is an odd number.</text>
      <return><code>(this & 1) != ZERO</code></return>
    </javadoc>
    <method type="boolean" name="isOdd" startLine="415" endLine="417" />
    <javadoc>
      <text>* Indicates if this large integer is probably prime.</text>
      <return><code>true</code> if this large integer is probable prime;
 * <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="isProbablyPrime" startLine="425" endLine="427" />
    <javadoc>
      <text>* Returns the minimal number of bits to represent this large integer
 * in the minimal two's-complement (sign excluded).</text>
      <return>the length of this integer in bits (sign excluded).</return>
    </javadoc>
    <method type="int" name="bitLength" startLine="435" endLine="442">
      <declaration type="int" name="n" />
      <declaration type="int" name="bitLength" />
    </method>
    <javadoc>
      <text>* Returns the minimal number of decimal digits necessary to represent 
 * this large integer (sign excluded).</text>
      <return>the maximum number of digits.</return>
    </javadoc>
    <method type="int" name="digitLength" startLine="450" endLine="458">
      <declaration type="int" name="bitLength" />
      <declaration type="int" name="min" />
      <declaration type="int" name="max" />
    </method>
    <declaration type="double" name="BITS_TO_DIGITS" />
    <javadoc>
      <text>* Indicates if this number is a power of two (equals to 2<sup>
 * ({@link #bitLength bitLength()} - 1)</sup>).</text>
      <return><code>true</code> if this number is a power of two; 
 * <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="isPowerOfTwo" startLine="469" endLine="479">
      <declaration type="int" name="n" />
      <scope startLine="473" endLine="476" />
      <declaration type="int" name="bitLength" />
    </method>
    <javadoc>
      <text>* Returns the index of the lowest-order one bit in this large integer
 * or <code>-1</code> if <code>this.equals(ZERO)</code>.</text>
      <return>the index of the rightmost bit set or <code>-1</code></return>
    </javadoc>
    <method type="int" name="getLowestSetBit" startLine="487" endLine="499">
      <scope startLine="490" endLine="498">
        <declaration type="long" name="w" />
        <scope startLine="494" endLine="497" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the final undivided part after division that is less or of 
 * lower degree than the divisor. This value is only set by the {@link #divide} operation and is not considered as part of 
 * this large integer (ignored by all methods).</text>
      <return>the remainder of the division for which this large integer
 * is the quotient.</return>
    </javadoc>
    <method type="LargeInteger" name="getRemainder" startLine="510" endLine="512" />
    <javadoc>
      <text>* Indicates if this large integer is larger than the one
 * specified in absolute value.</text>
      <param>that the integer to be compared with.</param>
      <return><code>this.abs().compareTo(that.abs()) > 0</code>.</return>
    </javadoc>
    <method type="boolean" name="isLargerThan" startLine="521" endLine="525" />
    <javadoc>
      <text>* Returns the absolute value of this large integer.</text>
      <return><code>|this|</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="abs" startLine="532" endLine="536" />
    <javadoc>
      <text>* Returns the opposite of this large integer.</text>
      <return><code>-this</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="opposite" startLine="543" endLine="549">
      <declaration type="LargeInteger" name="li" />
    </method>
    <javadoc>
      <text>* Returns the sum of this large integer with the specified 
 * <code>long</code> integer (convenience method)</text>
      <param>value the <code>long</code> integer being added.</param>
      <return><code>this + value</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="plus" startLine="558" endLine="560" />
    <javadoc>
      <text>* Returns the sum of this large integer with the one specified.</text>
      <param>that the integer to be added.</param>
      <return><code>this + that</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="plus" startLine="568" endLine="578">
      <declaration type="LargeInteger" name="li" />
      <comment>Adds smallest in size to largest.</comment>
      <comment>Switches that sign.</comment>
    </method>
    <javadoc>
      <text>* Returns the difference between this large integer and the one
 * specified.</text>
      <param>that the integer to be subtracted.</param>
      <return><code>this - that</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="minus" startLine="587" endLine="597">
      <declaration type="LargeInteger" name="li" />
      <comment>Switches that sign.</comment>
      <comment>Always subtract the smallest to the largest.</comment>
    </method>
    <javadoc>
      <text>* Returns the difference between this large integer and the specified
 * value</text>
      <param>value the value to be subtracted.</param>
      <return><code>this - value</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="minus" startLine="606" endLine="608" />
    <javadoc>
      <text>* Returns the product of this large integer with the one specified.</text>
      <param>that the large integer multiplier.</param>
      <return><code>this · that</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="times" startLine="616" endLine="671">
      <scope startLine="621" endLine="627">
        <declaration type="LargeInteger" name="li" />
        <comment>Conventional multiplication.</comment>
        <comment>Karatsuba (sequential).</comment>
      </scope>
      <scope startLine="627" endLine="643">
        <declaration type="int" name="n" />
        <declaration type="LargeInteger" name="b" />
        <declaration type="LargeInteger" name="a" />
        <declaration type="LargeInteger" name="d" />
        <declaration type="LargeInteger" name="c" />
        <declaration type="LargeInteger" name="ab" />
        <declaration type="LargeInteger" name="cd" />
        <declaration type="LargeInteger" name="abcd" />
        <declaration type="LargeInteger" name="ac" />
        <declaration type="LargeInteger" name="bd" />
        <comment>this = a + 2^(n*63) b, that = c + 2^(n*63) d</comment>
        <comment>Optimization for square (a == c, b == d).</comment>
        <comment>li = a*c + ((a+b)*(c+d)-(a*c+b*d)) 2^n + b*d 2^2n</comment>
        <comment>Karatsuba (concurrent).</comment>
      </scope>
      <scope startLine="643" endLine="670">
        <declaration type="int" name="n" />
        <declaration type="LargeInteger" name="b" />
        <declaration type="LargeInteger" name="a" />
        <declaration type="LargeInteger" name="d" />
        <declaration type="LargeInteger" name="c" />
        <declaration type="LargeInteger" name="ab" />
        <declaration type="LargeInteger" name="cd" />
        <declaration type="MultiplyLogic" name="abcd" />
        <declaration type="MultiplyLogic" name="ac" />
        <declaration type="MultiplyLogic" name="bd" />
        <scope startLine="657" endLine="661" />
        <scope startLine="661" endLine="663" />
        <declaration type="LargeInteger" name="result" />
        <comment>this = a + 2^(63*n) b, that = c + 2^(63*n) d</comment>
        <comment>Optimization for square (a == c, b == d).</comment>
        <comment>this = a + 2^n b,   that = c + 2^n d</comment>
        <comment>result = a*c + ((a+b)*(c+d)-(a*c+b*d)) 2^n + b*d 2^2n</comment>
      </scope>
      <comment>Always multiply the smallest to the largest.</comment>
      <comment>Direct times(long) multiplication.</comment>
    </method>
    <method type="LargeInteger" name="high" startLine="673" endLine="679">
      <declaration type="LargeInteger" name="li" />
      <comment>this.shiftRight(w * 63)</comment>
    </method>
    <method type="LargeInteger" name="low" startLine="681" endLine="692">
      <declaration type="LargeInteger" name="li" />
      <scope startLine="685" endLine="690">
        <scope startLine="686" endLine="689" />
        <comment>Else zero.</comment>
      </scope>
      <comment>this.minus(high(w).shiftLeft(w * 63));</comment>
    </method>
    <method type="LargeInteger" name="shiftWordLeft" startLine="694" endLine="705">
      <declaration type="LargeInteger" name="li" />
      <scope startLine="700" endLine="702" />
      <comment>this.minus(high(w).shiftLeft(w * 63));</comment>
    </method>
    <javadoc>
      <text>* Returns the product of this large integer with the specified 
 * <code>long</code> multiplier.</text>
      <param>multiplier the <code>long</code> multiplier.</param>
      <return><code>this · multiplier</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="times" startLine="714" endLine="725">
      <declaration type="boolean" name="isNegative" />
      <declaration type="LargeInteger" name="li" />
      <comment>Size 2.</comment>
    </method>
    <javadoc>
      <text>* Returns this large integer divided by the one specified (integer
 * division). The remainder of this division is accessible using {@link #getRemainder}.</text>
      <param>that the integer divisor.</param>
      <return><code>this / that</code> and <code>this % that</code> 
 * ({@link #getRemainder})</return>
      <throws>ArithmeticException if <code>that.equals(ZERO)</code></throws>
    </javadoc>
    <method type="LargeInteger" name="divide" startLine="737" endLine="777">
      <declaration type="LargeInteger" name="result" />
      <declaration type="LargeInteger" name="remainder" />
      <declaration type="LargeInteger" name="thisAbs" />
      <declaration type="LargeInteger" name="thatAbs" />
      <declaration type="int" name="precision" />
      <scope startLine="745" endLine="748" />
      <scope startLine="748" endLine="768">
        <declaration type="LargeInteger" name="thatReciprocal" />
        <scope startLine="755" endLine="761" />
        <scope startLine="761" endLine="767" />
        <comment>Calculates remainder, corrects for result +/- 1 error.</comment>
      </scope>
      <declaration type="LargeInteger" name="li" />
      <comment>Setups result and remainder.</comment>
    </method>
    <javadoc>
      <text>* Returns this large integer divided by the specified <code>int</code>
 * divisor. The remainder of this division is accessible using {@link #getRemainder}.</text>
      <param>divisor the <code>int</code> divisor.</param>
      <return><code>this / divisor</code> and <code>this % divisor</code>
 * ({@link #getRemainder})</return>
      <throws>ArithmeticException if <code>divisor == 0</code></throws>
    </javadoc>
    <method type="LargeInteger" name="divide" startLine="789" endLine="808">
      <scope startLine="792" endLine="799">
        <declaration type="LargeInteger" name="li" />
        <comment>abs(divisor) would overflow.</comment>
      </scope>
      <declaration type="LargeInteger" name="li" />
      <declaration type="long" name="rem" />
    </method>
    <javadoc>
      <text>* Returns the remainder of the division of this large integer with 
 * the one specified (convenience method equivalent to 
 * <code>this.divide(that).getRemainder()</code>).</text>
      <param>that the value by which this integer is to be divided, and the
 * remainder returned.</param>
      <return><code>this % that</code></return>
      <throws>ArithmeticException if <code>that.equals(ZERO)</code></throws>
      <see>#divide(LargeInteger)</see>
    </javadoc>
    <method type="LargeInteger" name="remainder" startLine="821" endLine="823" />
    <javadoc>
      <text>* Returns a scaled approximation of <code>1 / this</code>.</text>
      <param>precision the requested precision (reciprocal error being ± 1).</param>
      <return><code>2<sup>(precision + this.bitLength())</sup> / this</code></return>
      <throws>ArithmeticException if <code>this.isZero()</code></throws>
    </javadoc>
    <method type="LargeInteger" name="inverseScaled" startLine="832" endLine="848">
      <scope startLine="833" endLine="838">
        <declaration type="long" name="divisor" />
        <declaration type="long" name="dividend" />
        <comment>Straight calculation.</comment>
        <comment>Newton iteration (x = 2 * x - x^2 * this).</comment>
      </scope>
      <scope startLine="838" endLine="847">
        <declaration type="LargeInteger" name="x" />
        <declaration type="LargeInteger" name="thisTrunc" />
        <declaration type="LargeInteger" name="prod" />
        <declaration type="int" name="diff" />
        <declaration type="LargeInteger" name="prodTrunc" />
        <declaration type="LargeInteger" name="xPad" />
        <declaration type="LargeInteger" name="tmp" />
        <comment>Estimate.</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the integer square root of this integer.</text>
      <return><code>k<code> such as <code>k^2 <= this < (k + 1)^2</code></return>
      <throws>ArithmeticException if this integer is negative.</throws>
    </javadoc>
    <method type="LargeInteger" name="sqrt" startLine="856" endLine="878">
      <declaration type="int" name="bitLength" />
      <scope startLine="862" endLine="875">
        <declaration type="LargeInteger" name="k" />
        <scope startLine="865" endLine="874">
          <declaration type="LargeInteger" name="newK" />
          <scope startLine="867" endLine="872">
            <scope startLine="868" endLine="870" />
          </scope>
        </scope>
        <comment>First approximation.</comment>
      </scope>
      <scope startLine="875" endLine="877" />
    </method>
    <javadoc>
      <text>* Returns this large integer modulo the specified large integer. 
 * <p> Note: The result as the same sign as the divisor unlike the Java 
 * remainder (%) operator (which as the same sign as the dividend).</p></text>
      <param>m the modulus.</param>
      <return><code>this mod m</code></return>
      <see>#getRemainder()</see>
    </javadoc>
    <method type="LargeInteger" name="mod" startLine="890" endLine="894">
      <declaration type="LargeInteger" name="li" />
    </method>
    <javadoc>
      <text>* Returns the large integer whose value is <code>(this<sup>-1</sup> mod m)
 * </code>.</text>
      <param>m the modulus.</param>
      <return><code>this<sup>-1</sup> mod m</code>.</return>
      <throws>ArithmeticException <code> m &lt;= 0</code>, or this integer
 * has no multiplicative inverse mod m (that is, this integer
 * is not <i>relatively prime</i> to m).</throws>
    </javadoc>
    <method type="LargeInteger" name="modInverse" startLine="906" endLine="938">
      <scope startLine="910" endLine="935">
        <declaration type="LargeInteger" name="a" />
        <declaration type="LargeInteger" name="b" />
        <declaration type="LargeInteger" name="p" />
        <declaration type="LargeInteger" name="q" />
        <declaration type="LargeInteger" name="r" />
        <declaration type="LargeInteger" name="s" />
        <scope startLine="918" endLine="930">
          <declaration type="LargeInteger" name="quot" />
          <declaration type="LargeInteger" name="c" />
          <declaration type="LargeInteger" name="new_r" />
          <declaration type="LargeInteger" name="new_s" />
        </scope>
        <comment>Extended Euclidian Algorithm</comment>
        <comment>(a != 1) || (a != -1)</comment>
      </scope>
      <scope startLine="935" endLine="937" />
    </method>
    <javadoc>
      <text>* Returns this large integer raised at the specified exponent modulo 
 * the specified modulus.</text>
      <param>exp the exponent.</param>
      <param>m the modulus.</param>
      <return><code>this<sup>exp</sup> mod m</code></return>
      <throws>ArithmeticException <code>m &lt;= 0</code></throws>
      <see>#modInverse</see>
    </javadoc>
    <method type="LargeInteger" name="modPow" startLine="950" endLine="975">
      <scope startLine="953" endLine="970">
        <scope startLine="955" endLine="967">
          <declaration type="LargeInteger" name="result" />
          <declaration type="LargeInteger" name="pow2" />
          <scope startLine="958" endLine="965">
            <scope startLine="959" endLine="962" />
          </scope>
        </scope>
        <scope startLine="967" endLine="969" />
        <comment>Iteration.</comment>
      </scope>
      <scope startLine="970" endLine="972">
        <comment>exp == 0</comment>
      </scope>
      <scope startLine="972" endLine="974" />
    </method>
    <javadoc>
      <text>* Returns the greatest common divisor of this large integer and 
 * the one specified.</text>
      <param>that the other number to compute the GCD with.</param>
      <return>a positive number or {@link #ZERO} if
 * <code>(this.isZero() && that.isZero())</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="gcd" startLine="985" endLine="1031">
      <declaration type="LargeInteger" name="u" />
      <declaration type="LargeInteger" name="v" />
      <scope startLine="997" endLine="1004">
        <declaration type="LargeInteger" name="tmp" />
        <declaration type="LargeInteger" name="rem" />
      </scope>
      <declaration type="int" name="uShift" />
      <declaration type="int" name="vShift" />
      <scope startLine="1014" endLine="1029">
        <scope startLine="1017" endLine="1019" />
        <scope startLine="1019" endLine="1024">
          <declaration type="LargeInteger" name="tmp" />
        </scope>
        <comment>Now u and v are both odd, so diff(u, v) is even.</comment>
        <comment>Let u = min(u, v), v = diff(u, v)/2.</comment>
        <comment>Swaps.</comment>
      </scope>
      <comment>Works with local (modifiable) copies of the inputs.</comment>
      <comment>abs()</comment>
      <comment>abs()</comment>
      <comment>Euclidian algorithm until u, v about the same size.</comment>
      <comment>Binary GCD Implementation adapted from</comment>
      <comment>http:en.wikipedia.org/wiki/Binary_GCD_algorithm</comment>
      <comment>From here on, u is always odd.</comment>
    </method>
    <method type="void" name="shiftRightSelf" startLine="1033" endLine="1037" />
    <method type="void" name="shiftRightSelf" startLine="1039" endLine="1045">
      <declaration type="int" name="wordShift" />
      <declaration type="int" name="bitShift" />
      <comment>n - wordShift * 63</comment>
    </method>
    <method type="void" name="subtract" startLine="1047" endLine="1050">
      <comment>this >= that</comment>
    </method>
    <javadoc>
      <text>* Returns the value of this large integer after performing a binary
 * shift to left. The shift distance, <code>n</code>, may be negative,
 * in which case this method performs a right shift.</text>
      <param>n the shift distance, in bits.</param>
      <return><code>this &lt;&lt; n</code>.</return>
      <see>#shiftRight</see>
    </javadoc>
    <method type="LargeInteger" name="shiftLeft" startLine="1061" endLine="1073">
      <declaration type="int" name="wordShift" />
      <declaration type="int" name="bitShift" />
      <declaration type="LargeInteger" name="li" />
    </method>
    <javadoc>
      <text>* Returns the value of this large integer after performing a binary
 * shift to right with sign extension <code>(-1 >> 1 == -1)</code>.
 * The shift distance, <code>n</code>, may be negative, in which case 
 * this method performs a {@link #shiftLeft(int)}.</text>
      <param>n the shift distance, in bits.</param>
      <return><code>this &gt;&gt; n</code>.</return>
    </javadoc>
    <method type="LargeInteger" name="shiftRight" startLine="1084" endLine="1088">
      <declaration type="LargeInteger" name="li" />
    </method>
    <method type="boolean" name="isShiftRightCorrection" startLine="1092" endLine="1102">
      <declaration type="int" name="wordShift" />
      <declaration type="int" name="bitShift" />
      <declaration type="int" name="i" />
      <declaration type="boolean" name="bitsLost" />
      <scope startLine="1098" endLine="1100" />
      <comment>n - wordShift * 63</comment>
    </method>
    <javadoc>
      <text>* Returns the value of this large integer after multiplication by 
 * a power of two. This method is equivalent to {@link #shiftLeft(int)}for positive <code>n</code>; but is different from {@link #shiftRight(int)} for negative <code>n</code> as no sign 
 * extension is performed (<code>-1 >>> 1 == 0</code>).</text>
      <param>n the power of 2 exponent.</param>
      <return><code>this · 2<sup>n</sup></code>.</return>
    </javadoc>
    <method type="LargeInteger" name="times2pow" startLine="1114" endLine="1127">
      <declaration type="int" name="wordShift" />
      <declaration type="int" name="bitShift" />
      <declaration type="LargeInteger" name="li" />
      <comment>Works with positive n.</comment>
      <comment>n - wordShift * 63</comment>
      <comment>All bits have been shifted.</comment>
    </method>
    <javadoc>
      <text>* Returns the value of this large integer after multiplication by 
 * a power of ten. For example:[code]
 * LargeInteger billion = LargeInteger.ONE.times10pow(9); // 1E9
 * LargeInteger million = billion.times10pow(-3);[/code]</text>
      <param>n the decimal exponent.</param>
      <return><code>this · 10<sup>n</sup></code></return>
    </javadoc>
    <method type="LargeInteger" name="times10pow" startLine="1138" endLine="1180">
      <scope startLine="1141" endLine="1159">
        <declaration type="int" name="bitLength" />
        <declaration type="LargeInteger" name="li" />
        <declaration type="int" name="i" />
        <scope startLine="1148" endLine="1152" />
        <declaration type="int" name="wordShift" />
        <declaration type="int" name="bitShift" />
        <comment>Approx.</comment>
        <comment>Multiplies by 2^n</comment>
        <comment>n - 63 * wordShift</comment>
        <comment>n < 0</comment>
      </scope>
      <scope startLine="1159" endLine="1179">
        <declaration type="int" name="wordShift" />
        <declaration type="int" name="bitShift" />
        <declaration type="LargeInteger" name="li" />
        <scope startLine="1169" endLine="1176">
          <declaration type="int" name="i" />
          <scope startLine="1172" endLine="1174" />
        </scope>
        <comment>Divides by 2^n</comment>
        <comment>n - 63 * wordShift</comment>
        <comment>All bits would be shifted.</comment>
        <comment>Divides by 5^n</comment>
      </scope>
    </method>
    <declaration type="double" name="DIGITS_TO_BITS" />
    <declaration type="int[]" name="INT_POW_5" />
    <declaration type="long[]" name="LONG_POW_5" />
    <javadoc>
      <text>* Compares this large integer against the specified object.</text>
      <param>that the object to compare with.</param>
      <return><code>true</code> if the objects are the same; <code>false</code>
 * otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="1203" endLine="1209">
      <declaration type="LargeInteger" name="li" />
    </method>
    <javadoc>
      <text>* Compares this large integer against the specified <code>long</code>
 * value.</text>
      <param>value <code>long</code> value to compare with.</param>
      <return><code>true</code> if this large integer has the specified value;
 * <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="1219" endLine="1225" />
    <javadoc>
      <text>* Returns the hash code for this large integer number.</text>
      <return>the hash code value.</return>
    </javadoc>
    <method type="int" name="hashCode" startLine="1232" endLine="1240">
      <declaration type="long" name="code" />
      <scope startLine="1236" endLine="1238" />
      <comment>1327144033 is just an appropriately large prime;</comment>
      <comment>1050537101 is 263 mod 1327144033 . The result is this.mod(1327144033) .</comment>
    </method>
    <javadoc>
      <text>* Returns the low order bits of this large integer as a <code>long</code>.
 * <p>Note: This conversion can lose information about the overall magnitude
 * of the integer value and may return a result with the opposite 
 * sign.</p></text>
      <return>the numeric value represented by this integer after conversion
 * to type <code>long</code>.</return>
    </javadoc>
    <method type="long" name="longValue" startLine="1252" endLine="1257">
      <comment>bitLength > 63 bits.</comment>
    </method>
    <javadoc>
      <text>* Returns the value of this large integer as a <code>double</code>.</text>
      <return>the numeric value represented by this integer after conversion
 * to type <code>double</code>.</return>
    </javadoc>
    <method type="double" name="doubleValue" startLine="1265" endLine="1279">
      <declaration type="int" name="n" />
      <declaration type="int" name="bitLength" />
      <declaration type="int" name="shift" />
      <declaration type="LargeInteger" name="int63" />
      <declaration type="double" name="d" />
      <comment>Calculates bits length (ignores sign).</comment>
      <comment>Keep 63 most significant bits.</comment>
    </method>
    <javadoc>
      <text>* Compares two large integers numerically.</text>
      <param>that the integer to compare with.</param>
      <return>-1, 0 or 1 as this integer is numerically less than, equal to,
 * or greater than <code>that</code>.</return>
      <throws>ClassCastException <code>that</code> is not a 
 * large integer.</throws>
    </javadoc>
    <method type="int" name="compareTo" startLine="1290" endLine="1304">
      <comment>Compares sign.</comment>
      <comment>Same sign, compares size.</comment>
      <comment>Same size.</comment>
    </method>
    <javadoc>
      <text>* Compares this large integer to the specified <code>long</code> value.</text>
      <param>value the <code>long</code> value to compare with.</param>
      <return>-1, 0 or 1 as this integer is numerically less than, equal to,
 * or greater than the specified value.</return>
    </javadoc>
    <method type="int" name="compareTo" startLine="1313" endLine="1320">
      <declaration type="long" name="thisValue" />
      <comment>size <= 1</comment>
    </method>
    <method type="LargeInteger" name="copy" startLine="1323" endLine="1333">
      <declaration type="LargeInteger" name="li" />
      <scope startLine="1327" endLine="1330" />
    </method>
    <javadoc>
      <text>* Returns the text representation of this number using the current  {@link TextFormat#getInstance(Class) format}.</text>
      <return><code>TextFormat.getInstance(LargeInteger.class).format(this)</code></return>
    </javadoc>
    <method type="Text" name="toText" startLine="1345" endLine="1347" />
    <javadoc>
      <text>* Returns the text representation of this number in the specified radix.</text>
      <param>radix the radix of the representation.</param>
      <return>the text representation of this number in the specified radix.</return>
    </javadoc>
    <method type="Text" name="toText" startLine="1355" endLine="1365">
      <declaration type="TextBuilder" name="tmp" />
      <scope startLine="1357" endLine="1360" />
      <scope startLine="1360" endLine="1362" />
      <scope startLine="1362" endLine="1364" />
    </method>
    <javadoc>
      <text>* Parses the specified character sequence from the specified position 
 * as a large integer in the specified radix.</text>
      <param>csq the character sequence to parse.</param>
      <param>radix the radix to be used while parsing.</param>
      <param>cursor the current cursor position (being maintained).</param>
      <return>the corresponding large integer.</return>
      <throws>NumberFormatException if error when parsing.</throws>
    </javadoc>
    <method type="LargeInteger" name="parse" startLine="1377" endLine="1414">
      <declaration type="int" name="end" />
      <declaration type="boolean" name="isNegative" />
      <declaration type="LargeInteger" name="li" />
      <declaration type="int" name="maxDigits" />
      <scope startLine="1383" endLine="1411">
        <declaration type="int" name="start" />
        <declaration type="long" name="l" />
        <declaration type="int" name="readCount" />
        <scope startLine="1388" endLine="1390" />
        <scope startLine="1390" endLine="1402">
          <scope startLine="1391" endLine="1397">
            <declaration type="LargeInteger" name="tmp" />
          </scope>
          <declaration type="long" name="factor" />
        </scope>
        <declaration type="char" name="c" />
        <declaration type="int" name="digit" />
        <comment>Reads up to digitsCount at a time.</comment>
        <comment>Resizes.</comment>
        <comment>Reached end.</comment>
        <comment>No more digit.</comment>
      </scope>
      <comment>Restore end index.</comment>
    </method>
    <method type="long" name="pow" startLine="1416" endLine="1426">
      <declaration type="long" name="l" />
      <scope startLine="1422" endLine="1424" />
    </method>
    <declaration type="long[]" name="LONG_POW_10" />
    <declaration type="long[]" name="LONG_POW_16" />
    <javadoc>
      <text>* Formats the specified large integer in the specified radix and into
 * the specified <code>Appendable</code> argument.</text>
      <param>li the large integer to format.</param>
      <param>radix the radix.</param>
      <param>out the <code>Appendable</code> to append.</param>
      <return>the specified <code>Appendable</code> object.</return>
      <throws>IllegalArgumentException if radix is not in [2 .. 36] range.</throws>
      <throws>IOException if an I/O exception occurs.</throws>
    </javadoc>
    <method type="Appendable" name="format" startLine="1451" endLine="1457">
      <scope startLine="1452" endLine="1454" />
      <declaration type="int" name="maxDigits" />
    </method>
    <method type="Appendable" name="write" startLine="1460" endLine="1479">
      <declaration type="int" name="rem" />
      <scope startLine="1465" endLine="1467" />
      <scope startLine="1470" endLine="1473" />
      <scope startLine="1474" endLine="1476">
        <comment>Writes low.</comment>
      </scope>
      <scope startLine="1476" endLine="1478" />
      <comment>Direct long formatting.</comment>
      <comment>Writes high.</comment>
    </method>
    <declaration type="long" name="serialVersionUID" />
    <comment>Indicates if bits lost when shifting right the two's-complement</comment>
    <comment>representation (affects only negative numbers).</comment>
    <comment />
    <comment>Parsing/Formatting</comment>
    <comment />
  </class>
</source>
