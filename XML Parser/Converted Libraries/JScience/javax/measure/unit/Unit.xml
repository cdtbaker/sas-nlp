<?xml version="1.0" encoding="UTF-8"?>
<source package="javax.measure.unit">
  <import name="java.io.Serializable" />
  <import name="java.text.ParseException" />
  <import name="java.text.ParsePosition" />
  <import name="java.util.HashMap" />
  <import name="javax.measure.MeasureFormat" />
  <import name="javax.measure.converter.AddConverter" />
  <import name="javax.measure.converter.ConversionException" />
  <import name="javax.measure.converter.MultiplyConverter" />
  <import name="javax.measure.converter.RationalConverter" />
  <import name="javax.measure.converter.UnitConverter" />
  <import name="javax.measure.quantity.Dimensionless" />
  <import name="javax.measure.quantity.Quantity" />
  <class name="Unit" startLine="25">
    <implements name="Serializable" />
    <javadoc>
      <text>* <p> This class represents a determinate {@link javax.measure.quantity.Quantityquantity} (as of length, time, heat, or value) adopted as a standard
 * of measurement.</p>
 * <p> It is helpful to think of instances of this class as recording the
 * history by which they are created. Thus, for example, the string
 * "g/kg" (which is a dimensionless unit) would result from invoking
 * the method toString() on a unit that was created by dividing a
 * gram unit by a kilogram unit. Yet, "kg" divided by "kg" returns{@link #ONE} and not "kg/kg" due to automatic unit factorization.</p>
 * <p> This class supports the multiplication of offsets units. The result is
 * usually a unit not convertible to its {@link #getStandardUnit standard unit}.
 * Such units may appear in derivative quantities. For example °C/m is an 
 * unit of gradient, which is common in atmospheric and oceanographic
 * research.</p>
 * <p> Units raised at rational powers are also supported. For example
 * the cubic root of "liter" is a unit compatible with meter.</p>
 * <p> Instances of this class are immutable.</p></text>
      <author><a href="mailto:jean-marie@dautelle.com">Jean-Marie Dautelle</a></author>
      <author><a href="mailto:steve@unidata.ucar.edu">Steve Emmerson</a></author>
      <author>Martin Desruisseaux</author>
      <version>3.2, August 28, 2006</version>
      <see><a href="http://en.wikipedia.org/wiki/Units_of_measurement">
 *       Wikipedia: Units of measurement</a></see>
    </javadoc>
    <javadoc>
      <text>* Holds the dimensionless unit <code>ONE</code>.</text>
    </javadoc>
    <declaration type="Unit<Dimensionless>" name="ONE" />
    <javadoc>
      <text>* Holds the unique symbols collection (base unit or alternate units).</text>
    </javadoc>
    <declaration type="HashMap<String,Unit<?>>" name="SYMBOL_TO_UNIT" />
    <javadoc>
      <text>* Default constructor.</text>
    </javadoc>
    <method type="constructor" name="Unit" startLine="70" endLine="71" />
    <method name="getStandardUnit" type="Unit<? super Q>" startLine="77" endLine="94" />
    <javadoc>
      <text>* Returns the {@link BaseUnit base unit}, {@link AlternateUnit alternate
 * unit} or product of base units and alternate units this unit is derived
 * from. The standard unit identifies the "type" of {@link javax.measure.quantity.Quantity quantity} for which this unit is employed.
 * For example:[code]
 * boolean isAngularVelocity(Unit<?> u) {
 * return u.getStandardUnit().equals(RADIAN.divide(SECOND));
 * }
 * assert(REVOLUTION.divide(MINUTE).isAngularVelocity());  
 * [/code]
 * <p><i> Note: Having the same system unit is not sufficient to ensure
 * that a converter exists between the two units
 * (e.g. °C/m and K/m).</i></p></text>
      <return>the system unit this unit is derived from.</return>
    </javadoc>
    <method name="toStandardUnit" type="UnitConverter" startLine="97" endLine="102" />
    <javadoc>
      <text>* Returns the converter from this unit to its system unit.</text>
      <return><code>this.getConverterTo(this.getSystemUnit())</code></return>
    </javadoc>
    <method name="hashCode" type="int" startLine="104" endLine="109" />
    <javadoc>
      <text>* Returns the hash code for this unit.</text>
      <return>this unit hashcode value.</return>
    </javadoc>
    <method name="equals" type="boolean" startLine="111" endLine="119" />
    <javadoc>
      <text>* Indicates if the specified unit can be considered equals to 
 * the one specified.</text>
      <param>that the object to compare to.</param>
      <return><code>true</code> if this unit is considered equal to 
 * that unit; <code>false</code> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Indicates if this unit is a standard unit (base units and 
 * alternate units are standard units). The standard unit identifies 
 * the "type" of {@link javax.measure.quantity.Quantity quantity} for 
 * which the unit is employed.</text>
      <return><code>getStandardUnit().equals(this)</code></return>
    </javadoc>
    <method type="boolean" name="isStandardUnit" startLine="129" endLine="131" />
    <javadoc>
      <text>* Indicates if this unit is compatible with the unit specified.
 * Units don't need to be equals to be compatible. For example:[code]
 * RADIAN.equals(ONE) == false
 * RADIAN.isCompatible(ONE) == true
 * [/code]</text>
      <param>that the other unit.</param>
      <return><code>this.getDimension().equals(that.getDimension())</code></return>
      <see>#getDimension()</see>
    </javadoc>
    <method type="boolean" name="isCompatible" startLine="143" endLine="147" />
    <javadoc>
      <text>* Casts this unit to a parameterized unit of specified nature or 
 * throw a <code>ClassCastException</code> if the dimension of the 
 * specified quantity and this unit's dimension do not match.
 * For example:[code]
 * Unit<Length> LIGHT_YEAR = NonSI.C.times(NonSI.YEAR).asType(Length.class);
 * [/code]</text>
      <param>type the quantity class identifying the nature of the unit.</param>
      <return>this unit parameterized with the specified type.</return>
      <throws>ClassCastException if the dimension of this unit is different 
 * from the specified quantity dimension.</throws>
      <throws>UnsupportedOperationException if the specified quantity class
 * does not have a public static field named "UNIT" holding the 
 * standard unit for the quantity.</throws>
    </javadoc>
    <method type="Unit<T>" name="asType" startLine="166" endLine="178">
      <declaration type="Dimension" name="dim1" />
      <declaration type="Unit<T>" name="u" />
      <scope startLine="169" endLine="171" />
      <scope startLine="171" endLine="173" />
      <declaration type="Dimension" name="dim2" />
    </method>
    <javadoc>
      <text>* Returns the dimension of this unit (depends upon the current 
 * dimensional {@link Dimension.Model model}).</text>
      <return>the dimension of this unit for the current model.</return>
    </javadoc>
    <method type="Dimension" name="getDimension" startLine="186" endLine="202">
      <declaration type="Unit<?>" name="systemUnit" />
      <declaration type="ProductUnit<?>" name="productUnit" />
      <declaration type="Dimension" name="dimension" />
      <scope startLine="195" endLine="200">
        <declaration type="Unit<?>" name="unit" />
        <declaration type="Dimension" name="d" />
      </scope>
      <comment>Product of units.</comment>
    </method>
    <javadoc>
      <text>* Returns a converter of numeric values from this unit to another unit.</text>
      <param>that the unit to which to convert the numeric values.</param>
      <return>the converter from this unit to <code>that</code> unit.</return>
      <throws>ConversionException if the conveter cannot be constructed
 * (e.g. <code>!this.isCompatible(that)</code>).</throws>
    </javadoc>
    <method type="UnitConverter" name="getConverterTo" startLine="213" endLine="232">
      <declaration type="Unit<?>" name="thisSystemUnit" />
      <declaration type="Unit<?>" name="thatSystemUnit" />
      <declaration type="UnitConverter" name="thisTransform" />
      <declaration type="UnitConverter" name="thatTransform" />
      <comment>Use dimensional transforms.</comment>
      <comment>Transform between SystemUnit and BaseUnits is Identity.</comment>
    </method>
    <method type="Unit<?>" name="getBaseUnits" startLine="234" endLine="253">
      <declaration type="Unit<?>" name="systemUnit" />
      <scope startLine="239" endLine="249">
        <declaration type="ProductUnit<?>" name="productUnit" />
        <declaration type="Unit<?>" name="baseUnits" />
        <scope startLine="242" endLine="247">
          <declaration type="Unit<?>" name="unit" />
        </scope>
      </scope>
      <scope startLine="249" endLine="252" />
    </method>
    <method type="UnitConverter" name="transformOf" startLine="254" endLine="279">
      <declaration type="ProductUnit<?>" name="productUnit" />
      <declaration type="UnitConverter" name="converter" />
      <scope startLine="260" endLine="277">
        <declaration type="Unit<?>" name="unit" />
        <declaration type="UnitConverter" name="cvtr" />
        <declaration type="int" name="pow" />
        <scope startLine="270" endLine="273" />
        <scope startLine="274" endLine="276" />
        <comment>Negative power.</comment>
      </scope>
      <comment>Product of units.</comment>
    </method>
    <javadoc>
      <text>* Returns a unit equivalent to this unit but used in expressions to 
 * distinguish between quantities of a different nature but of the same
 * dimensions.
 * <p> Examples of alternate units:[code]
 * Unit<Angle> RADIAN = ONE.alternate("rad");
 * Unit<Force> NEWTON = METER.times(KILOGRAM).divide(SECOND.pow(2)).alternate("N");
 * Unit<Pressure> PASCAL = NEWTON.divide(METER.pow(2)).alternate("Pa");
 * [/code]</p></text>
      <param>symbol the new symbol for the alternate unit.</param>
      <return>the alternate unit.</return>
      <throws>UnsupportedOperationException if this unit is not a standard unit.</throws>
      <throws>IllegalArgumentException if the specified symbol is already 
 * associated to a different unit.</throws>
    </javadoc>
    <method type="AlternateUnit<A>" name="alternate" startLine="298" endLine="300" />
    <javadoc>
      <text>* Returns the combination of this unit with the specified sub-unit.
 * Compound units are typically used for formatting purpose. 
 * Examples of compound units:[code]
 * HOUR_MINUTE = NonSI.HOUR.compound(NonSI.MINUTE);
 * DEGREE_MINUTE_SECOND_ANGLE = NonSI.DEGREE_ANGLE.compound(
 * NonSI.DEGREE_MINUTE).compound(NonSI.SECOND_ANGLE);
 * [/code]</text>
      <param>subunit the sub-unit to combine with this unit.</param>
      <return>the corresponding compound unit.</return>
    </javadoc>
    <method type="CompoundUnit<Q>" name="compound" startLine="314" endLine="316" />
    <javadoc>
      <text>* Returns the unit derived from this unit using the specified converter.
 * The converter does not need to be linear. For example:[code]
 * Unit<Dimensionless> DECIBEL = Unit.ONE.transform(
 * new LogConverter(10).inverse().concatenate(
 * new RationalConverter(1, 10)));[/code]</text>
      <param>operation the converter from the transformed unit to this unit.</param>
      <return>the unit after the specified transformation.</return>
    </javadoc>
    <method type="Unit<Q>" name="transform" startLine="328" endLine="340">
      <scope startLine="329" endLine="336">
        <declaration type="TransformedUnit<Q>" name="tf" />
        <declaration type="Unit<Q>" name="parent" />
        <declaration type="UnitConverter" name="toParent" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the result of adding an offset to this unit. The returned unit
 * is convertible with all units that are convertible with this unit.</text>
      <param>offset the offset added (expressed in this unit,
 * e.g. <code>CELSIUS = KELVIN.plus(273.15)</code>).</param>
      <return><code>this.transform(new AddConverter(offset))</code></return>
    </javadoc>
    <method type="Unit<Q>" name="plus" startLine="350" endLine="352" />
    <javadoc>
      <text>* Returns the result of multiplying this unit by an exact factor.</text>
      <param>factor the exact scale factor
 * (e.g. <code>KILOMETER = METER.times(1000)</code>).</param>
      <return><code>this.transform(new RationalConverter(factor, 1))</code></return>
    </javadoc>
    <method type="Unit<Q>" name="times" startLine="361" endLine="363" />
    <javadoc>
      <text>* Returns the result of multiplying this unit by a an approximate factor</text>
      <param>factor the approximate factor (e.g. 
 * <code>ELECTRON_MASS = KILOGRAM.times(9.10938188e-31)</code>).</param>
      <return><code>this.transform(new MultiplyConverter(factor))</code></return>
    </javadoc>
    <method type="Unit<Q>" name="times" startLine="372" endLine="374" />
    <javadoc>
      <text>* Returns the product of this unit with the one specified.</text>
      <param>that the unit multiplicand.</param>
      <return><code>this * that</code></return>
    </javadoc>
    <method type="Unit<? extends Quantity>" name="times" startLine="382" endLine="384" />
    <javadoc>
      <text>* Returns the inverse of this unit.</text>
      <return><code>1 / this</code></return>
    </javadoc>
    <method type="Unit<? extends Quantity>" name="inverse" startLine="391" endLine="393" />
    <javadoc>
      <text>* Returns the result of dividing this unit by an exact divisor.</text>
      <param>divisor the exact divisor.
 * (e.g. <code>QUART = GALLON_LIQUID_US.divide(4)</code>).</param>
      <return><code>this.transform(new RationalConverter(1 , divisor))</code></return>
    </javadoc>
    <method type="Unit<Q>" name="divide" startLine="402" endLine="404" />
    <javadoc>
      <text>* Returns the result of dividing this unit by an approximate divisor.</text>
      <param>divisor the approximate divisor.</param>
      <return><code>this.transform(new MultiplyConverter(1.0 / divisor))</code></return>
    </javadoc>
    <method type="Unit<Q>" name="divide" startLine="412" endLine="414" />
    <javadoc>
      <text>* Returns the quotient of this unit with the one specified.</text>
      <param>that the unit divisor.</param>
      <return><code>this / that</code></return>
    </javadoc>
    <method type="Unit<? extends Quantity>" name="divide" startLine="422" endLine="424" />
    <javadoc>
      <text>* Returns a unit equals to the given root of this unit.</text>
      <param>n the root's order.</param>
      <return>the result of taking the given root of this unit.</return>
      <throws>ArithmeticException if <code>n == 0</code>.</throws>
    </javadoc>
    <method type="Unit<? extends Quantity>" name="root" startLine="433" endLine="441">
      <scope startLine="434" endLine="436" />
      <scope startLine="436" endLine="438">
        <comment>n < 0</comment>
      </scope>
      <scope startLine="438" endLine="440" />
    </method>
    <javadoc>
      <text>* Returns a unit equals to this unit raised to an exponent.</text>
      <param>n the exponent.</param>
      <return>the result of raising this unit to the exponent.</return>
    </javadoc>
    <method type="Unit<? extends Quantity>" name="pow" startLine="449" endLine="457">
      <scope startLine="450" endLine="452" />
      <scope startLine="452" endLine="454">
        <comment>n < 0</comment>
      </scope>
      <scope startLine="454" endLine="456" />
    </method>
    <javadoc>
      <text>* Returns a unit instance that is defined from the specified
 * character sequence using the {@link UnitFormat#getInstance()standard unit format}.
 * <p> Examples of valid entries (all for meters per second squared) are:
 * <code><ul>
 * <li>m*s-2</li>
 * <li>m/s²</li>
 * <li>m·s-²</li>
 * <li>m*s**-2</li>
 * <li>m^+1 s^-2</li>
 * </ul></code></p></text>
      <param>csq the character sequence to parse.</param>
      <return><code>UnitFormat.getStandardInstance().parse(csq, new ParsePosition(0))</code></return>
      <throws>IllegalArgumentException if the specified character sequence
 * cannot be correctly parsed (e.g. symbol unknown).</throws>
    </javadoc>
    <method type="Unit<? extends Quantity>" name="valueOf" startLine="477" endLine="484">
      <scope startLine="478" endLine="481" />
      <scope startLine="481" endLine="483" />
    </method>
    <javadoc>
      <text>* Returns the standard <code>String</code> representation of this unit.
 * This representation is not affected by locale. Locale-sensitive
 * unit formatting and parsing is handled by the {@link MeasureFormat} 
 * class and its subclasses.</text>
      <return><code>UnitFormat.getStandardInstance().format(this)</code></return>
    </javadoc>
    <method type="String" name="toString" startLine="498" endLine="500" />
    <comment />
    <comment>Contract methods (for sub-classes to implement).</comment>
    <comment />
    <comment />
    <comment>GENERAL CONTRACT</comment>
    <comment />
  </class>
</source>
