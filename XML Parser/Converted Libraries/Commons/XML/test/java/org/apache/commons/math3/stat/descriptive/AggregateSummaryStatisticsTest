<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.stat.descriptive">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="org.apache.commons.math3.TestUtils"/>
        <import package="org.apache.commons.math3.distribution.RealDistribution"/>
        <import package="org.apache.commons.math3.distribution.UniformRealDistribution"/>
        <import package="org.apache.commons.math3.distribution.IntegerDistribution"/>
        <import package="org.apache.commons.math3.distribution.UniformIntegerDistribution"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <import package="org.junit.Assert"/>
        <import package="org.junit.Test"/>
        <class name="AggregateSummaryStatisticsTest" line="34">
            <javadoc line="34">
                Test cases for {@link AggregateSummaryStatistics}                
            </javadoc>
            <javadoc line="40">
                Tests the standard aggregation behavior                
            </javadoc>
            <method name="testAggregation" type="void" line="44">
                <declaration name="aggregate" type="AggregateSummaryStatistics" line="45"/>
                <declaration name="setOneStats" type="SummaryStatistics" line="46"/>
                <declaration name="setTwoStats" type="SummaryStatistics" line="47"/>
            </method>
            <javadoc line="71">
                Verify that aggregating over a partition gives the same results
                 * as direct computation.
                 * 1) Randomly generate a dataset of 10-100 values
                 * from [-100, 100]
                 * 2) Divide the dataset it into 2-5 partitions
                 * 3) Create an AggregateSummaryStatistic and ContributingStatistics
                 * for each partition
                 * 4) Compare results from the AggregateSummaryStatistic with values
                 * returned by a single SummaryStatistics instance that is provided
                 * the full dataset                
            </javadoc>
            <method name="testAggregationConsistency" type="void" line="85">
                <comment line="86">
                    Generate a random sample and random partition                    
                </comment>
                <comment line="86">
                    Create aggregator and total stats for comparison                    
                </comment>
                <comment line="86">
                    Create array of component stats                    
                </comment>
                <comment line="86">
                    Compute totalStats directly                    
                </comment>
                <comment line="86">
                    Compare statistics in totalStats with aggregate.
                     Note that guaranteed success of this comparison depends on the
                     fact that &lt;aggregate&gt; gets values in exactly the same order                    
                </comment>
                <declaration name="totalSample" type="double[]" line="88"/>
                <declaration name="subSamples" type="double[][]" line="89"/>
                <declaration name="nSamples" type="int" line="90"/>
                <declaration name="aggregate" type="AggregateSummaryStatistics" line="93"/>
                <declaration name="totalStats" type="SummaryStatistics" line="94"/>
                <declaration name="componentStats" type="SummaryStatistics" line="97"/>
                <scope line="99">
                    <scope line="105"/>
                </scope>
                <scope line="111"/>
            </method>
            <javadoc line="126">
                Test aggregate function by randomly generating a dataset of 10-100 values
                 * from [-100, 100], dividing it into 2-5 partitions, computing stats for each
                 * partition and comparing the result of aggregate(...) applied to the collection
                 * of per-partition SummaryStatistics with a single SummaryStatistics computed
                 * over the full sample.                
            </javadoc>
            <method name="testAggregate" type="void" line="135">
                <comment line="136">
                    Generate a random sample and random partition                    
                </comment>
                <comment line="136">
                    Compute combined stats directly                    
                </comment>
                <comment line="136">
                    Now compute subsample stats individually and aggregate                    
                </comment>
                <comment line="136">
                    Compare values                    
                </comment>
                <declaration name="totalSample" type="double[]" line="138"/>
                <declaration name="subSamples" type="double[][]" line="139"/>
                <declaration name="nSamples" type="int" line="140"/>
                <declaration name="totalStats" type="SummaryStatistics" line="143"/>
                <scope line="144"/>
                <declaration name="subSampleStats" type="SummaryStatistics[]" line="149"/>
                <scope line="150"/>
                <declaration name="aggregate" type="Collection&lt;SummaryStatistics&gt;" line="153"/>
                <scope line="154">
                    <scope line="155"/>
                </scope>
                <declaration name="aggregatedStats" type="StatisticalSummary" line="162"/>
            </method>
            <method name="testAggregateDegenerate" type="void" line="168">
                <comment line="169">
                    Compute combined stats directly                    
                </comment>
                <comment line="169">
                    Now compute subsample stats individually and aggregate                    
                </comment>
                <comment line="169">
                    Compare values                    
                </comment>
                <declaration name="totalSample" type="double[]" line="169"/>
                <declaration name="subSamples" type="double[][]" line="170"/>
                <declaration name="totalStats" type="SummaryStatistics" line="173"/>
                <scope line="174"/>
                <declaration name="subSampleStats" type="SummaryStatistics[]" line="179"/>
                <scope line="180"/>
                <declaration name="aggregate" type="Collection&lt;SummaryStatistics&gt;" line="183"/>
                <scope line="184">
                    <scope line="185"/>
                </scope>
                <declaration name="aggregatedStats" type="StatisticalSummaryValues" line="192"/>
            </method>
            <method name="testAggregateSpecialValues" type="void" line="197">
                <comment line="198">
                    Compute combined stats directly                    
                </comment>
                <comment line="198">
                    Now compute subsample stats individually and aggregate                    
                </comment>
                <comment line="198">
                    Compare values                    
                </comment>
                <declaration name="totalSample" type="double[]" line="198"/>
                <declaration name="subSamples" type="double[][]" line="199"/>
                <declaration name="totalStats" type="SummaryStatistics" line="202"/>
                <scope line="203"/>
                <declaration name="subSampleStats" type="SummaryStatistics[]" line="208"/>
                <scope line="209"/>
                <declaration name="aggregate" type="Collection&lt;SummaryStatistics&gt;" line="212"/>
                <scope line="213">
                    <scope line="214"/>
                </scope>
                <declaration name="aggregatedStats" type="StatisticalSummaryValues" line="221"/>
            </method>
            <javadoc line="226">
                Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up
                 * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values
                 * have to agree exactly, delta is used only for sum, mean, variance, std dev.                
            </javadoc>
            <method name="assertEquals" type="void" line="231"/>
            <javadoc line="242">
                Generates a random sample of double values.
                 * Sample size is random, between 10 and 100 and values are
                 * uniformly distributed over [-100, 100].                
                <@return>
                    n array of random double values                    
                </@return>
            </javadoc>
            <method name="generateSample" type="double[]" line="249">
                <declaration name="size" type="IntegerDistribution" line="250"/>
                <declaration name="randomData" type="RealDistribution" line="251"/>
                <declaration name="sampleSize" type="int" line="252"/>
                <declaration name="out" type="double[]" line="253"/>
            </method>
            <javadoc line="257">
                Generates a partition of &lt;sample&gt; into up to 5 sequentially selected
                 * subsamples with randomly selected partition points.                
                <@param>
                    m sample array to partition                    
                </@param>
                <@return>
                    n rectangular array with rows = subsamples                    
                </@return>
            </javadoc>
            <method name="generatePartition" type="double[][]" line="264">
                <comment line="265">
                    t cur = 0;          // beginning of current partition segment                    
                </comment>
                <comment line="265">
                    t offset = 0;       // end of current partition segment                    
                </comment>
                <comment line="265">
                    t sampleCount = 0;  // number of segments defined                    
                </comment>
                <declaration name="length" type="int" line="265"/>
                <declaration name="out" type="double[][]" line="266"/>
                <declaration name="cur" type="int" line="267"/>
                <declaration name="offset" type="int" line="268"/>
                <declaration name="sampleCount" type="int" line="269"/>
                <scope line="270">
                    <scope line="271"/>
                    <declaration name="next" type="int" line="274"/>
                    <scope line="275"/>
                    <scope line="277"/>
                    <declaration name="subLength" type="int" line="280"/>
                </scope>
                <scope line="287">
                    <declaration name="out2" type="double[][]" line="288"/>
                    <scope line="289">
                        <declaration name="curSize" type="int" line="290"/>
                    </scope>
                </scope>
                <scope line="295"/>
            </method>
        </class>
    </source>