<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.util">
        <import package="java.lang.reflect.Array"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.Field"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathArithmeticException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NonMonotonicSequenceException"/>
        <import package="org.apache.commons.math3.exception.NotPositiveException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <class name="MathArrays" line="38">
            <javadoc line="38">
                Arrays utilities.                
                <@since>
                    e 3.0                    
                </@since>
                <@version>
                    n $Id: MathArrays.java 1462423 2013-03-29 07:25:18Z luc $                    
                </@version>
            </javadoc>
            <declaration name="SPLIT_FACTOR" type="int" line="45"/>
            <javadoc line="45">
                Factor used for splitting double numbers: n = 2^27 + 1 (i.e. {@value}).                
            </javadoc>
            <javadoc line="48">
                Private constructor.                
            </javadoc>
            <method name="MathArrays" type="constructor" line="51"/>
            <interface name="Function">
                <javadoc line="53">
                    Real-valued function that operate on an array or a part of it.                    
                    <@since>
                        e 3.1                        
                    </@since>
                </javadoc>
                <method name="evaluate" type="double" line="58"/>
                <javadoc line="58">
                    Operates on an entire array.                    
                    <@param>
                        m array Array to operate on.                        
                    </@param>
                    <@return>
                        n the result of the operation.                        
                    </@return>
                </javadoc>
                <method name="evaluate" type="double" line="65"/>
                <javadoc line="65">
                    @param array Array to operate on.                    
                    <@param>
                        m startIndex Index of the first element to take into account.                        
                    </@param>
                    <@param>
                        m numElements Number of elements to take into account.                        
                    </@param>
                    <@return>
                        n the result of the operation.                        
                    </@return>
                </javadoc>
            </interface>
            <javadoc line="76">
                Create a copy of an array scaled by a value.                
                <@param>
                    m arr Array to scale.                    
                </@param>
                <@param>
                    m val Scalar.                    
                </@param>
                <@return>
                    n scaled copy of array with each entry multiplied by val.                    
                </@return>
                <@since>
                    e 3.2                    
                </@since>
            </javadoc>
            <method name="scale" type="double[]" line="84">
                <declaration name="newArr" type="double[]" line="85"/>
                <scope line="86"/>
            </method>
            <javadoc line="92">
                &lt;p&gt;Multiply each element of an array by a value.&lt;/p&gt;
                 * &lt;p&gt;The array is modified in place (no copy is created).&lt;/p&gt;                
                <@param>
                    m arr Array to scale                    
                </@param>
                <@param>
                    m val Scalar                    
                </@param>
                <@since>
                    e 3.2                    
                </@since>
            </javadoc>
            <method name="scaleInPlace" type="void" line="101">
                <scope line="102"/>
            </method>
            <javadoc line="107">
                Creates an array whose contents will be the element-by-element
                 * addition of the arguments.                
                <@param>
                    m a First term of the addition.                    
                </@param>
                <@param>
                    m b Second term of the addition.                    
                </@param>
                <@return>
                    n a new array {@code r} where {@code r[i] = a[i] + b[i]}.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the array lengths differ.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="ebeAdd" type="double[]" line="118">
                <scope line="119"/>
                <declaration name="result" type="double[]" line="123"/>
                <scope line="124"/>
            </method>
            <javadoc line="129">
                Creates an array whose contents will be the element-by-element
                 * subtraction of the second argument from the first.                
                <@param>
                    m a First term.                    
                </@param>
                <@param>
                    m b Element to be subtracted.                    
                </@param>
                <@return>
                    n a new array {@code r} where {@code r[i] = a[i] - b[i]}.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the array lengths differ.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="ebeSubtract" type="double[]" line="140">
                <scope line="141"/>
                <declaration name="result" type="double[]" line="145"/>
                <scope line="146"/>
            </method>
            <javadoc line="151">
                Creates an array whose contents will be the element-by-element
                 * multiplication of the arguments.                
                <@param>
                    m a First factor of the multiplication.                    
                </@param>
                <@param>
                    m b Second factor of the multiplication.                    
                </@param>
                <@return>
                    n a new array {@code r} where {@code r[i] = a[i] * b[i]}.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the array lengths differ.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="ebeMultiply" type="double[]" line="162">
                <scope line="163"/>
                <declaration name="result" type="double[]" line="167"/>
                <scope line="168"/>
            </method>
            <javadoc line="173">
                Creates an array whose contents will be the element-by-element
                 * division of the first argument by the second.                
                <@param>
                    m a Numerator of the division.                    
                </@param>
                <@param>
                    m b Denominator of the division.                    
                </@param>
                <@return>
                    n a new array {@code r} where {@code r[i] = a[i] / b[i]}.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the array lengths differ.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="ebeDivide" type="double[]" line="184">
                <scope line="185"/>
                <declaration name="result" type="double[]" line="189"/>
                <scope line="190"/>
            </method>
            <javadoc line="196">
                Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.                
                <@param>
                    m p1 the first point                    
                </@param>
                <@param>
                    m p2 the second point                    
                </@param>
                <@return>
                    n the L<sub>1</sub> distance between the two points                    
                </@return>
            </javadoc>
            <method name="distance1" type="double" line="203">
                <declaration name="sum" type="double" line="204"/>
                <scope line="205"/>
            </method>
            <javadoc line="211">
                Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.                
                <@param>
                    m p1 the first point                    
                </@param>
                <@param>
                    m p2 the second point                    
                </@param>
                <@return>
                    n the L<sub>1</sub> distance between the two points                    
                </@return>
            </javadoc>
            <method name="distance1" type="int" line="218">
                <declaration name="sum" type="int" line="219"/>
                <scope line="220"/>
            </method>
            <javadoc line="226">
                Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.                
                <@param>
                    m p1 the first point                    
                </@param>
                <@param>
                    m p2 the second point                    
                </@param>
                <@return>
                    n the L<sub>2</sub> distance between the two points                    
                </@return>
            </javadoc>
            <method name="distance" type="double" line="233">
                <declaration name="sum" type="double" line="234"/>
                <scope line="235">
                    <declaration name="dp" type="double" line="236"/>
                </scope>
            </method>
            <javadoc line="242">
                Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.                
                <@param>
                    m p1 the first point                    
                </@param>
                <@param>
                    m p2 the second point                    
                </@param>
                <@return>
                    n the L<sub>2</sub> distance between the two points                    
                </@return>
            </javadoc>
            <method name="distance" type="double" line="249">
                <declaration name="sum" type="double" line="250"/>
                <scope line="251">
                    <declaration name="dp" type="double" line="252"/>
                </scope>
            </method>
            <javadoc line="258">
                Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.                
                <@param>
                    m p1 the first point                    
                </@param>
                <@param>
                    m p2 the second point                    
                </@param>
                <@return>
                    n the L<sub>&infin;</sub> distance between the two points                    
                </@return>
            </javadoc>
            <method name="distanceInf" type="double" line="265">
                <declaration name="max" type="double" line="266"/>
                <scope line="267"/>
            </method>
            <javadoc line="273">
                Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.                
                <@param>
                    m p1 the first point                    
                </@param>
                <@param>
                    m p2 the second point                    
                </@param>
                <@return>
                    n the L<sub>&infin;</sub> distance between the two points                    
                </@return>
            </javadoc>
            <method name="distanceInf" type="int" line="280">
                <declaration name="max" type="int" line="281"/>
                <scope line="282"/>
            </method>
            <javadoc line="288">
                Specification of ordering direction.                
            </javadoc>
            <javadoc line="292">
                Constant for increasing direction.                
            </javadoc>
            <javadoc line="294">
                Constant for decreasing direction.                
            </javadoc>
            <javadoc line="298">
                Check that an array is monotonically increasing or decreasing.                
                <@param>
                    m<T>
                     *  the type of the elements in the specified array                    
                </@param>
                <@param>
                    m val Values.                    
                </@param>
                <@param>
                    m dir Ordering direction.                    
                </@param>
                <@param>
                    m strict Whether the order should be strict.                    
                </@param>
                <@return>
                    n {@code true} if sorted, {@code false} otherwise.                    
                </@return>
            </javadoc>
            <method name="isMonotonic" type="boolean" line="309">
                <declaration name="previous" type="T" line="310"/>
                <declaration name="max" type="int" line="311"/>
                <scope line="312">
                    <declaration name="comp" type="int" line="313"/>
                    <scope line="317">
                        <scope line="318"/>
                    </scope>
                    <scope line="321">
                        <scope line="322"/>
                    </scope>
                    <scope line="329">
                        <scope line="330"/>
                    </scope>
                    <scope line="333">
                        <scope line="334"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="349">
                Check that an array is monotonically increasing or decreasing.                
                <@param>
                    m val Values.                    
                </@param>
                <@param>
                    m dir Ordering direction.                    
                </@param>
                <@param>
                    m strict Whether the order should be strict.                    
                </@param>
                <@return>
                    n {@code true} if sorted, {@code false} otherwise.                    
                </@return>
            </javadoc>
            <method name="isMonotonic" type="boolean" line="357"/>
            <javadoc line="361">
                Check that the given array is sorted.                
                <@param>
                    m val Values.                    
                </@param>
                <@param>
                    m dir Ordering direction.                    
                </@param>
                <@param>
                    m strict Whether the order should be strict.                    
                </@param>
                <@param>
                    m abort Whether to throw an exception if the check fails.                    
                </@param>
                <@return>
                    n {@code true} if the array is sorted.                    
                </@return>
                <@throws>
                    s NonMonotonicSequenceException if the array is not sorted
                     * and {@code abort} is {@code true}.                    
                </@throws>
            </javadoc>
            <method name="checkOrder" type="boolean" line="374">
                <comment line="375">
                    Loop early exit means wrong ordering.                    
                </comment>
                <declaration name="previous" type="double" line="375"/>
                <declaration name="max" type="int" line="376"/>
                <declaration name="index" type="int" line="378"/>
                <scope line="380">
                    <scope line="383">
                        <scope line="384"/>
                    </scope>
                    <scope line="387">
                        <scope line="388"/>
                    </scope>
                    <scope line="394">
                        <scope line="395"/>
                    </scope>
                    <scope line="398">
                        <scope line="399"/>
                    </scope>
                </scope>
                <scope line="412"/>
                <scope line="418"/>
                <scope line="420"/>
            </method>
            <javadoc line="425">
                Check that the given array is sorted.                
                <@param>
                    m val Values.                    
                </@param>
                <@param>
                    m dir Ordering direction.                    
                </@param>
                <@param>
                    m strict Whether the order should be strict.                    
                </@param>
                <@throws>
                    s NonMonotonicSequenceException if the array is not sorted.                    
                </@throws>
                <@since>
                    e 2.2                    
                </@since>
            </javadoc>
            <method name="checkOrder" type="void" line="435"/>
            <javadoc line="439">
                Check that the given array is sorted in strictly increasing order.                
                <@param>
                    m val Values.                    
                </@param>
                <@throws>
                    s NonMonotonicSequenceException if the array is not sorted.                    
                </@throws>
                <@since>
                    e 2.2                    
                </@since>
            </javadoc>
            <method name="checkOrder" type="void" line="446"/>
            <javadoc line="450">
                Throws DimensionMismatchException if the input array is not rectangular.                
                <@param>
                    m in array to be tested                    
                </@param>
                <@throws>
                    s NullArgumentException if input array is null                    
                </@throws>
                <@throws>
                    s DimensionMismatchException if input array is not rectangular                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="checkRectangular" type="void" line="459">
                <scope line="461">
                    <scope line="462"/>
                </scope>
            </method>
            <javadoc line="470">
                Check that all entries of the input array are strictly positive.                
                <@param>
                    m in Array to be tested                    
                </@param>
                <@throws>
                    s NotStrictlyPositiveException if any entries of the array are not
                     * strictly positive.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="checkPositive" type="void" line="479">
                <scope line="480">
                    <scope line="481"/>
                </scope>
            </method>
            <javadoc line="487">
                Check that all entries of the input array are &gt;= 0.                
                <@param>
                    m in Array to be tested                    
                </@param>
                <@throws>
                    s NotPositiveException if any array entries are less than 0.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="checkNonNegative" type="void" line="495">
                <scope line="496">
                    <scope line="497"/>
                </scope>
            </method>
            <javadoc line="503">
                Check all entries of the input array are &gt;= 0.                
                <@param>
                    m in Array to be tested                    
                </@param>
                <@throws>
                    s NotPositiveException if any array entries are less than 0.                    
                </@throws>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="checkNonNegative" type="void" line="511">
                <scope line="512">
                    <scope line="513">
                        <scope line="514"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="521">
                Returns the Cartesian norm (2-norm), handling both overflow and underflow.
                 * Translation of the minpack enorm subroutine.
                 * The redistribution policy for MINPACK is available
                 * &lt;a href=&quot;http://www.netlib.org/minpack/disclaimer&quot;&gt;here&lt;/a&gt;, for
                 * convenience, it is reproduced below.&lt;/p&gt;
                 * &lt;table border=&quot;0&quot; width=&quot;80%&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;#E0E0E0&quot;&gt;
                 * &lt;tr&gt;&lt;td&gt;
                 * Minpack Copyright Notice (1999) University of Chicago.
                 * All rights reserved
                 * &lt;/td&gt;&lt;/tr&gt;
                 * &lt;tr&gt;&lt;td&gt;
                 * Redistribution and use in source and binary forms, with or without
                 * modification, are permitted provided that the following conditions
                 * are met:
                 * &lt;ol&gt;
                 * &lt;li&gt;Redistributions of source code must retain the above copyright
                 * notice, this list of conditions and the following disclaimer.&lt;/li&gt;
                 * &lt;li&gt;Redistributions in binary form must reproduce the above
                 * copyright notice, this list of conditions and the following
                 * disclaimer in the documentation and/or other materials provided
                 * with the distribution.&lt;/li&gt;
                 * &lt;li&gt;The end-user documentation included with the redistribution, if any,
                 * must include the following acknowledgment:{@code This product includes software developed by the University of
                 * Chicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself,
                 * if and wherever such third-party acknowledgments normally appear.&lt;/li&gt;
                 * &lt;li&gt;&lt;strong&gt;WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED &quot;AS IS&quot;
                 * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
                 * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
                 * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
                 * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
                 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
                 * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
                 * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
                 * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
                 * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
                 * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
                 * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
                 * BE CORRECTED.&lt;/strong&gt;&lt;/li&gt;
                 * &lt;li&gt;&lt;strong&gt;LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
                 * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
                 * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
                 * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
                 * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
                 * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
                 * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
                 * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
                 * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
                 * POSSIBILITY OF SUCH LOSS OR DAMAGES.&lt;/strong&gt;&lt;/li&gt;
                 * &lt;ol&gt;&lt;/td&gt;&lt;/tr&gt;
                 * &lt;/table&gt;                
                <@param>
                    m v Vector of doubles.                    
                </@param>
                <@return>
                    n the 2-norm of the vector.                    
                </@return>
                <@since>
                    e 2.2                    
                </@since>
            </javadoc>
            <method name="safeNorm" type="double" line="581">
                <declaration name="rdwarf" type="double" line="582"/>
                <declaration name="rgiant" type="double" line="583"/>
                <declaration name="s1" type="double" line="584"/>
                <declaration name="s2" type="double" line="585"/>
                <declaration name="s3" type="double" line="586"/>
                <declaration name="x1max" type="double" line="587"/>
                <declaration name="x3max" type="double" line="588"/>
                <declaration name="floatn" type="double" line="589"/>
                <declaration name="agiant" type="double" line="590"/>
                <scope line="591">
                    <declaration name="xabs" type="double" line="592"/>
                    <scope line="593">
                        <scope line="594">
                            <scope line="595">
                                <declaration name="r" type="double" line="596"/>
                            </scope>
                            <scope line="599">
                                <declaration name="r" type="double" line="600"/>
                            </scope>
                        </scope>
                        <scope line="603">
                            <scope line="604">
                                <declaration name="r" type="double" line="605"/>
                            </scope>
                            <scope line="608">
                                <scope line="609">
                                    <declaration name="r" type="double" line="610"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="615"/>
                </scope>
                <declaration name="norm" type="double" line="619"/>
                <scope line="620"/>
                <scope line="622">
                    <scope line="623"/>
                    <scope line="625">
                        <scope line="626"/>
                        <scope line="628"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="636">
                Sort an array in ascending order in place and perform the same reordering
                 * of entries on other arrays. For example, if{@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then{@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},{@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.                
                <@param>
                    m x Array to be sorted and used as a pattern for permutation
                     * of the other arrays.                    
                </@param>
                <@param>
                    m yList Set of arrays whose permutations of entries will follow
                     * those performed on {@code x}.                    
                </@param>
                <@throws>
                    s DimensionMismatchException if any {@code y} is not the same
                     * size as {@code x}.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code x} or any {@code y} is null.                    
                </@throws>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <method name="sortInPlace" type="void" line="653"/>
            <javadoc line="657">
                Sort an array in place and perform the same reordering of entries on
                 * other arrays.  This method works the same as the other{@link #sortInPlace(double[],double[][]) sortInPlace} method, but
                 * allows the order of the sort to be provided in the {@code dir}parameter.                
                <@param>
                    m x Array to be sorted and used as a pattern for permutation
                     * of the other arrays.                    
                </@param>
                <@param>
                    m dir Order direction.                    
                </@param>
                <@param>
                    m yList Set of arrays whose permutations of entries will follow
                     * those performed on {@code x}.                    
                </@param>
                <@throws>
                    s DimensionMismatchException if any {@code y} is not the same
                     * size as {@code x}.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code x} or any {@code y} is null                    
                </@throws>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <method name="sortInPlace" type="void" line="677">
                <scope line="678"/>
                <declaration name="len" type="int" line="682"/>
                <declaration name="list" type="List&lt;Pair&lt;Double,double[]&gt;&gt;" line="683"/>
                <declaration name="yListLen" type="int" line="686"/>
                <scope line="687">
                    <declaration name="yValues" type="double[]" line="688"/>
                    <scope line="689">
                        <declaration name="y" type="double[]" line="690"/>
                        <scope line="691"/>
                        <scope line="694"/>
                    </scope>
                </scope>
                <anonymous_class line="703">
                    <method name="compare" type="int" line="705">
                        <declaration name="val" type="int" line="706"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="Comparator&lt;Pair&lt;Double,double[]&gt;&gt;" line="702"/>
                <scope line="724">
                    <declaration name="e" type="Pair&lt;Double,double[]&gt;" line="725"/>
                    <declaration name="yValues" type="double[]" line="727"/>
                    <scope line="728"/>
                </scope>
            </method>
            <javadoc line="734">
                Creates a copy of the {@code source} array.                
                <@param>
                    m source Array to be copied.                    
                </@param>
                <@return>
                    n the copied array.                    
                </@return>
            </javadoc>
            <method name="copyOf" type="int[]" line="740"/>
            <javadoc line="744">
                Creates a copy of the {@code source} array.                
                <@param>
                    m source Array to be copied.                    
                </@param>
                <@return>
                    n the copied array.                    
                </@return>
            </javadoc>
            <method name="copyOf" type="double[]" line="750"/>
            <javadoc line="754">
                Creates a copy of the {@code source} array.                
                <@param>
                    m source Array to be copied.                    
                </@param>
                <@param>
                    m len Number of entries to copy. If smaller then the source
                     * length, the copy will be truncated, if larger it will padded with
                     * zeroes.                    
                </@param>
                <@return>
                    n the copied array.                    
                </@return>
            </javadoc>
            <method name="copyOf" type="int[]" line="763">
                <declaration name="output" type="int[]" line="764"/>
            </method>
            <javadoc line="769">
                Creates a copy of the {@code source} array.                
                <@param>
                    m source Array to be copied.                    
                </@param>
                <@param>
                    m len Number of entries to copy. If smaller then the source
                     * length, the copy will be truncated, if larger it will padded with
                     * zeroes.                    
                </@param>
                <@return>
                    n the copied array.                    
                </@return>
            </javadoc>
            <method name="copyOf" type="double[]" line="778">
                <declaration name="output" type="double[]" line="779"/>
            </method>
            <javadoc line="784">
                Compute a linear combination accurately.
                 * This method computes the sum of the products
                 * &lt;code&gt;a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt; to high accuracy.
                 * It does so by using specific multiplication and addition algorithms to
                 * preserve accuracy and reduce cancellation effects.
                 * &lt;br/&gt;
                 * It is based on the 2005 paper
                 * &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita, Siegfried M. Rump,
                 * and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.                
                <@param>
                    m a Factors.                    
                </@param>
                <@param>
                    m b Factors.                    
                </@param>
                <@return>
                    n <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if arrays dimensions don't match                    
                </@throws>
            </javadoc>
            <method name="linearCombination" type="double" line="802">
                <declaration name="len" type="int" line="803"/>
                <scope line="804"/>
                <declaration name="prodHigh" type="double[]" line="808"/>
                <declaration name="prodLowSum" type="double" line="809"/>
                <scope line="811">
                    <declaration name="ai" type="double" line="812"/>
                    <declaration name="ca" type="double" line="813"/>
                    <declaration name="aHigh" type="double" line="814"/>
                    <declaration name="aLow" type="double" line="815"/>
                    <declaration name="bi" type="double" line="817"/>
                    <declaration name="cb" type="double" line="818"/>
                    <declaration name="bHigh" type="double" line="819"/>
                    <declaration name="bLow" type="double" line="820"/>
                    <declaration name="prodLow" type="double" line="822"/>
                </scope>
                <declaration name="prodHighCur" type="double" line="830"/>
                <declaration name="prodHighNext" type="double" line="831"/>
                <declaration name="sHighPrev" type="double" line="832"/>
                <declaration name="sPrime" type="double" line="833"/>
                <declaration name="sLowSum" type="double" line="834"/>
                <declaration name="lenMinusOne" type="int" line="836"/>
                <scope line="837">
                    <declaration name="sHighCur" type="double" line="839"/>
                </scope>
                <declaration name="result" type="double" line="845"/>
                <scope line="847">
                    <scope line="851"/>
                </scope>
            </method>
            <javadoc line="859">
                Compute a linear combination accurately.
                 * &lt;p&gt;
                 * This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; to high accuracy. It does
                 * so by using specific multiplication and addition algorithms to
                 * preserve accuracy and reduce cancellation effects. It is based
                 * on the 2005 paper &lt;a
                 * href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
                 * Siegfried M. Rump, and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.
                 * &lt;/p&gt;                
                <@param>
                    m a1 first factor of the first term                    
                </@param>
                <@param>
                    m b1 second factor of the first term                    
                </@param>
                <@param>
                    m a2 first factor of the second term                    
                </@param>
                <@param>
                    m b2 second factor of the second term                    
                </@param>
                <@return>
                    n a<sub>1</sub>&times;b<sub>1</sub> +
                     * a<sub>2</sub>&times;b<sub>2</sub>                    
                </@return>
                <@see>
                    e #linearCombination(double,double,double,double,double,double)                    
                </@see>
                <@see>
                    e #linearCombination(double,double,double,double,double,double,double,double)                    
                </@see>
            </javadoc>
            <method name="linearCombination" type="double" line="881">
                <comment line="882">
                    the code below is split in many additions/subtractions that may                    
                </comment>
                <comment line="882">
                    appear redundant. However, they should NOT be simplified, as they                    
                </comment>
                <comment line="882">
                    use IEEE754 floating point arithmetic rounding properties.                    
                </comment>
                <comment line="882">
                    as an example, the expression &quot;ca1 - (ca1 - a1)&quot; is NOT the same as &quot;a1&quot;                    
                </comment>
                <comment line="882">
                    The variable naming conventions are that xyzHigh contains the most significant                    
                </comment>
                <comment line="882">
                    bits of xyz and xyzLow contains its least significant bits. So theoretically                    
                </comment>
                <comment line="882">
                    xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot                    
                </comment>
                <comment line="882">
                    be represented in only one double precision number so we preserve two numbers                    
                </comment>
                <comment line="882">
                    to hold it as long as we can, combining the high and low order bits together                    
                </comment>
                <comment line="882">
                    only at the end, after cancellation may have occurred on high order bits                    
                </comment>
                <comment line="882">
                    split a1 and b1 as two 26 bits numbers                    
                </comment>
                <comment line="882">
                    accurate multiplication a1 * b1                    
                </comment>
                <comment line="882">
                    split a2 and b2 as two 26 bits numbers                    
                </comment>
                <comment line="882">
                    accurate multiplication a2 * b2                    
                </comment>
                <comment line="882">
                    accurate addition a1 * b1 + a2 * b2                    
                </comment>
                <comment line="882">
                    final rounding, s12 may have suffered many cancellations, we try                    
                </comment>
                <comment line="882">
                    to recover some bits from the extra words we have saved up to now                    
                </comment>
                <declaration name="ca1" type="double" line="895"/>
                <declaration name="a1High" type="double" line="896"/>
                <declaration name="a1Low" type="double" line="897"/>
                <declaration name="cb1" type="double" line="898"/>
                <declaration name="b1High" type="double" line="899"/>
                <declaration name="b1Low" type="double" line="900"/>
                <declaration name="prod1High" type="double" line="903"/>
                <declaration name="prod1Low" type="double" line="904"/>
                <declaration name="ca2" type="double" line="907"/>
                <declaration name="a2High" type="double" line="908"/>
                <declaration name="a2Low" type="double" line="909"/>
                <declaration name="cb2" type="double" line="910"/>
                <declaration name="b2High" type="double" line="911"/>
                <declaration name="b2Low" type="double" line="912"/>
                <declaration name="prod2High" type="double" line="915"/>
                <declaration name="prod2Low" type="double" line="916"/>
                <declaration name="s12High" type="double" line="919"/>
                <declaration name="s12Prime" type="double" line="920"/>
                <declaration name="s12Low" type="double" line="921"/>
                <declaration name="result" type="double" line="925"/>
                <scope line="927"/>
            </method>
            <javadoc line="936">
                Compute a linear combination accurately.
                 * &lt;p&gt;
                 * This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;
                 * to high accuracy. It does so by using specific multiplication and
                 * addition algorithms to preserve accuracy and reduce cancellation effects.
                 * It is based on the 2005 paper &lt;a
                 * href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
                 * Siegfried M. Rump, and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.
                 * &lt;/p&gt;                
                <@param>
                    m a1 first factor of the first term                    
                </@param>
                <@param>
                    m b1 second factor of the first term                    
                </@param>
                <@param>
                    m a2 first factor of the second term                    
                </@param>
                <@param>
                    m b2 second factor of the second term                    
                </@param>
                <@param>
                    m a3 first factor of the third term                    
                </@param>
                <@param>
                    m b3 second factor of the third term                    
                </@param>
                <@return>
                    n a<sub>1</sub>&times;b<sub>1</sub> +
                     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>                    
                </@return>
                <@see>
                    e #linearCombination(double,double,double,double)                    
                </@see>
                <@see>
                    e #linearCombination(double,double,double,double,double,double,double,double)                    
                </@see>
            </javadoc>
            <method name="linearCombination" type="double" line="961">
                <comment line="962">
                    the code below is split in many additions/subtractions that may                    
                </comment>
                <comment line="962">
                    appear redundant. However, they should NOT be simplified, as they                    
                </comment>
                <comment line="962">
                    do use IEEE754 floating point arithmetic rounding properties.                    
                </comment>
                <comment line="962">
                    as an example, the expression &quot;ca1 - (ca1 - a1)&quot; is NOT the same as &quot;a1&quot;                    
                </comment>
                <comment line="962">
                    The variables naming conventions are that xyzHigh contains the most significant                    
                </comment>
                <comment line="962">
                    bits of xyz and xyzLow contains its least significant bits. So theoretically                    
                </comment>
                <comment line="962">
                    xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot                    
                </comment>
                <comment line="962">
                    be represented in only one double precision number so we preserve two numbers                    
                </comment>
                <comment line="962">
                    to hold it as long as we can, combining the high and low order bits together                    
                </comment>
                <comment line="962">
                    only at the end, after cancellation may have occurred on high order bits                    
                </comment>
                <comment line="962">
                    split a1 and b1 as two 26 bits numbers                    
                </comment>
                <comment line="962">
                    accurate multiplication a1 * b1                    
                </comment>
                <comment line="962">
                    split a2 and b2 as two 26 bits numbers                    
                </comment>
                <comment line="962">
                    accurate multiplication a2 * b2                    
                </comment>
                <comment line="962">
                    split a3 and b3 as two 26 bits numbers                    
                </comment>
                <comment line="962">
                    accurate multiplication a3 * b3                    
                </comment>
                <comment line="962">
                    accurate addition a1 * b1 + a2 * b2                    
                </comment>
                <comment line="962">
                    accurate addition a1 * b1 + a2 * b2 + a3 * b3                    
                </comment>
                <comment line="962">
                    final rounding, s123 may have suffered many cancellations, we try                    
                </comment>
                <comment line="962">
                    to recover some bits from the extra words we have saved up to now                    
                </comment>
                <declaration name="ca1" type="double" line="975"/>
                <declaration name="a1High" type="double" line="976"/>
                <declaration name="a1Low" type="double" line="977"/>
                <declaration name="cb1" type="double" line="978"/>
                <declaration name="b1High" type="double" line="979"/>
                <declaration name="b1Low" type="double" line="980"/>
                <declaration name="prod1High" type="double" line="983"/>
                <declaration name="prod1Low" type="double" line="984"/>
                <declaration name="ca2" type="double" line="987"/>
                <declaration name="a2High" type="double" line="988"/>
                <declaration name="a2Low" type="double" line="989"/>
                <declaration name="cb2" type="double" line="990"/>
                <declaration name="b2High" type="double" line="991"/>
                <declaration name="b2Low" type="double" line="992"/>
                <declaration name="prod2High" type="double" line="995"/>
                <declaration name="prod2Low" type="double" line="996"/>
                <declaration name="ca3" type="double" line="999"/>
                <declaration name="a3High" type="double" line="1000"/>
                <declaration name="a3Low" type="double" line="1001"/>
                <declaration name="cb3" type="double" line="1002"/>
                <declaration name="b3High" type="double" line="1003"/>
                <declaration name="b3Low" type="double" line="1004"/>
                <declaration name="prod3High" type="double" line="1007"/>
                <declaration name="prod3Low" type="double" line="1008"/>
                <declaration name="s12High" type="double" line="1011"/>
                <declaration name="s12Prime" type="double" line="1012"/>
                <declaration name="s12Low" type="double" line="1013"/>
                <declaration name="s123High" type="double" line="1016"/>
                <declaration name="s123Prime" type="double" line="1017"/>
                <declaration name="s123Low" type="double" line="1018"/>
                <declaration name="result" type="double" line="1022"/>
                <scope line="1024"/>
            </method>
            <javadoc line="1033">
                Compute a linear combination accurately.
                 * &lt;p&gt;
                 * This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                 * a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
                 * a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;
                 * to high accuracy. It does so by using specific multiplication and
                 * addition algorithms to preserve accuracy and reduce cancellation effects.
                 * It is based on the 2005 paper &lt;a
                 * href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                 * Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
                 * Siegfried M. Rump, and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.
                 * &lt;/p&gt;                
                <@param>
                    m a1 first factor of the first term                    
                </@param>
                <@param>
                    m b1 second factor of the first term                    
                </@param>
                <@param>
                    m a2 first factor of the second term                    
                </@param>
                <@param>
                    m b2 second factor of the second term                    
                </@param>
                <@param>
                    m a3 first factor of the third term                    
                </@param>
                <@param>
                    m b3 second factor of the third term                    
                </@param>
                <@param>
                    m a4 first factor of the third term                    
                </@param>
                <@param>
                    m b4 second factor of the third term                    
                </@param>
                <@return>
                    n a<sub>1</sub>&times;b<sub>1</sub> +
                     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
                     * a<sub>4</sub>&times;b<sub>4</sub>                    
                </@return>
                <@see>
                    e #linearCombination(double,double,double,double)                    
                </@see>
                <@see>
                    e #linearCombination(double,double,double,double,double,double)                    
                </@see>
            </javadoc>
            <method name="linearCombination" type="double" line="1063">
                <comment line="1064">
                    the code below is split in many additions/subtractions that may                    
                </comment>
                <comment line="1064">
                    appear redundant. However, they should NOT be simplified, as they                    
                </comment>
                <comment line="1064">
                    do use IEEE754 floating point arithmetic rounding properties.                    
                </comment>
                <comment line="1064">
                    as an example, the expression &quot;ca1 - (ca1 - a1)&quot; is NOT the same as &quot;a1&quot;                    
                </comment>
                <comment line="1064">
                    The variables naming conventions are that xyzHigh contains the most significant                    
                </comment>
                <comment line="1064">
                    bits of xyz and xyzLow contains its least significant bits. So theoretically                    
                </comment>
                <comment line="1064">
                    xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot                    
                </comment>
                <comment line="1064">
                    be represented in only one double precision number so we preserve two numbers                    
                </comment>
                <comment line="1064">
                    to hold it as long as we can, combining the high and low order bits together                    
                </comment>
                <comment line="1064">
                    only at the end, after cancellation may have occurred on high order bits                    
                </comment>
                <comment line="1064">
                    split a1 and b1 as two 26 bits numbers                    
                </comment>
                <comment line="1064">
                    accurate multiplication a1 * b1                    
                </comment>
                <comment line="1064">
                    split a2 and b2 as two 26 bits numbers                    
                </comment>
                <comment line="1064">
                    accurate multiplication a2 * b2                    
                </comment>
                <comment line="1064">
                    split a3 and b3 as two 26 bits numbers                    
                </comment>
                <comment line="1064">
                    accurate multiplication a3 * b3                    
                </comment>
                <comment line="1064">
                    split a4 and b4 as two 26 bits numbers                    
                </comment>
                <comment line="1064">
                    accurate multiplication a4 * b4                    
                </comment>
                <comment line="1064">
                    accurate addition a1 * b1 + a2 * b2                    
                </comment>
                <comment line="1064">
                    accurate addition a1 * b1 + a2 * b2 + a3 * b3                    
                </comment>
                <comment line="1064">
                    accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4                    
                </comment>
                <comment line="1064">
                    final rounding, s1234 may have suffered many cancellations, we try                    
                </comment>
                <comment line="1064">
                    to recover some bits from the extra words we have saved up to now                    
                </comment>
                <declaration name="ca1" type="double" line="1077"/>
                <declaration name="a1High" type="double" line="1078"/>
                <declaration name="a1Low" type="double" line="1079"/>
                <declaration name="cb1" type="double" line="1080"/>
                <declaration name="b1High" type="double" line="1081"/>
                <declaration name="b1Low" type="double" line="1082"/>
                <declaration name="prod1High" type="double" line="1085"/>
                <declaration name="prod1Low" type="double" line="1086"/>
                <declaration name="ca2" type="double" line="1089"/>
                <declaration name="a2High" type="double" line="1090"/>
                <declaration name="a2Low" type="double" line="1091"/>
                <declaration name="cb2" type="double" line="1092"/>
                <declaration name="b2High" type="double" line="1093"/>
                <declaration name="b2Low" type="double" line="1094"/>
                <declaration name="prod2High" type="double" line="1097"/>
                <declaration name="prod2Low" type="double" line="1098"/>
                <declaration name="ca3" type="double" line="1101"/>
                <declaration name="a3High" type="double" line="1102"/>
                <declaration name="a3Low" type="double" line="1103"/>
                <declaration name="cb3" type="double" line="1104"/>
                <declaration name="b3High" type="double" line="1105"/>
                <declaration name="b3Low" type="double" line="1106"/>
                <declaration name="prod3High" type="double" line="1109"/>
                <declaration name="prod3Low" type="double" line="1110"/>
                <declaration name="ca4" type="double" line="1113"/>
                <declaration name="a4High" type="double" line="1114"/>
                <declaration name="a4Low" type="double" line="1115"/>
                <declaration name="cb4" type="double" line="1116"/>
                <declaration name="b4High" type="double" line="1117"/>
                <declaration name="b4Low" type="double" line="1118"/>
                <declaration name="prod4High" type="double" line="1121"/>
                <declaration name="prod4Low" type="double" line="1122"/>
                <declaration name="s12High" type="double" line="1125"/>
                <declaration name="s12Prime" type="double" line="1126"/>
                <declaration name="s12Low" type="double" line="1127"/>
                <declaration name="s123High" type="double" line="1130"/>
                <declaration name="s123Prime" type="double" line="1131"/>
                <declaration name="s123Low" type="double" line="1132"/>
                <declaration name="s1234High" type="double" line="1135"/>
                <declaration name="s1234Prime" type="double" line="1136"/>
                <declaration name="s1234Low" type="double" line="1137"/>
                <declaration name="result" type="double" line="1141"/>
                <scope line="1143"/>
            </method>
            <javadoc line="1152">
                Returns true iff both arguments are null or have same dimensions and all
                 * their elements are equal as defined by{@link Precision#equals(float,float)}.                
                <@param>
                    m x first array                    
                </@param>
                <@param>
                    m y second array                    
                </@param>
                <@return>
                    n true if the values are both null or have same dimension
                     * and equal elements.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="1162">
                <scope line="1163"/>
                <scope line="1166"/>
                <scope line="1169">
                    <scope line="1170"/>
                </scope>
            </method>
            <javadoc line="1177">
                Returns true iff both arguments are null or have same dimensions and all
                 * their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.                
                <@param>
                    m x first array                    
                </@param>
                <@param>
                    m y second array                    
                </@param>
                <@return>
                    n true if the values are both null or have same dimension and
                     * equal elements                    
                </@return>
                <@since>
                    e 2.2                    
                </@since>
            </javadoc>
            <method name="equalsIncludingNaN" type="boolean" line="1188">
                <scope line="1189"/>
                <scope line="1192"/>
                <scope line="1195">
                    <scope line="1196"/>
                </scope>
            </method>
            <javadoc line="1203">
                Returns {@code true} iff both arguments are {@code null} or have same
                 * dimensions and all their elements are equal as defined by{@link Precision#equals(double,double)}.                
                <@param>
                    m x First array.                    
                </@param>
                <@param>
                    m y Second array.                    
                </@param>
                <@return>
                    n {@code true} if the values are both {@code null} or have same
                     * dimension and equal elements.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="1213">
                <scope line="1214"/>
                <scope line="1217"/>
                <scope line="1220">
                    <scope line="1221"/>
                </scope>
            </method>
            <javadoc line="1228">
                Returns {@code true} iff both arguments are {@code null} or have same
                 * dimensions and all their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.                
                <@param>
                    m x First array.                    
                </@param>
                <@param>
                    m y Second array.                    
                </@param>
                <@return>
                    n {@code true} if the values are both {@code null} or have same
                     * dimension and equal elements.                    
                </@return>
                <@since>
                    e 2.2                    
                </@since>
            </javadoc>
            <method name="equalsIncludingNaN" type="boolean" line="1239">
                <scope line="1240"/>
                <scope line="1243"/>
                <scope line="1246">
                    <scope line="1247"/>
                </scope>
            </method>
            <javadoc line="1254">
                Normalizes an array to make it sum to a specified value.
                 * Returns the result of the transformation &lt;pre&gt;
                 * x |-&gt; x * normalizedSum / sum
                 * &lt;/pre&gt;
                 * applied to each non-NaN element x of the input array, where sum is the
                 * sum of the non-NaN entries in the input array.&lt;/p&gt;
                 * &lt;p&gt;Throws IllegalArgumentException if {@code normalizedSum} is infinite
                 * or NaN and ArithmeticException if the input array contains any infinite elements
                 * or sums to 0.&lt;/p&gt;
                 * &lt;p&gt;Ignores (i.e., copies unchanged to the output array) NaNs in the input array.&lt;/p&gt;                
                <@param>
                    m values Input array to be normalized                    
                </@param>
                <@param>
                    m normalizedSum Target sum for the normalized array                    
                </@param>
                <@return>
                    n the normalized array.                    
                </@return>
                <@throws>
                    s MathArithmeticException if the input array contains infinite
                     * elements or sums to zero.                    
                </@throws>
                <@throws>
                    s MathIllegalArgumentException if the target sum is infinite or {@code NaN}.                    
                </@throws>
                <@since>
                    e 2.1                    
                </@since>
            </javadoc>
            <method name="normalizeArray" type="double[]" line="1277">
                <scope line="1278"/>
                <scope line="1281"/>
                <declaration name="sum" type="double" line="1284"/>
                <declaration name="len" type="int" line="1285"/>
                <declaration name="out" type="double[]" line="1286"/>
                <scope line="1287">
                    <scope line="1288"/>
                    <scope line="1291"/>
                </scope>
                <scope line="1295"/>
                <scope line="1298">
                    <scope line="1299"/>
                    <scope line="1301"/>
                </scope>
            </method>
            <javadoc line="1308">
                Build an array of elements.
                 * &lt;p&gt;
                 * Arrays are filled with field.getZero()
                 * &lt;/p&gt;                
                <@param>
                    m<T>
                     *  the type of the field elements                    
                </@param>
                <@param>
                    m field field to which array elements belong                    
                </@param>
                <@param>
                    m length of the array                    
                </@param>
                <@return>
                    n a new array                    
                </@return>
                <@since>
                    e 3.2                    
                </@since>
            </javadoc>
            <method name="buildArray" type="T[]" line="1318">
                <declaration name="array" type="T[]" line="1319"/>
            </method>
            <javadoc line="1325">
                Build a double dimension  array of elements.
                 * &lt;p&gt;
                 * Arrays are filled with field.getZero()
                 * &lt;/p&gt;                
                <@param>
                    m<T>
                     *  the type of the field elements                    
                </@param>
                <@param>
                    m field field to which array elements belong                    
                </@param>
                <@param>
                    m rows number of rows in the array                    
                </@param>
                <@param>
                    m columns number of columns (may be negative to build partial
                     * arrays in the same way <code>new Field[rows][]</code> works)                    
                </@param>
                <@return>
                    n a new array                    
                </@return>
                <@since>
                    e 3.2                    
                </@since>
            </javadoc>
            <method name="buildArray" type="T[][]" line="1338">
                <declaration name="array" type="T[][]" line="1339"/>
                <scope line="1340">
                    <declaration name="dummyRow" type="T[]" line="1341"/>
                </scope>
                <scope line="1343">
                    <scope line="1348"/>
                </scope>
            </method>
        </class>
    </source>