<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.transform">
        <import package="java.io.Serializable"/>
        <import package="java.lang.reflect.Array"/>
        <import package="org.apache.commons.math3.analysis.FunctionUtils"/>
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.complex.Complex"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.ArithmeticUtils"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathArrays"/>
        <class name="FastFourierTransformer" line="33">
            <implements interface="Serializable"/>
            <javadoc line="33">
                Implements the Fast Fourier Transform for transformation of one-dimensional
                 * real or complex data sets. For reference, see &lt;em&gt;Applied Numerical Linear
                 * Algebra&lt;/em&gt;, ISBN 0898713897, chapter 6.
                 * &lt;p&gt;
                 * There are several variants of the discrete Fourier transform, with various
                 * normalization conventions, which are specified by the parameter{@link DftNormalization}.
                 * &lt;p&gt;
                 * The current implementation of the discrete Fourier transform as a fast
                 * Fourier transform requires the length of the data set to be a power of 2.
                 * This greatly simplifies and speeds up the code. Users can pad the data with
                 * zeros to meet this requirement. There are other flavors of FFT, for
                 * reference, see S. Winograd,
                 * &lt;i&gt;On computing the discrete Fourier transform&lt;/i&gt;, Mathematics of
                 * Computation, 32 (1978), 175 - 199.                
                <@see>
                    e DftNormalization                    
                </@see>
                <@version>
                    n $Id: FastFourierTransformer.java 1385310 2012-09-16 16:32:10Z tn $                    
                </@version>
                <@since>
                    e 1.2                    
                </@since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="56"/>
            <javadoc line="56">
                Serializable version identifier.                
            </javadoc>
            <declaration name="W_SUB_N_R" type="double[]" line="59"/>
            <javadoc line="59">
                {@code W_SUB_N_R[i]} is the real part of{@code exp(- 2 * i * pi / n)}:{@code W_SUB_N_R[i] = cos(2 * pi/ n)}, where {@code n = 2^i}.                
            </javadoc>
            <declaration name="W_SUB_N_I" type="double[]" line="82"/>
            <javadoc line="82">
                {@code W_SUB_N_I[i]} is the imaginary part of{@code exp(- 2 * i * pi / n)}:{@code W_SUB_N_I[i] = -sin(2 * pi/ n)}, where {@code n = 2^i}.                
            </javadoc>
            <declaration name="normalization" type="DftNormalization" line="105"/>
            <javadoc line="105">
                The type of DFT to be performed.                
            </javadoc>
            <javadoc line="108">
                Creates a new instance of this class, with various normalization
                 * conventions.                
                <@param>
                    m normalization the type of normalization to be applied to the
                     * transformed data                    
                </@param>
            </javadoc>
            <method name="FastFourierTransformer" type="constructor" line="115"/>
            <javadoc line="119">
                Performs identical index bit reversal shuffles on two arrays of identical
                 * size. Each element in the array is swapped with another element based on
                 * the bit-reversal of the index. For example, in an array with length 16,
                 * item at binary index 0011 (decimal 3) would be swapped with the item at
                 * binary index 1100 (decimal 12).                
                <@param>
                    m a the first array to be shuffled                    
                </@param>
                <@param>
                    m b the second array to be shuffled                    
                </@param>
            </javadoc>
            <method name="bitReversalShuffle2" type="void" line="129">
                <declaration name="n" type="int" line="130"/>
                <declaration name="halfOfN" type="int" line="132"/>
                <declaration name="j" type="int" line="134"/>
                <scope line="135">
                    <scope line="136">
                        <declaration name="temp" type="double" line="138"/>
                    </scope>
                    <declaration name="k" type="int" line="147"/>
                    <scope line="148"/>
                </scope>
            </method>
            <javadoc line="156">
                Applies the proper normalization to the specified transformed data.                
                <@param>
                    m dataRI the unscaled transformed data                    
                </@param>
                <@param>
                    m normalization the normalization to be applied                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) which resulted in the specified data                    
                </@param>
            </javadoc>
            <method name="normalizeTransformedData" type="void" line="164">
                <declaration name="dataR" type="double[]" line="166"/>
                <declaration name="dataI" type="double[]" line="167"/>
                <declaration name="n" type="int" line="168"/>
                <scope line="173">
                    <declaration name="scaleFactor" type="double" line="174"/>
                    <scope line="175"/>
                </scope>
                <declaration name="scaleFactor" type="double" line="182"/>
                <scope line="183"/>
            </method>
            <javadoc line="199">
                Computes the standard transform of the specified complex data. The
                 * computation is done in place. The input data is laid out as follows
                 * &lt;ul&gt;
                 * &lt;li&gt;{@code dataRI[0][i]} is the real part of the {@code i}-th data point,&lt;/li&gt;
                 * &lt;li&gt;{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data point.&lt;/li&gt;
                 * &lt;/ul&gt;                
                <@param>
                    m dataRI the two dimensional array of real and imaginary parts of the data                    
                </@param>
                <@param>
                    m normalization the normalization to be applied to the transformed data                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) to be performed                    
                </@param>
                <@throws>
                    s DimensionMismatchException if the number of rows of the specified
                     * array is not two, or the array is not rectangular                    
                </@throws>
                <@throws>
                    s MathIllegalArgumentException if the number of data points is not
                     * a power of two                    
                </@throws>
            </javadoc>
            <method name="transformInPlace" type="void" line="216">
                <comment line="217">
                    Do 4-term DFT.                    
                </comment>
                <scope line="218"/>
                <declaration name="dataR" type="double[]" line="221"/>
                <declaration name="dataI" type="double[]" line="222"/>
                <scope line="223"/>
                <declaration name="n" type="int" line="227"/>
                <scope line="228"/>
                <scope line="234"/>
                <scope line="236">
                    <declaration name="srcR0" type="double" line="237"/>
                    <declaration name="srcI0" type="double" line="238"/>
                    <declaration name="srcR1" type="double" line="239"/>
                    <declaration name="srcI1" type="double" line="240"/>
                </scope>
                <scope line="256">
                    <scope line="257">
                        <declaration name="i1" type="int" line="258"/>
                        <declaration name="i2" type="int" line="259"/>
                        <declaration name="i3" type="int" line="260"/>
                        <declaration name="srcR0" type="double" line="262"/>
                        <declaration name="srcI0" type="double" line="263"/>
                        <declaration name="srcR1" type="double" line="264"/>
                        <declaration name="srcI1" type="double" line="265"/>
                        <declaration name="srcR2" type="double" line="266"/>
                        <declaration name="srcI2" type="double" line="267"/>
                        <declaration name="srcR3" type="double" line="268"/>
                        <declaration name="srcI3" type="double" line="269"/>
                    </scope>
                </scope>
                <scope line="285">
                    <scope line="286">
                        <declaration name="i1" type="int" line="287"/>
                        <declaration name="i2" type="int" line="288"/>
                        <declaration name="i3" type="int" line="289"/>
                        <declaration name="srcR0" type="double" line="291"/>
                        <declaration name="srcI0" type="double" line="292"/>
                        <declaration name="srcR1" type="double" line="293"/>
                        <declaration name="srcI1" type="double" line="294"/>
                        <declaration name="srcR2" type="double" line="295"/>
                        <declaration name="srcI2" type="double" line="296"/>
                        <declaration name="srcR3" type="double" line="297"/>
                        <declaration name="srcI3" type="double" line="298"/>
                    </scope>
                </scope>
                <declaration name="lastN0" type="int" line="316"/>
                <declaration name="lastLogN0" type="int" line="317"/>
                <scope line="318">
                    <declaration name="n0" type="int" line="319"/>
                    <declaration name="logN0" type="int" line="320"/>
                    <declaration name="wSubN0R" type="double" line="321"/>
                    <declaration name="wSubN0I" type="double" line="322"/>
                    <scope line="323"/>
                    <scope line="328">
                        <declaration name="destOddStartIndex" type="int" line="329"/>
                        <declaration name="wSubN0ToRR" type="double" line="331"/>
                        <declaration name="wSubN0ToRI" type="double" line="332"/>
                        <scope line="334">
                            <declaration name="grR" type="double" line="335"/>
                            <declaration name="grI" type="double" line="336"/>
                            <declaration name="hrR" type="double" line="337"/>
                            <declaration name="hrI" type="double" line="338"/>
                            <declaration name="nextWsubN0ToRR" type="double" line="348"/>
                            <declaration name="nextWsubN0ToRI" type="double" line="349"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="362">
                Returns the (forward, inverse) transform of the specified real data set.                
                <@param>
                    m f the real data array to be transformed                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) to be performed                    
                </@param>
                <@return>
                    n the complex transformed array                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the length of the data array is not a power of two                    
                </@throws>
            </javadoc>
            <method name="transform" type="Complex[]" line="370">
                <declaration name="dataRI" type="double[][]" line="371"/>
            </method>
            <javadoc line="380">
                Returns the (forward, inverse) transform of the specified real function,
                 * sampled on the specified interval.                
                <@param>
                    m f the function to be sampled and transformed                    
                </@param>
                <@param>
                    m min the (inclusive) lower bound for the interval                    
                </@param>
                <@param>
                    m max the (exclusive) upper bound for the interval                    
                </@param>
                <@param>
                    m n the number of sample points                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) to be performed                    
                </@param>
                <@return>
                    n the complex transformed array                    
                </@return>
                <@throws>
                    s org.apache.commons.math3.exception.NumberIsTooLargeExceptionif the lower bound is greater than, or equal to the upper bound                    
                </@throws>
                <@throws>
                    s org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points {@code n} is negative                    
                </@throws>
                <@throws>
                    s MathIllegalArgumentException if the number of sample points{@code n} is not a power of two                    
                </@throws>
            </javadoc>
            <method name="transform" type="Complex[]" line="399">
                <declaration name="data" type="double[]" line="401"/>
            </method>
            <javadoc line="405">
                Returns the (forward, inverse) transform of the specified complex data set.                
                <@param>
                    m f the complex data array to be transformed                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) to be performed                    
                </@param>
                <@return>
                    n the complex transformed array                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the length of the data array is not a power of two                    
                </@throws>
            </javadoc>
            <method name="transform" type="Complex[]" line="413">
                <declaration name="dataRI" type="double[][]" line="414"/>
            </method>
            <javadoc line="421">
                Performs a multi-dimensional Fourier transform on a given array. Use{@link #transform(Complex[],TransformType)} in a row-column
                 * implementation in any number of dimensions with
                 * O(N&amp;times;log(N)) complexity with
                 * N = n&lt;sub&gt;1&lt;/sub&gt; &amp;times; n&lt;sub&gt;2&lt;/sub&gt; &amp;times;n&lt;sub&gt;3&lt;/sub&gt; &amp;times; ...
                 * &amp;times; n&lt;sub&gt;d&lt;/sub&gt;, where n&lt;sub&gt;k&lt;/sub&gt; is the number of elements in
                 * dimension k, and d is the total number of dimensions.                
                <@param>
                    m mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) to be performed                    
                </@param>
                <@return>
                    n transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}                    
                </@return>
                <@throws>
                    s IllegalArgumentException if any dimension is not a power of two                    
                </@throws>
                <@deprecated>
                    d see MATH-736                    
                </@deprecated>
            </javadoc>
            <method name="mdfft" type="Object" line="437">
                <comment line="438">
                    cycle through each dimension                    
                </comment>
                <declaration name="mdcm" type="MultiDimensionalComplexMatrix" line="438"/>
                <declaration name="dimensionSize" type="int[]" line="440"/>
                <scope line="442"/>
            </method>
            <javadoc line="448">
                Performs one dimension of a multi-dimensional Fourier transform.                
                <@param>
                    m mdcm input matrix                    
                </@param>
                <@param>
                    m type the type of transform (forward, inverse) to be performed                    
                </@param>
                <@param>
                    m d index of the dimension to process                    
                </@param>
                <@param>
                    m subVector recursion subvector                    
                </@param>
                <@throws>
                    s IllegalArgumentException if any dimension is not a power of two                    
                </@throws>
                <@deprecated>
                    d see MATH-736                    
                </@deprecated>
            </javadoc>
            <method name="mdfft" type="void" line="460">
                <comment line="461">
                    if done                    
                </comment>
                <declaration name="dimensionSize" type="int[]" line="462"/>
                <scope line="464">
                    <declaration name="temp" type="Complex[]" line="465"/>
                    <scope line="466"/>
                    <scope line="474"/>
                </scope>
                <scope line="478">
                    <declaration name="vector" type="int[]" line="479"/>
                    <scope line="481"/>
                    <scope line="486">
                        <scope line="487"/>
                    </scope>
                </scope>
            </method>
            <class name="MultiDimensionalComplexMatrix" line="496">
                <implements interface="Cloneable"/>
                <javadoc line="496">
                    Complex matrix implementation. Not designed for synchronized access may
                     * eventually be replaced by jsr-83 of the java community process
                     * http://jcp.org/en/jsr/detail?id=83
                     * may require additional exception throws for other basic requirements.                    
                    <@deprecated>
                        d see MATH-736                        
                    </@deprecated>
                </javadoc>
                <declaration name="dimensionSize" type="int[]" line="508"/>
                <javadoc line="508">
                    Size in all dimensions.                    
                </javadoc>
                <declaration name="multiDimensionalComplexArray" type="Object" line="511"/>
                <javadoc line="511">
                    Storage array.                    
                </javadoc>
                <javadoc line="514">
                    Simple constructor.                    
                    <@param>
                        m multiDimensionalComplexArray array containing the matrix
                         * elements                        
                    </@param>
                </javadoc>
                <method name="MultiDimensionalComplexMatrix" type="constructor" line="521">
                    <comment line="522">
                        count dimensions                        
                    </comment>
                    <comment line="522">
                        allocate array with exact count                        
                    </comment>
                    <comment line="522">
                        fill array                        
                    </comment>
                    <declaration name="numOfDimensions" type="int" line="526"/>
                    <scope line="528">
                        <declaration name="array" type="Object[]" line="529"/>
                    </scope>
                    <scope line="540">
                        <declaration name="array" type="Object[]" line="541"/>
                    </scope>
                </method>
                <javadoc line="548">
                    Get a matrix element.                    
                    <@param>
                        m vector indices of the element                        
                    </@param>
                    <@return>
                        n matrix element                        
                    </@return>
                    <@exception>
                        n DimensionMismatchException if dimensions do not match                        
                    </@exception>
                </javadoc>
                <method name="get" type="Complex" line="556">
                    <scope line="558">
                        <scope line="559"/>
                    </scope>
                    <scope line="566"/>
                    <declaration name="lastDimension" type="Object" line="572"/>
                    <scope line="574"/>
                </method>
                <javadoc line="580">
                    Set a matrix element.                    
                    <@param>
                        m magnitude magnitude of the element                        
                    </@param>
                    <@param>
                        m vector indices of the element                        
                    </@param>
                    <@return>
                        n the previous value                        
                    </@return>
                    <@exception>
                        n DimensionMismatchException if dimensions do not match                        
                    </@exception>
                </javadoc>
                <method name="set" type="Complex" line="589">
                    <scope line="591">
                        <scope line="592"/>
                    </scope>
                    <scope line="599"/>
                    <declaration name="lastDimension" type="Object[]" line="605"/>
                    <scope line="606"/>
                    <declaration name="lastValue" type="Complex" line="610"/>
                </method>
                <javadoc line="616">
                    Get the size in all dimensions.                    
                    <@return>
                        n size in all dimensions                        
                    </@return>
                </javadoc>
                <method name="getDimensionSizes" type="int[]" line="621"/>
                <javadoc line="625">
                    Get the underlying storage array.                    
                    <@return>
                        n underlying storage array                        
                    </@return>
                </javadoc>
                <method name="getArray" type="Object" line="630"/>
                <javadoc line="634">
                    {@inheritDoc}                    
                </javadoc>
                <method name="clone" type="Object" line="636">
                    <declaration name="mdcm" type="MultiDimensionalComplexMatrix" line="637"/>
                </method>
                <javadoc line="644">
                    Copy contents of current array into mdcm.                    
                    <@param>
                        m mdcm array where to copy data                        
                    </@param>
                </javadoc>
                <method name="clone" type="void" line="649">
                    <declaration name="vector" type="int[]" line="651"/>
                    <declaration name="size" type="int" line="652"/>
                    <scope line="653"/>
                    <declaration name="vectorList" type="int[][]" line="656"/>
                    <scope line="657">
                        <scope line="660">
                            <scope line="662"/>
                            <scope line="664"/>
                        </scope>
                    </scope>
                    <scope line="670"/>
                </method>
            </class>
        </class>
    </source>