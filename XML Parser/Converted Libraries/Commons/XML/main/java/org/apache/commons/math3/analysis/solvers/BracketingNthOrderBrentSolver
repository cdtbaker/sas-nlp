<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.solvers">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.TooManyEvaluationsException"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <class name="BracketingNthOrderBrentSolver" extends="AbstractUnivariateSolver" line="29">
            <implements interface="BracketedUnivariateSolver&lt;UnivariateFunction&gt;"/>
            <javadoc line="29">
                This class implements a modification of the &lt;a
                 * href=&quot;http://mathworld.wolfram.com/BrentsMethod.html&quot;&gt; Brent algorithm&lt;/a&gt;.
                 * &lt;p&gt;
                 * The changes with respect to the original Brent algorithm are:
                 * &lt;ul&gt;
                 * &lt;li&gt;the returned value is chosen in the current interval according
                 * to user specified {@link AllowedSolution},&lt;/li&gt;
                 * &lt;li&gt;the maximal order for the invert polynomial root search is
                 * user-specified instead of being invert quadratic only&lt;/li&gt;
                 * &lt;/ul&gt;
                 * &lt;/p&gt;
                 * The given interval must bracket the root.                
                <@version>
                    n $Id: BracketingNthOrderBrentSolver.java 1379560 2012-08-31 19:40:30Z erans $                    
                </@version>
            </javadoc>
            <declaration name="DEFAULT_ABSOLUTE_ACCURACY" type="double" line="49"/>
            <javadoc line="49">
                Default absolute accuracy.                
            </javadoc>
            <declaration name="DEFAULT_MAXIMAL_ORDER" type="int" line="52"/>
            <javadoc line="52">
                Default maximal order.                
            </javadoc>
            <declaration name="MAXIMAL_AGING" type="int" line="55"/>
            <javadoc line="55">
                Maximal aging triggering an attempt to balance the bracketing interval.                
            </javadoc>
            <declaration name="REDUCTION_FACTOR" type="double" line="58"/>
            <javadoc line="58">
                Reduction factor for attempts to balance the bracketing interval.                
            </javadoc>
            <declaration name="maximalOrder" type="int" line="61"/>
            <javadoc line="61">
                Maximal order.                
            </javadoc>
            <declaration name="allowed" type="AllowedSolution" line="64"/>
            <javadoc line="64">
                The kinds of solutions that the algorithm may accept.                
            </javadoc>
            <javadoc line="67">
                Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)                
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="70"/>
            <javadoc line="74">
                Construct a solver.                
                <@param>
                    m absoluteAccuracy Absolute accuracy.                    
                </@param>
                <@param>
                    m maximalOrder maximal order.                    
                </@param>
                <@exception>
                    n NumberIsTooSmallException if maximal order is lower than 2                    
                </@exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="83">
                <scope line="85"/>
            </method>
            <javadoc line="92">
                Construct a solver.                
                <@param>
                    m relativeAccuracy Relative accuracy.                    
                </@param>
                <@param>
                    m absoluteAccuracy Absolute accuracy.                    
                </@param>
                <@param>
                    m maximalOrder maximal order.                    
                </@param>
                <@exception>
                    n NumberIsTooSmallException if maximal order is lower than 2                    
                </@exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="103">
                <scope line="105"/>
            </method>
            <javadoc line="112">
                Construct a solver.                
                <@param>
                    m relativeAccuracy Relative accuracy.                    
                </@param>
                <@param>
                    m absoluteAccuracy Absolute accuracy.                    
                </@param>
                <@param>
                    m functionValueAccuracy Function value accuracy.                    
                </@param>
                <@param>
                    m maximalOrder maximal order.                    
                </@param>
                <@exception>
                    n NumberIsTooSmallException if maximal order is lower than 2                    
                </@exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="125">
                <scope line="127"/>
            </method>
            <javadoc line="134">
                Get the maximal order.                
                <@return>
                    n maximal order                    
                </@return>
            </javadoc>
            <method name="getMaximalOrder" type="int" line="137"/>
            <javadoc line="141">
                {@inheritDoc}                
            </javadoc>
            <method name="doSolve" type="double" line="148">
                <comment line="149">
                    prepare arrays with the first points                    
                </comment>
                <comment line="149">
                    evaluate initial guess                    
                </comment>
                <comment line="149">
                    evaluate first  endpoint                    
                </comment>
                <comment line="149">
                    prepare a work array for inverse polynomial interpolation                    
                </comment>
                <comment line="149">
                    current tightest bracketing of the root                    
                </comment>
                <comment line="149">
                    search loop                    
                </comment>
                <declaration name="x" type="double[]" line="150"/>
                <declaration name="y" type="double[]" line="151"/>
                <scope line="159"/>
                <scope line="166"/>
                <declaration name="nbPoints" type="int" line="171"/>
                <declaration name="signChangeIndex" type="int" line="172"/>
                <scope line="173"/>
                <scope line="179">
                    <scope line="183"/>
                    <scope line="188"/>
                    <scope line="192"/>
                </scope>
                <declaration name="tmpX" type="double[]" line="199"/>
                <declaration name="xA" type="double" line="202"/>
                <declaration name="yA" type="double" line="203"/>
                <declaration name="absYA" type="double" line="204"/>
                <declaration name="agingA" type="int" line="205"/>
                <declaration name="xB" type="double" line="206"/>
                <declaration name="yB" type="double" line="207"/>
                <declaration name="absYB" type="double" line="208"/>
                <declaration name="agingB" type="int" line="209"/>
                <scope line="212">
                    <declaration name="xTol" type="double" line="215"/>
                    <scope line="217"/>
                    <declaration name="targetY" type="double" line="236"/>
                    <scope line="237">
                        <declaration name="p" type="int" line="239"/>
                        <declaration name="weightA" type="double" line="240"/>
                        <declaration name="weightB" type="double" line="241"/>
                    </scope>
                    <scope line="243">
                        <declaration name="p" type="int" line="245"/>
                        <declaration name="weightA" type="double" line="246"/>
                        <declaration name="weightB" type="double" line="247"/>
                    </scope>
                    <scope line="249"/>
                    <declaration name="nextX" type="double" line="255"/>
                    <declaration name="start" type="int" line="256"/>
                    <declaration name="end" type="int" line="257"/>
                    <scope line="258">
                        <scope line="264">
                            <scope line="270"/>
                            <scope line="273"/>
                        </scope>
                    </scope>
                    <scope line="285"/>
                    <declaration name="nextY" type="double" line="293"/>
                    <scope line="294"/>
                    <scope line="300"/>
                    <scope line="309">
                        <scope line="315"/>
                    </scope>
                    <scope line="333"/>
                    <scope line="340"/>
                </scope>
            </method>
            <javadoc line="357">
                Guess an x value by n&lt;sup&gt;th&lt;/sup&gt; order inverse polynomial interpolation.
                 * &lt;p&gt;
                 * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
                 * is built such that for all considered points (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;),
                 * Q(y&lt;sub&gt;i&lt;/sub&gt;) = x&lt;sub&gt;i&lt;/sub&gt;.
                 * &lt;/p&gt;                
                <@param>
                    m targetY target value for y                    
                </@param>
                <@param>
                    m x reference points abscissas for interpolation,
                     * note that this array <em>is</em> modified during computation                    
                </@param>
                <@param>
                    m y reference points ordinates for interpolation                    
                </@param>
                <@param>
                    m start start index of the points to consider (inclusive)                    
                </@param>
                <@param>
                    m end end index of the points to consider (exclusive)                    
                </@param>
                <@return>
                    n guessed root (will be a NaN if two points share the same y)                    
                </@return>
            </javadoc>
            <method name="guessX" type="double" line="372">
                <comment line="373">
                    compute Q Newton coefficients by divided differences                    
                </comment>
                <comment line="373">
                    evaluate Q(targetY)                    
                </comment>
                <scope line="375">
                    <declaration name="delta" type="int" line="376"/>
                    <scope line="377"/>
                </scope>
                <declaration name="x0" type="double" line="383"/>
                <scope line="384"/>
            </method>
            <javadoc line="392">
                {@inheritDoc}                
            </javadoc>
            <method name="solve" type="double" line="397"/>
            <javadoc line="402">
                {@inheritDoc}                
            </javadoc>
            <method name="solve" type="double" line="408"/>
        </class>
    </source>