<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.interpolation">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.analysis.polynomials.PolynomialFunctionLagrangeForm"/>
        <import package="org.apache.commons.math3.analysis.polynomials.PolynomialFunctionNewtonForm"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.NonMonotonicSequenceException"/>
        <class name="DividedDifferenceInterpolator" line="26">
            <implements interface="UnivariateInterpolator"/>
            <implements interface="Serializable"/>
            <javadoc line="26">
                Implements the &lt;a href=&quot;
                 * http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html&quot;&gt;
                 * Divided Difference Algorithm&lt;/a&gt; for interpolation of real univariate
                 * functions. For reference, see &lt;b&gt;Introduction to Numerical Analysis&lt;/b&gt;,
                 * ISBN 038795452X, chapter 2.
                 * &lt;p&gt;
                 * The actual code of Neville&apos;s evaluation is in PolynomialFunctionLagrangeForm,
                 * this class provides an easy-to-use interface to it.&lt;/p&gt;                
                <@version>
                    n $Id: DividedDifferenceInterpolator.java 1385313 2012-09-16 16:35:23Z tn $                    
                </@version>
                <@since>
                    e 1.2                    
                </@since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="41"/>
            <javadoc line="41">
                serializable version identifier                
            </javadoc>
            <javadoc line="44">
                Compute an interpolating function for the dataset.                
                <@param>
                    m x Interpolating points array.                    
                </@param>
                <@param>
                    m y Interpolating values array.                    
                </@param>
                <@return>
                    n a function which interpolates the dataset.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the array lengths are different.                    
                </@throws>
                <@throws>
                    s NumberIsTooSmallException if the number of points is less than 2.                    
                </@throws>
                <@throws>
                    s NonMonotonicSequenceException if {@code x} is not sorted in
                     * strictly increasing order.                    
                </@throws>
            </javadoc>
            <method name="interpolate" type="PolynomialFunctionNewtonForm" line="58">
                <comment line="59">
                    a[] and c[] are defined in the general formula of Newton form:
                     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +                    
                </comment>
                <comment line="59">
                    When used for interpolation, the Newton form formula becomes
                     p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +
                            f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])
                     Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].
                     &lt;p&gt;                    
                </comment>
                <declaration name="c" type="double[]" line="74"/>
                <declaration name="a" type="double[]" line="77"/>
            </method>
            <javadoc line="81">
                Return a copy of the divided difference array.
                 * &lt;p&gt;
                 * The divided difference array is defined recursively by &lt;pre&gt;
                 * f[x0] = f(x0)
                 * f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)
                 * &lt;/pre&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * The computational complexity is O(N^2).&lt;/p&gt;                
                <@param>
                    m x Interpolating points array.                    
                </@param>
                <@param>
                    m y Interpolating values array.                    
                </@param>
                <@return>
                    n a fresh copy of the divided difference array.                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the array lengths are different.                    
                </@throws>
                <@throws>
                    s NumberIsTooSmallException if the number of points is less than 2.                    
                </@throws>
                <@throws>
                    s NonMonotonicSequenceExceptionif {@code x} is not sorted in strictly increasing order.                    
                </@throws>
            </javadoc>
            <method name="computeDividedDifference" type="double[]" line="102">
                <comment line="103">
                    nal double[] divdiff = y.clone(); // initialization                    
                </comment>
                <declaration name="divdiff" type="double[]" line="105"/>
                <declaration name="n" type="int" line="107"/>
                <declaration name="a" type="double[]" line="108"/>
                <scope line="110">
                    <scope line="111">
                        <declaration name="denominator" type="double" line="112"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>