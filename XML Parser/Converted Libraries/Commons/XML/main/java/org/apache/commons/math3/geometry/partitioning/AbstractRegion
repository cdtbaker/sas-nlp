<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning">
        <import package="java.lang.reflect.Array"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.TreeSet"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.geometry.Space"/>
        <import package="org.apache.commons.math3.geometry.Vector"/>
        <class name="AbstractRegion" line="30">
            <implements interface="Region&lt;S&gt;"/>
            <javadoc line="30">
                Abstract class for all regions, independently of geometry type or dimension.                
                <@param>
                    m<S>
                     *  Type of the space.                    
                </@param>
                <@param>
                    m<T>
                     *  Type of the sub-space.                    
                </@param>
                <@version>
                    n $Id: AbstractRegion.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <declaration name="tree" type="BSPTree&lt;S&gt;" line="40"/>
            <javadoc line="40">
                Inside/Outside BSP tree.                
            </javadoc>
            <declaration name="size" type="double" line="43"/>
            <javadoc line="43">
                Size of the instance.                
            </javadoc>
            <declaration name="barycenter" type="Vector&lt;S&gt;" line="46"/>
            <javadoc line="46">
                Barycenter.                
            </javadoc>
            <javadoc line="49">
                Build a region representing the whole space.                
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="51"/>
            <javadoc line="55">
                Build a region from an inside/outside BSP tree.
                 * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                 * the corresponding cell (true for inside cells, false for outside
                 * cells). In order to avoid building too many small objects, it is
                 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
                 * tree also &lt;em&gt;must&lt;/em&gt; have either null internal nodes or
                 * internal nodes representing the boundary as specified in the{@link #getTree getTree} method).&lt;/p&gt;                
                <@param>
                    m tree inside/outside BSP tree representing the region                    
                </@param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="67"/>
            <javadoc line="71">
                Build a Region from a Boundary REPresentation (B-rep).
                 * &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                 * interior part of the region on its minus side and the exterior on
                 * its plus side.&lt;/p&gt;
                 * &lt;p&gt;The boundary elements can be in any order, and can form
                 * several non-connected sets (like for example polygons with holes
                 * or a set of disjoints polyhedrons considered as a whole). In
                 * fact, the elements do not even need to be connected together
                 * (their topological connections are not used here). However, if the
                 * boundary does not really separate an inside open from an outside
                 * open (open having here its topological meaning), then subsequent
                 * calls to the {@link #checkPoint(Vector) checkPoint} method will not be
                 * meaningful anymore.&lt;/p&gt;
                 * &lt;p&gt;If the boundary is empty, the region will represent the whole
                 * space.&lt;/p&gt;                
                <@param>
                    m boundary collection of boundary elements, as a
                     * collection of {@link SubHyperplane SubHyperplane} objects                    
                </@param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="90">
                <scope line="92"/>
                <scope line="97">
                    <anonymous_class line="102">
                        <method name="compare" type="int" line="103">
                            <declaration name="size1" type="double" line="104"/>
                            <declaration name="size2" type="double" line="105"/>
                        </method>
                    </anonymous_class>
                    <declaration name="ordered" type="TreeSet&lt;SubHyperplane&lt;S&gt;&gt;" line="102"/>
                    <anonymous_class line="116">
                        <javadoc line="118">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitOrder" type="Order" line="119"/>
                        <javadoc line="123">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitInternalNode" type="void" line="124"/>
                        <javadoc line="127">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitLeafNode" type="void" line="128"/>
                    </anonymous_class>
                </scope>
            </method>
            <javadoc line="138">
                Build a convex region from an array of bounding hyperplanes.                
                <@param>
                    m hyperplanes array of bounding hyperplanes (if null, an
                     * empty region will be built)                    
                </@param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="142">
                <scope line="143"/>
                <scope line="145">
                    <declaration name="node" type="BSPTree&lt;S&gt;" line="151"/>
                    <scope line="153">
                        <scope line="154"/>
                    </scope>
                </scope>
            </method>
            <method name="buildNew" type="AbstractRegion<S,T>" line="166"/>
            <javadoc line="166">
                {@inheritDoc}                
            </javadoc>
            <javadoc line="169">
                Recursively build a tree by inserting cut sub-hyperplanes.                
                <@param>
                    m node current tree node (it is a leaf node at the beginning
                     * of the call)                    
                </@param>
                <@param>
                    m boundary collection of edges belonging to the cell defined
                     * by the node                    
                </@param>
            </javadoc>
            <method name="insertCuts" type="void" line="175">
                <comment line="176">
                    build the current level                    
                </comment>
                <comment line="176">
                    distribute the remaining edges in the two sub-trees                    
                </comment>
                <comment line="176">
                    recurse through lower levels                    
                </comment>
                <declaration name="iterator" type="Iterator&lt;SubHyperplane&lt;S&gt;&gt;" line="177"/>
                <declaration name="inserted" type="Hyperplane&lt;S&gt;" line="180"/>
                <scope line="181">
                    <scope line="183"/>
                </scope>
                <scope line="188"/>
                <declaration name="plusList" type="ArrayList&lt;SubHyperplane&lt;S&gt;&gt;" line="193"/>
                <declaration name="minusList" type="ArrayList&lt;SubHyperplane&lt;S&gt;&gt;" line="194"/>
                <scope line="195">
                    <declaration name="other" type="SubHyperplane&lt;S&gt;" line="196"/>
                    <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="205"/>
                </scope>
            </method>
            <javadoc line="220">
                {@inheritDoc}                
            </javadoc>
            <method name="copySelf" type="AbstractRegion<S,T>" line="221"/>
            <javadoc line="225">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="226"/>
            <javadoc line="230">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="231">
                <comment line="232">
                    we use a recursive function rather than the BSPTreeVisitor                    
                </comment>
                <comment line="232">
                    interface because we can stop visiting the tree as soon as we                    
                </comment>
                <comment line="232">
                    have found an inside cell                    
                </comment>
                <comment line="232">
                    check both sides of the sub-tree                    
                </comment>
                <scope line="237"/>
            </method>
            <javadoc line="247">
                {@inheritDoc}                
            </javadoc>
            <method name="contains" type="boolean" line="248"/>
            <javadoc line="252">
                {@inheritDoc}                
            </javadoc>
            <method name="checkPoint" type="Location" line="253"/>
            <javadoc line="257">
                Check a point with respect to the region starting at a given node.                
                <@param>
                    m node root node of the region                    
                </@param>
                <@param>
                    m point point to check                    
                </@param>
                <@return>
                    n a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDEOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}                    
                </@return>
            </javadoc>
            <method name="checkPoint" type="Location" line="264">
                <comment line="265">
                    the point is on a cut-sub-hyperplane, is it on a boundary ?                    
                </comment>
                <declaration name="cell" type="BSPTree&lt;S&gt;" line="265"/>
                <scope line="266"/>
                <declaration name="minusCode" type="Location" line="272"/>
                <declaration name="plusCode" type="Location" line="273"/>
            </method>
            <javadoc line="278">
                {@inheritDoc}                
            </javadoc>
            <method name="getTree" type="BSPTree<S>" line="279">
                <scope line="280"/>
            </method>
            <class name="BoundaryBuilder" line="287">
                <implements interface="BSPTreeVisitor&lt;S&gt;"/>
                <javadoc line="287">
                    Visitor building boundary shell tree.
                     * &lt;p&gt;
                     * The boundary shell is represented as {@link BoundaryAttribute boundary attributes}at each internal node.
                     * &lt;/p&gt;                    
                </javadoc>
                <javadoc line="295">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitOrder" type="Order" line="296"/>
                <javadoc line="300">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitInternalNode" type="void" line="301">
                    <comment line="302">
                        characterize the cut sub-hyperplane,                        
                    </comment>
                    <comment line="302">
                        first with respect to the plus sub-tree                        
                    </comment>
                    <comment line="302">
                        set the boundary attribute at non-leaf nodes                        
                    </comment>
                    <declaration name="plusOutside" type="SubHyperplane&lt;S&gt;" line="303"/>
                    <declaration name="plusInside" type="SubHyperplane&lt;S&gt;" line="304"/>
                    <declaration name="plusChar" type="SubHyperplane&lt;S&gt;[]" line="308"/>
                    <scope line="312">
                        <declaration name="minusChar" type="SubHyperplane&lt;S&gt;[]" line="316"/>
                        <scope line="319"/>
                    </scope>
                    <scope line="326">
                        <declaration name="minusChar" type="SubHyperplane&lt;S&gt;[]" line="330"/>
                        <scope line="333"/>
                    </scope>
                </method>
                <javadoc line="345">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitLeafNode" type="void" line="346"/>
                <javadoc line="349">
                    Filter the parts of an hyperplane belonging to the boundary.
                     * &lt;p&gt;The filtering consist in splitting the specified
                     * sub-hyperplane into several parts lying in inside and outside
                     * cells of the tree. The principle is to call this method twice for
                     * each cut sub-hyperplane in the tree, once one the plus node and
                     * once on the minus node. The parts that have the same flag
                     * (inside/inside or outside/outside) do not belong to the boundary
                     * while parts that have different flags (inside/outside or
                     * outside/inside) do belong to the boundary.&lt;/p&gt;                    
                    <@param>
                        m node current BSP tree node                        
                    </@param>
                    <@param>
                        m sub sub-hyperplane to characterize                        
                    </@param>
                    <@param>
                        m characterization placeholder where to put the characterized parts                        
                    </@param>
                </javadoc>
                <method name="characterize" type="void" line="363">
                    <scope line="364">
                        <declaration name="inside" type="boolean" line="366"/>
                        <scope line="367">
                            <scope line="368"/>
                            <scope line="370"/>
                        </scope>
                        <scope line="373">
                            <scope line="374"/>
                            <scope line="376"/>
                        </scope>
                    </scope>
                    <scope line="380">
                        <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="381"/>
                        <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="390"/>
                    </scope>
                </method>
            </class>
            <javadoc line="403">
                {@inheritDoc}                
            </javadoc>
            <method name="getBoundarySize" type="double" line="404">
                <declaration name="visitor" type="BoundarySizeVisitor&lt;S&gt;" line="405"/>
            </method>
            <javadoc line="410">
                {@inheritDoc}                
            </javadoc>
            <method name="getSize" type="double" line="411">
                <scope line="412"/>
            </method>
            <javadoc line="418">
                Set the size of the instance.                
                <@param>
                    m size size of the instance                    
                </@param>
            </javadoc>
            <method name="setSize" type="void" line="421"/>
            <javadoc line="425">
                {@inheritDoc}                
            </javadoc>
            <method name="getBarycenter" type="Vector<S>" line="426">
                <scope line="427"/>
            </method>
            <javadoc line="433">
                Set the barycenter of the instance.                
                <@param>
                    m barycenter barycenter of the instance                    
                </@param>
            </javadoc>
            <method name="setBarycenter" type="void" line="436"/>
            <method name="computeGeometricalProperties" type="void" line="440"/>
            <javadoc line="440">
                Compute some geometrical properties.
                 * &lt;p&gt;The properties to compute are the barycenter and the size.&lt;/p&gt;                
            </javadoc>
            <javadoc line="445">
                {@inheritDoc}                
            </javadoc>
            <method name="side" type="Side" line="446">
                <declaration name="sides" type="Sides" line="447"/>
            </method>
            <javadoc line="454">
                Search recursively for inside leaf nodes on each side of the given hyperplane.
                 * &lt;p&gt;The algorithm used here is directly derived from the one
                 * described in section III (&lt;i&gt;Binary Partitioning of a BSP
                 * Tree&lt;/i&gt;) of the Bruce Naylor, John Amanatides and William
                 * Thibault paper &lt;a
                 * href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
                 * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph
                 * &apos;90, Computer Graphics 24(4), August 1990, pp 115-124, published
                 * by the Association for Computing Machinery (ACM)..&lt;/p&gt;                
                <@param>
                    m node current BSP tree node                    
                </@param>
                <@param>
                    m sub sub-hyperplane                    
                </@param>
                <@param>
                    m sides object holding the sides found                    
                </@param>
            </javadoc>
            <method name="recurseSides" type="void" line="469">
                <scope line="471">
                    <scope line="472"/>
                </scope>
                <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="480"/>
                <scope line="484">
                    <scope line="485"/>
                </scope>
                <scope line="488">
                    <scope line="489"/>
                </scope>
                <scope line="493"/>
                <scope line="499">
                    <scope line="500"/>
                </scope>
                <scope line="503">
                    <scope line="504"/>
                </scope>
                <scope line="508"/>
                <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="514"/>
                <scope line="520"/>
                <scope line="526">
                    <scope line="527"/>
                    <scope line="530"/>
                </scope>
                <scope line="533">
                    <scope line="534"/>
                    <scope line="537"/>
                </scope>
            </method>
            <class name="Sides" line="545">
                <javadoc line="545">
                    Utility class holding the already found sides.                    
                </javadoc>
                <declaration name="plusFound" type="boolean" line="548"/>
                <javadoc line="548">
                    Indicator of inside leaf nodes found on the plus side.                    
                </javadoc>
                <declaration name="minusFound" type="boolean" line="551"/>
                <javadoc line="551">
                    Indicator of inside leaf nodes found on the plus side.                    
                </javadoc>
                <javadoc line="554">
                    Simple constructor.                    
                </javadoc>
                <method name="Sides" type="constructor" line="556"/>
                <javadoc line="561">
                    Remember the fact that inside leaf nodes have been found on the plus side.                    
                </javadoc>
                <method name="rememberPlusFound" type="void" line="563"/>
                <javadoc line="567">
                    Check if inside leaf nodes have been found on the plus side.                    
                    <@return>
                        n true if inside leaf nodes have been found on the plus side                        
                    </@return>
                </javadoc>
                <method name="plusFound" type="boolean" line="570"/>
                <javadoc line="574">
                    Remember the fact that inside leaf nodes have been found on the minus side.                    
                </javadoc>
                <method name="rememberMinusFound" type="void" line="576"/>
                <javadoc line="580">
                    Check if inside leaf nodes have been found on the minus side.                    
                    <@return>
                        n true if inside leaf nodes have been found on the minus side                        
                    </@return>
                </javadoc>
                <method name="minusFound" type="boolean" line="583"/>
            </class>
            <javadoc line="589">
                {@inheritDoc}                
            </javadoc>
            <method name="intersection" type="SubHyperplane<S>" line="590"/>
            <javadoc line="594">
                Recursively compute the parts of a sub-hyperplane that are
                 * contained in the region.                
                <@param>
                    m node current BSP tree node                    
                </@param>
                <@param>
                    m sub sub-hyperplane traversing the region                    
                </@param>
                <@return>
                    n filtered sub-hyperplane                    
                </@return>
            </javadoc>
            <method name="recurseIntersection" type="SubHyperplane<S>" line="600">
                <scope line="602"/>
                <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="606"/>
                <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="613"/>
                <declaration name="plus" type="SubHyperplane&lt;S&gt;" line="614"/>
                <declaration name="minus" type="SubHyperplane&lt;S&gt;" line="615"/>
                <scope line="616"/>
                <scope line="618"/>
                <scope line="620"/>
            </method>
            <javadoc line="630">
                Transform a region.
                 * &lt;p&gt;Applying a transform to a region consist in applying the
                 * transform to all the hyperplanes of the underlying BSP tree and
                 * of the boundary (and also to the sub-hyperplanes embedded in
                 * these hyperplanes) and to the barycenter. The instance is not
                 * modified, a new instance is built.&lt;/p&gt;                
                <@param>
                    m transform transform to apply                    
                </@param>
                <@return>
                    n a new region, resulting from the application of the
                     * transform to the instance                    
                </@return>
            </javadoc>
            <method name="applyTransform" type="AbstractRegion<S,T>" line="640"/>
            <javadoc line="644">
                Recursively transform an inside/outside BSP-tree.                
                <@param>
                    m node current BSP tree node                    
                </@param>
                <@param>
                    m transform transform to apply                    
                </@param>
                <@return>
                    n a new tree                    
                </@return>
            </javadoc>
            <method name="recurseTransform" type="BSPTree<S>" line="650">
                <scope line="652"/>
                <declaration name="sub" type="SubHyperplane&lt;S&gt;" line="656"/>
                <declaration name="tSub" type="SubHyperplane&lt;S&gt;" line="657"/>
                <declaration name="attribute" type="BoundaryAttribute&lt;S&gt;" line="658"/>
                <scope line="659">
                    <declaration name="tPO" type="SubHyperplane&lt;S&gt;" line="660"/>
                    <declaration name="tPI" type="SubHyperplane&lt;S&gt;" line="662"/>
                </scope>
            </method>
        </class>
    </source>