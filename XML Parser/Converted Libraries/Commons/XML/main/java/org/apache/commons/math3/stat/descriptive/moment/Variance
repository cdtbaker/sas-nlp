<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.stat.descriptive.moment">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.stat.descriptive.WeightedEvaluation"/>
        <import package="org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="Variance" extends="AbstractStorelessUnivariateStatistic" line="28">
            <implements interface="Serializable"/>
            <implements interface="WeightedEvaluation"/>
            <javadoc line="28">
                Computes the variance of the available values.  By default, the unbiased
                 * &quot;sample variance&quot; definitional formula is used:
                 * &lt;p&gt;
                 * variance = sum((x_i - mean)^2) / (n - 1) &lt;/p&gt;
                 * &lt;p&gt;
                 * where mean is the {@link Mean} and &lt;code&gt;n&lt;/code&gt; is the number
                 * of sample observations.&lt;/p&gt;
                 * &lt;p&gt;
                 * The definitional formula does not have good numerical properties, so
                 * this implementation does not compute the statistic using the definitional
                 * formula. &lt;ul&gt;
                 * &lt;li&gt; The &lt;code&gt;getResult&lt;/code&gt; method computes the variance using
                 * updating formulas based on West&apos;s algorithm, as described in
                 * &lt;a href=&quot;http://doi.acm.org/10.1145/359146.359152&quot;&gt; Chan, T. F. and
                 * J. G. Lewis 1979, &lt;i&gt;Communications of the ACM&lt;/i&gt;,
                 * vol. 22 no. 9, pp. 526-531.&lt;/a&gt;&lt;/li&gt;
                 * &lt;li&gt; The &lt;code&gt;evaluate&lt;/code&gt; methods leverage the fact that they have the
                 * full array of values in memory to execute a two-pass algorithm.
                 * Specifically, these methods use the &quot;corrected two-pass algorithm&quot; from
                 * Chan, Golub, Levesque, &lt;i&gt;Algorithms for Computing the Sample Variance&lt;/i&gt;,
                 * American Statistician, vol. 37, no. 3 (1983) pp. 242-247.&lt;/li&gt;&lt;/ul&gt;
                 * Note that adding values using &lt;code&gt;increment&lt;/code&gt; or
                 * &lt;code&gt;incrementAll&lt;/code&gt; and then executing &lt;code&gt;getResult&lt;/code&gt; will
                 * sometimes give a different, less accurate, result than executing
                 * &lt;code&gt;evaluate&lt;/code&gt; with the full array of values. The former approach
                 * should only be used when the full array of values is not available.&lt;/p&gt;
                 * &lt;p&gt;
                 * The &quot;population variance&quot;  ( sum((x_i - mean)^2) / n ) can also
                 * be computed using this statistic.  The &lt;code&gt;isBiasCorrected&lt;/code&gt;
                 * property determines whether the &quot;population&quot; or &quot;sample&quot; value is
                 * returned by the &lt;code&gt;evaluate&lt;/code&gt; and &lt;code&gt;getResult&lt;/code&gt; methods.
                 * To compute population variances, set this property to &lt;code&gt;false.&lt;/code&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * &lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; If
                 * multiple threads access an instance of this class concurrently, and at least
                 * one of the threads invokes the &lt;code&gt;increment()&lt;/code&gt; or
                 * &lt;code&gt;clear()&lt;/code&gt; method, it must be synchronized externally.&lt;/p&gt;                
                <@version>
                    n $Id: Variance.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="72"/>
            <javadoc line="72">
                Serializable version identifier                
            </javadoc>
            <declaration name="moment" type="SecondMoment" line="75"/>
            <javadoc line="75">
                SecondMoment is used in incremental calculation of Variance                
            </javadoc>
            <declaration name="incMoment" type="boolean" line="78"/>
            <javadoc line="78">
                Whether or not {@link #increment(double)} should increment
                 * the internal second moment. When a Variance is constructed with an
                 * external SecondMoment as a constructor parameter, this property is
                 * set to false and increments must be applied to the second moment
                 * directly.                
            </javadoc>
            <declaration name="isBiasCorrected" type="boolean" line="87"/>
            <javadoc line="87">
                Whether or not bias correction is applied when computing the
                 * value of the statistic. True means that bias is corrected.  See{@link Variance} for details on the formula.                
            </javadoc>
            <javadoc line="94">
                Constructs a Variance with default (true) &lt;code&gt;isBiasCorrected&lt;/code&gt;
                 * property.                
            </javadoc>
            <method name="Variance" type="constructor" line="98"/>
            <javadoc line="102">
                Constructs a Variance based on an external second moment.
                 * When this constructor is used, the statistic may only be
                 * incremented via the moment, i.e., {@link #increment(double)}does nothing; whereas {@code m2.increment(value)} increments
                 * both {@code m2} and the Variance instance constructed from it.                
                <@param>
                    m m2 the SecondMoment (Third or Fourth moments work
                     * here as well.)                    
                </@param>
            </javadoc>
            <method name="Variance" type="constructor" line="112"/>
            <javadoc line="117">
                Constructs a Variance with the specified &lt;code&gt;isBiasCorrected&lt;/code&gt;
                 * property                
                <@param>
                    m isBiasCorrected  setting for bias correction - true means
                     * bias will be corrected and is equivalent to using the argumentless
                     * constructor                    
                </@param>
            </javadoc>
            <method name="Variance" type="constructor" line="125"/>
            <javadoc line="130">
                Constructs a Variance with the specified &lt;code&gt;isBiasCorrected&lt;/code&gt;
                 * property and the supplied external second moment.                
                <@param>
                    m isBiasCorrected  setting for bias correction - true means
                     * bias will be corrected                    
                </@param>
                <@param>
                    m m2 the SecondMoment (Third or Fourth moments work
                     * here as well.)                    
                </@param>
            </javadoc>
            <method name="Variance" type="constructor" line="139"/>
            <javadoc line="145">
                Copy constructor, creates a new {@code Variance} identical
                 * to the {@code original}                
                <@param>
                    m original the {@code Variance} instance to copy                    
                </@param>
                <@throws>
                    s NullArgumentException if original is null                    
                </@throws>
            </javadoc>
            <method name="Variance" type="constructor" line="152"/>
            <javadoc line="156">
                {@inheritDoc}&lt;p&gt;If all values are available, it is more accurate to use{@link #evaluate(double[])} rather than adding values one at a time
                 * using this method and then executing {@link #getResult}, since
                 * &lt;code&gt;evaluate&lt;/code&gt; leverages the fact that is has the full
                 * list of values together to execute a two-pass algorithm.
                 * See {@link Variance}.&lt;/p&gt;
                 * &lt;p&gt;Note also that when {@link #Variance(SecondMoment)} is used to
                 * create a Variance, this method does nothing. In that case, the
                 * SecondMoment should be incremented directly.&lt;/p&gt;                
            </javadoc>
            <method name="increment" type="void" line="170">
                <scope line="171"/>
            </method>
            <javadoc line="176">
                {@inheritDoc}                
            </javadoc>
            <method name="getResult" type="double" line="180">
                <scope line="181"/>
                <scope line="183"/>
                <scope line="185">
                    <scope line="186"/>
                    <scope line="188"/>
                </scope>
            </method>
            <javadoc line="194">
                {@inheritDoc}                
            </javadoc>
            <method name="getN" type="long" line="197"/>
            <javadoc line="201">
                {@inheritDoc}                
            </javadoc>
            <method name="clear" type="void" line="205">
                <scope line="206"/>
            </method>
            <javadoc line="211">
                Returns the variance of the entries in the input array, or
                 * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
                 * &lt;p&gt;
                 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@return>
                    n the variance of the values or Double.NaN if length = 0                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the array is null                    
                </@throws>
            </javadoc>
            <method name="evaluate" type="double" line="228">
                <scope line="229"/>
            </method>
            <javadoc line="235">
                Returns the variance of the entries in the specified portion of
                 * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
                 * is empty.
                 * &lt;p&gt;
                 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m begin index of the first array element to include                    
                </@param>
                <@param>
                    m length the number of elements to include                    
                </@param>
                <@return>
                    n the variance of the values or Double.NaN if length = 0                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the array is null or the array index
                     * parameters are not valid                    
                </@throws>
            </javadoc>
            <method name="evaluate" type="double" line="257">
                <declaration name="var" type="double" line="259"/>
                <scope line="261">
                    <scope line="263"/>
                    <scope line="265">
                        <declaration name="mean" type="Mean" line="266"/>
                        <declaration name="m" type="double" line="267"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="274">
                &lt;p&gt;Returns the weighted variance of the entries in the specified portion of
                 * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
                 * is empty.&lt;/p&gt;
                 * &lt;p&gt;
                 * Uses the formula &lt;pre&gt;
                 * &amp;Sigma;(weights[i]*(values[i] - weightedMean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
                 * &lt;/pre&gt;
                 * where weightedMean is the weighted mean&lt;/p&gt;
                 * &lt;p&gt;
                 * This formula will not return the same result as the unweighted variance when all
                 * weights are equal, unless all weights are equal to 1. The formula assumes that
                 * weights are to be treated as &quot;expansion values,&quot; as will be the case if for example
                 * the weights represent frequency counts. To normalize weights so that the denominator
                 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
                 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length)); &lt;/code&gt;
                 * &lt;/pre&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if any of the following are true:
                 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
                 * &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;
                 * &lt;/ul&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if either array is null.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m weights the weights array                    
                </@param>
                <@param>
                    m begin index of the first array element to include                    
                </@param>
                <@param>
                    m length the number of elements to include                    
                </@param>
                <@return>
                    n the weighted variance of the values or Double.NaN if length = 0                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the parameters are not valid                    
                </@throws>
                <@since>
                    e 2.1                    
                </@since>
            </javadoc>
            <method name="evaluate" type="double" line="317">
                <declaration name="var" type="double" line="319"/>
                <scope line="321">
                    <scope line="323"/>
                    <scope line="325">
                        <declaration name="mean" type="Mean" line="326"/>
                        <declaration name="m" type="double" line="327"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="334">
                &lt;p&gt;
                 * Returns the weighted variance of the entries in the the input array.&lt;/p&gt;
                 * &lt;p&gt;
                 * Uses the formula &lt;pre&gt;
                 * &amp;Sigma;(weights[i]*(values[i] - weightedMean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
                 * &lt;/pre&gt;
                 * where weightedMean is the weighted mean&lt;/p&gt;
                 * &lt;p&gt;
                 * This formula will not return the same result as the unweighted variance when all
                 * weights are equal, unless all weights are equal to 1. The formula assumes that
                 * weights are to be treated as &quot;expansion values,&quot; as will be the case if for example
                 * the weights represent frequency counts. To normalize weights so that the denominator
                 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
                 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length)); &lt;/code&gt;
                 * &lt;/pre&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
                 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
                 * &lt;/ul&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if either array is null.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m weights the weights array                    
                </@param>
                <@return>
                    n the weighted variance of the values                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the parameters are not valid                    
                </@throws>
                <@since>
                    e 2.1                    
                </@since>
            </javadoc>
            <method name="evaluate" type="double" line="373"/>
            <javadoc line="377">
                Returns the variance of the entries in the specified portion of
                 * the input array, using the precomputed mean value.  Returns
                 * &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
                 * &lt;p&gt;
                 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
                 * &lt;p&gt;
                 * The formula used assumes that the supplied mean value is the arithmetic
                 * mean of the sample data, not a known population parameter.  This method
                 * is supplied only to save computation when the mean has already been
                 * computed.&lt;/p&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m mean the precomputed mean value                    
                </@param>
                <@param>
                    m begin index of the first array element to include                    
                </@param>
                <@param>
                    m length the number of elements to include                    
                </@param>
                <@return>
                    n the variance of the values or Double.NaN if length = 0                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the array is null or the array index
                     * parameters are not valid                    
                </@throws>
            </javadoc>
            <method name="evaluate" type="double" line="404">
                <declaration name="var" type="double" line="406"/>
                <scope line="408">
                    <scope line="409"/>
                    <scope line="411">
                        <declaration name="accum" type="double" line="412"/>
                        <declaration name="dev" type="double" line="413"/>
                        <declaration name="accum2" type="double" line="414"/>
                        <scope line="415"/>
                        <declaration name="len" type="double" line="420"/>
                        <scope line="421"/>
                        <scope line="423"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="431">
                Returns the variance of the entries in the input array, using the
                 * precomputed mean value.  Returns &lt;code&gt;Double.NaN&lt;/code&gt; if the array
                 * is empty.
                 * &lt;p&gt;
                 * See {@link Variance} for details on the computing algorithm.&lt;/p&gt;
                 * &lt;p&gt;
                 * If &lt;code&gt;isBiasCorrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the formula used
                 * assumes that the supplied mean value is the arithmetic mean of the
                 * sample data, not a known population parameter.  If the mean is a known
                 * population parameter, or if the &quot;population&quot; version of the variance is
                 * desired, set &lt;code&gt;isBiasCorrected&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; before
                 * invoking this method.&lt;/p&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m mean the precomputed mean value                    
                </@param>
                <@return>
                    n the variance of the values or Double.NaN if the array is empty                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the array is null                    
                </@throws>
            </javadoc>
            <method name="evaluate" type="double" line="456"/>
            <javadoc line="460">
                Returns the weighted variance of the entries in the specified portion of
                 * the input array, using the precomputed weighted mean value.  Returns
                 * &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
                 * &lt;p&gt;
                 * Uses the formula &lt;pre&gt;
                 * &amp;Sigma;(weights[i]*(values[i] - mean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
                 * &lt;/pre&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * The formula used assumes that the supplied mean value is the weighted arithmetic
                 * mean of the sample data, not a known population parameter. This method
                 * is supplied only to save computation when the mean has already been
                 * computed.&lt;/p&gt;
                 * &lt;p&gt;
                 * This formula will not return the same result as the unweighted variance when all
                 * weights are equal, unless all weights are equal to 1. The formula assumes that
                 * weights are to be treated as &quot;expansion values,&quot; as will be the case if for example
                 * the weights represent frequency counts. To normalize weights so that the denominator
                 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
                 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); &lt;/code&gt;
                 * &lt;/pre&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
                 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
                 * &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;
                 * &lt;/ul&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m weights the weights array                    
                </@param>
                <@param>
                    m mean the precomputed weighted mean value                    
                </@param>
                <@param>
                    m begin index of the first array element to include                    
                </@param>
                <@param>
                    m length the number of elements to include                    
                </@param>
                <@return>
                    n the variance of the values or Double.NaN if length = 0                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the parameters are not valid                    
                </@throws>
                <@since>
                    e 2.1                    
                </@since>
            </javadoc>
            <method name="evaluate" type="double" line="507">
                <declaration name="var" type="double" line="509"/>
                <scope line="511">
                    <scope line="512"/>
                    <scope line="514">
                        <declaration name="accum" type="double" line="515"/>
                        <declaration name="dev" type="double" line="516"/>
                        <declaration name="accum2" type="double" line="517"/>
                        <scope line="518"/>
                        <declaration name="sumWts" type="double" line="524"/>
                        <scope line="525"/>
                        <scope line="529"/>
                        <scope line="531"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="539">
                &lt;p&gt;Returns the weighted variance of the values in the input array, using
                 * the precomputed weighted mean value.&lt;/p&gt;
                 * &lt;p&gt;
                 * Uses the formula &lt;pre&gt;
                 * &amp;Sigma;(weights[i]*(values[i] - mean)&lt;sup&gt;2&lt;/sup&gt;)/(&amp;Sigma;(weights[i]) - 1)
                 * &lt;/pre&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * The formula used assumes that the supplied mean value is the weighted arithmetic
                 * mean of the sample data, not a known population parameter. This method
                 * is supplied only to save computation when the mean has already been
                 * computed.&lt;/p&gt;
                 * &lt;p&gt;
                 * This formula will not return the same result as the unweighted variance when all
                 * weights are equal, unless all weights are equal to 1. The formula assumes that
                 * weights are to be treated as &quot;expansion values,&quot; as will be the case if for example
                 * the weights represent frequency counts. To normalize weights so that the denominator
                 * in the variance computation equals the length of the input vector minus one, use &lt;pre&gt;
                 * &lt;code&gt;evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); &lt;/code&gt;
                 * &lt;/pre&gt;
                 * &lt;p&gt;
                 * Returns 0 for a single-value (i.e. length = 1) sample.&lt;/p&gt;
                 * &lt;p&gt;
                 * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
                 * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array is null&lt;/li&gt;
                 * &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
                 * &lt;li&gt;the weights array contains negative values&lt;/li&gt;
                 * &lt;/ul&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * Does not change the internal state of the statistic.&lt;/p&gt;                
                <@param>
                    m values the input array                    
                </@param>
                <@param>
                    m weights the weights array                    
                </@param>
                <@param>
                    m mean the precomputed weighted mean value                    
                </@param>
                <@return>
                    n the variance of the values or Double.NaN if length = 0                    
                </@return>
                <@throws>
                    s MathIllegalArgumentException if the parameters are not valid                    
                </@throws>
                <@since>
                    e 2.1                    
                </@since>
            </javadoc>
            <method name="evaluate" type="double" line="581"/>
            <javadoc line="585">
                @return Returns the isBiasCorrected.                
            </javadoc>
            <method name="isBiasCorrected" type="boolean" line="588"/>
            <javadoc line="592">
                @param biasCorrected The isBiasCorrected to set.                
            </javadoc>
            <method name="setBiasCorrected" type="void" line="595"/>
            <javadoc line="599">
                {@inheritDoc}                
            </javadoc>
            <method name="copy" type="Variance" line="603">
                <comment line="604">
                    No try-catch or advertised exception because parameters are guaranteed non-null                    
                </comment>
                <declaration name="result" type="Variance" line="604"/>
            </method>
            <javadoc line="610">
                Copies source to dest.
                 * &lt;p&gt;Neither source nor dest can be null.&lt;/p&gt;                
                <@param>
                    m source Variance to copy                    
                </@param>
                <@param>
                    m dest Variance to copy to                    
                </@param>
                <@throws>
                    s NullArgumentException if either source or dest is null                    
                </@throws>
            </javadoc>
            <method name="copy" type="void" line="619"/>
        </class>
    </source>