<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning">
        <import package="org.apache.commons.math3.geometry.Space"/>
        <class name="RegionFactory" line="21">
            <type_params>
                <type_param name="S"/>
            </type_params>
            <javadoc line="21">
                This class is a factory for {@link Region}.                
                <@param>
                    m<S>
                       Type of the space.                    
                </@param>
                <@version>
                    n $Id: RegionFactory.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <declaration name="nodeCleaner" type="NodesCleaner" line="30"/>
            <javadoc line="30">
                Visitor removing internal nodes attributes.                
            </javadoc>
            <javadoc line="33">
                Simple constructor.                
            </javadoc>
            <method name="RegionFactory" type="constructor" line="35"/>
            <javadoc line="39">
                Build a convex region from a collection of bounding hyperplanes.                
                <@param>
                    m hyperplanes collection of bounding hyperplanes                    
                </@param>
                <@return>
                    n a new convex region, or null if the collection is empty                    
                </@return>
            </javadoc>
            <method name="buildConvex" type="Region<S>" line="43">
                <params>
                    <param name="hyperplanes" type="Hyperplane<S>"/>
                </params>
                <comment line="44">
                    use the first hyperplane to build the right class                    
                </comment>
                <comment line="44">
                    chop off parts of the space                    
                </comment>
                <scope line="44"/>
                <declaration name="region" type="Region&lt;S&gt;" line="49"/>
                <declaration name="node" type="BSPTree&lt;S&gt;" line="52"/>
                <scope line="54">
                    <scope line="55"/>
                </scope>
            </method>
            <javadoc line="67">
                Compute the union of two regions.                
                <@param>
                    m region1 first region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@param>
                    m region2 second region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@return>
                    n a new region, result of {@code region1 union region2}                    
                </@return>
            </javadoc>
            <method name="union" type="Region<S>" line="74">
                <params>
                    <param name="region1" type="Region<S>"/>
                    <param name="region2" type="Region<S>"/>
                </params>
                <declaration name="tree" type="BSPTree&lt;S&gt;" line="75"/>
            </method>
            <javadoc line="81">
                Compute the intersection of two regions.                
                <@param>
                    m region1 first region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@param>
                    m region2 second region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@return>
                    n a new region, result of {@code region1 intersection region2}                    
                </@return>
            </javadoc>
            <method name="intersection" type="Region<S>" line="88">
                <params>
                    <param name="region1" type="Region<S>"/>
                    <param name="region2" type="Region<S>"/>
                </params>
                <declaration name="tree" type="BSPTree&lt;S&gt;" line="89"/>
            </method>
            <javadoc line="95">
                Compute the symmetric difference (exclusive or) of two regions.                
                <@param>
                    m region1 first region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@param>
                    m region2 second region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@return>
                    n a new region, result of {@code region1 xor region2}                    
                </@return>
            </javadoc>
            <method name="xor" type="Region<S>" line="102">
                <params>
                    <param name="region1" type="Region<S>"/>
                    <param name="region2" type="Region<S>"/>
                </params>
                <declaration name="tree" type="BSPTree&lt;S&gt;" line="103"/>
            </method>
            <javadoc line="109">
                Compute the difference of two regions.                
                <@param>
                    m region1 first region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@param>
                    m region2 second region (will be unusable after the operation as
                      parts of it will be reused in the new region)                    
                </@param>
                <@return>
                    n a new region, result of {@code region1 minus region2}                    
                </@return>
            </javadoc>
            <method name="difference" type="Region<S>" line="116">
                <params>
                    <param name="region1" type="Region<S>"/>
                    <param name="region2" type="Region<S>"/>
                </params>
                <declaration name="tree" type="BSPTree&lt;S&gt;" line="117"/>
            </method>
            <javadoc line="123">
                Get the complement of the region (exchanged interior/exterior).                
                <@param>
                    m region region to complement, it will not modified, a new
                      region independent region will be built                    
                </@param>
                <@return>
                    n a new region, complement of the specified one                    
                </@return>
            </javadoc>
            <method name="getComplement" type="Region<S>" line="128">
                <params>
                    <param name="region" type="Region<S>"/>
                </params>
            </method>
            <javadoc line="132">
                Recursively build the complement of a BSP tree.                
                <@param>
                    m node current node of the original tree                    
                </@param>
                <@return>
                    n new tree, complement of the node                    
                </@return>
            </javadoc>
            <method name="recurseComplement" type="BSPTree<S>" line="136">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                </params>
                <scope line="137"/>
                <declaration name="attribute" type="BoundaryAttribute&lt;S&gt;" line="141"/>
                <scope line="143">
                    <declaration name="plusOutside" type="SubHyperplane&lt;S&gt;" line="144"/>
                    <declaration name="plusInside" type="SubHyperplane&lt;S&gt;" line="146"/>
                </scope>
            </method>
            <class name="UnionMerger" line="158">
                <implements interface="BSPTree.LeafMerger">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="158">
                    BSP tree leaf merger computing union of two regions.                    
                </javadoc>
                <javadoc line="160">
                    {@inheritDoc}                    
                </javadoc>
                <method name="merge" type="BSPTree<S>" line="163">
                    <params>
                        <param name="leaf" type="BSPTree<S>"/>
                        <param name="tree" type="BSPTree<S>"/>
                        <param name="parentTree" type="BSPTree<S>"/>
                        <param name="isPlusChild" type="boolean"/>
                        <param name="leafFromInstance" type="boolean"/>
                    </params>
                    <comment line="164">
                        the leaf node represents an outside cell                        
                    </comment>
                    <scope line="164"/>
                </method>
            </class>
            <class name="IntersectionMerger" line="175">
                <implements interface="BSPTree.LeafMerger">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="175">
                    BSP tree leaf merger computing union of two regions.                    
                </javadoc>
                <javadoc line="177">
                    {@inheritDoc}                    
                </javadoc>
                <method name="merge" type="BSPTree<S>" line="180">
                    <params>
                        <param name="leaf" type="BSPTree<S>"/>
                        <param name="tree" type="BSPTree<S>"/>
                        <param name="parentTree" type="BSPTree<S>"/>
                        <param name="isPlusChild" type="boolean"/>
                        <param name="leafFromInstance" type="boolean"/>
                    </params>
                    <comment line="181">
                        the leaf node represents an outside cell                        
                    </comment>
                    <scope line="181"/>
                </method>
            </class>
            <class name="XorMerger" line="192">
                <implements interface="BSPTree.LeafMerger">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="192">
                    BSP tree leaf merger computing union of two regions.                    
                </javadoc>
                <javadoc line="194">
                    {@inheritDoc}                    
                </javadoc>
                <method name="merge" type="BSPTree<S>" line="197">
                    <params>
                        <param name="leaf" type="BSPTree<S>"/>
                        <param name="tree" type="BSPTree<S>"/>
                        <param name="parentTree" type="BSPTree<S>"/>
                        <param name="isPlusChild" type="boolean"/>
                        <param name="leafFromInstance" type="boolean"/>
                    </params>
                    <declaration name="t" type="BSPTree&lt;S&gt;" line="198"/>
                    <scope line="199"/>
                </method>
            </class>
            <class name="DifferenceMerger" line="208">
                <implements interface="BSPTree.LeafMerger">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="208">
                    BSP tree leaf merger computing union of two regions.                    
                </javadoc>
                <javadoc line="210">
                    {@inheritDoc}                    
                </javadoc>
                <method name="merge" type="BSPTree<S>" line="213">
                    <params>
                        <param name="leaf" type="BSPTree<S>"/>
                        <param name="tree" type="BSPTree<S>"/>
                        <param name="parentTree" type="BSPTree<S>"/>
                        <param name="isPlusChild" type="boolean"/>
                        <param name="leafFromInstance" type="boolean"/>
                    </params>
                    <comment line="214">
                        the leaf node represents an outside cell                        
                    </comment>
                    <scope line="214">
                        <declaration name="argTree" type="BSPTree&lt;S&gt;" line="216"/>
                    </scope>
                    <declaration name="instanceTree" type="BSPTree&lt;S&gt;" line="222"/>
                </method>
            </class>
            <class name="NodesCleaner" line="229">
                <implements interface="BSPTreeVisitor">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="229">
                    Visitor removing internal nodes attributes.                    
                </javadoc>
                <javadoc line="232">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitOrder" type="Order" line="233">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                    </params>
                </method>
                <javadoc line="237">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitInternalNode" type="void" line="238">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                    </params>
                </method>
                <javadoc line="242">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitLeafNode" type="void" line="243">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                    </params>
                </method>
            </class>
        </class>
    </source>