<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optimization.fitting">
        <import package="java.util.Arrays"/>
        <import package="java.util.Comparator"/>
        <import package="org.apache.commons.math3.analysis.function.Gaussian"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.OutOfRangeException"/>
        <import package="org.apache.commons.math3.exception.ZeroException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="GaussianFitter" extends="CurveFitter<Gaussian.Parametric>" line="33">
            <javadoc line="33">
                Fits points to a {@link org.apache.commons.math3.analysis.function.Gaussian.Parametric Gaussian} function.
                 * &lt;p&gt;
                 * Usage example:
                 * &lt;pre&gt;
                 * GaussianFitter fitter = new GaussianFitter(
                 * new LevenbergMarquardtOptimizer());
                 * fitter.addObservedPoint(4.0254623,  531026.0);
                 * fitter.addObservedPoint(4.03128248, 984167.0);
                 * fitter.addObservedPoint(4.03839603, 1887233.0);
                 * fitter.addObservedPoint(4.04421621, 2687152.0);
                 * fitter.addObservedPoint(4.05132976, 3461228.0);
                 * fitter.addObservedPoint(4.05326982, 3580526.0);
                 * fitter.addObservedPoint(4.05779662, 3439750.0);
                 * fitter.addObservedPoint(4.0636168,  2877648.0);
                 * fitter.addObservedPoint(4.06943698, 2175960.0);
                 * fitter.addObservedPoint(4.07525716, 1447024.0);
                 * fitter.addObservedPoint(4.08237071, 717104.0);
                 * fitter.addObservedPoint(4.08366408, 620014.0);
                 * double[] parameters = fitter.fit();
                 * &lt;/pre&gt;                
                <@since>
                    e 2.2                    
                </@since>
                <@version>
                    n $Id: GaussianFitter.java 1422230 2012-12-15 12:11:13Z erans $                    
                </@version>
                <@deprecated>
                    d As of 3.1 (to be removed in 4.0).                    
                </@deprecated>
            </javadoc>
            <javadoc line="62">
                Constructs an instance using the specified optimizer.                
                <@param>
                    m optimizer Optimizer to use for the fitting.                    
                </@param>
            </javadoc>
            <method name="GaussianFitter" type="constructor" line="67"/>
            <javadoc line="71">
                Fits a Gaussian function to the observed points.                
                <@param>
                    m initialGuess First guess values in the following order:
                     * <ul>
                     * <li>Norm</li>
                     * <li>Mean</li>
                     * <li>Sigma</li>
                     * </ul>                    
                </@param>
                <@return>
                    n the parameters of the Gaussian function that best fits the
                     * observed points (in the same order as above).                    
                </@return>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <method name="fit" type="double[]" line="84">
                <anonymous_class line="85">
                    <method name="value" type="double" line="87">
                        <declaration name="v" type="double" line="88"/>
                        <scope line="89"/>
                        <scope line="91"/>
                    </method>
                    <method name="gradient" type="double[]" line="98">
                        <declaration name="v" type="double[]" line="99"/>
                        <scope line="102"/>
                        <scope line="104"/>
                    </method>
                </anonymous_class>
                <declaration name="f" type="Gaussian.Parametric" line="85"/>
            </method>
            <javadoc line="114">
                Fits a Gaussian function to the observed points.                
                <@return>
                    n the parameters of the Gaussian function that best fits the
                     * observed points (in the same order as above).                    
                </@return>
            </javadoc>
            <method name="fit" type="double[]" line="120">
                <declaration name="guess" type="double[]" line="121"/>
            </method>
            <class name="ParameterGuesser" line="125">
                <javadoc line="125">
                    Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}of a {@link org.apache.commons.math3.analysis.function.Gaussian.Parametric}based on the specified observed points.                    
                </javadoc>
                <declaration name="norm" type="double" line="131"/>
                <javadoc line="131">
                    Normalization factor.                    
                </javadoc>
                <declaration name="mean" type="double" line="133"/>
                <javadoc line="133">
                    Mean.                    
                </javadoc>
                <declaration name="sigma" type="double" line="135"/>
                <javadoc line="135">
                    Standard deviation.                    
                </javadoc>
                <javadoc line="138">
                    Constructs instance with the specified observed points.                    
                    <@param>
                        m observations Observed points from which to guess the
                         * parameters of the Gaussian.                        
                    </@param>
                    <@throws>
                        s NullArgumentException if {@code observations} is{@code null}.                        
                    </@throws>
                    <@throws>
                        s NumberIsTooSmallException if there are less than 3
                         * observations.                        
                    </@throws>
                </javadoc>
                <method name="ParameterGuesser" type="constructor" line="148">
                    <scope line="149"/>
                    <scope line="152"/>
                    <declaration name="sorted" type="WeightedObservedPoint[]" line="156"/>
                    <declaration name="params" type="double[]" line="157"/>
                </method>
                <javadoc line="164">
                    Gets an estimation of the parameters.                    
                    <@return>
                        n the guessed parameters, in the following order:
                         * <ul>
                         * <li>Normalization factor</li>
                         * <li>Mean</li>
                         * <li>Standard deviation</li>
                         * </ul>                        
                    </@return>
                </javadoc>
                <method name="guess" type="double[]" line="174"/>
                <javadoc line="178">
                    Sort the observations.                    
                    <@param>
                        m unsorted Input observations.                        
                    </@param>
                    <@return>
                        n the input observations, sorted.                        
                    </@return>
                </javadoc>
                <method name="sortObservations" type="WeightedObservedPoint[]" line="184">
                    <declaration name="observations" type="WeightedObservedPoint[]" line="185"/>
                    <anonymous_class line="187">
                        <method name="compare" type="int" line="189">
                            <scope line="190"/>
                            <scope line="193"/>
                            <scope line="196"/>
                            <scope line="199"/>
                            <scope line="202"/>
                            <scope line="205"/>
                            <scope line="208"/>
                            <scope line="211"/>
                            <scope line="214"/>
                        </method>
                    </anonymous_class>
                    <declaration name="cmp" type="Comparator&lt;WeightedObservedPoint&gt;" line="186"/>
                </method>
                <javadoc line="225">
                    Guesses the parameters based on the specified observed points.                    
                    <@param>
                        m points Observed points, sorted.                        
                    </@param>
                    <@return>
                        n the guessed parameters (normalization factor, mean and
                         * sigma).                        
                    </@return>
                </javadoc>
                <method name="basicGuess" type="double[]" line="232">
                    <declaration name="maxYIdx" type="int" line="233"/>
                    <declaration name="n" type="double" line="234"/>
                    <declaration name="m" type="double" line="235"/>
                    <declaration name="fwhmApprox" type="double" line="237"/>
                    <scope line="238">
                        <declaration name="halfY" type="double" line="239"/>
                        <declaration name="fwhmX1" type="double" line="240"/>
                        <declaration name="fwhmX2" type="double" line="241"/>
                    </scope>
                    <scope line="243"/>
                    <declaration name="s" type="double" line="247"/>
                </method>
                <javadoc line="252">
                    Finds index of point in specified points with the largest Y.                    
                    <@param>
                        m points Points to search.                        
                    </@param>
                    <@return>
                        n the index in specified points array.                        
                    </@return>
                </javadoc>
                <method name="findMaxY" type="int" line="258">
                    <declaration name="maxYIdx" type="int" line="259"/>
                    <scope line="260">
                        <scope line="261"/>
                    </scope>
                </method>
                <javadoc line="268">
                    Interpolates using the specified points to determine X at the
                     * specified Y.                    
                    <@param>
                        m points Points to use for interpolation.                        
                    </@param>
                    <@param>
                        m startIdx Index within points from which to start the search for
                         * interpolation bounds points.                        
                    </@param>
                    <@param>
                        m idxStep Index step for searching interpolation bounds points.                        
                    </@param>
                    <@param>
                        m y Y value for which X should be determined.                        
                    </@param>
                    <@return>
                        n the value of X for the specified Y.                        
                    </@return>
                    <@throws>
                        s ZeroException if {@code idxStep} is 0.                        
                    </@throws>
                    <@throws>
                        s OutOfRangeException if specified {@code y} is not within the
                         * range of the specified {@code points}.                        
                    </@throws>
                </javadoc>
                <method name="interpolateXAtY" type="double" line="286">
                    <scope line="287"/>
                    <declaration name="twoPoints" type="WeightedObservedPoint[]" line="290"/>
                    <declaration name="p1" type="WeightedObservedPoint" line="292"/>
                    <declaration name="p2" type="WeightedObservedPoint" line="293"/>
                    <scope line="294"/>
                    <scope line="297"/>
                </method>
                <javadoc line="304">
                    Gets the two bounding interpolation points from the specified points
                     * suitable for determining X at the specified Y.                    
                    <@param>
                        m points Points to use for interpolation.                        
                    </@param>
                    <@param>
                        m startIdx Index within points from which to start search for
                         * interpolation bounds points.                        
                    </@param>
                    <@param>
                        m idxStep Index step for search for interpolation bounds points.                        
                    </@param>
                    <@param>
                        m y Y value for which X should be determined.                        
                    </@param>
                    <@return>
                        n the array containing two points suitable for determining X at
                         * the specified Y.                        
                    </@return>
                    <@throws>
                        s ZeroException if {@code idxStep} is 0.                        
                    </@throws>
                    <@throws>
                        s OutOfRangeException if specified {@code y} is not within the
                         * range of the specified {@code points}.                        
                    </@throws>
                </javadoc>
                <method name="getInterpolationPointsForY" type="WeightedObservedPoint[]" line="323">
                    <comment line="324">
                        Boundaries are replaced by dummy values because the raised                        
                    </comment>
                    <comment line="324">
                        exception is caught and the message never displayed.                        
                    </comment>
                    <comment line="324">
                        TODO: Exceptions should not be used for flow control.                        
                    </comment>
                    <scope line="324"/>
                    <scope line="329">
                        <declaration name="p1" type="WeightedObservedPoint" line="330"/>
                        <declaration name="p2" type="WeightedObservedPoint" line="331"/>
                        <scope line="332">
                            <scope line="333"/>
                            <scope line="335"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="349">
                    Determines whether a value is between two other values.                    
                    <@param>
                        m value Value to test whether it is between {@code boundary1}and {@code boundary2}.                        
                    </@param>
                    <@param>
                        m boundary1 One end of the range.                        
                    </@param>
                    <@param>
                        m boundary2 Other end of the range.                        
                    </@param>
                    <@return>
                        n {@code true} if {@code value} is between {@code boundary1} and{@code boundary2} (inclusive), {@code false} otherwise.                        
                    </@return>
                </javadoc>
                <method name="isBetween" type="boolean" line="361"/>
            </class>
        </class>
    </source>