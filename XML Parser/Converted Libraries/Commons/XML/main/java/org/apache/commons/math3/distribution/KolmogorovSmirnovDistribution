<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.distribution">
        <import package="java.io.Serializable"/>
        <import package="java.math.BigDecimal"/>
        <import package="org.apache.commons.math3.exception.MathArithmeticException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.fraction.BigFraction"/>
        <import package="org.apache.commons.math3.fraction.BigFractionField"/>
        <import package="org.apache.commons.math3.fraction.FractionConversionException"/>
        <import package="org.apache.commons.math3.linear.Array2DRowFieldMatrix"/>
        <import package="org.apache.commons.math3.linear.Array2DRowRealMatrix"/>
        <import package="org.apache.commons.math3.linear.FieldMatrix"/>
        <import package="org.apache.commons.math3.linear.RealMatrix"/>
        <class name="KolmogorovSmirnovDistribution" line="35">
            <implements interface="Serializable"/>
            <javadoc line="35">
                Implementation of the Kolmogorov-Smirnov distribution.
                  &lt;p&gt;
                  Treats the distribution of the two-sided {@code P(D_n &lt; d)} where{@code D_n = sup_x |G(x) - G_n (x)|} for the theoretical cdf {@code G} and
                  the empirical cdf {@code G_n}.
                  &lt;/p&gt;
                  &lt;p&gt;
                  This implementation is based on [1] with certain quick decisions for extreme
                  values given in [2].
                  &lt;/p&gt;
                  &lt;p&gt;
                  In short, when wanting to evaluate {@code P(D_n &lt; d)}, the method in [1] is
                  to write {@code d = (k - h) / n} for positive integer {@code k} and{@code 0 &lt;= h &lt; 1}. Then {@code P(D_n &lt; d) = (n! / n^n)  t_kk}, where{@code t_kk} is the {@code (k, k)}&apos;th entry in the special matrix{@code H^n}, i.e. {@code H} to the {@code n}&apos;th power.
                  &lt;/p&gt;
                  &lt;p&gt;
                  References:
                  &lt;ul&gt;
                  &lt;li&gt;[1] &lt;a href=&quot;http://www.jstatsoft.org/v08/i18/&quot;&gt;
                  Evaluating Kolmogorov&apos;s Distribution&lt;/a&gt; by George Marsaglia, Wai
                  Wan Tsang, and Jingbo Wang&lt;/li&gt;
                  &lt;li&gt;[2] &lt;a href=&quot;http://www.jstatsoft.org/v39/i11/&quot;&gt;
                  Computing the Two-Sided Kolmogorov-Smirnov Distribution&lt;/a&gt; by Richard Simard
                  and Pierre L&apos;Ecuyer&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that [1] contains an error in computing h, refer to
                  &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-437&quot;&gt;MATH-437&lt;/a&gt; for details.
                  &lt;/p&gt;                
                <@see>
                    e <a href="http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test">
                      Kolmogorov-Smirnov test (Wikipedia)</a>                    
                </@see>
                <@version>
                    n $Id: KolmogorovSmirnovDistribution.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="74"/>
            <javadoc line="74">
                Serializable version identifier.                
            </javadoc>
            <declaration name="n" type="int" line="77"/>
            <javadoc line="77">
                Number of observations.                
            </javadoc>
            <javadoc line="80">
                @param n Number of observations                
                <@throws>
                    s NotStrictlyPositiveException if {@code n <= 0}                    
                </@throws>
            </javadoc>
            <method name="KolmogorovSmirnovDistribution" type="constructor" line="85">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="86"/>
            </method>
            <javadoc line="93">
                Calculates {@code P(D_n &lt; d)} using method described in [1] with quick
                  decisions for extreme values given in [2] (see above). The result is not
                  exact as with{@link KolmogorovSmirnovDistribution#cdfExact(double)} because
                  calculations are based on {@code double} rather than{@link org.apache.commons.math3.fraction.BigFraction}.                
                <@param>
                    m d statistic                    
                </@param>
                <@return>
                    n the two-sided probability of {@code P(D_n < d)}                    
                </@return>
                <@throws>
                    s MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.                    
                </@throws>
            </javadoc>
            <method name="cdf" type="double" line="108">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="112">
                Calculates {@code P(D_n &lt; d)} using method described in [1] with quick
                  decisions for extreme values given in [2] (see above). The result is
                  exact in the sense that BigFraction/BigReal is used everywhere at the
                  expense of very slow execution time. Almost never choose this in real
                  applications unless you are very sure; this is almost solely for
                  verification purposes. Normally, you would choose{@link KolmogorovSmirnovDistribution#cdf(double)}                
                <@param>
                    m d statistic                    
                </@param>
                <@return>
                    n the two-sided probability of {@code P(D_n < d)}                    
                </@return>
                <@throws>
                    s MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.                    
                </@throws>
            </javadoc>
            <method name="cdfExact" type="double" line="128">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="132">
                Calculates {@code P(D_n &lt; d)} using method described in [1] with quick
                  decisions for extreme values given in [2] (see above).                
                <@param>
                    m d statistic                    
                </@param>
                <@param>
                    m exact whether the probability should be calculated exact using{@link org.apache.commons.math3.fraction.BigFraction} everywhere at the
                      expense of very slow execution time, or if {@code double} should be used
                      convenient places to gain speed. Almost never choose {@code true} in real
                      applications unless you are very sure; {@code true} is almost solely for
                      verification purposes.                    
                </@param>
                <@return>
                    n the two-sided probability of {@code P(D_n < d)}                    
                </@return>
                <@throws>
                    s MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.                    
                </@throws>
            </javadoc>
            <method name="cdf" type="double" line="149">
                <params>
                    <param name="d" type="double"/>
                    <param name="exact" type="boolean"/>
                </params>
                <declaration name="ninv" type="double" line="151"/>
                <declaration name="ninvhalf" type="double" line="152"/>
                <scope line="154"/>
                <scope line="158">
                    <declaration name="res" type="double" line="160"/>
                    <declaration name="f" type="double" line="161"/>
                    <scope line="164"/>
                </scope>
                <scope line="170"/>
                <scope line="174"/>
            </method>
            <javadoc line="182">
                Calculates the exact value of {@code P(D_n &lt; d)} using method described
                  in [1] and {@link org.apache.commons.math3.fraction.BigFraction} (see
                  above).                
                <@param>
                    m d statistic                    
                </@param>
                <@return>
                    n the two-sided probability of {@code P(D_n < d)}                    
                </@return>
                <@throws>
                    s MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.                    
                </@throws>
            </javadoc>
            <method name="exactK" type="double" line="194">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="195">
                    BigFraction.doubleValue converts numerator to double and the
                     denominator to double and divides afterwards. That gives NaN quite
                     easy. This does not (scale is the number of digits):                    
                </comment>
                <declaration name="k" type="int" line="196"/>
                <declaration name="H" type="FieldMatrix&lt;BigFraction&gt;" line="198"/>
                <declaration name="Hpower" type="FieldMatrix&lt;BigFraction&gt;" line="199"/>
                <declaration name="pFrac" type="BigFraction" line="201"/>
                <scope line="203"/>
            </method>
            <javadoc line="215">
                Calculates {@code P(D_n &lt; d)} using method described in [1] and doubles
                  (see above).                
                <@param>
                    m d statistic                    
                </@param>
                <@return>
                    n the two-sided probability of {@code P(D_n < d)}                    
                </@return>
                <@throws>
                    s MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.                    
                </@throws>
            </javadoc>
            <method name="roundedK" type="double" line="226">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="227">
                    Here the rounding part comes into play: use                    
                </comment>
                <declaration name="k" type="int" line="228"/>
                <declaration name="HBigFraction" type="FieldMatrix&lt;BigFraction&gt;" line="229"/>
                <declaration name="m" type="int" line="230"/>
                <declaration name="H" type="RealMatrix" line="236"/>
                <scope line="238">
                    <scope line="239"/>
                </scope>
                <declaration name="Hpower" type="RealMatrix" line="244"/>
                <declaration name="pFrac" type="double" line="246"/>
                <scope line="248"/>
            </method>
            <javadoc line="255">
                Creates {@code H} of size {@code m x m} as described in [1] (see above).                
                <@param>
                    m d statistic                    
                </@param>
                <@return>
                    n H matrix                    
                </@return>
                <@throws>
                    s NumberIsTooLargeException if fractional part is greater than 1                    
                </@throws>
                <@throws>
                    s FractionConversionException if algorithm fails to convert{@code h} to a {@link org.apache.commons.math3.fraction.BigFraction} in
                      expressing {@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.                    
                </@throws>
            </javadoc>
            <method name="createH" type="FieldMatrix<BigFraction>" line="267">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="268">
                    Start by filling everything with either 0 or 1.                    
                </comment>
                <comment line="268">
                    Setting up power-array to avoid calculating the same value twice:                    
                </comment>
                <comment line="268">
                    First column and last row has special values (each other reversed).                    
                </comment>
                <comment line="268">
                    [1] states: &quot;For 12 &lt; h &lt; 1 the bottom left element of the matrix
                     should be (1 - 2h^m + (2h - 1)^m )m!&quot; Since 0 &lt;= h &lt; 1, then if h &gt;                    
                </comment>
                <comment line="268">
                    Aside from the first column and last row, the (i, j)-th element is
                     1(i - j + 1)! if i - j + 1 &gt;= 0, else 0. 1&apos;s and 0&apos;s are already
                     put, so only division with (i - j + 1)! is needed in the elements
                     that have 1&apos;s. There is no need to calculate (i - j + 1)! and then
                     divide - small steps avoid overflows.
                    
                     Note that i - j + 1 &gt; 0 &lt;=&gt; i + 1 &gt; j instead of j&apos;ing all the way to
                     m. Also note that it is started at g = 2 because dividing by 1 isn&apos;t
                     really necessary.                    
                </comment>
                <declaration name="k" type="int" line="269"/>
                <declaration name="m" type="int" line="271"/>
                <declaration name="hDouble" type="double" line="272"/>
                <scope line="274"/>
                <declaration name="h" type="BigFraction" line="278"/>
                <scope line="280"/>
                <scope line="282">
                    <scope line="283"/>
                    <scope line="285"/>
                </scope>
                <declaration name="Hdata" type="BigFraction[][]" line="290"/>
                <scope line="295">
                    <scope line="296">
                        <scope line="297"/>
                        <scope line="299"/>
                    </scope>
                </scope>
                <declaration name="hPowers" type="BigFraction[]" line="309"/>
                <scope line="311"/>
                <scope line="318"/>
                <scope line="328"/>
                <scope line="343">
                    <scope line="344">
                        <scope line="345">
                            <scope line="346"/>
                        </scope>
                    </scope>
                </scope>
            </method>
        </class>
    </source>