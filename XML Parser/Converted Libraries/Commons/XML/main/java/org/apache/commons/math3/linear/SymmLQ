<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.linear">
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MaxCountExceededException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.ExceptionContext"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.IterationManager"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="SymmLQ" extends="PreconditionedIterativeLinearSolver" line="27">
            <comment line="28">
                IMPLEMENTATION NOTES
                 --------------------
                 The implementation follows as closely as possible the notations of Paige
                 and Saunders (1975). Attention must be paid to the fact that some
                 quantities which are relevant to iteration k can only be computed in
                 iteration (k+1). Therefore, minute attention must be paid to the index of
                 each state variable of this algorithm.
                
                 1. Preconditioning
                    ---------------
                 The Lanczos iterations associated with Ahat and bhat read
                   beta[1] = ||P  b||
                   v[1] = P  b  beta[1]
                   beta[k+1]  v[k+1] = Ahat  v[k] - alpha[k]  v[k] - beta[k]  v[k-1]
                                      = P  (A - shift  I)  P&apos;  v[k] - alpha[k]  v[k]
                                        - beta[k]  v[k-1]
                 Multiplying both sides by P&apos;, we get
                   beta[k+1]  (P&apos;  v)[k+1] = M  (A - shift  I)  (P&apos;  v)[k]
                                               - alpha[k]  (P&apos;  v)[k]
                                               - beta[k]  (P&apos;  v[k-1]),
                 and
                   alpha[k+1] = v[k+1]&apos;  Ahat  v[k+1]
                              = v[k+1]&apos;  P  (A - shift  I)  P&apos;  v[k+1]
                              = (P&apos;  v)[k+1]&apos;  (A - shift  I)  (P&apos;  v)[k+1].
                
                 In other words, the Lanczos iterations are unchanged, except for the fact
                 that we really compute (P&apos;  v) instead of v. It can easily be checked
                 that all other formulas are unchanged. It must be noted that P is never
                 explicitly used, only matrix-vector products involving are invoked.
                
                 2. Accounting for the shift parameter
                    ----------------------------------
                 Is trivial: each time A.operate(x) is invoked, one must subtract shift  x
                 to the result.
                
                 3. Accounting for the goodb flag
                    -----------------------------
                 When goodb is set to true, the component of xL along b is computed
                 separately. From Paige and Saunders (1975), equation (5.9), we have
                   wbar[k+1] = s[k]  wbar[k] - c[k]  v[k+1],
                   wbar[1] = v[1].
                 Introducing wbar2[k] = wbar[k] - s[1]  ...  s[k-1]  v[1], it can
                 easily be verified by induction that wbar2 follows the same recursive
                 relation
                   wbar2[k+1] = s[k]  wbar2[k] - c[k]  v[k+1],
                   wbar2[1] = 0,
                 and we then have
                   w[k] = c[k]  wbar2[k] + s[k]  v[k+1]
                          + s[1]  ...  s[k-1]  c[k]  v[1].
                 Introducing w2[k] = w[k] - s[1]  ...  s[k-1]  c[k]  v[1], we find,
                 from (5.10)
                   xL[k] = zeta[1]  w[1] + ... + zeta[k]  w[k]
                         = zeta[1]  w2[1] + ... + zeta[k]  w2[k]
                           + (s[1]  c[2]  zeta[2] + ...
                           + s[1]  ...  s[k-1]  c[k]  zeta[k])  v[1]
                         = xL2[k] + bstep[k]  v[1],
                 where xL2[k] is defined by
                   xL2[0] = 0,
                   xL2[k+1] = xL2[k] + zeta[k+1]  w2[k+1],
                 and bstep is defined by
                   bstep[1] = 0,
                   bstep[k] = bstep[k-1] + s[1]  ...  s[k-1]  c[k]  zeta[k].                
            </comment>
            <javadoc line="27">
                &lt;p&gt;
                 * Implementation of the SYMMLQ iterative linear solver proposed by &lt;a
                 * href=&quot;#PAIG1975&quot;&gt;Paige and Saunders (1975)&lt;/a&gt;. This implementation is
                 * largely based on the FORTRAN code by Pr. Michael A. Saunders, available &lt;a
                 * href=&quot;http://www.stanford.edu/group/SOL/software/symmlq/f77/&quot;&gt;here&lt;/a&gt;.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * SYMMLQ is designed to solve the system of linear equations A &amp;middot; x = b
                 * where A is an n &amp;times; n self-adjoint linear operator (defined as a{@link RealLinearOperator}), and b is a given vector. The operator A is not
                 * required to be positive definite. If A is known to be definite, the method of
                 * conjugate gradients might be preferred, since it will require about the same
                 * number of iterations as SYMMLQ but slightly less work per iteration.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * SYMMLQ is designed to solve the system (A - shift &amp;middot; I) &amp;middot; x = b,
                 * where shift is a specified scalar value. If shift and b are suitably chosen,
                 * the computed vector x may approximate an (unnormalized) eigenvector of A, as
                 * in the methods of inverse iteration and/or Rayleigh-quotient iteration.
                 * Again, the linear operator (A - shift &amp;middot; I) need not be positive
                 * definite (but &lt;em&gt;must&lt;/em&gt; be self-adjoint). The work per iteration is very
                 * slightly less if shift = 0.
                 * &lt;/p&gt;
                 * &lt;h3&gt;Preconditioning&lt;/h3&gt;
                 * &lt;p&gt;
                 * Preconditioning may reduce the number of iterations required. The solver may
                 * be provided with a positive definite preconditioner
                 * M = P&lt;sup&gt;T&lt;/sup&gt; &amp;middot; P
                 * that is known to approximate
                 * (A - shift &amp;middot; I)&lt;sup&gt;-1&lt;/sup&gt; in some sense, where matrix-vector
                 * products of the form M &amp;middot; y = x can be computed efficiently. Then
                 * SYMMLQ will implicitly solve the system of equations
                 * P &amp;middot; (A - shift &amp;middot; I) &amp;middot; P&lt;sup&gt;T&lt;/sup&gt; &amp;middot;
                 * x&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; b, i.e.
                 * A&lt;sub&gt;hat&lt;/sub&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt; = b&lt;sub&gt;hat&lt;/sub&gt;,
                 * where
                 * A&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; (A - shift &amp;middot; I) &amp;middot; P&lt;sup&gt;T&lt;/sup&gt;,
                 * b&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; b,
                 * and return the solution
                 * x = P&lt;sup&gt;T&lt;/sup&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt;.
                 * The associated residual is
                 * r&lt;sub&gt;hat&lt;/sub&gt; = b&lt;sub&gt;hat&lt;/sub&gt; - A&lt;sub&gt;hat&lt;/sub&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt;
                 * = P &amp;middot; [b - (A - shift &amp;middot; I) &amp;middot; x]
                 * = P &amp;middot; r.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * In the case of preconditioning, the {@link IterativeLinearSolverEvent}s that
                 * this solver fires are such that{@link IterativeLinearSolverEvent#getNormOfResidual()} returns the norm of
                 * the &lt;em&gt;preconditioned&lt;/em&gt;, updated residual, ||P &amp;middot; r||, not the norm
                 * of the &lt;em&gt;true&lt;/em&gt; residual ||r||.
                 * &lt;/p&gt;
                 * &lt;h3&gt;&lt;a id=&quot;stopcrit&quot;&gt;Default stopping criterion&lt;/a&gt;&lt;/h3&gt;
                 * &lt;p&gt;
                 * A default stopping criterion is implemented. The iterations stop when || rhat
                 * || &amp;le; &amp;delta; || Ahat || || xhat ||, where xhat is the current estimate of
                 * the solution of the transformed system, rhat the current estimate of the
                 * corresponding residual, and &amp;delta; a user-specified tolerance.
                 * &lt;/p&gt;
                 * &lt;h3&gt;Iteration count&lt;/h3&gt;
                 * &lt;p&gt;
                 * In the present context, an iteration should be understood as one evaluation
                 * of the matrix-vector product A &amp;middot; x. The initialization phase therefore
                 * counts as one iteration. If the user requires checks on the symmetry of A,
                 * this entails one further matrix-vector product in the initial phase. This
                 * further product is &lt;em&gt;not&lt;/em&gt; accounted for in the iteration count. In
                 * other words, the number of iterations required to reach convergence will be
                 * identical, whether checks have been required or not.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * The present definition of the iteration count differs from that adopted in
                 * the original FOTRAN code, where the initialization phase was &lt;em&gt;not&lt;/em&gt;
                 * taken into account.
                 * &lt;/p&gt;
                 * &lt;h3&gt;&lt;a id=&quot;initguess&quot;&gt;Initial guess of the solution&lt;/a&gt;&lt;/h3&gt;
                 * &lt;p&gt;
                 * The {@code x} parameter in
                 * &lt;ul&gt;
                 * &lt;li&gt;{@link #solve(RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
                 * &lt;li&gt;{@link #solve(RealLinearOperator,RealLinearOperator,RealVector,RealVector)}},&lt;/li&gt;
                 * &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
                 * &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
                 * &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealLinearOperator,RealVector,RealVector,boolean,double)},&lt;/li&gt;
                 * &lt;/ul&gt;
                 * should not be considered as an initial guess, as it is set to zero in the
                 * initial phase. If x&lt;sub&gt;0&lt;/sub&gt; is known to be a good approximation to x, one
                 * should compute r&lt;sub&gt;0&lt;/sub&gt; = b - A &amp;middot; x, solve A &amp;middot; dx = r0,
                 * and set x = x&lt;sub&gt;0&lt;/sub&gt; + dx.
                 * &lt;/p&gt;
                 * &lt;h3&gt;&lt;a id=&quot;context&quot;&gt;Exception context&lt;/a&gt;&lt;/h3&gt;
                 * &lt;p&gt;
                 * Besides standard {@link DimensionMismatchException}, this class might throw{@link NonSelfAdjointOperatorException} if the linear operator or the
                 * preconditioner are not symmetric. In this case, the {@link ExceptionContext}provides more information
                 * &lt;ul&gt;
                 * &lt;li&gt;key {@code &quot;operator&quot;} points to the offending linear operator, say L,&lt;/li&gt;
                 * &lt;li&gt;key {@code &quot;vector1&quot;} points to the first offending vector, say x,
                 * &lt;li&gt;key {@code &quot;vector2&quot;} points to the second offending vector, say y, such
                 * that x&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L &amp;middot; y &amp;ne; y&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L
                 * &amp;middot; x (within a certain accuracy).&lt;/li&gt;
                 * &lt;/ul&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;{@link NonPositiveDefiniteOperatorException} might also be thrown in case the
                 * preconditioner is not positive definite. The relevant keys to the{@link ExceptionContext} are
                 * &lt;ul&gt;
                 * &lt;li&gt;key {@code &quot;operator&quot;}, which points to the offending linear operator,
                 * say L,&lt;/li&gt;
                 * &lt;li&gt;key {@code &quot;vector&quot;}, which points to the offending vector, say x, such
                 * that x&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L &amp;middot; x &lt; 0.&lt;/li&gt;
                 * &lt;/ul&gt;
                 * &lt;/p&gt;
                 * &lt;h3&gt;References&lt;/h3&gt;
                 * &lt;dl&gt;
                 * &lt;dt&gt;&lt;a id=&quot;PAIG1975&quot;&gt;Paige and Saunders (1975)&lt;/a&gt;&lt;/dt&gt;
                 * &lt;dd&gt;C. C. Paige and M. A. Saunders, &lt;a
                 * href=&quot;http://www.stanford.edu/group/SOL/software/symmlq/PS75.pdf&quot;&gt;&lt;em&gt;
                 * Solution of Sparse Indefinite Systems of Linear Equations&lt;/em&gt;&lt;/a&gt;, SIAM
                 * Journal on Numerical Analysis 12(4): 617-629, 1975&lt;/dd&gt;
                 * &lt;/dl&gt;                
                <@version>
                    n $Id: SymmLQ.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <class name="State" line="226">
                <javadoc line="226">
                    &lt;p&gt;
                     * A simple container holding the non-final variables used in the
                     * iterations. Making the current state of the solver visible from the
                     * outside is necessary, because during the iterations, {@code x} does not
                     * &lt;em&gt;exactly&lt;/em&gt; hold the current estimate of the solution. Indeed,{@code x} needs in general to be moved from the LQ point to the CG point.
                     * Besides, additional upudates must be carried out in case {@code goodb} is
                     * set to {@code true}.
                     * &lt;/p&gt;
                     * &lt;p&gt;
                     * In all subsequent comments, the description of the state variables refer
                     * to their value after a call to {@link #update()}. In these comments, k is
                     * the current number of evaluations of matrix-vector products.
                     * &lt;/p&gt;                    
                </javadoc>
                <declaration name="CBRT_MACH_PREC" type="double" line="243"/>
                <javadoc line="243">
                    The cubic root of {@link #MACH_PREC}.                    
                </javadoc>
                <declaration name="MACH_PREC" type="double" line="246"/>
                <javadoc line="246">
                    The machine precision.                    
                </javadoc>
                <declaration name="a" type="RealLinearOperator" line="249"/>
                <javadoc line="249">
                    Reference to the linear operator.                    
                </javadoc>
                <declaration name="b" type="RealVector" line="252"/>
                <javadoc line="252">
                    Reference to the right-hand side vector.                    
                </javadoc>
                <declaration name="check" type="boolean" line="255"/>
                <javadoc line="255">
                    {@code true} if symmetry of matrix and conditioner must be checked.                    
                </javadoc>
                <declaration name="delta" type="double" line="258"/>
                <javadoc line="258">
                    The value of the custom tolerance &amp;delta; for the default stopping
                     * criterion.                    
                </javadoc>
                <declaration name="beta" type="double" line="264"/>
                <javadoc line="264">
                    The value of beta[k+1].                    
                </javadoc>
                <declaration name="beta1" type="double" line="267"/>
                <javadoc line="267">
                    The value of beta[1].                    
                </javadoc>
                <declaration name="bstep" type="double" line="270"/>
                <javadoc line="270">
                    The value of bstep[k-1].                    
                </javadoc>
                <declaration name="cgnorm" type="double" line="273"/>
                <javadoc line="273">
                    The estimate of the norm of P * rC[k].                    
                </javadoc>
                <declaration name="dbar" type="double" line="276"/>
                <javadoc line="276">
                    The value of dbar[k+1] = -beta[k+1] * c[k-1].                    
                </javadoc>
                <declaration name="gammaZeta" type="double" line="279"/>
                <javadoc line="279">
                    The value of gamma[k] * zeta[k]. Was called {@code rhs1} in the
                     * initial code.                    
                </javadoc>
                <declaration name="gbar" type="double" line="285"/>
                <javadoc line="285">
                    The value of gbar[k].                    
                </javadoc>
                <declaration name="gmax" type="double" line="288"/>
                <javadoc line="288">
                    The value of max(|alpha[1]|, gamma[1], ..., gamma[k-1]).                    
                </javadoc>
                <declaration name="gmin" type="double" line="291"/>
                <javadoc line="291">
                    The value of min(|alpha[1]|, gamma[1], ..., gamma[k-1]).                    
                </javadoc>
                <declaration name="goodb" type="boolean" line="294"/>
                <javadoc line="294">
                    Copy of the {@code goodb} parameter.                    
                </javadoc>
                <declaration name="hasConverged" type="boolean" line="297"/>
                <javadoc line="297">
                    {@code true} if the default convergence criterion is verified.                    
                </javadoc>
                <declaration name="lqnorm" type="double" line="300"/>
                <javadoc line="300">
                    The estimate of the norm of P * rL[k-1].                    
                </javadoc>
                <declaration name="m" type="RealLinearOperator" line="303"/>
                <javadoc line="303">
                    Reference to the preconditioner, M.                    
                </javadoc>
                <declaration name="minusEpsZeta" type="double" line="306"/>
                <javadoc line="306">
                    The value of (-eps[k+1] * zeta[k-1]). Was called {@code rhs2} in the
                     * initial code.                    
                </javadoc>
                <declaration name="mb" type="RealVector" line="312"/>
                <javadoc line="312">
                    The value of M * b.                    
                </javadoc>
                <declaration name="oldb" type="double" line="315"/>
                <javadoc line="315">
                    The value of beta[k].                    
                </javadoc>
                <declaration name="r1" type="RealVector" line="318"/>
                <javadoc line="318">
                    The value of beta[k] * M^(-1) * P&apos; * v[k].                    
                </javadoc>
                <declaration name="r2" type="RealVector" line="321"/>
                <javadoc line="321">
                    The value of beta[k+1] * M^(-1) * P&apos; * v[k+1].                    
                </javadoc>
                <declaration name="rnorm" type="double" line="324"/>
                <javadoc line="324">
                    The value of the updated, preconditioned residual P * r. This value is
                     * given by {@code min(}{@link #cgnorm}{@code , }{@link #lqnorm}{@code )}.                    
                </javadoc>
                <declaration name="shift" type="double" line="330"/>
                <javadoc line="330">
                    Copy of the {@code shift} parameter.                    
                </javadoc>
                <declaration name="snprod" type="double" line="333"/>
                <javadoc line="333">
                    The value of s[1] * ... * s[k-1].                    
                </javadoc>
                <declaration name="tnorm" type="double" line="336"/>
                <javadoc line="336">
                    An estimate of the square of the norm of A * V[k], based on Paige and
                     * Saunders (1975), equation (3.3).                    
                </javadoc>
                <declaration name="wbar" type="RealVector" line="342"/>
                <javadoc line="342">
                    The value of P&apos; * wbar[k] or P&apos; * (wbar[k] - s[1] * ... * s[k-1] 
                     * v[1]) if {@code goodb} is {@code true}. Was called {@code w} in the
                     * initial code.                    
                </javadoc>
                <declaration name="xL" type="RealVector" line="349"/>
                <javadoc line="349">
                    A reference to the vector to be updated with the solution. Contains
                     * the value of xL[k-1] if {@code goodb} is {@code false}, (xL[k-1] -
                     * bstep[k-1] * v[1]) otherwise.                    
                </javadoc>
                <declaration name="y" type="RealVector" line="356"/>
                <javadoc line="356">
                    The value of beta[k+1] * P&apos; * v[k+1].                    
                </javadoc>
                <declaration name="ynorm2" type="double" line="359"/>
                <javadoc line="359">
                    The value of zeta[1]^2 + ... + zeta[k-1]^2.                    
                </javadoc>
                <declaration name="bIsNull" type="boolean" line="362"/>
                <javadoc line="362">
                    The value of {@code b == 0} (exact floating-point equality).                    
                </javadoc>
                <scope line="365"/>
                <javadoc line="370">
                    Creates and inits to k = 1 a new instance of this class.                    
                    <@param>
                        m a the linear operator A of the system                        
                    </@param>
                    <@param>
                        m m the preconditioner, M (can be {@code null})                        
                    </@param>
                    <@param>
                        m b the right-hand side vector                        
                    </@param>
                    <@param>
                        m goodb usually {@code false}, except if {@code x} is expected
                         * to contain a large multiple of {@code b}                        
                    </@param>
                    <@param>
                        m shift the amount to be subtracted to all diagonal elements of
                         * A                        
                    </@param>
                    <@param>
                        m delta the &delta; parameter for the default stopping criterion                        
                    </@param>
                    <@param>
                        m check {@code true} if self-adjointedness of both matrix and
                         * preconditioner should be checked                        
                    </@param>
                </javadoc>
                <method name="State" type="constructor" line="390"/>
                <javadoc line="403">
                    Performs a symmetry check on the specified linear operator, and throws an
                     * exception in case this check fails. Given a linear operator L, and a
                     * vector x, this method checks that
                     * x&apos; &amp;middot; L &amp;middot; y = y&apos; &amp;middot; L &amp;middot; x
                     * (within a given accuracy), where y = L &amp;middot; x.                    
                    <@param>
                        m l the linear operator L                        
                    </@param>
                    <@param>
                        m x the candidate vector x                        
                    </@param>
                    <@param>
                        m y the candidate vector y = L &middot; x                        
                    </@param>
                    <@param>
                        m z the vector z = L &middot; y                        
                    </@param>
                    <@throws>
                        s NonSelfAdjointOperatorException when the test fails                        
                    </@throws>
                </javadoc>
                <method name="checkSymmetry" type="void" line="418">
                    <declaration name="s" type="double" line="419"/>
                    <declaration name="t" type="double" line="420"/>
                    <declaration name="epsa" type="double" line="421"/>
                    <scope line="422">
                        <declaration name="e" type="NonSelfAdjointOperatorException" line="423"/>
                        <declaration name="context" type="ExceptionContext" line="425"/>
                    </scope>
                </method>
                <javadoc line="434">
                    Throws a new {@link NonPositiveDefiniteOperatorException} with
                     * appropriate context.                    
                    <@param>
                        m l the offending linear operator                        
                    </@param>
                    <@param>
                        m v the offending vector                        
                    </@param>
                    <@throws>
                        s NonPositiveDefiniteOperatorException in any circumstances                        
                    </@throws>
                </javadoc>
                <method name="throwNPDLOException" type="void" line="443">
                    <declaration name="e" type="NonPositiveDefiniteOperatorException" line="444"/>
                    <declaration name="context" type="ExceptionContext" line="446"/>
                </method>
                <javadoc line="452">
                    A clone of the BLAS {@code DAXPY} function, which carries out the
                     * operation y &amp;larr; a &amp;middot; x + y. This is for internal use only: no
                     * dimension checks are provided.                    
                    <@param>
                        m a the scalar by which {@code x} is to be multiplied                        
                    </@param>
                    <@param>
                        m x the vector to be added to {@code y}                        
                    </@param>
                    <@param>
                        m y the vector to be incremented                        
                    </@param>
                </javadoc>
                <method name="daxpy" type="void" line="462">
                    <declaration name="n" type="int" line="463"/>
                    <scope line="464"/>
                </method>
                <javadoc line="469">
                    A BLAS-like function, for the operation z &amp;larr; a &amp;middot; x + b
                     * &amp;middot; y + z. This is for internal use only: no dimension checks are
                     * provided.                    
                    <@param>
                        m a the scalar by which {@code x} is to be multiplied                        
                    </@param>
                    <@param>
                        m x the first vector to be added to {@code z}                        
                    </@param>
                    <@param>
                        m b the scalar by which {@code y} is to be multiplied                        
                    </@param>
                    <@param>
                        m y the second vector to be added to {@code z}                        
                    </@param>
                    <@param>
                        m z the vector to be incremented                        
                    </@param>
                </javadoc>
                <method name="daxpbypz" type="void" line="481">
                    <declaration name="n" type="int" line="482"/>
                    <scope line="483">
                        <declaration name="zi" type="double" line="484"/>
                    </scope>
                </method>
                <javadoc line="490">
                    &lt;p&gt;
                     * Move to the CG point if it seems better. In this version of SYMMLQ,
                     * the convergence tests involve only cgnorm, so we&apos;re unlikely to stop
                     * at an LQ point, except if the iteration limit interferes.
                     * &lt;/p&gt;
                     * &lt;p&gt;
                     * Additional upudates are also carried out in case {@code goodb} is set
                     * to {@code true}.
                     * &lt;/p&gt;                    
                    <@param>
                        m x the vector to be updated with the refined value of xL                        
                    </@param>
                </javadoc>
                <method name="refineSolution" type="void" line="503">
                    <declaration name="n" type="int" line="504"/>
                    <scope line="505">
                        <scope line="506"/>
                        <scope line="508">
                            <declaration name="step" type="double" line="509"/>
                            <scope line="510">
                                <declaration name="bi" type="double" line="511"/>
                                <declaration name="xi" type="double" line="512"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="516">
                        <declaration name="anorm" type="double" line="517"/>
                        <declaration name="diag" type="double" line="518"/>
                        <declaration name="zbar" type="double" line="519"/>
                        <declaration name="step" type="double" line="520"/>
                        <scope line="522">
                            <scope line="523">
                                <declaration name="xi" type="double" line="524"/>
                                <declaration name="wi" type="double" line="525"/>
                            </scope>
                        </scope>
                        <scope line="528">
                            <scope line="529">
                                <declaration name="xi" type="double" line="530"/>
                                <declaration name="wi" type="double" line="531"/>
                                <declaration name="bi" type="double" line="532"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="539">
                    Performs the initial phase of the SYMMLQ algorithm. On return, the
                     * value of the state variables of {@code this} object correspond to k =
                     * 1.                    
                </javadoc>
                <method name="init" type="void" line="544">
                    <comment line="545">
                        Set up y for the first Lanczos vector. y and beta1 will be zero                        
                    </comment>
                    <comment line="545">
                        At this point
                           r1 = b,                        
                    </comment>
                    <comment line="545">
                        Set up y for the second Lanczos vector. y and beta will be zero
                         or very small if b is an eigenvector.                        
                    </comment>
                    <comment line="545">
                        At this point                        
                    </comment>
                    <comment line="545">
                        Make sure r2 will be orthogonal to the first v.                        
                    </comment>
                    <comment line="545">
                        At this point
                           oldb = beta[1]                        
                    </comment>
                    <scope line="552"/>
                    <scope line="557"/>
                    <scope line="560"/>
                    <declaration name="v" type="RealVector" line="572"/>
                    <scope line="574"/>
                    <declaration name="alpha" type="double" line="582"/>
                    <declaration name="vty" type="double" line="590"/>
                    <declaration name="vtv" type="double" line="591"/>
                    <scope line="594"/>
                    <scope line="599"/>
                    <scope line="622"/>
                    <scope line="625"/>
                </method>
                <javadoc line="631">
                    Performs the next iteration of the algorithm. The iteration count
                     * should be incremented prior to calling this method. On return, the
                     * value of the state variables of {@code this} object correspond to the
                     * current iteration count {@code k}.                    
                </javadoc>
                <method name="update" type="void" line="637">
                    <comment line="638">
                        At this point
                           v     = P&apos;  v[k],
                           y     = (A - shift  I)  P&apos;  v[k] - beta[k]  M^(-1)  P&apos;  v[k-1],
                           alpha = v&apos;[k]  P  (A - shift  I)  P&apos;  v[k]
                                   - beta[k]  v[k]&apos;  P  M^(-1)  P&apos;  v[k-1]
                                 = v&apos;[k]  P  (A - shift  I)  P&apos;  v[k]
                                   - beta[k]  v[k]&apos;  v[k-1]                        
                    </comment>
                    <comment line="638">
                        At this point
                           y = (A - shift  I)  P&apos;  v[k] - alpha[k]  M^(-1)  P&apos;  v[k]
                               - beta[k]  M^(-1)  P&apos;  v[k-1]
                             = M^(-1)  P&apos;  (P  (A - shift  I)  P&apos;  v[k] -alpha[k]  v[k]
                               - beta[k]  v[k-1])
                             = beta[k+1]  M^(-1)  P&apos;  v[k+1],
                         from Paige and Saunders (1975), equation (3.2).
                        
                         WATCH-IT: the two following lines work only because y is no longer
                         updated up to the end of the present iteration, and is
                         reinitialized at the beginning of the next iteration.                        
                    </comment>
                    <comment line="638">
                        At this point
                           r1 = beta[k]  M^(-1)  P&apos;  v[k],
                           r2 = beta[k+1]  M^(-1)  P&apos;  v[k+1],                        
                    </comment>
                    <comment line="638">
                        Compute the next plane rotation for Q. See Paige and Saunders
                         (1975), equation (5.6), with
                           gamma = gamma[k-1],                        
                    </comment>
                    <comment line="638">
                        The relations
                           gbar[k] = s[k-1]  (-c[k-2]  beta[k]) - c[k-1]  alpha[k]
                                   = s[k-1]  dbar[k] - c[k-1]  alpha[k],
                           delta[k] = c[k-1]  dbar[k] + s[k-1]  alpha[k],
                         are not stated in Paige and Saunders (1975), but can be retrieved
                         by expanding the (k, k-1) and (k, k) coefficients of the matrix in
                         equation (5.5).                        
                    </comment>
                    <comment line="638">
                        At this point
                           gbar   = gbar[k]
                           deltak = delta[k]                        
                    </comment>
                    <comment line="638">
                        At this point
                           x = xL[k-1],                        
                    </comment>
                    <comment line="638">
                        At this point
                           snprod       = s[1]  ...  s[k-1],
                           gmax         = max(|alpha[1]|, gamma[1], ..., gamma[k-1]),
                           gmin         = min(|alpha[1]|, gamma[1], ..., gamma[k-1]),
                           ynorm2       = zeta[1]^2 + ... + zeta[k-1]^2,
                           gammaZeta    = gamma[k]  zeta[k],
                           minusEpsZeta = -eps[k+1]  zeta[k-1].
                         The relation for gammaZeta can be retrieved from Paige and
                         Saunders (1975), equation (5.4a), last line of the vector
                         gbar[k]  zbar[k] = -eps[k]  zeta[k-2] - delta[k]  zeta[k-1].                        
                    </comment>
                    <declaration name="v" type="RealVector" line="638"/>
                    <declaration name="alpha" type="double" line="641"/>
                    <scope line="668"/>
                    <scope line="673"/>
                    <declaration name="gamma" type="double" line="693"/>
                    <declaration name="c" type="double" line="694"/>
                    <declaration name="s" type="double" line="695"/>
                    <declaration name="deltak" type="double" line="705"/>
                    <declaration name="eps" type="double" line="707"/>
                    <declaration name="zeta" type="double" line="709"/>
                    <declaration name="zetaC" type="double" line="718"/>
                    <declaration name="zetaS" type="double" line="719"/>
                    <declaration name="n" type="int" line="720"/>
                    <scope line="721">
                        <declaration name="xi" type="double" line="722"/>
                        <declaration name="vi" type="double" line="723"/>
                        <declaration name="wi" type="double" line="724"/>
                    </scope>
                </method>
                <javadoc line="756">
                    Computes the norms of the residuals, and checks for convergence.
                     * Updates {@link #lqnorm} and {@link #cgnorm}.                    
                </javadoc>
                <method name="updateNorms" type="void" line="760">
                    <comment line="761">
                        Estimate cond(A). In this version we look at the diagonals of L
                         in the factorization of the tridiagonal matrix, T = L  Q.
                         Sometimes, T[k] can be misleadingly ill-conditioned when T[k+1]
                         is not, so we must be careful not to overestimate acond.                        
                    </comment>
                    <declaration name="anorm" type="double" line="761"/>
                    <declaration name="ynorm" type="double" line="762"/>
                    <declaration name="epsa" type="double" line="763"/>
                    <declaration name="epsx" type="double" line="764"/>
                    <declaration name="epsr" type="double" line="765"/>
                    <declaration name="diag" type="double" line="766"/>
                    <declaration name="qrnorm" type="double" line="769"/>
                    <declaration name="acond" type="double" line="778"/>
                    <scope line="779"/>
                    <scope line="781"/>
                    <scope line="784"/>
                    <scope line="787"/>
                </method>
                <javadoc line="798">
                    Returns {@code true} if the default stopping criterion is fulfilled.                    
                    <@return>
                        n {@code true} if convergence of the iterations has occured                        
                    </@return>
                </javadoc>
                <method name="hasConverged" type="boolean" line="803"/>
                <javadoc line="807">
                    Returns {@code true} if the right-hand side vector is zero exactly.                    
                    <@return>
                        n the boolean value of {@code b == 0}                        
                    </@return>
                </javadoc>
                <method name="bEqualsNullVector" type="boolean" line="812"/>
                <javadoc line="816">
                    Returns {@code true} if {@code beta} is essentially zero. This method
                     * is used to check for early stop of the iterations.                    
                    <@return>
                        n {@code true} if {@code beta < }{@link #MACH_PREC}                        
                    </@return>
                </javadoc>
                <method name="betaEqualsZero" type="boolean" line="822"/>
                <javadoc line="826">
                    Returns the norm of the updated, preconditioned residual.                    
                    <@return>
                        n the norm of the residual, ||P * r||                        
                    </@return>
                </javadoc>
                <method name="getNormOfResidual" type="double" line="831"/>
            </class>
            <declaration name="OPERATOR" type="String" line="836"/>
            <javadoc line="836">
                Key for the exception context.                
            </javadoc>
            <declaration name="THRESHOLD" type="String" line="839"/>
            <javadoc line="839">
                Key for the exception context.                
            </javadoc>
            <declaration name="VECTOR" type="String" line="842"/>
            <javadoc line="842">
                Key for the exception context.                
            </javadoc>
            <declaration name="VECTOR1" type="String" line="845"/>
            <javadoc line="845">
                Key for the exception context.                
            </javadoc>
            <declaration name="VECTOR2" type="String" line="848"/>
            <javadoc line="848">
                Key for the exception context.                
            </javadoc>
            <declaration name="check" type="boolean" line="851"/>
            <javadoc line="851">
                {@code true} if symmetry of matrix and conditioner must be checked.                
            </javadoc>
            <declaration name="delta" type="double" line="854"/>
            <javadoc line="854">
                The value of the custom tolerance &amp;delta; for the default stopping
                 * criterion.                
            </javadoc>
            <javadoc line="860">
                Creates a new instance of this class, with &lt;a href=&quot;#stopcrit&quot;&gt;default
                 * stopping criterion&lt;/a&gt;. Note that setting {@code check} to {@code true}entails an extra matrix-vector product in the initial phase.                
                <@param>
                    m maxIterations the maximum number of iterations                    
                </@param>
                <@param>
                    m delta the &delta; parameter for the default stopping criterion                    
                </@param>
                <@param>
                    m check {@code true} if self-adjointedness of both matrix and
                     * preconditioner should be checked                    
                </@param>
            </javadoc>
            <method name="SymmLQ" type="constructor" line="871"/>
            <javadoc line="877">
                Creates a new instance of this class, with &lt;a href=&quot;#stopcrit&quot;&gt;default
                 * stopping criterion&lt;/a&gt; and custom iteration manager. Note that setting{@code check} to {@code true} entails an extra matrix-vector product in
                 * the initial phase.                
                <@param>
                    m manager the custom iteration manager                    
                </@param>
                <@param>
                    m delta the &delta; parameter for the default stopping criterion                    
                </@param>
                <@param>
                    m check {@code true} if self-adjointedness of both matrix and
                     * preconditioner should be checked                    
                </@param>
            </javadoc>
            <method name="SymmLQ" type="constructor" line="889"/>
            <javadoc line="895">
                Returns {@code true} if symmetry of the matrix, and symmetry as well as
                 * positive definiteness of the preconditioner should be checked.                
                <@return>
                    n {@code true} if the tests are to be performed                    
                </@return>
            </javadoc>
            <method name="getCheck" type="boolean" line="901"/>
            <javadoc line="905">
                {@inheritDoc}                
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </@throws>
                <@throws>
                    s NonPositiveDefiniteOperatorException if {@code m} is not
                     * positive definite                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solve" type="RealVector" line="920">
                <declaration name="x" type="RealVector" line="922"/>
            </method>
            <javadoc line="926">
                Returns an estimate of the solution to the linear system (A - shift
                 * &amp;middot; I) &amp;middot; x = b.
                 * &lt;p&gt;
                 * If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
                 * achieved with {@code goodb} set to {@code true}; this however requires an
                 * extra call to the preconditioner.
                 * &lt;/p&gt;
                 * &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
                 * solved. Otherwise, it could be an approximation to an eigenvalue of A,
                 * such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
                 * (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
                 * sufficiently like an eigenvector corresponding to an eigenvalue near
                 * shift, then the computed x may have very large components. When
                 * normalized, x may be closer to an eigenvector than b.
                 * &lt;/p&gt;                
                <@param>
                    m a the linear operator A of the system                    
                </@param>
                <@param>
                    m m the preconditioner, M (can be {@code null})                    
                </@param>
                <@param>
                    m b the right-hand side vector                    
                </@param>
                <@param>
                    m goodb usually {@code false}, except if {@code x} is expected to
                     * contain a large multiple of {@code b}                    
                </@param>
                <@param>
                    m shift the amount to be subtracted to all diagonal elements of A                    
                </@param>
                <@return>
                    n a reference to {@code x} (shallow copy)                    
                </@return>
                <@throws>
                    s NullArgumentException if one of the parameters is {@code null}                    
                </@throws>
                <@throws>
                    s NonSquareOperatorException if {@code a} or {@code m} is not square                    
                </@throws>
                <@throws>
                    s DimensionMismatchException if {@code m} or {@code b} have dimensions
                     * inconsistent with {@code a}                    
                </@throws>
                <@throws>
                    s MaxCountExceededException at exhaustion of the iteration count,
                     * unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}                    
                </@throws>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </@throws>
                <@throws>
                    s NonPositiveDefiniteOperatorException if {@code m} is not
                     * positive definite                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solve" type="RealVector" line="971">
                <declaration name="x" type="RealVector" line="973"/>
            </method>
            <javadoc line="977">
                {@inheritDoc}                
                <@param>
                    m x not meaningful in this implementation; should not be considered
                     * as an initial guess (<a href="#initguess">more</a>)                    
                </@param>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </@throws>
                <@throws>
                    s NonPositiveDefiniteOperatorException if {@code m} is not positive
                     * definite                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solve" type="RealVector" line="994"/>
            <javadoc line="999">
                {@inheritDoc}                
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solve" type="RealVector" line="1010">
                <declaration name="x" type="RealVector" line="1012"/>
            </method>
            <javadoc line="1017">
                Returns the solution to the system (A - shift &amp;middot; I) &amp;middot; x = b.
                 * &lt;p&gt;
                 * If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
                 * achieved with {@code goodb} set to {@code true}.
                 * &lt;/p&gt;
                 * &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
                 * solved. Otherwise, it could be an approximation to an eigenvalue of A,
                 * such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
                 * (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
                 * sufficiently like an eigenvector corresponding to an eigenvalue near
                 * shift, then the computed x may have very large components. When
                 * normalized, x may be closer to an eigenvector than b.
                 * &lt;/p&gt;                
                <@param>
                    m a the linear operator A of the system                    
                </@param>
                <@param>
                    m b the right-hand side vector                    
                </@param>
                <@param>
                    m goodb usually {@code false}, except if {@code x} is expected to
                     * contain a large multiple of {@code b}                    
                </@param>
                <@param>
                    m shift the amount to be subtracted to all diagonal elements of A                    
                </@param>
                <@return>
                    n a reference to {@code x}                    
                </@return>
                <@throws>
                    s NullArgumentException if one of the parameters is {@code null}                    
                </@throws>
                <@throws>
                    s NonSquareOperatorException if {@code a} is not square                    
                </@throws>
                <@throws>
                    s DimensionMismatchException if {@code b} has dimensions
                     * inconsistent with {@code a}                    
                </@throws>
                <@throws>
                    s MaxCountExceededException at exhaustion of the iteration count,
                     * unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}                    
                </@throws>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solve" type="RealVector" line="1056">
                <declaration name="x" type="RealVector" line="1058"/>
            </method>
            <javadoc line="1062">
                {@inheritDoc}                
                <@param>
                    m x not meaningful in this implementation; should not be considered
                     * as an initial guess (<a href="#initguess">more</a>)                    
                </@param>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solve" type="RealVector" line="1076"/>
            <javadoc line="1081">
                {@inheritDoc}                
                <@param>
                    m x the vector to be updated with the solution; {@code x} should
                     * not be considered as an initial guess (<a href="#initguess">more</a>)                    
                </@param>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </@throws>
                <@throws>
                    s NonPositiveDefiniteOperatorException if {@code m} is not
                     * positive definite                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solveInPlace" type="RealVector" line="1098"/>
            <javadoc line="1102">
                Returns an estimate of the solution to the linear system (A - shift
                 * &amp;middot; I) &amp;middot; x = b. The solution is computed in-place.
                 * &lt;p&gt;
                 * If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
                 * achieved with {@code goodb} set to {@code true}; this however requires an
                 * extra call to the preconditioner.
                 * &lt;/p&gt;
                 * &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
                 * solved. Otherwise, it could be an approximation to an eigenvalue of A,
                 * such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
                 * (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
                 * sufficiently like an eigenvector corresponding to an eigenvalue near
                 * shift, then the computed x may have very large components. When
                 * normalized, x may be closer to an eigenvector than b.
                 * &lt;/p&gt;                
                <@param>
                    m a the linear operator A of the system                    
                </@param>
                <@param>
                    m m the preconditioner, M (can be {@code null})                    
                </@param>
                <@param>
                    m b the right-hand side vector                    
                </@param>
                <@param>
                    m x the vector to be updated with the solution; {@code x} should
                     * not be considered as an initial guess (<a href="#initguess">more</a>)                    
                </@param>
                <@param>
                    m goodb usually {@code false}, except if {@code x} is expected to
                     * contain a large multiple of {@code b}                    
                </@param>
                <@param>
                    m shift the amount to be subtracted to all diagonal elements of A                    
                </@param>
                <@return>
                    n a reference to {@code x} (shallow copy).                    
                </@return>
                <@throws>
                    s NullArgumentException if one of the parameters is {@code null}                    
                </@throws>
                <@throws>
                    s NonSquareOperatorException if {@code a} or {@code m} is not square                    
                </@throws>
                <@throws>
                    s DimensionMismatchException if {@code m}, {@code b} or {@code x}have dimensions inconsistent with {@code a}.                    
                </@throws>
                <@throws>
                    s MaxCountExceededException at exhaustion of the iteration count,
                     * unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}                    
                </@throws>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </@throws>
                <@throws>
                    s NonPositiveDefiniteOperatorException if {@code m} is not positive
                     * definite                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solveInPlace" type="RealVector" line="1150">
                <comment line="1151">
                    Initialization counts as an iteration.                    
                </comment>
                <comment line="1151">
                    Cause termination if beta is essentially zero.                    
                </comment>
                <declaration name="manager" type="IterationManager" line="1153"/>
                <declaration name="state" type="State" line="1158"/>
                <declaration name="event" type="IterativeLinearSolverEvent" line="1162"/>
                <scope line="1168"/>
                <declaration name="earlyStop" type="boolean" line="1174"/>
                <scope line="1177">
                    <scope line="1178"/>
                </scope>
            </method>
            <javadoc line="1205">
                {@inheritDoc}                
                <@param>
                    m x the vector to be updated with the solution; {@code x} should
                     * not be considered as an initial guess (<a href="#initguess">more</a>)                    
                </@param>
                <@throws>
                    s NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </@throws>
                <@throws>
                    s IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </@throws>
            </javadoc>
            <method name="solveInPlace" type="RealVector" line="1219"/>
        </class>
    </source>