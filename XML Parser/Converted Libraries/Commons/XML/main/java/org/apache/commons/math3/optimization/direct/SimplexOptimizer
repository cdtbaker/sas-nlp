<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optimization.direct">
        <import package="java.util.Comparator"/>
        <import package="org.apache.commons.math3.analysis.MultivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.optimization.GoalType"/>
        <import package="org.apache.commons.math3.optimization.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optimization.PointValuePair"/>
        <import package="org.apache.commons.math3.optimization.SimpleValueChecker"/>
        <import package="org.apache.commons.math3.optimization.MultivariateOptimizer"/>
        <import package="org.apache.commons.math3.optimization.OptimizationData"/>
        <class name="SimplexOptimizer" line="31">
            <extends class="BaseAbstractMultivariateOptimizer">
                <type_params>
                    <type_param name="MultivariateFunction"/>
                </type_params>
            </extends>
            <implements interface="MultivariateOptimizer"/>
            <javadoc line="31">
                This class implements simplex-based direct search optimization.
                  &lt;p&gt;
                  Direct search methods only use objective function values, they do
                  not need derivatives and don&apos;t either try to compute approximation
                  of the derivatives. According to a 1996 paper by Margaret H. Wright
                  (&lt;a href=&quot;http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz&quot;&gt;Direct
                  Search Methods: Once Scorned, Now Respectable&lt;/a&gt;), they are used
                  when either the computation of the derivative is impossible (noisy
                  functions, unpredictable discontinuities) or difficult (complexity,
                  computation cost). In the first cases, rather than an optimum, a
                  &lt;em&gt;not too bad&lt;/em&gt; point is desired. In the latter cases, an
                  optimum is desired but cannot be reasonably found. In all cases
                  direct search methods can be useful.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Simplex-based direct search methods are based on comparison of
                  the objective function values at the vertices of a simplex (which is a
                  set of n+1 points in dimension n) that is updated by the algorithms
                  steps.
                  &lt;p&gt;
                  &lt;p&gt;
                  The {@link #setSimplex(AbstractSimplex) setSimplex} method &lt;em&gt;must&lt;/em&gt;
                  be called prior to calling the {@code optimize} method.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each call to {@link #optimize(int,MultivariateFunction,GoalType,double[])optimize} will re-use the start configuration of the current simplex and
                  move it such that its first vertex is at the provided start point of the
                  optimization. If the {@code optimize} method is called to solve a different
                  problem and the number of parameters change, the simplex must be
                  re-initialized to one with the appropriate dimensions.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Convergence is checked by providing the &lt;em&gt;worst&lt;/em&gt; points of
                  previous and current simplex to the convergence checker, not the best
                  ones.
                  &lt;/p&gt;
                  &lt;p&gt;
                  This simplex optimizer implementation does not directly support constrained
                  optimization with simple bounds, so for such optimizations, either a more
                  dedicated method must be used like {@link CMAESOptimizer} or {@link BOBYQAOptimizer}, or the optimized method must be wrapped in an adapter like{@link MultivariateFunctionMappingAdapter} or {@link MultivariateFunctionPenaltyAdapter}.
                  &lt;/p&gt;                
                <@see>
                    e AbstractSimplex                    
                </@see>
                <@see>
                    e MultivariateFunctionMappingAdapter                    
                </@see>
                <@see>
                    e MultivariateFunctionPenaltyAdapter                    
                </@see>
                <@see>
                    e CMAESOptimizer                    
                </@see>
                <@see>
                    e BOBYQAOptimizer                    
                </@see>
                <@version>
                    n $Id: SimplexOptimizer.java 1422230 2012-12-15 12:11:13Z erans $                    
                </@version>
                <@deprecated>
                    d As of 3.1 (to be removed in 4.0).                    
                </@deprecated>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <declaration name="simplex" type="AbstractSimplex" line="92"/>
            <javadoc line="92">
                Simplex.                
            </javadoc>
            <javadoc line="95">
                Constructor using a default {@link SimpleValueChecker convergence
                  checker}.                
                <@deprecated>
                    d See {@link SimpleValueChecker#SimpleValueChecker()}                    
                </@deprecated>
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="101"/>
            <javadoc line="105">
                @param checker Convergence checker.                
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="108">
                <params>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                </params>
            </method>
            <javadoc line="112">
                @param rel Relative threshold.                
                <@param>
                    m abs Absolute threshold.                    
                </@param>
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="116">
                <params>
                    <param name="rel" type="double"/>
                    <param name="abs" type="double"/>
                </params>
            </method>
            <javadoc line="120">
                Set the simplex algorithm.                
                <@param>
                    m simplex Simplex.                    
                </@param>
                <@deprecated>
                    d As of 3.1. The initial simplex can now be passed as an
                      argument of the {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])}method.                    
                </@deprecated>
            </javadoc>
            <method name="setSimplex" type="void" line="129">
                <params>
                    <param name="simplex" type="AbstractSimplex"/>
                </params>
            </method>
            <javadoc line="133">
                Optimize an objective function.                
                <@param>
                    m maxEval Allowed number of evaluations of the objective function.                    
                </@param>
                <@param>
                    m f Objective function.                    
                </@param>
                <@param>
                    m goalType Optimization type.                    
                </@param>
                <@param>
                    m optData Optimization data. The following data will be looked for:
                      <ul>
                      <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>
                      <li>{@link AbstractSimplex}</li>
                      </ul>                    
                </@param>
                <@return>
                    n the point/value pair giving the optimal value for objective
                      function.                    
                </@return>
            </javadoc>
            <method name="optimizeInternal" type="PointValuePair" line="150">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="MultivariateFunction"/>
                    <param name="goalType" type="GoalType"/>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="151">
                    Scan &quot;optData&quot; for the input specific to this optimizer.                    
                </comment>
                <comment line="151">
                    The parent&apos;s method will retrieve the common parameters from                    
                </comment>
                <comment line="151">
                    &quot;optData&quot; and call &quot;doOptimize&quot;.                    
                </comment>
            </method>
            <javadoc line="159">
                Scans the list of (required and optional) optimization data that
                  characterize the problem.                
                <@param>
                    m optData Optimization data. The following data will be looked for:
                      <ul>
                      <li>{@link AbstractSimplex}</li>
                      </ul>                    
                </@param>
            </javadoc>
            <method name="parseOptimizationData" type="void" line="168">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="169">
                    The existing values (as set by the previous call) are reused if                    
                </comment>
                <comment line="169">
                    not provided in the argument list.                    
                </comment>
                <scope line="171">
                    <scope line="172"/>
                </scope>
            </method>
            <javadoc line="179">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="181">
                <comment line="182">
                    Indirect call to &quot;computeObjectiveValue&quot; in order to update the                    
                </comment>
                <comment line="182">
                    evaluations counter.                    
                </comment>
                <comment line="182">
                    Initialize search.                    
                </comment>
                <scope line="182"/>
                <anonymous_class line="189">
                    <method name="value" type="double" line="190">
                        <params>
                            <param name="point" type="double[]"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="evalFunc" type="MultivariateFunction" line="188"/>
                <declaration name="isMinim" type="boolean" line="195"/>
                <anonymous_class line="197">
                    <method name="compare" type="int" line="199">
                        <params>
                            <param name="o1" type="PointValuePair"/>
                            <param name="o2" type="PointValuePair"/>
                        </params>
                        <declaration name="v1" type="double" line="200"/>
                        <declaration name="v2" type="double" line="201"/>
                    </method>
                </anonymous_class>
                <declaration name="comparator" type="Comparator&lt;PointValuePair&gt;" line="196"/>
                <declaration name="previous" type="PointValuePair[]" line="210"/>
                <declaration name="iteration" type="int" line="211"/>
                <declaration name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;" line="212"/>
                <scope line="213">
                    <scope line="214">
                        <declaration name="converged" type="boolean" line="215"/>
                        <scope line="216">
                            <declaration name="prev" type="PointValuePair" line="217"/>
                        </scope>
                        <scope line="221"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>