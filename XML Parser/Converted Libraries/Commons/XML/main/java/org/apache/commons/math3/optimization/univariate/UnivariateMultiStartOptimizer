<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optimization.univariate">
        <import package="java.util.Arrays"/>
        <import package="java.util.Comparator"/>
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.random.RandomGenerator"/>
        <import package="org.apache.commons.math3.optimization.GoalType"/>
        <import package="org.apache.commons.math3.optimization.ConvergenceChecker"/>
        <class name="UnivariateMultiStartOptimizer" line="32">
            <implements interface="BaseUnivariateOptimizer&lt;FUNC&gt;"/>
            <javadoc line="32">
                Special implementation of the {@link UnivariateOptimizer} interface
                 * adding multi-start features to an existing optimizer.
                 * This class wraps a classical optimizer to use it several times in
                 * turn with different starting points in order to avoid being trapped
                 * into a local extremum when looking for a global one.                
                <@param>
                    m<FUNC>
                     *  Type of the objective function to be optimized.                    
                </@param>
                <@version>
                    n $Id: UnivariateMultiStartOptimizer.java 1422230 2012-12-15 12:11:13Z erans $                    
                </@version>
                <@deprecated>
                    d As of 3.1 (to be removed in 4.0).                    
                </@deprecated>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <declaration name="optimizer" type="BaseUnivariateOptimizer&lt;FUNC&gt;" line="49"/>
            <javadoc line="49">
                Underlying classical optimizer.                
            </javadoc>
            <declaration name="maxEvaluations" type="int" line="51"/>
            <javadoc line="51">
                Maximal number of evaluations allowed.                
            </javadoc>
            <declaration name="totalEvaluations" type="int" line="53"/>
            <javadoc line="53">
                Number of evaluations already performed for all starts.                
            </javadoc>
            <declaration name="starts" type="int" line="55"/>
            <javadoc line="55">
                Number of starts to go.                
            </javadoc>
            <declaration name="generator" type="RandomGenerator" line="57"/>
            <javadoc line="57">
                Random generator for multi-start.                
            </javadoc>
            <declaration name="optima" type="UnivariatePointValuePair[]" line="59"/>
            <javadoc line="59">
                Found optima.                
            </javadoc>
            <javadoc line="62">
                Create a multi-start optimizer from a single-start optimizer.                
                <@param>
                    m optimizer Single-start optimizer to wrap.                    
                </@param>
                <@param>
                    m starts Number of starts to perform. If {@code starts == 1},
                     * the {@code optimize} methods will return the same solution as{@code optimizer} would.                    
                </@param>
                <@param>
                    m generator Random generator to use for restarts.                    
                </@param>
                <@throws>
                    s NullArgumentException if {@code optimizer} or {@code generator}is {@code null}.                    
                </@throws>
                <@throws>
                    s NotStrictlyPositiveException if {@code starts < 1}.                    
                </@throws>
            </javadoc>
            <method name="UnivariateMultiStartOptimizer" type="constructor" line="76">
                <scope line="78"/>
                <scope line="81"/>
            </method>
            <javadoc line="90">
                {@inheritDoc}                
            </javadoc>
            <method name="getConvergenceChecker" type="ConvergenceChecker<UnivariatePointValuePair>" line="93"/>
            <javadoc line="97">
                {@inheritDoc}                
            </javadoc>
            <method name="getMaxEvaluations" type="int" line="98"/>
            <javadoc line="102">
                {@inheritDoc}                
            </javadoc>
            <method name="getEvaluations" type="int" line="103"/>
            <javadoc line="107">
                Get all the optima found during the last call to {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}.
                 * The optimizer stores all the optima found during a set of
                 * restarts. The {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}method returns the best point only. This method returns all the points
                 * found at the end of each starts, including the best one already
                 * returned by the {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}method.
                 * &lt;br/&gt;
                 * The returned array as one element for each start as specified
                 * in the constructor. It is ordered with the results from the
                 * runs that did converge first, sorted from best to worst
                 * objective value (i.e in ascending order if minimizing and in
                 * descending order if maximizing), followed by {@code null} elements
                 * corresponding to the runs that did not converge. This means all
                 * elements will be {@code null} if the {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}method did throw an exception.
                 * This also means that if the first element is not {@code null}, it is
                 * the best point found across all starts.                
                <@return>
                    n an array containing the optima.                    
                </@return>
                <@throws>
                    s MathIllegalStateException if {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}has not been called.                    
                </@throws>
            </javadoc>
            <method name="getOptima" type="UnivariatePointValuePair[]" line="134">
                <scope line="135"/>
            </method>
            <javadoc line="141">
                {@inheritDoc}                
            </javadoc>
            <method name="optimize" type="UnivariatePointValuePair" line="144"/>
            <javadoc line="148">
                {@inheritDoc}                
            </javadoc>
            <method name="optimize" type="UnivariatePointValuePair" line="152">
                <comment line="153">
                    Multi-start loop.                    
                </comment>
                <comment line="153">
                    Return the point with the best objective function value.                    
                </comment>
                <declaration name="lastException" type="RuntimeException" line="153"/>
                <scope line="158">
                    <scope line="160">
                        <declaration name="s" type="double" line="161"/>
                    </scope>
                    <scope line="163"/>
                </scope>
                <scope line="174"/>
            </method>
            <javadoc line="182">
                Sort the optima from best to worst, followed by {@code null} elements.                
                <@param>
                    m goal Goal type.                    
                </@param>
            </javadoc>
            <method name="sortPairs" type="void" line="187">
                <anonymous_class line="188">
                    <method name="compare" type="int" line="190">
                        <scope line="191"/>
                        <scope line="193"/>
                        <declaration name="v1" type="double" line="196"/>
                        <declaration name="v2" type="double" line="197"/>
                    </method>
                </anonymous_class>
            </method>
        </class>
    </source>