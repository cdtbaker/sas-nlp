<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.genetics">
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.List"/>
        <import package="java.util.Set"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <class name="CycleCrossover" line="28">
            <implements interface="CrossoverPolicy"/>
            <javadoc line="28">
                Cycle Crossover [CX] builds offspring from &lt;b&gt;ordered&lt;/b&gt; chromosomes by identifying cycles
                 * between two parent chromosomes. To form the children, the cycles are copied from the
                 * respective parents.
                 * &lt;p&gt;
                 * To form a cycle the following procedure is applied:
                 * &lt;ol&gt;
                 * &lt;li&gt;start with the first gene of parent 1&lt;/li&gt;
                 * &lt;li&gt;look at the gene at the same position of parent 2&lt;/li&gt;
                 * &lt;li&gt;go to the position with the same gene in parent 1&lt;/li&gt;
                 * &lt;li&gt;add this gene index to the cycle&lt;/li&gt;
                 * &lt;li&gt;repeat the steps 2-5 until we arrive at the starting gene of this cycle&lt;/li&gt;
                 * &lt;/ol&gt;
                 * The indices that form a cycle are then used to form the children in alternating order, i.e.
                 * in cycle 1, the genes of parent 1 are copied to child 1, while in cycle 2 the genes of parent 1
                 * are copied to child 2, and so forth ...
                 * &lt;/p&gt;
                 * Example (zero-start cycle):
                 * &lt;pre&gt;
                 * p1 = (8 4 7 3 6 2 5 1 9 0)    X   c1 = (8 1 2 3 4 5 6 7 9 0)
                 * p2 = (0 1 2 3 4 5 6 7 8 9)    X   c2 = (0 4 7 3 6 2 5 1 8 9)
                 * cycle 1: 8 0 9
                 * cycle 2: 4 1 7 2 5 6
                 * cycle 3: 3
                 * &lt;/pre&gt;
                 * This policy works only on {@link AbstractListChromosome}, and therefore it
                 * is parameterized by T. Moreover, the chromosomes must have same lengths.                
                <@see>
                    e <a href="http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx">
                     * Cycle Crossover Operator</a>                    
                </@see>
                <@param>
                    m<T>
                     *  generic type of the {@link AbstractListChromosome}s for crossover                    
                </@param>
                <@since>
                    e 3.1                    
                </@since>
                <@version>
                    n $Id: CycleCrossover.java 1385297 2012-09-16 16:05:57Z tn $                    
                </@version>
            </javadoc>
            <declaration name="randomStart" type="boolean" line="68"/>
            <javadoc line="68">
                If the start index shall be chosen randomly.                
            </javadoc>
            <javadoc line="71">
                Creates a new {@link CycleCrossover} policy.                
            </javadoc>
            <method name="CycleCrossover" type="constructor" line="74"/>
            <javadoc line="78">
                Creates a new {@link CycleCrossover} policy using the given {@code randomStart} behavior.                
                <@param>
                    m randomStart whether the start index shall be chosen randomly or be set to 0                    
                </@param>
            </javadoc>
            <method name="CycleCrossover" type="constructor" line="83"/>
            <javadoc line="87">
                Returns whether the starting index is chosen randomly or set to zero.                
                <@return>
                    n {@code true} if the starting index is chosen randomly, {@code false} otherwise                    
                </@return>
            </javadoc>
            <method name="isRandomStart" type="boolean" line="92"/>
            <javadoc line="96">
                {@inheritDoc}                
                <@throws>
                    s MathIllegalArgumentException if the chromosomes are not an instance of {@link AbstractListChromosome}                    
                </@throws>
                <@throws>
                    s DimensionMismatchException if the length of the two chromosomes is different                    
                </@throws>
            </javadoc>
            <method name="crossover" type="ChromosomePair" line="104">
                <scope line="106"/>
            </method>
            <javadoc line="112">
                Helper for {@link #crossover(Chromosome,Chromosome)}. Performs the actual crossover.                
                <@param>
                    m first the first chromosome                    
                </@param>
                <@param>
                    m second the second chromosome                    
                </@param>
                <@return>
                    n the pair of new chromosomes that resulted from the crossover                    
                </@return>
                <@throws>
                    s DimensionMismatchException if the length of the two chromosomes is different                    
                </@throws>
            </javadoc>
            <method name="mate" type="ChromosomePair" line="121">
                <comment line="122">
                    array representations of the parents                    
                </comment>
                <comment line="122">
                    and of the children: do a crossover copy to simplify the later processing                    
                </comment>
                <comment line="122">
                    the set of all visited indices so far                    
                </comment>
                <comment line="122">
                    the indices of the current cycle                    
                </comment>
                <comment line="122">
                    determine the starting index                    
                </comment>
                <declaration name="length" type="int" line="123"/>
                <scope line="124"/>
                <declaration name="parent1Rep" type="List&lt;T&gt;" line="129"/>
                <declaration name="parent2Rep" type="List&lt;T&gt;" line="130"/>
                <declaration name="child1Rep" type="List&lt;T&gt;" line="132"/>
                <declaration name="child2Rep" type="List&lt;T&gt;" line="133"/>
                <declaration name="visitedIndices" type="Set&lt;Integer&gt;" line="136"/>
                <declaration name="indices" type="List&lt;Integer&gt;" line="138"/>
                <declaration name="idx" type="int" line="141"/>
                <declaration name="cycle" type="int" line="142"/>
                <scope line="144">
                    <declaration name="item" type="T" line="147"/>
                    <scope line="150"/>
                    <scope line="160">
                        <scope line="161">
                            <declaration name="tmp" type="T" line="162"/>
                        </scope>
                    </scope>
                    <scope line="171">
                        <scope line="173"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>