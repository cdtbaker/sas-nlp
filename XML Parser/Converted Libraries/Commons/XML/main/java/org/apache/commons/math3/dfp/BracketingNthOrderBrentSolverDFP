<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.dfp">
        <import package="org.apache.commons.math3.analysis.solvers.AllowedSolution"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.util.Incrementor"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="BracketingNthOrderBrentSolverDFP" line="28">
            <javadoc line="28">
                This class implements a modification of the &lt;a
                 * href=&quot;http://mathworld.wolfram.com/BrentsMethod.html&quot;&gt; Brent algorithm&lt;/a&gt;.
                 * &lt;p&gt;
                 * The changes with respect to the original Brent algorithm are:
                 * &lt;ul&gt;
                 * &lt;li&gt;the returned value is chosen in the current interval according
                 * to user specified {@link AllowedSolution},&lt;/li&gt;
                 * &lt;li&gt;the maximal order for the invert polynomial root search is
                 * user-specified instead of being invert quadratic only&lt;/li&gt;
                 * &lt;/ul&gt;
                 * &lt;/p&gt;
                 * The given interval must bracket the root.                
                <@version>
                    n $Id: BracketingNthOrderBrentSolverDFP.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
            </javadoc>
            <declaration name="MAXIMAL_AGING" type="int" line="46"/>
            <javadoc line="46">
                Maximal aging triggering an attempt to balance the bracketing interval.                
            </javadoc>
            <declaration name="maximalOrder" type="int" line="49"/>
            <javadoc line="49">
                Maximal order.                
            </javadoc>
            <declaration name="functionValueAccuracy" type="Dfp" line="52"/>
            <javadoc line="52">
                Function value accuracy.                
            </javadoc>
            <declaration name="absoluteAccuracy" type="Dfp" line="55"/>
            <javadoc line="55">
                Absolute accuracy.                
            </javadoc>
            <declaration name="relativeAccuracy" type="Dfp" line="58"/>
            <javadoc line="58">
                Relative accuracy.                
            </javadoc>
            <declaration name="evaluations" type="Incrementor" line="61"/>
            <javadoc line="61">
                Evaluations counter.                
            </javadoc>
            <javadoc line="64">
                Construct a solver.                
                <@param>
                    m relativeAccuracy Relative accuracy.                    
                </@param>
                <@param>
                    m absoluteAccuracy Absolute accuracy.                    
                </@param>
                <@param>
                    m functionValueAccuracy Function value accuracy.                    
                </@param>
                <@param>
                    m maximalOrder maximal order.                    
                </@param>
                <@exception>
                    n NumberIsTooSmallException if maximal order is lower than 2                    
                </@exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolverDFP" type="constructor" line="77">
                <scope line="78"/>
            </method>
            <javadoc line="87">
                Get the maximal order.                
                <@return>
                    n maximal order                    
                </@return>
            </javadoc>
            <method name="getMaximalOrder" type="int" line="90"/>
            <javadoc line="94">
                Get the maximal number of function evaluations.                
                <@return>
                    n the maximal number of function evaluations.                    
                </@return>
            </javadoc>
            <method name="getMaxEvaluations" type="int" line="99"/>
            <javadoc line="103">
                Get the number of evaluations of the objective function.
                 * The number of evaluations corresponds to the last call to the{@code optimize} method. It is 0 if the method has not been
                 * called yet.                
                <@return>
                    n the number of evaluations of the objective function.                    
                </@return>
            </javadoc>
            <method name="getEvaluations" type="int" line="111"/>
            <javadoc line="115">
                Get the absolute accuracy.                
                <@return>
                    n absolute accuracy                    
                </@return>
            </javadoc>
            <method name="getAbsoluteAccuracy" type="Dfp" line="119"/>
            <javadoc line="123">
                Get the relative accuracy.                
                <@return>
                    n relative accuracy                    
                </@return>
            </javadoc>
            <method name="getRelativeAccuracy" type="Dfp" line="127"/>
            <javadoc line="131">
                Get the function accuracy.                
                <@return>
                    n function accuracy                    
                </@return>
            </javadoc>
            <method name="getFunctionValueAccuracy" type="Dfp" line="135"/>
            <javadoc line="139">
                Solve for a zero in the given interval.
                 * A solver may require that the interval brackets a single zero root.
                 * Solvers that do require bracketing should be able to handle the case
                 * where one of the endpoints is itself a root.                
                <@param>
                    m maxEval Maximum number of evaluations.                    
                </@param>
                <@param>
                    m f Function to solve.                    
                </@param>
                <@param>
                    m min Lower bound for the interval.                    
                </@param>
                <@param>
                    m max Upper bound for the interval.                    
                </@param>
                <@param>
                    m allowedSolution The kind of solutions that the root-finding algorithm may
                     * accept as solutions.                    
                </@param>
                <@return>
                    n a value where the function is zero.                    
                </@return>
                <@exception>
                    n NullArgumentException if f is null.                    
                </@exception>
                <@exception>
                    n NoBracketingException if root cannot be bracketed                    
                </@exception>
            </javadoc>
            <method name="solve" type="Dfp" line="157"/>
            <javadoc line="161">
                Solve for a zero in the given interval, start at {@code startValue}.
                 * A solver may require that the interval brackets a single zero root.
                 * Solvers that do require bracketing should be able to handle the case
                 * where one of the endpoints is itself a root.                
                <@param>
                    m maxEval Maximum number of evaluations.                    
                </@param>
                <@param>
                    m f Function to solve.                    
                </@param>
                <@param>
                    m min Lower bound for the interval.                    
                </@param>
                <@param>
                    m max Upper bound for the interval.                    
                </@param>
                <@param>
                    m startValue Start value to use.                    
                </@param>
                <@param>
                    m allowedSolution The kind of solutions that the root-finding algorithm may
                     * accept as solutions.                    
                </@param>
                <@return>
                    n a value where the function is zero.                    
                </@return>
                <@exception>
                    n NullArgumentException if f is null.                    
                </@exception>
                <@exception>
                    n NoBracketingException if root cannot be bracketed                    
                </@exception>
            </javadoc>
            <method name="solve" type="Dfp" line="181">
                <comment line="182">
                    Checks.                    
                </comment>
                <comment line="182">
                    Reset.                    
                </comment>
                <comment line="182">
                    prepare arrays with the first points                    
                </comment>
                <comment line="182">
                    evaluate initial guess                    
                </comment>
                <comment line="182">
                    evaluate first  endpoint                    
                </comment>
                <comment line="182">
                    prepare a work array for inverse polynomial interpolation                    
                </comment>
                <comment line="182">
                    current tightest bracketing of the root                    
                </comment>
                <comment line="182">
                    search loop                    
                </comment>
                <declaration name="zero" type="Dfp" line="189"/>
                <declaration name="nan" type="Dfp" line="190"/>
                <declaration name="x" type="Dfp[]" line="193"/>
                <declaration name="y" type="Dfp[]" line="194"/>
                <scope line="202"/>
                <scope line="210"/>
                <declaration name="nbPoints" type="int" line="215"/>
                <declaration name="signChangeIndex" type="int" line="216"/>
                <scope line="217"/>
                <scope line="223">
                    <scope line="228"/>
                    <scope line="233"/>
                    <scope line="237"/>
                </scope>
                <declaration name="tmpX" type="Dfp[]" line="245"/>
                <declaration name="xA" type="Dfp" line="248"/>
                <declaration name="yA" type="Dfp" line="249"/>
                <declaration name="absXA" type="Dfp" line="250"/>
                <declaration name="absYA" type="Dfp" line="251"/>
                <declaration name="agingA" type="int" line="252"/>
                <declaration name="xB" type="Dfp" line="253"/>
                <declaration name="yB" type="Dfp" line="254"/>
                <declaration name="absXB" type="Dfp" line="255"/>
                <declaration name="absYB" type="Dfp" line="256"/>
                <declaration name="agingB" type="int" line="257"/>
                <scope line="260">
                    <declaration name="maxX" type="Dfp" line="263"/>
                    <declaration name="maxY" type="Dfp" line="264"/>
                    <declaration name="xTol" type="Dfp" line="265"/>
                    <scope line="267"/>
                    <declaration name="targetY" type="Dfp" line="286"/>
                    <scope line="287"/>
                    <scope line="290"/>
                    <scope line="293"/>
                    <declaration name="nextX" type="Dfp" line="299"/>
                    <declaration name="start" type="int" line="300"/>
                    <declaration name="end" type="int" line="301"/>
                    <scope line="302">
                        <scope line="308">
                            <scope line="314"/>
                            <scope line="317"/>
                        </scope>
                    </scope>
                    <scope line="329"/>
                    <declaration name="nextY" type="Dfp" line="338"/>
                    <scope line="339"/>
                    <scope line="345"/>
                    <scope line="354">
                        <scope line="360"/>
                    </scope>
                    <scope line="378"/>
                    <scope line="385"/>
                </scope>
            </method>
            <javadoc line="402">
                Guess an x value by n&lt;sup&gt;th&lt;/sup&gt; order inverse polynomial interpolation.
                 * &lt;p&gt;
                 * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
                 * is built such that for all considered points (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;),
                 * Q(y&lt;sub&gt;i&lt;/sub&gt;) = x&lt;sub&gt;i&lt;/sub&gt;.
                 * &lt;/p&gt;                
                <@param>
                    m targetY target value for y                    
                </@param>
                <@param>
                    m x reference points abscissas for interpolation,
                     * note that this array <em>is</em> modified during computation                    
                </@param>
                <@param>
                    m y reference points ordinates for interpolation                    
                </@param>
                <@param>
                    m start start index of the points to consider (inclusive)                    
                </@param>
                <@param>
                    m end end index of the points to consider (exclusive)                    
                </@param>
                <@return>
                    n guessed root (will be a NaN if two points share the same y)                    
                </@return>
            </javadoc>
            <method name="guessX" type="Dfp" line="417">
                <comment line="418">
                    compute Q Newton coefficients by divided differences                    
                </comment>
                <comment line="418">
                    evaluate Q(targetY)                    
                </comment>
                <scope line="420">
                    <declaration name="delta" type="int" line="421"/>
                    <scope line="422"/>
                </scope>
                <declaration name="x0" type="Dfp" line="428"/>
                <scope line="429"/>
            </method>
        </class>
    </source>