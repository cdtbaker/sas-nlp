<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.transform">
        <javadoc line="19">
            This enumeration defines the various types of normalizations that can be
              applied to discrete sine transforms (DST). The exact definition of these
              normalizations is detailed below.            
            <@see>
                e FastSineTransformer                
            </@see>
            <@version>
                n $Id: DstNormalization.java 1385310 2012-09-16 16:32:10Z tn $                
            </@version>
            <@since>
                e 3.0                
            </@since>
        </javadoc>
        <javadoc line="29">
            Should be passed to the constructor of {@link FastSineTransformer} to
              use the &lt;em&gt;standard&lt;/em&gt; normalization convention. The standard DST-I
              normalization convention is defined as follows
              &lt;ul&gt;
              &lt;li&gt;forward transform: y&lt;sub&gt;n&lt;/sub&gt; = &amp;sum;&lt;sub&gt;k=0&lt;/sub&gt;&lt;sup&gt;N-1&lt;/sup&gt;
              x&lt;sub&gt;k&lt;/sub&gt; sin(&amp;pi; nk / N),&lt;/li&gt;
              &lt;li&gt;inverse transform: x&lt;sub&gt;k&lt;/sub&gt; = (2 / N)
              &amp;sum;&lt;sub&gt;n=0&lt;/sub&gt;&lt;sup&gt;N-1&lt;/sup&gt; y&lt;sub&gt;n&lt;/sub&gt; sin(&amp;pi; nk / N),&lt;/li&gt;
              &lt;/ul&gt;
              where N is the size of the data sample, and x&lt;sub&gt;0&lt;/sub&gt; = 0.            
        </javadoc>
        <javadoc line="43">
            Should be passed to the constructor of {@link FastSineTransformer} to
              use the &lt;em&gt;orthogonal&lt;/em&gt; normalization convention. The orthogonal
              DCT-I normalization convention is defined as follows
              &lt;ul&gt;
              &lt;li&gt;Forward transform: y&lt;sub&gt;n&lt;/sub&gt; = &amp;radic;(2 / N)
              &amp;sum;&lt;sub&gt;k=0&lt;/sub&gt;&lt;sup&gt;N-1&lt;/sup&gt; x&lt;sub&gt;k&lt;/sub&gt; sin(&amp;pi; nk / N),&lt;/li&gt;
              &lt;li&gt;Inverse transform: x&lt;sub&gt;k&lt;/sub&gt; = &amp;radic;(2 / N)
              &amp;sum;&lt;sub&gt;n=0&lt;/sub&gt;&lt;sup&gt;N-1&lt;/sup&gt; y&lt;sub&gt;n&lt;/sub&gt; sin(&amp;pi; nk / N),&lt;/li&gt;
              &lt;/ul&gt;
              which makes the transform orthogonal. N is the size of the data sample,
              and x&lt;sub&gt;0&lt;/sub&gt; = 0.            
        </javadoc>
    </source>