<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.solvers">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="UnivariateSolverUtils" line="27">
            <javadoc line="27">
                Utility routines for {@link UnivariateSolver} objects.                
                <@version>
                    n $Id: UnivariateSolverUtils.java 1400850 2012-10-22 11:57:17Z erans $                    
                </@version>
            </javadoc>
            <javadoc line="33">
                Class contains only static methods.                
            </javadoc>
            <method name="UnivariateSolverUtils" type="constructor" line="36"/>
            <javadoc line="38">
                Convenience method to find a zero of a univariate real function.  A default
                 * solver is used.                
                <@param>
                    m function Function.                    
                </@param>
                <@param>
                    m x0 Lower bound for the interval.                    
                </@param>
                <@param>
                    m x1 Upper bound for the interval.                    
                </@param>
                <@return>
                    n a value where the function is zero.                    
                </@return>
                <@throws>
                    s NoBracketingException if the function has the same sign at the
                     * endpoints.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code function} is {@code null}.                    
                </@throws>
            </javadoc>
            <method name="solve" type="double" line="52">
                <scope line="53"/>
                <declaration name="solver" type="UnivariateSolver" line="56"/>
            </method>
            <javadoc line="60">
                Convenience method to find a zero of a univariate real function.  A default
                 * solver is used.                
                <@param>
                    m function Function.                    
                </@param>
                <@param>
                    m x0 Lower bound for the interval.                    
                </@param>
                <@param>
                    m x1 Upper bound for the interval.                    
                </@param>
                <@param>
                    m absoluteAccuracy Accuracy to be used by the solver.                    
                </@param>
                <@return>
                    n a value where the function is zero.                    
                </@return>
                <@throws>
                    s NoBracketingException if the function has the same sign at the
                     * endpoints.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code function} is {@code null}.                    
                </@throws>
            </javadoc>
            <method name="solve" type="double" line="77">
                <scope line="78"/>
                <declaration name="solver" type="UnivariateSolver" line="81"/>
            </method>
            <javadoc line="85">
                Force a root found by a non-bracketing solver to lie on a specified side,
                 * as if the solver was a bracketing one.                
                <@param>
                    m maxEval maximal number of new evaluations of the function
                     * (evaluations already done for finding the root should have already been subtracted
                     * from this number)                    
                </@param>
                <@param>
                    m f function to solve                    
                </@param>
                <@param>
                    m bracketing bracketing solver to use for shifting the root                    
                </@param>
                <@param>
                    m baseRoot original root found by a previous non-bracketing solver                    
                </@param>
                <@param>
                    m min minimal bound of the search interval                    
                </@param>
                <@param>
                    m max maximal bound of the search interval                    
                </@param>
                <@param>
                    m allowedSolution the kind of solutions that the root-finding algorithm may
                     * accept as solutions.                    
                </@param>
                <@return>
                    n a root approximation, on the specified side of the exact root                    
                </@return>
                <@throws>
                    s NoBracketingException if the function has the same sign at the
                     * endpoints.                    
                </@throws>
            </javadoc>
            <method name="forceSide" type="double" line="105">
                <comment line="106">
                    find a very small interval bracketing the root                    
                </comment>
                <scope line="107"/>
                <declaration name="step" type="double" line="113"/>
                <declaration name="xLo" type="double" line="115"/>
                <declaration name="fLo" type="double" line="116"/>
                <declaration name="xHi" type="double" line="117"/>
                <declaration name="fHi" type="double" line="118"/>
                <declaration name="remainingEval" type="int" line="119"/>
                <scope line="120">
                    <scope line="122"/>
                    <declaration name="changeLo" type="boolean" line="128"/>
                    <declaration name="changeHi" type="boolean" line="129"/>
                    <scope line="130">
                        <scope line="132"/>
                        <scope line="134"/>
                    </scope>
                    <scope line="137">
                        <scope line="139"/>
                        <scope line="141"/>
                    </scope>
                    <scope line="144"/>
                    <scope line="151"/>
                    <scope line="158"/>
                </scope>
            </method>
            <javadoc line="173">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                 * &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
                 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt; 0 &lt;/code&gt;&lt;/li&gt;
                 * &lt;/ul&gt;
                 * If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
                 * and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
                 * &lt;p&gt;
                 * The algorithm starts by setting
                 * &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
                 * function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
                 * the endpoints out by one unit each time through a loop that terminates
                 * when one of the following happens: &lt;ul&gt;
                 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt; 0 &lt;/code&gt; --  success!&lt;/li&gt;
                 * &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
                 * -- NoBracketingException &lt;/li&gt;
                 * &lt;li&gt; &lt;code&gt; Integer.MAX_VALUE&lt;/code&gt; iterations elapse
                 * -- NoBracketingException &lt;/li&gt;
                 * &lt;/ul&gt;&lt;/p&gt;
                 * &lt;p&gt;
                 * &lt;strong&gt;Note: &lt;/strong&gt; this method can take
                 * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; iterations to throw a
                 * &lt;code&gt;ConvergenceException.&lt;/code&gt;  Unless you are confident that there
                 * is a root between &lt;code&gt;lowerBound&lt;/code&gt; and &lt;code&gt;upperBound&lt;/code&gt;
                 * near &lt;code&gt;initial,&lt;/code&gt; it is better to use{@link #bracket(UnivariateFunction,double,double,double,int)},
                 * explicitly specifying the maximum number of iterations.&lt;/p&gt;                
                <@param>
                    m function Function.                    
                </@param>
                <@param>
                    m initial Initial midpoint of interval being expanded to
                     * bracket a root.                    
                </@param>
                <@param>
                    m lowerBound Lower bound (a is never lower than this value)                    
                </@param>
                <@param>
                    m upperBound Upper bound (b never is greater than this
                     * value).                    
                </@param>
                <@return>
                    n a two-element array holding a and b.                    
                </@return>
                <@throws>
                    s NoBracketingException if a root cannot be bracketted.                    
                </@throws>
                <@throws>
                    s NotStrictlyPositiveException if {@code maximumIterations <= 0}.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code function} is {@code null}.                    
                </@throws>
            </javadoc>
            <method name="bracket" type="double[]" line="217"/>
            <javadoc line="221">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                 * &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
                 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt;= 0 &lt;/code&gt; &lt;/li&gt;
                 * &lt;/ul&gt;
                 * If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
                 * and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
                 * &lt;p&gt;
                 * The algorithm starts by setting
                 * &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
                 * function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
                 * the endpoints out by one unit each time through a loop that terminates
                 * when one of the following happens: &lt;ul&gt;
                 * &lt;li&gt; &lt;code&gt; f(a) * f(b) &lt;= 0 &lt;/code&gt; --  success!&lt;/li&gt;
                 * &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
                 * -- NoBracketingException &lt;/li&gt;
                 * &lt;li&gt; &lt;code&gt; maximumIterations&lt;/code&gt; iterations elapse
                 * -- NoBracketingException &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;                
                <@param>
                    m function Function.                    
                </@param>
                <@param>
                    m initial Initial midpoint of interval being expanded to
                     * bracket a root.                    
                </@param>
                <@param>
                    m lowerBound Lower bound (a is never lower than this value).                    
                </@param>
                <@param>
                    m upperBound Upper bound (b never is greater than this
                     * value).                    
                </@param>
                <@param>
                    m maximumIterations Maximum number of iterations to perform                    
                </@param>
                <@return>
                    n a two element array holding a and b.                    
                </@return>
                <@throws>
                    s NoBracketingException if the algorithm fails to find a and b
                     * satisfying the desired conditions.                    
                </@throws>
                <@throws>
                    s NotStrictlyPositiveException if {@code maximumIterations <= 0}.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code function} is {@code null}.                    
                </@throws>
            </javadoc>
            <method name="bracket" type="double[]" line="259">
                <scope line="260"/>
                <scope line="263"/>
                <declaration name="a" type="double" line="268"/>
                <declaration name="b" type="double" line="269"/>
                <declaration name="fa" type="double" line="270"/>
                <declaration name="fb" type="double" line="271"/>
                <declaration name="numIterations" type="int" line="272"/>
                <scope line="274"/>
                <scope line="284"/>
            </method>
            <javadoc line="294">
                Compute the midpoint of two values.                
                <@param>
                    m a first value.                    
                </@param>
                <@param>
                    m b second value.                    
                </@param>
                <@return>
                    n the midpoint.                    
                </@return>
            </javadoc>
            <method name="midpoint" type="double" line="301"/>
            <javadoc line="305">
                Check whether the interval bounds bracket a root. That is, if the
                 * values at the endpoints are not equal to zero, then the function takes
                 * opposite signs at the endpoints.                
                <@param>
                    m function Function.                    
                </@param>
                <@param>
                    m lower Lower endpoint.                    
                </@param>
                <@param>
                    m upper Upper endpoint.                    
                </@param>
                <@return>
                    n {@code true} if the function values have opposite signs at the
                     * given points.                    
                </@return>
                <@throws>
                    s NullArgumentException if {@code function} is {@code null}.                    
                </@throws>
            </javadoc>
            <method name="isBracketing" type="boolean" line="320">
                <scope line="321"/>
                <declaration name="fLo" type="double" line="324"/>
                <declaration name="fHi" type="double" line="325"/>
            </method>
            <javadoc line="329">
                Check whether the arguments form a (strictly) increasing sequence.                
                <@param>
                    m start First number.                    
                </@param>
                <@param>
                    m mid Second number.                    
                </@param>
                <@param>
                    m end Third number.                    
                </@param>
                <@return>
                    n {@code true} if the arguments form an increasing sequence.                    
                </@return>
            </javadoc>
            <method name="isSequence" type="boolean" line="339"/>
            <javadoc line="343">
                Check that the endpoints specify an interval.                
                <@param>
                    m lower Lower endpoint.                    
                </@param>
                <@param>
                    m upper Upper endpoint.                    
                </@param>
                <@throws>
                    s NumberIsTooLargeException if {@code lower >= upper}.                    
                </@throws>
            </javadoc>
            <method name="verifyInterval" type="void" line="352">
                <scope line="353"/>
            </method>
            <javadoc line="359">
                Check that {@code lower &lt; initial &lt; upper}.                
                <@param>
                    m lower Lower endpoint.                    
                </@param>
                <@param>
                    m initial Initial value.                    
                </@param>
                <@param>
                    m upper Upper endpoint.                    
                </@param>
                <@throws>
                    s NumberIsTooLargeException if {@code lower >= initial} or{@code initial >= upper}.                    
                </@throws>
            </javadoc>
            <method name="verifySequence" type="void" line="371"/>
            <javadoc line="376">
                Check that the endpoints specify an interval and the end points
                 * bracket a root.                
                <@param>
                    m function Function.                    
                </@param>
                <@param>
                    m lower Lower endpoint.                    
                </@param>
                <@param>
                    m upper Upper endpoint.                    
                </@param>
                <@throws>
                    s NoBracketingException if the function has the same sign at the
                     * endpoints.                    
                </@throws>
                <@throws>
                    s NullArgumentException if {@code function} is {@code null}.                    
                </@throws>
            </javadoc>
            <method name="verifyBracketing" type="void" line="391">
                <scope line="392"/>
                <scope line="396"/>
            </method>
        </class>
    </source>