<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.ode.nonstiff">
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MaxCountExceededException"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.linear.Array2DRowRealMatrix"/>
        <import package="org.apache.commons.math3.ode.EquationsMapper"/>
        <import package="org.apache.commons.math3.ode.ExpandableStatefulODE"/>
        <import package="org.apache.commons.math3.ode.sampling.NordsieckStepInterpolator"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="AdamsBashforthIntegrator" line="31">
            <extends class="AdamsIntegrator"/>
            <javadoc line="31">
                This class implements explicit Adams-Bashforth integrators for Ordinary
                  Differential Equations.
                  &lt;p&gt;Adams-Bashforth methods (in fact due to Adams alone) are explicit
                  multistep ODE solvers. This implementation is a variation of the classical
                  one: it uses adaptive stepsize to implement error control, whereas
                  classical implementations are fixed step size. The value of state vector
                  at step n+1 is a simple combination of the value at step n and of the
                  derivatives at steps n, n-1, n-2 ... Depending on the number k of previous
                  steps one wants to use for computing the next value, different formulas
                  are available:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;k = 1: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h y&apos;&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
                  &lt;li&gt;k = 2: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (3y&apos;&lt;sub&gt;n&lt;/sub&gt;-y&apos;&lt;sub&gt;n-1&lt;/sub&gt;)/2&lt;/li&gt;
                  &lt;li&gt;k = 3: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (23y&apos;&lt;sub&gt;n&lt;/sub&gt;-16y&apos;&lt;sub&gt;n-1&lt;/sub&gt;+5y&apos;&lt;sub&gt;n-2&lt;/sub&gt;)/12&lt;/li&gt;
                  &lt;li&gt;k = 4: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + h (55y&apos;&lt;sub&gt;n&lt;/sub&gt;-59y&apos;&lt;sub&gt;n-1&lt;/sub&gt;+37y&apos;&lt;sub&gt;n-2&lt;/sub&gt;-9y&apos;&lt;sub&gt;n-3&lt;/sub&gt;)/24&lt;/li&gt;
                  &lt;li&gt;...&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;A k-steps Adams-Bashforth method is of order k.&lt;/p&gt;
                  &lt;h3&gt;Implementation details&lt;/h3&gt;
                  &lt;p&gt;We define scaled derivatives s&lt;sub&gt;i&lt;/sub&gt;(n) at step n as:
                  &lt;pre&gt;
                  s&lt;sub&gt;1&lt;/sub&gt;(n) = h y&apos;&lt;sub&gt;n&lt;/sub&gt; for first derivative
                  s&lt;sub&gt;2&lt;/sub&gt;(n) = h&lt;sup&gt;2&lt;/sup&gt;/2 y&apos;&apos;&lt;sub&gt;n&lt;/sub&gt; for second derivative
                  s&lt;sub&gt;3&lt;/sub&gt;(n) = h&lt;sup&gt;3&lt;/sup&gt;/6 y&apos;&apos;&apos;&lt;sub&gt;n&lt;/sub&gt; for third derivative
                  ...
                  s&lt;sub&gt;k&lt;/sub&gt;(n) = h&lt;sup&gt;k&lt;/sup&gt;/k! y&lt;sup&gt;(k)&lt;/sup&gt;&lt;sub&gt;n&lt;/sub&gt; for k&lt;sup&gt;th&lt;/sup&gt; derivative
                  &lt;/pre&gt;&lt;/p&gt;
                  &lt;p&gt;The definitions above use the classical representation with several previous first
                  derivatives. Lets define
                  &lt;pre&gt;
                  q&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;1&lt;/sub&gt;(n-1) s&lt;sub&gt;1&lt;/sub&gt;(n-2) ... s&lt;sub&gt;1&lt;/sub&gt;(n-(k-1)) ]&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/pre&gt;
                  (we omit the k index in the notation for clarity). With these definitions,
                  Adams-Bashforth methods can be written:
                  &lt;ul&gt;
                  &lt;li&gt;k = 1: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n)&lt;/li&gt;
                  &lt;li&gt;k = 2: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 3/2 s&lt;sub&gt;1&lt;/sub&gt;(n) + [ -1/2 ] q&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
                  &lt;li&gt;k = 3: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 23/12 s&lt;sub&gt;1&lt;/sub&gt;(n) + [ -16/12 5/12 ] q&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
                  &lt;li&gt;k = 4: y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + 55/24 s&lt;sub&gt;1&lt;/sub&gt;(n) + [ -59/24 37/24 -9/24 ] q&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
                  &lt;li&gt;...&lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;
                  &lt;p&gt;Instead of using the classical representation with first derivatives only (y&lt;sub&gt;n&lt;/sub&gt;,
                  s&lt;sub&gt;1&lt;/sub&gt;(n) and q&lt;sub&gt;n&lt;/sub&gt;), our implementation uses the Nordsieck vector with
                  higher degrees scaled derivatives all taken at the same step (y&lt;sub&gt;n&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;(n)
                  and r&lt;sub&gt;n&lt;/sub&gt;) where r&lt;sub&gt;n&lt;/sub&gt; is defined as:
                  &lt;pre&gt;
                  r&lt;sub&gt;n&lt;/sub&gt; = [ s&lt;sub&gt;2&lt;/sub&gt;(n), s&lt;sub&gt;3&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n) ]&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/pre&gt;
                  (here again we omit the k index in the notation for clarity)
                  &lt;/p&gt;
                  &lt;p&gt;Taylor series formulas show that for any index offset i, s&lt;sub&gt;1&lt;/sub&gt;(n-i) can be
                  computed from s&lt;sub&gt;1&lt;/sub&gt;(n), s&lt;sub&gt;2&lt;/sub&gt;(n) ... s&lt;sub&gt;k&lt;/sub&gt;(n), the formula being exact
                  for degree k polynomials.
                  &lt;pre&gt;
                  s&lt;sub&gt;1&lt;/sub&gt;(n-i) = s&lt;sub&gt;1&lt;/sub&gt;(n) + &amp;sum;&lt;sub&gt;j&lt;/sub&gt; j (-i)&lt;sup&gt;j-1&lt;/sup&gt; s&lt;sub&gt;j&lt;/sub&gt;(n)
                  &lt;/pre&gt;
                  The previous formula can be used with several values for i to compute the transform between
                  classical representation and Nordsieck vector. The transform between r&lt;sub&gt;n&lt;/sub&gt;
                  and q&lt;sub&gt;n&lt;/sub&gt; resulting from the Taylor series formulas above is:
                  &lt;pre&gt;
                  q&lt;sub&gt;n&lt;/sub&gt; = s&lt;sub&gt;1&lt;/sub&gt;(n) u + P r&lt;sub&gt;n&lt;/sub&gt;
                  &lt;/pre&gt;
                  where u is the [ 1 1 ... 1 ]&lt;sup&gt;T&lt;/sup&gt; vector and P is the (k-1)&amp;times;(k-1) matrix built
                  with the j (-i)&lt;sup&gt;j-1&lt;/sup&gt; terms:
                  &lt;pre&gt;
                  [  -2   3   -4    5  ... ]
                  [  -4  12  -32   80  ... ]
                  P =  [  -6  27 -108  405  ... ]
                  [  -8  48 -256 1280  ... ]
                  [          ...           ]
                  &lt;/pre&gt;&lt;/p&gt;
                  &lt;p&gt;Using the Nordsieck vector has several advantages:
                  &lt;ul&gt;
                  &lt;li&gt;it greatly simplifies step interpolation as the interpolator mainly applies
                  Taylor series formulas,&lt;/li&gt;
                  &lt;li&gt;it simplifies step changes that occur when discrete events that truncate
                  the step are triggered,&lt;/li&gt;
                  &lt;li&gt;it allows to extend the methods in order to support adaptive stepsize.&lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;
                  &lt;p&gt;The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:
                  &lt;ul&gt;
                  &lt;li&gt;y&lt;sub&gt;n+1&lt;/sub&gt; = y&lt;sub&gt;n&lt;/sub&gt; + s&lt;sub&gt;1&lt;/sub&gt;(n) + u&lt;sup&gt;T&lt;/sup&gt; r&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
                  &lt;li&gt;s&lt;sub&gt;1&lt;/sub&gt;(n+1) = h f(t&lt;sub&gt;n+1&lt;/sub&gt;, y&lt;sub&gt;n+1&lt;/sub&gt;)&lt;/li&gt;
                  &lt;li&gt;r&lt;sub&gt;n+1&lt;/sub&gt; = (s&lt;sub&gt;1&lt;/sub&gt;(n) - s&lt;sub&gt;1&lt;/sub&gt;(n+1)) P&lt;sup&gt;-1&lt;/sup&gt; u + P&lt;sup&gt;-1&lt;/sup&gt; A P r&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  where A is a rows shifting matrix (the lower left part is an identity matrix):
                  &lt;pre&gt;
                  [ 0 0   ...  0 0 | 0 ]
                  [ ---------------+---]
                  [ 1 0   ...  0 0 | 0 ]
                  A = [ 0 1   ...  0 0 | 0 ]
                  [       ...      | 0 ]
                  [ 0 0   ...  1 0 | 0 ]
                  [ 0 0   ...  0 1 | 0 ]
                  &lt;/pre&gt;&lt;/p&gt;
                  &lt;p&gt;The P&lt;sup&gt;-1&lt;/sup&gt;u vector and the P&lt;sup&gt;-1&lt;/sup&gt; A P matrix do not depend on the state,
                  they only depend on k and therefore are precomputed once for all.&lt;/p&gt;                
                <@version>
                    n $Id: AdamsBashforthIntegrator.java 1463684 2013-04-02 19:04:13Z luc $                    
                </@version>
                <@since>
                    e 2.0                    
                </@since>
            </javadoc>
            <declaration name="METHOD_NAME" type="String" line="145"/>
            <javadoc line="145">
                Integrator method name.                
            </javadoc>
            <javadoc line="148">
                Build an Adams-Bashforth integrator with the given order and step control parameters.                
                <@param>
                    m nSteps number of steps of the method excluding the one being computed                    
                </@param>
                <@param>
                    m minStep minimal step (sign is irrelevant, regardless of
                      integration direction, forward or backward), the last step can
                      be smaller than this                    
                </@param>
                <@param>
                    m maxStep maximal step (sign is irrelevant, regardless of
                      integration direction, forward or backward), the last step can
                      be smaller than this                    
                </@param>
                <@param>
                    m scalAbsoluteTolerance allowed absolute error                    
                </@param>
                <@param>
                    m scalRelativeTolerance allowed relative error                    
                </@param>
                <@exception>
                    n NumberIsTooSmallException if order is 1 or less                    
                </@exception>
            </javadoc>
            <method name="AdamsBashforthIntegrator" type="constructor" line="165">
                <params>
                    <param name="nSteps" type="int"/>
                    <param name="minStep" type="double"/>
                    <param name="maxStep" type="double"/>
                    <param name="scalAbsoluteTolerance" type="double"/>
                    <param name="scalRelativeTolerance" type="double"/>
                </params>
            </method>
            <javadoc line="170">
                Build an Adams-Bashforth integrator with the given order and step control parameters.                
                <@param>
                    m nSteps number of steps of the method excluding the one being computed                    
                </@param>
                <@param>
                    m minStep minimal step (sign is irrelevant, regardless of
                      integration direction, forward or backward), the last step can
                      be smaller than this                    
                </@param>
                <@param>
                    m maxStep maximal step (sign is irrelevant, regardless of
                      integration direction, forward or backward), the last step can
                      be smaller than this                    
                </@param>
                <@param>
                    m vecAbsoluteTolerance allowed absolute error                    
                </@param>
                <@param>
                    m vecRelativeTolerance allowed relative error                    
                </@param>
                <@exception>
                    n IllegalArgumentException if order is 1 or less                    
                </@exception>
            </javadoc>
            <method name="AdamsBashforthIntegrator" type="constructor" line="187">
                <params>
                    <param name="nSteps" type="int"/>
                    <param name="minStep" type="double"/>
                    <param name="maxStep" type="double"/>
                    <param name="vecAbsoluteTolerance" type="double[]"/>
                    <param name="vecRelativeTolerance" type="double[]"/>
                </params>
            </method>
            <javadoc line="192">
                {@inheritDoc}                
            </javadoc>
            <method name="integrate" type="void" line="196">
                <params>
                    <param name="equations" type="ExpandableStatefulODE"/>
                    <param name="t" type="double"/>
                </params>
                <comment line="197">
                    initialize working arrays                    
                </comment>
                <comment line="197">
                    set up an interpolator sharing the integrator arrays                    
                </comment>
                <comment line="197">
                    set up integration control objects                    
                </comment>
                <comment line="197">
                    compute the initial Nordsieck vector using the configured starter integrator                    
                </comment>
                <comment line="197">
                    reuse the step that was chosen by the starter integrator                    
                </comment>
                <comment line="197">
                    main integration loop                    
                </comment>
                <comment line="197">
                    dispatch results                    
                </comment>
                <declaration name="forward" type="boolean" line="200"/>
                <declaration name="y0" type="double[]" line="203"/>
                <declaration name="y" type="double[]" line="204"/>
                <declaration name="yDot" type="double[]" line="205"/>
                <declaration name="interpolator" type="NordsieckStepInterpolator" line="208"/>
                <declaration name="lastRow" type="int" line="219"/>
                <declaration name="hNew" type="double" line="222"/>
                <scope line="227">
                    <declaration name="error" type="double" line="229"/>
                    <scope line="230">
                        <scope line="236">
                            <declaration name="yScale" type="double" line="237"/>
                            <declaration name="tol" type="double" line="238"/>
                            <declaration name="ratio" type="double" line="241"/>
                        </scope>
                        <scope line="246">
                            <declaration name="factor" type="double" line="248"/>
                        </scope>
                    </scope>
                    <declaration name="stepEnd" type="double" line="256"/>
                    <declaration name="expandable" type="ExpandableStatefulODE" line="259"/>
                    <declaration name="primary" type="EquationsMapper" line="260"/>
                    <declaration name="index" type="int" line="262"/>
                    <scope line="263"/>
                    <declaration name="predictedScaled" type="double[]" line="272"/>
                    <scope line="273"/>
                    <declaration name="nordsieckTmp" type="Array2DRowRealMatrix" line="276"/>
                    <scope line="287">
                        <scope line="292"/>
                        <declaration name="factor" type="double" line="300"/>
                        <declaration name="scaledH" type="double" line="301"/>
                        <declaration name="nextT" type="double" line="302"/>
                        <declaration name="nextIsLast" type="boolean" line="303"/>
                        <declaration name="filteredNextT" type="double" line="306"/>
                        <declaration name="filteredNextIsLast" type="boolean" line="307"/>
                        <scope line="308"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>