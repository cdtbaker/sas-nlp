<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar.gradient">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.analysis.solvers.BrentSolver"/>
        <import package="org.apache.commons.math3.analysis.solvers.UnivariateSolver"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.TooManyEvaluationsException"/>
        <import package="org.apache.commons.math3.exception.MathUnsupportedOperationException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optim.OptimizationData"/>
        <import package="org.apache.commons.math3.optim.PointValuePair"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="NonLinearConjugateGradientOptimizer" extends="GradientMultivariateOptimizer" line="35">
            <javadoc line="35">
                Non-linear conjugate gradient optimizer.
                 * &lt;br/&gt;
                 * This class supports both the Fletcher-Reeves and the Polak-Ribière
                 * update formulas for the conjugate search directions.
                 * It also supports optional preconditioning.
                 * &lt;br/&gt;
                 * Constraints are not supported: the call to{@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.                
                <@version>
                    n $Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $                    
                </@version>
                <@since>
                    e 2.0                    
                </@since>
            </javadoc>
            <declaration name="updateFormula" type="Formula" line="51"/>
            <javadoc line="51">
                Update formula for the beta parameter.                
            </javadoc>
            <declaration name="preconditioner" type="Preconditioner" line="53"/>
            <javadoc line="53">
                Preconditioner (may be null).                
            </javadoc>
            <declaration name="solver" type="UnivariateSolver" line="55"/>
            <javadoc line="55">
                solver to use in the line search (may be null).                
            </javadoc>
            <declaration name="initialStep" type="double" line="57"/>
            <javadoc line="57">
                Initial step used to bracket the optimum in line search.                
            </javadoc>
            <javadoc line="60">
                Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.                
                <@param>
                    m updateFormula formula to use for updating the &beta; parameter,
                     * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </@param>
                <@param>
                    m checker Convergence checker.                    
                </@param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="70"/>
            <javadoc line="77">
                Available choices of update formulas for the updating the parameter
                 * that is used to compute the successive conjugate search directions.
                 * For non-linear conjugate gradients, there are
                 * two formulas:
                 * &lt;ul&gt;
                 * &lt;li&gt;Fletcher-Reeves formula&lt;/li&gt;
                 * &lt;li&gt;Polak-Ribière formula&lt;/li&gt;
                 * &lt;/ul&gt;
                 * On the one hand, the Fletcher-Reeves formula is guaranteed to converge
                 * if the start point is close enough of the optimum whether the
                 * Polak-Ribière formula may not converge in rare cases. On the
                 * other hand, the Polak-Ribière formula is often faster when it
                 * does converge. Polak-Ribière is often used.                
                <@since>
                    e 2.0                    
                </@since>
            </javadoc>
            <javadoc line="96">
                Fletcher-Reeves formula.                
            </javadoc>
            <javadoc line="98">
                Polak-Ribière formula.                
            </javadoc>
            <class name="BracketingStep" line="102">
                <implements interface="OptimizationData"/>
                <javadoc line="102">
                    The initial step is a factor with respect to the search direction
                     * (which itself is roughly related to the gradient of the function).
                     * &lt;br/&gt;
                     * It is used to find an interval that brackets the optimum in line
                     * search.                    
                    <@since>
                        e 3.1                        
                    </@since>
                </javadoc>
                <declaration name="initialStep" type="double" line="112"/>
                <javadoc line="112">
                    Initial step.                    
                </javadoc>
                <javadoc line="115">
                    @param step Initial step for the bracket search.                    
                </javadoc>
                <method name="BracketingStep" type="constructor" line="118"/>
                <javadoc line="122">
                    Gets the initial step.                    
                    <@return>
                        n the initial step.                        
                    </@return>
                </javadoc>
                <method name="getBracketingStep" type="double" line="127"/>
            </class>
            <javadoc line="132">
                Constructor with default {@link IdentityPreconditioner preconditioner}.                
                <@param>
                    m updateFormula formula to use for updating the &beta; parameter,
                     * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </@param>
                <@param>
                    m checker Convergence checker.                    
                </@param>
                <@param>
                    m lineSearchSolver Solver to use during line search.                    
                </@param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="143"/>
            <javadoc line="150">
                @param updateFormula formula to use for updating the &amp;beta; parameter,
                 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                
                <@param>
                    m checker Convergence checker.                    
                </@param>
                <@param>
                    m lineSearchSolver Solver to use during line search.                    
                </@param>
                <@param>
                    m preconditioner Preconditioner.                    
                </@param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="161"/>
            <javadoc line="170">
                {@inheritDoc}                
                <@param>
                    m optData Optimization data. In addition to those documented in{@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])GradientMultivariateOptimizer}, this method will register the following data:
                     * <ul>
                     * <li>{@link BracketingStep}</li>
                     * </ul>                    
                </@param>
                <@return>
                    n {@inheritDoc}                    
                </@return>
                <@throws>
                    s TooManyEvaluationsException if the maximal number of
                     * evaluations (of the objective function) is exceeded.                    
                </@throws>
            </javadoc>
            <method name="optimize" type="PointValuePair" line="185">
                <comment line="186">
                    Set up base class and perform computation.                    
                </comment>
            </method>
            <javadoc line="190">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="192">
                <comment line="193">
                    Initial search direction.                    
                </comment>
                <declaration name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;" line="193"/>
                <declaration name="point" type="double[]" line="194"/>
                <declaration name="goal" type="GoalType" line="195"/>
                <declaration name="n" type="int" line="196"/>
                <declaration name="r" type="double[]" line="197"/>
                <scope line="198">
                    <scope line="199"/>
                </scope>
                <declaration name="steepestDescent" type="double[]" line="205"/>
                <declaration name="searchDirection" type="double[]" line="206"/>
                <declaration name="delta" type="double" line="208"/>
                <scope line="209"/>
                <declaration name="current" type="PointValuePair" line="213"/>
                <declaration name="maxEval" type="int" line="214"/>
                <scope line="215">
                    <declaration name="objective" type="double" line="218"/>
                    <declaration name="previous" type="PointValuePair" line="219"/>
                    <scope line="221"/>
                    <declaration name="lsf" type="UnivariateFunction" line="227"/>
                    <declaration name="uB" type="double" line="228"/>
                    <declaration name="step" type="double" line="232"/>
                    <scope line="236"/>
                    <scope line="241">
                        <scope line="242"/>
                    </scope>
                    <declaration name="deltaOld" type="double" line="248"/>
                    <declaration name="newSteepestDescent" type="double[]" line="249"/>
                    <scope line="251"/>
                    <declaration name="beta" type="double" line="255"/>
                    <declaration name="deltaMid" type="double" line="261"/>
                    <scope line="262"/>
                    <scope line="275"/>
                    <scope line="278">
                        <scope line="280"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="287">
                Scans the list of (required and optional) optimization data that
                 * characterize the problem.                
                <@param>
                    m optData Optimization data.
                     * The following data will be looked for:
                     * <ul>
                     * <li>{@link BracketingStep}</li>
                     * </ul>                    
                </@param>
            </javadoc>
            <method name="parseOptimizationData" type="void" line="298">
                <comment line="299">
                    Allow base class to register its own data.                    
                </comment>
                <comment line="299">
                    The existing values (as set by the previous call) are reused if                    
                </comment>
                <comment line="299">
                    not provided in the argument list.                    
                </comment>
                <scope line="304">
                    <scope line="305"/>
                </scope>
            </method>
            <javadoc line="316">
                Finds the upper bound b ensuring bracketing of a root between a and b.                
                <@param>
                    m f function whose root must be bracketed.                    
                </@param>
                <@param>
                    m a lower bound of the interval.                    
                </@param>
                <@param>
                    m h initial step to try.                    
                </@param>
                <@return>
                    n b such that f(a) and f(b) have opposite signs.                    
                </@return>
                <@throws>
                    s MathIllegalStateException if no bracket can be found.                    
                </@throws>
            </javadoc>
            <method name="findUpperBound" type="double" line="326">
                <declaration name="yA" type="double" line="327"/>
                <declaration name="yB" type="double" line="328"/>
                <scope line="329">
                    <declaration name="b" type="double" line="330"/>
                    <scope line="332"/>
                </scope>
            </method>
            <class name="IdentityPreconditioner" line="339">
                <implements interface="Preconditioner"/>
                <javadoc line="339">
                    Default identity preconditioner.                    
                </javadoc>
                <javadoc line="341">
                    {@inheritDoc}                    
                </javadoc>
                <method name="precondition" type="double[]" line="342"/>
            </class>
            <class name="LineSearchFunction" line="347">
                <implements interface="UnivariateFunction"/>
                <javadoc line="347">
                    Internal class for line search.
                     * &lt;p&gt;
                     * The function represented by this class is the dot product of
                     * the objective function gradient and the search direction. Its
                     * value is zero when the gradient is orthogonal to the search
                     * direction, i.e. when the objective function value is a local
                     * extremum along the search direction.
                     * &lt;/p&gt;                    
                </javadoc>
                <declaration name="currentPoint" type="double[]" line="358"/>
                <javadoc line="358">
                    Current point.                    
                </javadoc>
                <declaration name="searchDirection" type="double[]" line="360"/>
                <javadoc line="360">
                    Search direction.                    
                </javadoc>
                <javadoc line="363">
                    @param point Current point.                    
                    <@param>
                        m direction Search direction.                        
                    </@param>
                </javadoc>
                <method name="LineSearchFunction" type="constructor" line="368"/>
                <javadoc line="373">
                    {@inheritDoc}                    
                </javadoc>
                <method name="value" type="double" line="374">
                    <comment line="375">
                        current point in the search direction                        
                    </comment>
                    <comment line="375">
                        gradient of the objective function                        
                    </comment>
                    <comment line="375">
                        dot product with the search direction                        
                    </comment>
                    <declaration name="shiftedPoint" type="double[]" line="376"/>
                    <scope line="377"/>
                    <declaration name="gradient" type="double[]" line="382"/>
                    <declaration name="dotProduct" type="double" line="385"/>
                    <scope line="386"/>
                </method>
            </class>
            <javadoc line="394">
                @throws MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.                
            </javadoc>
            <method name="checkParameters" type="void" line="398">
                <scope line="400"/>
            </method>
        </class>
    </source>