<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar.noderiv">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.NotPositiveException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.OutOfRangeException"/>
        <import package="org.apache.commons.math3.exception.TooManyEvaluationsException"/>
        <import package="org.apache.commons.math3.linear.Array2DRowRealMatrix"/>
        <import package="org.apache.commons.math3.linear.EigenDecomposition"/>
        <import package="org.apache.commons.math3.linear.MatrixUtils"/>
        <import package="org.apache.commons.math3.linear.RealMatrix"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optim.OptimizationData"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.PointValuePair"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer"/>
        <import package="org.apache.commons.math3.random.RandomGenerator"/>
        <import package="org.apache.commons.math3.util.MathArrays"/>
        <class name="CMAESOptimizer" extends="MultivariateOptimizer" line="40">
            <comment line="41">
                global search parameters                
            </comment>
            <comment line="41">
                ivate int lambda; // population size                
            </comment>
            <comment line="41">
                termination criteria                
            </comment>
            <comment line="41">
                selection strategy parameters                
            </comment>
            <comment line="41">
                ivate int mu; //                
            </comment>
            <comment line="41">
                ivate double mueff; //                
            </comment>
            <comment line="41">
                dynamic strategy parameters and constants                
            </comment>
            <comment line="41">
                CMA internal values - updated each generation                
            </comment>
            <comment line="41">
                -----Matrix utility functions similar to the Matlab build in functions------                
            </comment>
            <javadoc line="40">
                &lt;p&gt;An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES)
                 * for non-linear, non-convex, non-smooth, global function minimization.
                 * The CMA-Evolution Strategy (CMA-ES) is a reliable stochastic optimization method
                 * which should be applied if derivative-based methods, e.g. quasi-Newton BFGS or
                 * conjugate gradient, fail due to a rugged search landscape (e.g. noise, local
                 * optima, outlier, etc.) of the objective function. Like a
                 * quasi-Newton method, the CMA-ES learns and applies a variable metric
                 * on the underlying search space. Unlike a quasi-Newton method, the
                 * CMA-ES neither estimates nor uses gradients, making it considerably more
                 * reliable in terms of finding a good, or even close to optimal, solution.&lt;/p&gt;
                 * &lt;p&gt;In general, on smooth objective functions the CMA-ES is roughly ten times
                 * slower than BFGS (counting objective function evaluations, no gradients provided).
                 * For up to &lt;math&gt;N=10&lt;/math&gt; variables also the derivative-free simplex
                 * direct search method (Nelder and Mead) can be faster, but it is
                 * far less reliable than CMA-ES.&lt;/p&gt;
                 * &lt;p&gt;The CMA-ES is particularly well suited for non-separable
                 * and/or badly conditioned problems. To observe the advantage of CMA compared
                 * to a conventional evolution strategy, it will usually take about
                 * &lt;math&gt;30 N&lt;/math&gt; function evaluations. On difficult problems the complete
                 * optimization (a single run) is expected to take &lt;em&gt;roughly&lt;/em&gt; between
                 * &lt;math&gt;30 N&lt;/math&gt; and &lt;math&gt;300 N&lt;sup&gt;2&lt;/sup&gt;&lt;/math&gt;
                 * function evaluations.&lt;/p&gt;
                 * &lt;p&gt;This implementation is translated and adapted from the Matlab version
                 * of the CMA-ES algorithm as implemented in module {@code cmaes.m} version 3.51.&lt;/p&gt;
                 * For more information, please refer to the following links:
                 * &lt;ul&gt;
                 * &lt;li&gt;&lt;a href=&quot;http://www.lri.fr/~hansen/cmaes.m&quot;&gt;Matlab code&lt;/a&gt;&lt;/li&gt;
                 * &lt;li&gt;&lt;a href=&quot;http://www.lri.fr/~hansen/cmaesintro.html&quot;&gt;Introduction to CMA-ES&lt;/a&gt;&lt;/li&gt;
                 * &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CMA-ES&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
                 * &lt;/ul&gt;                
                <@version>
                    n $Id: CMAESOptimizer.java 1462503 2013-03-29 15:48:27Z luc $                    
                </@version>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <declaration name="lambda" type="int" line="82"/>
            <javadoc line="82">
                Population size, offspring number. The primary strategy parameter to play
                 * with, which can be increased from its default value. Increasing the
                 * population size improves global search properties in exchange to speed.
                 * Speed decreases, as a rule, at most linearly with increasing population
                 * size. It is advisable to begin with the default small population size.                
            </javadoc>
            <declaration name="isActiveCMA" type="boolean" line="90"/>
            <javadoc line="90">
                Covariance update mechanism, default is active CMA. isActiveCMA = true
                 * turns on &quot;active CMA&quot; with a negative update of the covariance matrix and
                 * checks for positive definiteness. OPTS.CMA.active = 2 does not check for
                 * pos. def. and is numerically faster. Active CMA usually speeds up the
                 * adaptation.                
            </javadoc>
            <declaration name="checkFeasableCount" type="int" line="98"/>
            <javadoc line="98">
                Determines how often a new random offspring is generated in case it is
                 * not feasible / beyond the defined limits, default is 0.                
            </javadoc>
            <declaration name="inputSigma" type="double[]" line="103"/>
            <javadoc line="103">
                @see Sigma                
            </javadoc>
            <declaration name="dimension" type="int" line="107"/>
            <javadoc line="107">
                Number of objective variables/problem dimension                
            </javadoc>
            <declaration name="diagonalOnly" type="int" line="109"/>
            <javadoc line="109">
                Defines the number of initial iterations, where the covariance matrix
                 * remains diagonal and the algorithm has internally linear time complexity.
                 * diagonalOnly = 1 means keeping the covariance matrix always diagonal and
                 * this setting also exhibits linear space complexity. This can be
                 * particularly useful for dimension &gt; 100.                
                <@see>
                    e <a href="http://hal.archives-ouvertes.fr/inria-00287367/en">A Simple Modification in CMA-ES</a>                    
                </@see>
            </javadoc>
            <declaration name="isMinimize" type="boolean" line="118"/>
            <javadoc line="118">
                Number of objective variables/problem dimension                
            </javadoc>
            <declaration name="generateStatistics" type="boolean" line="120"/>
            <javadoc line="120">
                Indicates whether statistic data is collected.                
            </javadoc>
            <declaration name="maxIterations" type="int" line="124"/>
            <javadoc line="124">
                Maximal number of iterations allowed.                
            </javadoc>
            <declaration name="stopFitness" type="double" line="126"/>
            <javadoc line="126">
                Limit for fitness value.                
            </javadoc>
            <declaration name="stopTolUpX" type="double" line="128"/>
            <javadoc line="128">
                Stop if x-changes larger stopTolUpX.                
            </javadoc>
            <declaration name="stopTolX" type="double" line="130"/>
            <javadoc line="130">
                Stop if x-change smaller stopTolX.                
            </javadoc>
            <declaration name="stopTolFun" type="double" line="132"/>
            <javadoc line="132">
                Stop if fun-changes smaller stopTolFun.                
            </javadoc>
            <declaration name="stopTolHistFun" type="double" line="134"/>
            <javadoc line="134">
                Stop if back fun-changes smaller stopTolHistFun.                
            </javadoc>
            <declaration name="mu" type="int" line="138"/>
            <javadoc line="138">
                Number of parents/points for recombination.                
            </javadoc>
            <declaration name="logMu2" type="double" line="140"/>
            <javadoc line="140">
                log(mu + 0.5), stored for efficiency.                
            </javadoc>
            <declaration name="weights" type="RealMatrix" line="142"/>
            <javadoc line="142">
                Array for weighted recombination.                
            </javadoc>
            <declaration name="mueff" type="double" line="144"/>
            <javadoc line="144">
                Variance-effectiveness of sum w_i x_i.                
            </javadoc>
            <declaration name="sigma" type="double" line="148"/>
            <javadoc line="148">
                Overall standard deviation - search volume.                
            </javadoc>
            <declaration name="cc" type="double" line="150"/>
            <javadoc line="150">
                Cumulation constant.                
            </javadoc>
            <declaration name="cs" type="double" line="152"/>
            <javadoc line="152">
                Cumulation constant for step-size.                
            </javadoc>
            <declaration name="damps" type="double" line="154"/>
            <javadoc line="154">
                Damping for step-size.                
            </javadoc>
            <declaration name="ccov1" type="double" line="156"/>
            <javadoc line="156">
                Learning rate for rank-one update.                
            </javadoc>
            <declaration name="ccovmu" type="double" line="158"/>
            <javadoc line="158">
                Learning rate for rank-mu update&apos;                
            </javadoc>
            <declaration name="chiN" type="double" line="160"/>
            <javadoc line="160">
                Expectation of ||N(0,I)|| == norm(randn(N,1)).                
            </javadoc>
            <declaration name="ccov1Sep" type="double" line="162"/>
            <javadoc line="162">
                Learning rate for rank-one update - diagonalOnly                
            </javadoc>
            <declaration name="ccovmuSep" type="double" line="164"/>
            <javadoc line="164">
                Learning rate for rank-mu update - diagonalOnly                
            </javadoc>
            <declaration name="xmean" type="RealMatrix" line="168"/>
            <javadoc line="168">
                Objective variables.                
            </javadoc>
            <declaration name="pc" type="RealMatrix" line="170"/>
            <javadoc line="170">
                Evolution path.                
            </javadoc>
            <declaration name="ps" type="RealMatrix" line="172"/>
            <javadoc line="172">
                Evolution path for sigma.                
            </javadoc>
            <declaration name="normps" type="double" line="174"/>
            <javadoc line="174">
                Norm of ps, stored for efficiency.                
            </javadoc>
            <declaration name="B" type="RealMatrix" line="176"/>
            <javadoc line="176">
                Coordinate system.                
            </javadoc>
            <declaration name="D" type="RealMatrix" line="178"/>
            <javadoc line="178">
                Scaling.                
            </javadoc>
            <declaration name="BD" type="RealMatrix" line="180"/>
            <javadoc line="180">
                B*D, stored for efficiency.                
            </javadoc>
            <declaration name="diagD" type="RealMatrix" line="182"/>
            <javadoc line="182">
                Diagonal of sqrt(D), stored for efficiency.                
            </javadoc>
            <declaration name="C" type="RealMatrix" line="184"/>
            <javadoc line="184">
                Covariance matrix.                
            </javadoc>
            <declaration name="diagC" type="RealMatrix" line="186"/>
            <javadoc line="186">
                Diagonal of C, used for diagonalOnly.                
            </javadoc>
            <declaration name="iterations" type="int" line="188"/>
            <javadoc line="188">
                Number of iterations already performed.                
            </javadoc>
            <declaration name="fitnessHistory" type="double[]" line="191"/>
            <javadoc line="191">
                History queue of best values.                
            </javadoc>
            <declaration name="historySize" type="int" line="193"/>
            <javadoc line="193">
                Size of history queue of best values.                
            </javadoc>
            <declaration name="random" type="RandomGenerator" line="196"/>
            <javadoc line="196">
                Random generator.                
            </javadoc>
            <declaration name="statisticsSigmaHistory" type="List&lt;Double&gt;" line="199"/>
            <javadoc line="199">
                History of sigma values.                
            </javadoc>
            <declaration name="statisticsMeanHistory" type="List&lt;RealMatrix&gt;" line="201"/>
            <javadoc line="201">
                History of mean matrix.                
            </javadoc>
            <declaration name="statisticsFitnessHistory" type="List&lt;Double&gt;" line="203"/>
            <javadoc line="203">
                History of fitness values.                
            </javadoc>
            <declaration name="statisticsDHistory" type="List&lt;RealMatrix&gt;" line="205"/>
            <javadoc line="205">
                History of D matrix.                
            </javadoc>
            <javadoc line="208">
                @param maxIterations Maximal number of iterations.                
                <@param>
                    m stopFitness Whether to stop if objective function value is smaller than{@code stopFitness}.                    
                </@param>
                <@param>
                    m isActiveCMA Chooses the covariance matrix update method.                    
                </@param>
                <@param>
                    m diagonalOnly Number of initial iterations, where the covariance matrix
                     * remains diagonal.                    
                </@param>
                <@param>
                    m checkFeasableCount Determines how often new random objective variables are
                     * generated in case they are out of bounds.                    
                </@param>
                <@param>
                    m random Random generator.                    
                </@param>
                <@param>
                    m generateStatistics Whether statistic data is collected.                    
                </@param>
                <@param>
                    m checker Convergence checker.                    
                </@param>
                <@since>
                    e 3.1                    
                </@since>
            </javadoc>
            <method name="CMAESOptimizer" type="constructor" line="230"/>
            <javadoc line="241">
                @return History of sigma values.                
            </javadoc>
            <method name="getStatisticsSigmaHistory" type="List<Double>" line="244"/>
            <javadoc line="248">
                @return History of mean matrix.                
            </javadoc>
            <method name="getStatisticsMeanHistory" type="List<RealMatrix>" line="251"/>
            <javadoc line="255">
                @return History of fitness values.                
            </javadoc>
            <method name="getStatisticsFitnessHistory" type="List<Double>" line="258"/>
            <javadoc line="262">
                @return History of D matrix.                
            </javadoc>
            <method name="getStatisticsDHistory" type="List<RealMatrix>" line="265"/>
            <class name="Sigma" line="269">
                <implements interface="OptimizationData"/>
                <javadoc line="269">
                    Input sigma values.
                     * They define the initial coordinate-wise standard deviations for
                     * sampling new search points around the initial guess.
                     * It is suggested to set them to the estimated distance from the
                     * initial to the desired optimum.
                     * Small values induce the search to be more local (and very small
                     * values are more likely to find a local optimum close to the initial
                     * guess).
                     * Too small values might however lead to early termination.                    
                </javadoc>
                <declaration name="sigma" type="double[]" line="281"/>
                <javadoc line="281">
                    Sigma values.                    
                </javadoc>
                <javadoc line="284">
                    @param s Sigma values.                    
                    <@throws>
                        s NotPositiveException if any of the array entries is smaller
                         * than zero.                        
                    </@throws>
                </javadoc>
                <method name="Sigma" type="constructor" line="290">
                    <scope line="291">
                        <scope line="292"/>
                    </scope>
                </method>
                <javadoc line="300">
                    @return the sigma values.                    
                </javadoc>
                <method name="getSigma" type="double[]" line="303"/>
            </class>
            <class name="PopulationSize" line="308">
                <implements interface="OptimizationData"/>
                <javadoc line="308">
                    Population size.
                     * The number of offspring is the primary strategy parameter.
                     * In the absence of better clues, a good default could be an
                     * integer close to {@code 4 + 3 ln(n)}, where {@code n} is the
                     * number of optimized parameters.
                     * Increasing the population size improves global search properties
                     * at the expense of speed (which in general decreases at most
                     * linearly with increasing population size).                    
                </javadoc>
                <declaration name="lambda" type="int" line="319"/>
                <javadoc line="319">
                    Population size.                    
                </javadoc>
                <javadoc line="322">
                    @param size Population size.                    
                    <@throws>
                        s NotStrictlyPositiveException if {@code size <= 0}.                        
                    </@throws>
                </javadoc>
                <method name="PopulationSize" type="constructor" line="327">
                    <scope line="328"/>
                </method>
                <javadoc line="334">
                    @return the population size.                    
                </javadoc>
                <method name="getPopulationSize" type="int" line="337"/>
            </class>
            <javadoc line="342">
                {@inheritDoc}                
                <@param>
                    m optData Optimization data. In addition to those documented in{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])MultivariateOptimizer}, this method will register the following data:
                     * <ul>
                     * <li>{@link Sigma}</li>
                     * <li>{@link PopulationSize}</li>
                     * </ul>                    
                </@param>
                <@return>
                    n {@inheritDoc}                    
                </@return>
                <@throws>
                    s TooManyEvaluationsException if the maximal number of
                     * evaluations is exceeded.                    
                </@throws>
                <@throws>
                    s DimensionMismatchException if the initial guess, target, and weight
                     * arguments have inconsistent dimensions.                    
                </@throws>
            </javadoc>
            <method name="optimize" type="PointValuePair" line="361">
                <comment line="362">
                    Set up base class and perform computation.                    
                </comment>
            </method>
            <javadoc line="366">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="368">
                <comment line="369">
                    -------------------- Initialization --------------------------------                    
                </comment>
                <comment line="369">
                    number of objective variables/problem dimension                    
                </comment>
                <comment line="369">
                    -------------------- Generation Loop --------------------------------                    
                </comment>
                <declaration name="fitfun" type="FitnessFunction" line="371"/>
                <declaration name="guess" type="double[]" line="372"/>
                <declaration name="bestValue" type="double" line="377"/>
                <declaration name="optimum" type="PointValuePair" line="379"/>
                <declaration name="lastResult" type="PointValuePair" line="382"/>
                <scope line="387">
                    <declaration name="arz" type="RealMatrix" line="391"/>
                    <declaration name="arx" type="RealMatrix" line="392"/>
                    <declaration name="fitness" type="double[]" line="393"/>
                    <scope line="395">
                        <declaration name="arxk" type="RealMatrix" line="396"/>
                        <scope line="397">
                            <scope line="398"/>
                            <scope line="401"/>
                            <scope line="406"/>
                        </scope>
                        <scope line="413"/>
                        <scope line="415"/>
                    </scope>
                    <declaration name="arindex" type="int[]" line="420"/>
                    <declaration name="xold" type="RealMatrix" line="422"/>
                    <declaration name="bestArx" type="RealMatrix" line="423"/>
                    <declaration name="bestArz" type="RealMatrix" line="425"/>
                    <declaration name="zmean" type="RealMatrix" line="426"/>
                    <declaration name="hsig" type="boolean" line="427"/>
                    <scope line="428"/>
                    <scope line="430"/>
                    <declaration name="bestFitness" type="double" line="435"/>
                    <declaration name="worstFitness" type="double" line="436"/>
                    <scope line="437">
                        <scope line="443"/>
                    </scope>
                    <scope line="449"/>
                    <declaration name="sqrtDiagC" type="double[]" line="452"/>
                    <declaration name="pcCol" type="double[]" line="453"/>
                    <scope line="454">
                        <scope line="455"/>
                        <scope line="458"/>
                    </scope>
                    <scope line="462">
                        <scope line="463"/>
                    </scope>
                    <declaration name="historyBest" type="double" line="467"/>
                    <declaration name="historyWorst" type="double" line="468"/>
                    <scope line="471"/>
                    <scope line="475"/>
                    <scope line="479"/>
                    <scope line="483">
                        <declaration name="current" type="PointValuePair" line="484"/>
                        <scope line="488"/>
                    </scope>
                    <scope line="494"/>
                    <scope line="498"/>
                    <scope line="504"/>
                </scope>
            </method>
            <javadoc line="514">
                Scans the list of (required and optional) optimization data that
                 * characterize the problem.                
                <@param>
                    m optData Optimization data. The following data will be looked for:
                     * <ul>
                     * <li>{@link Sigma}</li>
                     * <li>{@link PopulationSize}</li>
                     * </ul>                    
                </@param>
            </javadoc>
            <method name="parseOptimizationData" type="void" line="525">
                <comment line="526">
                    Allow base class to register its own data.                    
                </comment>
                <comment line="526">
                    The existing values (as set by the previous call) are reused if                    
                </comment>
                <comment line="526">
                    not provided in the argument list.                    
                </comment>
                <scope line="531">
                    <scope line="532"/>
                    <scope line="536"/>
                </scope>
            </method>
            <javadoc line="545">
                Checks dimensions and values of boundaries and inputSigma if defined.                
            </javadoc>
            <method name="checkParameters" type="void" line="548">
                <declaration name="init" type="double[]" line="549"/>
                <declaration name="lB" type="double[]" line="550"/>
                <declaration name="uB" type="double[]" line="551"/>
                <scope line="553">
                    <scope line="554"/>
                    <scope line="557">
                        <scope line="558"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="565">
                Initialization of the dynamic search parameters                
                <@param>
                    m guess Initial guess for the arguments of the fitness function.                    
                </@param>
            </javadoc>
            <method name="initializeCMA" type="void" line="570">
                <comment line="571">
                    initialize sigma                    
                </comment>
                <comment line="571">
                    gma = max(insigma); // overall standard deviation                    
                </comment>
                <comment line="571">
                    initialize termination criteria                    
                </comment>
                <comment line="571">
                    initialize selection strategy parameters                    
                </comment>
                <comment line="571">
                    = lambda / 2; // number of parents/points for recombination                    
                </comment>
                <comment line="571">
                    eff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i                    
                </comment>
                <comment line="571">
                    initialize dynamic strategy parameters and constants                    
                </comment>
                <comment line="571">
                    - dimension / (1e-6 + maxIterations)) + cs; // minor increment                    
                </comment>
                <comment line="571">
                    intialize CMA internal values - updated each generation                    
                </comment>
                <comment line="571">
                    ean = MatrixUtils.createColumnRealMatrix(guess); // objective variables                    
                </comment>
                <comment line="571">
                    = zeros(dimension, 1); // evolution paths for C and sigma                    
                </comment>
                <comment line="571">
                    = zeros(dimension, 1); // B defines the coordinate system                    
                </comment>
                <comment line="571">
                    = ones(dimension, 1); // diagonal D defines the scaling                    
                </comment>
                <comment line="571">
                    = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance                    
                </comment>
                <comment line="571">
                    tnessHistory = new double[historySize]; // history of fitness values                    
                </comment>
                <scope line="571"/>
                <declaration name="sigmaArray" type="double[][]" line="575"/>
                <scope line="576"/>
                <declaration name="insigma" type="RealMatrix" line="579"/>
                <declaration name="sumw" type="double" line="592"/>
                <declaration name="sumwq" type="double" line="593"/>
                <scope line="594">
                    <declaration name="w" type="double" line="595"/>
                </scope>
                <scope line="631"/>
            </method>
            <javadoc line="636">
                Update of the evolution paths ps and pc.                
                <@param>
                    m zmean Weighted row matrix of the gaussian random numbers generating
                     * the current offspring.                    
                </@param>
                <@param>
                    m xold xmean matrix of the previous generation.                    
                </@param>
                <@return>
                    n hsig flag indicating a small correction.                    
                </@return>
            </javadoc>
            <method name="updateEvolutionPaths" type="boolean" line="644">
                <declaration name="hsig" type="boolean" line="649"/>
                <scope line="653"/>
            </method>
            <javadoc line="659">
                Update of the covariance matrix C for diagonalOnly &gt; 0                
                <@param>
                    m hsig Flag indicating a small correction.                    
                </@param>
                <@param>
                    m bestArz Fitness-sorted matrix of the gaussian random values of the
                     * current offspring.                    
                </@param>
            </javadoc>
            <method name="updateCovarianceDiagonalOnly" type="void" line="667">
                <comment line="668">
                    minor correction if hsig==false                    
                </comment>
                <comment line="668">
                    agD = sqrt(diagC); // replaces eig(C)                    
                </comment>
                <declaration name="oldFac" type="double" line="669"/>
                <scope line="677"/>
            </method>
            <javadoc line="686">
                Update of the covariance matrix C.                
                <@param>
                    m hsig Flag indicating a small correction.                    
                </@param>
                <@param>
                    m bestArx Fitness-sorted matrix of the argument vectors producing the
                     * current offspring.                    
                </@param>
                <@param>
                    m arz Unsorted matrix containing the gaussian random values of the
                     * current offspring.                    
                </@param>
                <@param>
                    m arindex Indices indicating the fitness-order of the current offspring.                    
                </@param>
                <@param>
                    m xold xmean matrix of the previous generation.                    
                </@param>
            </javadoc>
            <method name="updateCovariance" type="void" line="699">
                <declaration name="negccov" type="double" line="700"/>
                <scope line="701">
                    <declaration name="arpos" type="RealMatrix" line="702"/>
                    <declaration name="roneu" type="RealMatrix" line="704"/>
                    <declaration name="oldFac" type="double" line="707"/>
                    <scope line="709">
                        <declaration name="negminresidualvariance" type="double" line="715"/>
                        <declaration name="negalphaold" type="double" line="717"/>
                        <declaration name="arReverseIndex" type="int[]" line="719"/>
                        <declaration name="arzneg" type="RealMatrix" line="720"/>
                        <declaration name="arnorms" type="RealMatrix" line="721"/>
                        <declaration name="idxnorms" type="int[]" line="722"/>
                        <declaration name="arnormsSorted" type="RealMatrix" line="723"/>
                        <declaration name="idxReverse" type="int[]" line="724"/>
                        <declaration name="arnormsReverse" type="RealMatrix" line="725"/>
                        <declaration name="idxInv" type="int[]" line="727"/>
                        <declaration name="arnormsInv" type="RealMatrix" line="728"/>
                        <declaration name="negcovMax" type="double" line="730"/>
                        <scope line="732"/>
                        <declaration name="artmp" type="RealMatrix" line="736"/>
                        <declaration name="Cneg" type="RealMatrix" line="737"/>
                    </scope>
                    <scope line="746"/>
                </scope>
            </method>
            <javadoc line="758">
                Update B and D from C.                
                <@param>
                    m negccov Negative covariance factor.                    
                </@param>
            </javadoc>
            <method name="updateBD" type="void" line="763">
                <scope line="765">
                    <declaration name="eig" type="EigenDecomposition" line="769"/>
                    <scope line="773">
                        <scope line="774">
                            <scope line="775"/>
                        </scope>
                        <declaration name="tfac" type="double" line="779"/>
                    </scope>
                    <scope line="783">
                        <declaration name="tfac" type="double" line="784"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="794">
                Pushes the current best fitness value in a history queue.                
                <@param>
                    m vals History queue.                    
                </@param>
                <@param>
                    m val Current best fitness value.                    
                </@param>
            </javadoc>
            <method name="push" type="void" line="800">
                <scope line="801"/>
            </method>
            <javadoc line="807">
                Sorts fitness values.                
                <@param>
                    m doubles Array of values to be sorted.                    
                </@param>
                <@return>
                    n a sorted array of indices pointing into doubles.                    
                </@return>
            </javadoc>
            <method name="sortedIndices" type="int[]" line="813">
                <declaration name="dis" type="DoubleIndex[]" line="814"/>
                <scope line="815"/>
                <declaration name="indices" type="int[]" line="819"/>
                <scope line="820"/>
            </method>
            <class name="DoubleIndex" line="826">
                <implements interface="Comparable&lt;DoubleIndex&gt;"/>
                <javadoc line="826">
                    Used to sort fitness values. Sorting is always in lower value first
                     * order.                    
                </javadoc>
                <declaration name="value" type="double" line="831"/>
                <javadoc line="831">
                    Value to compare.                    
                </javadoc>
                <declaration name="index" type="int" line="833"/>
                <javadoc line="833">
                    Index into sorted array.                    
                </javadoc>
                <javadoc line="836">
                    @param value Value to compare.                    
                    <@param>
                        m index Index into sorted array.                        
                    </@param>
                </javadoc>
                <method name="DoubleIndex" type="constructor" line="840"/>
                <javadoc line="845">
                    {@inheritDoc}                    
                </javadoc>
                <method name="compareTo" type="int" line="846"/>
                <javadoc line="850">
                    {@inheritDoc}                    
                </javadoc>
                <method name="equals" type="boolean" line="852">
                    <scope line="854"/>
                    <scope line="858"/>
                </method>
                <javadoc line="865">
                    {@inheritDoc}                    
                </javadoc>
                <method name="hashCode" type="int" line="867">
                    <declaration name="bits" type="long" line="868"/>
                </method>
            </class>
            <class name="FitnessFunction" line="873">
                <javadoc line="873">
                    Normalizes fitness values to the range [0,1]. Adds a penalty to the
                     * fitness value if out of range. The penalty is adjusted by calling
                     * setValueRange().                    
                </javadoc>
                <declaration name="valueRange" type="double" line="879"/>
                <javadoc line="879">
                    Determines the penalty for boundary violations                    
                </javadoc>
                <declaration name="isRepairMode" type="boolean" line="881"/>
                <javadoc line="881">
                    Flag indicating whether the objective variables are forced into their
                     * bounds if defined                    
                </javadoc>
                <javadoc line="887">
                    Simple constructor.                    
                </javadoc>
                <method name="FitnessFunction" type="constructor" line="889"/>
                <javadoc line="894">
                    @param point Normalized objective variables.                    
                    <@return>
                        n the objective value + penalty for violated bounds.                        
                    </@return>
                </javadoc>
                <method name="value" type="double" line="898">
                    <declaration name="value" type="double" line="899"/>
                    <scope line="900">
                        <declaration name="repaired" type="double[]" line="901"/>
                    </scope>
                    <scope line="904"/>
                </method>
                <javadoc line="910">
                    @param x Normalized objective variables.                    
                    <@return>
                        n {@code true} if in bounds.                        
                    </@return>
                </javadoc>
                <method name="isFeasible" type="boolean" line="914">
                    <declaration name="lB" type="double[]" line="915"/>
                    <declaration name="uB" type="double[]" line="916"/>
                    <scope line="918">
                        <scope line="919"/>
                        <scope line="922"/>
                    </scope>
                </method>
                <javadoc line="929">
                    @param valueRange Adjusts the penalty computation.                    
                </javadoc>
                <method name="setValueRange" type="void" line="932"/>
                <javadoc line="936">
                    @param x Normalized objective variables.                    
                    <@return>
                        n the repaired (i.e. all in bounds) objective variables.                        
                    </@return>
                </javadoc>
                <method name="repair" type="double[]" line="940">
                    <declaration name="lB" type="double[]" line="941"/>
                    <declaration name="uB" type="double[]" line="942"/>
                    <declaration name="repaired" type="double[]" line="944"/>
                    <scope line="945">
                        <scope line="946"/>
                        <scope line="948"/>
                        <scope line="950"/>
                    </scope>
                </method>
                <javadoc line="957">
                    @param x Normalized objective variables.                    
                    <@param>
                        m repaired Repaired objective variables.                        
                    </@param>
                    <@return>
                        n Penalty value according to the violation of the bounds.                        
                    </@return>
                </javadoc>
                <method name="penalty" type="double" line="962">
                    <declaration name="penalty" type="double" line="963"/>
                    <scope line="964">
                        <declaration name="diff" type="double" line="965"/>
                    </scope>
                </method>
            </class>
            <javadoc line="974">
                @param m Input matrix                
                <@return>
                    n Matrix representing the element-wise logarithm of m.                    
                </@return>
            </javadoc>
            <method name="log" type="RealMatrix" line="978">
                <declaration name="d" type="double[][]" line="979"/>
                <scope line="980">
                    <scope line="981"/>
                </scope>
            </method>
            <javadoc line="988">
                @param m Input matrix.                
                <@return>
                    n Matrix representing the element-wise square root of m.                    
                </@return>
            </javadoc>
            <method name="sqrt" type="RealMatrix" line="992">
                <declaration name="d" type="double[][]" line="993"/>
                <scope line="994">
                    <scope line="995"/>
                </scope>
            </method>
            <javadoc line="1002">
                @param m Input matrix.                
                <@return>
                    n Matrix representing the element-wise square of m.                    
                </@return>
            </javadoc>
            <method name="square" type="RealMatrix" line="1006">
                <declaration name="d" type="double[][]" line="1007"/>
                <scope line="1008">
                    <scope line="1009">
                        <declaration name="e" type="double" line="1010"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1017">
                @param m Input matrix 1.                
                <@param>
                    m n Input matrix 2.                    
                </@param>
                <@return>
                    n the matrix where the elements of m and n are element-wise multiplied.                    
                </@return>
            </javadoc>
            <method name="times" type="RealMatrix" line="1022">
                <declaration name="d" type="double[][]" line="1023"/>
                <scope line="1024">
                    <scope line="1025"/>
                </scope>
            </method>
            <javadoc line="1032">
                @param m Input matrix 1.                
                <@param>
                    m n Input matrix 2.                    
                </@param>
                <@return>
                    n Matrix where the elements of m and n are element-wise divided.                    
                </@return>
            </javadoc>
            <method name="divide" type="RealMatrix" line="1037">
                <declaration name="d" type="double[][]" line="1038"/>
                <scope line="1039">
                    <scope line="1040"/>
                </scope>
            </method>
            <javadoc line="1047">
                @param m Input matrix.                
                <@param>
                    m cols Columns to select.                    
                </@param>
                <@return>
                    n Matrix representing the selected columns.                    
                </@return>
            </javadoc>
            <method name="selectColumns" type="RealMatrix" line="1052">
                <declaration name="d" type="double[][]" line="1053"/>
                <scope line="1054">
                    <scope line="1055"/>
                </scope>
            </method>
            <javadoc line="1062">
                @param m Input matrix.                
                <@param>
                    m k Diagonal position.                    
                </@param>
                <@return>
                    n Upper triangular part of matrix.                    
                </@return>
            </javadoc>
            <method name="triu" type="RealMatrix" line="1067">
                <declaration name="d" type="double[][]" line="1068"/>
                <scope line="1069">
                    <scope line="1070"/>
                </scope>
            </method>
            <javadoc line="1077">
                @param m Input matrix.                
                <@return>
                    n Row matrix representing the sums of the rows.                    
                </@return>
            </javadoc>
            <method name="sumRows" type="RealMatrix" line="1081">
                <declaration name="d" type="double[][]" line="1082"/>
                <scope line="1083">
                    <declaration name="sum" type="double" line="1084"/>
                    <scope line="1085"/>
                </scope>
            </method>
            <javadoc line="1093">
                @param m Input matrix.                
                <@return>
                    n the diagonal n-by-n matrix if m is a column matrix or the column
                     * matrix representing the diagonal if m is a n-by-n matrix.                    
                </@return>
            </javadoc>
            <method name="diag" type="RealMatrix" line="1098">
                <scope line="1099">
                    <declaration name="d" type="double[][]" line="1100"/>
                    <scope line="1101"/>
                </scope>
                <scope line="1105">
                    <declaration name="d" type="double[][]" line="1106"/>
                    <scope line="1107"/>
                </scope>
            </method>
            <javadoc line="1114">
                Copies a column from m1 to m2.                
                <@param>
                    m m1 Source matrix.                    
                </@param>
                <@param>
                    m col1 Source column.                    
                </@param>
                <@param>
                    m m2 Target matrix.                    
                </@param>
                <@param>
                    m col2 Target column.                    
                </@param>
            </javadoc>
            <method name="copyColumn" type="void" line="1123">
                <scope line="1124"/>
            </method>
            <javadoc line="1129">
                @param n Number of rows.                
                <@param>
                    m m Number of columns.                    
                </@param>
                <@return>
                    n n-by-m matrix filled with 1.                    
                </@return>
            </javadoc>
            <method name="ones" type="RealMatrix" line="1134">
                <declaration name="d" type="double[][]" line="1135"/>
                <scope line="1136"/>
            </method>
            <javadoc line="1142">
                @param n Number of rows.                
                <@param>
                    m m Number of columns.                    
                </@param>
                <@return>
                    n n-by-m matrix of 0 values out of diagonal, and 1 values on
                     * the diagonal.                    
                </@return>
            </javadoc>
            <method name="eye" type="RealMatrix" line="1148">
                <declaration name="d" type="double[][]" line="1149"/>
                <scope line="1150">
                    <scope line="1151"/>
                </scope>
            </method>
            <javadoc line="1158">
                @param n Number of rows.                
                <@param>
                    m m Number of columns.                    
                </@param>
                <@return>
                    n n-by-m matrix of zero values.                    
                </@return>
            </javadoc>
            <method name="zeros" type="RealMatrix" line="1163"/>
            <javadoc line="1167">
                @param mat Input matrix.                
                <@param>
                    m n Number of row replicates.                    
                </@param>
                <@param>
                    m m Number of column replicates.                    
                </@param>
                <@return>
                    n a matrix which replicates the input matrix in both directions.                    
                </@return>
            </javadoc>
            <method name="repmat" type="RealMatrix" line="1173">
                <declaration name="rd" type="int" line="1174"/>
                <declaration name="cd" type="int" line="1175"/>
                <declaration name="d" type="double[][]" line="1176"/>
                <scope line="1177">
                    <scope line="1178"/>
                </scope>
            </method>
            <javadoc line="1185">
                @param start Start value.                
                <@param>
                    m end End value.                    
                </@param>
                <@param>
                    m step Step size.                    
                </@param>
                <@return>
                    n a sequence as column matrix.                    
                </@return>
            </javadoc>
            <method name="sequence" type="RealMatrix" line="1191">
                <declaration name="size" type="int" line="1192"/>
                <declaration name="d" type="double[][]" line="1193"/>
                <declaration name="value" type="double" line="1194"/>
                <scope line="1195"/>
            </method>
            <javadoc line="1202">
                @param m Input matrix.                
                <@return>
                    n the maximum of the matrix element values.                    
                </@return>
            </javadoc>
            <method name="max" type="double" line="1206">
                <declaration name="max" type="double" line="1207"/>
                <scope line="1208">
                    <scope line="1209">
                        <declaration name="e" type="double" line="1210"/>
                        <scope line="1211"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1219">
                @param m Input matrix.                
                <@return>
                    n the minimum of the matrix element values.                    
                </@return>
            </javadoc>
            <method name="min" type="double" line="1223">
                <declaration name="min" type="double" line="1224"/>
                <scope line="1225">
                    <scope line="1226">
                        <declaration name="e" type="double" line="1227"/>
                        <scope line="1228"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1236">
                @param m Input array.                
                <@return>
                    n the maximum of the array values.                    
                </@return>
            </javadoc>
            <method name="max" type="double" line="1240">
                <declaration name="max" type="double" line="1241"/>
                <scope line="1242">
                    <scope line="1243"/>
                </scope>
            </method>
            <javadoc line="1250">
                @param m Input array.                
                <@return>
                    n the minimum of the array values.                    
                </@return>
            </javadoc>
            <method name="min" type="double" line="1254">
                <declaration name="min" type="double" line="1255"/>
                <scope line="1256">
                    <scope line="1257"/>
                </scope>
            </method>
            <javadoc line="1264">
                @param indices Input index array.                
                <@return>
                    n the inverse of the mapping defined by indices.                    
                </@return>
            </javadoc>
            <method name="inverse" type="int[]" line="1268">
                <declaration name="inverse" type="int[]" line="1269"/>
                <scope line="1270"/>
            </method>
            <javadoc line="1276">
                @param indices Input index array.                
                <@return>
                    n the indices in inverse order (last is first).                    
                </@return>
            </javadoc>
            <method name="reverse" type="int[]" line="1280">
                <declaration name="reverse" type="int[]" line="1281"/>
                <scope line="1282"/>
            </method>
            <javadoc line="1288">
                @param size Length of random array.                
                <@return>
                    n an array of Gaussian random numbers.                    
                </@return>
            </javadoc>
            <method name="randn" type="double[]" line="1292">
                <declaration name="randn" type="double[]" line="1293"/>
                <scope line="1294"/>
            </method>
            <javadoc line="1300">
                @param size Number of rows.                
                <@param>
                    m popSize Population size.                    
                </@param>
                <@return>
                    n a 2-dimensional matrix of Gaussian random numbers.                    
                </@return>
            </javadoc>
            <method name="randn1" type="RealMatrix" line="1305">
                <declaration name="d" type="double[][]" line="1306"/>
                <scope line="1307">
                    <scope line="1308"/>
                </scope>
            </method>
        </class>
    </source>