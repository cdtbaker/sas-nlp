<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.fitting">
        <import package="org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer"/>
        <import package="org.apache.commons.math3.analysis.function.HarmonicOscillator"/>
        <import package="org.apache.commons.math3.exception.ZeroException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="HarmonicFitter" line="27">
            <extends class="CurveFitter">
                <type_params>
                    <type_param name="HarmonicOscillator.Parametric"/>
                </type_params>
            </extends>
            <javadoc line="27">
                Class that implements a curve fitting specialized for sinusoids.
                  Harmonic fitting is a very simple case of curve fitting. The
                  estimated coefficients are the amplitude a, the pulsation &amp;omega; and
                  the phase &amp;phi;: &lt;code&gt;f (t) = a cos (&amp;omega; t + &amp;phi;)&lt;/code&gt;. They are
                  searched by a least square estimator initialized with a rough guess
                  based on integrals.                
                <@version>
                    n $Id: HarmonicFitter.java 1416643 2012-12-03 19:37:14Z tn $                    
                </@version>
                <@since>
                    e 2.0                    
                </@since>
            </javadoc>
            <javadoc line="40">
                Simple constructor.                
                <@param>
                    m optimizer Optimizer to use for the fitting.                    
                </@param>
            </javadoc>
            <method name="HarmonicFitter" type="constructor" line="44">
                <params>
                    <param name="optimizer" type="MultivariateVectorOptimizer"/>
                </params>
            </method>
            <javadoc line="48">
                Fit an harmonic function to the observed points.                
                <@param>
                    m initialGuess First guess values in the following order:
                      <ul>
                      <li>Amplitude</li>
                      <li>Angular frequency</li>
                      <li>Phase</li>
                      </ul>                    
                </@param>
                <@return>
                    n the parameters of the harmonic function that best fits the
                      observed points (in the same order as above).                    
                </@return>
            </javadoc>
            <method name="fit" type="double[]" line="60">
                <params>
                    <param name="initialGuess" type="double[]"/>
                </params>
            </method>
            <javadoc line="64">
                Fit an harmonic function to the observed points.
                  An initial guess will be automatically computed.                
                <@return>
                    n the parameters of the harmonic function that best fits the
                      observed points (see the other {@link #fit(double[]) fit} method.                    
                </@return>
                <@throws>
                    s NumberIsTooSmallException if the sample is too short for the
                      the first guess to be computed.                    
                </@throws>
                <@throws>
                    s ZeroException if the first guess cannot be computed because
                      the abscissa range is zero.                    
                </@throws>
            </javadoc>
            <method name="fit" type="double[]" line="75"/>
            <class name="ParameterGuesser" line="79">
                <javadoc line="79">
                    This class guesses harmonic coefficients from a sample.
                      &lt;p&gt;The algorithm used to guess the coefficients is as follows:&lt;/p&gt;
                      &lt;p&gt;We know f (t) at some sampling points t&lt;sub&gt;i&lt;/sub&gt; and want to find a,
                      &amp;omega; and &amp;phi; such that f (t) = a cos (&amp;omega; t + &amp;phi;).
                      &lt;/p&gt;
                      &lt;p&gt;From the analytical expression, we can compute two primitives :
                      &lt;pre&gt;
                      If2  (t) = &amp;int; f&lt;sup&gt;2&lt;/sup&gt;  = a&lt;sup&gt;2&lt;/sup&gt; &amp;times; [t + S (t)] / 2
                      If&apos;2 (t) = &amp;int; f&apos;&lt;sup&gt;2&lt;/sup&gt; = a&lt;sup&gt;2&lt;/sup&gt; &amp;omega;&lt;sup&gt;2&lt;/sup&gt; &amp;times; [t - S (t)] / 2
                      where S (t) = sin (2 (&amp;omega; t + &amp;phi;)) / (2 &amp;omega;)
                      &lt;/pre&gt;
                      &lt;/p&gt;
                      &lt;p&gt;We can remove S between these expressions :
                      &lt;pre&gt;
                      If&apos;2 (t) = a&lt;sup&gt;2&lt;/sup&gt; &amp;omega;&lt;sup&gt;2&lt;/sup&gt; t - &amp;omega;&lt;sup&gt;2&lt;/sup&gt; If2 (t)
                      &lt;/pre&gt;
                      &lt;/p&gt;
                      &lt;p&gt;The preceding expression shows that If&apos;2 (t) is a linear
                      combination of both t and If2 (t): If&apos;2 (t) = A &amp;times; t + B &amp;times; If2 (t)
                      &lt;/p&gt;
                      &lt;p&gt;From the primitive, we can deduce the same form for definite
                      integrals between t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;i&lt;/sub&gt; for each t&lt;sub&gt;i&lt;/sub&gt; :
                      &lt;pre&gt;
                      If2 (t&lt;sub&gt;i&lt;/sub&gt;) - If2 (t&lt;sub&gt;1&lt;/sub&gt;) = A &amp;times; (t&lt;sub&gt;i&lt;/sub&gt; - t&lt;sub&gt;1&lt;/sub&gt;) + B &amp;times; (If2 (t&lt;sub&gt;i&lt;/sub&gt;) - If2 (t&lt;sub&gt;1&lt;/sub&gt;))
                      &lt;/pre&gt;
                      &lt;/p&gt;
                      &lt;p&gt;We can find the coefficients A and B that best fit the sample
                      to this linear expression by computing the definite integrals for
                      each sample points.
                      &lt;/p&gt;
                      &lt;p&gt;For a bilinear expression z (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;) = A &amp;times; x&lt;sub&gt;i&lt;/sub&gt; + B &amp;times; y&lt;sub&gt;i&lt;/sub&gt;, the
                      coefficients A and B that minimize a least square criterion
                      &amp;sum; (z&lt;sub&gt;i&lt;/sub&gt; - z (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;))&lt;sup&gt;2&lt;/sup&gt; are given by these expressions:&lt;/p&gt;
                      &lt;pre&gt;
                      &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
                      A = ------------------------
                      &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;
                      &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
                      B = ------------------------
                      &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;
                      &lt;/pre&gt;
                      &lt;/p&gt;
                      &lt;p&gt;In fact, we can assume both a and &amp;omega; are positive and
                      compute them directly, knowing that A = a&lt;sup&gt;2&lt;/sup&gt; &amp;omega;&lt;sup&gt;2&lt;/sup&gt; and that
                      B = - &amp;omega;&lt;sup&gt;2&lt;/sup&gt;. The complete algorithm is therefore:&lt;/p&gt;
                      &lt;pre&gt;
                      for each t&lt;sub&gt;i&lt;/sub&gt; from t&lt;sub&gt;1&lt;/sub&gt; to t&lt;sub&gt;n-1&lt;/sub&gt;, compute:
                      f  (t&lt;sub&gt;i&lt;/sub&gt;)
                      f&apos; (t&lt;sub&gt;i&lt;/sub&gt;) = (f (t&lt;sub&gt;i+1&lt;/sub&gt;) - f(t&lt;sub&gt;i-1&lt;/sub&gt;)) / (t&lt;sub&gt;i+1&lt;/sub&gt; - t&lt;sub&gt;i-1&lt;/sub&gt;)
                      x&lt;sub&gt;i&lt;/sub&gt; = t&lt;sub&gt;i&lt;/sub&gt; - t&lt;sub&gt;1&lt;/sub&gt;
                      y&lt;sub&gt;i&lt;/sub&gt; = &amp;int; f&lt;sup&gt;2&lt;/sup&gt; from t&lt;sub&gt;1&lt;/sub&gt; to t&lt;sub&gt;i&lt;/sub&gt;
                      z&lt;sub&gt;i&lt;/sub&gt; = &amp;int; f&apos;&lt;sup&gt;2&lt;/sup&gt; from t&lt;sub&gt;1&lt;/sub&gt; to t&lt;sub&gt;i&lt;/sub&gt;
                      update the sums &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt;, &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;, &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;, &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; and &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
                      end for
                      |--------------------------
                      \  | &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
                      a     =  \ | ------------------------
                      \| &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
                      |--------------------------
                      \  | &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;z&lt;sub&gt;i&lt;/sub&gt;
                      &amp;omega;     =  \ | ------------------------
                      \| &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;x&lt;sub&gt;i&lt;/sub&gt; &amp;sum;y&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; - &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt; &amp;sum;x&lt;sub&gt;i&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;
                      &lt;/pre&gt;
                      &lt;/p&gt;
                      &lt;p&gt;Once we know &amp;omega;, we can compute:
                      &lt;pre&gt;
                      fc = &amp;omega; f (t) cos (&amp;omega; t) - f&apos; (t) sin (&amp;omega; t)
                      fs = &amp;omega; f (t) sin (&amp;omega; t) + f&apos; (t) cos (&amp;omega; t)
                      &lt;/pre&gt;
                      &lt;/p&gt;
                      &lt;p&gt;It appears that &lt;code&gt;fc = a &amp;omega; cos (&amp;phi;)&lt;/code&gt; and
                      &lt;code&gt;fs = -a &amp;omega; sin (&amp;phi;)&lt;/code&gt;, so we can use these
                      expressions to compute &amp;phi;. The best estimate over the sample is
                      given by averaging these expressions.
                      &lt;/p&gt;
                      &lt;p&gt;Since integrals and means are involved in the preceding
                      estimations, these operations run in O(n) time, where n is the
                      number of measurements.&lt;/p&gt;                    
                </javadoc>
                <declaration name="a" type="double" line="179"/>
                <javadoc line="179">
                    Amplitude.                    
                </javadoc>
                <declaration name="omega" type="double" line="181"/>
                <javadoc line="181">
                    Angular frequency.                    
                </javadoc>
                <declaration name="phi" type="double" line="183"/>
                <javadoc line="183">
                    Phase.                    
                </javadoc>
                <javadoc line="186">
                    Simple constructor.                    
                    <@param>
                        m observations Sampled observations.                        
                    </@param>
                    <@throws>
                        s NumberIsTooSmallException if the sample is too short.                        
                    </@throws>
                    <@throws>
                        s ZeroException if the abscissa range is zero.                        
                    </@throws>
                    <@throws>
                        s MathIllegalStateException when the guessing procedure cannot
                          produce sensible results.                        
                    </@throws>
                </javadoc>
                <method name="ParameterGuesser" type="constructor" line="195">
                    <params>
                        <param name="observations" type="WeightedObservedPoint[]"/>
                    </params>
                    <scope line="196"/>
                    <declaration name="sorted" type="WeightedObservedPoint[]" line="201"/>
                    <declaration name="aOmega" type="double" line="203"/>
                </method>
                <javadoc line="210">
                    Gets an estimation of the parameters.                    
                    <@return>
                        n the guessed parameters, in the following order:
                          <ul>
                          <li>Amplitude</li>
                          <li>Angular frequency</li>
                          <li>Phase</li>
                          </ul>                        
                    </@return>
                </javadoc>
                <method name="guess" type="double[]" line="220"/>
                <javadoc line="224">
                    Sort the observations with respect to the abscissa.                    
                    <@param>
                        m unsorted Input observations.                        
                    </@param>
                    <@return>
                        n the input observations, sorted.                        
                    </@return>
                </javadoc>
                <method name="sortObservations" type="WeightedObservedPoint[]" line="230">
                    <params>
                        <param name="unsorted" type="WeightedObservedPoint[]"/>
                    </params>
                    <comment line="231">
                        Since the samples are almost always already sorted, this                        
                    </comment>
                    <comment line="231">
                        method is implemented as an insertion sort that reorders the                        
                    </comment>
                    <comment line="231">
                        elements in place. Insertion sort is very efficient in this case.                        
                    </comment>
                    <declaration name="observations" type="WeightedObservedPoint[]" line="231"/>
                    <declaration name="curr" type="WeightedObservedPoint" line="236"/>
                    <scope line="237">
                        <declaration name="prec" type="WeightedObservedPoint" line="238"/>
                        <scope line="240">
                            <declaration name="i" type="int" line="242"/>
                            <declaration name="mI" type="WeightedObservedPoint" line="243"/>
                            <scope line="244">
                                <scope line="246"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="258">
                    Estimate a first guess of the amplitude and angular frequency.
                      This method assumes that the {@link #sortObservations()} method
                      has been called previously.                    
                    <@param>
                        m observations Observations, sorted w.r.t. abscissa.                        
                    </@param>
                    <@throws>
                        s ZeroException if the abscissa range is zero.                        
                    </@throws>
                    <@throws>
                        s MathIllegalStateException when the guessing procedure cannot
                          produce sensible results.                        
                    </@throws>
                    <@return>
                        n the guessed amplitude (at index 0) and circular frequency
                          (at index 1).                        
                    </@return>
                </javadoc>
                <method name="guessAOmega" type="double[]" line="270">
                    <params>
                        <param name="observations" type="WeightedObservedPoint[]"/>
                    </params>
                    <comment line="271">
                        initialize the sums for the linear model between the two integrals                        
                    </comment>
                    <comment line="271">
                        compute the amplitude and pulsation coefficients                        
                    </comment>
                    <declaration name="aOmega" type="double[]" line="271"/>
                    <declaration name="sx2" type="double" line="274"/>
                    <declaration name="sy2" type="double" line="275"/>
                    <declaration name="sxy" type="double" line="276"/>
                    <declaration name="sxz" type="double" line="277"/>
                    <declaration name="syz" type="double" line="278"/>
                    <declaration name="currentX" type="double" line="280"/>
                    <declaration name="currentY" type="double" line="281"/>
                    <declaration name="f2Integral" type="double" line="282"/>
                    <declaration name="fPrime2Integral" type="double" line="283"/>
                    <declaration name="startX" type="double" line="284"/>
                    <scope line="285">
                        <declaration name="previousX" type="double" line="287"/>
                        <declaration name="previousY" type="double" line="288"/>
                        <declaration name="dx" type="double" line="294"/>
                        <declaration name="dy" type="double" line="295"/>
                        <declaration name="f2StepIntegral" type="double" line="296"/>
                        <declaration name="fPrime2StepIntegral" type="double" line="298"/>
                        <declaration name="x" type="double" line="300"/>
                    </scope>
                    <declaration name="c1" type="double" line="312"/>
                    <declaration name="c2" type="double" line="313"/>
                    <declaration name="c3" type="double" line="314"/>
                    <scope line="315">
                        <declaration name="last" type="int" line="316"/>
                        <declaration name="xRange" type="double" line="319"/>
                        <scope line="320"/>
                        <declaration name="yMin" type="double" line="325"/>
                        <declaration name="yMax" type="double" line="326"/>
                        <scope line="327">
                            <declaration name="y" type="double" line="328"/>
                            <scope line="329"/>
                            <scope line="332"/>
                        </scope>
                    </scope>
                    <scope line="337">
                        <scope line="338"/>
                    </scope>
                </method>
                <javadoc line="351">
                    Estimate a first guess of the phase.                    
                    <@param>
                        m observations Observations, sorted w.r.t. abscissa.                        
                    </@param>
                    <@return>
                        n the guessed phase.                        
                    </@return>
                </javadoc>
                <method name="guessPhi" type="double" line="357">
                    <params>
                        <param name="observations" type="WeightedObservedPoint[]"/>
                    </params>
                    <comment line="358">
                        initialize the means                        
                    </comment>
                    <declaration name="fcMean" type="double" line="359"/>
                    <declaration name="fsMean" type="double" line="360"/>
                    <declaration name="currentX" type="double" line="362"/>
                    <declaration name="currentY" type="double" line="363"/>
                    <scope line="364">
                        <declaration name="previousX" type="double" line="366"/>
                        <declaration name="previousY" type="double" line="367"/>
                        <declaration name="currentYPrime" type="double" line="370"/>
                        <declaration name="omegaX" type="double" line="372"/>
                        <declaration name="cosine" type="double" line="373"/>
                        <declaration name="sine" type="double" line="374"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>