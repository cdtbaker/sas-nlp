<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optimization.direct">
        <import package="org.apache.commons.math3.analysis.MultivariateFunction"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="MultivariateFunctionPenaltyAdapter" line="26">
            <implements interface="MultivariateFunction"/>
            <javadoc line="26">
                &lt;p&gt;Adapter extending bounded {@link MultivariateFunction} to an unbouded
                  domain using a penalty function.&lt;/p&gt;
                  &lt;p&gt;
                  This adapter can be used to wrap functions subject to simple bounds on
                  parameters so they can be used by optimizers that do &lt;em&gt;not&lt;/em&gt; directly
                  support simple bounds.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The principle is that the user function that will be wrapped will see its
                  parameters bounded as required, i.e when its {@code value} method is called
                  with argument array {@code point}, the elements array will fulfill requirement{@code lower[i] &lt;= point[i] &lt;= upper[i]} for all i. Some of the components
                  may be unbounded or bounded only on one side if the corresponding bound is
                  set to an infinite value. The optimizer will not manage the user function by
                  itself, but it will handle this adapter and it is this adapter that will take
                  care the bounds are fulfilled. The adapter {@link #value(double[])} method will
                  be called by the optimizer with unbound parameters, and the adapter will check
                  if the parameters is within range or not. If it is in range, then the underlying
                  user function will be called, and if it is not the value of a penalty function
                  will be returned instead.
                  &lt;/p&gt;
                  &lt;p&gt;
                  This adapter is only a poor man solution to simple bounds optimization constraints
                  that can be used with simple optimizers like {@link SimplexOptimizer} with {@link NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use
                  an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or{@link BOBYQAOptimizer}. One caveat of this poor man solution is that if start point
                  or start simplex is completely outside of the allowed range, only the penalty function
                  is used, and the optimizer may converge without ever entering the range.
                  &lt;/p&gt;                
                <@see>
                    e MultivariateFunctionMappingAdapter                    
                </@see>
                <@version>
                    n $Id: MultivariateFunctionPenaltyAdapter.java 1422230 2012-12-15 12:11:13Z erans $                    
                </@version>
                <@deprecated>
                    d As of 3.1 (to be removed in 4.0).                    
                </@deprecated>
                <@since>
                    e 3.0                    
                </@since>
            </javadoc>
            <declaration name="bounded" type="MultivariateFunction" line="69"/>
            <javadoc line="69">
                Underlying bounded function.                
            </javadoc>
            <declaration name="lower" type="double[]" line="72"/>
            <javadoc line="72">
                Lower bounds.                
            </javadoc>
            <declaration name="upper" type="double[]" line="75"/>
            <javadoc line="75">
                Upper bounds.                
            </javadoc>
            <declaration name="offset" type="double" line="78"/>
            <javadoc line="78">
                Penalty offset.                
            </javadoc>
            <declaration name="scale" type="double[]" line="81"/>
            <javadoc line="81">
                Penalty scales.                
            </javadoc>
            <javadoc line="84">
                Simple constructor.
                  &lt;p&gt;
                  When the optimizer provided points are out of range, the value of the
                  penalty function will be used instead of the value of the underlying
                  function. In order for this penalty to be effective in rejecting this
                  point during the optimization process, the penalty function value should
                  be defined with care. This value is computed as:
                  &lt;pre&gt;
                  penalty(point) = offset + &amp;sum;&lt;sub&gt;i&lt;/sub&gt;[scale[i]  &amp;radic;|point[i]-boundary[i]|]
                  &lt;/pre&gt;
                  where indices i correspond to all the components that violates their boundaries.
                  &lt;/p&gt;
                  &lt;p&gt;
                  So when attempting a function minimization, offset should be larger than
                  the maximum expected value of the underlying function and scale components
                  should all be positive. When attempting a function maximization, offset
                  should be lesser than the minimum expected value of the underlying function
                  and scale components should all be negative.
                  minimization, and lesser than the minimum expected value of the underlying
                  function when attempting maximization.
                  &lt;/p&gt;
                  &lt;p&gt;
                  These choices for the penalty function have two properties. First, all out
                  of range points will return a function value that is worse than the value
                  returned by any in range point. Second, the penalty is worse for large
                  boundaries violation than for small violations, so the optimizer has an hint
                  about the direction in which it should search for acceptable points.
                  &lt;/p&gt;                
                <@param>
                    m bounded bounded function                    
                </@param>
                <@param>
                    m lower lower bounds for each element of the input parameters array
                      (some elements may be set to {@code Double.NEGATIVE_INFINITY} for
                      unbounded values)                    
                </@param>
                <@param>
                    m upper upper bounds for each element of the input parameters array
                      (some elements may be set to {@code Double.POSITIVE_INFINITY} for
                      unbounded values)                    
                </@param>
                <@param>
                    m offset base offset of the penalty function                    
                </@param>
                <@param>
                    m scale scale of the penalty function                    
                </@param>
                <@exception>
                    n DimensionMismatchException if lower bounds, upper bounds and
                      scales are not consistent, either according to dimension or to bounadary
                      values                    
                </@exception>
            </javadoc>
            <method name="MultivariateFunctionPenaltyAdapter" type="constructor" line="127">
                <params>
                    <param name="bounded" type="MultivariateFunction"/>
                    <param name="lower" type="double[]"/>
                    <param name="upper" type="double[]"/>
                    <param name="offset" type="double"/>
                    <param name="scale" type="double[]"/>
                </params>
                <comment line="128">
                    safety checks                    
                </comment>
                <scope line="133"/>
                <scope line="136"/>
                <scope line="139">
                    <scope line="141"/>
                </scope>
            </method>
            <javadoc line="154">
                Compute the underlying function value from an unbounded point.
                  &lt;p&gt;
                  This method simply returns the value of the underlying function
                  if the unbounded point already fulfills the bounds, and compute
                  a replacement value using the offset and scale if bounds are
                  violated, without calling the function at all.
                  &lt;/p&gt;                
                <@param>
                    m point unbounded point                    
                </@param>
                <@return>
                    n either underlying function value or penalty function value                    
                </@return>
            </javadoc>
            <method name="value" type="double" line="164">
                <params>
                    <param name="point" type="double[]"/>
                </params>
                <comment line="165">
                    all boundaries are fulfilled, we are in the expected                    
                </comment>
                <comment line="165">
                    domain of the underlying function                    
                </comment>
                <scope line="166">
                    <scope line="167">
                        <declaration name="sum" type="double" line="169"/>
                        <scope line="170">
                            <declaration name="overshoot" type="double" line="171"/>
                            <scope line="172"/>
                            <scope line="174"/>
                            <scope line="176"/>
                        </scope>
                    </scope>
                </scope>
            </method>
        </class>
    </source>