<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.nonstiff">
  <import name="java.util.Arrays" />
  <import name="java.util.HashMap" />
  <import name="java.util.Map" />
  <import name="org.apache.commons.math3.fraction.BigFraction" />
  <import name="org.apache.commons.math3.linear.Array2DRowFieldMatrix" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.linear.ArrayFieldVector" />
  <import name="org.apache.commons.math3.linear.FieldDecompositionSolver" />
  <import name="org.apache.commons.math3.linear.FieldLUDecomposition" />
  <import name="org.apache.commons.math3.linear.FieldMatrix" />
  <import name="org.apache.commons.math3.linear.MatrixUtils" />
  <import name="org.apache.commons.math3.linear.QRDecomposition" />
  <import name="org.apache.commons.math3.linear.RealMatrix" />
  <class name="AdamsNordsieckTransformer" startLine="35">
    <javadoc>
      <text>* Transformer to Nordsieck vectors for Adams integrators.
 * <p>This class is used by {@link AdamsBashforthIntegrator Adams-Bashforth} and{@link AdamsMoultonIntegrator Adams-Moulton} integrators to convert between
 * classical representation with several previous first derivatives and Nordsieck
 * representation with higher order scaled derivatives.</p>
 * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:
 * <pre>
 * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative
 * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative
 * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative
 * ...
 * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative
 * </pre></p>
 * <p>With the previous definition, the classical representation of multistep methods
 * uses first derivatives only, i.e. it handles y<sub>n</sub>, s<sub>1</sub>(n) and
 * q<sub>n</sub> where q<sub>n</sub> is defined as:
 * <pre>
 * q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>
 * </pre>
 * (we omit the k index in the notation for clarity).</p>
 * <p>Another possible representation uses the Nordsieck vector with
 * higher degrees scaled derivatives all taken at the same step, i.e it handles y<sub>n</sub>,
 * s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:
 * <pre>
 * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>
 * </pre>
 * (here again we omit the k index in the notation for clarity)
 * </p>
 * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be
 * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact
 * for degree k polynomials.
 * <pre>
 * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j&gt;1</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)
 * </pre>
 * The previous formula can be used with several values for i to compute the transform between
 * classical representation and Nordsieck vector at step end. The transform between r<sub>n</sub>
 * and q<sub>n</sub> resulting from the Taylor series formulas above is:
 * <pre>
 * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>
 * </pre>
 * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built
 * with the j (-i)<sup>j-1</sup> terms:
 * <pre>
 * [  -2   3   -4    5  ... ]
 * [  -4  12  -32   80  ... ]
 * P =  [  -6  27 -108  405  ... ]
 * [  -8  48 -256 1280  ... ]
 * [          ...           ]
 * </pre></p>
 * <p>Changing -i into +i in the formula above can be used to compute a similar transform between
 * classical representation and Nordsieck vector at step start. The resulting matrix is simply
 * the absolute value of matrix P.</p>
 * <p>For {@link AdamsBashforthIntegrator Adams-Bashforth} method, the Nordsieck vector
 * at step n+1 is computed from the Nordsieck vector at step n as follows:
 * <ul>
 * <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>
 * <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>
 * <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>
 * </ul>
 * where A is a rows shifting matrix (the lower left part is an identity matrix):
 * <pre>
 * [ 0 0   ...  0 0 | 0 ]
 * [ ---------------+---]
 * [ 1 0   ...  0 0 | 0 ]
 * A = [ 0 1   ...  0 0 | 0 ]
 * [       ...      | 0 ]
 * [ 0 0   ...  1 0 | 0 ]
 * [ 0 0   ...  0 1 | 0 ]
 * </pre></p>
 * <p>For {@link AdamsMoultonIntegrator Adams-Moulton} method, the predicted Nordsieck vector
 * at step n+1 is computed from the Nordsieck vector at step n as follows:
 * <ul>
 * <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>
 * <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>
 * <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>
 * </ul>
 * From this predicted vector, the corrected vector is computed as follows:
 * <ul>
 * <li>y<sub>n+1</sub> = y<sub>n</sub> + S<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>
 * <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>
 * <li>r<sub>n+1</sub> = R<sub>n+1</sub> + (s<sub>1</sub>(n+1) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>
 * </ul>
 * where the upper case Y<sub>n+1</sub>, S<sub>1</sub>(n+1) and R<sub>n+1</sub> represent the
 * predicted states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>
 * represent the corrected states.</p>
 * <p>We observe that both methods use similar update formulas. In both cases a P<sup>-1</sup>u
 * vector and a P<sup>-1</sup> A P matrix are used that do not depend on the state,
 * they only depend on k. This class handles these transformations.</p></text>
      <version>$Id: AdamsNordsieckTransformer.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Cache for already computed coefficients.</text>
    </javadoc>
    <declaration type="Map<Integer,AdamsNordsieckTransformer>" name="CACHE" />
    <javadoc>
      <text>* Update matrix for the higher order derivatives h<sup>2</sup>/2y'', h<sup>3</sup>/6 y''' ...</text>
    </javadoc>
    <declaration type="Array2DRowRealMatrix" name="update" />
    <javadoc>
      <text>* Update coefficients of the higher order derivatives wrt y'.</text>
    </javadoc>
    <declaration type="double[]" name="c1" />
    <javadoc>
      <text>* Simple constructor.</text>
      <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
    </javadoc>
    <method type="constructor" name="AdamsNordsieckTransformer" startLine="151" endLine="183">
      <declaration type="FieldMatrix<BigFraction>" name="bigP" />
      <declaration type="FieldDecompositionSolver<BigFraction>" name="pSolver" />
      <declaration type="BigFraction[]" name="u" />
      <declaration type="BigFraction[]" name="bigC1" />
      <declaration type="BigFraction[][]" name="shiftedP" />
      <scope startLine="167" endLine="170">
        <comment>shift rows</comment>
      </scope>
      <declaration type="FieldMatrix<BigFraction>" name="bigMSupdate" />
      <scope startLine="179" endLine="181" />
      <comment>compute exact coefficients</comment>
      <comment>update coefficients are computed by combining transform from</comment>
      <comment>Nordsieck to multistep, then shifting rows to represent step advance</comment>
      <comment>then applying inverse transform</comment>
      <comment>convert coefficients to double</comment>
    </method>
    <javadoc>
      <text>* Get the Nordsieck transformer for a given number of steps.</text>
      <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
      <return>Nordsieck transformer for the specified number of steps</return>
    </javadoc>
    <method type="AdamsNordsieckTransformer" name="getInstance" startLine="190" endLine="199">
      <scope startLine="191" endLine="198">
        <declaration type="AdamsNordsieckTransformer" name="t" />
        <scope startLine="193" endLine="196" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the number of steps of the method
 * (excluding the one being computed).</text>
      <return>number of steps of the method
 * (excluding the one being computed)</return>
    </javadoc>
    <method type="int" name="getNSteps" startLine="206" endLine="208" />
    <javadoc>
      <text>* Build the P matrix.
 * <p>The P matrix general terms are shifted j (-i)<sup>j-1</sup> terms:
 * <pre>
 * [  -2   3   -4    5  ... ]
 * [  -4  12  -32   80  ... ]
 * P =  [  -6  27 -108  405  ... ]
 * [  -8  48 -256 1280  ... ]
 * [          ...           ]
 * </pre></p></text>
      <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
      <return>P matrix</return>
    </javadoc>
    <method type="FieldMatrix<BigFraction>" name="buildP" startLine="223" endLine="240">
      <declaration type="BigFraction[][]" name="pData" />
      <scope startLine="227" endLine="236">
        <declaration type="BigFraction[]" name="pI" />
        <declaration type="int" name="factor" />
        <declaration type="int" name="aj" />
        <scope startLine="232" endLine="235" />
        <comment>build the P matrix elements from Taylor series formulas</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Initialize the high order scaled derivatives at step start.</text>
      <param>h step size to use for scaling</param>
      <param>t first steps times</param>
      <param>y first steps states</param>
      <param>yDot first steps derivatives</param>
      <return>Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,
 * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)</return>
    </javadoc>
    <method type="Array2DRowRealMatrix" name="initializeHighOrderDerivatives" startLine="252" endLine="297">
      <declaration type="double[][]" name="a" />
      <declaration type="double[][]" name="b" />
      <declaration type="double[]" name="y0" />
      <declaration type="double[]" name="yDot0" />
      <scope startLine="263" endLine="289">
        <declaration type="double" name="di" />
        <declaration type="double" name="ratio" />
        <declaration type="double" name="dikM1Ohk" />
        <declaration type="double[]" name="aI" />
        <declaration type="double[]" name="aDotI" />
        <scope startLine="273" endLine="277" />
        <declaration type="double[]" name="yI" />
        <declaration type="double[]" name="yDotI" />
        <declaration type="double[]" name="bI" />
        <declaration type="double[]" name="bDotI" />
        <scope startLine="284" endLine="287" />
        <comment>linear coefficients of equations</comment>
        <comment>y(ti) - y(t0) - di y'(t0) and y'(ti) - y'(t0)</comment>
        <comment>expected value of the previous equations</comment>
      </scope>
      <declaration type="QRDecomposition" name="decomposition" />
      <declaration type="RealMatrix" name="x" />
      <comment>using Taylor series with di = ti - t0, we get:</comment>
      <comment>y(ti)  - y(t0)  - di y'(t0) =   di^2 / h^2 s2 + ... +   di^k     / h^k sk + O(h^(k+1))</comment>
      <comment>y'(ti) - y'(t0)             = 2 di   / h^2 s2 + ... + k di^(k-1) / h^k sk + O(h^k)</comment>
      <comment>we write these relations for i = 1 to i= n-1 as a set of 2(n-1) linear</comment>
      <comment>equations depending on the Nordsieck vector [s2 ... sk]</comment>
      <comment>solve the rectangular system in the least square sense</comment>
      <comment>to get the best estimate of the Nordsieck vector [s2 ... sk]</comment>
    </method>
    <javadoc>
      <text>* Update the high order scaled derivatives for Adams integrators (phase 1).
 * <p>The complete update of high order derivatives has a form similar to:
 * <pre>
 * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>
 * </pre>
 * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p></text>
      <param>highOrder high order scaled derivatives
 * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))</param>
      <return>updated high order derivatives</return>
      <see>#updateHighOrderDerivativesPhase2(double[],double[],Array2DRowRealMatrix)</see>
    </javadoc>
    <method type="Array2DRowRealMatrix" name="updateHighOrderDerivativesPhase1" startLine="310" endLine="312" />
    <javadoc>
      <text>* Update the high order scaled derivatives Adams integrators (phase 2).
 * <p>The complete update of high order derivatives has a form similar to:
 * <pre>
 * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>
 * </pre>
 * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>
 * <p>Phase 1 of the update must already have been performed.</p></text>
      <param>start first order scaled derivatives at step start</param>
      <param>end first order scaled derivatives at step end</param>
      <param>highOrder high order scaled derivatives, will be modified
 * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))</param>
      <see>#updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)</see>
    </javadoc>
    <method type="void" name="updateHighOrderDerivativesPhase2" startLine="329" endLine="338">
      <declaration type="double[][]" name="data" />
      <scope startLine="331" endLine="337">
        <declaration type="double[]" name="dataI" />
        <declaration type="double" name="c1I" />
        <scope startLine="334" endLine="336" />
      </scope>
    </method>
  </class>
</source>
