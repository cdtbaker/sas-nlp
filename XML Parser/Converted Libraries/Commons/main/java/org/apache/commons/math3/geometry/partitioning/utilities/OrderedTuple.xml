<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.partitioning.utilities">
  <import name="java.util.Arrays" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="OrderedTuple" startLine="23">
    <implements name="Comparable<OrderedTuple>" />
    <javadoc>
      <text>* This class implements an ordering operation for T-uples.
 * <p>Ordering is done by encoding all components of the T-uple into a
 * single scalar value and using this value as the sorting
 * key. Encoding is performed using the method invented by Georg
 * Cantor in 1877 when he proved it was possible to establish a
 * bijection between a line and a plane. The binary representations of
 * the components of the T-uple are mixed together to form a single
 * scalar. This means that the 2<sup>k</sup> bit of component 0 is
 * followed by the 2<sup>k</sup> bit of component 1, then by the
 * 2<sup>k</sup> bit of component 2 up to the 2<sup>k</sup> bit of
 * component {@code t}, which is followed by the 2<sup>k-1</sup>
 * bit of component 0, followed by the 2<sup>k-1</sup> bit of
 * component 1 ... The binary representations are extended as needed
 * to handle numbers with different scales and a suitable
 * 2<sup>p</sup> offset is added to the components in order to avoid
 * negative numbers (this offset is adjusted as needed during the
 * comparison operations).</p>
 * <p>The more interesting property of the encoding method for our
 * purpose is that it allows to select all the points that are in a
 * given range. This is depicted in dimension 2 by the following
 * picture:</p>
 * <img src="doc-files/OrderedTuple.png" />
 * <p>This picture shows a set of 100000 random 2-D pairs having their
 * first component between -50 and +150 and their second component
 * between -350 and +50. We wanted to extract all pairs having their
 * first component between +30 and +70 and their second component
 * between -120 and -30. We built the lower left point at coordinates
 * (30, -120) and the upper right point at coordinates (70, -30). All
 * points smaller than the lower left point are drawn in red and all
 * points larger than the upper right point are drawn in blue. The
 * green points are between the two limits. This picture shows that
 * all the desired points are selected, along with spurious points. In
 * this case, we get 15790 points, 4420 of which really belonging to
 * the desired rectangle. It is possible to extract very small
 * subsets. As an example extracting from the same 100000 points set
 * the points having their first component between +30 and +31 and
 * their second component between -91 and -90, we get a subset of 11
 * points, 2 of which really belonging to the desired rectangle.</p>
 * <p>the previous selection technique can be applied in all
 * dimensions, still using two points to define the interval. The
 * first point will have all its components set to their lower bounds
 * while the second point will have all its components set to their
 * upper bounds.</p>
 * <p>T-uples with negative infinite or positive infinite components
 * are sorted logically.</p>
 * <p>Since the specification of the {@code Comparator} interface
 * allows only {@code ClassCastException} errors, some arbitrary
 * choices have been made to handle specific cases. The rationale for
 * these choices is to keep <em>regular</em> and consistent T-uples
 * together.</p>
 * <ul>
 * <li>instances with different dimensions are sorted according to
 * their dimension regardless of their components values</li>
 * <li>instances with {@code Double.NaN} components are sorted
 * after all other ones (even after instances with positive infinite
 * components</li>
 * <li>instances with both positive and negative infinite components
 * are considered as if they had {@code Double.NaN}components</li>
 * </ul></text>
      <version>$Id: OrderedTuple.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Sign bit mask.</text>
    </javadoc>
    <declaration type="long" name="SIGN_MASK" />
    <javadoc>
      <text>* Exponent bits mask.</text>
    </javadoc>
    <declaration type="long" name="EXPONENT_MASK" />
    <javadoc>
      <text>* Mantissa bits mask.</text>
    </javadoc>
    <declaration type="long" name="MANTISSA_MASK" />
    <javadoc>
      <text>* Implicit MSB for normalized numbers.</text>
    </javadoc>
    <declaration type="long" name="IMPLICIT_ONE" />
    <javadoc>
      <text>* Double components of the T-uple.</text>
    </javadoc>
    <declaration type="double[]" name="components" />
    <javadoc>
      <text>* Offset scale.</text>
    </javadoc>
    <declaration type="int" name="offset" />
    <javadoc>
      <text>* Least Significant Bit scale.</text>
    </javadoc>
    <declaration type="int" name="lsb" />
    <javadoc>
      <text>* Ordering encoding of the double components.</text>
    </javadoc>
    <declaration type="long[]" name="encoding" />
    <javadoc>
      <text>* Positive infinity marker.</text>
    </javadoc>
    <declaration type="boolean" name="posInf" />
    <javadoc>
      <text>* Negative infinity marker.</text>
    </javadoc>
    <declaration type="boolean" name="negInf" />
    <javadoc>
      <text>* Not A Number marker.</text>
    </javadoc>
    <declaration type="boolean" name="nan" />
    <javadoc>
      <text>* Build an ordered T-uple from its components.</text>
      <param>components double components of the T-uple</param>
    </javadoc>
    <method type="constructor" name="OrderedTuple" startLine="132" endLine="175">
      <declaration type="int" name="msb" />
      <scope startLine="139" endLine="157">
        <scope startLine="140" endLine="146">
          <scope startLine="141" endLine="143" />
          <scope startLine="143" endLine="145" />
        </scope>
        <scope startLine="146" endLine="148" />
        <scope startLine="148" endLine="156">
          <declaration type="long" name="b" />
          <declaration type="long" name="m" />
          <scope startLine="151" endLine="155">
            <declaration type="int" name="e" />
          </scope>
        </scope>
      </scope>
      <scope startLine="159" endLine="164">
        <comment>instance cannot be sorted logically</comment>
      </scope>
      <scope startLine="166" endLine="169">
        <comment>encode the T-upple with the specified offset</comment>
      </scope>
      <scope startLine="169" endLine="173" />
    </method>
    <javadoc>
      <text>* Encode the T-uple with a given offset.</text>
      <param>minOffset minimal scale of the offset to add to all
 * components (must be greater than the MSBs of all components)</param>
    </javadoc>
    <method type="void" name="encode" startLine="181" endLine="215">
      <scope startLine="187" endLine="190">
        <comment>the components are all zeroes</comment>
      </scope>
      <declaration type="int" name="neededBits" />
      <declaration type="int" name="neededLongs" />
      <declaration type="int" name="eIndex" />
      <declaration type="int" name="shift" />
      <declaration type="long" name="word" />
      <scope startLine="202" endLine="213">
        <scope startLine="203" endLine="212">
          <scope startLine="204" endLine="206" />
          <scope startLine="207" endLine="211" />
        </scope>
      </scope>
      <comment>choose an offset with some margins</comment>
      <comment>allocate an integer array to encode the components (we use only</comment>
      <comment>63 bits per element because there is no unsigned long in Java)</comment>
      <comment>mix the bits from all components</comment>
    </method>
    <javadoc>
      <text>* Compares this ordered T-uple with the specified object.
 * <p>The ordering method is detailed in the general description of
 * the class. Its main property is to be consistent with distance:
 * geometrically close T-uples stay close to each other when stored
 * in a sorted collection using this comparison method.</p>
 * <p>T-uples with negative infinite, positive infinite are sorted
 * logically.</p>
 * <p>Some arbitrary choices have been made to handle specific
 * cases. The rationale for these choices is to keep
 * <em>normal</em> and consistent T-uples together.</p>
 * <ul>
 * <li>instances with different dimensions are sorted according to
 * their dimension regardless of their components values</li>
 * <li>instances with {@code Double.NaN} components are sorted
 * after all other ones (evan after instances with positive infinite
 * components</li>
 * <li>instances with both positive and negative infinite components
 * are considered as if they had {@code Double.NaN}components</li>
 * </ul></text>
      <param>ot T-uple to compare instance with</param>
      <return>a negative integer if the instance is less than the
 * object, zero if they are equal, or a positive integer if the
 * instance is greater than the object</return>
    </javadoc>
    <method type="int" name="compareTo" startLine="247" endLine="287">
      <scope startLine="248" endLine="283">
        <scope startLine="249" endLine="251" />
        <scope startLine="251" endLine="253" />
        <scope startLine="253" endLine="255" />
        <scope startLine="255" endLine="257" />
        <scope startLine="257" endLine="282">
          <scope startLine="259" endLine="261" />
          <scope startLine="261" endLine="263" />
          <declaration type="int" name="limit" />
          <scope startLine="266" endLine="272">
            <scope startLine="267" endLine="269" />
            <scope startLine="269" endLine="271" />
          </scope>
          <scope startLine="274" endLine="276" />
          <scope startLine="276" endLine="278" />
          <scope startLine="278" endLine="280" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="equals" startLine="291" endLine="299">
      <scope startLine="292" endLine="294" />
      <scope startLine="294" endLine="296" />
      <scope startLine="296" endLine="298" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="int" name="hashCode" startLine="303" endLine="321">
      <declaration type="int" name="multiplier" />
      <declaration type="int" name="trueHash" />
      <declaration type="int" name="falseHash" />
      <declaration type="int" name="hash" />
      <comment>the following constants are arbitrary small primes</comment>
      <comment>hash fields and combine them</comment>
      <comment>(we rely on the multiplier to have different combined weights</comment>
      <comment>for all int fields and all boolean fields)</comment>
    </method>
    <javadoc>
      <text>* Get the components array.</text>
      <return>array containing the T-uple components</return>
    </javadoc>
    <method type="double[]" name="getComponents" startLine="326" endLine="328" />
    <javadoc>
      <text>* Extract the sign from the bits of a double.</text>
      <param>bits binary representation of the double</param>
      <return>sign bit (zero if positive, non zero if negative)</return>
    </javadoc>
    <method type="long" name="sign" startLine="334" endLine="336" />
    <javadoc>
      <text>* Extract the exponent from the bits of a double.</text>
      <param>bits binary representation of the double</param>
      <return>exponent</return>
    </javadoc>
    <method type="int" name="exponent" startLine="342" endLine="344" />
    <javadoc>
      <text>* Extract the mantissa from the bits of a double.</text>
      <param>bits binary representation of the double</param>
      <return>mantissa</return>
    </javadoc>
    <method type="long" name="mantissa" startLine="350" endLine="354">
      <comment>subnormal number</comment>
      <comment>normal number</comment>
    </method>
    <javadoc>
      <text>* Compute the most significant bit of a long.</text>
      <param>l long from which the most significant bit is requested</param>
      <return>scale of the most significant bit of {@code l},
 * or 0 if {@code l} is zero</return>
      <see>#computeLSB</see>
    </javadoc>
    <method type="int" name="computeMSB" startLine="362" endLine="380">
      <declaration type="long" name="ll" />
      <declaration type="long" name="mask" />
      <declaration type="int" name="scale" />
      <declaration type="int" name="msb" />
      <scope startLine="369" endLine="376">
        <scope startLine="370" endLine="373" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the least significant bit of a long.</text>
      <param>l long from which the least significant bit is requested</param>
      <return>scale of the least significant bit of {@code l},
 * or 63 if {@code l} is zero</return>
      <see>#computeMSB</see>
    </javadoc>
    <method type="int" name="computeLSB" startLine="388" endLine="406">
      <declaration type="long" name="ll" />
      <declaration type="long" name="mask" />
      <declaration type="int" name="scale" />
      <declaration type="int" name="lsb" />
      <scope startLine="395" endLine="402">
        <scope startLine="396" endLine="399" />
      </scope>
    </method>
    <javadoc>
      <text>* Get a bit from the mantissa of a double.</text>
      <param>i index of the component</param>
      <param>k scale of the requested bit</param>
      <return>the specified bit (either 0 or 1), after the offset has
 * been added to the double</return>
    </javadoc>
    <method type="int" name="getBit" startLine="414" endLine="427">
      <declaration type="long" name="bits" />
      <declaration type="int" name="e" />
      <scope startLine="417" endLine="419" />
      <scope startLine="419" endLine="421" />
      <scope startLine="421" endLine="423" />
      <scope startLine="423" endLine="426">
        <declaration type="long" name="m" />
      </scope>
    </method>
  </class>
</source>
