<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.stat.descriptive.rank">
  <import name="java.io.Serializable" />
  <import name="java.util.Arrays" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="Percentile" extends="AbstractUnivariateStatistic" startLine="30">
    <implements name="Serializable" />
    <javadoc>
      <text>* Provides percentile computation.
 * <p>
 * There are several commonly used methods for estimating percentiles (a.k.a.
 * quantiles) based on sample data.  For large samples, the different methods
 * agree closely, but when sample sizes are small, different methods will give
 * significantly different results.  The algorithm implemented here works as follows:
 * <ol>
 * <li>Let <code>n</code> be the length of the (sorted) array and
 * <code>0 < p <= 100</code> be the desired percentile.</li>
 * <li>If <code> n = 1 </code> return the unique array element (regardless of
 * the value of <code>p</code>); otherwise </li>
 * <li>Compute the estimated percentile position
 * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>
 * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional
 * part of <code>pos</code>).</li>
 * <li> If <code>pos < 1</code> return the smallest element in the array.</li>
 * <li> Else if <code>pos >= n</code> return the largest element in the array.</li>
 * <li> Else let <code>lower</code> be the element in position
 * <code>floor(pos)</code> in the array and let <code>upper</code> be the
 * next element in the array.  Return <code>lower + d * (upper - lower)</code>
 * </li>
 * </ol></p>
 * <p>
 * To compute percentiles, the data must be at least partially ordered.  Input
 * arrays are copied and recursively partitioned using an ordering definition.
 * The ordering used by <code>Arrays.sort(double[])</code> is the one determined
 * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes
 * <code>Double.NaN</code> larger than any other value (including
 * <code>Double.POSITIVE_INFINITY</code>).  Therefore, for example, the median
 * (50th percentile) of
 * <code>{0, 1, 2, 3, 4, Double.NaN}</code> evaluates to <code>2.5.</code></p>
 * <p>
 * Since percentile estimation usually involves interpolation between array
 * elements, arrays containing  <code>NaN</code> or infinite values will often
 * result in <code>NaN</code> or infinite values returned.</p>
 * <p>
 * Since 2.2, Percentile uses only selection instead of complete sorting
 * and caches selection algorithm state between calls to the various{@code evaluate} methods. This greatly improves efficiency, both for a single
 * percentile and multiple percentile computations. To maximize performance when
 * multiple percentiles are computed based on the same data, users should set the
 * data array once using either one of the {@link #evaluate(double[],double)} or{@link #setData(double[])} methods and thereafter {@link #evaluate(double)}with just the percentile provided.
 * </p>
 * <p>
 * <strong>Note that this implementation is not synchronized.</strong> If
 * multiple threads access an instance of this class concurrently, and at least
 * one of the threads invokes the <code>increment()</code> or
 * <code>clear()</code> method, it must be synchronized externally.</p></text>
      <version>$Id: Percentile.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Minimum size under which we use a simple insertion sort rather than Hoare's select.</text>
    </javadoc>
    <declaration type="int" name="MIN_SELECT_SIZE" />
    <javadoc>
      <text>* Maximum number of partitioning pivots cached (each level double the number of pivots).</text>
    </javadoc>
    <declaration type="int" name="MAX_CACHED_LEVELS" />
    <javadoc>
      <text>* Determines what percentile is computed when evaluate() is activated
 * with no quantile argument</text>
    </javadoc>
    <declaration type="double" name="quantile" />
    <javadoc>
      <text>* Cached pivots.</text>
    </javadoc>
    <declaration type="int[]" name="cachedPivots" />
    <javadoc>
      <text>* Constructs a Percentile with a default quantile
 * value of 50.0.</text>
    </javadoc>
    <method type="constructor" name="Percentile" startLine="106" endLine="109">
      <comment>No try-catch or advertised exception here - arg is valid</comment>
    </method>
    <javadoc>
      <text>* Constructs a Percentile with the specific quantile value.</text>
      <param>p the quantile</param>
      <throws>MathIllegalArgumentException  if p is not greater than 0 and less
 * than or equal to 100</throws>
    </javadoc>
    <method type="constructor" name="Percentile" startLine="117" endLine="120" />
    <javadoc>
      <text>* Copy constructor, creates a new {@code Percentile} identical
 * to the {@code original}</text>
      <param>original the {@code Percentile} instance to copy</param>
      <throws>NullArgumentException if original is null</throws>
    </javadoc>
    <method type="constructor" name="Percentile" startLine="129" endLine="131" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="setData" startLine="135" endLine="143">
      <scope startLine="136" endLine="138" />
      <scope startLine="138" endLine="141" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="setData" startLine="148" endLine="156">
      <scope startLine="149" endLine="151" />
      <scope startLine="151" endLine="154" />
    </method>
    <javadoc>
      <text>* Returns the result of evaluating the statistic over the stored data.
 * <p>
 * The stored array is the one which was set by previous calls to{@link #setData(double[])}</p></text>
      <param>p the percentile value to compute</param>
      <return>the value of the statistic applied to the stored data</return>
      <throws>MathIllegalArgumentException if p is not a valid quantile value
 * (p must be greater than 0 and less than or equal to 100)</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="169" endLine="171" />
    <javadoc>
      <text>* Returns an estimate of the <code>p</code>th percentile of the values
 * in the <code>values</code> array.
 * <p>
 * Calls to this method do not modify the internal <code>quantile</code>
 * state of this statistic.</p>
 * <p>
 * <ul>
 * <li>Returns <code>Double.NaN</code> if <code>values</code> has length
 * <code>0</code></li>
 * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>
 * if <code>values</code> has length <code>1</code></li>
 * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>
 * is null or p is not a valid quantile value (p must be greater than 0
 * and less than or equal to 100) </li>
 * </ul></p>
 * <p>
 * See {@link Percentile} for a description of the percentile estimation
 * algorithm used.</p></text>
      <param>values input array of values</param>
      <param>p the percentile value to compute</param>
      <return>the percentile value or Double.NaN if the array is empty</return>
      <throws>MathIllegalArgumentException if <code>values</code> is null
 * or p is invalid</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="200" endLine="203" />
    <javadoc>
      <text>* Returns an estimate of the <code>quantile</code>th percentile of the
 * designated values in the <code>values</code> array.  The quantile
 * estimated is determined by the <code>quantile</code> property.
 * <p>
 * <ul>
 * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>
 * <li>Returns (for any value of <code>quantile</code>)
 * <code>values[begin]</code> if <code>length = 1 </code></li>
 * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>
 * is null, or <code>start</code> or <code>length</code> is invalid</li>
 * </ul></p>
 * <p>
 * See {@link Percentile} for a description of the percentile estimation
 * algorithm used.</p></text>
      <param>values the input array</param>
      <param>start index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the percentile value</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="230" endLine="232" />
    <javadoc>
      <text>* Returns an estimate of the <code>p</code>th percentile of the values
 * in the <code>values</code> array, starting with the element in (0-based)
 * position <code>begin</code> in the array and including <code>length</code>
 * values.
 * <p>
 * Calls to this method do not modify the internal <code>quantile</code>
 * state of this statistic.</p>
 * <p>
 * <ul>
 * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>
 * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>
 * if <code>length = 1 </code></li>
 * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>
 * is null , <code>begin</code> or <code>length</code> is invalid, or
 * <code>p</code> is not a valid quantile value (p must be greater than 0
 * and less than or equal to 100)</li>
 * </ul></p>
 * <p>
 * See {@link Percentile} for a description of the percentile estimation
 * algorithm used.</p></text>
      <param>values array of input values</param>
      <param>p  the percentile to compute</param>
      <param>begin  the first (0-based) element to include in the computation</param>
      <param>length  the number of array elements to include</param>
      <return>the percentile value</return>
      <throws>MathIllegalArgumentException if the parameters are not valid or the
 * input array is null</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="265" endLine="305">
      <scope startLine="269" endLine="272" />
      <scope startLine="273" endLine="275" />
      <scope startLine="276" endLine="278">
        <comment>always return single value for n = 1</comment>
      </scope>
      <declaration type="double" name="n" />
      <declaration type="double" name="pos" />
      <declaration type="double" name="fpos" />
      <declaration type="int" name="intPos" />
      <declaration type="double" name="dif" />
      <declaration type="double[]" name="work" />
      <declaration type="int[]" name="pivotsHeap" />
      <scope startLine="286" endLine="289" />
      <scope startLine="289" endLine="294" />
      <scope startLine="296" endLine="298" />
      <scope startLine="299" endLine="301" />
      <declaration type="double" name="lower" />
      <declaration type="double" name="upper" />
    </method>
    <javadoc>
      <text>* Select the k<sup>th</sup> smallest element from work array</text>
      <param>work work array (will be reorganized during the call)</param>
      <param>pivotsHeap set of pivot index corresponding to elements that
 * are already at their sorted location, stored as an implicit heap
 * (i.e. a sorted binary tree stored in a flat array, where the
 * children of a node at index n are at indices 2n+1 for the left
 * child and 2n+2 for the right child, with 0-based indices)</param>
      <param>k index of the desired element</param>
      <return>k<sup>th</sup> smallest element</return>
    </javadoc>
    <method type="double" name="select" startLine="318" endLine="359">
      <declaration type="int" name="begin" />
      <declaration type="int" name="end" />
      <declaration type="int" name="node" />
      <scope startLine="324" endLine="352">
        <declaration type="int" name="pivot" />
        <scope startLine="327" endLine="331" />
        <scope startLine="331" endLine="337">
          <scope startLine="334" endLine="336" />
        </scope>
        <scope startLine="339" endLine="342" />
        <scope startLine="342" endLine="346" />
        <scope startLine="346" endLine="350" />
        <comment>the pivot has already been found in a previous call</comment>
        <comment>and the array has already been partitioned around it</comment>
        <comment>select a pivot and partition work array around it</comment>
        <comment>the pivot was exactly the element we wanted</comment>
        <comment>the element is in the left partition</comment>
        <comment>the min is here to avoid integer overflow</comment>
        <comment>the element is in the right partition</comment>
        <comment>the min is here to avoid integer overflow</comment>
      </scope>
      <comment>the element is somewhere in the small sub-array</comment>
      <comment>sort the sub-array using insertion sort</comment>
    </method>
    <javadoc>
      <text>* Select a pivot index as the median of three</text>
      <param>work data array</param>
      <param>begin index of the first element of the slice</param>
      <param>end index after the last element of the slice</param>
      <return>the index of the median element chosen between the
 * first, the middle and the last element of the array slice</return>
    </javadoc>
    <method type="int" name="medianOf3" startLine="368" endLine="390">
      <declaration type="int" name="inclusiveEnd" />
      <declaration type="int" name="middle" />
      <declaration type="double" name="wBegin" />
      <declaration type="double" name="wMiddle" />
      <declaration type="double" name="wEnd" />
      <scope startLine="376" endLine="382">
        <scope startLine="377" endLine="379" />
        <scope startLine="379" endLine="381" />
      </scope>
      <scope startLine="382" endLine="388">
        <scope startLine="383" endLine="385" />
        <scope startLine="385" endLine="387" />
      </scope>
    </method>
    <javadoc>
      <text>* Partition an array slice around a pivot
 * <p>
 * Partitioning exchanges array elements such that all elements
 * smaller than pivot are before it and all elements larger than
 * pivot are after it
 * </p></text>
      <param>work data array</param>
      <param>begin index of the first element of the slice</param>
      <param>end index after the last element of the slice</param>
      <param>pivot initial index of the pivot</param>
      <return>index of the pivot after partition</return>
    </javadoc>
    <method type="int" name="partition" startLine="405" endLine="434">
      <declaration type="double" name="value" />
      <declaration type="int" name="i" />
      <declaration type="int" name="j" />
      <scope startLine="412" endLine="425">
        <scope startLine="413" endLine="415" />
        <scope startLine="416" endLine="418" />
        <scope startLine="420" endLine="424">
          <declaration type="double" name="tmp" />
        </scope>
      </scope>
      <scope startLine="427" endLine="429" />
    </method>
    <javadoc>
      <text>* Sort in place a (small) array slice using insertion sort</text>
      <param>work array to sort</param>
      <param>begin index of the first element of the slice to sort</param>
      <param>end index after the last element of the slice to sort</param>
    </javadoc>
    <method type="void" name="insertionSort" startLine="442" endLine="452">
      <scope startLine="443" endLine="451">
        <declaration type="double" name="saved" />
        <declaration type="int" name="i" />
        <scope startLine="446" endLine="449" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the value of the quantile field (determines what percentile is
 * computed when evaluate() is called with no quantile argument).</text>
      <return>quantile</return>
    </javadoc>
    <method type="double" name="getQuantile" startLine="460" endLine="462" />
    <javadoc>
      <text>* Sets the value of the quantile field (determines what percentile is
 * computed when evaluate() is called with no quantile argument).</text>
      <param>p a value between 0 < p <= 100</param>
      <throws>MathIllegalArgumentException  if p is not greater than 0 and less
 * than or equal to 100</throws>
    </javadoc>
    <method type="void" name="setQuantile" startLine="472" endLine="478">
      <scope startLine="473" endLine="476" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Percentile" name="copy" startLine="484" endLine="489">
      <declaration type="Percentile" name="result" />
      <comment>No try-catch or advertised exception because args are guaranteed non-null</comment>
    </method>
    <javadoc>
      <text>* Copies source to dest.
 * <p>Neither source nor dest can be null.</p></text>
      <param>source Percentile to copy</param>
      <param>dest Percentile to copy to</param>
      <throws>NullArgumentException if either source or dest is null</throws>
    </javadoc>
    <method type="void" name="copy" startLine="500" endLine="508">
      <scope startLine="504" endLine="506" />
    </method>
  </class>
</source>
