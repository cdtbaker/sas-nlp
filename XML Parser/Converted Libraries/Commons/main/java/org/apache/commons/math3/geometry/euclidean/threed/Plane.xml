<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <import name="org.apache.commons.math3.geometry.euclidean.oned.Vector1D" />
  <import name="org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D" />
  <import name="org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet" />
  <import name="org.apache.commons.math3.geometry.euclidean.twod.Vector2D" />
  <import name="org.apache.commons.math3.geometry.partitioning.Embedding" />
  <import name="org.apache.commons.math3.geometry.partitioning.Hyperplane" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="Plane" startLine="30">
    <implements name="Hyperplane<Euclidean3D>" />
    <implements name="Embedding<Euclidean3D,Euclidean2D>" />
    <javadoc>
      <text>* The class represent planes in a three dimensional space.</text>
      <version>$Id: Plane.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Offset of the origin with respect to the plane.</text>
    </javadoc>
    <declaration type="double" name="originOffset" />
    <javadoc>
      <text>* Origin of the plane frame.</text>
    </javadoc>
    <declaration type="Vector3D" name="origin" />
    <javadoc>
      <text>* First vector of the plane frame (in plane).</text>
    </javadoc>
    <declaration type="Vector3D" name="u" />
    <javadoc>
      <text>* Second vector of the plane frame (in plane).</text>
    </javadoc>
    <declaration type="Vector3D" name="v" />
    <javadoc>
      <text>* Third vector of the plane frame (plane normal).</text>
    </javadoc>
    <declaration type="Vector3D" name="w" />
    <javadoc>
      <text>* Build a plane normal to a given direction and containing the origin.</text>
      <param>normal normal direction to the plane</param>
      <exception>MathArithmeticException if the normal norm is too small</exception>
    </javadoc>
    <method type="constructor" name="Plane" startLine="55" endLine="59" />
    <javadoc>
      <text>* Build a plane from a point and a normal.</text>
      <param>p point belonging to the plane</param>
      <param>normal normal direction to the plane</param>
      <exception>MathArithmeticException if the normal norm is too small</exception>
    </javadoc>
    <method type="constructor" name="Plane" startLine="66" endLine="70" />
    <javadoc>
      <text>* Build a plane from three points.
 * <p>The plane is oriented in the direction of{@code (p2-p1) ^ (p3-p1)}</p></text>
      <param>p1 first point belonging to the plane</param>
      <param>p2 second point belonging to the plane</param>
      <param>p3 third point belonging to the plane</param>
      <exception>MathArithmeticException if the points do not constitute a plane</exception>
    </javadoc>
    <method type="constructor" name="Plane" startLine="81" endLine="83" />
    <javadoc>
      <text>* Copy constructor.
 * <p>The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying object are
 * shared.</p></text>
      <param>plane plane to copy</param>
    </javadoc>
    <method type="constructor" name="Plane" startLine="91" endLine="97" />
    <javadoc>
      <text>* Copy the instance.
 * <p>The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying objects are
 * shared (except for immutable objects).</p></text>
      <return>a new hyperplane, copy of the instance</return>
    </javadoc>
    <method type="Plane" name="copySelf" startLine="105" endLine="107" />
    <javadoc>
      <text>* Reset the instance as if built from a point and a normal.</text>
      <param>p point belonging to the plane</param>
      <param>normal normal direction to the plane</param>
      <exception>MathArithmeticException if the normal norm is too small</exception>
    </javadoc>
    <method type="void" name="reset" startLine="114" endLine="118" />
    <javadoc>
      <text>* Reset the instance from another one.
 * <p>The updated instance is completely independant of the original
 * one. A deep reset is used none of the underlying object is
 * shared.</p></text>
      <param>original plane to reset from</param>
    </javadoc>
    <method type="void" name="reset" startLine="126" endLine="132" />
    <javadoc>
      <text>* Set the normal vactor.</text>
      <param>normal normal direction to the plane (will be copied)</param>
      <exception>MathArithmeticException if the normal norm is too small</exception>
    </javadoc>
    <method type="void" name="setNormal" startLine="138" endLine="144">
      <declaration type="double" name="norm" />
      <scope startLine="140" endLine="142" />
    </method>
    <javadoc>
      <text>* Reset the plane frame.</text>
    </javadoc>
    <method type="void" name="setFrame" startLine="148" endLine="152" />
    <javadoc>
      <text>* Get the origin point of the plane frame.
 * <p>The point returned is the orthogonal projection of the
 * 3D-space origin in the plane.</p></text>
      <return>the origin point of the plane frame (point closest to the
 * 3D-space origin)</return>
    </javadoc>
    <method type="Vector3D" name="getOrigin" startLine="160" endLine="162" />
    <javadoc>
      <text>* Get the normalized normal vector.
 * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},{@link #getNormal getNormal}) is a rigth-handed orthonormalized
 * frame).</p></text>
      <return>normalized normal vector</return>
      <see>#getU</see>
      <see>#getV</see>
    </javadoc>
    <method type="Vector3D" name="getNormal" startLine="172" endLine="174" />
    <javadoc>
      <text>* Get the plane first canonical vector.
 * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},{@link #getNormal getNormal}) is a rigth-handed orthonormalized
 * frame).</p></text>
      <return>normalized first canonical vector</return>
      <see>#getV</see>
      <see>#getNormal</see>
    </javadoc>
    <method type="Vector3D" name="getU" startLine="184" endLine="186" />
    <javadoc>
      <text>* Get the plane second canonical vector.
 * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},{@link #getNormal getNormal}) is a rigth-handed orthonormalized
 * frame).</p></text>
      <return>normalized second canonical vector</return>
      <see>#getU</see>
      <see>#getNormal</see>
    </javadoc>
    <method type="Vector3D" name="getV" startLine="196" endLine="198" />
    <javadoc>
      <text>* Revert the plane.
 * <p>Replace the instance by a similar plane with opposite orientation.</p>
 * <p>The new plane frame is chosen in such a way that a 3D point that had{@code (x, y)} in-plane coordinates and {@code z} offset with
 * respect to the plane and is unaffected by the change will have{@code (y, x)} in-plane coordinates and {@code -z} offset with
 * respect to the new plane. This means that the {@code u} and {@code v}vectors returned by the {@link #getU} and {@link #getV} methods are exchanged,
 * and the {@code w} vector returned by the {@link #getNormal} method is
 * reversed.</p></text>
    </javadoc>
    <method type="void" name="revertSelf" startLine="211" endLine="217">
      <declaration type="Vector3D" name="tmp" />
    </method>
    <javadoc>
      <text>* Transform a 3D space point into an in-plane point.</text>
      <param>point point of the space (must be a {@link Vector3DVector3D} instance)</param>
      <return>in-plane point (really a {@link org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)</return>
      <see>#toSpace</see>
    </javadoc>
    <method type="Vector2D" name="toSubSpace" startLine="226" endLine="228" />
    <javadoc>
      <text>* Transform an in-plane point into a 3D space point.</text>
      <param>point in-plane point (must be a {@link org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)</param>
      <return>3D space point (really a {@link Vector3D Vector3D} instance)</return>
      <see>#toSubSpace</see>
    </javadoc>
    <method type="Vector3D" name="toSpace" startLine="236" endLine="239">
      <declaration type="Vector2D" name="p2D" />
    </method>
    <javadoc>
      <text>* Get one point from the 3D-space.</text>
      <param>inPlane desired in-plane coordinates for the point in the
 * plane</param>
      <param>offset desired offset for the point</param>
      <return>one point in the 3D-space, with given coordinates and offset
 * relative to the plane</return>
    </javadoc>
    <method type="Vector3D" name="getPointAt" startLine="248" endLine="250" />
    <javadoc>
      <text>* Check if the instance is similar to another plane.
 * <p>Planes are considered similar if they contain the same
 * points. This does not mean they are equal since they can have
 * opposite normals.</p></text>
      <param>plane plane to which the instance is compared</param>
      <return>true if the planes are similar</return>
    </javadoc>
    <method type="boolean" name="isSimilarTo" startLine="259" endLine="263">
      <declaration type="double" name="angle" />
    </method>
    <javadoc>
      <text>* Rotate the plane around the specified point.
 * <p>The instance is not modified, a new instance is created.</p></text>
      <param>center rotation center</param>
      <param>rotation vectorial rotation operator</param>
      <return>a new plane</return>
    </javadoc>
    <method type="Plane" name="rotate" startLine="271" endLine="283">
      <declaration type="Vector3D" name="delta" />
      <declaration type="Plane" name="plane" />
      <comment>make sure the frame is transformed as desired</comment>
    </method>
    <javadoc>
      <text>* Translate the plane by the specified amount.
 * <p>The instance is not modified, a new instance is created.</p></text>
      <param>translation translation to apply</param>
      <return>a new plane</return>
    </javadoc>
    <method type="Plane" name="translate" startLine="290" endLine="300">
      <declaration type="Plane" name="plane" />
      <comment>make sure the frame is transformed as desired</comment>
    </method>
    <javadoc>
      <text>* Get the intersection of a line with the instance.</text>
      <param>line line intersecting the instance</param>
      <return>intersection point between between the line and the
 * instance (null if the line is parallel to the instance)</return>
    </javadoc>
    <method type="Vector3D" name="intersection" startLine="307" endLine="316">
      <declaration type="Vector3D" name="direction" />
      <declaration type="double" name="dot" />
      <scope startLine="310" endLine="312" />
      <declaration type="Vector3D" name="point" />
      <declaration type="double" name="k" />
    </method>
    <javadoc>
      <text>* Build the line shared by the instance and another plane.</text>
      <param>other other plane</param>
      <return>line at the intersection of the instance and the
 * other plane (really a {@link Line Line} instance)</return>
    </javadoc>
    <method type="Line" name="intersection" startLine="323" endLine="330">
      <declaration type="Vector3D" name="direction" />
      <scope startLine="325" endLine="327" />
      <declaration type="Vector3D" name="point" />
    </method>
    <javadoc>
      <text>* Get the intersection point of three planes.</text>
      <param>plane1 first plane1</param>
      <param>plane2 second plane2</param>
      <param>plane3 third plane2</param>
      <return>intersection point of three planes, null if some planes are parallel</return>
    </javadoc>
    <method type="Vector3D" name="intersection" startLine="338" endLine="372">
      <declaration type="double" name="a1" />
      <declaration type="double" name="b1" />
      <declaration type="double" name="c1" />
      <declaration type="double" name="d1" />
      <declaration type="double" name="a2" />
      <declaration type="double" name="b2" />
      <declaration type="double" name="c2" />
      <declaration type="double" name="d2" />
      <declaration type="double" name="a3" />
      <declaration type="double" name="b3" />
      <declaration type="double" name="c3" />
      <declaration type="double" name="d3" />
      <declaration type="double" name="a23" />
      <declaration type="double" name="b23" />
      <declaration type="double" name="c23" />
      <declaration type="double" name="determinant" />
      <scope startLine="362" endLine="364" />
      <declaration type="double" name="r" />
      <comment>coefficients of the three planes linear equations</comment>
      <comment>direct Cramer resolution of the linear system</comment>
      <comment>(this is still feasible for a 3x3 system)</comment>
    </method>
    <javadoc>
      <text>* Build a region covering the whole hyperplane.</text>
      <return>a region covering the whole hyperplane</return>
    </javadoc>
    <method type="SubPlane" name="wholeHyperplane" startLine="377" endLine="379" />
    <javadoc>
      <text>* Build a region covering the whole space.</text>
      <return>a region containing the instance (really a {@link PolyhedronsSet PolyhedronsSet} instance)</return>
    </javadoc>
    <method type="PolyhedronsSet" name="wholeSpace" startLine="385" endLine="387" />
    <javadoc>
      <text>* Check if the instance contains a point.</text>
      <param>p point to check</param>
      <return>true if p belongs to the plane</return>
    </javadoc>
    <method type="boolean" name="contains" startLine="393" endLine="395" />
    <javadoc>
      <text>* Get the offset (oriented distance) of a parallel plane.
 * <p>This method should be called only for parallel planes otherwise
 * the result is not meaningful.</p>
 * <p>The offset is 0 if both planes are the same, it is
 * positive if the plane is on the plus side of the instance and
 * negative if it is on the minus side, according to its natural
 * orientation.</p></text>
      <param>plane plane to check</param>
      <return>offset of the plane</return>
    </javadoc>
    <method type="double" name="getOffset" startLine="407" endLine="409" />
    <javadoc>
      <text>* Get the offset (oriented distance) of a point.
 * <p>The offset is 0 if the point is on the underlying hyperplane,
 * it is positive if the point is on one particular side of the
 * hyperplane, and it is negative if the point is on the other side,
 * according to the hyperplane natural orientation.</p></text>
      <param>point point to check</param>
      <return>offset of the point</return>
    </javadoc>
    <method type="double" name="getOffset" startLine="419" endLine="421" />
    <javadoc>
      <text>* Check if the instance has the same orientation as another hyperplane.</text>
      <param>other other hyperplane to check against the instance</param>
      <return>true if the instance and the other hyperplane have
 * the same orientation</return>
    </javadoc>
    <method type="boolean" name="sameOrientationAs" startLine="428" endLine="430" />
  </class>
</source>
