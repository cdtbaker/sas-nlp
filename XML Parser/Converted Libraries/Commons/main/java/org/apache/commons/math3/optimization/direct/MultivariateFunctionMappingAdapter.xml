<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optimization.direct">
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.analysis.function.Logit" />
  <import name="org.apache.commons.math3.analysis.function.Sigmoid" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="MultivariateFunctionMappingAdapter" startLine="29">
    <implements name="MultivariateFunction" />
    <javadoc>
      <text>* <p>Adapter for mapping bounded {@link MultivariateFunction} to unbounded ones.</p>
 * <p>
 * This adapter can be used to wrap functions subject to simple bounds on
 * parameters so they can be used by optimizers that do <em>not</em> directly
 * support simple bounds.
 * </p>
 * <p>
 * The principle is that the user function that will be wrapped will see its
 * parameters bounded as required, i.e when its {@code value} method is called
 * with argument array {@code point}, the elements array will fulfill requirement{@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components
 * may be unbounded or bounded only on one side if the corresponding bound is
 * set to an infinite value. The optimizer will not manage the user function by
 * itself, but it will handle this adapter and it is this adapter that will take
 * care the bounds are fulfilled. The adapter {@link #value(double[])} method will
 * be called by the optimizer with unbound parameters, and the adapter will map
 * the unbounded value to the bounded range using appropriate functions like{@link Sigmoid} for double bounded elements for example.
 * </p>
 * <p>
 * As the optimizer sees only unbounded parameters, it should be noted that the
 * start point or simplex expected by the optimizer should be unbounded, so the
 * user is responsible for converting his bounded point to unbounded by calling{@link #boundedToUnbounded(double[])} before providing them to the optimizer.
 * For the same reason, the point returned by the {@link org.apache.commons.math3.optimization.BaseMultivariateOptimizer#optimize(int,MultivariateFunction,org.apache.commons.math3.optimization.GoalType,double[])}method is unbounded. So to convert this point to bounded, users must call{@link #unboundedToBounded(double[])} by themselves!</p>
 * <p>
 * This adapter is only a poor man solution to simple bounds optimization constraints
 * that can be used with simple optimizers like {@link SimplexOptimizer} with {@link NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use
 * an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or{@link BOBYQAOptimizer}. One caveat of this poor man solution is that behavior near
 * the bounds may be numerically unstable as bounds are mapped from infinite values.
 * Another caveat is that convergence values are evaluated by the optimizer with respect
 * to unbounded variables, so there will be scales differences when converted to bounded
 * variables.
 * </p></text>
      <see>MultivariateFunctionPenaltyAdapter</see>
      <version>$Id: MultivariateFunctionMappingAdapter.java 1422230 2012-12-15 12:11:13Z erans $</version>
      <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Underlying bounded function.</text>
    </javadoc>
    <declaration type="MultivariateFunction" name="bounded" />
    <javadoc>
      <text>* Mapping functions.</text>
    </javadoc>
    <declaration type="Mapper[]" name="mappers" />
    <javadoc>
      <text>* Simple constructor.</text>
      <param>bounded bounded function</param>
      <param>lower lower bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for
 * unbounded values)</param>
      <param>upper upper bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.POSITIVE_INFINITY} for
 * unbounded values)</param>
      <exception>DimensionMismatchException if lower and upper bounds are not
 * consistent, either according to dimension or to values</exception>
    </javadoc>
    <method type="constructor" name="MultivariateFunctionMappingAdapter" startLine="100" endLine="137">
      <scope startLine="105" endLine="107" />
      <scope startLine="108" endLine="113">
        <scope startLine="110" endLine="112" />
        <comment>note the following test is written in such a way it also fails for NaN</comment>
      </scope>
      <scope startLine="117" endLine="135">
        <scope startLine="118" endLine="126">
          <scope startLine="119" endLine="122" />
          <scope startLine="122" endLine="125" />
        </scope>
        <scope startLine="126" endLine="134">
          <scope startLine="127" endLine="130" />
          <scope startLine="130" endLine="133" />
        </scope>
        <comment>element is unbounded, no transformation is needed</comment>
        <comment>element is simple-bounded on the upper side</comment>
        <comment>element is simple-bounded on the lower side</comment>
        <comment>element is double-bounded</comment>
      </scope>
      <comment>safety checks</comment>
    </method>
    <javadoc>
      <text>* Map an array from unbounded to bounded.</text>
      <param>point unbounded value</param>
      <return>bounded value</return>
    </javadoc>
    <method type="double[]" name="unboundedToBounded" startLine="143" endLine="153">
      <declaration type="double[]" name="mapped" />
      <scope startLine="147" endLine="149" />
      <comment>map unbounded input point to bounded point</comment>
    </method>
    <javadoc>
      <text>* Map an array from bounded to unbounded.</text>
      <param>point bounded value</param>
      <return>unbounded value</return>
    </javadoc>
    <method type="double[]" name="boundedToUnbounded" startLine="159" endLine="169">
      <declaration type="double[]" name="mapped" />
      <scope startLine="163" endLine="165" />
      <comment>map bounded input point to unbounded point</comment>
    </method>
    <javadoc>
      <text>* Compute the underlying function value from an unbounded point.
 * <p>
 * This method simply bounds the unbounded point using the mappings
 * set up at construction and calls the underlying function using
 * the bounded point.
 * </p></text>
      <param>point unbounded value</param>
      <return>underlying function value</return>
      <see>#unboundedToBounded(double[])</see>
    </javadoc>
    <method type="double" name="value" startLine="181" endLine="183" />
    <interface name="Mapper" startLine="185">
      <javadoc>
        <text>* Mapping interface.</text>
      </javadoc>
      <method name="unboundedToBounded" type="double" startLine="188" endLine="192" />
      <javadoc>
        <text>* Map a value from unbounded to bounded.</text>
        <param>y unbounded value</param>
        <return>bounded value</return>
      </javadoc>
      <method name="boundedToUnbounded" type="double" startLine="194" endLine="198" />
      <javadoc>
        <text>* Map a value from bounded to unbounded.</text>
        <param>x bounded value</param>
        <return>unbounded value</return>
      </javadoc>
      <class name="NoBoundsMapper" startLine="202">
        <implements name="Mapper" />
        <javadoc>
          <text>* Local class for no bounds mapping.</text>
        </javadoc>
        <javadoc>
          <text>* Simple constructor.</text>
        </javadoc>
        <method type="constructor" name="NoBoundsMapper" startLine="207" endLine="208" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="double" name="unboundedToBounded" startLine="211" endLine="213" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="double" name="boundedToUnbounded" startLine="216" endLine="218" />
        <class name="LowerBoundMapper" startLine="222">
          <implements name="Mapper" />
          <javadoc>
            <text>* Local class for lower bounds mapping.</text>
          </javadoc>
          <javadoc>
            <text>* Low bound.</text>
          </javadoc>
          <declaration type="double" name="lower" />
          <javadoc>
            <text>* Simple constructor.</text>
            <param>lower lower bound</param>
          </javadoc>
          <method type="constructor" name="LowerBoundMapper" startLine="231" endLine="233" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="unboundedToBounded" startLine="236" endLine="238" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="boundedToUnbounded" startLine="241" endLine="243" />
          <class name="UpperBoundMapper" startLine="247">
            <implements name="Mapper" />
            <javadoc>
              <text>* Local class for upper bounds mapping.</text>
            </javadoc>
            <javadoc>
              <text>* Upper bound.</text>
            </javadoc>
            <declaration type="double" name="upper" />
            <javadoc>
              <text>* Simple constructor.</text>
              <param>upper upper bound</param>
            </javadoc>
            <method type="constructor" name="UpperBoundMapper" startLine="256" endLine="258" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="double" name="unboundedToBounded" startLine="261" endLine="263" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="double" name="boundedToUnbounded" startLine="266" endLine="268" />
            <class name="LowerUpperBoundMapper" startLine="272">
              <implements name="Mapper" />
              <javadoc>
                <text>* Local class for lower and bounds mapping.</text>
              </javadoc>
              <javadoc>
                <text>* Function from unbounded to bounded.</text>
              </javadoc>
              <declaration type="UnivariateFunction" name="boundingFunction" />
              <javadoc>
                <text>* Function from bounded to unbounded.</text>
              </javadoc>
              <declaration type="UnivariateFunction" name="unboundingFunction" />
              <javadoc>
                <text>* Simple constructor.</text>
                <param>lower lower bound</param>
                <param>upper upper bound</param>
              </javadoc>
              <method type="constructor" name="LowerUpperBoundMapper" startLine="285" endLine="288" />
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="double" name="unboundedToBounded" startLine="291" endLine="293" />
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="double" name="boundedToUnbounded" startLine="296" endLine="298" />
            </class>
          </class>
        </class>
      </class>
    </interface>
  </class>
</source>
