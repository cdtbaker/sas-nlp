<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.partitioning">
  <import name="java.lang.reflect.Array" />
  <import name="java.util.ArrayList" />
  <import name="java.util.Collection" />
  <import name="java.util.Comparator" />
  <import name="java.util.Iterator" />
  <import name="java.util.TreeSet" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.geometry.Space" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <class name="AbstractRegion" startLine="30">
    <implements name="Region<S>" />
    <javadoc>
      <text>* Abstract class for all regions, independently of geometry type or dimension.</text>
      <param><S>
 *  Type of the space.</param>
      <param><T>
 *  Type of the sub-space.</param>
      <version>$Id: AbstractRegion.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Inside/Outside BSP tree.</text>
    </javadoc>
    <declaration type="BSPTree<S>" name="tree" />
    <javadoc>
      <text>* Size of the instance.</text>
    </javadoc>
    <declaration type="double" name="size" />
    <javadoc>
      <text>* Barycenter.</text>
    </javadoc>
    <declaration type="Vector<S>" name="barycenter" />
    <javadoc>
      <text>* Build a region representing the whole space.</text>
    </javadoc>
    <method type="constructor" name="AbstractRegion" startLine="51" endLine="53" />
    <javadoc>
      <text>* Build a region from an inside/outside BSP tree.
 * <p>The leaf nodes of the BSP tree <em>must</em> have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
 * tree also <em>must</em> have either null internal nodes or
 * internal nodes representing the boundary as specified in the{@link #getTree getTree} method).</p></text>
      <param>tree inside/outside BSP tree representing the region</param>
    </javadoc>
    <method type="constructor" name="AbstractRegion" startLine="67" endLine="69" />
    <javadoc>
      <text>* Build a Region from a Boundary REPresentation (B-rep).
 * <p>The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.</p>
 * <p>The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polygons with holes
 * or a set of disjoints polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link #checkPoint(Vector) checkPoint} method will not be
 * meaningful anymore.</p>
 * <p>If the boundary is empty, the region will represent the whole
 * space.</p></text>
      <param>boundary collection of boundary elements, as a
 * collection of {@link SubHyperplane SubHyperplane} objects</param>
    </javadoc>
    <method type="constructor" name="AbstractRegion" startLine="90" endLine="136">
      <scope startLine="92" endLine="97">
        <comment>the tree represents the whole space</comment>
      </scope>
      <scope startLine="97" endLine="134">
        <declaration type="TreeSet<SubHyperplane<S>>" name="ordered" />
        <method type="int" name="compare" startLine="103" endLine="107">
          <declaration type="double" name="size1" />
          <declaration type="double" name="size2" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="Order" name="visitOrder" startLine="119" endLine="121" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="visitInternalNode" startLine="124" endLine="125" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="visitLeafNode" startLine="128" endLine="131" />
        <comment>sort the boundary elements in decreasing size order</comment>
        <comment>(we don't want equal size elements to be removed, so</comment>
        <comment>we use a trick to fool the TreeSet)</comment>
        <comment>build the tree top-down</comment>
        <comment>set up the inside/outside flags</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Build a convex region from an array of bounding hyperplanes.</text>
      <param>hyperplanes array of bounding hyperplanes (if null, an
 * empty region will be built)</param>
    </javadoc>
    <method type="constructor" name="AbstractRegion" startLine="142" endLine="164">
      <scope startLine="143" endLine="145" />
      <scope startLine="145" endLine="162">
        <declaration type="BSPTree<S>" name="node" />
        <scope startLine="153" endLine="160">
          <scope startLine="154" endLine="159" />
        </scope>
        <comment>use the first hyperplane to build the right class</comment>
        <comment>chop off parts of the space</comment>
      </scope>
    </method>
    <method name="buildNew" type="AbstractRegion<S,T>" startLine="166" endLine="167" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <javadoc>
      <text>* Recursively build a tree by inserting cut sub-hyperplanes.</text>
      <param>node current tree node (it is a leaf node at the beginning
 * of the call)</param>
      <param>boundary collection of edges belonging to the cell defined
 * by the node</param>
    </javadoc>
    <method type="void" name="insertCuts" startLine="175" endLine="218">
      <declaration type="Iterator<SubHyperplane<S>>" name="iterator" />
      <declaration type="Hyperplane<S>" name="inserted" />
      <scope startLine="181" endLine="186">
        <scope startLine="183" endLine="185" />
      </scope>
      <scope startLine="188" endLine="190" />
      <declaration type="ArrayList<SubHyperplane<S>>" name="plusList" />
      <declaration type="ArrayList<SubHyperplane<S>>" name="minusList" />
      <scope startLine="195" endLine="212">
        <declaration type="SubHyperplane<S>" name="other" />
        <declaration type="SubHyperplane.SplitSubHyperplane<S>" name="split" />
        <comment>ignore the sub-hyperplanes belonging to the cut hyperplane</comment>
      </scope>
      <comment>build the current level</comment>
      <comment>distribute the remaining edges in the two sub-trees</comment>
      <comment>recurse through lower levels</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="AbstractRegion<S,T>" name="copySelf" startLine="221" endLine="223" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isEmpty" startLine="226" endLine="228" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isEmpty" startLine="231" endLine="245">
      <scope startLine="237" endLine="240">
        <comment>if we find an inside node, the region is not empty</comment>
      </scope>
      <comment>we use a recursive function rather than the BSPTreeVisitor</comment>
      <comment>interface because we can stop visiting the tree as soon as we</comment>
      <comment>have found an inside cell</comment>
      <comment>check both sides of the sub-tree</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="contains" startLine="248" endLine="250" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Location" name="checkPoint" startLine="253" endLine="255" />
    <javadoc>
      <text>* Check a point with respect to the region starting at a given node.</text>
      <param>node root node of the region</param>
      <param>point point to check</param>
      <return>a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDEOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}</return>
    </javadoc>
    <method type="Location" name="checkPoint" startLine="264" endLine="276">
      <declaration type="BSPTree<S>" name="cell" />
      <scope startLine="266" endLine="269">
        <comment>the point is in the interior of a cell, just check the attribute</comment>
      </scope>
      <declaration type="Location" name="minusCode" />
      <declaration type="Location" name="plusCode" />
      <comment>the point is on a cut-sub-hyperplane, is it on a boundary ?</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="BSPTree<S>" name="getTree" startLine="279" endLine="285">
      <scope startLine="280" endLine="283">
        <comment>we need to compute the boundary attributes</comment>
      </scope>
    </method>
    <class name="BoundaryBuilder" startLine="287">
      <implements name="BSPTreeVisitor<S>" />
      <javadoc>
        <text>* Visitor building boundary shell tree.
 * <p>
 * The boundary shell is represented as {@link BoundaryAttribute boundary attributes}at each internal node.
 * </p></text>
      </javadoc>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Order" name="visitOrder" startLine="296" endLine="298" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visitInternalNode" startLine="301" endLine="343">
        <declaration type="SubHyperplane<S>" name="plusOutside" />
        <declaration type="SubHyperplane<S>" name="plusInside" />
        <declaration type="SubHyperplane<S>[][]" name="plusChar" />
        <scope startLine="312" endLine="324">
          <declaration type="SubHyperplane<S>[][]" name="minusChar" />
          <scope startLine="319" endLine="323" />
          <comment>plusChar[0] corresponds to a subset of the cut sub-hyperplane known to have</comment>
          <comment>outside cells on its plus side, we want to check if parts of this subset</comment>
          <comment>do have inside cells on their minus side</comment>
          <comment>this part belongs to the boundary,</comment>
          <comment>it has the outside on its plus side and the inside on its minus side</comment>
        </scope>
        <scope startLine="326" endLine="338">
          <declaration type="SubHyperplane<S>[][]" name="minusChar" />
          <scope startLine="333" endLine="337" />
          <comment>plusChar[1] corresponds to a subset of the cut sub-hyperplane known to have</comment>
          <comment>inside cells on its plus side, we want to check if parts of this subset</comment>
          <comment>do have outside cells on their minus side</comment>
          <comment>this part belongs to the boundary,</comment>
          <comment>it has the inside on its plus side and the outside on its minus side</comment>
        </scope>
        <comment>characterize the cut sub-hyperplane,</comment>
        <comment>first with respect to the plus sub-tree</comment>
        <comment>set the boundary attribute at non-leaf nodes</comment>
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visitLeafNode" startLine="346" endLine="347" />
      <javadoc>
        <text>* Filter the parts of an hyperplane belonging to the boundary.
 * <p>The filtering consist in splitting the specified
 * sub-hyperplane into several parts lying in inside and outside
 * cells of the tree. The principle is to call this method twice for
 * each cut sub-hyperplane in the tree, once one the plus node and
 * once on the minus node. The parts that have the same flag
 * (inside/inside or outside/outside) do not belong to the boundary
 * while parts that have different flags (inside/outside or
 * outside/inside) do belong to the boundary.</p></text>
        <param>node current BSP tree node</param>
        <param>sub sub-hyperplane to characterize</param>
        <param>characterization placeholder where to put the characterized parts</param>
      </javadoc>
      <method type="void" name="characterize" startLine="363" endLine="399">
        <scope startLine="364" endLine="380">
          <declaration type="boolean" name="inside" />
          <scope startLine="367" endLine="373">
            <scope startLine="368" endLine="370" />
            <scope startLine="370" endLine="372" />
          </scope>
          <scope startLine="373" endLine="379">
            <scope startLine="374" endLine="376" />
            <scope startLine="376" endLine="378" />
          </scope>
          <comment>we have reached a leaf node</comment>
        </scope>
        <scope startLine="380" endLine="398">
          <declaration type="Hyperplane<S>" name="hyperplane" />
          <declaration type="SubHyperplane.SplitSubHyperplane<S>" name="split" />
          <comment>this should not happen</comment>
        </scope>
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="double" name="getBoundarySize" startLine="404" endLine="408">
        <declaration type="BoundarySizeVisitor<S>" name="visitor" />
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="double" name="getSize" startLine="411" endLine="416">
        <scope startLine="412" endLine="414" />
      </method>
      <javadoc>
        <text>* Set the size of the instance.</text>
        <param>size size of the instance</param>
      </javadoc>
      <method type="void" name="setSize" startLine="421" endLine="423" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Vector<S>" name="getBarycenter" startLine="426" endLine="431">
        <scope startLine="427" endLine="429" />
      </method>
      <javadoc>
        <text>* Set the barycenter of the instance.</text>
        <param>barycenter barycenter of the instance</param>
      </javadoc>
      <method type="void" name="setBarycenter" startLine="436" endLine="438" />
      <method name="computeGeometricalProperties" type="void" startLine="440" endLine="443" />
      <javadoc>
        <text>* Compute some geometrical properties.
 * <p>The properties to compute are the barycenter and the size.</p></text>
      </javadoc>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Side" name="side" startLine="446" endLine="452">
        <declaration type="Sides" name="sides" />
      </method>
      <javadoc>
        <text>* Search recursively for inside leaf nodes on each side of the given hyperplane.
 * <p>The algorithm used here is directly derived from the one
 * described in section III (<i>Binary Partitioning of a BSP
 * Tree</i>) of the Bruce Naylor, John Amanatides and William
 * Thibault paper <a
 * href="http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf">Merging
 * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph
 * '90, Computer Graphics 24(4), August 1990, pp 115-124, published
 * by the Association for Computing Machinery (ACM)..</p></text>
        <param>node current BSP tree node</param>
        <param>sub sub-hyperplane</param>
        <param>sides object holding the sides found</param>
      </javadoc>
      <method type="void" name="recurseSides" startLine="469" endLine="543">
        <scope startLine="471" endLine="478">
          <scope startLine="472" endLine="476" />
          <comment>this is an inside cell expanding across the hyperplane</comment>
        </scope>
        <declaration type="Hyperplane<S>" name="hyperplane" />
        <scope startLine="484" endLine="488">
          <scope startLine="485" endLine="487" />
        </scope>
        <scope startLine="488" endLine="492">
          <scope startLine="489" endLine="491" />
        </scope>
        <scope startLine="493" endLine="495" />
        <scope startLine="499" endLine="503">
          <scope startLine="500" endLine="502" />
        </scope>
        <scope startLine="503" endLine="507">
          <scope startLine="504" endLine="506" />
        </scope>
        <scope startLine="508" endLine="510" />
        <declaration type="SubHyperplane.SplitSubHyperplane<S>" name="split" />
        <scope startLine="520" endLine="522" />
        <scope startLine="526" endLine="533">
          <scope startLine="527" endLine="529" />
          <scope startLine="530" endLine="532" />
        </scope>
        <scope startLine="533" endLine="540">
          <scope startLine="534" endLine="536" />
          <scope startLine="537" endLine="539" />
        </scope>
        <comment>the sub-hyperplane is entirely in the plus sub-tree</comment>
        <comment>the sub-hyperplane is entirely in the minus sub-tree</comment>
        <comment>the sub-hyperplane extends in both sub-trees</comment>
        <comment>explore first the plus sub-tree</comment>
        <comment>if needed, explore the minus sub-tree</comment>
        <comment>the sub-hyperplane and the cut sub-hyperplane share the same hyperplane</comment>
      </method>
      <class name="Sides" startLine="545">
        <javadoc>
          <text>* Utility class holding the already found sides.</text>
        </javadoc>
        <javadoc>
          <text>* Indicator of inside leaf nodes found on the plus side.</text>
        </javadoc>
        <declaration type="boolean" name="plusFound" />
        <javadoc>
          <text>* Indicator of inside leaf nodes found on the plus side.</text>
        </javadoc>
        <declaration type="boolean" name="minusFound" />
        <javadoc>
          <text>* Simple constructor.</text>
        </javadoc>
        <method type="constructor" name="Sides" startLine="556" endLine="559" />
        <javadoc>
          <text>* Remember the fact that inside leaf nodes have been found on the plus side.</text>
        </javadoc>
        <method type="void" name="rememberPlusFound" startLine="563" endLine="565" />
        <javadoc>
          <text>* Check if inside leaf nodes have been found on the plus side.</text>
          <return>true if inside leaf nodes have been found on the plus side</return>
        </javadoc>
        <method type="boolean" name="plusFound" startLine="570" endLine="572" />
        <javadoc>
          <text>* Remember the fact that inside leaf nodes have been found on the minus side.</text>
        </javadoc>
        <method type="void" name="rememberMinusFound" startLine="576" endLine="578" />
        <javadoc>
          <text>* Check if inside leaf nodes have been found on the minus side.</text>
          <return>true if inside leaf nodes have been found on the minus side</return>
        </javadoc>
        <method type="boolean" name="minusFound" startLine="583" endLine="585" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="SubHyperplane<S>" name="intersection" startLine="590" endLine="592" />
        <javadoc>
          <text>* Recursively compute the parts of a sub-hyperplane that are
 * contained in the region.</text>
          <param>node current BSP tree node</param>
          <param>sub sub-hyperplane traversing the region</param>
          <return>filtered sub-hyperplane</return>
        </javadoc>
        <method type="SubHyperplane<S>" name="recurseIntersection" startLine="600" endLine="628">
          <scope startLine="602" endLine="604" />
          <declaration type="Hyperplane<S>" name="hyperplane" />
          <declaration type="SubHyperplane.SplitSubHyperplane<S>" name="split" />
          <declaration type="SubHyperplane<S>" name="plus" />
          <declaration type="SubHyperplane<S>" name="minus" />
          <scope startLine="616" endLine="618" />
          <scope startLine="618" endLine="620" />
          <scope startLine="620" endLine="622" />
        </method>
        <javadoc>
          <text>* Transform a region.
 * <p>Applying a transform to a region consist in applying the
 * transform to all the hyperplanes of the underlying BSP tree and
 * of the boundary (and also to the sub-hyperplanes embedded in
 * these hyperplanes) and to the barycenter. The instance is not
 * modified, a new instance is built.</p></text>
          <param>transform transform to apply</param>
          <return>a new region, resulting from the application of the
 * transform to the instance</return>
        </javadoc>
        <method type="AbstractRegion<S,T>" name="applyTransform" startLine="640" endLine="642" />
        <javadoc>
          <text>* Recursively transform an inside/outside BSP-tree.</text>
          <param>node current BSP tree node</param>
          <param>transform transform to apply</param>
          <return>a new tree</return>
        </javadoc>
        <method type="BSPTree<S>" name="recurseTransform" startLine="650" endLine="672">
          <scope startLine="652" endLine="654" />
          <declaration type="SubHyperplane<S>" name="sub" />
          <declaration type="SubHyperplane<S>" name="tSub" />
          <declaration type="BoundaryAttribute<S>" name="attribute" />
          <scope startLine="659" endLine="665">
            <declaration type="SubHyperplane<S>" name="tPO" />
            <declaration type="SubHyperplane<S>" name="tPI" />
          </scope>
        </method>
      </class>
    </class>
  </class>
</source>
