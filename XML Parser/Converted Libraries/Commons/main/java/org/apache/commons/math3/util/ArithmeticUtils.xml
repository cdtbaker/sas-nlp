<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.math.BigInteger" />
  <import name="java.util.concurrent.atomic.AtomicReference" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.util.Localizable" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="ArithmeticUtils" startLine="28">
    <javadoc>
      <text>* Some useful, arithmetics related, additions to the built-in functions in{@link Math}.</text>
      <version>$Id: ArithmeticUtils.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
    </javadoc>
    <javadoc>
      <text>* All long-representable factorials</text>
    </javadoc>
    <declaration type="long[]" name="FACTORIALS" />
    <javadoc>
      <text>* Stirling numbers of the second kind.</text>
    </javadoc>
    <declaration type="AtomicReference<long[][]>" name="STIRLING_S2" />
    <javadoc>
      <text>* Private constructor.</text>
    </javadoc>
    <method type="constructor" name="ArithmeticUtils" startLine="50" endLine="52" />
    <javadoc>
      <text>* Add two integers, checking for overflow.</text>
      <param>x an addend</param>
      <param>y an addend</param>
      <return>the sum {@code x+y}</return>
      <throws>MathArithmeticException if the result can not be represented
 * as an {@code int}.</throws>
      <since>1.1</since>
    </javadoc>
    <method type="int" name="addAndCheck" startLine="65" endLine="71">
      <declaration type="long" name="s" />
      <scope startLine="67" endLine="69" />
    </method>
    <javadoc>
      <text>* Add two long integers, checking for overflow.</text>
      <param>a an addend</param>
      <param>b an addend</param>
      <return>the sum {@code a+b}</return>
      <throws>MathArithmeticException if the result can not be represented as an
 * long</throws>
      <since>1.2</since>
    </javadoc>
    <method type="long" name="addAndCheck" startLine="83" endLine="85" />
    <javadoc>
      <text>* Returns an exact representation of the <a
 * href="http://mathworld.wolfram.com/BinomialCoefficient.html"> Binomial
 * Coefficient</a>, "{@code n choose k}", the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> {@code 0 <= k <= n } (otherwise{@code IllegalArgumentException} is thrown)</li>
 * <li> The result is small enough to fit into a {@code long}. The
 * largest value of {@code n} for which all coefficients are{@code  < Long.MAX_VALUE} is 66. If the computed value exceeds{@code Long.MAX_VALUE} an {@code ArithMeticException} is
 * thrown.</li>
 * </ul></p></text>
      <param>n the size of the set</param>
      <param>k the size of the subsets to be counted</param>
      <return>{@code n choose k}</return>
      <throws>NotPositiveException if {@code n < 0}.</throws>
      <throws>NumberIsTooLargeException if {@code k > n}.</throws>
      <throws>MathArithmeticException if the result is too large to be
 * represented by a long integer.</throws>
    </javadoc>
    <method type="long" name="binomialCoefficient" startLine="114" endLine="167">
      <scope startLine="116" endLine="118" />
      <scope startLine="119" endLine="121" />
      <scope startLine="123" endLine="125" />
      <declaration type="long" name="result" />
      <scope startLine="133" endLine="140">
        <declaration type="int" name="i" />
        <scope startLine="136" endLine="139" />
        <comment>For n <= 61, the naive implementation cannot overflow.</comment>
      </scope>
      <scope startLine="140" endLine="155">
        <declaration type="int" name="i" />
        <scope startLine="144" endLine="154">
          <declaration type="long" name="d" />
        </scope>
        <comment>For n > 61 but n <= 66, the result cannot overflow,</comment>
        <comment>but we must take care not to overflow intermediate values.</comment>
        <comment>We know that (result * i) is divisible by j,</comment>
        <comment>but (result * i) may overflow, so we split j:</comment>
        <comment>Filter out the gcd, d, so j/d and i/d are integer.</comment>
        <comment>result is divisible by (j/d) because (j/d)</comment>
        <comment>is relative prime to (i/d) and is a divisor of</comment>
        <comment>result * (i/d).</comment>
      </scope>
      <scope startLine="155" endLine="165">
        <declaration type="int" name="i" />
        <scope startLine="160" endLine="164">
          <declaration type="long" name="d" />
        </scope>
        <comment>For n > 66, a result overflow might occur, so we check</comment>
        <comment>the multiplication, taking care to not overflow</comment>
        <comment>unnecessary.</comment>
      </scope>
      <comment>Use symmetry for large k</comment>
      <comment>We use the formula</comment>
      <comment>(n choose k) = n! / (n-k)! / k!</comment>
      <comment>(n choose k) == ((n-k+1)*...*n) / (1*...*k)</comment>
      <comment>which could be written</comment>
      <comment>(n choose k) == (n-1 choose k-1) * n / k</comment>
    </method>
    <javadoc>
      <text>* Returns a {@code double} representation of the <a
 * href="http://mathworld.wolfram.com/BinomialCoefficient.html"> Binomial
 * Coefficient</a>, "{@code n choose k}", the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> {@code 0 <= k <= n } (otherwise{@code IllegalArgumentException} is thrown)</li>
 * <li> The result is small enough to fit into a {@code double}. The
 * largest value of {@code n} for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p></text>
      <param>n the size of the set</param>
      <param>k the size of the subsets to be counted</param>
      <return>{@code n choose k}</return>
      <throws>NotPositiveException if {@code n < 0}.</throws>
      <throws>NumberIsTooLargeException if {@code k > n}.</throws>
      <throws>MathArithmeticException if the result is too large to be
 * represented by a long integer.</throws>
    </javadoc>
    <method type="double" name="binomialCoefficientDouble" startLine="195" endLine="216">
      <scope startLine="197" endLine="199" />
      <scope startLine="200" endLine="202" />
      <scope startLine="203" endLine="205" />
      <scope startLine="206" endLine="208" />
      <declaration type="double" name="result" />
      <scope startLine="211" endLine="213" />
    </method>
    <javadoc>
      <text>* Returns the natural {@code log} of the <a
 * href="http://mathworld.wolfram.com/BinomialCoefficient.html"> Binomial
 * Coefficient</a>, "{@code n choose k}", the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> {@code 0 <= k <= n } (otherwise{@code IllegalArgumentException} is thrown)</li>
 * </ul></p></text>
      <param>n the size of the set</param>
      <param>k the size of the subsets to be counted</param>
      <return>{@code n choose k}</return>
      <throws>NotPositiveException if {@code n < 0}.</throws>
      <throws>NumberIsTooLargeException if {@code k > n}.</throws>
      <throws>MathArithmeticException if the result is too large to be
 * represented by a long integer.</throws>
    </javadoc>
    <method type="double" name="binomialCoefficientLog" startLine="240" endLine="285">
      <scope startLine="242" endLine="244" />
      <scope startLine="245" endLine="247" />
      <scope startLine="253" endLine="255" />
      <scope startLine="261" endLine="263" />
      <scope startLine="265" endLine="267" />
      <declaration type="double" name="logSum" />
      <scope startLine="275" endLine="277" />
      <scope startLine="280" endLine="282" />
      <comment>For values small enough to do exact integer computation,
 return the log of the exact value</comment>
      <comment>Return the log of binomialCoefficientDouble for values that will not
 overflow binomialCoefficientDouble</comment>
      <comment>Sum logs for values that could overflow</comment>
      <comment>n!/(n-k)!</comment>
      <comment>divide by k!</comment>
    </method>
    <javadoc>
      <text>* Returns n!. Shorthand for {@code n} <a
 * href="http://mathworld.wolfram.com/Factorial.html"> Factorial</a>, the
 * product of the numbers {@code 1,...,n}.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> {@code n >= 0} (otherwise{@code IllegalArgumentException} is thrown)</li>
 * <li> The result is small enough to fit into a {@code long}. The
 * largest value of {@code n} for which {@code n!} <
 * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}an {@code ArithMeticException } is thrown.</li>
 * </ul>
 * </p></text>
      <param>n argument</param>
      <return>{@code n!}</return>
      <throws>MathArithmeticException if the result is too large to be represented
 * by a {@code long}.</throws>
      <throws>NotPositiveException if {@code n < 0}.</throws>
      <throws>MathArithmeticException if {@code n > 20}: The factorial value is too
 * large to fit in a {@code long}.</throws>
    </javadoc>
    <method type="long" name="factorial" startLine="311" endLine="320">
      <scope startLine="312" endLine="315" />
      <scope startLine="316" endLine="318" />
    </method>
    <javadoc>
      <text>* Compute n!, the<a href="http://mathworld.wolfram.com/Factorial.html">
 * factorial</a> of {@code n} (the product of the numbers 1 to n), as a{@code double}.
 * The result should be small enough to fit into a {@code double}: The
 * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.
 * If the computed value exceeds {@code Double.MAX_VALUE},{@code Double.POSITIVE_INFINITY} is returned.</text>
      <param>n Argument.</param>
      <return>{@code n!}</return>
      <throws>NotPositiveException if {@code n < 0}.</throws>
    </javadoc>
    <method type="double" name="factorialDouble" startLine="335" endLine="344">
      <scope startLine="336" endLine="339" />
      <scope startLine="340" endLine="342" />
    </method>
    <javadoc>
      <text>* Compute the natural logarithm of the factorial of {@code n}.</text>
      <param>n Argument.</param>
      <return>{@code n!}</return>
      <throws>NotPositiveException if {@code n < 0}.</throws>
    </javadoc>
    <method type="double" name="factorialLog" startLine="353" endLine="366">
      <scope startLine="354" endLine="357" />
      <scope startLine="358" endLine="360" />
      <declaration type="double" name="logSum" />
      <scope startLine="362" endLine="364" />
    </method>
    <javadoc>
      <text>* Computes the greatest common divisor of the absolute value of two
 * numbers, using a modified version of the "binary gcd" method.
 * See Knuth 4.5.2 algorithm B.
 * The algorithm is due to Josef Stein (1961).
 * <br/>
 * Special cases:
 * <ul>
 * <li>The invocations{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},{@code gcd(Integer.MIN_VALUE, 0)} and{@code gcd(0, Integer.MIN_VALUE)} throw an{@code ArithmeticException}, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and{@code gcd(x, 0)} is the absolute value of {@code x}, except
 * for the special cases above.</li>
 * <li>The invocation {@code gcd(0, 0)} is the only one which returns{@code 0}.</li>
 * </ul></text>
      <param>p Number.</param>
      <param>q Number.</param>
      <return>the greatest common divisor (never negative).</return>
      <throws>MathArithmeticException if the result cannot be represented as
 * a non-negative {@code int} value.</throws>
      <since>1.1</since>
    </javadoc>
    <method type="int" name="gcd" startLine="398" endLine="453">
      <declaration type="int" name="a" />
      <declaration type="int" name="b" />
      <scope startLine="402" endLine="409">
        <scope startLine="404" endLine="407" />
      </scope>
      <declaration type="long" name="al" />
      <declaration type="long" name="bl" />
      <declaration type="boolean" name="useLong" />
      <scope startLine="414" endLine="421">
        <scope startLine="415" endLine="417" />
        <scope startLine="417" endLine="419" />
      </scope>
      <scope startLine="422" endLine="429">
        <scope startLine="423" endLine="425" />
        <scope startLine="425" endLine="427" />
      </scope>
      <scope startLine="430" endLine="450">
        <scope startLine="431" endLine="434" />
        <declaration type="long" name="blbu" />
        <scope startLine="438" endLine="444">
          <scope startLine="439" endLine="442" />
        </scope>
        <comment>Now "al" and "bl" fit in an "int".</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Computes the greatest common divisor of two <em>positive</em> numbers
 * (this precondition is <em>not</em> checked and the result is undefined
 * if not fulfilled) using the "binary gcd" method which avoids division
 * and modulo operations.
 * See Knuth 4.5.2 algorithm B.
 * The algorithm is due to Josef Stein (1961).
 * <br/>
 * Special cases:
 * <ul>
 * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and{@code gcd(x, 0)} is the value of {@code x}.</li>
 * <li>The invocation {@code gcd(0, 0)} is the only one which returns{@code 0}.</li>
 * </ul></text>
      <param>a Positive number.</param>
      <param>b Positive number.</param>
      <return>the greatest common divisor.</return>
    </javadoc>
    <method type="int" name="gcdPositive" startLine="476" endLine="508">
      <scope startLine="477" endLine="479" />
      <scope startLine="480" endLine="482" />
      <declaration type="int" name="aTwos" />
      <declaration type="int" name="bTwos" />
      <declaration type="int" name="shift" />
      <scope startLine="497" endLine="504">
        <declaration type="int" name="delta" />
        <comment>Remove any power of 2 in "a" ("b" is guaranteed to be odd).</comment>
      </scope>
      <comment>Make "a" and "b" odd, keeping track of common power of 2.</comment>
      <comment>"a" and "b" are positive.</comment>
      <comment>If a > b then "gdc(a, b)" is equal to "gcd(a - b, b)".</comment>
      <comment>If a < b then "gcd(a, b)" is equal to "gcd(b - a, a)".</comment>
      <comment>Hence, in the successive iterations:</comment>
      <comment>"a" becomes the absolute difference of the current values,</comment>
      <comment>"b" becomes the minimum of the current values.</comment>
      <comment>Recover the common power of 2.</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the "binary gcd" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations{@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},{@code gcd(Long.MIN_VALUE, 0L)} and{@code gcd(0L, Long.MIN_VALUE)} throw an{@code ArithmeticException}, because the result would be 2^63, which
 * is too large for a long value.</li>
 * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and{@code gcd(x, 0L)} is the absolute value of {@code x}, except
 * for the special cases above.
 * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns{@code 0L}.</li>
 * </ul></text>
      <param>p Number.</param>
      <param>q Number.</param>
      <return>the greatest common divisor, never negative.</return>
      <throws>MathArithmeticException if the result cannot be represented as
 * a non-negative {@code long} value.</throws>
      <since>2.1</since>
    </javadoc>
    <method type="long" name="gcd" startLine="539" endLine="595">
      <declaration type="long" name="u" />
      <declaration type="long" name="v" />
      <scope startLine="542" endLine="548">
        <scope startLine="543" endLine="546" />
      </scope>
      <scope startLine="554" endLine="556">
        <comment>make u negative</comment>
      </scope>
      <scope startLine="557" endLine="559">
        <comment>make v negative</comment>
      </scope>
      <declaration type="int" name="k" />
      <scope startLine="562" endLine="567">
        <comment>while u and v are</comment>
        <comment>both even...</comment>
        <comment>cast out twos.</comment>
      </scope>
      <scope startLine="568" endLine="571" />
      <declaration type="long" name="t" />
      <scope startLine="577" endLine="593">
        <scope startLine="580" endLine="582" />
        <scope startLine="584" endLine="586" />
        <scope startLine="586" endLine="588" />
        <comment>assert u<0 && v<0;</comment>
        <comment>B4/B3: cast out twos from t.</comment>
        <comment>while t is even..</comment>
        <comment>cast out twos</comment>
        <comment>B5 [reset max(u,v)]</comment>
        <comment>B6/B3. at this point both u and v should be odd.</comment>
        <comment>|u| larger: t positive (replace u)</comment>
        <comment>|v| larger: t negative (replace v)</comment>
      </scope>
      <comment>keep u and v negative, as negative integers range down to</comment>
      <comment>-2^63, while positive numbers can only be as large as 2^63-1</comment>
      <comment>(i.e. we can't necessarily negate a negative number without</comment>
      <comment>overflow)</comment>
      <comment>assert u!=0 && v!=0;</comment>
      <comment>B1. [Find power of 2]</comment>
      <comment>B2. Initialize: u and v have been divided by 2^k and at least</comment>
      <comment>one is odd.</comment>
      <comment>long t = ((u & 1) == 1) ? v : -(u  2) B3 ;</comment>
      <comment>t negative: u was odd, v may be even (t replaces v)</comment>
      <comment>t positive: u was even, v is odd (t replaces u)</comment>
      <comment>gcd is u*2^k</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and{@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a
 * power of 2, throw an {@code ArithmeticException}, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is{@code 0} for any {@code x}.
 * </ul></text>
      <param>a Number.</param>
      <param>b Number.</param>
      <return>the least common multiple, never negative.</return>
      <throws>MathArithmeticException if the result cannot be represented as
 * a non-negative {@code int} value.</throws>
      <since>1.1</since>
    </javadoc>
    <method type="int" name="lcm" startLine="619" endLine="629">
      <scope startLine="620" endLine="622" />
      <declaration type="int" name="lcm" />
      <scope startLine="624" endLine="627" />
    </method>
    <javadoc>
      <text>* <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and{@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a
 * power of 2, throw an {@code ArithmeticException}, because the result
 * would be 2^63, which is too large for an int value.</li>
 * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is{@code 0L} for any {@code x}.
 * </ul></text>
      <param>a Number.</param>
      <param>b Number.</param>
      <return>the least common multiple, never negative.</return>
      <throws>MathArithmeticException if the result cannot be represented
 * as a non-negative {@code long} value.</throws>
      <since>2.1</since>
    </javadoc>
    <method type="long" name="lcm" startLine="653" endLine="663">
      <scope startLine="654" endLine="656" />
      <declaration type="long" name="lcm" />
      <scope startLine="658" endLine="661" />
    </method>
    <javadoc>
      <text>* Multiply two integers, checking for overflow.</text>
      <param>x Factor.</param>
      <param>y Factor.</param>
      <return>the product {@code x * y}.</return>
      <throws>MathArithmeticException if the result can not be
 * represented as an {@code int}.</throws>
      <since>1.1</since>
    </javadoc>
    <method type="int" name="mulAndCheck" startLine="675" endLine="681">
      <declaration type="long" name="m" />
      <scope startLine="677" endLine="679" />
    </method>
    <javadoc>
      <text>* Multiply two long integers, checking for overflow.</text>
      <param>a Factor.</param>
      <param>b Factor.</param>
      <return>the product {@code a * b}.</return>
      <throws>MathArithmeticException if the result can not be represented
 * as a {@code long}.</throws>
      <since>1.2</since>
    </javadoc>
    <method type="long" name="mulAndCheck" startLine="693" endLine="735">
      <declaration type="long" name="ret" />
      <scope startLine="695" endLine="698">
        <comment>use symmetry to reduce boundary cases</comment>
      </scope>
      <scope startLine="698" endLine="733">
        <scope startLine="699" endLine="719">
          <scope startLine="700" endLine="707">
            <scope startLine="702" endLine="704" />
            <scope startLine="704" endLine="706" />
          </scope>
          <scope startLine="707" endLine="715">
            <scope startLine="709" endLine="711" />
            <scope startLine="711" endLine="714" />
          </scope>
          <scope startLine="715" endLine="718" />
        </scope>
        <scope startLine="719" endLine="729">
          <scope startLine="724" endLine="726" />
          <scope startLine="726" endLine="728" />
        </scope>
        <scope startLine="729" endLine="732" />
        <comment>check for positive overflow with negative a, negative b</comment>
        <comment>check for negative overflow with negative a, positive b</comment>
        <comment>assert b == 0</comment>
        <comment>assert a > 0</comment>
        <comment>assert b > 0</comment>
        <comment>check for positive overflow with positive a, positive b</comment>
        <comment>assert a == 0</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Subtract two integers, checking for overflow.</text>
      <param>x Minuend.</param>
      <param>y Subtrahend.</param>
      <return>the difference {@code x - y}.</return>
      <throws>MathArithmeticException if the result can not be represented
 * as an {@code int}.</throws>
      <since>1.1</since>
    </javadoc>
    <method type="int" name="subAndCheck" startLine="747" endLine="753">
      <declaration type="long" name="s" />
      <scope startLine="749" endLine="751" />
    </method>
    <javadoc>
      <text>* Subtract two long integers, checking for overflow.</text>
      <param>a Value.</param>
      <param>b Value.</param>
      <return>the difference {@code a - b}.</return>
      <throws>MathArithmeticException if the result can not be represented as a{@code long}.</throws>
      <since>1.2</since>
    </javadoc>
    <method type="long" name="subAndCheck" startLine="765" endLine="778">
      <declaration type="long" name="ret" />
      <scope startLine="767" endLine="773">
        <scope startLine="768" endLine="770" />
        <scope startLine="770" endLine="772" />
      </scope>
      <scope startLine="773" endLine="776">
        <comment>use additive inverse</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Raise an int to an int power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="int" name="pow" startLine="788" endLine="804">
      <scope startLine="789" endLine="791" />
      <declaration type="int" name="result" />
      <declaration type="int" name="k2p" />
      <scope startLine="795" endLine="801">
        <scope startLine="796" endLine="798" />
      </scope>
    </method>
    <javadoc>
      <text>* Raise an int to a long power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="int" name="pow" startLine="814" endLine="830">
      <scope startLine="815" endLine="817" />
      <declaration type="int" name="result" />
      <declaration type="int" name="k2p" />
      <scope startLine="821" endLine="827">
        <scope startLine="822" endLine="824" />
      </scope>
    </method>
    <javadoc>
      <text>* Raise a long to an int power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="long" name="pow" startLine="840" endLine="856">
      <scope startLine="841" endLine="843" />
      <declaration type="long" name="result" />
      <declaration type="long" name="k2p" />
      <scope startLine="847" endLine="853">
        <scope startLine="848" endLine="850" />
      </scope>
    </method>
    <javadoc>
      <text>* Raise a long to a long power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="long" name="pow" startLine="866" endLine="882">
      <scope startLine="867" endLine="869" />
      <declaration type="long" name="result" />
      <declaration type="long" name="k2p" />
      <scope startLine="873" endLine="879">
        <scope startLine="874" endLine="876" />
      </scope>
    </method>
    <javadoc>
      <text>* Raise a BigInteger to an int power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="BigInteger" name="pow" startLine="892" endLine="898">
      <scope startLine="893" endLine="895" />
    </method>
    <javadoc>
      <text>* Raise a BigInteger to a long power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="BigInteger" name="pow" startLine="908" endLine="925">
      <scope startLine="909" endLine="911" />
      <declaration type="BigInteger" name="result" />
      <declaration type="BigInteger" name="k2p" />
      <scope startLine="915" endLine="921">
        <scope startLine="916" endLine="918" />
      </scope>
    </method>
    <javadoc>
      <text>* Raise a BigInteger to a BigInteger power.</text>
      <param>k Number to raise.</param>
      <param>e Exponent (must be positive or zero).</param>
      <return>k<sup>e</sup></return>
      <throws>NotPositiveException if {@code e < 0}.</throws>
    </javadoc>
    <method type="BigInteger" name="pow" startLine="935" endLine="951">
      <scope startLine="936" endLine="938" />
      <declaration type="BigInteger" name="result" />
      <declaration type="BigInteger" name="k2p" />
      <scope startLine="942" endLine="948">
        <scope startLine="943" endLine="945" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the <a
 * href="http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html">
 * Stirling number of the second kind</a>, "{@code S(n,k)}", the number of
 * ways of partitioning an {@code n}-element set into {@code k} non-empty
 * subsets.
 * <p>
 * The preconditions are {@code 0 <= k <= n } (otherwise{@code NotPositiveException} is thrown)
 * </p></text>
      <param>n the size of the set</param>
      <param>k the number of non-empty subsets</param>
      <return>{@code S(n,k)}</return>
      <throws>NotPositiveException if {@code k < 0}.</throws>
      <throws>NumberIsTooLargeException if {@code k > n}.</throws>
      <throws>MathArithmeticException if some overflow happens, typically for n exceeding 25 and
 * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)</throws>
      <since>3.1</since>
    </javadoc>
    <method type="long" name="stirlingS2" startLine="973" endLine="1037">
      <scope startLine="974" endLine="976" />
      <scope startLine="977" endLine="979" />
      <declaration type="long[][]" name="stirlingS2" />
      <scope startLine="983" endLine="1005">
        <declaration type="int" name="maxIndex" />
        <scope startLine="992" endLine="1000">
          <scope startLine="997" endLine="999" />
        </scope>
        <comment>the cache has never been initialized, compute the first numbers</comment>
        <comment>by direct recurrence relation</comment>
        <comment>as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE</comment>
        <comment>we must stop computation at row 26</comment>
        <comment>atomically save the cache</comment>
      </scope>
      <scope startLine="1007" endLine="1010">
        <comment>the number is in the small cache</comment>
      </scope>
      <scope startLine="1010" endLine="1035">
        <scope startLine="1012" endLine="1014" />
        <scope startLine="1014" endLine="1016" />
        <scope startLine="1016" endLine="1018" />
        <scope startLine="1018" endLine="1020" />
        <scope startLine="1020" endLine="1034">
          <declaration type="long" name="sum" />
          <declaration type="long" name="sign" />
          <scope startLine="1024" endLine="1032">
            <scope startLine="1027" endLine="1031" />
          </scope>
        </scope>
        <comment>use explicit formula to compute the number without caching it</comment>
        <comment>definition formula: note that this may trigger some overflow</comment>
        <comment>there was an overflow somewhere</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Add two long integers, checking for overflow.</text>
      <param>a Addend.</param>
      <param>b Addend.</param>
      <param>pattern Pattern to use for any thrown exception.</param>
      <return>the sum {@code a + b}.</return>
      <throws>MathArithmeticException if the result cannot be represented
 * as a {@code long}.</throws>
      <since>1.2</since>
    </javadoc>
    <method type="long" name="addAndCheck" startLine="1050" endLine="1083">
      <declaration type="long" name="ret" />
      <scope startLine="1052" endLine="1055">
        <comment>use symmetry to reduce boundary cases</comment>
      </scope>
      <scope startLine="1055" endLine="1081">
        <scope startLine="1058" endLine="1070">
          <scope startLine="1059" endLine="1066">
            <scope startLine="1061" endLine="1063" />
            <scope startLine="1063" endLine="1065" />
          </scope>
          <scope startLine="1066" endLine="1069" />
        </scope>
        <scope startLine="1070" endLine="1080">
          <scope startLine="1075" endLine="1077" />
          <scope startLine="1077" endLine="1079" />
        </scope>
        <comment>assert a <= b</comment>
        <comment>check for negative overflow</comment>
        <comment>opposite sign addition is always safe</comment>
        <comment>assert a >= 0</comment>
        <comment>assert b >= 0</comment>
        <comment>check for positive overflow</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Check binomial preconditions.</text>
      <param>n Size of the set.</param>
      <param>k Size of the subsets to be counted.</param>
      <throws>NotPositiveException if {@code n < 0}.</throws>
      <throws>NumberIsTooLargeException if {@code k > n}.</throws>
    </javadoc>
    <method type="void" name="checkBinomial" startLine="1093" endLine="1101">
      <scope startLine="1094" endLine="1097" />
      <scope startLine="1098" endLine="1100" />
    </method>
    <javadoc>
      <text>* Returns true if the argument is a power of two.</text>
      <param>n the number to test</param>
      <return>true if the argument is a power of two</return>
    </javadoc>
    <method type="boolean" name="isPowerOfTwo" startLine="1109" endLine="1111" />
  </class>
</source>
