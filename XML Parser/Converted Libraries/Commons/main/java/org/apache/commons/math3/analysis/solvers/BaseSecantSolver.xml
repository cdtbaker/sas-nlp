<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.solvers">
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.exception.ConvergenceException" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <class name="BaseSecantSolver" extends="AbstractUnivariateSolver" startLine="25">
    <implements name="BracketedUnivariateSolver<UnivariateFunction>" />
    <javadoc>
      <text>* Base class for all bracketing <em>Secant</em>-based methods for root-finding
 * (approximating a zero of a univariate real function).
 * <p>Implementation of the {@link RegulaFalsiSolver <em>Regula Falsi</em>} and{@link IllinoisSolver <em>Illinois</em>} methods is based on the
 * following article: M. Dowell and P. Jarratt,
 * <em>A modified regula falsi method for computing the root of an
 * equation</em>, BIT Numerical Mathematics, volume 11, number 2,
 * pages 168-174, Springer, 1971.</p>
 * <p>Implementation of the {@link PegasusSolver <em>Pegasus</em>} method is
 * based on the following article: M. Dowell and P. Jarratt,
 * <em>The "Pegasus" method for computing the root of an equation</em>,
 * BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer,
 * 1972.</p>
 * <p>The {@link SecantSolver <em>Secant</em>} method is <em>not</em> a
 * bracketing method, so it is not implemented here. It has a separate
 * implementation.</p></text>
      <since>3.0</since>
      <version>$Id: BaseSecantSolver.java 1455194 2013-03-11 15:45:54Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* Default absolute accuracy.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_ABSOLUTE_ACCURACY" />
    <javadoc>
      <text>* The kinds of solutions that the algorithm may accept.</text>
    </javadoc>
    <declaration type="AllowedSolution" name="allowed" />
    <javadoc>
      <text>* The <em>Secant</em>-based root-finding method to use.</text>
    </javadoc>
    <declaration type="Method" name="method" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>absoluteAccuracy Absolute accuracy.</param>
      <param>method <em>Secant</em>-based root-finding method to use.</param>
    </javadoc>
    <method type="constructor" name="BaseSecantSolver" startLine="68" endLine="72" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>relativeAccuracy Relative accuracy.</param>
      <param>absoluteAccuracy Absolute accuracy.</param>
      <param>method <em>Secant</em>-based root-finding method to use.</param>
    </javadoc>
    <method type="constructor" name="BaseSecantSolver" startLine="83" endLine="87" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>relativeAccuracy Maximum relative error.</param>
      <param>absoluteAccuracy Maximum absolute error.</param>
      <param>functionValueAccuracy Maximum function value error.</param>
      <param>method <em>Secant</em>-based root-finding method to use</param>
    </javadoc>
    <method type="constructor" name="BaseSecantSolver" startLine="100" endLine="104" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="solve" startLine="109" endLine="111" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="solve" startLine="116" endLine="119" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="solve" startLine="124" endLine="126" />
    <javadoc>
      <text>* {@inheritDoc}</text>
      <throws>ConvergenceException if the algorithm failed due to finite
 * precision.</throws>
    </javadoc>
    <method type="double" name="doSolve" startLine="136" endLine="261">
      <declaration type="double" name="x0" />
      <declaration type="double" name="x1" />
      <declaration type="double" name="f0" />
      <declaration type="double" name="f1" />
      <scope startLine="146" endLine="148" />
      <scope startLine="149" endLine="151" />
      <declaration type="double" name="ftol" />
      <declaration type="double" name="atol" />
      <declaration type="double" name="rtol" />
      <declaration type="boolean" name="inverted" />
      <scope startLine="166" endLine="260">
        <declaration type="double" name="x" />
        <declaration type="double" name="fx" />
        <scope startLine="174" endLine="176" />
        <scope startLine="179" endLine="185" />
        <scope startLine="185" endLine="204">
          <scope startLine="196" endLine="198" />
        </scope>
        <scope startLine="212" endLine="239">
          <scope startLine="217" endLine="219" />
          <scope startLine="222" endLine="224" />
          <scope startLine="227" endLine="229" />
          <scope startLine="232" endLine="234" />
        </scope>
        <scope startLine="244" endLine="259" />
        <comment>Calculate the next approximation.</comment>
        <comment>If the new approximation is the exact root, return it. Since</comment>
        <comment>this is not an under-approximation or an over-approximation,</comment>
        <comment>we can return it regardless of the allowed solutions.</comment>
        <comment>Update the bounds with the new approximation.</comment>
        <comment>The value of x1 has switched to the other bound, thus inverting</comment>
        <comment>the interval.</comment>
        <comment>Detect early that algorithm is stuck, instead of waiting</comment>
        <comment>for the maximum number of iterations to be exceeded.</comment>
        <comment>Should never happen.</comment>
        <comment>Update from [x0, x1] to [x0, x].</comment>
        <comment>If the function value of the last approximation is too small,</comment>
        <comment>given the function value accuracy, then we can't get closer to</comment>
        <comment>the root than we already are.</comment>
        <comment>If the current interval is within the given accuracies, we</comment>
        <comment>are satisfied with the current approximation.</comment>
      </scope>
      <comment>Get initial solution</comment>
      <comment>If one of the bounds is the exact root, return it. Since these are</comment>
      <comment>not under-approximations or over-approximations, we can return them</comment>
      <comment>regardless of the allowed solutions.</comment>
      <comment>Verify bracketing of initial solution.</comment>
      <comment>Get accuracies.</comment>
      <comment>Keep track of inverted intervals, meaning that the left bound is</comment>
      <comment>larger than the right bound.</comment>
      <comment>Keep finding better approximations.</comment>
    </method>
    <javadoc>
      <text>* <em>Secant</em>-based root-finding methods.</text>
    </javadoc>
    <javadoc>
      <text>* The {@link RegulaFalsiSolver <em>Regula Falsi</em>} or
 * <em>False Position</em> method.</text>
    </javadoc>
    <javadoc>
      <text>* The {@link IllinoisSolver <em>Illinois</em>} method.</text>
    </javadoc>
    <javadoc>
      <text>* The {@link PegasusSolver <em>Pegasus</em>} method.</text>
    </javadoc>
  </class>
</source>
