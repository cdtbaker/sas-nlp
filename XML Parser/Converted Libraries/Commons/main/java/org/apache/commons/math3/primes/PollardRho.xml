<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.primes">
  <import name="java.util.ArrayList" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="PollardRho" startLine="24">
    <javadoc>
      <text>* Implementation of the Pollard's rho factorization algorithm.</text>
      <version>$Id: PollardRho.java 1462702 2013-03-30 04:45:52Z psteitz $</version>
      <since>3.2</since>
    </javadoc>
    <javadoc>
      <text>* Hide utility class.</text>
    </javadoc>
    <method type="constructor" name="PollardRho" startLine="34" endLine="35" />
    <javadoc>
      <text>* Factorization using Pollard's rho algorithm.</text>
      <param>n number to factors, must be &gt; 0</param>
      <return>the list of prime factors of n.</return>
    </javadoc>
    <method type="List<Integer>" name="primeFactors" startLine="42" endLine="59">
      <declaration type="List<Integer>" name="factors" />
      <scope startLine="46" endLine="48" />
      <scope startLine="50" endLine="53" />
      <declaration type="int" name="divisor" />
    </method>
    <javadoc>
      <text>* Implementation of the Pollard's rho factorization algorithm.
 * <p>
 * This implementation follows the paper "An improved Monte Carlo factorization algorithm"
 * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's
 * rho implementations. It also batches several gcd computation into 1.
 * <p>
 * The backtracking is not implemented as we deal only with semi-primes.</text>
      <param>n number to factor, must be semi-prime.</param>
      <return>a prime factor of n.</return>
    </javadoc>
    <method type="int" name="rhoBrent" startLine="73" endLine="114">
      <declaration type="int" name="x0" />
      <declaration type="int" name="m" />
      <declaration type="int" name="cst" />
      <declaration type="int" name="y" />
      <declaration type="int" name="r" />
      <scope startLine="79" endLine="113">
        <declaration type="int" name="x" />
        <scope startLine="81" endLine="84">
          <declaration type="long" name="y2" />
        </scope>
        <declaration type="int" name="k" />
        <scope startLine="86" endLine="111">
          <declaration type="int" name="bound" />
          <declaration type="int" name="q" />
          <scope startLine="89" endLine="105">
            <declaration type="long" name="y2" />
            <declaration type="long" name="divisor" />
            <scope startLine="93" endLine="99" />
            <declaration type="long" name="prod" />
            <scope startLine="102" endLine="104" />
          </scope>
          <declaration type="int" name="out" />
          <scope startLine="107" endLine="109" />
        </scope>
        <comment>start at -3 to ensure we enter this loop at least 3 times</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Gcd between two positive numbers.
 * <p>
 * Gets the greatest common divisor of two numbers, using the "binary gcd" method,
 * which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.
 * This algorithm is due to Josef Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.</li>
 * <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li>
 * </ul></text>
      <param>a first number, must be &ge; 0</param>
      <param>b second number, must be &ge; 0</param>
      <return>gcd(a,b)</return>
    </javadoc>
    <method type="int" name="gcdPositive" startLine="133" endLine="164">
      <scope startLine="136" endLine="138" />
      <scope startLine="138" endLine="140" />
      <declaration type="int" name="aTwos" />
      <declaration type="int" name="bTwos" />
      <declaration type="int" name="shift" />
      <scope startLine="153" endLine="160">
        <declaration type="int" name="delta" />
        <comment>for speed optimization:</comment>
        <comment>remove any power of two in a as b is guaranteed to be odd throughout all iterations</comment>
      </scope>
      <comment>both a and b must be positive, it is not checked here</comment>
      <comment>gdc(a,0) = a</comment>
      <comment>make a and b odd, keep in mind the common power of twos</comment>
      <comment>a and b >0</comment>
      <comment>if a > b then gdc(a,b) = gcd(a-b,b)</comment>
      <comment>if a < b then gcd(a,b) = gcd(b-a,a)</comment>
      <comment>so next a is the absolute difference and next b is the minimum of current values</comment>
      <comment>gcd(a,a) = a, just "add" the common power of twos</comment>
    </method>
  </class>
</source>
