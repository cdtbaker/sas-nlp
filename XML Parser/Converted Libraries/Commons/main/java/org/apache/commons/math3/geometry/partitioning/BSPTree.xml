<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.partitioning">
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <import name="org.apache.commons.math3.geometry.Space" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="BSPTree" startLine="24">
    <javadoc>
      <text>* This class represent a Binary Space Partition tree.
 * <p>BSP trees are an efficient way to represent space partitions and
 * to associate attributes with each cell. Each node in a BSP tree
 * represents a convex region which is partitioned in two convex
 * sub-regions at each side of a cut hyperplane. The root tree
 * contains the complete space.</p>
 * <p>The main use of such partitions is to use a boolean attribute to
 * define an inside/outside property, hence representing arbitrary
 * polytopes (line segments in 1D, polygons in 2D and polyhedrons in
 * 3D) and to operate on them.</p>
 * <p>Another example would be to represent Voronoi tesselations, the
 * attribute of each cell holding the defining point of the cell.</p>
 * <p>The application-defined attributes are shared among copied
 * instances and propagated to split parts. These attributes are not
 * used by the BSP-tree algorithms themselves, so the application can
 * use them for any purpose. Since the tree visiting method holds
 * internal and leaf nodes differently, it is possible to use
 * different classes for internal nodes attributes and leaf nodes
 * attributes. This should be used with care, though, because if the
 * tree is modified in any way after attributes have been set, some
 * internal nodes may become leaf nodes and some leaf nodes may become
 * internal nodes.</p>
 * <p>One of the main sources for the development of this package was
 * Bruce Naylor, John Amanatides and William Thibault paper <a
 * href="http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf">Merging
 * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph '90,
 * Computer Graphics 24(4), August 1990, pp 115-124, published by the
 * Association for Computing Machinery (ACM).</p></text>
      <param><S>
 *  Type of the space.</param>
      <version>$Id: BSPTree.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Cut sub-hyperplane.</text>
    </javadoc>
    <declaration type="SubHyperplane<S>" name="cut" />
    <javadoc>
      <text>* Tree at the plus side of the cut hyperplane.</text>
    </javadoc>
    <declaration type="BSPTree<S>" name="plus" />
    <javadoc>
      <text>* Tree at the minus side of the cut hyperplane.</text>
    </javadoc>
    <declaration type="BSPTree<S>" name="minus" />
    <javadoc>
      <text>* Parent tree.</text>
    </javadoc>
    <declaration type="BSPTree<S>" name="parent" />
    <javadoc>
      <text>* Application-defined attribute.</text>
    </javadoc>
    <declaration type="Object" name="attribute" />
    <javadoc>
      <text>* Build a tree having only one root cell representing the whole space.</text>
    </javadoc>
    <method type="constructor" name="BSPTree" startLine="82" endLine="88" />
    <javadoc>
      <text>* Build a tree having only one root cell representing the whole space.</text>
      <param>attribute attribute of the tree (may be null)</param>
    </javadoc>
    <method type="constructor" name="BSPTree" startLine="93" endLine="99" />
    <javadoc>
      <text>* Build a BSPTree from its underlying elements.
 * <p>This method does <em>not</em> perform any verification on
 * consistency of its arguments, it should therefore be used only
 * when then caller knows what it is doing.</p>
 * <p>This method is mainly useful kto build trees
 * bottom-up. Building trees top-down is realized with the help of
 * method {@link #insertCut insertCut}.</p></text>
      <param>cut cut sub-hyperplane for the tree</param>
      <param>plus plus side sub-tree</param>
      <param>minus minus side sub-tree</param>
      <param>attribute attribute associated with the node (may be null)</param>
      <see>#insertCut</see>
    </javadoc>
    <method type="constructor" name="BSPTree" startLine="115" endLine="123" />
    <javadoc>
      <text>* Insert a cut sub-hyperplane in a node.
 * <p>The sub-tree starting at this node will be completely
 * overwritten. The new cut sub-hyperplane will be built from the
 * intersection of the provided hyperplane with the cell. If the
 * hyperplane does intersect the cell, the cell will have two
 * children cells with {@code null} attributes on each side of
 * the inserted cut sub-hyperplane. If the hyperplane does not
 * intersect the cell then <em>no</em> cut hyperplane will be
 * inserted and the cell will be changed to a leaf cell. The
 * attribute of the node is never changed.</p>
 * <p>This method is mainly useful when called on leaf nodes
 * (i.e. nodes for which {@link #getCut getCut} returns{@code null}), in this case it provides a way to build a
 * tree top-down (whereas the {@link #BSPTree(SubHyperplane,BSPTree,BSPTree,Object) 4 arguments constructor} is devoted to
 * build trees bottom-up).</p></text>
      <param>hyperplane hyperplane to insert, it will be chopped in
 * order to fit in the cell defined by the parent nodes of the
 * instance</param>
      <return>true if a cut sub-hyperplane has been inserted (i.e. if
 * the cell now has two leaf child nodes)</return>
      <see>#BSPTree(SubHyperplane,BSPTree,BSPTree,Object)</see>
    </javadoc>
    <method type="boolean" name="insertCut" startLine="148" endLine="170">
      <scope startLine="150" endLine="153" />
      <declaration type="SubHyperplane<S>" name="chopped" />
      <scope startLine="156" endLine="161" />
    </method>
    <javadoc>
      <text>* Copy the instance.
 * <p>The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying objects are
 * shared (except for the nodes attributes and immutable
 * objects).</p></text>
      <return>a new tree, copy of the instance</return>
    </javadoc>
    <method type="BSPTree<S>" name="copySelf" startLine="179" endLine="188">
      <scope startLine="181" endLine="183" />
    </method>
    <javadoc>
      <text>* Get the cut sub-hyperplane.</text>
      <return>cut sub-hyperplane, null if this is a leaf tree</return>
    </javadoc>
    <method type="SubHyperplane<S>" name="getCut" startLine="193" endLine="195" />
    <javadoc>
      <text>* Get the tree on the plus side of the cut hyperplane.</text>
      <return>tree on the plus side of the cut hyperplane, null if this
 * is a leaf tree</return>
    </javadoc>
    <method type="BSPTree<S>" name="getPlus" startLine="201" endLine="203" />
    <javadoc>
      <text>* Get the tree on the minus side of the cut hyperplane.</text>
      <return>tree on the minus side of the cut hyperplane, null if this
 * is a leaf tree</return>
    </javadoc>
    <method type="BSPTree<S>" name="getMinus" startLine="209" endLine="211" />
    <javadoc>
      <text>* Get the parent node.</text>
      <return>parent node, null if the node has no parents</return>
    </javadoc>
    <method type="BSPTree<S>" name="getParent" startLine="216" endLine="218" />
    <javadoc>
      <text>* Associate an attribute with the instance.</text>
      <param>attribute attribute to associate with the node</param>
      <see>#getAttribute</see>
    </javadoc>
    <method type="void" name="setAttribute" startLine="224" endLine="226" />
    <javadoc>
      <text>* Get the attribute associated with the instance.</text>
      <return>attribute associated with the node or null if no
 * attribute has been explicitly set using the {@link #setAttributesetAttribute} method</return>
      <see>#setAttribute</see>
    </javadoc>
    <method type="Object" name="getAttribute" startLine="234" endLine="236" />
    <javadoc>
      <text>* Visit the BSP tree nodes.</text>
      <param>visitor object visiting the tree nodes</param>
    </javadoc>
    <method type="void" name="visit" startLine="241" endLine="281">
      <scope startLine="242" endLine="244" />
      <scope startLine="244" endLine="280" />
    </method>
    <javadoc>
      <text>* Fit a sub-hyperplane inside the cell defined by the instance.
 * <p>Fitting is done by chopping off the parts of the
 * sub-hyperplane that lie outside of the cell using the
 * cut-hyperplanes of the parent nodes of the instance.</p></text>
      <param>sub sub-hyperplane to fit</param>
      <return>a new sub-hyperplane, guaranteed to have no part outside
 * of the instance cell</return>
    </javadoc>
    <method type="SubHyperplane<S>" name="fitToCell" startLine="291" endLine="301">
      <declaration type="SubHyperplane<S>" name="s" />
      <scope startLine="293" endLine="299">
        <scope startLine="294" endLine="296" />
        <scope startLine="296" endLine="298" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the cell to which a point belongs.
 * <p>If the returned cell is a leaf node the points belongs to the
 * interior of the node, if the cell is an internal node the points
 * belongs to the node cut sub-hyperplane.</p></text>
      <param>point point to check</param>
      <return>the tree cell to which the point belongs (can be</return>
    </javadoc>
    <method type="BSPTree<S>" name="getCell" startLine="310" endLine="329">
      <scope startLine="312" endLine="314" />
      <declaration type="double" name="offset" />
      <scope startLine="319" endLine="321" />
      <scope startLine="321" endLine="324">
        <comment>point is on the minus side of the cut hyperplane</comment>
      </scope>
      <scope startLine="324" endLine="327">
        <comment>point is on the plus side of the cut hyperplane</comment>
      </scope>
      <comment>position of the point with respect to the cut hyperplane</comment>
    </method>
    <javadoc>
      <text>* Perform condensation on a tree.
 * <p>The condensation operation is not recursive, it must be called
 * explicitely from leaves to root.</p></text>
    </javadoc>
    <method type="void" name="condense" startLine="335" endLine="344">
      <scope startLine="338" endLine="343" />
    </method>
    <javadoc>
      <text>* Merge a BSP tree with the instance.
 * <p>All trees are modified (parts of them are reused in the new
 * tree), it is the responsibility of the caller to ensure a copy
 * has been done before if any of the former tree should be
 * preserved, <em>no</em> such copy is done here!</p>
 * <p>The algorithm used here is directly derived from the one
 * described in the Naylor, Amanatides and Thibault paper (section
 * III, Binary Partitioning of a BSP Tree).</p></text>
      <param>tree other tree to merge with the instance (will be
 * <em>unusable</em> after the operation, as well as the
 * instance itself)</param>
      <param>leafMerger object implementing the final merging phase
 * (this is where the semantic of the operation occurs, generally
 * depending on the attribute of the leaf node)</param>
      <return>a new tree, result of <code>instance &lt;op&gt;
 * tree</code>, this value can be ignored if parentTree is not null
 * since all connections have already been established</return>
    </javadoc>
    <method type="BSPTree<S>" name="merge" startLine="364" endLine="366" />
    <javadoc>
      <text>* Merge a BSP tree with the instance.</text>
      <param>tree other tree to merge with the instance (will be
 * <em>unusable</em> after the operation, as well as the
 * instance itself)</param>
      <param>leafMerger object implementing the final merging phase
 * (this is where the semantic of the operation occurs, generally
 * depending on the attribute of the leaf node)</param>
      <param>parentTree parent tree to connect to (may be null)</param>
      <param>isPlusChild if true and if parentTree is not null, the
 * resulting tree should be the plus child of its parent, ignored if
 * parentTree is null</param>
      <return>a new tree, result of <code>instance &lt;op&gt;
 * tree</code>, this value can be ignored if parentTree is not null
 * since all connections have already been established</return>
    </javadoc>
    <method type="BSPTree<S>" name="merge" startLine="384" endLine="415">
      <scope startLine="385" endLine="388">
        <comment>cell/tree operation</comment>
      </scope>
      <scope startLine="388" endLine="391">
        <comment>tree/cell operation</comment>
      </scope>
      <scope startLine="391" endLine="414">
        <declaration type="BSPTree<S>" name="merged" />
        <scope startLine="394" endLine="401">
          <scope startLine="396" endLine="398" />
          <scope startLine="398" endLine="400" />
        </scope>
        <scope startLine="407" endLine="410" />
        <comment>tree/tree operation</comment>
        <comment>merging phase</comment>
      </scope>
    </method>
    <interface name="LeafMerger" startLine="417">
      <javadoc>
        <text>* This interface gather the merging operations between a BSP tree
 * leaf and another BSP tree.
 * <p>As explained in Bruce Naylor, John Amanatides and William
 * Thibault paper <a
 * href="http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf">Merging
 * BSP Trees Yields Polyhedral Set Operations</a>,
 * the operations on {@link BSPTree BSP trees} can be expressed as a
 * generic recursive merging operation where only the final part,
 * when one of the operand is a leaf, is specific to the real
 * operation semantics. For example, a tree representing a region
 * using a boolean attribute to identify inside cells and outside
 * cells would use four different objects to implement the final
 * merging phase of the four set operations union, intersection,
 * difference and symmetric difference (exclusive or).</p></text>
        <param><S>
 *  Type of the space.</param>
      </javadoc>
      <method name="merge" type="BSPTree<S>" startLine="435" endLine="465" />
      <javadoc>
        <text>* Merge a leaf node and a tree node.
 * <p>This method is called at the end of a recursive merging
 * resulting from a {@code tree1.merge(tree2, leafMerger)}call, when one of the sub-trees involved is a leaf (i.e. when
 * its cut-hyperplane is null). This is the only place where the
 * precise semantics of the operation are required. For all upper
 * level nodes in the tree, the merging operation is only a
 * generic partitioning algorithm.</p>
 * <p>Since the final operation may be non-commutative, it is
 * important to know if the leaf node comes from the instance tree
 * ({@code tree1}) or the argument tree
 * ({@code tree2}). The third argument of the method is
 * devoted to this. It can be ignored for commutative
 * operations.</p>
 * <p>The {@link BSPTree#insertInTree BSPTree.insertInTree} method
 * may be useful to implement this method.</p></text>
        <param>leaf leaf node (its cut hyperplane is guaranteed to be
 * null)</param>
        <param>tree tree node (its cut hyperplane may be null or not)</param>
        <param>parentTree parent tree to connect to (may be null)</param>
        <param>isPlusChild if true and if parentTree is not null, the
 * resulting tree should be the plus child of its parent, ignored if
 * parentTree is null</param>
        <param>leafFromInstance if true, the leaf node comes from the
 * instance tree ({@code tree1}) and the tree node comes from
 * the argument tree ({@code tree2})</param>
        <return>the BSP tree resulting from the merging (may be one of
 * the arguments)</return>
      </javadoc>
      <javadoc>
        <text>* Split a BSP tree by an external sub-hyperplane.
 * <p>Split a tree in two halves, on each side of the
 * sub-hyperplane. The instance is not modified.</p>
 * <p>The tree returned is not upward-consistent: despite all of its
 * sub-trees cut sub-hyperplanes (including its own cut
 * sub-hyperplane) are bounded to the current cell, it is <em>not</em>
 * attached to any parent tree yet. This tree is intended to be
 * later inserted into an higher level tree.</p>
 * <p>The algorithm used here is the one given in Naylor, Amanatides
 * and Thibault paper (section III, Binary Partitioning of a BSP
 * Tree).</p></text>
        <param>sub partitioning sub-hyperplane, must be already clipped
 * to the convex region represented by the instance, will be used as
 * the cut sub-hyperplane of the returned tree</param>
        <return>a tree having the specified sub-hyperplane as its cut
 * sub-hyperplane, the two parts of the split instance as its two
 * sub-trees and a null parent</return>
      </javadoc>
      <method type="BSPTree<S>" name="split" startLine="487" endLine="553">
        <scope startLine="489" endLine="492" />
        <declaration type="Hyperplane<S>" name="cHyperplane" />
        <declaration type="Hyperplane<S>" name="sHyperplane" />
        <scope startLine="498" endLine="512">
          <declaration type="BSPTree<S>" name="split" />
          <scope startLine="500" endLine="505" />
          <scope startLine="505" endLine="510" />
          <comment>the partitioning sub-hyperplane is entirely in the plus sub-tree</comment>
        </scope>
        <scope startLine="514" endLine="528">
          <declaration type="BSPTree<S>" name="split" />
          <scope startLine="516" endLine="521" />
          <scope startLine="521" endLine="526" />
          <comment>the partitioning sub-hyperplane is entirely in the minus sub-tree</comment>
        </scope>
        <scope startLine="530" endLine="546">
          <declaration type="SubHyperplane.SplitSubHyperplane<S>" name="cutParts" />
          <declaration type="SubHyperplane.SplitSubHyperplane<S>" name="subParts" />
          <declaration type="BSPTree<S>" name="split" />
          <declaration type="BSPTree<S>" name="tmp" />
        </scope>
      </method>
      <javadoc>
        <text>* Insert the instance into another tree.
 * <p>The instance itself is modified so its former parent should
 * not be used anymore.</p></text>
        <param>parentTree parent tree to connect to (may be null)</param>
        <param>isPlusChild if true and if parentTree is not null, the
 * resulting tree should be the plus child of its parent, ignored if
 * parentTree is null</param>
        <see>LeafMerger</see>
      </javadoc>
      <method type="void" name="insertInTree" startLine="564" endLine="605">
        <scope startLine="568" endLine="574">
          <scope startLine="569" endLine="571" />
          <scope startLine="571" endLine="573" />
        </scope>
        <scope startLine="577" endLine="603">
          <scope startLine="580" endLine="597">
            <declaration type="Hyperplane<S>" name="hyperplane" />
            <scope startLine="587" endLine="591" />
            <scope startLine="591" endLine="595" />
          </scope>
          <comment>explore the parent nodes from here towards tree root</comment>
          <comment>this is an hyperplane of some parent node</comment>
          <comment>chop off the parts of the inserted tree that extend</comment>
          <comment>on the wrong side of this parent hyperplane</comment>
          <comment>since we may have drop some parts of the inserted tree,</comment>
          <comment>perform a condensation pass to keep the tree structure simple</comment>
        </scope>
        <comment>set up parent/child links</comment>
        <comment>make sure the inserted tree lies in the cell defined by its parent nodes</comment>
      </method>
      <javadoc>
        <text>* Chop off parts of the tree.
 * <p>The instance is modified in place, all the parts that are on
 * the minus side of the chopping hyperplane are discarded, only the
 * parts on the plus side remain.</p></text>
        <param>hyperplane chopping hyperplane</param>
      </javadoc>
      <method type="void" name="chopOffMinus" startLine="613" endLine="619">
        <scope startLine="614" endLine="618" />
      </method>
      <javadoc>
        <text>* Chop off parts of the tree.
 * <p>The instance is modified in place, all the parts that are on
 * the plus side of the chopping hyperplane are discarded, only the
 * parts on the minus side remain.</p></text>
        <param>hyperplane chopping hyperplane</param>
      </javadoc>
      <method type="void" name="chopOffPlus" startLine="627" endLine="633">
        <scope startLine="628" endLine="632" />
      </method>
    </interface>
  </class>
</source>
