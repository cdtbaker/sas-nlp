<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.io.PrintStream" />
  <class name="FastMath" startLine="21">
    <javadoc>
      <text>* Faster, more accurate, portable alternative to {@link Math} and{@link StrictMath} for large scale computation.
 * <p>
 * FastMath is a drop-in replacement for both Math and StrictMath. This
 * means that for any method in Math (say {@code Math.sin(x)} or{@code Math.cbrt(y)}), user can directly change the class and use the
 * methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)}in the previous example).
 * </p>
 * <p>
 * FastMath speed is achieved by relying heavily on optimizing compilers
 * to native code present in many JVMs today and use of large tables.
 * The larger tables are lazily initialised on first use, so that the setup
 * time does not penalise methods that don't need them.
 * </p>
 * <p>
 * Note that FastMath is
 * extensively used inside Apache Commons Math, so by calling some algorithms,
 * the overhead when the the tables need to be intialised will occur
 * regardless of the end-user calling FastMath methods directly or not.
 * Performance figures for a specific JVM and hardware can be evaluated by
 * running the FastMathTestPerformance tests in the test directory of the source
 * distribution.
 * </p>
 * <p>
 * FastMath accuracy should be mostly independent of the JVM as it relies only
 * on IEEE-754 basic operations and on embedded tables. Almost all operations
 * are accurate to about 0.5 ulp throughout the domain range. This statement,
 * of course is only a rough global observed behavior, it is <em>not</em> a
 * guarantee for <em>every</em> double numbers input (see William Kahan's <a
 * href="http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma">Table
 * Maker's Dilemma</a>).
 * </p>
 * <p>
 * FastMath additionally implements the following methods not found in Math/StrictMath:
 * <ul>
 * <li>{@link #asinh(double)}</li>
 * <li>{@link #acosh(double)}</li>
 * <li>{@link #atanh(double)}</li>
 * </ul>
 * The following methods are found in Math/StrictMath since 1.6 only, they are provided
 * by FastMath even in 1.5 Java virtual machines
 * <ul>
 * <li>{@link #copySign(double,double)}</li>
 * <li>{@link #getExponent(double)}</li>
 * <li>{@link #nextAfter(double,double)}</li>
 * <li>{@link #nextUp(double)}</li>
 * <li>{@link #scalb(double,int)}</li>
 * <li>{@link #copySign(float,float)}</li>
 * <li>{@link #getExponent(float)}</li>
 * <li>{@link #nextAfter(float,double)}</li>
 * <li>{@link #nextUp(float)}</li>
 * <li>{@link #scalb(float,int)}</li>
 * </ul>
 * </p></text>
      <version>$Id: FastMath.java 1462503 2013-03-29 15:48:27Z luc $</version>
      <since>2.2</since>
    </javadoc>
    <javadoc>
      <text>* Archimede's constant PI, ratio of circle circumference to diameter.</text>
    </javadoc>
    <declaration type="double" name="PI" />
    <javadoc>
      <text>* Napier's constant e, base of the natural logarithm.</text>
    </javadoc>
    <declaration type="double" name="E" />
    <javadoc>
      <text>* Index of exp(0) in the array of integer exponentials.</text>
    </javadoc>
    <declaration type="int" name="EXP_INT_TABLE_MAX_INDEX" />
    <javadoc>
      <text>* Length of the array of integer exponentials.</text>
    </javadoc>
    <declaration type="int" name="EXP_INT_TABLE_LEN" />
    <javadoc>
      <text>* Logarithm table length.</text>
    </javadoc>
    <declaration type="int" name="LN_MANT_LEN" />
    <javadoc>
      <text>* Exponential fractions table length.</text>
    </javadoc>
    <declaration type="int" name="EXP_FRAC_TABLE_LEN" />
    <javadoc>
      <text>* StrictMath.log(Double.MAX_VALUE): {@value}</text>
    </javadoc>
    <declaration type="double" name="LOG_MAX_VALUE" />
    <javadoc>
      <text>* Indicator for tables initialization.
 * <p>
 * This compile-time constant should be set to true only if one explicitly
 * wants to compute the tables at class loading time instead of using the
 * already computed ones provided as literal arrays below.
 * </p></text>
    </javadoc>
    <declaration type="boolean" name="RECOMPUTE_TABLES_AT_RUNTIME" />
    <javadoc>
      <text>* log(2) (high bits).</text>
    </javadoc>
    <declaration type="double" name="LN_2_A" />
    <javadoc>
      <text>* log(2) (low bits).</text>
    </javadoc>
    <declaration type="double" name="LN_2_B" />
    <javadoc>
      <text>* Coefficients for log, when input 0.99 < x < 1.01.</text>
    </javadoc>
    <declaration type="double" name="LN_QUICK_COEF" />
    <javadoc>
      <text>* Coefficients for log in the range of 1.0 < x < 1.0 + 2^-10.</text>
    </javadoc>
    <declaration type="double" name="LN_HI_PREC_COEF" />
    <javadoc>
      <text>* Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx.</text>
    </javadoc>
    <declaration type="int" name="SINE_TABLE_LEN" />
    <javadoc>
      <text>* Sine table (high bits).</text>
    </javadoc>
    <declaration type="double" name="SINE_TABLE_A" />
    <javadoc>
      <text>* Sine table (low bits).</text>
    </javadoc>
    <declaration type="double" name="SINE_TABLE_B" />
    <javadoc>
      <text>* Cosine table (high bits).</text>
    </javadoc>
    <declaration type="double" name="COSINE_TABLE_A" />
    <javadoc>
      <text>* Cosine table (low bits).</text>
    </javadoc>
    <declaration type="double" name="COSINE_TABLE_B" />
    <javadoc>
      <text>* Tangent table, used by atan() (high bits).</text>
    </javadoc>
    <declaration type="double" name="TANGENT_TABLE_A" />
    <javadoc>
      <text>* Tangent table, used by atan() (low bits).</text>
    </javadoc>
    <declaration type="double" name="TANGENT_TABLE_B" />
    <javadoc>
      <text>* Bits of 1/(2*pi), need for reducePayneHanek().</text>
    </javadoc>
    <declaration type="long" name="RECIP_2PI" />
    <javadoc>
      <text>* Bits of pi/4, need for reducePayneHanek().</text>
    </javadoc>
    <declaration type="long" name="PI_O_4_BITS" />
    <javadoc>
      <text>* Eighths.
 * This is used by sinQ, because its faster to do a table lookup than
 * a multiply in this time-critical routine</text>
    </javadoc>
    <declaration type="double" name="EIGHTHS" />
    <javadoc>
      <text>* Table of 2^((n+2)/3)</text>
    </javadoc>
    <declaration type="double" name="CBRTTWO" />
    <javadoc>
      <text>* 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
 * Equivalent to 2^30.</text>
    </javadoc>
    <declaration type="long" name="HEX_40000000" />
    <javadoc>
      <text>* Mask used to clear low order 30 bits</text>
    </javadoc>
    <declaration type="long" name="MASK_30BITS" />
    <javadoc>
      <text>* Mask used to clear the non-sign part of an int.</text>
    </javadoc>
    <declaration type="int" name="MASK_NON_SIGN_INT" />
    <javadoc>
      <text>* Mask used to clear the non-sign part of a long.</text>
    </javadoc>
    <declaration type="long" name="MASK_NON_SIGN_LONG" />
    <javadoc>
      <text>* 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite</text>
    </javadoc>
    <declaration type="double" name="TWO_POWER_52" />
    <javadoc>
      <text>* 2^53 - double numbers this large must be even.</text>
    </javadoc>
    <declaration type="double" name="TWO_POWER_53" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_3" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_5" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_7" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_9" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_11" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_13" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_15" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_17" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_3_4" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_15_16" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_13_14" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_11_12" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_9_10" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_7_8" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_5_6" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_2" />
    <javadoc>
      <text>* Constant: {@value}.</text>
    </javadoc>
    <declaration type="double" name="F_1_4" />
    <javadoc>
      <text>* Private Constructor</text>
    </javadoc>
    <method type="constructor" name="FastMath" startLine="359" endLine="359" />
    <javadoc>
      <text>* Get the high order bits from the mantissa.
 * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers</text>
      <param>d the value to split</param>
      <return>the high order part of the mantissa</return>
    </javadoc>
    <method type="double" name="doubleHighPart" startLine="370" endLine="377">
      <scope startLine="371" endLine="373">
        <comment>These are un-normalised - don't try to convert</comment>
      </scope>
      <declaration type="long" name="xl" />
      <comment>can take raw bits because just gonna convert it back</comment>
      <comment>Drop low order bits</comment>
    </method>
    <javadoc>
      <text>* Compute the square root of a number.
 * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}</text>
      <param>a number on which evaluation is done</param>
      <return>square root of a</return>
    </javadoc>
    <method type="double" name="sqrt" startLine="384" endLine="386" />
    <javadoc>
      <text>* Compute the hyperbolic cosine of a number.</text>
      <param>x number on which evaluation is done</param>
      <return>hyperbolic cosine of x</return>
    </javadoc>
    <method type="double" name="cosh" startLine="392" endLine="455">
      <scope startLine="393" endLine="395" />
      <scope startLine="402" endLine="410">
        <scope startLine="403" endLine="407">
          <declaration type="double" name="t" />
        </scope>
        <scope startLine="407" endLine="409" />
        <comment>Avoid overflow (MATH-905).</comment>
      </scope>
      <scope startLine="410" endLine="418">
        <scope startLine="411" endLine="415">
          <declaration type="double" name="t" />
        </scope>
        <scope startLine="415" endLine="417" />
        <comment>Avoid overflow (MATH-905).</comment>
      </scope>
      <declaration type="double[]" name="hiPrec" />
      <scope startLine="421" endLine="423" />
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="yaa" />
      <declaration type="double" name="yab" />
      <declaration type="double" name="recip" />
      <declaration type="double" name="recipa" />
      <declaration type="double" name="recipb" />
      <declaration type="double" name="result" />
      <comment>cosh[z] = (exp(z) + exp(-z))/2</comment>
      <comment>for numbers with magnitude 20 or so,</comment>
      <comment>exp(-z) can be ignored in comparison with exp(z)</comment>
      <comment>recip = 1/y</comment>
      <comment>Correct for rounding in division</comment>
      <comment>Account for yb</comment>
      <comment>y = y + 1/y</comment>
    </method>
    <javadoc>
      <text>* Compute the hyperbolic sine of a number.</text>
      <param>x number on which evaluation is done</param>
      <return>hyperbolic sine of x</return>
    </javadoc>
    <method type="double" name="sinh" startLine="461" endLine="580">
      <declaration type="boolean" name="negate" />
      <scope startLine="463" endLine="465" />
      <scope startLine="472" endLine="480">
        <scope startLine="473" endLine="477">
          <declaration type="double" name="t" />
        </scope>
        <scope startLine="477" endLine="479" />
        <comment>Avoid overflow (MATH-905).</comment>
      </scope>
      <scope startLine="480" endLine="488">
        <scope startLine="481" endLine="485">
          <declaration type="double" name="t" />
        </scope>
        <scope startLine="485" endLine="487" />
        <comment>Avoid overflow (MATH-905).</comment>
      </scope>
      <scope startLine="490" endLine="492" />
      <scope startLine="494" endLine="497" />
      <declaration type="double" name="result" />
      <scope startLine="501" endLine="536">
        <declaration type="double[]" name="hiPrec" />
        <declaration type="double" name="ya" />
        <declaration type="double" name="yb" />
        <declaration type="double" name="temp" />
        <declaration type="double" name="yaa" />
        <declaration type="double" name="yab" />
        <declaration type="double" name="recip" />
        <declaration type="double" name="recipa" />
        <declaration type="double" name="recipb" />
        <comment>recip = 1/y</comment>
        <comment>Correct for rounding in division</comment>
        <comment>Account for yb</comment>
        <comment>y = y + 1/y</comment>
      </scope>
      <scope startLine="537" endLine="573">
        <declaration type="double[]" name="hiPrec" />
        <declaration type="double" name="ya" />
        <declaration type="double" name="yb" />
        <declaration type="double" name="denom" />
        <declaration type="double" name="denomr" />
        <declaration type="double" name="denomb" />
        <declaration type="double" name="ratio" />
        <declaration type="double" name="temp" />
        <declaration type="double" name="ra" />
        <declaration type="double" name="rb" />
        <declaration type="double" name="za" />
        <declaration type="double" name="zb" />
        <comment>Compute expm1(-x) = -expm1(x)  (expm1(x) + 1)</comment>
        <comment>Adjust for yb</comment>
        <comment>numerator</comment>
        <comment>denominator</comment>
        <comment>y = y - 1/y</comment>
      </scope>
      <scope startLine="575" endLine="577" />
      <comment>sinh[z] = (exp(z) - exp(-z) / 2</comment>
      <comment>for values of z larger than about 20,</comment>
      <comment>exp(-z) can be ignored in comparison with exp(z)</comment>
    </method>
    <javadoc>
      <text>* Compute the hyperbolic tangent of a number.</text>
      <param>x number on which evaluation is done</param>
      <return>hyperbolic tangent of x</return>
    </javadoc>
    <method type="double" name="tanh" startLine="586" endLine="704">
      <declaration type="boolean" name="negate" />
      <scope startLine="589" endLine="591" />
      <scope startLine="599" endLine="601" />
      <scope startLine="603" endLine="605" />
      <scope startLine="607" endLine="609" />
      <scope startLine="611" endLine="614" />
      <declaration type="double" name="result" />
      <scope startLine="617" endLine="658">
        <declaration type="double[]" name="hiPrec" />
        <declaration type="double" name="ya" />
        <declaration type="double" name="yb" />
        <declaration type="double" name="na" />
        <declaration type="double" name="nb" />
        <declaration type="double" name="temp" />
        <declaration type="double" name="da" />
        <declaration type="double" name="db" />
        <declaration type="double" name="daa" />
        <declaration type="double" name="dab" />
        <declaration type="double" name="ratio" />
        <declaration type="double" name="ratioa" />
        <declaration type="double" name="ratiob" />
        <comment>tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)</comment>
        <comment>Numerator</comment>
        <comment>Denominator</comment>
        <comment>ratio = na/da</comment>
        <comment>Correct for rounding in division</comment>
        <comment>Account for nb</comment>
        <comment>Account for db</comment>
      </scope>
      <scope startLine="659" endLine="697">
        <declaration type="double[]" name="hiPrec" />
        <declaration type="double" name="ya" />
        <declaration type="double" name="yb" />
        <declaration type="double" name="na" />
        <declaration type="double" name="nb" />
        <declaration type="double" name="da" />
        <declaration type="double" name="db" />
        <declaration type="double" name="temp" />
        <declaration type="double" name="daa" />
        <declaration type="double" name="dab" />
        <declaration type="double" name="ratio" />
        <declaration type="double" name="ratioa" />
        <declaration type="double" name="ratiob" />
        <comment>tanh(x) = expm1(2x) / (expm1(2x) + 2)</comment>
        <comment>Numerator</comment>
        <comment>Denominator</comment>
        <comment>ratio = na/da</comment>
        <comment>Correct for rounding in division</comment>
        <comment>Account for nb</comment>
        <comment>Account for db</comment>
      </scope>
      <scope startLine="699" endLine="701" />
      <comment>tanh[z] = sinh[z] / cosh[z]</comment>
      <comment>= (exp(z) - exp(-z)) / (exp(z) + exp(-z))</comment>
      <comment>= (exp(2x) - 1) / (exp(2x) + 1)</comment>
      <comment>for magnitude > 20, sinh[z] == cosh[z] in double precision</comment>
    </method>
    <javadoc>
      <text>* Compute the inverse hyperbolic cosine of a number.</text>
      <param>a number on which evaluation is done</param>
      <return>inverse hyperbolic cosine of a</return>
    </javadoc>
    <method type="double" name="acosh" startLine="710" endLine="712" />
    <javadoc>
      <text>* Compute the inverse hyperbolic sine of a number.</text>
      <param>a number on which evaluation is done</param>
      <return>inverse hyperbolic sine of a</return>
    </javadoc>
    <method type="double" name="asinh" startLine="718" endLine="742">
      <declaration type="boolean" name="negative" />
      <scope startLine="720" endLine="723" />
      <declaration type="double" name="absAsinh" />
      <scope startLine="726" endLine="728" />
      <scope startLine="728" endLine="739">
        <declaration type="double" name="a2" />
        <scope startLine="730" endLine="732" />
        <scope startLine="732" endLine="734" />
        <scope startLine="734" endLine="736" />
        <scope startLine="736" endLine="738" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the inverse hyperbolic tangent of a number.</text>
      <param>a number on which evaluation is done</param>
      <return>inverse hyperbolic tangent of a</return>
    </javadoc>
    <method type="double" name="atanh" startLine="748" endLine="772">
      <declaration type="boolean" name="negative" />
      <scope startLine="750" endLine="753" />
      <declaration type="double" name="absAtanh" />
      <scope startLine="756" endLine="758" />
      <scope startLine="758" endLine="769">
        <declaration type="double" name="a2" />
        <scope startLine="760" endLine="762" />
        <scope startLine="762" endLine="764" />
        <scope startLine="764" endLine="766" />
        <scope startLine="766" endLine="768" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the signum of a number.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise</text>
      <param>a number on which evaluation is done</param>
      <return>-1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a</return>
    </javadoc>
    <method type="double" name="signum" startLine="779" endLine="781">
      <comment>return +0.0/-0.0/NaN depending on a</comment>
    </method>
    <javadoc>
      <text>* Compute the signum of a number.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise</text>
      <param>a number on which evaluation is done</param>
      <return>-1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a</return>
    </javadoc>
    <method type="float" name="signum" startLine="788" endLine="790">
      <comment>return +0.0/-0.0/NaN depending on a</comment>
    </method>
    <javadoc>
      <text>* Compute next number towards positive infinity.</text>
      <param>a number to which neighbor should be computed</param>
      <return>neighbor of a towards positive infinity</return>
    </javadoc>
    <method type="double" name="nextUp" startLine="796" endLine="798" />
    <javadoc>
      <text>* Compute next number towards positive infinity.</text>
      <param>a number to which neighbor should be computed</param>
      <return>neighbor of a towards positive infinity</return>
    </javadoc>
    <method type="float" name="nextUp" startLine="804" endLine="806" />
    <javadoc>
      <text>* Returns a pseudo-random number between 0.0 and 1.0.
 * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}</text>
      <return>a random number between 0.0 and 1.0</return>
    </javadoc>
    <method type="double" name="random" startLine="812" endLine="814" />
    <javadoc>
      <text>* Exponential function.
 * Computes exp(x), function result is nearly rounded.   It will be correctly
 * rounded to the theoretical value for 99.9% of input values, otherwise it will
 * have a 1 UPL error.
 * Method:
 * Lookup intVal = exp(int(x))
 * Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );
 * Compute z as the exponential of the remaining bits by a polynomial minus one
 * exp(x) = intVal * fracVal * (1 + z)
 * Accuracy:
 * Calculation is done with 63 bits of precision, so result should be correctly
 * rounded for 99.9% of input values, with less than 1 ULP error otherwise.</text>
      <param>x   a double</param>
      <return>double e<sup>x</sup></return>
    </javadoc>
    <method type="double" name="exp" startLine="836" endLine="838" />
    <javadoc>
      <text>* Internal helper method for exponential function.</text>
      <param>x original argument of the exponential function</param>
      <param>extra extra bits of precision on input (To Be Confirmed)</param>
      <param>hiPrec extra bits of precision on output (To Be Confirmed)</param>
      <return>exp(x)</return>
    </javadoc>
    <method type="double" name="exp" startLine="847" endLine="962">
      <declaration type="double" name="intPartA" />
      <declaration type="double" name="intPartB" />
      <declaration type="int" name="intVal" />
      <scope startLine="856" endLine="893">
        <scope startLine="859" endLine="865">
          <scope startLine="860" endLine="863" />
        </scope>
        <scope startLine="867" endLine="875">
          <declaration type="double" name="result" />
          <scope startLine="870" endLine="873" />
        </scope>
        <scope startLine="877" endLine="885">
          <declaration type="double" name="result" />
          <scope startLine="880" endLine="883" />
        </scope>
        <comment>This will produce a subnormal output</comment>
        <comment>exp(1.494140625) is nearly a machine number...</comment>
      </scope>
      <scope startLine="893" endLine="906">
        <scope startLine="896" endLine="902">
          <scope startLine="897" endLine="900" />
        </scope>
      </scope>
      <declaration type="int" name="intFrac" />
      <declaration type="double" name="fracPartA" />
      <declaration type="double" name="fracPartB" />
      <declaration type="double" name="epsilon" />
      <declaration type="double" name="z" />
      <declaration type="double" name="tempA" />
      <declaration type="double" name="tempB" />
      <declaration type="double" name="tempC" />
      <declaration type="double" name="result" />
      <scope startLine="949" endLine="951" />
      <scope startLine="951" endLine="953" />
      <scope startLine="955" endLine="959">
        <comment>If requesting high precision</comment>
      </scope>
      <comment>Lookup exp(floor(x)).
 intPartA will have the upper 22 bits, intPartB will have the lower
 52 bits.</comment>
      <comment>Get the fractional part of x, find the greatest multiple of 2^-10 less than
 x and look up the exp function of it.
 fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.</comment>
      <comment>epsilon is the difference in x from the nearest multiple of 2^-10.  It
 has a value in the range 0 <= epsilon < 2^-10.
 Do the subtraction from x as the last step to avoid possible loss of percison.</comment>
      <comment>Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has
full double precision (52 bits).  Since z < 2^-10, we will have
62 bits of precision when combined with the contant 1.  This will be
used in the last addition below to get proper rounding.</comment>
      <comment>Remez generated polynomial.  Converges on the interval [0, 2^-10], error
is less than 0.5 ULP</comment>
      <comment>Compute (intPartA+intPartB)  (fracPartA+fracPartB) by binomial
expansion.
tempA is exact since intPartA and intPartB only have 22 bits each.
tempB will have 52 bits of precision.</comment>
      <comment>Compute the result.  (1+z)(tempA+tempB).  Order of operations is
important.  For accuracy add by increasing size.  tempA is exact and
much larger than the others.  If there are extra bits specified from the
pow() function, use them.</comment>
    </method>
    <javadoc>
      <text>* Compute exp(x) - 1</text>
      <param>x number to compute shifted exponential</param>
      <return>exp(x) - 1</return>
    </javadoc>
    <method type="double" name="expm1" startLine="968" endLine="970" />
    <javadoc>
      <text>* Internal helper method for expm1</text>
      <param>x number to compute shifted exponential</param>
      <param>hiPrecOut receive high precision result for -1.0 < x < 1.0</param>
      <return>exp(x) - 1</return>
    </javadoc>
    <method type="double" name="expm1" startLine="977" endLine="1117">
      <scope startLine="978" endLine="980">
        <comment>NaN or zero</comment>
      </scope>
      <scope startLine="982" endLine="995">
        <declaration type="double[]" name="hiPrec" />
        <scope startLine="987" endLine="989" />
        <scope startLine="989" endLine="994">
          <declaration type="double" name="ra" />
          <declaration type="double" name="rb" />
        </scope>
        <comment>If not between +/- 1.0</comment>
        <comment>return exp(x) - 1.0;</comment>
      </scope>
      <declaration type="double" name="baseA" />
      <declaration type="double" name="baseB" />
      <declaration type="double" name="epsilon" />
      <declaration type="boolean" name="negative" />
      <scope startLine="1002" endLine="1005" />
      <scope startLine="1007" endLine="1021">
        <declaration type="int" name="intFrac" />
        <declaration type="double" name="tempA" />
        <declaration type="double" name="tempB" />
        <declaration type="double" name="temp" />
      </scope>
      <declaration type="double" name="zb" />
      <declaration type="double" name="za" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <scope startLine="1078" endLine="1109">
        <declaration type="double" name="denom" />
        <declaration type="double" name="denomr" />
        <declaration type="double" name="denomb" />
        <declaration type="double" name="ratio" />
        <declaration type="double" name="ra" />
        <declaration type="double" name="rb" />
        <comment>Compute expm1(-x) = -expm1(x)  (expm1(x) + 1)</comment>
        <comment>f(x) = x/1+x</comment>
        <comment>Compute f'(x)</comment>
        <comment>Product rule:  d(uv) = du*v + u*dv</comment>
        <comment>Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))</comment>
        <comment>d(1/x) = -1/(x*x)</comment>
        <comment>d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))</comment>
        <comment>d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))</comment>
        <comment>Adjust for yb</comment>
        <comment>numerator</comment>
        <comment>denominator</comment>
        <comment>negate</comment>
      </scope>
      <scope startLine="1111" endLine="1114" />
      <comment>Compute expm1(epsilon)</comment>
      <comment>Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)expm1(b)</comment>
      <comment>double yb = za*baseB + zb*baseA + zb*baseB;</comment>
      <comment>ya = ya + za + baseA;</comment>
      <comment>yb = yb + zb + baseB;</comment>
      <comment>yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);</comment>
      <comment>yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);</comment>
      <comment>yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);</comment>
    </method>
    <javadoc>
      <text>* Natural logarithm.</text>
      <param>x   a double</param>
      <return>log(x)</return>
    </javadoc>
    <method type="double" name="log" startLine="1125" endLine="1127" />
    <javadoc>
      <text>* Internal helper method for natural logarithm function.</text>
      <param>x original argument of the natural logarithm function</param>
      <param>hiPrec extra bits of precision on output (To Be Confirmed)</param>
      <return>log(x)</return>
    </javadoc>
    <method type="double" name="log" startLine="1135" endLine="1355">
      <scope startLine="1136" endLine="1138">
        <comment>Handle special case of +0/-0</comment>
      </scope>
      <declaration type="long" name="bits" />
      <scope startLine="1142" endLine="1148">
        <scope startLine="1143" endLine="1145" />
      </scope>
      <scope startLine="1151" endLine="1157">
        <scope startLine="1152" endLine="1154" />
      </scope>
      <declaration type="int" name="exp" />
      <scope startLine="1162" endLine="1179">
        <scope startLine="1164" endLine="1171">
          <scope startLine="1166" endLine="1168" />
        </scope>
        <scope startLine="1175" endLine="1178" />
        <comment>Subnormal!</comment>
        <comment>Zero</comment>
        <comment>Normalize the subnormal number.</comment>
      </scope>
      <scope startLine="1182" endLine="1227">
        <declaration type="double" name="xa" />
        <declaration type="double" name="xb" />
        <declaration type="double" name="tmp" />
        <declaration type="double" name="aa" />
        <declaration type="double" name="ab" />
        <declaration type="double[]" name="lnCoef_last" />
        <declaration type="double" name="ya" />
        <declaration type="double" name="yb" />
        <scope startLine="1199" endLine="1216">
          <declaration type="double[]" name="lnCoef_i" />
        </scope>
        <comment>The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
polynomial expansion in higer precision.</comment>
        <comment>Compute x - 1.0 and split it</comment>
        <comment>Multiply a = y  x</comment>
        <comment>split, so now y = a</comment>
        <comment>Add  a = y + lnQuickCoef</comment>
        <comment>Split y = a</comment>
        <comment>Multiply a = y  x</comment>
        <comment>split, so now y = a</comment>
      </scope>
      <declaration type="double[]" name="lnm" />
      <declaration type="double" name="epsilon" />
      <declaration type="double" name="lnza" />
      <declaration type="double" name="lnzb" />
      <scope startLine="1246" endLine="1296">
        <declaration type="double" name="tmp" />
        <declaration type="double" name="aa" />
        <declaration type="double" name="ab" />
        <declaration type="double" name="xa" />
        <declaration type="double" name="xb" />
        <declaration type="double" name="numer" />
        <declaration type="double" name="denom" />
        <declaration type="double[]" name="lnCoef_last" />
        <declaration type="double" name="ya" />
        <declaration type="double" name="yb" />
        <scope startLine="1265" endLine="1282">
          <declaration type="double[]" name="lnCoef_i" />
        </scope>
        <comment>split epsilon -> x</comment>
        <comment>Need a more accurate epsilon, so adjust the division.</comment>
        <comment>Remez polynomial evaluation</comment>
        <comment>Multiply a = y  x</comment>
        <comment>split, so now y = a</comment>
        <comment>Add  a = y + lnHiPrecCoef</comment>
        <comment>Split y = a</comment>
        <comment>Multiply a = y  x</comment>
        <comment>split, so now lnz = a</comment>
        <comment>tmp = aa  1073741824.0;
lnza = aa + tmp - tmp;
lnzb = aa - lnza + ab;</comment>
      </scope>
      <scope startLine="1296" endLine="1306">
        <comment>High precision not required.  Eval Remez polynomial
using standard double precision</comment>
      </scope>
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="c" />
      <declaration type="double" name="d" />
      <scope startLine="1349" endLine="1352" />
      <comment>Handle special cases of negative input, and NaN</comment>
      <comment>Handle special cases of Positive infinity.</comment>
      <comment>Extract the exponent</comment>
      <comment>lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)</comment>
      <comment>double epsilon = x  Double.longBitsToDouble(bits & 0xfffffc0000000000L);

epsilon -= 1.0;</comment>
      <comment>y is the most significant 10 bits of the mantissa</comment>
      <comment>double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);</comment>
      <comment>double epsilon = (x - y) / y;</comment>
      <comment>Relative sizes:
 lnzb     [0, 2.33E-10]
 lnm[1]   [0, 1.17E-7]
 ln2Bexp [0, 1.12E-4]
 lnza      [0, 9.7E-4]
 lnm[0]   [0, 0.692]
 ln2Aexp [0, 709]</comment>
      <comment>Compute the following sum:
 lnzb + lnm[1] + ln2Bexp + lnza + lnm[0] + ln2Aexp;</comment>
      <comment>return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;</comment>
    </method>
    <javadoc>
      <text>* Computes log(1 + x).</text>
      <param>x Number.</param>
      <return>{@code log(1 + x)}.</return>
    </javadoc>
    <method type="double" name="log1p" startLine="1363" endLine="1393">
      <scope startLine="1364" endLine="1366" />
      <scope startLine="1368" endLine="1370" />
      <scope startLine="1373" endLine="1388">
        <declaration type="double" name="xpa" />
        <declaration type="double" name="xpb" />
        <declaration type="double[]" name="hiPrec" />
        <declaration type="double" name="lores" />
        <scope startLine="1379" endLine="1381" />
        <declaration type="double" name="fx1" />
        <declaration type="double" name="epsilon" />
        <comment>Don't allow this to be converted to NaN</comment>
        <comment>Do a taylor series expansion around xpa:</comment>
        <comment>f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2</comment>
      </scope>
      <scope startLine="1388" endLine="1392">
        <declaration type="double" name="y" />
        <comment>Value is small |x| < 1e6, do a Taylor series centered on 1.</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Compute the base 10 logarithm.</text>
      <param>x a number</param>
      <return>log10(x)</return>
    </javadoc>
    <method type="double" name="log10" startLine="1399" endLine="1415">
      <declaration type="double[]" name="hiPrec" />
      <declaration type="double" name="lores" />
      <scope startLine="1403" endLine="1405">
        <comment>don't allow this to be converted to NaN</comment>
      </scope>
      <declaration type="double" name="tmp" />
      <declaration type="double" name="lna" />
      <declaration type="double" name="lnb" />
      <declaration type="double" name="rln10a" />
      <declaration type="double" name="rln10b" />
    </method>
    <javadoc>
      <text>* Computes the <a href="http://mathworld.wolfram.com/Logarithm.html">
 * logarithm</a> in a given base.
 * Returns {@code NaN} if either argument is negative.
 * If {@code base} is 0 and {@code x} is positive, 0 is returned.
 * If {@code base} is positive and {@code x} is 0,{@code Double.NEGATIVE_INFINITY} is returned.
 * If both arguments are 0, the result is {@code NaN}.</text>
      <param>base Base of the logarithm, must be greater than 0.</param>
      <param>x Argument, must be greater than 0.</param>
      <return>the value of the logarithm, i.e. the number {@code y} such that
 * <code>base<sup>y</sup> = x</code>.</return>
      <since>1.2 (previously in {@code MathUtils}, moved as of version 3.0)</since>
    </javadoc>
    <method type="double" name="log" startLine="1433" endLine="1435" />
    <javadoc>
      <text>* Power function.  Compute x^y.</text>
      <param>x   a double</param>
      <param>y   a double</param>
      <return>double</return>
    </javadoc>
    <method type="double" name="pow" startLine="1444" endLine="1602">
      <declaration type="double[]" name="lns" />
      <scope startLine="1447" endLine="1449" />
      <scope startLine="1451" endLine="1453">
        <comment>X is NaN</comment>
      </scope>
      <scope startLine="1456" endLine="1479">
        <declaration type="long" name="bits" />
        <scope startLine="1458" endLine="1469">
          <declaration type="long" name="yi" />
          <scope startLine="1462" endLine="1464" />
          <scope startLine="1466" endLine="1468" />
        </scope>
        <scope startLine="1471" endLine="1473" />
        <scope startLine="1474" endLine="1476" />
        <comment>-zero</comment>
      </scope>
      <scope startLine="1481" endLine="1490">
        <scope startLine="1482" endLine="1484" />
        <scope startLine="1485" endLine="1487" />
        <scope startLine="1487" endLine="1489" />
        <comment>y is NaN</comment>
      </scope>
      <scope startLine="1492" endLine="1502">
        <scope startLine="1493" endLine="1495" />
        <scope startLine="1497" endLine="1499" />
        <scope startLine="1499" endLine="1501" />
      </scope>
      <scope startLine="1504" endLine="1526">
        <scope startLine="1505" endLine="1507" />
        <scope startLine="1509" endLine="1516">
          <declaration type="long" name="yi" />
          <scope startLine="1511" endLine="1513" />
        </scope>
        <scope startLine="1518" endLine="1525">
          <declaration type="long" name="yi" />
          <scope startLine="1520" endLine="1522" />
        </scope>
        <comment>y is NaN</comment>
      </scope>
      <scope startLine="1528" endLine="1539">
        <scope startLine="1530" endLine="1532" />
        <scope startLine="1534" endLine="1536" />
        <scope startLine="1536" endLine="1538" />
      </scope>
      <scope startLine="1542" endLine="1554">
        <scope startLine="1544" endLine="1546" />
        <scope startLine="1548" endLine="1551" />
        <scope startLine="1551" endLine="1553" />
        <comment>y is an even integer in this case</comment>
        <comment>If y is an integer</comment>
      </scope>
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <scope startLine="1559" endLine="1563">
        <declaration type="double" name="tmp1" />
      </scope>
      <scope startLine="1563" endLine="1568">
        <declaration type="double" name="tmp1" />
        <declaration type="double" name="tmp2" />
      </scope>
      <declaration type="double" name="lores" />
      <scope startLine="1572" endLine="1574">
        <comment>don't allow this to be converted to NaN</comment>
      </scope>
      <declaration type="double" name="lna" />
      <declaration type="double" name="lnb" />
      <declaration type="double" name="tmp1" />
      <declaration type="double" name="tmp2" />
      <declaration type="double" name="aa" />
      <declaration type="double" name="ab" />
      <declaration type="double" name="z" />
      <declaration type="double" name="result" />
      <comment>Handle special case x<0</comment>
      <comment>Split y into ya and yb such that y = ya+yb</comment>
      <comment>Compute ln(x)</comment>
      <comment>resplit lns</comment>
      <comment>y*ln(x) = (aa+ab)</comment>
      <comment>result = result + result * z;</comment>
    </method>
    <javadoc>
      <text>* Raise a double to an int power.</text>
      <param>d Number to raise.</param>
      <param>e Exponent.</param>
      <return>d<sup>e</sup></return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="pow" startLine="1613" endLine="1670">
      <scope startLine="1615" endLine="1617" />
      <scope startLine="1617" endLine="1620" />
      <declaration type="int" name="splitFactor" />
      <declaration type="double" name="cd" />
      <declaration type="double" name="d1High" />
      <declaration type="double" name="d1Low" />
      <declaration type="double" name="resultHigh" />
      <declaration type="double" name="resultLow" />
      <declaration type="double" name="d2p" />
      <declaration type="double" name="d2pHigh" />
      <declaration type="double" name="d2pLow" />
      <scope startLine="1638" endLine="1666">
        <scope startLine="1640" endLine="1650">
          <declaration type="double" name="tmpHigh" />
          <declaration type="double" name="cRH" />
          <declaration type="double" name="rHH" />
          <declaration type="double" name="rHL" />
          <declaration type="double" name="tmpLow" />
        </scope>
        <declaration type="double" name="tmpHigh" />
        <declaration type="double" name="cD2pH" />
        <declaration type="double" name="d2pHH" />
        <declaration type="double" name="d2pHL" />
        <declaration type="double" name="tmpLow" />
        <declaration type="double" name="cTmpH" />
        <comment>accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm</comment>
        <comment>beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties</comment>
        <comment>accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm</comment>
        <comment>beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties</comment>
      </scope>
      <comment>split d as two 26 bits numbers</comment>
      <comment>beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties</comment>
      <comment>prepare result</comment>
      <comment>d^(2p)</comment>
    </method>
    <javadoc>
      <text>* Computes sin(x) - x, where |x| < 1/16.
 * Use a Remez polynomial approximation.</text>
      <param>x a number smaller than 1/16</param>
      <return>sin(x) - x</return>
    </javadoc>
    <method type="double" name="polySine" startLine="1679" endLine="1691">
      <declaration type="double" name="x2" />
      <declaration type="double" name="p" />
      <comment>p *= x2;</comment>
      <comment>p *= x;</comment>
    </method>
    <javadoc>
      <text>* Computes cos(x) - 1, where |x| < 1/16.
 * Use a Remez polynomial approximation.</text>
      <param>x a number smaller than 1/16</param>
      <return>cos(x) - 1</return>
    </javadoc>
    <method type="double" name="polyCosine" startLine="1699" endLine="1709">
      <declaration type="double" name="x2" />
      <declaration type="double" name="p" />
    </method>
    <javadoc>
      <text>* Compute sine over the first quadrant (0 < x < pi/2).
 * Use combination of table lookup and rational polynomial expansion.</text>
      <param>xa number from which sine is requested</param>
      <param>xb extra bits for x (may be 0.0)</param>
      <return>sin(xa + xb)</return>
    </javadoc>
    <method type="double" name="sinQ" startLine="1718" endLine="1833">
      <declaration type="int" name="idx" />
      <declaration type="double" name="epsilon" />
      <declaration type="double" name="sintA" />
      <declaration type="double" name="sintB" />
      <declaration type="double" name="costA" />
      <declaration type="double" name="costB" />
      <declaration type="double" name="sinEpsA" />
      <declaration type="double" name="sinEpsB" />
      <declaration type="double" name="cosEpsA" />
      <declaration type="double" name="cosEpsB" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="temp2" />
      <declaration type="double" name="result" />
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="t" />
      <declaration type="double" name="c" />
      <declaration type="double" name="d" />
      <scope startLine="1821" endLine="1828">
        <comment>approximate cosine*xb</comment>
      </scope>
      <comment>idx*0.125;</comment>
      <comment>Table lookups</comment>
      <comment>Polynomial eval of sin(epsilon), cos(epsilon)</comment>
      <comment>Split epsilon   xa + xb = x</comment>
      <comment>Compute sin(x) by angle addition formula</comment>
      <comment>Compute the following sum:

 result = sintA + costAsinEpsA + sintAcosEpsB + costAsinEpsB +
          sintB + costBsinEpsA + sintBcosEpsB + costBsinEpsB;

 Ranges of elements

 xxxtA   0            PI2
 xxxtB   -1.5e-9      1.5e-9
 sinEpsA -0.0625      0.0625
 sinEpsB -6e-11       6e-11
 cosEpsA  1.0
 cosEpsB  0           -0.0625</comment>
      <comment>result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +</comment>
      <comment>sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;</comment>
      <comment>result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;</comment>
      <comment>result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;</comment>
      <comment>t = sintAcosEpsB;
c = a + t;
d = -(c - a - t);
a = c;
b = b + d;

t = costAsinEpsB;
c = a + t;
d = -(c - a - t);
a = c;
b = b + d;</comment>
      <comment>t = sintB;
c = a + t;
d = -(c - a - t);
a = c;
b = b + d;

t = costBsinEpsA;
c = a + t;
d = -(c - a - t);
a = c;
b = b + d;

t = sintBcosEpsB;
c = a + t;
d = -(c - a - t);
a = c;
b = b + d;

t = costBsinEpsB;
c = a + t;
d = -(c - a - t);
a = c;
b = b + d;</comment>
    </method>
    <javadoc>
      <text>* Compute cosine in the first quadrant by subtracting input from PI/2 and
 * then calling sinQ.  This is more accurate as the input approaches PI/2.</text>
      <param>xa number from which cosine is requested</param>
      <param>xb extra bits for x (may be 0.0)</param>
      <return>cos(xa + xb)</return>
    </javadoc>
    <method type="double" name="cosQ" startLine="1842" endLine="1851">
      <declaration type="double" name="pi2a" />
      <declaration type="double" name="pi2b" />
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
    </method>
    <javadoc>
      <text>* Compute tangent (or cotangent) over the first quadrant.   0 < x < pi/2
 * Use combination of table lookup and rational polynomial expansion.</text>
      <param>xa number from which sine is requested</param>
      <param>xb extra bits for x (may be 0.0)</param>
      <param>cotanFlag if true, compute the cotangent instead of the tangent</param>
      <return>tan(xa+xb) (or cotangent, depending on cotanFlag)</return>
    </javadoc>
    <method type="double" name="tanQ" startLine="1861" endLine="1996">
      <declaration type="int" name="idx" />
      <declaration type="double" name="epsilon" />
      <declaration type="double" name="sintA" />
      <declaration type="double" name="sintB" />
      <declaration type="double" name="costA" />
      <declaration type="double" name="costB" />
      <declaration type="double" name="sinEpsA" />
      <declaration type="double" name="sinEpsB" />
      <declaration type="double" name="cosEpsA" />
      <declaration type="double" name="cosEpsB" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="temp2" />
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="t" />
      <declaration type="double" name="c" />
      <declaration type="double" name="d" />
      <declaration type="double" name="sina" />
      <declaration type="double" name="sinb" />
      <declaration type="double" name="cosa" />
      <declaration type="double" name="cosb" />
      <scope startLine="1951" endLine="1955">
        <declaration type="double" name="tmp" />
      </scope>
      <declaration type="double" name="est" />
      <declaration type="double" name="esta" />
      <declaration type="double" name="estb" />
      <declaration type="double" name="cosaa" />
      <declaration type="double" name="cosab" />
      <declaration type="double" name="err" />
      <scope startLine="1984" endLine="1993">
        <declaration type="double" name="xbadj" />
        <scope startLine="1988" endLine="1990" />
        <comment>tan' = 1 + tan^2      cot' = -(1 + cot^2)</comment>
        <comment>Approximate impact of xb</comment>
      </scope>
      <comment>idx*0.125;</comment>
      <comment>Table lookups</comment>
      <comment>Polynomial eval of sin(epsilon), cos(epsilon)</comment>
      <comment>Split epsilon   xa + xb = x</comment>
      <comment>Compute sin(x) by angle addition formula</comment>
      <comment>Compute the following sum:

 result = sintA + costAsinEpsA + sintAcosEpsB + costAsinEpsB +
          sintB + costBsinEpsA + sintBcosEpsB + costBsinEpsB;

 Ranges of elements

 xxxtA   0            PI2
 xxxtB   -1.5e-9      1.5e-9
 sinEpsA -0.0625      0.0625
 sinEpsB -6e-11       6e-11
 cosEpsA  1.0
 cosEpsB  0           -0.0625</comment>
      <comment>result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +</comment>
      <comment>sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;</comment>
      <comment>result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;</comment>
      <comment>result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;</comment>
      <comment>Compute sine</comment>
      <comment>Compute cosine</comment>
      <comment>estimate and correct, compute 1.0(cosa+cosb)</comment>
      <comment>double est = (sina+sinb)(cosa+cosb);
double err = (sina - cosaest) + (sinb - cosbest);
est += err(cosa+cosb);
err = (sina - cosaest) + (sinb - cosbest);</comment>
      <comment>f(x) = 1/x,   f'(x) = -1/x^2</comment>
      <comment>Split the estimate to get more accurate read on division rounding</comment>
      <comment>double err = (sina - est*cosa)/cosa;   Correction for division rounding</comment>
      <comment>Correction for division rounding</comment>
      <comment>Change in est due to sinb</comment>
      <comment>Change in est due to cosb</comment>
    </method>
    <javadoc>
      <text>* Reduce the input argument using the Payne and Hanek method.
 * This is good for all inputs 0.0 < x < inf
 * Output is remainder after dividing by PI/2
 * The result array should contain 3 numbers.
 * result[0] is the integer portion, so mod 4 this gives the quadrant.
 * result[1] is the upper bits of the remainder
 * result[2] is the lower bits of the remainder</text>
      <param>x number to reduce</param>
      <param>result placeholder where to put the result</param>
    </javadoc>
    <method type="void" name="reducePayneHanek" startLine="2010" endLine="2219">
      <declaration type="long" name="inbits" />
      <declaration type="int" name="exponent" />
      <declaration type="long" name="shpi0" />
      <declaration type="long" name="shpiA" />
      <declaration type="long" name="shpiB" />
      <declaration type="int" name="idx" />
      <declaration type="int" name="shift" />
      <scope startLine="2030" endLine="2035" />
      <scope startLine="2035" endLine="2039" />
      <declaration type="long" name="a" />
      <declaration type="long" name="b" />
      <declaration type="long" name="c" />
      <declaration type="long" name="d" />
      <declaration type="long" name="ac" />
      <declaration type="long" name="bd" />
      <declaration type="long" name="bc" />
      <declaration type="long" name="ad" />
      <declaration type="long" name="prodB" />
      <declaration type="long" name="prodA" />
      <declaration type="boolean" name="bita" />
      <declaration type="boolean" name="bitb" />
      <declaration type="boolean" name="bitsum" />
      <scope startLine="2062" endLine="2064" />
      <scope startLine="2076" endLine="2078" />
      <scope startLine="2096" endLine="2098" />
      <declaration type="int" name="intPart" />
      <declaration type="long" name="prod2B" />
      <declaration type="long" name="prod2A" />
      <scope startLine="2148" endLine="2150" />
      <scope startLine="2162" endLine="2164" />
      <scope startLine="2182" endLine="2184" />
      <scope startLine="2204" endLine="2206" />
      <declaration type="double" name="tmpA" />
      <declaration type="double" name="tmpB" />
      <declaration type="double" name="sumA" />
      <declaration type="double" name="sumB" />
      <comment>Convert input double to bits</comment>
      <comment>Convert to fixed point representation</comment>
      <comment>Normalize input to be between 0.5 and 1.0</comment>
      <comment>Based on the exponent, get a shifted copy of recip2pi</comment>
      <comment>Multiply input by shpiA</comment>
      <comment>Carry</comment>
      <comment>Carry</comment>
      <comment>Multiply input by shpiB</comment>
      <comment>Collect terms</comment>
      <comment>Carry</comment>
      <comment>Multiply by shpi0</comment>
      <comment>prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
 PI2, so use the following steps:
 1.) multiply by 4.
 2.) do a fixed point muliply by PI4.
 3.) Convert to floating point.
 4.) Multiply by 2</comment>
      <comment>This identifies the quadrant</comment>
      <comment>Multiply by 4</comment>
      <comment>Multiply by PI4</comment>
      <comment>Carry</comment>
      <comment>Carry</comment>
      <comment>Multiply input by pio4bits[1]</comment>
      <comment>Collect terms</comment>
      <comment>Carry</comment>
      <comment>Multiply inputB by pio4bits[0]</comment>
      <comment>Collect terms</comment>
      <comment>Carry</comment>
      <comment>Convert to double</comment>
      <comment>High order 52 bits</comment>
      <comment>Low bits</comment>
      <comment>Multiply by PI2 and return</comment>
    </method>
    <javadoc>
      <text>* Sine function.</text>
      <param>x Argument.</param>
      <return>sin(x)</return>
    </javadoc>
    <method type="double" name="sin" startLine="2227" endLine="2286">
      <declaration type="boolean" name="negative" />
      <declaration type="int" name="quadrant" />
      <declaration type="double" name="xa" />
      <declaration type="double" name="xb" />
      <scope startLine="2235" endLine="2238" />
      <scope startLine="2241" endLine="2247">
        <declaration type="long" name="bits" />
        <scope startLine="2243" endLine="2245" />
      </scope>
      <scope startLine="2249" endLine="2251" />
      <scope startLine="2254" endLine="2263">
        <declaration type="double[]" name="reduceResults" />
        <comment>PI * (2**20)</comment>
        <comment>Argument too big for CodyWaite reduction.  Must use</comment>
        <comment>PayneHanek.</comment>
      </scope>
      <scope startLine="2263" endLine="2268">
        <declaration type="CodyWaite" name="cw" />
      </scope>
      <scope startLine="2270" endLine="2272">
        <comment>Flip bit 1</comment>
      </scope>
      <comment>Take absolute value of the input</comment>
      <comment>Check for zero and negative zero</comment>
      <comment>Perform any argument reduction</comment>
    </method>
    <javadoc>
      <text>* Cosine function.</text>
      <param>x Argument.</param>
      <return>cos(x)</return>
    </javadoc>
    <method type="double" name="cos" startLine="2294" endLine="2340">
      <declaration type="int" name="quadrant" />
      <declaration type="double" name="xa" />
      <scope startLine="2299" endLine="2301" />
      <scope startLine="2303" endLine="2305" />
      <declaration type="double" name="xb" />
      <scope startLine="2309" endLine="2318">
        <declaration type="double[]" name="reduceResults" />
        <comment>PI * (2**20)</comment>
        <comment>Argument too big for CodyWaite reduction.  Must use</comment>
        <comment>PayneHanek.</comment>
      </scope>
      <scope startLine="2318" endLine="2323">
        <declaration type="CodyWaite" name="cw" />
      </scope>
      <comment>Take absolute value of the input</comment>
      <comment>Perform any argument reduction</comment>
      <comment>if (negative)</comment>
      <comment>quadrant = (quadrant + 2) % 4;</comment>
    </method>
    <javadoc>
      <text>* Tangent function.</text>
      <param>x Argument.</param>
      <return>tan(x)</return>
    </javadoc>
    <method type="double" name="tan" startLine="2348" endLine="2417">
      <declaration type="boolean" name="negative" />
      <declaration type="int" name="quadrant" />
      <declaration type="double" name="xa" />
      <scope startLine="2354" endLine="2357" />
      <scope startLine="2360" endLine="2366">
        <declaration type="long" name="bits" />
        <scope startLine="2362" endLine="2364" />
      </scope>
      <scope startLine="2368" endLine="2370" />
      <declaration type="double" name="xb" />
      <scope startLine="2374" endLine="2383">
        <declaration type="double[]" name="reduceResults" />
        <comment>PI * (2**20)</comment>
        <comment>Argument too big for CodyWaite reduction.  Must use</comment>
        <comment>PayneHanek.</comment>
      </scope>
      <scope startLine="2383" endLine="2388">
        <declaration type="CodyWaite" name="cw" />
      </scope>
      <scope startLine="2390" endLine="2403">
        <declaration type="double" name="pi2a" />
        <declaration type="double" name="pi2b" />
        <declaration type="double" name="a" />
        <declaration type="double" name="b" />
        <comment>Accuracy suffers between 1.5 and PI/2</comment>
      </scope>
      <declaration type="double" name="result" />
      <scope startLine="2406" endLine="2408" />
      <scope startLine="2408" endLine="2410" />
      <scope startLine="2412" endLine="2414" />
      <comment>Take absolute value of the input</comment>
      <comment>Check for zero and negative zero</comment>
      <comment>Perform any argument reduction</comment>
    </method>
    <javadoc>
      <text>* Arctangent function</text>
      <param>x a number</param>
      <return>atan(x)</return>
    </javadoc>
    <method type="double" name="atan" startLine="2424" endLine="2426" />
    <javadoc>
      <text>* Internal helper function to compute arctangent.</text>
      <param>xa number from which arctangent is requested</param>
      <param>xb extra bits for x (may be 0.0)</param>
      <param>leftPlane if true, result angle must be put in the left half plane</param>
      <return>atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)</return>
    </javadoc>
    <method type="double" name="atan" startLine="2434" endLine="2573">
      <declaration type="boolean" name="negate" />
      <declaration type="int" name="idx" />
      <scope startLine="2438" endLine="2440">
        <comment>Matches +/- 0.0; return correct sign</comment>
      </scope>
      <scope startLine="2442" endLine="2447">
        <comment>negative</comment>
      </scope>
      <scope startLine="2449" endLine="2451">
        <comment>Very large input</comment>
      </scope>
      <scope startLine="2454" endLine="2456" />
      <scope startLine="2456" endLine="2459">
        <declaration type="double" name="oneOverXa" />
      </scope>
      <declaration type="double" name="epsA" />
      <declaration type="double" name="epsB" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <scope startLine="2476" endLine="2483">
        <declaration type="double" name="denom" />
        <comment>If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice</comment>
        <comment>double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);</comment>
        <comment>double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);</comment>
      </scope>
      <scope startLine="2483" endLine="2508">
        <declaration type="double" name="temp2" />
        <declaration type="double" name="za" />
        <declaration type="double" name="zb" />
        <declaration type="double" name="yaa" />
        <declaration type="double" name="yab" />
        <declaration type="double" name="zaa" />
        <declaration type="double" name="zab" />
        <comment>Correct for rounding in division</comment>
      </scope>
      <declaration type="double" name="epsA2" />
      <declaration type="double" name="za" />
      <declaration type="double" name="zb" />
      <declaration type="double" name="result" />
      <declaration type="double" name="resultb" />
      <scope startLine="2554" endLine="2565">
        <declaration type="double" name="pia" />
        <declaration type="double" name="pib" />
        <comment>Result is in the left plane</comment>
      </scope>
      <scope startLine="2568" endLine="2570" />
      <comment>Estimate the closest tabulated arctan value, compute eps = xa-tangentTable</comment>
      <comment>Compute eps = eps  (1.0 + xatangent)</comment>
      <comment>if (idx > 8 || idx == 0)</comment>
      <comment>Evaluate polynomial</comment>
      <comment>yb = -0.09001346640161823;
yb = yb  epsA2 + 0.11110718400605211;
yb = yb  epsA2 + -0.1428571349122913;
yb = yb  epsA2 + 0.19999999999273194;
yb = yb  epsA2 + -0.33333333333333093;
yb = yb  epsA2  epsA;</comment>
      <comment>Add in effect of epsB.   atan'(x) = 1(1+x^2)</comment>
      <comment>result = yb + eighths[idx] + ya;</comment>
    </method>
    <javadoc>
      <text>* Two arguments arctangent function</text>
      <param>y ordinate</param>
      <param>x abscissa</param>
      <return>phase angle of point (x,y) between {@code -PI} and {@code PI}</return>
    </javadoc>
    <method type="double" name="atan2" startLine="2581" endLine="2696">
      <scope startLine="2582" endLine="2584" />
      <scope startLine="2586" endLine="2608">
        <declaration type="double" name="result" />
        <declaration type="double" name="invx" />
        <declaration type="double" name="invy" />
        <scope startLine="2591" endLine="2597">
          <scope startLine="2592" endLine="2594" />
          <scope startLine="2594" endLine="2596" />
        </scope>
        <scope startLine="2599" endLine="2605">
          <scope startLine="2600" endLine="2602" />
          <scope startLine="2602" endLine="2604" />
        </scope>
        <scope startLine="2605" endLine="2607" />
        <comment>X is infinite</comment>
        <comment>return +/- 0.0</comment>
      </scope>
      <scope startLine="2612" endLine="2622">
        <scope startLine="2613" endLine="2615" />
        <scope startLine="2617" endLine="2619" />
      </scope>
      <scope startLine="2624" endLine="2634">
        <scope startLine="2625" endLine="2627" />
        <scope startLine="2629" endLine="2631" />
      </scope>
      <scope startLine="2636" endLine="2644">
        <scope startLine="2637" endLine="2639" />
        <scope startLine="2641" endLine="2643" />
      </scope>
      <scope startLine="2647" endLine="2655">
        <scope startLine="2648" endLine="2650" />
        <scope startLine="2652" endLine="2654" />
      </scope>
      <scope startLine="2659" endLine="2667">
        <scope startLine="2660" endLine="2662" />
        <scope startLine="2664" endLine="2666" />
      </scope>
      <declaration type="double" name="r" />
      <scope startLine="2671" endLine="2673">
        <comment>bypass calculations that can create NaN</comment>
      </scope>
      <declaration type="double" name="ra" />
      <declaration type="double" name="rb" />
      <declaration type="double" name="xa" />
      <declaration type="double" name="xb" />
      <declaration type="double" name="temp" />
      <scope startLine="2688" endLine="2690">
        <comment>Fix up the sign so atan works correctly</comment>
      </scope>
      <declaration type="double" name="result" />
      <comment>y cannot now be zero</comment>
      <comment>Neither y nor x can be infinite or NAN here</comment>
      <comment>Compute ratio r = y/x</comment>
      <comment>Split x</comment>
      <comment>Call atan</comment>
    </method>
    <javadoc>
      <text>* Compute the arc sine of a number.</text>
      <param>x number on which evaluation is done</param>
      <return>arc sine of x</return>
    </javadoc>
    <method type="double" name="asin" startLine="2702" endLine="2772">
      <scope startLine="2703" endLine="2705" />
      <scope startLine="2707" endLine="2709" />
      <scope startLine="2711" endLine="2713" />
      <scope startLine="2715" endLine="2717" />
      <scope startLine="2719" endLine="2721">
        <comment>Matches +/- 0.0; return correct sign</comment>
      </scope>
      <declaration type="double" name="temp" />
      <declaration type="double" name="xa" />
      <declaration type="double" name="xb" />
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <declaration type="double" name="za" />
      <declaration type="double" name="zb" />
      <declaration type="double" name="y" />
      <declaration type="double" name="dx" />
      <declaration type="double" name="r" />
      <declaration type="double" name="ra" />
      <declaration type="double" name="rb" />
      <comment>Compute asin(x) = atan(xsqrt(1-xx))</comment>
      <comment>Split x</comment>
      <comment>Square it</comment>
      <comment>Subtract from 1</comment>
      <comment>Square root</comment>
      <comment>Extend precision of sqrt</comment>
      <comment>Contribution of zb to sqrt</comment>
      <comment>Compute ratio r = x/y</comment>
      <comment>Correct for rounding in division</comment>
      <comment>Add in effect additional bits of sqrt.</comment>
    </method>
    <javadoc>
      <text>* Compute the arc cosine of a number.</text>
      <param>x number on which evaluation is done</param>
      <return>arc cosine of x</return>
    </javadoc>
    <method type="double" name="acos" startLine="2778" endLine="2854">
      <scope startLine="2779" endLine="2781" />
      <scope startLine="2783" endLine="2785" />
      <scope startLine="2787" endLine="2789" />
      <scope startLine="2791" endLine="2793" />
      <scope startLine="2795" endLine="2797" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="xa" />
      <declaration type="double" name="xb" />
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <declaration type="double" name="za" />
      <declaration type="double" name="zb" />
      <declaration type="double" name="y" />
      <declaration type="double" name="r" />
      <scope startLine="2839" endLine="2841">
        <comment>x is effectively zero</comment>
        <comment>so return the appropriate value</comment>
      </scope>
      <declaration type="double" name="ra" />
      <declaration type="double" name="rb" />
      <comment>Compute acos(x) = atan(sqrt(1-xx)x)</comment>
      <comment>Split x</comment>
      <comment>Square it</comment>
      <comment>Subtract from 1</comment>
      <comment>Square root</comment>
      <comment>Extend precision of sqrt</comment>
      <comment>Contribution of zb to sqrt</comment>
      <comment>Compute ratio r = y/x</comment>
      <comment>Did r overflow?</comment>
      <comment>Correct for rounding in division</comment>
      <comment>Add in effect additional bits of sqrt.</comment>
    </method>
    <javadoc>
      <text>* Compute the cubic root of a number.</text>
      <param>x number on which evaluation is done</param>
      <return>cubic root of x</return>
    </javadoc>
    <method type="double" name="cbrt" startLine="2860" endLine="2938">
      <declaration type="long" name="inbits" />
      <declaration type="int" name="exponent" />
      <declaration type="boolean" name="subnormal" />
      <scope startLine="2866" endLine="2876">
        <scope startLine="2867" endLine="2869" />
        <comment>Subnormal, so normalize</comment>
        <comment>2^54</comment>
      </scope>
      <scope startLine="2878" endLine="2881">
        <comment>Nan or infinity.  Don't care which.</comment>
      </scope>
      <declaration type="int" name="exp3" />
      <declaration type="double" name="p2" />
      <declaration type="double" name="mant" />
      <declaration type="double" name="est" />
      <declaration type="double" name="xs" />
      <declaration type="double" name="temp" />
      <declaration type="double" name="ya" />
      <declaration type="double" name="yb" />
      <declaration type="double" name="za" />
      <declaration type="double" name="zb" />
      <declaration type="double" name="temp2" />
      <declaration type="double" name="na" />
      <declaration type="double" name="nb" />
      <scope startLine="2933" endLine="2935">
        <comment>2^-18</comment>
      </scope>
      <comment>Convert input double to bits</comment>
      <comment>Divide the exponent by 3</comment>
      <comment>p2 will be the nearest power of 2 to x with its exponent divided by 3</comment>
      <comment>This will be a number between 1 and 2</comment>
      <comment>Estimate the cube root of mant by polynomial</comment>
      <comment>est should now be good to about 15 bits of precision.   Do 2 rounds of</comment>
      <comment>Newton's method to get closer,  this should get us full double precision</comment>
      <comment>Scale down x for the purpose of doing newtons method.  This avoids over/under flows.</comment>
      <comment>Do one round of Newton's method in extended precision to get the last bit right.</comment>
      <comment>Scale by a power of two, so this is exact.</comment>
    </method>
    <javadoc>
      <text>* Convert degrees to radians, with error of less than 0.5 ULP</text>
      <param>x angle in degrees</param>
      <return>x converted into radians</return>
    </javadoc>
    <method type="double" name="toRadians" startLine="2946" endLine="2963">
      <scope startLine="2947" endLine="2949">
        <comment>Matches +/- 0.0; return correct sign</comment>
      </scope>
      <declaration type="double" name="facta" />
      <declaration type="double" name="factb" />
      <declaration type="double" name="xa" />
      <declaration type="double" name="xb" />
      <declaration type="double" name="result" />
      <scope startLine="2959" endLine="2961">
        <comment>ensure correct sign if calculation underflows</comment>
      </scope>
      <comment>These are PI/180 split into high and low order bits</comment>
    </method>
    <javadoc>
      <text>* Convert radians to degrees, with error of less than 0.5 ULP</text>
      <param>x angle in radians</param>
      <return>x converted into degrees</return>
    </javadoc>
    <method type="double" name="toDegrees" startLine="2971" endLine="2984">
      <scope startLine="2972" endLine="2974">
        <comment>Matches +/- 0.0; return correct sign</comment>
      </scope>
      <declaration type="double" name="facta" />
      <declaration type="double" name="factb" />
      <declaration type="double" name="xa" />
      <declaration type="double" name="xb" />
      <comment>These are 180/PI split into high and low order bits</comment>
    </method>
    <javadoc>
      <text>* Absolute value.</text>
      <param>x number from which absolute value is requested</param>
      <return>abs(x)</return>
    </javadoc>
    <method type="int" name="abs" startLine="2991" endLine="2994">
      <declaration type="int" name="i" />
    </method>
    <javadoc>
      <text>* Absolute value.</text>
      <param>x number from which absolute value is requested</param>
      <return>abs(x)</return>
    </javadoc>
    <method type="long" name="abs" startLine="3001" endLine="3008">
      <declaration type="long" name="l" />
      <comment>l is one if x negative zero else</comment>
      <comment>~l+1 is zero if x is positive, -1 if x is negative</comment>
      <comment>x^(~l+1) is x is x is positive, ~x if x is negative</comment>
      <comment>add around</comment>
    </method>
    <javadoc>
      <text>* Absolute value.</text>
      <param>x number from which absolute value is requested</param>
      <return>abs(x)</return>
    </javadoc>
    <method type="float" name="abs" startLine="3015" endLine="3017" />
    <javadoc>
      <text>* Absolute value.</text>
      <param>x number from which absolute value is requested</param>
      <return>abs(x)</return>
    </javadoc>
    <method type="double" name="abs" startLine="3024" endLine="3026" />
    <javadoc>
      <text>* Compute least significant bit (Unit in Last Position) for a number.</text>
      <param>x number from which ulp is requested</param>
      <return>ulp(x)</return>
    </javadoc>
    <method type="double" name="ulp" startLine="3033" endLine="3038">
      <scope startLine="3034" endLine="3036" />
    </method>
    <javadoc>
      <text>* Compute least significant bit (Unit in Last Position) for a number.</text>
      <param>x number from which ulp is requested</param>
      <return>ulp(x)</return>
    </javadoc>
    <method type="float" name="ulp" startLine="3045" endLine="3050">
      <scope startLine="3046" endLine="3048" />
    </method>
    <javadoc>
      <text>* Multiply a double number by a power of 2.</text>
      <param>d number to multiply</param>
      <param>n power of 2</param>
      <return>d &times; 2<sup>n</sup></return>
    </javadoc>
    <method type="double" name="scalb" startLine="3058" endLine="3134">
      <scope startLine="3061" endLine="3063" />
      <scope startLine="3066" endLine="3068" />
      <scope startLine="3069" endLine="3071" />
      <scope startLine="3072" endLine="3074" />
      <declaration type="long" name="bits" />
      <declaration type="long" name="sign" />
      <declaration type="int" name="exponent" />
      <declaration type="long" name="mantissa" />
      <declaration type="int" name="scaledExponent" />
      <scope startLine="3085" endLine="3109">
        <scope startLine="3087" endLine="3090" />
        <scope startLine="3090" endLine="3105">
          <declaration type="long" name="mostSignificantLostBit" />
          <scope startLine="3099" endLine="3102" />
        </scope>
        <scope startLine="3105" endLine="3108" />
        <comment>we are really in the case n <= -1023</comment>
        <comment>both the input and the result are normal numbers, we only adjust the exponent</comment>
        <comment>the input is a normal number and the result is a subnormal number</comment>
        <comment>recover the hidden mantissa bit</comment>
        <comment>scales down complete mantissa, hence losing least significant bits</comment>
        <comment>we need to add 1 bit to round up the result</comment>
        <comment>no need to compute the mantissa, the number scales down to 0</comment>
      </scope>
      <scope startLine="3109" endLine="3132">
        <scope startLine="3111" endLine="3127">
          <scope startLine="3114" endLine="3117" />
          <scope startLine="3121" endLine="3123" />
          <scope startLine="3123" endLine="3125" />
        </scope>
        <scope startLine="3127" endLine="3129" />
        <scope startLine="3129" endLine="3131" />
        <comment>we are really in the case n >= 1024</comment>
        <comment>the input number is subnormal, normalize it</comment>
      </scope>
      <comment>first simple and fast handling when 2^n can be represented using normal numbers</comment>
      <comment>handle special cases</comment>
      <comment>decompose d</comment>
      <comment>compute scaled exponent</comment>
    </method>
    <javadoc>
      <text>* Multiply a float number by a power of 2.</text>
      <param>f number to multiply</param>
      <param>n power of 2</param>
      <return>f &times; 2<sup>n</sup></return>
    </javadoc>
    <method type="float" name="scalb" startLine="3142" endLine="3218">
      <scope startLine="3145" endLine="3147" />
      <scope startLine="3150" endLine="3152" />
      <scope startLine="3153" endLine="3155" />
      <scope startLine="3156" endLine="3158" />
      <declaration type="int" name="bits" />
      <declaration type="int" name="sign" />
      <declaration type="int" name="exponent" />
      <declaration type="int" name="mantissa" />
      <declaration type="int" name="scaledExponent" />
      <scope startLine="3169" endLine="3193">
        <scope startLine="3171" endLine="3174" />
        <scope startLine="3174" endLine="3189">
          <declaration type="int" name="mostSignificantLostBit" />
          <scope startLine="3183" endLine="3186" />
        </scope>
        <scope startLine="3189" endLine="3192" />
        <comment>we are really in the case n <= -127</comment>
        <comment>both the input and the result are normal numbers, we only adjust the exponent</comment>
        <comment>the input is a normal number and the result is a subnormal number</comment>
        <comment>recover the hidden mantissa bit</comment>
        <comment>scales down complete mantissa, hence losing least significant bits</comment>
        <comment>we need to add 1 bit to round up the result</comment>
        <comment>no need to compute the mantissa, the number scales down to 0</comment>
      </scope>
      <scope startLine="3193" endLine="3216">
        <scope startLine="3195" endLine="3211">
          <scope startLine="3198" endLine="3201" />
          <scope startLine="3205" endLine="3207" />
          <scope startLine="3207" endLine="3209" />
        </scope>
        <scope startLine="3211" endLine="3213" />
        <scope startLine="3213" endLine="3215" />
        <comment>we are really in the case n >= 128</comment>
        <comment>the input number is subnormal, normalize it</comment>
      </scope>
      <comment>first simple and fast handling when 2^n can be represented using normal numbers</comment>
      <comment>handle special cases</comment>
      <comment>decompose f</comment>
      <comment>compute scaled exponent</comment>
    </method>
    <javadoc>
      <text>* Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * The ordering is as follows (increasing):
 * <ul>
 * <li>-INFINITY</li>
 * <li>-MAX_VALUE</li>
 * <li>-MIN_VALUE</li>
 * <li>-0.0</li>
 * <li>+0.0</li>
 * <li>+MIN_VALUE</li>
 * <li>+MAX_VALUE</li>
 * <li>+INFINITY</li>
 * <li></li>
 * <p>
 * If arguments compare equal, then the second argument is returned.
 * <p>
 * If {@code direction} is greater than {@code d},
 * the smallest machine representable number strictly greater than{@code d} is returned; if less, then the largest representable number
 * strictly less than {@code d} is returned.</p>
 * <p>
 * If {@code d} is infinite and direction does not
 * bring it back to finite numbers, it is returned unchanged.</p></text>
      <param>d base number</param>
      <param>direction (the only important thing is whether{@code direction} is greater or smaller than {@code d})</param>
      <return>the next machine representable number in the specified direction</return>
    </javadoc>
    <method type="double" name="nextAfter" startLine="3251" endLine="3274">
      <scope startLine="3254" endLine="3256" />
      <scope startLine="3256" endLine="3258" />
      <scope startLine="3258" endLine="3260" />
      <scope startLine="3260" endLine="3262" />
      <declaration type="long" name="bits" />
      <declaration type="long" name="sign" />
      <scope startLine="3268" endLine="3270" />
      <scope startLine="3270" endLine="3272" />
      <comment>handling of some important special cases</comment>
      <comment>special cases MAX_VALUE to infinity and  MIN_VALUE to 0</comment>
      <comment>are handled just as normal numbers</comment>
      <comment>can use raw bits since already dealt with infinity and NaN</comment>
    </method>
    <javadoc>
      <text>* Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * The ordering is as follows (increasing):
 * <ul>
 * <li>-INFINITY</li>
 * <li>-MAX_VALUE</li>
 * <li>-MIN_VALUE</li>
 * <li>-0.0</li>
 * <li>+0.0</li>
 * <li>+MIN_VALUE</li>
 * <li>+MAX_VALUE</li>
 * <li>+INFINITY</li>
 * <li></li>
 * <p>
 * If arguments compare equal, then the second argument is returned.
 * <p>
 * If {@code direction} is greater than {@code f},
 * the smallest machine representable number strictly greater than{@code f} is returned; if less, then the largest representable number
 * strictly less than {@code f} is returned.</p>
 * <p>
 * If {@code f} is infinite and direction does not
 * bring it back to finite numbers, it is returned unchanged.</p></text>
      <param>f base number</param>
      <param>direction (the only important thing is whether{@code direction} is greater or smaller than {@code f})</param>
      <return>the next machine representable number in the specified direction</return>
    </javadoc>
    <method type="float" name="nextAfter" startLine="3307" endLine="3330">
      <scope startLine="3310" endLine="3312" />
      <scope startLine="3312" endLine="3314" />
      <scope startLine="3314" endLine="3316" />
      <scope startLine="3316" endLine="3318" />
      <declaration type="int" name="bits" />
      <declaration type="int" name="sign" />
      <scope startLine="3324" endLine="3326" />
      <scope startLine="3326" endLine="3328" />
      <comment>handling of some important special cases</comment>
      <comment>special cases MAX_VALUE to infinity and  MIN_VALUE to 0</comment>
      <comment>are handled just as normal numbers</comment>
    </method>
    <javadoc>
      <text>* Get the largest whole number smaller than x.</text>
      <param>x number from which floor is requested</param>
      <return>a double number f such that f is an integer f <= x < f + 1.0</return>
    </javadoc>
    <method type="double" name="floor" startLine="3336" endLine="3357">
      <declaration type="long" name="y" />
      <scope startLine="3339" endLine="3341">
        <comment>NaN</comment>
      </scope>
      <scope startLine="3343" endLine="3345" />
      <scope startLine="3348" endLine="3350" />
      <scope startLine="3352" endLine="3354" />
    </method>
    <javadoc>
      <text>* Get the smallest whole number larger than x.</text>
      <param>x number from which ceil is requested</param>
      <return>a double number c such that c is an integer c - 1.0 < x <= c</return>
    </javadoc>
    <method type="double" name="ceil" startLine="3363" endLine="3382">
      <declaration type="double" name="y" />
      <scope startLine="3366" endLine="3368">
        <comment>NaN</comment>
      </scope>
      <scope startLine="3371" endLine="3373" />
      <scope startLine="3377" endLine="3379" />
    </method>
    <javadoc>
      <text>* Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.</text>
      <param>x number from which nearest whole number is requested</param>
      <return>a double number r such that r is an integer r - 0.5 <= x <= r + 0.5</return>
    </javadoc>
    <method type="double" name="rint" startLine="3388" endLine="3405">
      <declaration type="double" name="y" />
      <declaration type="double" name="d" />
      <scope startLine="3392" endLine="3397">
        <scope startLine="3393" endLine="3395" />
        <comment>Preserve sign of operand</comment>
      </scope>
      <scope startLine="3398" endLine="3400" />
      <declaration type="long" name="z" />
      <comment>half way, round to even</comment>
    </method>
    <javadoc>
      <text>* Get the closest long to x.</text>
      <param>x number from which closest long is requested</param>
      <return>closest long to x</return>
    </javadoc>
    <method type="long" name="round" startLine="3411" endLine="3413" />
    <javadoc>
      <text>* Get the closest int to x.</text>
      <param>x number from which closest int is requested</param>
      <return>closest int to x</return>
    </javadoc>
    <method type="int" name="round" startLine="3419" endLine="3421" />
    <javadoc>
      <text>* Compute the minimum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>a if a is lesser or equal to b, b otherwise</return>
    </javadoc>
    <method type="int" name="min" startLine="3428" endLine="3430" />
    <javadoc>
      <text>* Compute the minimum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>a if a is lesser or equal to b, b otherwise</return>
    </javadoc>
    <method type="long" name="min" startLine="3437" endLine="3439" />
    <javadoc>
      <text>* Compute the minimum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>a if a is lesser or equal to b, b otherwise</return>
    </javadoc>
    <method type="float" name="min" startLine="3446" endLine="3464">
      <scope startLine="3447" endLine="3449" />
      <scope startLine="3450" endLine="3452" />
      <scope startLine="3454" endLine="3456" />
      <declaration type="int" name="bits" />
      <scope startLine="3460" endLine="3462" />
      <comment>if either arg is NaN, return NaN</comment>
      <comment>min(+0.0,-0.0) == -0.0</comment>
      <comment>0x80000000 == Float.floatToRawIntBits(-0.0d)</comment>
    </method>
    <javadoc>
      <text>* Compute the minimum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>a if a is lesser or equal to b, b otherwise</return>
    </javadoc>
    <method type="double" name="min" startLine="3471" endLine="3489">
      <scope startLine="3472" endLine="3474" />
      <scope startLine="3475" endLine="3477" />
      <scope startLine="3479" endLine="3481" />
      <declaration type="long" name="bits" />
      <scope startLine="3485" endLine="3487" />
      <comment>if either arg is NaN, return NaN</comment>
      <comment>min(+0.0,-0.0) == -0.0</comment>
      <comment>0x8000000000000000L == Double.doubleToRawLongBits(-0.0d)</comment>
    </method>
    <javadoc>
      <text>* Compute the maximum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>b if a is lesser or equal to b, a otherwise</return>
    </javadoc>
    <method type="int" name="max" startLine="3496" endLine="3498" />
    <javadoc>
      <text>* Compute the maximum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>b if a is lesser or equal to b, a otherwise</return>
    </javadoc>
    <method type="long" name="max" startLine="3505" endLine="3507" />
    <javadoc>
      <text>* Compute the maximum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>b if a is lesser or equal to b, a otherwise</return>
    </javadoc>
    <method type="float" name="max" startLine="3514" endLine="3532">
      <scope startLine="3515" endLine="3517" />
      <scope startLine="3518" endLine="3520" />
      <scope startLine="3522" endLine="3524" />
      <declaration type="int" name="bits" />
      <scope startLine="3528" endLine="3530" />
      <comment>if either arg is NaN, return NaN</comment>
      <comment>min(+0.0,-0.0) == -0.0</comment>
      <comment>0x80000000 == Float.floatToRawIntBits(-0.0d)</comment>
    </method>
    <javadoc>
      <text>* Compute the maximum of two values</text>
      <param>a first value</param>
      <param>b second value</param>
      <return>b if a is lesser or equal to b, a otherwise</return>
    </javadoc>
    <method type="double" name="max" startLine="3539" endLine="3557">
      <scope startLine="3540" endLine="3542" />
      <scope startLine="3543" endLine="3545" />
      <scope startLine="3547" endLine="3549" />
      <declaration type="long" name="bits" />
      <scope startLine="3553" endLine="3555" />
      <comment>if either arg is NaN, return NaN</comment>
      <comment>min(+0.0,-0.0) == -0.0</comment>
      <comment>0x8000000000000000L == Double.doubleToRawLongBits(-0.0d)</comment>
    </method>
    <javadoc>
      <text>* Returns the hypotenuse of a triangle with sides {@code x} and {@code y}- sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>
 * avoiding intermediate overflow or underflow.
 * <ul>
 * <li> If either argument is infinite, then the result is positive infinity.</li>
 * <li> else, if either argument is NaN then the result is NaN.</li>
 * </ul></text>
      <param>x a value</param>
      <param>y a value</param>
      <return>sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)</return>
    </javadoc>
    <method type="double" name="hypot" startLine="3573" endLine="3606">
      <scope startLine="3574" endLine="3576" />
      <scope startLine="3576" endLine="3578" />
      <scope startLine="3578" endLine="3605">
        <declaration type="int" name="expX" />
        <declaration type="int" name="expY" />
        <scope startLine="3582" endLine="3585" />
        <scope startLine="3585" endLine="3588" />
        <scope startLine="3588" endLine="3603">
          <declaration type="int" name="middleExp" />
          <declaration type="double" name="scaledX" />
          <declaration type="double" name="scaledY" />
          <declaration type="double" name="scaledH" />
        </scope>
        <comment>y is neglectible with respect to x</comment>
        <comment>x is neglectible with respect to y</comment>
        <comment>find an intermediate scale to avoid both overflow and underflow</comment>
        <comment>scale parameters without losing precision</comment>
        <comment>compute scaled hypotenuse</comment>
        <comment>remove scaling</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Computes the remainder as prescribed by the IEEE 754 standard.
 * The remainder value is mathematically equal to {@code x - y*n}where {@code n} is the mathematical integer closest to the exact mathematical value
 * of the quotient {@code x/y}.
 * If two mathematical integers are equally close to {@code x/y} then{@code n} is the integer that is even.
 * <p>
 * <ul>
 * <li>If either operand is NaN, the result is NaN.</li>
 * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>
 * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>
 * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>
 * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>
 * </ul>
 * <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}</text>
      <param>dividend the number to be divided</param>
      <param>divisor the number by which to divide</param>
      <return>the remainder, rounded</return>
    </javadoc>
    <method type="double" name="IEEEremainder" startLine="3628" endLine="3630">
      <comment>TODO provide our own implementation</comment>
    </method>
    <javadoc>
      <text>* Returns the first argument with the sign of the second argument.
 * A NaN {@code sign} argument is treated as positive.</text>
      <param>magnitude the value to return</param>
      <param>sign the sign for the returned value</param>
      <return>the magnitude with the same sign as the {@code sign} argument</return>
    </javadoc>
    <method type="double" name="copySign" startLine="3640" endLine="3651">
      <declaration type="long" name="m" />
      <declaration type="long" name="s" />
      <scope startLine="3647" endLine="3649" />
      <comment>The highest order bit is going to be zero if the</comment>
      <comment>highest order bit of m and s is the same and one otherwise.</comment>
      <comment>So (m^s) will be positive if both m and s have the same sign</comment>
      <comment>and negative otherwise.</comment>
      <comment>don't care about NaN</comment>
      <comment>flip sign</comment>
    </method>
    <javadoc>
      <text>* Returns the first argument with the sign of the second argument.
 * A NaN {@code sign} argument is treated as positive.</text>
      <param>magnitude the value to return</param>
      <param>sign the sign for the returned value</param>
      <return>the magnitude with the same sign as the {@code sign} argument</return>
    </javadoc>
    <method type="float" name="copySign" startLine="3661" endLine="3672">
      <declaration type="int" name="m" />
      <declaration type="int" name="s" />
      <scope startLine="3668" endLine="3670" />
      <comment>The highest order bit is going to be zero if the</comment>
      <comment>highest order bit of m and s is the same and one otherwise.</comment>
      <comment>So (m^s) will be positive if both m and s have the same sign</comment>
      <comment>and negative otherwise.</comment>
      <comment>flip sign</comment>
    </method>
    <javadoc>
      <text>* Return the exponent of a double number, removing the bias.
 * <p>
 * For double numbers of the form 2<sup>x</sup>, the unbiased
 * exponent is exactly x.
 * </p></text>
      <param>d number from which exponent is requested</param>
      <return>exponent for d in IEEE754 representation, without bias</return>
    </javadoc>
    <method type="int" name="getExponent" startLine="3683" endLine="3686">
      <comment>NaN and Infinite will return 1024 anywho so can use raw bits</comment>
    </method>
    <javadoc>
      <text>* Return the exponent of a float number, removing the bias.
 * <p>
 * For float numbers of the form 2<sup>x</sup>, the unbiased
 * exponent is exactly x.
 * </p></text>
      <param>f number from which exponent is requested</param>
      <return>exponent for d in IEEE754 representation, without bias</return>
    </javadoc>
    <method type="int" name="getExponent" startLine="3697" endLine="3700">
      <comment>NaN and Infinite will return the same exponent anywho so can use raw bits</comment>
    </method>
    <javadoc>
      <text>* Print out contents of arrays, and check the length.
 * <p>used to generate the preset arrays originally.</p></text>
      <param>a unused</param>
    </javadoc>
    <method type="void" name="main" startLine="3707" endLine="3720">
      <declaration type="PrintStream" name="out" />
    </method>
    <class name="ExpIntTable" startLine="3722">
      <javadoc>
        <text>* Enclose large data table in nested static class so it's only loaded on first access.</text>
      </javadoc>
      <javadoc>
        <text>* Exponential evaluated at integer values,
 * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].</text>
      </javadoc>
      <declaration type="double[]" name="EXP_INT_TABLE_A" />
      <javadoc>
        <text>* Exponential evaluated at integer values,
 * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]</text>
      </javadoc>
      <declaration type="double[]" name="EXP_INT_TABLE_B" />
      <scope startLine="3733" endLine="3758">
        <scope startLine="3734" endLine="3754">
          <declaration type="double[]" name="tmp" />
          <declaration type="double[]" name="recip" />
          <scope startLine="3742" endLine="3753">
            <scope startLine="3747" endLine="3752" />
          </scope>
        </scope>
        <scope startLine="3754" endLine="3757" />
        <comment>Populate expIntTable</comment>
        <comment>Negative integer powers</comment>
      </scope>
      <class name="ExpFracTable" startLine="3761">
        <javadoc>
          <text>* Enclose large data table in nested static class so it's only loaded on first access.</text>
        </javadoc>
        <javadoc>
          <text>* Exponential over the range of 0 - 1 in increments of 2^-10
 * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
 * 1024 = 2^10</text>
        </javadoc>
        <declaration type="double[]" name="EXP_FRAC_TABLE_A" />
        <javadoc>
          <text>* Exponential over the range of 0 - 1 in increments of 2^-10
 * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].</text>
        </javadoc>
        <declaration type="double[]" name="EXP_FRAC_TABLE_B" />
        <scope startLine="3773" endLine="3791">
          <scope startLine="3774" endLine="3787">
            <declaration type="double[]" name="tmp" />
            <declaration type="double" name="factor" />
            <scope startLine="3782" endLine="3786" />
          </scope>
          <scope startLine="3787" endLine="3790" />
          <comment>Populate expFracTable</comment>
        </scope>
        <class name="lnMant" startLine="3794">
          <javadoc>
            <text>* Enclose large data table in nested static class so it's only loaded on first access.</text>
          </javadoc>
          <javadoc>
            <text>* Extended precision logarithm table over the range 1 - 2 in increments of 2^-10.</text>
          </javadoc>
          <declaration type="double[][]" name="LN_MANT" />
          <scope startLine="3799" endLine="3811">
            <scope startLine="3800" endLine="3808">
              <scope startLine="3804" endLine="3807">
                <declaration type="double" name="d" />
              </scope>
            </scope>
            <scope startLine="3808" endLine="3810" />
            <comment>Populate lnMant table</comment>
          </scope>
          <class name="CodyWaite" startLine="3814">
            <javadoc>
              <text>* Enclose the Cody/Waite reduction (used in "sin", "cos" and "tan").</text>
            </javadoc>
            <javadoc>
              <text>* k</text>
            </javadoc>
            <declaration type="int" name="finalK" />
            <javadoc>
              <text>* remA</text>
            </javadoc>
            <declaration type="double" name="finalRemA" />
            <javadoc>
              <text>* remB</text>
            </javadoc>
            <declaration type="double" name="finalRemB" />
            <javadoc>
              <param>xa Argument.</param>
            </javadoc>
            <method type="constructor" name="CodyWaite" startLine="3826" endLine="3862">
              <declaration type="int" name="k" />
              <declaration type="double" name="remA" />
              <declaration type="double" name="remB" />
              <scope startLine="3834" endLine="3857">
                <declaration type="double" name="a" />
                <declaration type="double" name="b" />
                <scope startLine="3849" endLine="3851" />
                <comment>Remainder is negative, so decrement k and try again.</comment>
                <comment>This should only happen if the input is very close</comment>
                <comment>to an even multiple of pi/2.</comment>
              </scope>
              <comment>Estimate k.</comment>
              <comment>k = (int)(xa / 1.5707963267948966);</comment>
              <comment>Compute remainder.</comment>
            </method>
            <javadoc>
              <return>k</return>
            </javadoc>
            <method type="int" name="getK" startLine="3867" endLine="3869" />
            <javadoc>
              <return>remA</return>
            </javadoc>
            <method type="double" name="getRemA" startLine="3873" endLine="3875" />
            <javadoc>
              <return>remB</return>
            </javadoc>
            <method type="double" name="getRemB" startLine="3879" endLine="3881" />
          </class>
        </class>
      </class>
    </class>
    <comment>0, 1/1024, ... 1024/1024</comment>
    <comment>There are 52 bits in the mantissa of a double.
  For additional precision, the code splits double numbers into two parts,
  by clearing the low order 30 bits if possible, and then performs the arithmetic
  on each half separately.</comment>
    <comment>1073741824L</comment>
    <comment>0xFFFFFFFFC0000000L;</comment>
    <comment>Generic helper methods</comment>
  </class>
</source>
