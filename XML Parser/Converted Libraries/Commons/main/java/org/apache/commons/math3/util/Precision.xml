<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.math.BigDecimal" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="Precision" startLine="26">
    <javadoc>
      <text>* Utilities for comparing numbers.</text>
      <since>3.0</since>
      <version>$Id: Precision.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
    </javadoc>
    <javadoc>
      <text>* <p>
 * Largest double-precision floating-point number such that{@code 1 + EPSILON} is numerically equal to 1. This value is an upper
 * bound on the relative error due to rounding real numbers to double
 * precision floating-point numbers.
 * </p>
 * <p>
 * In IEEE 754 arithmetic, this is 2<sup>-53</sup>.
 * </p></text>
      <see><a href="http://en.wikipedia.org/wiki/Machine_epsilon">Machine epsilon</a></see>
    </javadoc>
    <declaration type="double" name="EPSILON" />
    <javadoc>
      <text>* Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.
 * <br/>
 * In IEEE 754 arithmetic, this is also the smallest normalized
 * number 2<sup>-1022</sup>.</text>
    </javadoc>
    <declaration type="double" name="SAFE_MIN" />
    <javadoc>
      <text>* Exponent offset in IEEE754 representation.</text>
    </javadoc>
    <declaration type="long" name="EXPONENT_OFFSET" />
    <javadoc>
      <text>* Offset to order signed double numbers lexicographically.</text>
    </javadoc>
    <declaration type="long" name="SGN_MASK" />
    <javadoc>
      <text>* Offset to order signed double numbers lexicographically.</text>
    </javadoc>
    <declaration type="int" name="SGN_MASK_FLOAT" />
    <scope startLine="64" endLine="78">
      <comment>This was previously expressed as = 0x1.0p-53;
  However, OpenJDK (Sparc Solaris) cannot handle such small
  constants: MATH-721</comment>
      <comment>This was previously expressed as = 0x1.0p-1022;
 However, OpenJDK (Sparc Solaris) cannot handle such small
 constants: MATH-721</comment>
    </scope>
    <javadoc>
      <text>* Private constructor.</text>
    </javadoc>
    <method type="constructor" name="Precision" startLine="83" endLine="83" />
    <javadoc>
      <text>* Compares two numbers given some amount of allowed error.</text>
      <param>x the first number</param>
      <param>y the second number</param>
      <param>eps the amount of error to allow when checking for equality</param>
      <return><ul><li>0 if  {@link #equals(double,double,double) equals(x, y, eps)}</li>
 * <li>&lt; 0 if !{@link #equals(double,double,double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>
 * <li>> 0 if !{@link #equals(double,double,double) equals(x, y, eps)} &amp;&amp; x > y</li></ul></return>
    </javadoc>
    <method type="int" name="compareTo" startLine="95" endLine="102">
      <scope startLine="96" endLine="98" />
      <scope startLine="98" endLine="100" />
    </method>
    <javadoc>
      <text>* Compares two numbers given some amount of allowed error.
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
 * Bruce Dawson</a></text>
      <param>x first value</param>
      <param>y second value</param>
      <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
      <return><ul><li>0 if  {@link #equals(double,double,int) equals(x, y, maxUlps)}</li>
 * <li>&lt; 0 if !{@link #equals(double,double,int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>
 * <li>> 0 if !{@link #equals(double,double,int) equals(x, y, maxUlps)} &amp;&amp; x > y</li></ul></return>
    </javadoc>
    <method type="int" name="compareTo" startLine="121" endLine="128">
      <scope startLine="122" endLine="124" />
      <scope startLine="124" endLine="126" />
    </method>
    <javadoc>
      <text>* Returns true iff they are equal as defined by{@link #equals(float,float,int) equals(x, y, 1)}.</text>
      <param>x first value</param>
      <param>y second value</param>
      <return>{@code true} if the values are equal.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="138" endLine="140" />
    <javadoc>
      <text>* Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.</text>
      <param>x first value</param>
      <param>y second value</param>
      <return>{@code true} if the values are equal or both are NaN.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equalsIncludingNaN" startLine="151" endLine="153" />
    <javadoc>
      <text>* Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).</text>
      <param>x first value</param>
      <param>y second value</param>
      <param>eps the amount of absolute error to allow.</param>
      <return>{@code true} if the values are equal or within range of each other.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equals" startLine="165" endLine="167" />
    <javadoc>
      <text>* Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).</text>
      <param>x first value</param>
      <param>y second value</param>
      <param>eps the amount of absolute error to allow.</param>
      <return>{@code true} if the values are equal or within range of each other,
 * or both are NaN.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equalsIncludingNaN" startLine="180" endLine="182" />
    <javadoc>
      <text>* Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
 * Bruce Dawson</a></text>
      <param>x first value</param>
      <param>y second value</param>
      <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
      <return>{@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equals" startLine="202" endLine="217">
      <declaration type="int" name="xInt" />
      <declaration type="int" name="yInt" />
      <scope startLine="207" endLine="209" />
      <scope startLine="210" endLine="212" />
      <declaration type="boolean" name="isEqual" />
      <comment>Make lexicographically ordered as a two's-complement integer.</comment>
    </method>
    <javadoc>
      <text>* Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.</text>
      <param>x first value</param>
      <param>y second value</param>
      <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
      <return>{@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equalsIncludingNaN" startLine="231" endLine="233" />
    <javadoc>
      <text>* Returns true iff they are equal as defined by{@link #equals(double,double,int) equals(x, y, 1)}.</text>
      <param>x first value</param>
      <param>y second value</param>
      <return>{@code true} if the values are equal.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="243" endLine="245" />
    <javadoc>
      <text>* Returns true if both arguments are NaN or neither is NaN and they are
 * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.</text>
      <param>x first value</param>
      <param>y second value</param>
      <return>{@code true} if the values are equal or both are NaN.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equalsIncludingNaN" startLine="256" endLine="258" />
    <javadoc>
      <text>* Returns {@code true} if there is no double value strictly between the
 * arguments or the difference between them is within the range of allowed
 * error (inclusive).</text>
      <param>x First value.</param>
      <param>y Second value.</param>
      <param>eps Amount of allowed absolute error.</param>
      <return>{@code true} if the values are two adjacent floating point
 * numbers or they are within range of each other.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="271" endLine="273" />
    <javadoc>
      <text>* Returns {@code true} if there is no double value strictly between the
 * arguments or the reltaive difference between them is smaller or equal
 * to the given tolerance.</text>
      <param>x First value.</param>
      <param>y Second value.</param>
      <param>eps Amount of allowed relative error.</param>
      <return>{@code true} if the values are two adjacent floating point
 * numbers or they are within range of each other.</return>
      <since>3.1</since>
    </javadoc>
    <method type="boolean" name="equalsWithRelativeTolerance" startLine="287" endLine="296">
      <scope startLine="288" endLine="290" />
      <declaration type="double" name="absoluteMax" />
      <declaration type="double" name="relativeDifference" />
    </method>
    <javadoc>
      <text>* Returns true if both arguments are NaN or are equal or within the range
 * of allowed error (inclusive).</text>
      <param>x first value</param>
      <param>y second value</param>
      <param>eps the amount of absolute error to allow.</param>
      <return>{@code true} if the values are equal or within range of each other,
 * or both are NaN.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equalsIncludingNaN" startLine="309" endLine="311" />
    <javadoc>
      <text>* Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
 * Bruce Dawson</a></text>
      <param>x first value</param>
      <param>y second value</param>
      <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
      <return>{@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="330" endLine="345">
      <declaration type="long" name="xInt" />
      <declaration type="long" name="yInt" />
      <scope startLine="335" endLine="337" />
      <scope startLine="338" endLine="340" />
      <declaration type="boolean" name="isEqual" />
      <comment>Make lexicographically ordered as a two's-complement integer.</comment>
    </method>
    <javadoc>
      <text>* Returns true if both arguments are NaN or if they are equal as defined
 * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.</text>
      <param>x first value</param>
      <param>y second value</param>
      <param>maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.</param>
      <return>{@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.</return>
      <since>2.2</since>
    </javadoc>
    <method type="boolean" name="equalsIncludingNaN" startLine="359" endLine="361" />
    <javadoc>
      <text>* Rounds the given value to the specified number of decimal places.
 * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.</text>
      <param>x Value to round.</param>
      <param>scale Number of digits to the right of the decimal point.</param>
      <return>the rounded value.</return>
      <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
    </javadoc>
    <method type="double" name="round" startLine="372" endLine="374" />
    <javadoc>
      <text>* Rounds the given value to the specified number of decimal places.
 * The value is rounded using the given method which is any method defined
 * in {@link BigDecimal}.
 * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is
 * returned unchanged, regardless of the other parameters.</text>
      <param>x Value to round.</param>
      <param>scale Number of digits to the right of the decimal point.</param>
      <param>roundingMethod Rounding method as defined in {@link BigDecimal}.</param>
      <return>the rounded value.</return>
      <throws>ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}and the specified scaling operation would require rounding.</throws>
      <throws>IllegalArgumentException if {@code roundingMethod} does not
 * represent a valid rounding mode.</throws>
      <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
    </javadoc>
    <method type="double" name="round" startLine="393" endLine="406">
      <scope startLine="394" endLine="399" />
      <scope startLine="399" endLine="405">
        <scope startLine="400" endLine="402" />
        <scope startLine="402" endLine="404" />
      </scope>
    </method>
    <javadoc>
      <text>* Rounds the given value to the specified number of decimal places.
 * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.</text>
      <param>x Value to round.</param>
      <param>scale Number of digits to the right of the decimal point.</param>
      <return>the rounded value.</return>
      <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
    </javadoc>
    <method type="float" name="round" startLine="417" endLine="419" />
    <javadoc>
      <text>* Rounds the given value to the specified number of decimal places.
 * The value is rounded using the given method which is any method defined
 * in {@link BigDecimal}.</text>
      <param>x Value to round.</param>
      <param>scale Number of digits to the right of the decimal point.</param>
      <param>roundingMethod Rounding method as defined in {@link BigDecimal}.</param>
      <return>the rounded value.</return>
      <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
      <throws>MathArithmeticException if an exact operation is required but result is not exact</throws>
      <throws>MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.</throws>
    </javadoc>
    <method type="float" name="round" startLine="435" endLine="439">
      <declaration type="float" name="sign" />
      <declaration type="float" name="factor" />
    </method>
    <javadoc>
      <text>* Rounds the given non-negative value to the "nearest" integer. Nearest is
 * determined by the rounding method specified. Rounding methods are defined
 * in {@link BigDecimal}.</text>
      <param>unscaled Value to round.</param>
      <param>sign Sign of the original, scaled value.</param>
      <param>roundingMethod Rounding method, as defined in {@link BigDecimal}.</param>
      <return>the rounded value.</return>
      <throws>MathArithmeticException if an exact operation is required but result is not exact</throws>
      <throws>MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.</throws>
      <since>1.1 (previously in {@code MathUtils}, moved as of version 3.0)</since>
    </javadoc>
    <method type="double" name="roundUnscaled" startLine="457" endLine="534">
      <scope startLine="460" endLine="462" />
      <scope startLine="462" endLine="464" />
      <scope startLine="470" endLine="472" />
      <scope startLine="472" endLine="474" />
      <scope startLine="476" endLine="485">
        <declaration type="double" name="fraction" />
        <scope startLine="479" endLine="481" />
        <scope startLine="481" endLine="483" />
      </scope>
      <scope startLine="486" endLine="502">
        <declaration type="double" name="fraction" />
        <scope startLine="488" endLine="490" />
        <scope startLine="490" endLine="492" />
        <scope startLine="492" endLine="500">
          <scope startLine="495" endLine="497" />
          <scope startLine="497" endLine="499" />
        </scope>
        <comment>The following equality test is intentional and needed for rounding purposes</comment>
        <comment>even</comment>
        <comment>odd</comment>
      </scope>
      <scope startLine="503" endLine="512">
        <declaration type="double" name="fraction" />
        <scope startLine="506" endLine="508" />
        <scope startLine="508" endLine="510" />
      </scope>
      <scope startLine="514" endLine="516" />
    </method>
    <javadoc>
      <text>* Computes a number {@code delta} close to {@code originalDelta} with
 * the property that <pre><code>
 * x + delta - x
 * </code></pre>
 * is exactly machine-representable.
 * This is useful when computing numerical derivatives, in order to reduce
 * roundoff errors.</text>
      <param>x Value.</param>
      <param>originalDelta Offset value.</param>
      <return>a number {@code delta} so that {@code x + delta} and {@code x}differ by a representable floating number.</return>
    </javadoc>
    <method type="double" name="representableDelta" startLine="552" endLine="554" />
  </class>
</source>
