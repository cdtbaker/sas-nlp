<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.linear">
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.Precision" />
  <class name="SchurTransformer" startLine="25">
    <javadoc>
      <text>* Class transforming a general real matrix to Schur form.
 * <p>A m &times; m matrix A can be written as the product of three matrices: A = P
 * &times; T &times; P<sup>T</sup> with P an orthogonal matrix and T an quasi-triangular
 * matrix. Both P and T are m &times; m matrices.</p>
 * <p>Transformation to Schur form is often not a goal by itself, but it is an
 * intermediate step in more general decomposition algorithms like{@link EigenDecomposition eigen decomposition}. This class is therefore
 * intended for internal use by the library and is not public. As a consequence
 * of this explicitly limited scope, many methods directly returns references to
 * internal arrays, not copies.</p>
 * <p>This class is based on the method hqr2 in class EigenvalueDecomposition
 * from the <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a> library.</p></text>
      <see><a href="http://mathworld.wolfram.com/SchurDecomposition.html">Schur Decomposition - MathWorld</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Schur_decomposition">Schur Decomposition - Wikipedia</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Householder_transformation">Householder Transformations</a></see>
      <version>$Id: SchurTransformer.java 1389129 2012-09-23 19:34:02Z tn $</version>
      <since>3.1</since>
    </javadoc>
    <javadoc>
      <text>* Maximum allowed iterations for convergence of the transformation.</text>
    </javadoc>
    <declaration type="int" name="MAX_ITERATIONS" />
    <javadoc>
      <text>* P matrix.</text>
    </javadoc>
    <declaration type="double" name="matrixP" />
    <javadoc>
      <text>* T matrix.</text>
    </javadoc>
    <declaration type="double" name="matrixT" />
    <javadoc>
      <text>* Cached value of P.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedP" />
    <javadoc>
      <text>* Cached value of T.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedT" />
    <javadoc>
      <text>* Cached value of PT.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedPt" />
    <javadoc>
      <text>* Epsilon criteria taken from JAMA code (originally was 2^-52).</text>
    </javadoc>
    <declaration type="double" name="epsilon" />
    <javadoc>
      <text>* Build the transformation to Schur form of a general real matrix.</text>
      <param>matrix matrix to transform</param>
      <throws>NonSquareMatrixException if the matrix is not square</throws>
    </javadoc>
    <method type="constructor" name="SchurTransformer" startLine="69" endLine="84">
      <scope startLine="70" endLine="73" />
      <declaration type="HessenbergTransformer" name="transformer" />
      <comment>transform matrix</comment>
    </method>
    <javadoc>
      <text>* Returns the matrix P of the transform.
 * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p></text>
      <return>the P matrix</return>
    </javadoc>
    <method type="RealMatrix" name="getP" startLine="92" endLine="97">
      <scope startLine="93" endLine="95" />
    </method>
    <javadoc>
      <text>* Returns the transpose of the matrix P of the transform.
 * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p></text>
      <return>the transpose of the P matrix</return>
    </javadoc>
    <method type="RealMatrix" name="getPT" startLine="105" endLine="112">
      <scope startLine="106" endLine="108" />
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Returns the quasi-triangular Schur matrix T of the transform.</text>
      <return>the T matrix</return>
    </javadoc>
    <method type="RealMatrix" name="getT" startLine="119" endLine="126">
      <scope startLine="120" endLine="122" />
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Transform original matrix to Schur form.</text>
      <throws>MaxCountExceededException if the transformation does not converge</throws>
    </javadoc>
    <method type="void" name="transform" startLine="132" endLine="217">
      <declaration type="int" name="n" />
      <declaration type="double" name="norm" />
      <declaration type="ShiftInfo" name="shift" />
      <declaration type="int" name="iteration" />
      <declaration type="int" name="iu" />
      <scope startLine="144" endLine="216">
        <declaration type="int" name="il" />
        <scope startLine="150" endLine="155" />
        <scope startLine="155" endLine="200">
          <declaration type="double" name="p" />
          <declaration type="double" name="q" />
          <scope startLine="162" endLine="197">
            <declaration type="double" name="z" />
            <scope startLine="164" endLine="166" />
            <scope startLine="166" endLine="168" />
            <declaration type="double" name="x" />
            <declaration type="double" name="s" />
            <declaration type="double" name="r" />
            <scope startLine="178" endLine="182" />
            <scope startLine="185" endLine="189" />
            <scope startLine="192" endLine="196" />
          </scope>
        </scope>
        <scope startLine="200" endLine="215">
          <scope startLine="205" endLine="208" />
          <declaration type="double[]" name="hVec" />
          <declaration type="int" name="im" />
        </scope>
        <comment>Look for single small sub-diagonal element</comment>
        <comment>Check for convergence</comment>
        <comment>One root found</comment>
        <comment>Two roots found</comment>
        <comment>Row modification</comment>
        <comment>Column modification</comment>
        <comment>Accumulate transformations</comment>
        <comment>No convergence yet</comment>
        <comment>stop transformation after too many iterations</comment>
        <comment>the initial houseHolder vector for the QR step</comment>
      </scope>
      <comment>compute matrix norm</comment>
      <comment>shift information</comment>
      <comment>Outer loop over eigenvalue index</comment>
    </method>
    <javadoc>
      <text>* Computes the L1 norm of the (quasi-)triangular matrix T.</text>
      <return>the L1 norm of matrix T</return>
    </javadoc>
    <method type="double" name="getNorm" startLine="224" endLine="233">
      <declaration type="double" name="norm" />
      <scope startLine="226" endLine="231">
        <scope startLine="228" endLine="230" />
        <comment>as matrix T is (quasi-)triangular, also take the sub-diagonal element into account</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Find the first small sub-diagonal element and returns its index.</text>
      <param>startIdx the starting index for the search</param>
      <param>norm the L1 norm of the matrix</param>
      <return>the index of the first small sub-diagonal element</return>
    </javadoc>
    <method type="int" name="findSmallSubDiagonalElement" startLine="242" endLine="255">
      <declaration type="int" name="l" />
      <scope startLine="244" endLine="253">
        <declaration type="double" name="s" />
        <scope startLine="246" endLine="248" />
        <scope startLine="249" endLine="251" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the shift for the current iteration.</text>
      <param>l the index of the small sub-diagonal element</param>
      <param>idx the current eigenvalue index</param>
      <param>iteration the current iteration</param>
      <param>shift holder for shift information</param>
    </javadoc>
    <method type="void" name="computeShift" startLine="265" endLine="303">
      <scope startLine="269" endLine="272" />
      <scope startLine="275" endLine="284">
        <scope startLine="277" endLine="279" />
        <declaration type="double" name="s" />
      </scope>
      <scope startLine="287" endLine="302">
        <declaration type="double" name="s" />
        <scope startLine="290" endLine="301">
          <scope startLine="292" endLine="294" />
          <scope startLine="296" endLine="298" />
        </scope>
      </scope>
      <comment>Form shift</comment>
      <comment>Wilkinson's original ad hoc shift</comment>
      <comment>MATLAB's new ad hoc shift</comment>
    </method>
    <javadoc>
      <text>* Initialize the householder vectors for the QR step.</text>
      <param>il the index of the small sub-diagonal element</param>
      <param>iu the current eigenvalue index</param>
      <param>shift shift information holder</param>
      <param>hVec the initial houseHolder vector</param>
      <return>the start index for the QR step</return>
    </javadoc>
    <method type="int" name="initQRStep" startLine="314" endLine="341">
      <declaration type="int" name="im" />
      <scope startLine="317" endLine="338">
        <declaration type="double" name="z" />
        <declaration type="double" name="r" />
        <declaration type="double" name="s" />
        <scope startLine="325" endLine="327" />
        <declaration type="double" name="lhs" />
        <declaration type="double" name="rhs" />
        <scope startLine="334" endLine="336" />
      </scope>
      <comment>Look for two consecutive small sub-diagonal elements</comment>
    </method>
    <javadoc>
      <text>* Perform a double QR step involving rows l:idx and columns m:n</text>
      <param>il the index of the small sub-diagonal element</param>
      <param>im the start index for the QR step</param>
      <param>iu the current eigenvalue index</param>
      <param>shift shift information holder</param>
      <param>hVec the initial houseHolder vector</param>
    </javadoc>
    <method type="void" name="performDoubleQRStep" startLine="353" endLine="436">
      <declaration type="int" name="n" />
      <declaration type="double" name="p" />
      <declaration type="double" name="q" />
      <declaration type="double" name="r" />
      <scope startLine="360" endLine="427">
        <declaration type="boolean" name="notlast" />
        <scope startLine="362" endLine="372">
          <scope startLine="367" endLine="371" />
        </scope>
        <scope startLine="373" endLine="375" />
        <declaration type="double" name="s" />
        <scope startLine="377" endLine="379" />
        <scope startLine="380" endLine="426">
          <scope startLine="381" endLine="383" />
          <scope startLine="383" endLine="385" />
          <declaration type="double" name="z" />
          <scope startLine="394" endLine="402">
            <scope startLine="396" endLine="399" />
          </scope>
          <scope startLine="405" endLine="413">
            <scope startLine="407" endLine="410" />
          </scope>
          <declaration type="int" name="high" />
          <scope startLine="417" endLine="425">
            <scope startLine="419" endLine="422" />
          </scope>
        </scope>
        <comment>Row modification</comment>
        <comment>Column modification</comment>
        <comment>Accumulate transformations</comment>
        <comment>(s != 0)</comment>
        <comment>k loop</comment>
      </scope>
      <scope startLine="430" endLine="435">
        <scope startLine="432" endLine="434" />
      </scope>
      <comment>clean up pollution due to round-off errors</comment>
    </method>
    <class name="ShiftInfo" startLine="438">
      <javadoc>
        <text>* Internal data structure holding the current shift information.
 * Contains variable names as present in the original JAMA code.</text>
      </javadoc>
      <javadoc>
        <text>* x shift info</text>
      </javadoc>
      <declaration type="double" name="x" />
      <javadoc>
        <text>* y shift info</text>
      </javadoc>
      <declaration type="double" name="y" />
      <javadoc>
        <text>* w shift info</text>
      </javadoc>
      <declaration type="double" name="w" />
      <javadoc>
        <text>* Indicates an exceptional shift.</text>
      </javadoc>
      <declaration type="double" name="exShift" />
    </class>
    <comment>CHECKSTYLE: stop all</comment>
    <comment>CHECKSTYLE: resume all</comment>
  </class>
</source>
