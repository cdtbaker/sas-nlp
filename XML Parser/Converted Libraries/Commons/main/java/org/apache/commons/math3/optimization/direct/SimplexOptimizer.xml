<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optimization.direct">
  <import name="java.util.Comparator" />
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.optimization.GoalType" />
  <import name="org.apache.commons.math3.optimization.ConvergenceChecker" />
  <import name="org.apache.commons.math3.optimization.PointValuePair" />
  <import name="org.apache.commons.math3.optimization.SimpleValueChecker" />
  <import name="org.apache.commons.math3.optimization.MultivariateOptimizer" />
  <import name="org.apache.commons.math3.optimization.OptimizationData" />
  <class name="SimplexOptimizer" extends="BaseAbstractMultivariateOptimizer<MultivariateFunction>" startLine="31">
    <implements name="MultivariateOptimizer" />
    <javadoc>
      <text>* This class implements simplex-based direct search optimization.
 * <p>
 * Direct search methods only use objective function values, they do
 * not need derivatives and don't either try to compute approximation
 * of the derivatives. According to a 1996 paper by Margaret H. Wright
 * (<a href="http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz">Direct
 * Search Methods: Once Scorned, Now Respectable</a>), they are used
 * when either the computation of the derivative is impossible (noisy
 * functions, unpredictable discontinuities) or difficult (complexity,
 * computation cost). In the first cases, rather than an optimum, a
 * <em>not too bad</em> point is desired. In the latter cases, an
 * optimum is desired but cannot be reasonably found. In all cases
 * direct search methods can be useful.
 * </p>
 * <p>
 * Simplex-based direct search methods are based on comparison of
 * the objective function values at the vertices of a simplex (which is a
 * set of n+1 points in dimension n) that is updated by the algorithms
 * steps.
 * <p>
 * <p>
 * The {@link #setSimplex(AbstractSimplex) setSimplex} method <em>must</em>
 * be called prior to calling the {@code optimize} method.
 * </p>
 * <p>
 * Each call to {@link #optimize(int,MultivariateFunction,GoalType,double[])optimize} will re-use the start configuration of the current simplex and
 * move it such that its first vertex is at the provided start point of the
 * optimization. If the {@code optimize} method is called to solve a different
 * problem and the number of parameters change, the simplex must be
 * re-initialized to one with the appropriate dimensions.
 * </p>
 * <p>
 * Convergence is checked by providing the <em>worst</em> points of
 * previous and current simplex to the convergence checker, not the best
 * ones.
 * </p>
 * <p>
 * This simplex optimizer implementation does not directly support constrained
 * optimization with simple bounds, so for such optimizations, either a more
 * dedicated method must be used like {@link CMAESOptimizer} or {@link BOBYQAOptimizer}, or the optimized method must be wrapped in an adapter like{@link MultivariateFunctionMappingAdapter} or {@link MultivariateFunctionPenaltyAdapter}.
 * </p></text>
      <see>AbstractSimplex</see>
      <see>MultivariateFunctionMappingAdapter</see>
      <see>MultivariateFunctionPenaltyAdapter</see>
      <see>CMAESOptimizer</see>
      <see>BOBYQAOptimizer</see>
      <version>$Id: SimplexOptimizer.java 1422230 2012-12-15 12:11:13Z erans $</version>
      <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Simplex.</text>
    </javadoc>
    <declaration type="AbstractSimplex" name="simplex" />
    <javadoc>
      <text>* Constructor using a default {@link SimpleValueChecker convergence
 * checker}.</text>
      <deprecated>See {@link SimpleValueChecker#SimpleValueChecker()}</deprecated>
    </javadoc>
    <method type="constructor" name="SimplexOptimizer" startLine="101" endLine="103" />
    <javadoc>
      <param>checker Convergence checker.</param>
    </javadoc>
    <method type="constructor" name="SimplexOptimizer" startLine="108" endLine="110" />
    <javadoc>
      <param>rel Relative threshold.</param>
      <param>abs Absolute threshold.</param>
    </javadoc>
    <method type="constructor" name="SimplexOptimizer" startLine="116" endLine="118" />
    <javadoc>
      <text>* Set the simplex algorithm.</text>
      <param>simplex Simplex.</param>
      <deprecated>As of 3.1. The initial simplex can now be passed as an
 * argument of the {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])}method.</deprecated>
    </javadoc>
    <method type="void" name="setSimplex" startLine="129" endLine="131" />
    <javadoc>
      <text>* Optimize an objective function.</text>
      <param>maxEval Allowed number of evaluations of the objective function.</param>
      <param>f Objective function.</param>
      <param>goalType Optimization type.</param>
      <param>optData Optimization data. The following data will be looked for:
 * <ul>
 * <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>
 * <li>{@link AbstractSimplex}</li>
 * </ul></param>
      <return>the point/value pair giving the optimal value for objective
 * function.</return>
    </javadoc>
    <method type="PointValuePair" name="optimizeInternal" startLine="150" endLine="157">
      <comment>Scan "optData" for the input specific to this optimizer.</comment>
      <comment>The parent's method will retrieve the common parameters from</comment>
      <comment>"optData" and call "doOptimize".</comment>
    </method>
    <javadoc>
      <text>* Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
      <param>optData Optimization data. The following data will be looked for:
 * <ul>
 * <li>{@link AbstractSimplex}</li>
 * </ul></param>
    </javadoc>
    <method type="void" name="parseOptimizationData" startLine="168" endLine="177">
      <scope startLine="171" endLine="176">
        <scope startLine="172" endLine="175" />
      </scope>
      <comment>The existing values (as set by the previous call) are reused if</comment>
      <comment>not provided in the argument list.</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="PointValuePair" name="doOptimize" startLine="181" endLine="232">
      <scope startLine="182" endLine="184" />
      <declaration type="MultivariateFunction[]" name="evalFunc" />
      <method type="double" name="value" startLine="190" endLine="192" />
      <declaration type="boolean" name="isMinim" />
      <declaration type="Comparator<PointValuePair>" name="comparator" />
      <method type="int" name="compare" startLine="199" endLine="203">
        <declaration type="double" name="v1" />
        <declaration type="double" name="v2" />
      </method>
      <declaration type="PointValuePair[]" name="previous" />
      <declaration type="int" name="iteration" />
      <declaration type="ConvergenceChecker<PointValuePair>" name="checker" />
      <scope startLine="213" endLine="231">
        <scope startLine="214" endLine="225">
          <declaration type="boolean" name="converged" />
          <scope startLine="216" endLine="220">
            <declaration type="PointValuePair" name="prev" />
          </scope>
          <scope startLine="221" endLine="224" />
        </scope>
        <comment>We have found an optimum.</comment>
        <comment>We still need to search.</comment>
      </scope>
      <comment>Indirect call to "computeObjectiveValue" in order to update the</comment>
      <comment>evaluations counter.</comment>
      <comment>Initialize search.</comment>
    </method>
  </class>
</source>
