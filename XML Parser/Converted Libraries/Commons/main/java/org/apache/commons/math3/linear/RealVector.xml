<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.linear">
  <import name="java.util.Iterator" />
  <import name="java.util.NoSuchElementException" />
  <import name="org.apache.commons.math3.exception.MathUnsupportedOperationException" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.analysis.FunctionUtils" />
  <import name="org.apache.commons.math3.analysis.function.Add" />
  <import name="org.apache.commons.math3.analysis.function.Multiply" />
  <import name="org.apache.commons.math3.analysis.function.Divide" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="RealVector" startLine="37">
    <javadoc>
      <text>* Class defining a real-valued vector with basic algebraic operations.
 * <p>
 * vector element indexing is 0-based -- e.g., {@code getEntry(0)}returns the first element of the vector.
 * </p>
 * <p>
 * The {@code code map} and {@code mapToSelf} methods operate
 * on vectors element-wise, i.e. they perform the same operation (adding a scalar,
 * applying a function ...) on each element in turn. The {@code map}versions create a new vector to hold the result and do not change the instance.
 * The {@code mapToSelf} version uses the instance itself to store the
 * results, so the instance is changed by this method. In all cases, the result
 * vector is returned by the methods, allowing the <i>fluent API</i>
 * style, like this:
 * </p>
 * <pre>
 * RealVector result = v.mapAddToSelf(3.4).mapToSelf(new Tan()).mapToSelf(new Power(2.3));
 * </pre></text>
      <version>$Id: RealVector.java 1422313 2012-12-15 18:53:41Z psteitz $</version>
      <since>2.1</since>
    </javadoc>
    <method name="getDimension" type="int" startLine="61" endLine="66" />
    <javadoc>
      <text>* Returns the size of the vector.</text>
      <return>the size of this vector.</return>
    </javadoc>
    <method name="getEntry" type="double" startLine="68" endLine="76" />
    <javadoc>
      <text>* Return the entry at the specified index.</text>
      <param>index Index location of entry to be fetched.</param>
      <return>the vector entry at {@code index}.</return>
      <throws>OutOfRangeException if the index is not valid.</throws>
      <see>#setEntry(int,double)</see>
    </javadoc>
    <method name="setEntry" type="void" startLine="78" endLine="87" />
    <javadoc>
      <text>* Set a single element.</text>
      <param>index element index.</param>
      <param>value new value for the element.</param>
      <throws>OutOfRangeException if the index is not valid.</throws>
      <see>#getEntry(int)</see>
    </javadoc>
    <javadoc>
      <text>* Change an entry at the specified index.</text>
      <param>index Index location of entry to be set.</param>
      <param>increment Value to add to the vector entry.</param>
      <throws>OutOfRangeException if the index is not valid.</throws>
      <since>3.0</since>
    </javadoc>
    <method type="void" name="addToEntry" startLine="98" endLine="100" />
    <method name="append" type="RealVector" startLine="102" endLine="108" />
    <javadoc>
      <text>* Construct a new vector by appending a vector to this vector.</text>
      <param>v vector to append to this one.</param>
      <return>a new vector.</return>
    </javadoc>
    <method name="append" type="RealVector" startLine="110" endLine="116" />
    <javadoc>
      <text>* Construct a new vector by appending a double to this vector.</text>
      <param>d double to append.</param>
      <return>a new vector.</return>
    </javadoc>
    <method name="getSubVector" type="RealVector" startLine="118" endLine="128" />
    <javadoc>
      <text>* Get a subvector from consecutive elements.</text>
      <param>index index of first element.</param>
      <param>n number of elements to be retrieved.</param>
      <return>a vector containing n elements.</return>
      <throws>OutOfRangeException if the index is not valid.</throws>
      <throws>NotPositiveException if the number of elements is not positive.</throws>
    </javadoc>
    <method name="setSubVector" type="void" startLine="130" endLine="138" />
    <javadoc>
      <text>* Set a sequence of consecutive elements.</text>
      <param>index index of first element to be set.</param>
      <param>v vector containing the values to set.</param>
      <throws>OutOfRangeException if the index is not valid.</throws>
    </javadoc>
    <method name="isNaN" type="boolean" startLine="140" endLine="146" />
    <javadoc>
      <text>* Check whether any coordinate of this vector is {@code NaN}.</text>
      <return>{@code true} if any coordinate of this vector is {@code NaN},{@code false} otherwise.</return>
    </javadoc>
    <method name="isInfinite" type="boolean" startLine="148" endLine="154" />
    <javadoc>
      <text>* Check whether any coordinate of this vector is infinite and none are {@code NaN}.</text>
      <return>{@code true} if any coordinate of this vector is infinite and
 * none are {@code NaN}, {@code false} otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Check if instance and specified vectors have the same dimension.</text>
      <param>v Vector to compare instance with.</param>
      <throws>DimensionMismatchException if the vectors do not
 * have the same dimension.</throws>
    </javadoc>
    <method type="void" name="checkVectorDimensions" startLine="164" endLine="166" />
    <javadoc>
      <text>* Check if instance dimension is equal to some expected value.</text>
      <param>n Expected dimension.</param>
      <throws>DimensionMismatchException if the dimension is
 * inconsistent with the vector size.</throws>
    </javadoc>
    <method type="void" name="checkVectorDimensions" startLine="176" endLine="181">
      <declaration type="int" name="d" />
      <scope startLine="178" endLine="180" />
    </method>
    <javadoc>
      <text>* Check if an index is valid.</text>
      <param>index Index to check.</param>
      <exception>OutOfRangeException if {@code index} is not valid.</exception>
    </javadoc>
    <method type="void" name="checkIndex" startLine="189" endLine="195">
      <scope startLine="191" endLine="194" />
    </method>
    <javadoc>
      <text>* Checks that the indices of a subvector are valid.</text>
      <param>start the index of the first entry of the subvector</param>
      <param>end the index of the last entry of the subvector (inclusive)</param>
      <throws>OutOfRangeException if {@code start} of {@code end} are not valid</throws>
      <throws>NumberIsTooSmallException if {@code end < start}</throws>
      <since>3.1</since>
    </javadoc>
    <method type="void" name="checkIndices" startLine="207" endLine="222">
      <declaration type="int" name="dim" />
      <scope startLine="209" endLine="212" />
      <scope startLine="213" endLine="216" />
      <scope startLine="217" endLine="221">
        <comment>TODO Use more specific error message</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Compute the sum of this vector and {@code v}.
 * Returns a new vector. Does not change instance data.</text>
      <param>v Vector to be added.</param>
      <return>{@code this} + {@code v}.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    </javadoc>
    <method type="RealVector" name="add" startLine="233" endLine="243">
      <declaration type="RealVector" name="result" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="237" endLine="241">
        <declaration type="Entry" name="e" />
        <declaration type="int" name="index" />
      </scope>
    </method>
    <javadoc>
      <text>* Subtract {@code v} from this vector.
 * Returns a new vector. Does not change instance data.</text>
      <param>v Vector to be subtracted.</param>
      <return>{@code this} - {@code v}.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    </javadoc>
    <method type="RealVector" name="subtract" startLine="254" endLine="264">
      <declaration type="RealVector" name="result" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="258" endLine="262">
        <declaration type="Entry" name="e" />
        <declaration type="int" name="index" />
      </scope>
    </method>
    <javadoc>
      <text>* Add a value to each entry.
 * Returns a new vector. Does not change instance data.</text>
      <param>d Value to be added to each entry.</param>
      <return>{@code this} + {@code d}.</return>
    </javadoc>
    <method type="RealVector" name="mapAdd" startLine="273" endLine="275" />
    <javadoc>
      <text>* Add a value to each entry.
 * The instance is changed in-place.</text>
      <param>d Value to be added to each entry.</param>
      <return>{@code this}.</return>
    </javadoc>
    <method type="RealVector" name="mapAddToSelf" startLine="284" endLine="289">
      <scope startLine="285" endLine="287" />
    </method>
    <method name="copy" type="RealVector" startLine="291" endLine="296" />
    <javadoc>
      <text>* Returns a (deep) copy of this vector.</text>
      <return>a vector copy.</return>
    </javadoc>
    <javadoc>
      <text>* Compute the dot product of this vector with {@code v}.</text>
      <param>v Vector with which dot product should be computed</param>
      <return>the scalar dot product between this instance and {@code v}.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    </javadoc>
    <method type="double" name="dotProduct" startLine="306" endLine="314">
      <declaration type="double" name="d" />
      <declaration type="int" name="n" />
      <scope startLine="310" endLine="312" />
    </method>
    <javadoc>
      <text>* Computes the cosine of the angle between this vector and the
 * argument.</text>
      <param>v Vector.</param>
      <return>the cosine of the angle between this vector and {@code v}.</return>
      <throws>MathArithmeticException if {@code this} or {@code v} is the null
 * vector</throws>
      <throws>DimensionMismatchException if the dimensions of {@code this} and{@code v} do not match</throws>
    </javadoc>
    <method type="double" name="cosine" startLine="328" endLine="337">
      <declaration type="double" name="norm" />
      <declaration type="double" name="vNorm" />
      <scope startLine="333" endLine="335" />
    </method>
    <method name="ebeDivide" type="RealVector" startLine="339" endLine="358" />
    <javadoc>
      <text>* Element-by-element division.</text>
      <param>v Vector by which instance elements must be divided.</param>
      <return>a vector containing this[i] / v[i] for all i.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
      <deprecated>As of version 3.1, this method is deprecated, and will be
 * removed in version 4.0. This decision follows the discussion reported in
 * <a href="https://issues.apache.org/jira/browse/MATH-803?focusedCommentId=13399150#comment-13399150">MATH-803</a>.
 * Uses of this method involving sparse implementations of{@link RealVector} might lead to wrong results. Since there is no
 * satisfactory correction to this bug, this method is deprecated. Users who
 * want to preserve this feature are advised to implement{@link RealVectorPreservingVisitor} (possibly ignoring corner cases for
 * the sake of efficiency).</deprecated>
    </javadoc>
    <method name="ebeMultiply" type="RealVector" startLine="360" endLine="379" />
    <javadoc>
      <text>* Element-by-element multiplication.</text>
      <param>v Vector by which instance elements must be multiplied</param>
      <return>a vector containing this[i] * v[i] for all i.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
      <deprecated>As of version 3.1, this method is deprecated, and will be
 * removed in version 4.0. This decision follows the discussion reported in
 * <a href="https://issues.apache.org/jira/browse/MATH-803?focusedCommentId=13399150#comment-13399150">MATH-803</a>.
 * Uses of this method involving sparse implementations of{@link RealVector} might lead to wrong results. Since there is no
 * satisfactory correction to this bug, this method is deprecated. Users who
 * want to preserve this feature are advised to implement{@link RealVectorPreservingVisitor} (possibly ignoring corner cases for
 * the sake of efficiency).</deprecated>
    </javadoc>
    <javadoc>
      <text>* Distance between two vectors.
 * <p>This method computes the distance consistent with the
 * L<sub>2</sub> norm, i.e. the square root of the sum of
 * element differences, or Euclidean distance.</p></text>
      <param>v Vector to which distance is requested.</param>
      <return>the distance between two vectors.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
      <see>#getL1Distance(RealVector)</see>
      <see>#getLInfDistance(RealVector)</see>
      <see>#getNorm()</see>
    </javadoc>
    <method type="double" name="getDistance" startLine="395" endLine="405">
      <declaration type="double" name="d" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="399" endLine="403">
        <declaration type="Entry" name="e" />
        <declaration type="double" name="diff" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the L<sub>2</sub> norm of the vector.
 * <p>The L<sub>2</sub> norm is the root of the sum of
 * the squared elements.</p></text>
      <return>the norm.</return>
      <see>#getL1Norm()</see>
      <see>#getLInfNorm()</see>
      <see>#getDistance(RealVector)</see>
    </javadoc>
    <method type="double" name="getNorm" startLine="417" endLine="426">
      <declaration type="double" name="sum" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="420" endLine="424">
        <declaration type="Entry" name="e" />
        <declaration type="double" name="value" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the L<sub>1</sub> norm of the vector.
 * <p>The L<sub>1</sub> norm is the sum of the absolute
 * values of the elements.</p></text>
      <return>the norm.</return>
      <see>#getNorm()</see>
      <see>#getLInfNorm()</see>
      <see>#getL1Distance(RealVector)</see>
    </javadoc>
    <method type="double" name="getL1Norm" startLine="438" endLine="446">
      <declaration type="double" name="norm" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="441" endLine="444">
        <declaration type="Entry" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the L<sub>&infin;</sub> norm of the vector.
 * <p>The L<sub>&infin;</sub> norm is the max of the absolute
 * values of the elements.</p></text>
      <return>the norm.</return>
      <see>#getNorm()</see>
      <see>#getL1Norm()</see>
      <see>#getLInfDistance(RealVector)</see>
    </javadoc>
    <method type="double" name="getLInfNorm" startLine="458" endLine="466">
      <declaration type="double" name="norm" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="461" endLine="464">
        <declaration type="Entry" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Distance between two vectors.
 * <p>This method computes the distance consistent with
 * L<sub>1</sub> norm, i.e. the sum of the absolute values of
 * the elements differences.</p></text>
      <param>v Vector to which distance is requested.</param>
      <return>the distance between two vectors.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
    </javadoc>
    <method type="double" name="getL1Distance" startLine="480" endLine="489">
      <declaration type="double" name="d" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="484" endLine="487">
        <declaration type="Entry" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Distance between two vectors.
 * <p>This method computes the distance consistent with
 * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of
 * element differences.</p></text>
      <param>v Vector to which distance is requested.</param>
      <return>the distance between two vectors.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
      <see>#getDistance(RealVector)</see>
      <see>#getL1Distance(RealVector)</see>
      <see>#getLInfNorm()</see>
    </javadoc>
    <method type="double" name="getLInfDistance" startLine="506" endLine="515">
      <declaration type="double" name="d" />
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="510" endLine="513">
        <declaration type="Entry" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the index of the minimum entry.</text>
      <return>the index of the minimum entry or -1 if vector length is 0
 * or all entries are {@code NaN}.</return>
    </javadoc>
    <method type="int" name="getMinIndex" startLine="523" endLine="535">
      <declaration type="int" name="minIndex" />
      <declaration type="double" name="minValue" />
      <declaration type="Iterator<Entry>" name="iterator" />
      <scope startLine="527" endLine="533">
        <declaration type="Entry" name="entry" />
        <scope startLine="529" endLine="532" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the value of the minimum entry.</text>
      <return>the value of the minimum entry or {@code NaN} if all
 * entries are {@code NaN}.</return>
    </javadoc>
    <method type="double" name="getMinValue" startLine="543" endLine="546">
      <declaration type="int" name="minIndex" />
    </method>
    <javadoc>
      <text>* Get the index of the maximum entry.</text>
      <return>the index of the maximum entry or -1 if vector length is 0
 * or all entries are {@code NaN}</return>
    </javadoc>
    <method type="int" name="getMaxIndex" startLine="554" endLine="566">
      <declaration type="int" name="maxIndex" />
      <declaration type="double" name="maxValue" />
      <declaration type="Iterator<Entry>" name="iterator" />
      <scope startLine="558" endLine="564">
        <declaration type="Entry" name="entry" />
        <scope startLine="560" endLine="563" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the value of the maximum entry.</text>
      <return>the value of the maximum entry or {@code NaN} if all
 * entries are {@code NaN}.</return>
    </javadoc>
    <method type="double" name="getMaxValue" startLine="574" endLine="577">
      <declaration type="int" name="maxIndex" />
    </method>
    <javadoc>
      <text>* Multiply each entry by the argument. Returns a new vector.
 * Does not change instance data.</text>
      <param>d Multiplication factor.</param>
      <return>{@code this} * {@code d}.</return>
    </javadoc>
    <method type="RealVector" name="mapMultiply" startLine="587" endLine="589" />
    <javadoc>
      <text>* Multiply each entry.
 * The instance is changed in-place.</text>
      <param>d Multiplication factor.</param>
      <return>{@code this}.</return>
    </javadoc>
    <method type="RealVector" name="mapMultiplyToSelf" startLine="598" endLine="600" />
    <javadoc>
      <text>* Subtract a value from each entry. Returns a new vector.
 * Does not change instance data.</text>
      <param>d Value to be subtracted.</param>
      <return>{@code this} - {@code d}.</return>
    </javadoc>
    <method type="RealVector" name="mapSubtract" startLine="609" endLine="611" />
    <javadoc>
      <text>* Subtract a value from each entry.
 * The instance is changed in-place.</text>
      <param>d Value to be subtracted.</param>
      <return>{@code this}.</return>
    </javadoc>
    <method type="RealVector" name="mapSubtractToSelf" startLine="620" endLine="622" />
    <javadoc>
      <text>* Divide each entry by the argument. Returns a new vector.
 * Does not change instance data.</text>
      <param>d Value to divide by.</param>
      <return>{@code this} / {@code d}.</return>
    </javadoc>
    <method type="RealVector" name="mapDivide" startLine="631" endLine="633" />
    <javadoc>
      <text>* Divide each entry by the argument.
 * The instance is changed in-place.</text>
      <param>d Value to divide by.</param>
      <return>{@code this}.</return>
    </javadoc>
    <method type="RealVector" name="mapDivideToSelf" startLine="642" endLine="644" />
    <javadoc>
      <text>* Compute the outer product.</text>
      <param>v Vector with which outer product should be computed.</param>
      <return>the matrix outer product between this instance and {@code v}.</return>
    </javadoc>
    <method type="RealMatrix" name="outerProduct" startLine="652" endLine="667">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="RealMatrix" name="product" />
      <scope startLine="656" endLine="658" />
      <scope startLine="658" endLine="660" />
      <scope startLine="661" endLine="665">
        <scope startLine="662" endLine="664" />
      </scope>
    </method>
    <javadoc>
      <text>* Find the orthogonal projection of this vector onto another vector.</text>
      <param>v vector onto which instance must be projected.</param>
      <return>projection of the instance onto {@code v}.</return>
      <throws>DimensionMismatchException if {@code v} is not the same size as{@code this} vector.</throws>
      <throws>MathArithmeticException if {@code this} or {@code v} is the null
 * vector</throws>
    </javadoc>
    <method type="RealVector" name="projection" startLine="680" endLine="686">
      <declaration type="double" name="norm2" />
      <scope startLine="682" endLine="684" />
    </method>
    <javadoc>
      <text>* Set all elements to a single value.</text>
      <param>value Single value to set for all elements.</param>
    </javadoc>
    <method type="void" name="set" startLine="693" endLine="699">
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="695" endLine="698">
        <declaration type="Entry" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Convert the vector to an array of {@code double}s.
 * The array is independent from this vector data: the elements
 * are copied.</text>
      <return>an array containing a copy of the vector elements.</return>
    </javadoc>
    <method type="double[]" name="toArray" startLine="708" endLine="715">
      <declaration type="int" name="dim" />
      <declaration type="double[]" name="values" />
      <scope startLine="711" endLine="713" />
    </method>
    <javadoc>
      <text>* Creates a unit vector pointing in the direction of this vector.
 * The instance is not changed by this method.</text>
      <return>a unit vector pointing in direction of this vector.</return>
      <throws>MathArithmeticException if the norm is zero.</throws>
    </javadoc>
    <method type="RealVector" name="unitVector" startLine="724" endLine="730">
      <declaration type="double" name="norm" />
      <scope startLine="726" endLine="728" />
    </method>
    <javadoc>
      <text>* Converts this vector into a unit vector.
 * The instance itself is changed by this method.</text>
      <throws>MathArithmeticException if the norm is zero.</throws>
    </javadoc>
    <method type="void" name="unitize" startLine="738" endLine="744">
      <declaration type="double" name="norm" />
      <scope startLine="740" endLine="742" />
    </method>
    <javadoc>
      <text>* Create a sparse iterator over the vector, which may omit some entries.
 * Specialized implementations may choose to not iterate over all
 * dimensions, either because those values are unset, or are equal
 * to defaultValue(), or are small enough to be ignored for the
 * purposes of iteration. No guarantees are made about order of iteration.
 * In dense implementations, this method will often delegate to{@link #iterator()}.
 * <p>Note: derived classes are required to return an {@link Iterator} that
 * returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}returns {@code true}.</p></text>
      <return>a sparse iterator.</return>
      <deprecated>As of 3.1, this method is deprecated, because its interface
 * is too confusing (see
 * <a href="https://issues.apache.org/jira/browse/MATH-875">JIRA MATH-875</a>).
 * This method will be completely removed in 4.0.</deprecated>
    </javadoc>
    <method type="Iterator<Entry>" name="sparseIterator" startLine="766" endLine="768" />
    <javadoc>
      <text>* Generic dense iterator. Iteration is in increasing order
 * of the vector index.
 * <p>Note: derived classes are required to return an {@link Iterator} that
 * returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}returns {@code true}.</p></text>
      <return>a dense iterator.</return>
    </javadoc>
    <method type="Iterator<Entry>" name="iterator" startLine="780" endLine="814">
      <declaration type="int" name="dim" />
      <javadoc>
        <text>* Current index.</text>
      </javadoc>
      <declaration type="int" name="i" />
      <javadoc>
        <text>* Current entry.</text>
      </javadoc>
      <declaration type="Entry" name="e" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="boolean" name="hasNext" startLine="791" endLine="793" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Entry" name="next" startLine="796" endLine="803">
        <scope startLine="797" endLine="800" />
        <scope startLine="800" endLine="802" />
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
        <throws>MathUnsupportedOperationException in all circumstances.</throws>
      </javadoc>
      <method type="void" name="remove" startLine="810" endLine="812" />
    </method>
    <javadoc>
      <text>* Acts as if implemented as:
 * <pre>
 * return copy().mapToSelf(function);
 * </pre>
 * Returns a new vector. Does not change instance data.</text>
      <param>function Function to apply to each entry.</param>
      <return>a new vector.</return>
    </javadoc>
    <method type="RealVector" name="map" startLine="826" endLine="828" />
    <javadoc>
      <text>* Acts as if it is implemented as:
 * <pre>
 * Entry e = null;
 * for(Iterator<Entry> it = iterator(); it.hasNext(); e = it.next()) {
 * e.setValue(function.value(e.getValue()));
 * }
 * </pre>
 * Entries of this vector are modified in-place by this method.</text>
      <param>function Function to apply to each entry.</param>
      <return>a reference to this vector.</return>
    </javadoc>
    <method type="RealVector" name="mapToSelf" startLine="843" endLine="850">
      <declaration type="Iterator<Entry>" name="it" />
      <scope startLine="845" endLine="848">
        <declaration type="Entry" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a new vector representing {@code a * this + b * y}, the linear
 * combination of {@code this} and {@code y}.
 * Returns a new vector. Does not change instance data.</text>
      <param>a Coefficient of {@code this}.</param>
      <param>b Coefficient of {@code y}.</param>
      <param>y Vector with which {@code this} is linearly combined.</param>
      <return>a vector containing {@code a * this[i] + b * y[i]} for all{@code i}.</return>
      <throws>DimensionMismatchException if {@code y} is not the same size as{@code this} vector.</throws>
    </javadoc>
    <method type="RealVector" name="combine" startLine="866" endLine="868" />
    <javadoc>
      <text>* Updates {@code this} with the linear combination of {@code this} and{@code y}.</text>
      <param>a Weight of {@code this}.</param>
      <param>b Weight of {@code y}.</param>
      <param>y Vector with which {@code this} is linearly combined.</param>
      <return>{@code this}, with components equal to{@code a * this[i] + b * y[i]} for all {@code i}.</return>
      <throws>DimensionMismatchException if {@code y} is not the same size as{@code this} vector.</throws>
    </javadoc>
    <method type="RealVector" name="combineToSelf" startLine="883" endLine="891">
      <scope startLine="885" endLine="889">
        <declaration type="double" name="xi" />
        <declaration type="double" name="yi" />
      </scope>
    </method>
    <javadoc>
      <text>* Visits (but does not alter) all entries of this vector in default order
 * (increasing index).</text>
      <param>visitor the visitor to be used to process the entries of this
 * vector</param>
      <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInDefaultOrder" startLine="903" endLine="910">
      <declaration type="int" name="dim" />
      <scope startLine="906" endLine="908" />
    </method>
    <javadoc>
      <text>* Visits (but does not alter) some entries of this vector in default order
 * (increasing index).</text>
      <param>visitor visitor to be used to process the entries of this vector</param>
      <param>start the index of the first entry to be visited</param>
      <param>end the index of the last entry to be visited (inclusive)</param>
      <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
      <throws>NumberIsTooSmallException if {@code end < start}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInDefaultOrder" startLine="927" endLine="934">
      <scope startLine="930" endLine="932" />
    </method>
    <javadoc>
      <text>* Visits (but does not alter) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
      <param>visitor the visitor to be used to process the entries of this
 * vector</param>
      <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInOptimizedOrder" startLine="948" endLine="950" />
    <javadoc>
      <text>* Visits (but does not alter) some entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
      <param>visitor visitor to be used to process the entries of this vector</param>
      <param>start the index of the first entry to be visited</param>
      <param>end the index of the last entry to be visited (inclusive)</param>
      <return>the value returned by {@link RealVectorPreservingVisitor#end()}at the end of the walk</return>
      <throws>NumberIsTooSmallException if {@code end < start}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInOptimizedOrder" startLine="969" endLine="971" />
    <javadoc>
      <text>* Visits (and possibly alters) all entries of this vector in default order
 * (increasing index).</text>
      <param>visitor the visitor to be used to process and modify the entries
 * of this vector</param>
      <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInDefaultOrder" startLine="983" endLine="990">
      <declaration type="int" name="dim" />
      <scope startLine="986" endLine="988" />
    </method>
    <javadoc>
      <text>* Visits (and possibly alters) some entries of this vector in default order
 * (increasing index).</text>
      <param>visitor visitor to be used to process the entries of this vector</param>
      <param>start the index of the first entry to be visited</param>
      <param>end the index of the last entry to be visited (inclusive)</param>
      <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
      <throws>NumberIsTooSmallException if {@code end < start}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInDefaultOrder" startLine="1007" endLine="1014">
      <scope startLine="1010" endLine="1012" />
    </method>
    <javadoc>
      <text>* Visits (and possibly alters) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
      <param>visitor the visitor to be used to process the entries of this
 * vector</param>
      <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInOptimizedOrder" startLine="1028" endLine="1030" />
    <javadoc>
      <text>* Visits (and possibly change) some entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.</text>
      <param>visitor visitor to be used to process the entries of this vector</param>
      <param>start the index of the first entry to be visited</param>
      <param>end the index of the last entry to be visited (inclusive)</param>
      <return>the value returned by {@link RealVectorChangingVisitor#end()}at the end of the walk</return>
      <throws>NumberIsTooSmallException if {@code end < start}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="walkInOptimizedOrder" startLine="1049" endLine="1051" />
    <class name="Entry" startLine="1053">
      <javadoc>
        <text>* An entry in the vector.</text>
      </javadoc>
      <javadoc>
        <text>* Index of this entry.</text>
      </javadoc>
      <declaration type="int" name="index" />
      <javadoc>
        <text>* Simple constructor.</text>
      </javadoc>
      <method type="constructor" name="Entry" startLine="1059" endLine="1061" />
      <javadoc>
        <text>* Get the value of the entry.</text>
        <return>the value of the entry.</return>
      </javadoc>
      <method type="double" name="getValue" startLine="1068" endLine="1070" />
      <javadoc>
        <text>* Set the value of the entry.</text>
        <param>value New value for the entry.</param>
      </javadoc>
      <method type="void" name="setValue" startLine="1077" endLine="1079" />
      <javadoc>
        <text>* Get the index of the entry.</text>
        <return>the index of the entry.</return>
      </javadoc>
      <method type="int" name="getIndex" startLine="1086" endLine="1088" />
      <javadoc>
        <text>* Set the index of the entry.</text>
        <param>index New index for the entry.</param>
      </javadoc>
      <method type="void" name="setIndex" startLine="1095" endLine="1097" />
      <javadoc>
        <text>* <p>
 * Test for the equality of two real vectors. If all coordinates of two real
 * vectors are exactly the same, and none are {@code NaN}, the two real
 * vectors are considered to be equal. {@code NaN} coordinates are
 * considered to affect globally the vector and be equals to each other -
 * i.e, if either (or all) coordinates of the real vector are equal to{@code NaN}, the real vector is equal to a vector with all {@code NaN}coordinates.
 * </p>
 * <p>
 * This method <em>must</em> be overriden by concrete subclasses of{@link RealVector} (the current implementation throws an exception).
 * </p></text>
        <param>other Object to test for equality.</param>
        <return>{@code true} if two vector objects are equal, {@code false} if{@code other} is null, not an instance of {@code RealVector}, or
 * not equal to this {@code RealVector} instance.</return>
        <throws>MathUnsupportedOperationException if this method is not
 * overridden.</throws>
      </javadoc>
      <method type="boolean" name="equals" startLine="1124" endLine="1126" />
      <javadoc>
        <text>* {@inheritDoc}. This method <em>must</em> be overriden by concrete
 * subclasses of {@link RealVector} (current implementation throws an
 * exception).</text>
        <throws>MathUnsupportedOperationException if this method is not
 * overridden.</throws>
      </javadoc>
      <method type="int" name="hashCode" startLine="1137" endLine="1139" />
      <class name="SparseEntryIterator" startLine="1141">
        <implements name="Iterator<Entry>" />
        <javadoc>
          <text>* This class should rarely be used, but is here to provide
 * a default implementation of sparseIterator(), which is implemented
 * by walking over the entries, skipping those whose values are the default one.
 * Concrete subclasses which are SparseVector implementations should
 * make their own sparse iterator, rather than using this one.
 * This implementation might be useful for ArrayRealVector, when expensive
 * operations which preserve the default value are to be done on the entries,
 * and the fraction of non-default values is small (i.e. someone took a
 * SparseVector, and passed it into the copy-constructor of ArrayRealVector)</text>
          <deprecated>As of 3.1, this class is deprecated, see
 * <a href="https://issues.apache.org/jira/browse/MATH-875">JIRA MATH-875</a>.
 * This class will be completely removed in 4.0.</deprecated>
        </javadoc>
        <javadoc>
          <text>* Dimension of the vector.</text>
        </javadoc>
        <declaration type="int" name="dim" />
        <javadoc>
          <text>* Last entry returned by {@link #next()}.</text>
        </javadoc>
        <declaration type="Entry" name="current" />
        <javadoc>
          <text>* Next entry for {@link #next()} to return.</text>
        </javadoc>
        <declaration type="Entry" name="next" />
        <javadoc>
          <text>* Simple constructor.</text>
        </javadoc>
        <method type="constructor" name="SparseEntryIterator" startLine="1169" endLine="1176">
          <scope startLine="1173" endLine="1175" />
        </method>
        <javadoc>
          <text>* Advance an entry up to the next nonzero one.</text>
          <param>e entry to advance.</param>
        </javadoc>
        <method type="void" name="advance" startLine="1183" endLine="1193">
          <scope startLine="1184" endLine="1186" />
          <scope startLine="1187" endLine="1189" />
          <scope startLine="1190" endLine="1192" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="boolean" name="hasNext" startLine="1196" endLine="1198" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="Entry" name="next" startLine="1201" endLine="1209">
          <declaration type="int" name="index" />
          <scope startLine="1203" endLine="1205" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
          <throws>MathUnsupportedOperationException in all circumstances.</throws>
        </javadoc>
        <method type="void" name="remove" startLine="1216" endLine="1218" />
        <javadoc>
          <text>* Returns an unmodifiable view of the specified vector.
 * The returned vector has read-only access. An attempt to modify it will
 * result in a {@link MathUnsupportedOperationException}. However, the
 * returned vector is <em>not</em> immutable, since any modification of{@code v} will also change the returned view.
 * For example, in the following piece of code
 * <pre>
 * RealVector v = new ArrayRealVector(2);
 * RealVector w = RealVector.unmodifiableRealVector(v);
 * v.setEntry(0, 1.2);
 * v.setEntry(1, -3.4);
 * </pre>
 * the changes will be seen in the {@code w} view of {@code v}.</text>
          <param>v Vector for which an unmodifiable view is to be returned.</param>
          <return>an unmodifiable view of {@code v}.</return>
        </javadoc>
        <method type="RealVector" name="unmodifiableRealVector" startLine="1239" endLine="1650">
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all circumstances.</throws>
          </javadoc>
          <method type="RealVector" name="mapToSelf" startLine="1257" endLine="1259" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="map" startLine="1263" endLine="1265" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="Iterator<Entry>" name="iterator" startLine="1269" endLine="1296">
            <declaration type="Iterator<Entry>" name="i" />
            <javadoc>
              <text>* The current entry.</text>
            </javadoc>
            <declaration type="UnmodifiableEntry" name="e" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="boolean" name="hasNext" startLine="1276" endLine="1278" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="Entry" name="next" startLine="1281" endLine="1284" />
            <javadoc>
              <text>* {@inheritDoc}</text>
              <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
            </javadoc>
            <method type="void" name="remove" startLine="1292" endLine="1294" />
          </method>
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="Iterator<Entry>" name="sparseIterator" startLine="1300" endLine="1329">
            <declaration type="Iterator<Entry>" name="i" />
            <javadoc>
              <text>* The current entry.</text>
            </javadoc>
            <declaration type="UnmodifiableEntry" name="e" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="boolean" name="hasNext" startLine="1308" endLine="1310" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="Entry" name="next" startLine="1313" endLine="1316" />
            <javadoc>
              <text>* {@inheritDoc}</text>
              <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
            </javadoc>
            <method type="void" name="remove" startLine="1325" endLine="1327" />
          </method>
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="copy" startLine="1333" endLine="1335" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="add" startLine="1340" endLine="1342" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="subtract" startLine="1347" endLine="1349" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="mapAdd" startLine="1353" endLine="1355" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="RealVector" name="mapAddToSelf" startLine="1365" endLine="1367" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="mapSubtract" startLine="1371" endLine="1373" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="RealVector" name="mapSubtractToSelf" startLine="1383" endLine="1385" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="mapMultiply" startLine="1389" endLine="1391" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="RealVector" name="mapMultiplyToSelf" startLine="1401" endLine="1403" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="mapDivide" startLine="1407" endLine="1409" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="RealVector" name="mapDivideToSelf" startLine="1419" endLine="1421" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="ebeMultiply" startLine="1426" endLine="1428" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="ebeDivide" startLine="1433" endLine="1435" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="dotProduct" startLine="1440" endLine="1442" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="cosine" startLine="1447" endLine="1449" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getNorm" startLine="1453" endLine="1455" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getL1Norm" startLine="1459" endLine="1461" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getLInfNorm" startLine="1465" endLine="1467" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getDistance" startLine="1472" endLine="1474" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getL1Distance" startLine="1479" endLine="1481" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getLInfDistance" startLine="1486" endLine="1488" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="unitVector" startLine="1492" endLine="1494" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="void" name="unitize" startLine="1503" endLine="1505" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealMatrix" name="outerProduct" startLine="1509" endLine="1511" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="getEntry" startLine="1515" endLine="1517" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="void" name="setEntry" startLine="1527" endLine="1529" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="void" name="addToEntry" startLine="1539" endLine="1541" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="int" name="getDimension" startLine="1545" endLine="1547" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="append" startLine="1551" endLine="1553" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="append" startLine="1557" endLine="1559" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="getSubVector" startLine="1564" endLine="1566" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="void" name="setSubVector" startLine="1576" endLine="1578" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="void" name="set" startLine="1588" endLine="1590" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double[]" name="toArray" startLine="1594" endLine="1596" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="boolean" name="isNaN" startLine="1600" endLine="1602" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="boolean" name="isInfinite" startLine="1606" endLine="1608" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="RealVector" name="combine" startLine="1613" endLine="1615" />
          <javadoc>
            <text>* {@inheritDoc}</text>
            <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
          </javadoc>
          <method type="RealVector" name="combineToSelf" startLine="1625" endLine="1627" />
          <class name="UnmodifiableEntry" extends="Entry" startLine="1629">
            <javadoc>
              <text>* An entry in the vector.</text>
            </javadoc>
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="double" name="getValue" startLine="1633" endLine="1635" />
            <javadoc>
              <text>* {@inheritDoc}</text>
              <throws>MathUnsupportedOperationException in all
 * circumstances.</throws>
            </javadoc>
            <method type="void" name="setValue" startLine="1645" endLine="1647" />
          </class>
          <javadoc>
            <text>* This anonymous class is an implementation of {@link RealVector}with read-only access.
 * It wraps any {@link RealVector}, and exposes all methods which
 * do not modify it. Invoking methods which should normally result
 * in the modification of the calling {@link RealVector} results in
 * a {@link MathUnsupportedOperationException}. It should be noted
 * that {@link UnmodifiableVector} is <em>not</em> immutable.</text>
          </javadoc>
        </method>
      </class>
    </class>
  </class>
</source>
