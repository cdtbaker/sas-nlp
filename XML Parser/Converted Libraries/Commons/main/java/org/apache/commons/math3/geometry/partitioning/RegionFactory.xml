<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.partitioning">
  <import name="org.apache.commons.math3.geometry.Space" />
  <class name="RegionFactory" startLine="21">
    <javadoc>
      <text>* This class is a factory for {@link Region}.</text>
      <param><S>
 *  Type of the space.</param>
      <version>$Id: RegionFactory.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Visitor removing internal nodes attributes.</text>
    </javadoc>
    <declaration type="NodesCleaner" name="nodeCleaner" />
    <javadoc>
      <text>* Simple constructor.</text>
    </javadoc>
    <method type="constructor" name="RegionFactory" startLine="35" endLine="37" />
    <javadoc>
      <text>* Build a convex region from a collection of bounding hyperplanes.</text>
      <param>hyperplanes collection of bounding hyperplanes</param>
      <return>a new convex region, or null if the collection is empty</return>
    </javadoc>
    <method type="Region<S>" name="buildConvex" startLine="43" endLine="65">
      <scope startLine="44" endLine="46" />
      <declaration type="Region<S>" name="region" />
      <declaration type="BSPTree<S>" name="node" />
      <scope startLine="54" endLine="61">
        <scope startLine="55" endLine="60" />
      </scope>
      <comment>use the first hyperplane to build the right class</comment>
      <comment>chop off parts of the space</comment>
    </method>
    <javadoc>
      <text>* Compute the union of two regions.</text>
      <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <return>a new region, result of {@code region1 union region2}</return>
    </javadoc>
    <method type="Region<S>" name="union" startLine="74" endLine="79">
      <declaration type="BSPTree<S>" name="tree" />
    </method>
    <javadoc>
      <text>* Compute the intersection of two regions.</text>
      <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <return>a new region, result of {@code region1 intersection region2}</return>
    </javadoc>
    <method type="Region<S>" name="intersection" startLine="88" endLine="93">
      <declaration type="BSPTree<S>" name="tree" />
    </method>
    <javadoc>
      <text>* Compute the symmetric difference (exclusive or) of two regions.</text>
      <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <return>a new region, result of {@code region1 xor region2}</return>
    </javadoc>
    <method type="Region<S>" name="xor" startLine="102" endLine="107">
      <declaration type="BSPTree<S>" name="tree" />
    </method>
    <javadoc>
      <text>* Compute the difference of two regions.</text>
      <param>region1 first region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <param>region2 second region (will be unusable after the operation as
 * parts of it will be reused in the new region)</param>
      <return>a new region, result of {@code region1 minus region2}</return>
    </javadoc>
    <method type="Region<S>" name="difference" startLine="116" endLine="121">
      <declaration type="BSPTree<S>" name="tree" />
    </method>
    <javadoc>
      <text>* Get the complement of the region (exchanged interior/exterior).</text>
      <param>region region to complement, it will not modified, a new
 * region independent region will be built</param>
      <return>a new region, complement of the specified one</return>
    </javadoc>
    <method type="Region<S>" name="getComplement" startLine="128" endLine="130" />
    <javadoc>
      <text>* Recursively build the complement of a BSP tree.</text>
      <param>node current node of the original tree</param>
      <return>new tree, complement of the node</return>
    </javadoc>
    <method type="BSPTree<S>" name="recurseComplement" startLine="136" endLine="156">
      <scope startLine="137" endLine="139" />
      <declaration type="BoundaryAttribute<S>" name="attribute" />
      <scope startLine="143" endLine="149">
        <declaration type="SubHyperplane<S>" name="plusOutside" />
        <declaration type="SubHyperplane<S>" name="plusInside" />
      </scope>
    </method>
    <class name="UnionMerger" startLine="158">
      <implements name="BSPTree.LeafMerger<S>" />
      <javadoc>
        <text>* BSP tree leaf merger computing union of two regions.</text>
      </javadoc>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="BSPTree<S>" name="merge" startLine="163" endLine="172">
        <scope startLine="164" endLine="168">
          <comment>the leaf node represents an inside cell</comment>
        </scope>
        <comment>the leaf node represents an outside cell</comment>
      </method>
      <class name="IntersectionMerger" startLine="175">
        <implements name="BSPTree.LeafMerger<S>" />
        <javadoc>
          <text>* BSP tree leaf merger computing union of two regions.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="BSPTree<S>" name="merge" startLine="180" endLine="189">
          <scope startLine="181" endLine="185">
            <comment>the leaf node represents an inside cell</comment>
          </scope>
          <comment>the leaf node represents an outside cell</comment>
        </method>
        <class name="XorMerger" startLine="192">
          <implements name="BSPTree.LeafMerger<S>" />
          <javadoc>
            <text>* BSP tree leaf merger computing union of two regions.</text>
          </javadoc>
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="BSPTree<S>" name="merge" startLine="197" endLine="205">
            <declaration type="BSPTree<S>" name="t" />
            <scope startLine="199" endLine="202">
              <comment>the leaf node represents an inside cell</comment>
            </scope>
          </method>
          <class name="DifferenceMerger" startLine="208">
            <implements name="BSPTree.LeafMerger<S>" />
            <javadoc>
              <text>* BSP tree leaf merger computing union of two regions.</text>
            </javadoc>
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="BSPTree<S>" name="merge" startLine="213" endLine="226">
              <scope startLine="214" endLine="220">
                <declaration type="BSPTree<S>" name="argTree" />
                <comment>the leaf node represents an inside cell</comment>
              </scope>
              <declaration type="BSPTree<S>" name="instanceTree" />
              <comment>the leaf node represents an outside cell</comment>
            </method>
            <class name="NodesCleaner" startLine="229">
              <implements name="BSPTreeVisitor<S>" />
              <javadoc>
                <text>* Visitor removing internal nodes attributes.</text>
              </javadoc>
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="Order" name="visitOrder" startLine="233" endLine="235" />
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="void" name="visitInternalNode" startLine="238" endLine="240" />
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="void" name="visitLeafNode" startLine="243" endLine="244" />
            </class>
          </class>
        </class>
      </class>
    </class>
  </class>
</source>
