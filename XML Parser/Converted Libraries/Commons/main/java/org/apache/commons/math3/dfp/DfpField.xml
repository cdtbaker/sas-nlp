<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.dfp">
  <import name="org.apache.commons.math3.Field" />
  <import name="org.apache.commons.math3.FieldElement" />
  <class name="DfpField" startLine="23">
    <implements name="Field<Dfp>" />
    <javadoc>
      <text>* Field for Decimal floating point instances.</text>
      <version>$Id: DfpField.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>2.2</since>
    </javadoc>
    <javadoc>
      <text>* Enumerate for rounding modes.</text>
    </javadoc>
    <javadoc>
      <text>* Rounds toward zero (truncation).</text>
    </javadoc>
    <javadoc>
      <text>* Rounds away from zero if discarded digit is non-zero.</text>
    </javadoc>
    <javadoc>
      <text>* Rounds towards nearest unless both are equidistant in which case it rounds away from zero.</text>
    </javadoc>
    <javadoc>
      <text>* Rounds towards nearest unless both are equidistant in which case it rounds toward zero.</text>
    </javadoc>
    <javadoc>
      <text>* Rounds towards nearest unless both are equidistant in which case it rounds toward the even neighbor.
 * This is the default as  specified by IEEE 854-1987</text>
    </javadoc>
    <javadoc>
      <text>* Rounds towards nearest unless both are equidistant in which case it rounds toward the odd neighbor.</text>
    </javadoc>
    <javadoc>
      <text>* Rounds towards positive infinity.</text>
    </javadoc>
    <javadoc>
      <text>* Rounds towards negative infinity.</text>
    </javadoc>
    <javadoc>
      <text>* IEEE 854-1987 flag for invalid operation.</text>
    </javadoc>
    <declaration type="int" name="FLAG_INVALID" />
    <javadoc>
      <text>* IEEE 854-1987 flag for division by zero.</text>
    </javadoc>
    <declaration type="int" name="FLAG_DIV_ZERO" />
    <javadoc>
      <text>* IEEE 854-1987 flag for overflow.</text>
    </javadoc>
    <declaration type="int" name="FLAG_OVERFLOW" />
    <javadoc>
      <text>* IEEE 854-1987 flag for underflow.</text>
    </javadoc>
    <declaration type="int" name="FLAG_UNDERFLOW" />
    <javadoc>
      <text>* IEEE 854-1987 flag for inexact result.</text>
    </javadoc>
    <declaration type="int" name="FLAG_INEXACT" />
    <javadoc>
      <text>* High precision string representation of &radic;2.</text>
    </javadoc>
    <declaration type="String" name="sqr2String" />
    <javadoc>
      <text>* High precision string representation of &radic;2 / 2.</text>
    </javadoc>
    <declaration type="String" name="sqr2ReciprocalString" />
    <javadoc>
      <text>* High precision string representation of &radic;3.</text>
    </javadoc>
    <declaration type="String" name="sqr3String" />
    <javadoc>
      <text>* High precision string representation of &radic;3 / 3.</text>
    </javadoc>
    <declaration type="String" name="sqr3ReciprocalString" />
    <javadoc>
      <text>* High precision string representation of &pi;.</text>
    </javadoc>
    <declaration type="String" name="piString" />
    <javadoc>
      <text>* High precision string representation of e.</text>
    </javadoc>
    <declaration type="String" name="eString" />
    <javadoc>
      <text>* High precision string representation of ln(2).</text>
    </javadoc>
    <declaration type="String" name="ln2String" />
    <javadoc>
      <text>* High precision string representation of ln(5).</text>
    </javadoc>
    <declaration type="String" name="ln5String" />
    <javadoc>
      <text>* High precision string representation of ln(10).</text>
    </javadoc>
    <declaration type="String" name="ln10String" />
    <javadoc>
      <text>* The number of radix digits.
 * Note these depend on the radix which is 10000 digits,
 * so each one is equivalent to 4 decimal digits.</text>
    </javadoc>
    <declaration type="int" name="radixDigits" />
    <javadoc>
      <text>* A {@link Dfp} with value 0.</text>
    </javadoc>
    <declaration type="Dfp" name="zero" />
    <javadoc>
      <text>* A {@link Dfp} with value 1.</text>
    </javadoc>
    <declaration type="Dfp" name="one" />
    <javadoc>
      <text>* A {@link Dfp} with value 2.</text>
    </javadoc>
    <declaration type="Dfp" name="two" />
    <javadoc>
      <text>* A {@link Dfp} with value &radic;2.</text>
    </javadoc>
    <declaration type="Dfp" name="sqr2" />
    <javadoc>
      <text>* A two elements {@link Dfp} array with value &radic;2 split in two pieces.</text>
    </javadoc>
    <declaration type="Dfp[]" name="sqr2Split" />
    <javadoc>
      <text>* A {@link Dfp} with value &radic;2 / 2.</text>
    </javadoc>
    <declaration type="Dfp" name="sqr2Reciprocal" />
    <javadoc>
      <text>* A {@link Dfp} with value &radic;3.</text>
    </javadoc>
    <declaration type="Dfp" name="sqr3" />
    <javadoc>
      <text>* A {@link Dfp} with value &radic;3 / 3.</text>
    </javadoc>
    <declaration type="Dfp" name="sqr3Reciprocal" />
    <javadoc>
      <text>* A {@link Dfp} with value &pi;.</text>
    </javadoc>
    <declaration type="Dfp" name="pi" />
    <javadoc>
      <text>* A two elements {@link Dfp} array with value &pi; split in two pieces.</text>
    </javadoc>
    <declaration type="Dfp[]" name="piSplit" />
    <javadoc>
      <text>* A {@link Dfp} with value e.</text>
    </javadoc>
    <declaration type="Dfp" name="e" />
    <javadoc>
      <text>* A two elements {@link Dfp} array with value e split in two pieces.</text>
    </javadoc>
    <declaration type="Dfp[]" name="eSplit" />
    <javadoc>
      <text>* A {@link Dfp} with value ln(2).</text>
    </javadoc>
    <declaration type="Dfp" name="ln2" />
    <javadoc>
      <text>* A two elements {@link Dfp} array with value ln(2) split in two pieces.</text>
    </javadoc>
    <declaration type="Dfp[]" name="ln2Split" />
    <javadoc>
      <text>* A {@link Dfp} with value ln(5).</text>
    </javadoc>
    <declaration type="Dfp" name="ln5" />
    <javadoc>
      <text>* A two elements {@link Dfp} array with value ln(5) split in two pieces.</text>
    </javadoc>
    <declaration type="Dfp[]" name="ln5Split" />
    <javadoc>
      <text>* A {@link Dfp} with value ln(10).</text>
    </javadoc>
    <declaration type="Dfp" name="ln10" />
    <javadoc>
      <text>* Current rounding mode.</text>
    </javadoc>
    <declaration type="RoundingMode" name="rMode" />
    <javadoc>
      <text>* IEEE 854-1987 signals.</text>
    </javadoc>
    <declaration type="int" name="ieeeFlags" />
    <javadoc>
      <text>* Create a factory for the specified number of radix digits.
 * <p>
 * Note that since the {@link Dfp} class uses 10000 as its radix, each radix
 * digit is equivalent to 4 decimal digits. This implies that asking for
 * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
 * all cases.
 * </p></text>
      <param>decimalDigits minimal number of decimal digits.</param>
    </javadoc>
    <method type="constructor" name="DfpField" startLine="176" endLine="178" />
    <javadoc>
      <text>* Create a factory for the specified number of radix digits.
 * <p>
 * Note that since the {@link Dfp} class uses 10000 as its radix, each radix
 * digit is equivalent to 4 decimal digits. This implies that asking for
 * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
 * all cases.
 * </p></text>
      <param>decimalDigits minimal number of decimal digits</param>
      <param>computeConstants if true, the transcendental constants for the given precision
 * must be computed (setting this flag to false is RESERVED for the internal recursive call)</param>
    </javadoc>
    <method type="constructor" name="DfpField" startLine="191" endLine="245">
      <scope startLine="200" endLine="227">
        <scope startLine="202" endLine="226" />
        <comment>set up transcendental constants</comment>
        <comment>as a heuristic to circumvent Table-Maker's Dilemma, we set the string</comment>
        <comment>representation of the constants to be at least 3 times larger than the</comment>
        <comment>number of decimal digits, also as an attempt to really compute these</comment>
        <comment>constants only once, we set a minimum number of digits</comment>
        <comment>set up the constants at current field accuracy</comment>
      </scope>
      <scope startLine="227" endLine="243">
        <comment>dummy settings for unused constants</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Get the number of radix digits of the {@link Dfp} instances built by this factory.</text>
      <return>number of radix digits</return>
    </javadoc>
    <method type="int" name="getRadixDigits" startLine="250" endLine="252" />
    <javadoc>
      <text>* Set the rounding mode.
 * If not set, the default value is {@link RoundingMode#ROUND_HALF_EVEN}.</text>
      <param>mode desired rounding mode
 * Note that the rounding mode is common to all {@link Dfp} instances
 * belonging to the current {@link DfpField} in the system and will
 * affect all future calculations.</param>
    </javadoc>
    <method type="void" name="setRoundingMode" startLine="261" endLine="263" />
    <javadoc>
      <text>* Get the current rounding mode.</text>
      <return>current rounding mode</return>
    </javadoc>
    <method type="RoundingMode" name="getRoundingMode" startLine="268" endLine="270" />
    <javadoc>
      <text>* Get the IEEE 854 status flags.</text>
      <return>IEEE 854 status flags</return>
      <see>#clearIEEEFlags()</see>
      <see>#setIEEEFlags(int)</see>
      <see>#setIEEEFlagsBits(int)</see>
      <see>#FLAG_INVALID</see>
      <see>#FLAG_DIV_ZERO</see>
      <see>#FLAG_OVERFLOW</see>
      <see>#FLAG_UNDERFLOW</see>
      <see>#FLAG_INEXACT</see>
    </javadoc>
    <method type="int" name="getIEEEFlags" startLine="283" endLine="285" />
    <javadoc>
      <text>* Clears the IEEE 854 status flags.</text>
      <see>#getIEEEFlags()</see>
      <see>#setIEEEFlags(int)</see>
      <see>#setIEEEFlagsBits(int)</see>
      <see>#FLAG_INVALID</see>
      <see>#FLAG_DIV_ZERO</see>
      <see>#FLAG_OVERFLOW</see>
      <see>#FLAG_UNDERFLOW</see>
      <see>#FLAG_INEXACT</see>
    </javadoc>
    <method type="void" name="clearIEEEFlags" startLine="297" endLine="299" />
    <javadoc>
      <text>* Sets the IEEE 854 status flags.</text>
      <param>flags desired value for the flags</param>
      <see>#getIEEEFlags()</see>
      <see>#clearIEEEFlags()</see>
      <see>#setIEEEFlagsBits(int)</see>
      <see>#FLAG_INVALID</see>
      <see>#FLAG_DIV_ZERO</see>
      <see>#FLAG_OVERFLOW</see>
      <see>#FLAG_UNDERFLOW</see>
      <see>#FLAG_INEXACT</see>
    </javadoc>
    <method type="void" name="setIEEEFlags" startLine="312" endLine="314" />
    <javadoc>
      <text>* Sets some bits in the IEEE 854 status flags, without changing the already set bits.
 * <p>
 * Calling this method is equivalent to call {@code setIEEEFlags(getIEEEFlags() | bits)}</p></text>
      <param>bits bits to set</param>
      <see>#getIEEEFlags()</see>
      <see>#clearIEEEFlags()</see>
      <see>#setIEEEFlags(int)</see>
      <see>#FLAG_INVALID</see>
      <see>#FLAG_DIV_ZERO</see>
      <see>#FLAG_OVERFLOW</see>
      <see>#FLAG_UNDERFLOW</see>
      <see>#FLAG_INEXACT</see>
    </javadoc>
    <method type="void" name="setIEEEFlagsBits" startLine="330" endLine="332" />
    <javadoc>
      <text>* Makes a {@link Dfp} with a value of 0.</text>
      <return>a new {@link Dfp} with a value of 0</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="337" endLine="339" />
    <javadoc>
      <text>* Create an instance from a byte value.</text>
      <param>x value to convert to an instance</param>
      <return>a new {@link Dfp} with the same value as x</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="345" endLine="347" />
    <javadoc>
      <text>* Create an instance from an int value.</text>
      <param>x value to convert to an instance</param>
      <return>a new {@link Dfp} with the same value as x</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="353" endLine="355" />
    <javadoc>
      <text>* Create an instance from a long value.</text>
      <param>x value to convert to an instance</param>
      <return>a new {@link Dfp} with the same value as x</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="361" endLine="363" />
    <javadoc>
      <text>* Create an instance from a double value.</text>
      <param>x value to convert to an instance</param>
      <return>a new {@link Dfp} with the same value as x</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="369" endLine="371" />
    <javadoc>
      <text>* Copy constructor.</text>
      <param>d instance to copy</param>
      <return>a new {@link Dfp} with the same value as d</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="377" endLine="379" />
    <javadoc>
      <text>* Create a {@link Dfp} given a String representation.</text>
      <param>s string representation of the instance</param>
      <return>a new {@link Dfp} parsed from specified string</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="385" endLine="387" />
    <javadoc>
      <text>* Creates a {@link Dfp} with a non-finite value.</text>
      <param>sign sign of the Dfp to create</param>
      <param>nans code of the value, must be one of {@link Dfp#INFINITE},{@link Dfp#SNAN},  {@link Dfp#QNAN}</param>
      <return>a new {@link Dfp} with a non-finite value</return>
    </javadoc>
    <method type="Dfp" name="newDfp" startLine="395" endLine="397" />
    <javadoc>
      <text>* Get the constant 0.</text>
      <return>a {@link Dfp} with value 0</return>
    </javadoc>
    <method type="Dfp" name="getZero" startLine="402" endLine="404" />
    <javadoc>
      <text>* Get the constant 1.</text>
      <return>a {@link Dfp} with value 1</return>
    </javadoc>
    <method type="Dfp" name="getOne" startLine="409" endLine="411" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Class<? extends FieldElement<Dfp>>" name="getRuntimeClass" startLine="414" endLine="416" />
    <javadoc>
      <text>* Get the constant 2.</text>
      <return>a {@link Dfp} with value 2</return>
    </javadoc>
    <method type="Dfp" name="getTwo" startLine="421" endLine="423" />
    <javadoc>
      <text>* Get the constant &radic;2.</text>
      <return>a {@link Dfp} with value &radic;2</return>
    </javadoc>
    <method type="Dfp" name="getSqr2" startLine="428" endLine="430" />
    <javadoc>
      <text>* Get the constant &radic;2 split in two pieces.</text>
      <return>a {@link Dfp} with value &radic;2 split in two pieces</return>
    </javadoc>
    <method type="Dfp[]" name="getSqr2Split" startLine="435" endLine="437" />
    <javadoc>
      <text>* Get the constant &radic;2 / 2.</text>
      <return>a {@link Dfp} with value &radic;2 / 2</return>
    </javadoc>
    <method type="Dfp" name="getSqr2Reciprocal" startLine="442" endLine="444" />
    <javadoc>
      <text>* Get the constant &radic;3.</text>
      <return>a {@link Dfp} with value &radic;3</return>
    </javadoc>
    <method type="Dfp" name="getSqr3" startLine="449" endLine="451" />
    <javadoc>
      <text>* Get the constant &radic;3 / 3.</text>
      <return>a {@link Dfp} with value &radic;3 / 3</return>
    </javadoc>
    <method type="Dfp" name="getSqr3Reciprocal" startLine="456" endLine="458" />
    <javadoc>
      <text>* Get the constant &pi;.</text>
      <return>a {@link Dfp} with value &pi;</return>
    </javadoc>
    <method type="Dfp" name="getPi" startLine="463" endLine="465" />
    <javadoc>
      <text>* Get the constant &pi; split in two pieces.</text>
      <return>a {@link Dfp} with value &pi; split in two pieces</return>
    </javadoc>
    <method type="Dfp[]" name="getPiSplit" startLine="470" endLine="472" />
    <javadoc>
      <text>* Get the constant e.</text>
      <return>a {@link Dfp} with value e</return>
    </javadoc>
    <method type="Dfp" name="getE" startLine="477" endLine="479" />
    <javadoc>
      <text>* Get the constant e split in two pieces.</text>
      <return>a {@link Dfp} with value e split in two pieces</return>
    </javadoc>
    <method type="Dfp[]" name="getESplit" startLine="484" endLine="486" />
    <javadoc>
      <text>* Get the constant ln(2).</text>
      <return>a {@link Dfp} with value ln(2)</return>
    </javadoc>
    <method type="Dfp" name="getLn2" startLine="491" endLine="493" />
    <javadoc>
      <text>* Get the constant ln(2) split in two pieces.</text>
      <return>a {@link Dfp} with value ln(2) split in two pieces</return>
    </javadoc>
    <method type="Dfp[]" name="getLn2Split" startLine="498" endLine="500" />
    <javadoc>
      <text>* Get the constant ln(5).</text>
      <return>a {@link Dfp} with value ln(5)</return>
    </javadoc>
    <method type="Dfp" name="getLn5" startLine="505" endLine="507" />
    <javadoc>
      <text>* Get the constant ln(5) split in two pieces.</text>
      <return>a {@link Dfp} with value ln(5) split in two pieces</return>
    </javadoc>
    <method type="Dfp[]" name="getLn5Split" startLine="512" endLine="514" />
    <javadoc>
      <text>* Get the constant ln(10).</text>
      <return>a {@link Dfp} with value ln(10)</return>
    </javadoc>
    <method type="Dfp" name="getLn10" startLine="519" endLine="521" />
    <javadoc>
      <text>* Breaks a string representation up into two {@link Dfp}'s.
 * The split is such that the sum of them is equivalent to the input string,
 * but has higher precision than using a single Dfp.</text>
      <param>a string representation of the number to split</param>
      <return>an array of two {@link Dfp Dfp} instances which sum equals a</return>
    </javadoc>
    <method type="Dfp[]" name="split" startLine="529" endLine="572">
      <declaration type="Dfp[]" name="result" />
      <declaration type="boolean" name="leading" />
      <declaration type="int" name="sp" />
      <declaration type="int" name="sig" />
      <declaration type="char[]" name="buf" />
      <scope startLine="537" endLine="557">
        <scope startLine="540" endLine="542" />
        <scope startLine="544" endLine="547" />
        <scope startLine="549" endLine="552" />
        <scope startLine="554" endLine="556" />
      </scope>
      <scope startLine="561" endLine="566">
        <scope startLine="563" endLine="565" />
      </scope>
    </method>
    <javadoc>
      <text>* Recompute the high precision string constants.</text>
      <param>highPrecisionDecimalDigits precision at which the string constants mus be computed</param>
    </javadoc>
    <method type="void" name="computeStringConstants" startLine="577" endLine="601">
      <scope startLine="578" endLine="600">
        <declaration type="DfpField" name="highPrecisionField" />
        <declaration type="Dfp" name="highPrecisionOne" />
        <declaration type="Dfp" name="highPrecisionTwo" />
        <declaration type="Dfp" name="highPrecisionThree" />
        <declaration type="Dfp" name="highPrecisionSqr2" />
        <declaration type="Dfp" name="highPrecisionSqr3" />
        <comment>recompute the string representation of the transcendental constants</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Compute &pi; using Jonathan and Peter Borwein quartic formula.</text>
      <param>one constant with value 1 at desired precision</param>
      <param>two constant with value 2 at desired precision</param>
      <param>three constant with value 3 at desired precision</param>
      <return>&pi;</return>
    </javadoc>
    <method type="Dfp" name="computePi" startLine="609" endLine="644">
      <declaration type="Dfp" name="sqrt2" />
      <declaration type="Dfp" name="yk" />
      <declaration type="Dfp" name="four" />
      <declaration type="Dfp" name="two2kp3" />
      <declaration type="Dfp" name="ak" />
      <scope startLine="623" endLine="640">
        <declaration type="Dfp" name="ykM1" />
        <declaration type="Dfp" name="y2" />
        <declaration type="Dfp" name="oneMinusY4" />
        <declaration type="Dfp" name="s" />
        <declaration type="Dfp" name="p" />
        <declaration type="Dfp" name="p2" />
        <scope startLine="637" endLine="639" />
      </scope>
      <comment>The formula converges quartically. This means the number of correct</comment>
      <comment>digits is multiplied by 4 at each iteration! Five iterations are</comment>
      <comment>sufficient for about 160 digits, eight iterations give about</comment>
      <comment>10000 digits (this has been checked) and 20 iterations more than</comment>
      <comment>160 billions of digits (this has NOT been checked).</comment>
      <comment>So the limit here is considered sufficient for most purposes ...</comment>
    </method>
    <javadoc>
      <text>* Compute exp(a).</text>
      <param>a number for which we want the exponential</param>
      <param>one constant with value 1 at desired precision</param>
      <return>exp(a)</return>
    </javadoc>
    <method type="Dfp" name="computeExp" startLine="651" endLine="672">
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="py" />
      <declaration type="Dfp" name="f" />
      <declaration type="Dfp" name="fi" />
      <declaration type="Dfp" name="x" />
      <scope startLine="659" endLine="668">
        <scope startLine="664" endLine="666" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute ln(a).
 * Let f(x) = ln(x),
 * We know that f'(x) = 1/x, thus from Taylor's theorem we have:
 * -----          n+1         n
 * f(x) =   \           (-1)    (x - 1)
 * /          ----------------    for 1 <= n <= infinity
 * -----             n
 * or
 * 2        3       4
 * (x-1)   (x-1)    (x-1)
 * ln(x) =  (x-1) - ----- + ------ - ------ + ...
 * 2       3        4
 * alternatively,
 * 2    3   4
 * x    x   x
 * ln(x+1) =  x - -  + - - - + ...
 * 2    3   4
 * This series can be used to compute ln(x), but it converges too slowly.
 * If we substitute -x for x above, we get
 * 2    3    4
 * x    x    x
 * ln(1-x) =  -x - -  - -  - - + ...
 * 2    3    4
 * Note that all terms are now negative.  Because the even powered ones
 * absorbed the sign.  Now, subtract the series above from the previous
 * one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
 * only the odd ones
 * 3     5      7
 * 2x    2x     2x
 * ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
 * 3     5      7
 * By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
 * 3        5        7
 * x+1           /          x        x        x          \
 * ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
 * x-1           \          3        5        7          /
 * But now we want to find ln(a), so we need to find the value of x
 * such that a = (x+1)/(x-1).   This is easily solved to find that
 * x = (a-1)/(a+1).</text>
      <param>a number for which we want the exponential</param>
      <param>one constant with value 1 at desired precision</param>
      <param>two constant with value 2 at desired precision</param>
      <return>ln(a)</return>
    </javadoc>
    <method type="Dfp" name="computeLn" startLine="734" endLine="756">
      <declaration type="int" name="den" />
      <declaration type="Dfp" name="x" />
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="num" />
      <declaration type="Dfp" name="py" />
      <scope startLine="742" endLine="752">
        <declaration type="Dfp" name="t" />
        <scope startLine="748" endLine="750" />
      </scope>
    </method>
    <comment>Note: the static strings are set up (once) by the ctor and @GuardedBy("DfpField.class")</comment>
  </class>
</source>
