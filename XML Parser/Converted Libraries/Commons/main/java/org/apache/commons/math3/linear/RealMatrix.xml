<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.linear">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NoDataException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <interface name="RealMatrix" startLine="28">
    <implements name="AnyMatrix" />
    <javadoc>
      <text>* Interface defining a real-valued matrix with basic algebraic operations.
 * <p>
 * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>
 * returns the element in the first row, first column of the matrix.</p></text>
      <version>$Id: RealMatrix.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <method name="createMatrix" type="RealMatrix" startLine="38" endLine="51" />
    <javadoc>
      <text>* Create a new RealMatrix of the same type as the instance with the
 * supplied
 * row and column dimensions.</text>
      <param>rowDimension the number of rows in the new matrix</param>
      <param>columnDimension the number of columns in the new matrix</param>
      <return>a new matrix of the same type as the instance</return>
      <throws>NotStrictlyPositiveException if row or column dimension is not
 * positive.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="copy" type="RealMatrix" startLine="53" endLine="58" />
    <javadoc>
      <text>* Returns a (deep) copy of this.</text>
      <return>matrix copy</return>
    </javadoc>
    <method name="add" type="RealMatrix" startLine="60" endLine="69" />
    <javadoc>
      <text>* Returns the sum of {@code this} and {@code m}.</text>
      <param>m matrix to be added</param>
      <return>{@code this + m}</return>
      <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this}.</throws>
    </javadoc>
    <method name="subtract" type="RealMatrix" startLine="71" endLine="80" />
    <javadoc>
      <text>* Returns {@code this} minus {@code m}.</text>
      <param>m matrix to be subtracted</param>
      <return>{@code this - m}</return>
      <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this}.</throws>
    </javadoc>
    <method name="scalarAdd" type="RealMatrix" startLine="82" endLine="88" />
    <javadoc>
      <text>* Returns the result of adding {@code d} to each entry of {@code this}.</text>
      <param>d value to be added to each entry</param>
      <return>{@code d + this}</return>
    </javadoc>
    <method name="scalarMultiply" type="RealMatrix" startLine="90" endLine="97" />
    <javadoc>
      <text>* Returns the result of multiplying each entry of {@code this} by{@code d}.</text>
      <param>d value to multiply all entries by</param>
      <return>{@code d * this}</return>
    </javadoc>
    <method name="multiply" type="RealMatrix" startLine="99" endLine="108" />
    <javadoc>
      <text>* Returns the result of postmultiplying {@code this} by {@code m}.</text>
      <param>m matrix to postmultiply by</param>
      <return>{@code this * m}</return>
      <throws>DimensionMismatchException if{@code columnDimension(this) != rowDimension(m)}</throws>
    </javadoc>
    <method name="preMultiply" type="RealMatrix" startLine="110" endLine="119" />
    <javadoc>
      <text>* Returns the result of premultiplying {@code this} by {@code m}.</text>
      <param>m matrix to premultiply by</param>
      <return>{@code m * this}</return>
      <throws>DimensionMismatchException if{@code rowDimension(this) != columnDimension(m)}</throws>
    </javadoc>
    <method name="power" type="RealMatrix" startLine="121" endLine="132" />
    <javadoc>
      <text>* Returns the result of multiplying {@code this} with itself {@code p}times. Depending on the underlying storage, instability for high powers
 * might occur.</text>
      <param>p raise {@code this} to power {@code p}</param>
      <return>{@code this^p}</return>
      <throws>NotPositiveException if {@code p < 0}</throws>
      <throws>NonSquareMatrixException if the matrix is not square</throws>
    </javadoc>
    <method name="getData" type="double[][]" startLine="134" endLine="139" />
    <javadoc>
      <text>* Returns matrix entries as a two-dimensional array.</text>
      <return>2-dimensional array of entries</return>
    </javadoc>
    <method name="getNorm" type="double" startLine="141" endLine="147" />
    <javadoc>
      <text>* Returns the <a href="http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html">
 * maximum absolute row sum norm</a> of the matrix.</text>
      <return>norm</return>
    </javadoc>
    <method name="getFrobeniusNorm" type="double" startLine="149" endLine="155" />
    <javadoc>
      <text>* Returns the <a href="http://mathworld.wolfram.com/FrobeniusNorm.html">
 * Frobenius norm</a> of the matrix.</text>
      <return>norm</return>
    </javadoc>
    <method name="getSubMatrix" type="RealMatrix" startLine="157" endLine="173" />
    <javadoc>
      <text>* Gets a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.</text>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <return>The subMatrix containing the data of the
 * specified rows and columns.</return>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
    </javadoc>
    <method name="getSubMatrix" type="RealMatrix" startLine="175" endLine="189" />
    <javadoc>
      <text>* Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.</text>
      <param>selectedRows Array of row indices.</param>
      <param>selectedColumns Array of column indices.</param>
      <return>The subMatrix containing the data in the specified rows and
 * columns</return>
      <throws>NullArgumentException if the row or column selections are{@code null}</throws>
      <throws>NoDataException if the row or column selections are empty (zero
 * length).</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
    </javadoc>
    <method name="copySubMatrix" type="void" startLine="191" endLine="210" />
    <javadoc>
      <text>* Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.</text>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <param>destination The arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be
 * used)</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <throws>MatrixDimensionMismatchException if the destination array is too
 * small.</throws>
    </javadoc>
    <method name="copySubMatrix" type="void" startLine="212" endLine="231" />
    <javadoc>
      <text>* Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.</text>
      <param>selectedRows Array of row indices.</param>
      <param>selectedColumns Array of column indices.</param>
      <param>destination The arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be
 * used)</param>
      <throws>NullArgumentException if the row or column selections are{@code null}</throws>
      <throws>NoDataException if the row or column selections are empty (zero
 * length).</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>MatrixDimensionMismatchException if the destination array is too
 * small.</throws>
    </javadoc>
    <method name="setSubMatrix" type="void" startLine="233" endLine="263" />
    <javadoc>
      <text>* Replace the submatrix starting at {@code row, column} using data in the
 * input {@code subMatrix} array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking{@code setSubMatrix(subMatrix,1,1))} will result in <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre></p></text>
      <param>subMatrix  array containing the submatrix replacement data</param>
      <param>row  row coordinate of the top, left element to be replaced</param>
      <param>column  column coordinate of the top, left element to be replaced</param>
      <throws>NoDataException if {@code subMatrix} is empty.</throws>
      <throws>OutOfRangeException if {@code subMatrix} does not fit into
 * this matrix from element in {@code (row, column)}.</throws>
      <throws>DimensionMismatchException if {@code subMatrix} is not rectangular
 * (not all rows have the same length) or empty.</throws>
      <throws>NullArgumentException if {@code subMatrix} is {@code null}.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="getRowMatrix" type="RealMatrix" startLine="265" endLine="273" />
    <javadoc>
      <text>* Get the entries at the given row index as a row matrix.  Row indices start
 * at 0.</text>
      <param>row Row to be fetched.</param>
      <return>row Matrix.</return>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
    </javadoc>
    <method name="setRowMatrix" type="void" startLine="275" endLine="288" />
    <javadoc>
      <text>* Sets the specified {@code row} of {@code this} matrix to the entries of
 * the specified row {@code matrix}. Row indices start at 0.</text>
      <param>row Row to be set.</param>
      <param>matrix Row matrix to be copied (must have one row and the same
 * number of columns as the instance).</param>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the row dimension of the{@code matrix} is not {@code 1}, or the column dimensions of {@code this}and {@code matrix} do not match.</throws>
    </javadoc>
    <method name="getColumnMatrix" type="RealMatrix" startLine="290" endLine="299" />
    <javadoc>
      <text>* Get the entries at the given column index as a column matrix. Column
 * indices start at 0.</text>
      <param>column Column to be fetched.</param>
      <return>column Matrix.</return>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
    </javadoc>
    <method name="setColumnMatrix" type="void" startLine="301" endLine="314" />
    <javadoc>
      <text>* Sets the specified {@code column} of {@code this} matrix to the entries
 * of the specified column {@code matrix}. Column indices start at 0.</text>
      <param>column Column to be set.</param>
      <param>matrix Column matrix to be copied (must have one column and the
 * same number of rows as the instance).</param>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the column dimension of the{@code matrix} is not {@code 1}, or the row dimensions of {@code this}and {@code matrix} do not match.</throws>
    </javadoc>
    <method name="getRowVector" type="RealVector" startLine="316" endLine="325" />
    <javadoc>
      <text>* Returns the entries in row number {@code row} as a vector. Row indices
 * start at 0.</text>
      <param>row Row to be fetched.</param>
      <return>a row vector.</return>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
    </javadoc>
    <method name="setRowVector" type="void" startLine="327" endLine="339" />
    <javadoc>
      <text>* Sets the specified {@code row} of {@code this} matrix to the entries of
 * the specified {@code vector}. Row indices start at 0.</text>
      <param>row Row to be set.</param>
      <param>vector row vector to be copied (must have the same number of
 * column as the instance).</param>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the {@code vector} dimension
 * does not match the column dimension of {@code this} matrix.</throws>
    </javadoc>
    <method name="getColumnVector" type="RealVector" startLine="341" endLine="350" />
    <javadoc>
      <text>* Get the entries at the given column index as a vector. Column indices
 * start at 0.</text>
      <param>column Column to be fetched.</param>
      <return>a column vector.</return>
      <throws>OutOfRangeException if the specified column index is invalid</throws>
    </javadoc>
    <method name="setColumnVector" type="void" startLine="352" endLine="364" />
    <javadoc>
      <text>* Sets the specified {@code column} of {@code this} matrix to the entries
 * of the specified {@code vector}. Column indices start at 0.</text>
      <param>column Column to be set.</param>
      <param>vector column vector to be copied (must have the same number of
 * rows as the instance).</param>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the {@code vector} dimension
 * does not match the row dimension of {@code this} matrix.</throws>
    </javadoc>
    <method name="getRow" type="double[]" startLine="366" endLine="373" />
    <javadoc>
      <text>* Get the entries at the given row index. Row indices start at 0.</text>
      <param>row Row to be fetched.</param>
      <return>the array of entries in the row.</return>
      <throws>OutOfRangeException if the specified row index is not valid.</throws>
    </javadoc>
    <method name="setRow" type="void" startLine="375" endLine="387" />
    <javadoc>
      <text>* Sets the specified {@code row} of {@code this} matrix to the entries
 * of the specified {@code array}. Row indices start at 0.</text>
      <param>row Row to be set.</param>
      <param>array Row matrix to be copied (must have the same number of
 * columns as the instance)</param>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the {@code array} length does
 * not match the column dimension of {@code this} matrix.</throws>
    </javadoc>
    <method name="getColumn" type="double[]" startLine="389" endLine="397" />
    <javadoc>
      <text>* Get the entries at the given column index as an array. Column indices
 * start at 0.</text>
      <param>column Column to be fetched.</param>
      <return>the array of entries in the column.</return>
      <throws>OutOfRangeException if the specified column index is not valid.</throws>
    </javadoc>
    <method name="setColumn" type="void" startLine="399" endLine="411" />
    <javadoc>
      <text>* Sets the specified {@code column} of {@code this} matrix to the entries
 * of the specified {@code array}. Column indices start at 0.</text>
      <param>column Column to be set.</param>
      <param>array Column array to be copied (must have the same number of
 * rows as the instance).</param>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the {@code array} length does
 * not match the row dimension of {@code this} matrix.</throws>
    </javadoc>
    <method name="getEntry" type="double" startLine="413" endLine="422" />
    <javadoc>
      <text>* Get the entry in the specified row and column. Row and column indices
 * start at 0.</text>
      <param>row Row index of entry to be fetched.</param>
      <param>column Column index of entry to be fetched.</param>
      <return>the matrix entry at {@code (row, column)}.</return>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
    </javadoc>
    <method name="setEntry" type="void" startLine="424" endLine="434" />
    <javadoc>
      <text>* Set the entry in the specified row and column. Row and column indices
 * start at 0.</text>
      <param>row Row index of entry to be set.</param>
      <param>column Column index of entry to be set.</param>
      <param>value the new value of the entry.</param>
      <throws>OutOfRangeException if the row or column index is not valid</throws>
      <since>2.0</since>
    </javadoc>
    <method name="addToEntry" type="void" startLine="436" endLine="446" />
    <javadoc>
      <text>* Adds (in place) the specified value to the specified entry of{@code this} matrix. Row and column indices start at 0.</text>
      <param>row Row index of the entry to be modified.</param>
      <param>column Column index of the entry to be modified.</param>
      <param>increment value to add to the matrix entry.</param>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="multiplyEntry" type="void" startLine="448" endLine="458" />
    <javadoc>
      <text>* Multiplies (in place) the specified entry of {@code this} matrix by the
 * specified value. Row and column indices start at 0.</text>
      <param>row Row index of the entry to be modified.</param>
      <param>column Column index of the entry to be modified.</param>
      <param>factor Multiplication factor for the matrix entry.</param>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="transpose" type="RealMatrix" startLine="460" endLine="465" />
    <javadoc>
      <text>* Returns the transpose of this matrix.</text>
      <return>transpose matrix</return>
    </javadoc>
    <method name="getTrace" type="double" startLine="467" endLine="474" />
    <javadoc>
      <text>* Returns the <a href="http://mathworld.wolfram.com/MatrixTrace.html">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).</text>
      <return>the trace.</return>
      <throws>NonSquareMatrixException if the matrix is not square.</throws>
    </javadoc>
    <method name="operate" type="double[]" startLine="476" endLine="484" />
    <javadoc>
      <text>* Returns the result of multiplying this by the vector {@code v}.</text>
      <param>v the vector to operate on</param>
      <return>{@code this * v}</return>
      <throws>DimensionMismatchException if the length of {@code v} does not
 * match the column dimension of {@code this}.</throws>
    </javadoc>
    <method name="operate" type="RealVector" startLine="486" endLine="494" />
    <javadoc>
      <text>* Returns the result of multiplying this by the vector {@code v}.</text>
      <param>v the vector to operate on</param>
      <return>{@code this * v}</return>
      <throws>DimensionMismatchException if the dimension of {@code v} does not
 * match the column dimension of {@code this}.</throws>
    </javadoc>
    <method name="preMultiply" type="double[]" startLine="496" endLine="504" />
    <javadoc>
      <text>* Returns the (row) vector result of premultiplying this by the vector {@code v}.</text>
      <param>v the row vector to premultiply by</param>
      <return>{@code v * this}</return>
      <throws>DimensionMismatchException if the length of {@code v} does not
 * match the row dimension of {@code this}.</throws>
    </javadoc>
    <method name="preMultiply" type="RealVector" startLine="506" endLine="514" />
    <javadoc>
      <text>* Returns the (row) vector result of premultiplying this by the vector {@code v}.</text>
      <param>v the row vector to premultiply by</param>
      <return>{@code v * this}</return>
      <throws>DimensionMismatchException if the dimension of {@code v} does not
 * match the row dimension of {@code this}.</throws>
    </javadoc>
    <method name="walkInRowOrder" type="double" startLine="516" endLine="536" />
    <javadoc>
      <text>* Visit (and possibly change) all matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInRowOrder" type="double" startLine="538" endLine="558" />
    <javadoc>
      <text>* Visit (but don't change) all matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInRowOrder" type="double" startLine="560" endLine="589" />
    <javadoc>
      <text>* Visit (and possibly change) some matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInRowOrder" type="double" startLine="591" endLine="620" />
    <javadoc>
      <text>* Visit (but don't change) some matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="double" startLine="622" endLine="642" />
    <javadoc>
      <text>* Visit (and possibly change) all matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="double" startLine="644" endLine="664" />
    <javadoc>
      <text>* Visit (but don't change) all matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="double" startLine="666" endLine="695" />
    <javadoc>
      <text>* Visit (and possibly change) some matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="double" startLine="697" endLine="726" />
    <javadoc>
      <text>* Visit (but don't change) some matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="double" startLine="728" endLine="747" />
    <javadoc>
      <text>* Visit (and possibly change) all matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="double" startLine="749" endLine="768" />
    <javadoc>
      <text>* Visit (but don't change) all matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="double" startLine="770" endLine="798" />
    <javadoc>
      <text>* Visit (and possibly change) some matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="double" startLine="800" endLine="828" />
    <javadoc>
      <text>* Visit (but don't change) some matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(RealMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(RealMatrixChangingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link RealMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
  </interface>
</source>
