<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.complex">
  <import name="java.io.Serializable" />
  <import name="java.util.ArrayList" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.FieldElement" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="Complex" startLine="31">
    <implements name="FieldElement<Complex>" />
    <implements name="Serializable" />
    <javadoc>
      <text>* Representation of a Complex number, i.e. a number which has both a
 * real and imaginary part.
 * <br/>
 * Implementations of arithmetic operations handle {@code NaN} and
 * infinite values according to the rules for {@link java.lang.Double}, i.e.{@link #equals} is an equivalence relation for all instances that have
 * a {@code NaN} in either real or imaginary part, e.g. the following are
 * considered equal:
 * <ul>
 * <li>{@code 1 + NaNi}</li>
 * <li>{@code NaN + i}</li>
 * <li>{@code NaN + NaNi}</li>
 * </ul>
 * Note that this is in contradiction with the IEEE-754 standard for floating
 * point numbers (according to which the test {@code x == x} must fail if{@code x} is {@code NaN}). The method{@link org.apache.commons.math3.util.Precision#equals(double,double,int)equals for primitive double} in {@link org.apache.commons.math3.util.Precision}conforms with IEEE-754 while this class conforms with the standard behavior
 * for Java object types.
 * <br/>
 * Implements Serializable since 2.0</text>
      <version>$Id: Complex.java 1459927 2013-03-22 18:55:58Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* The square root of -1. A number representing "0.0 + 1.0i"</text>
    </javadoc>
    <declaration type="Complex" name="I" />
    <javadoc>
      <text>* A complex number representing "NaN + NaNi"</text>
    </javadoc>
    <declaration type="Complex" name="NaN" />
    <javadoc>
      <text>* A complex number representing "+INF + INFi"</text>
    </javadoc>
    <declaration type="Complex" name="INF" />
    <javadoc>
      <text>* A complex number representing "1.0 + 0.0i"</text>
    </javadoc>
    <declaration type="Complex" name="ONE" />
    <javadoc>
      <text>* A complex number representing "0.0 + 0.0i"</text>
    </javadoc>
    <declaration type="Complex" name="ZERO" />
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* The imaginary part.</text>
    </javadoc>
    <declaration type="double" name="imaginary" />
    <javadoc>
      <text>* The real part.</text>
    </javadoc>
    <declaration type="double" name="real" />
    <javadoc>
      <text>* Record whether this complex number is equal to NaN.</text>
    </javadoc>
    <declaration type="boolean" name="isNaN" />
    <javadoc>
      <text>* Record whether this complex number is infinite.</text>
    </javadoc>
    <declaration type="boolean" name="isInfinite" />
    <javadoc>
      <text>* Create a complex number given only the real part.</text>
      <param>real Real part.</param>
    </javadoc>
    <method type="constructor" name="Complex" startLine="88" endLine="90" />
    <javadoc>
      <text>* Create a complex number given the real and imaginary parts.</text>
      <param>real Real part.</param>
      <param>imaginary Imaginary part.</param>
    </javadoc>
    <method type="constructor" name="Complex" startLine="98" endLine="105" />
    <javadoc>
      <text>* Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.</text>
      <return>the absolute value.</return>
    </javadoc>
    <method type="double" name="abs" startLine="115" endLine="135">
      <scope startLine="116" endLine="118" />
      <scope startLine="119" endLine="121" />
      <scope startLine="122" endLine="128">
        <scope startLine="123" endLine="125" />
        <declaration type="double" name="q" />
      </scope>
      <scope startLine="128" endLine="134">
        <scope startLine="129" endLine="131" />
        <declaration type="double" name="q" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is{@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 * <code>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.</text>
      <param>addend Value to be added to this {@code Complex}.</param>
      <return>{@code this + addend}.</return>
      <throws>NullArgumentException if {@code addend} is {@code null}.</throws>
    </javadoc>
    <method type="Complex" name="add" startLine="156" endLine="164">
      <scope startLine="158" endLine="160" />
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.</text>
      <param>addend Value to be added to this {@code Complex}.</param>
      <return>{@code this + addend}.</return>
      <see>#add(Complex)</see>
    </javadoc>
    <method type="Complex" name="add" startLine="174" endLine="180">
      <scope startLine="175" endLine="177" />
    </method>
    <javadoc>
      <text>* Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>{@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not{@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of{@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.</text>
      <return>the conjugate of this Complex object.</return>
    </javadoc>
    <method type="Complex" name="conjugate" startLine="196" endLine="202">
      <scope startLine="197" endLine="199" />
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is{@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 * <code>
 * a + bi          ac + bd + (bc - ad)i
 * ----------- = -------------------------
 * c + di         c<sup>2</sup> + d<sup>2</sup>
 * </code>
 * </pre>
 * but uses
 * <a href="http://doi.acm.org/10.1145/1039813.1039814">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>{@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 * <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 * in either part, {@link #NaN} is returned.
 * </li>
 * <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
 * </li>
 * <li>If {@code this} and {@code divisor} are both infinite,{@link #NaN} is returned.
 * </li>
 * <li>If {@code this} is finite (i.e., has no {@code Infinite} or{@code NaN} parts) and {@code divisor} is infinite (one or both parts
 * infinite), {@link #ZERO} is returned.
 * </li>
 * <li>If {@code this} is infinite and {@code divisor} is finite,{@code NaN} values are returned in the parts of the result if the{@link java.lang.Double} rules applied to the definitional formula
 * force {@code NaN} results.
 * </li>
 * </ul></text>
      <param>divisor Value by which this {@code Complex} is to be divided.</param>
      <return>{@code this / divisor}.</return>
      <throws>NullArgumentException if {@code divisor} is {@code null}.</throws>
    </javadoc>
    <method type="Complex" name="divide" startLine="247" endLine="274">
      <scope startLine="249" endLine="251" />
      <declaration type="double" name="c" />
      <declaration type="double" name="d" />
      <scope startLine="255" endLine="257" />
      <scope startLine="259" endLine="261" />
      <scope startLine="263" endLine="268">
        <declaration type="double" name="q" />
        <declaration type="double" name="denominator" />
      </scope>
      <scope startLine="268" endLine="273">
        <declaration type="double" name="q" />
        <declaration type="double" name="denominator" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.</text>
      <param>divisor Value by which this {@code Complex} is to be divided.</param>
      <return>{@code this / divisor}.</return>
      <see>#divide(Complex)</see>
    </javadoc>
    <method type="Complex" name="divide" startLine="284" endLine="296">
      <scope startLine="285" endLine="287" />
      <scope startLine="288" endLine="290" />
      <scope startLine="291" endLine="293" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Complex" name="reciprocal" startLine="299" endLine="321">
      <scope startLine="300" endLine="302" />
      <scope startLine="304" endLine="306" />
      <scope startLine="308" endLine="310" />
      <scope startLine="312" endLine="316">
        <declaration type="double" name="q" />
        <declaration type="double" name="scale" />
      </scope>
      <scope startLine="316" endLine="320">
        <declaration type="double" name="q" />
        <declaration type="double" name="scale" />
      </scope>
    </method>
    <javadoc>
      <text>* Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to{@code NaN}.</text>
      <param>other Object to test for equality to this</param>
      <return>true if two Complex objects are equal, false if object is{@code null}, not an instance of Complex, or not equal to this Complex
 * instance.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="339" endLine="352">
      <scope startLine="340" endLine="342" />
      <scope startLine="343" endLine="350">
        <declaration type="Complex" name="c" />
        <scope startLine="345" endLine="347" />
        <scope startLine="347" endLine="349" />
      </scope>
    </method>
    <javadoc>
      <text>* Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.</text>
      <return>a hash code value for this object.</return>
    </javadoc>
    <method type="int" name="hashCode" startLine="362" endLine="368">
      <scope startLine="363" endLine="365" />
    </method>
    <javadoc>
      <text>* Access the imaginary part.</text>
      <return>the imaginary part.</return>
    </javadoc>
    <method type="double" name="getImaginary" startLine="375" endLine="377" />
    <javadoc>
      <text>* Access the real part.</text>
      <return>the real part.</return>
    </javadoc>
    <method type="double" name="getReal" startLine="384" endLine="386" />
    <javadoc>
      <text>* Checks whether either or both parts of this complex number is{@code NaN}.</text>
      <return>true if either or both parts of this complex number is{@code NaN}; false otherwise.</return>
    </javadoc>
    <method type="boolean" name="isNaN" startLine="395" endLine="397" />
    <javadoc>
      <text>* Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or{@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.</text>
      <return>true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.</return>
    </javadoc>
    <method type="boolean" name="isInfinite" startLine="408" endLine="410" />
    <javadoc>
      <text>* Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 * <code>
 * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 * </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.</text>
      <param>factor value to be multiplied by this {@code Complex}.</param>
      <return>{@code this * factor}.</return>
      <throws>NullArgumentException if {@code factor} is {@code null}.</throws>
    </javadoc>
    <method type="Complex" name="multiply" startLine="437" endLine="451">
      <scope startLine="439" endLine="441" />
      <scope startLine="445" endLine="448">
        <comment>we don't use isInfinite() to avoid testing for NaN again</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}interpreted as a integer number.</text>
      <param>factor value to be multiplied by this {@code Complex}.</param>
      <return>{@code this * factor}.</return>
      <see>#multiply(Complex)</see>
    </javadoc>
    <method type="Complex" name="multiply" startLine="461" endLine="470">
      <scope startLine="462" endLine="464" />
      <scope startLine="466" endLine="468" />
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}interpreted as a real number.</text>
      <param>factor value to be multiplied by this {@code Complex}.</param>
      <return>{@code this * factor}.</return>
      <see>#multiply(Complex)</see>
    </javadoc>
    <method type="Complex" name="multiply" startLine="480" endLine="491">
      <scope startLine="481" endLine="483" />
      <scope startLine="486" endLine="489">
        <comment>we don't use isInfinite() to avoid testing for NaN again</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is {@code (-this)}.
 * Returns {@code NaN} if either real or imaginary
 * part of this Complex number equals {@code Double.NaN}.</text>
      <return>{@code -this}.</return>
    </javadoc>
    <method type="Complex" name="negate" startLine="500" endLine="506">
      <scope startLine="501" endLine="503" />
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is{@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 * <code>
 * (a + bi) - (c + di) = (a-c) + (b-d)i
 * </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,{@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for{@link java.lang.Double} arithmetic.</text>
      <param>subtrahend value to be subtracted from this {@code Complex}.</param>
      <return>{@code this - subtrahend}.</return>
      <throws>NullArgumentException if {@code subtrahend} is {@code null}.</throws>
    </javadoc>
    <method type="Complex" name="subtract" startLine="527" endLine="535">
      <scope startLine="529" endLine="531" />
    </method>
    <javadoc>
      <text>* Returns a {@code Complex} whose value is{@code (this - subtrahend)}.</text>
      <param>subtrahend value to be subtracted from this {@code Complex}.</param>
      <return>{@code this - subtrahend}.</return>
      <see>#subtract(Complex)</see>
    </javadoc>
    <method type="Complex" name="subtract" startLine="545" endLine="550">
      <scope startLine="546" endLine="548" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/InverseCosine.html" TARGET="_top">
 * inverse cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))
 * </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.</text>
      <return>the inverse cosine of this complex number.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="acos" startLine="568" endLine="574">
      <scope startLine="569" endLine="571" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/InverseSine.html" TARGET="_top">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 * </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.</text>
      <return>the inverse sine of this complex number.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="asin" startLine="592" endLine="598">
      <scope startLine="593" endLine="595" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/InverseTangent.html" TARGET="_top">
 * inverse tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * atan(z) = (i/2) log((i + z)/(i - z))
 * </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.</text>
      <return>the inverse tangent of this complex number</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="atan" startLine="616" endLine="623">
      <scope startLine="617" endLine="619" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/Cosine.html" TARGET="_top">
 * cosine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 * cos(&plusmn;INFINITY + i) = NaN + NaN i
 * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * </code>
 * </pre></text>
      <return>the cosine of this complex number.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="cos" startLine="657" endLine="664">
      <scope startLine="658" endLine="660" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/HyperbolicCosine.html" TARGET="_top">
 * hyperbolic cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * </code>
 * </pre></text>
      <return>the hyperbolic cosine of this complex number.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="cosh" startLine="697" endLine="704">
      <scope startLine="698" endLine="700" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/ExponentialFunction.html" TARGET="_top">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and{@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * exp(1 &plusmn; INFINITY i) = NaN + NaN i
 * exp(INFINITY + i) = INFINITY + INFINITY i
 * exp(-INFINITY + i) = 0 + 0i
 * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * </code>
 * </pre></text>
      <return><code><i>e</i><sup>this</sup></code>.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="exp" startLine="738" endLine="746">
      <scope startLine="739" endLine="741" />
      <declaration type="double" name="expReal" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/NaturalLogarithm.html" TARGET="_top">
 * natural logarithm</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * log(a + bi) = ln(|a + bi|) + arg(a + bi)i
 * </code>
 * </pre>
 * where ln on the right hand side is {@link java.lang.Math#log},{@code |a + bi|} is the modulus, {@link Complex#abs},  and{@code arg(a + bi) = }{@link java.lang.Math#atan2}(b, a).
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 * log(INFINITY + i) = INFINITY + 0i
 * log(-INFINITY + i) = INFINITY + &pi;i
 * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 * log(0 + 0i) = -INFINITY + 0i
 * </code>
 * </pre></text>
      <return>the value <code>ln &nbsp; this</code>, the natural logarithm
 * of {@code this}.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="log" startLine="783" endLine="790">
      <scope startLine="784" endLine="786" />
    </method>
    <javadoc>
      <text>* Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 * <code>
 * y<sup>x</sup> = exp(x&middot;log(y))
 * </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and{@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}equals {@link Complex#ZERO}.</text>
      <param>x exponent to which this {@code Complex} is to be raised.</param>
      <return><code> this<sup>{@code x}</sup></code>.</return>
      <throws>NullArgumentException if x is {@code null}.</throws>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="pow" startLine="813" endLine="816" />
    <javadoc>
      <text>* Returns of value of this complex number raised to the power of {@code x}.</text>
      <param>x exponent to which this {@code Complex} is to be raised.</param>
      <return><code>this<sup>x</sup></code>.</return>
      <see>#pow(Complex)</see>
    </javadoc>
    <method type="Complex" name="pow" startLine="825" endLine="827" />
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/Sine.html" TARGET="_top">
 * sine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or {@code NaN} values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 * sin(&plusmn;INFINITY + i) = NaN + NaN i
 * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * </code>
 * </pre></text>
      <return>the sine of this complex number.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="sin" startLine="861" endLine="868">
      <scope startLine="862" endLine="864" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/HyperbolicSine.html" TARGET="_top">
 * hyperbolic sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link java.lang.Math#sin}, {@link java.lang.Math#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * sinh(1 &plusmn; INFINITY i) = NaN + NaN i
 * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
 * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * </code>
 * </pre></text>
      <return>the hyperbolic sine of {@code this}.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="sinh" startLine="901" endLine="908">
      <scope startLine="902" endLine="904" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}</ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(INFINITY + i) = INFINITY + 0i
 * sqrt(-INFINITY + i) = 0 + INFINITY i
 * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 * </code>
 * </pre></text>
      <return>the square root of {@code this}.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="sqrt" startLine="944" endLine="960">
      <scope startLine="945" endLine="947" />
      <scope startLine="949" endLine="951" />
      <declaration type="double" name="t" />
      <scope startLine="954" endLine="956" />
      <scope startLine="956" endLine="959" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">
 * square root</a> of <code>1 - this<sup>2</sup></code> for this complex
 * number.
 * Computes the result directly as{@code sqrt(ONE.subtract(z.multiply(z)))}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.</text>
      <return>the square root of <code>1 - this<sup>2</sup></code>.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="sqrt1z" startLine="979" endLine="981" />
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/Tangent.html" TARGET="_top">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and{@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * tan(a &plusmn; INFINITY i) = 0 &plusmn; i
 * tan(&plusmn;INFINITY + bi) = NaN + NaN i
 * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 * </code>
 * </pre></text>
      <return>the tangent of {@code this}.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="tan" startLine="1015" endLine="1032">
      <scope startLine="1016" endLine="1018" />
      <scope startLine="1019" endLine="1021" />
      <scope startLine="1022" endLine="1024" />
      <declaration type="double" name="real2" />
      <declaration type="double" name="imaginary2" />
      <declaration type="double" name="d" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://mathworld.wolfram.com/HyperbolicTangent.html" TARGET="_top">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 * <code>
 * tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 * </code>
 * </pre>
 * where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and{@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 * Examples:
 * <code>
 * tanh(a &plusmn; INFINITY i) = NaN + NaN i
 * tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i
 * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 * tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 * </code>
 * </pre></text>
      <return>the hyperbolic tangent of {@code this}.</return>
      <since>1.2</since>
    </javadoc>
    <method type="Complex" name="tanh" startLine="1066" endLine="1082">
      <scope startLine="1067" endLine="1069" />
      <scope startLine="1070" endLine="1072" />
      <scope startLine="1073" endLine="1075" />
      <declaration type="double" name="real2" />
      <declaration type="double" name="imaginary2" />
      <declaration type="double" name="d" />
    </method>
    <javadoc>
      <text>* Compute the argument of this complex number.
 * The argument is the angle phi between the positive real axis and
 * the point representing this number in the complex plane.
 * The value returned is between -PI (not inclusive)
 * and PI (inclusive), with negative values returned for numbers with
 * negative imaginary parts.
 * <br/>
 * If either real or imaginary part (or both) is NaN, NaN is returned.
 * Infinite parts are handled as {@code Math.atan2} handles them,
 * essentially treating finite parts as zero in the presence of an
 * infinite coordinate and returning a multiple of pi/4 depending on
 * the signs of the infinite parts.
 * See the javadoc for {@code Math.atan2} for full details.</text>
      <return>the argument of {@code this}.</return>
    </javadoc>
    <method type="double" name="getArgument" startLine="1103" endLine="1105" />
    <javadoc>
      <text>* Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 * <code>
 * z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 * </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}are respectively the {@link #abs() modulus} and{@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.</text>
      <param>n Degree of root.</param>
      <return>a List<Complex> of all {@code n}-th roots of {@code this}.</return>
      <throws>NotPositiveException if {@code n <= 0}.</throws>
      <since>2.0</since>
    </javadoc>
    <method type="List<Complex>" name="nthRoot" startLine="1129" endLine="1163">
      <scope startLine="1131" endLine="1134" />
      <declaration type="List<Complex>" name="result" />
      <scope startLine="1138" endLine="1141" />
      <scope startLine="1142" endLine="1145" />
      <declaration type="double" name="nthRootOfAbs" />
      <declaration type="double" name="nthPhi" />
      <declaration type="double" name="slice" />
      <declaration type="double" name="innerPart" />
      <scope startLine="1154" endLine="1160">
        <declaration type="double" name="realPart" />
        <declaration type="double" name="imaginaryPart" />
        <comment>inner part</comment>
      </scope>
      <comment>nth root of abs -- faster / more accurate to use a solver here?</comment>
      <comment>Compute nth roots of complex number with k = 0, 1, ... n-1</comment>
    </method>
    <javadoc>
      <text>* Create a complex number given the real and imaginary parts.</text>
      <param>realPart Real part.</param>
      <param>imaginaryPart Imaginary part.</param>
      <return>a new complex number instance.</return>
      <since>1.2</since>
      <see>#valueOf(double,double)</see>
    </javadoc>
    <method type="Complex" name="createComplex" startLine="1175" endLine="1177" />
    <javadoc>
      <text>* Create a complex number given the real and imaginary parts.</text>
      <param>realPart Real part.</param>
      <param>imaginaryPart Imaginary part.</param>
      <return>a Complex instance.</return>
    </javadoc>
    <method type="Complex" name="valueOf" startLine="1187" endLine="1193">
      <scope startLine="1189" endLine="1191" />
    </method>
    <javadoc>
      <text>* Create a complex number given only the real part.</text>
      <param>realPart Real part.</param>
      <return>a Complex instance.</return>
    </javadoc>
    <method type="Complex" name="valueOf" startLine="1201" endLine="1206">
      <scope startLine="1202" endLine="1204" />
    </method>
    <javadoc>
      <text>* Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.</text>
      <return>A Complex instance with all fields resolved.</return>
      <since>2.0</since>
    </javadoc>
    <method type="Object" name="readResolve" startLine="1216" endLine="1218" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="ComplexField" name="getField" startLine="1221" endLine="1223" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="String" name="toString" startLine="1227" endLine="1229" />
    <comment>CHECKSTYLE: stop ConstantName</comment>
    <comment>CHECKSTYLE: resume ConstantName</comment>
  </class>
</source>
