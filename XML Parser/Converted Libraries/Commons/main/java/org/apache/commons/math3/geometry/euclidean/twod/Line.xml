<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.twod">
  <import name="java.awt.geom.AffineTransform" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <import name="org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D" />
  <import name="org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet" />
  <import name="org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint" />
  <import name="org.apache.commons.math3.geometry.euclidean.oned.Vector1D" />
  <import name="org.apache.commons.math3.geometry.partitioning.Embedding" />
  <import name="org.apache.commons.math3.geometry.partitioning.Hyperplane" />
  <import name="org.apache.commons.math3.geometry.partitioning.SubHyperplane" />
  <import name="org.apache.commons.math3.geometry.partitioning.Transform" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="Line" startLine="35">
    <implements name="Hyperplane<Euclidean2D>" />
    <implements name="Embedding<Euclidean2D,Euclidean1D>" />
    <javadoc>
      <text>* This class represents an oriented line in the 2D plane.
 * <p>An oriented line can be defined either by prolongating a line
 * segment between two points past these points, or by one point and
 * an angular direction (in trigonometric orientation).</p>
 * <p>Since it is oriented the two half planes at its two sides are
 * unambiguously identified as a left half plane and a right half
 * plane. This can be used to identify the interior and the exterior
 * in a simple way by local properties only when part of a line is
 * used to define part of a polygon boundary.</p>
 * <p>A line can also be used to completely define a reference frame
 * in the plane. It is sufficient to select one specific point in the
 * line (the orthogonal projection of the original reference frame on
 * the line) and to use the unit vector in the line direction and the
 * orthogonal vector oriented from left half plane to right half
 * plane. We define two coordinates by the process, the
 * <em>abscissa</em> along the line, and the <em>offset</em> across
 * the line. All points of the plane are uniquely identified by these
 * two coordinates. The line is the set of points at zero offset, the
 * left half plane is the set of points with negative offsets and the
 * right half plane is the set of points with positive offsets.</p></text>
      <version>$Id: Line.java 1422195 2012-12-15 06:45:18Z psteitz $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Angle with respect to the abscissa axis.</text>
    </javadoc>
    <declaration type="double" name="angle" />
    <javadoc>
      <text>* Cosine of the line angle.</text>
    </javadoc>
    <declaration type="double" name="cos" />
    <javadoc>
      <text>* Sine of the line angle.</text>
    </javadoc>
    <declaration type="double" name="sin" />
    <javadoc>
      <text>* Offset of the frame origin.</text>
    </javadoc>
    <declaration type="double" name="originOffset" />
    <javadoc>
      <text>* Build a line from two points.
 * <p>The line is oriented from p1 to p2</p></text>
      <param>p1 first point</param>
      <param>p2 second point</param>
    </javadoc>
    <method type="constructor" name="Line" startLine="81" endLine="83" />
    <javadoc>
      <text>* Build a line from a point and an angle.</text>
      <param>p point belonging to the line</param>
      <param>angle angle of the line with respect to abscissa axis</param>
    </javadoc>
    <method type="constructor" name="Line" startLine="89" endLine="91" />
    <javadoc>
      <text>* Build a line from its internal characteristics.</text>
      <param>angle angle of the line with respect to abscissa axis</param>
      <param>cos cosine of the angle</param>
      <param>sin sine of the angle</param>
      <param>originOffset offset of the origin</param>
    </javadoc>
    <method type="constructor" name="Line" startLine="99" endLine="104" />
    <javadoc>
      <text>* Copy constructor.
 * <p>The created instance is completely independent from the
 * original instance, it is a deep copy.</p></text>
      <param>line line to copy</param>
    </javadoc>
    <method type="constructor" name="Line" startLine="111" endLine="116" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Line" name="copySelf" startLine="119" endLine="121" />
    <javadoc>
      <text>* Reset the instance as if built from two points.
 * <p>The line is oriented from p1 to p2</p></text>
      <param>p1 first point</param>
      <param>p2 second point</param>
    </javadoc>
    <method type="void" name="reset" startLine="128" endLine="143">
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
      <declaration type="double" name="d" />
      <scope startLine="132" endLine="137" />
      <scope startLine="137" endLine="142" />
    </method>
    <javadoc>
      <text>* Reset the instance as if built from a line and an angle.</text>
      <param>p point belonging to the line</param>
      <param>alpha angle of the line with respect to abscissa axis</param>
    </javadoc>
    <method type="void" name="reset" startLine="149" endLine="154" />
    <javadoc>
      <text>* Revert the instance.</text>
    </javadoc>
    <method type="void" name="revertSelf" startLine="158" endLine="167">
      <scope startLine="159" endLine="161" />
      <scope startLine="161" endLine="163" />
    </method>
    <javadoc>
      <text>* Get the reverse of the instance.
 * <p>Get a line with reversed orientation with respect to the
 * instance. A new object is built, the instance is untouched.</p></text>
      <return>a new line, with orientation opposite to the instance orientation</return>
    </javadoc>
    <method type="Line" name="getReverse" startLine="174" endLine="177" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector1D" name="toSubSpace" startLine="180" endLine="183">
      <declaration type="Vector2D" name="p2" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector2D" name="toSpace" startLine="186" endLine="190">
      <declaration type="double" name="abscissa" />
    </method>
    <javadoc>
      <text>* Get the intersection point of the instance and another line.</text>
      <param>other other line</param>
      <return>intersection point of the instance and the other line
 * or null if there are no intersection points</return>
    </javadoc>
    <method type="Vector2D" name="intersection" startLine="197" endLine="204">
      <declaration type="double" name="d" />
      <scope startLine="199" endLine="201" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="SubLine" name="wholeHyperplane" startLine="207" endLine="209" />
    <javadoc>
      <text>* Build a region covering the whole space.</text>
      <return>a region containing the instance (really a {@link PolygonsSet PolygonsSet} instance)</return>
    </javadoc>
    <method type="PolygonsSet" name="wholeSpace" startLine="215" endLine="217" />
    <javadoc>
      <text>* Get the offset (oriented distance) of a parallel line.
 * <p>This method should be called only for parallel lines otherwise
 * the result is not meaningful.</p>
 * <p>The offset is 0 if both lines are the same, it is
 * positive if the line is on the right side of the instance and
 * negative if it is on the left side, according to its natural
 * orientation.</p></text>
      <param>line line to check</param>
      <return>offset of the line</return>
    </javadoc>
    <method type="double" name="getOffset" startLine="229" endLine="232" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getOffset" startLine="235" endLine="238">
      <declaration type="Vector2D" name="p2" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="sameOrientationAs" startLine="241" endLine="244">
      <declaration type="Line" name="otherL" />
    </method>
    <javadoc>
      <text>* Get one point from the plane.</text>
      <param>abscissa desired abscissa for the point</param>
      <param>offset desired offset for the point</param>
      <return>one point in the plane, with given abscissa and offset
 * relative to the line</return>
    </javadoc>
    <method type="Vector2D" name="getPointAt" startLine="252" endLine="256">
      <declaration type="double" name="x" />
      <declaration type="double" name="dOffset" />
    </method>
    <javadoc>
      <text>* Check if the line contains a point.</text>
      <param>p point to check</param>
      <return>true if p belongs to the line</return>
    </javadoc>
    <method type="boolean" name="contains" startLine="262" endLine="264" />
    <javadoc>
      <text>* Compute the distance between the instance and a point.
 * <p>This is a shortcut for invoking FastMath.abs(getOffset(p)),
 * and provides consistency with what is in the
 * org.apache.commons.math3.geometry.euclidean.threed.Line class.</p></text>
      <param>p to check</param>
      <return>distance between the instance and the point</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="distance" startLine="275" endLine="277" />
    <javadoc>
      <text>* Check the instance is parallel to another line.</text>
      <param>line other line to check</param>
      <return>true if the instance is parallel to the other line
 * (they can have either the same or opposite orientations)</return>
    </javadoc>
    <method type="boolean" name="isParallelTo" startLine="284" endLine="286" />
    <javadoc>
      <text>* Translate the line to force it passing by a point.</text>
      <param>p point by which the line should pass</param>
    </javadoc>
    <method type="void" name="translateToPoint" startLine="291" endLine="293" />
    <javadoc>
      <text>* Get the angle of the line.</text>
      <return>the angle of the line with respect to the abscissa axis</return>
    </javadoc>
    <method type="double" name="getAngle" startLine="298" endLine="300" />
    <javadoc>
      <text>* Set the angle of the line.</text>
      <param>angle new angle of the line with respect to the abscissa axis</param>
    </javadoc>
    <method type="void" name="setAngle" startLine="305" endLine="309" />
    <javadoc>
      <text>* Get the offset of the origin.</text>
      <return>the offset of the origin</return>
    </javadoc>
    <method type="double" name="getOriginOffset" startLine="314" endLine="316" />
    <javadoc>
      <text>* Set the offset of the origin.</text>
      <param>offset offset of the origin</param>
    </javadoc>
    <method type="void" name="setOriginOffset" startLine="321" endLine="323" />
    <javadoc>
      <text>* Get a {@link org.apache.commons.math3.geometry.partitioning.TransformTransform} embedding an affine transform.</text>
      <param>transform affine transform to embed (must be inversible
 * otherwise the {@link org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)apply(Hyperplane)} method would work only for some lines, and
 * fail for other ones)</param>
      <return>a new transform that can be applied to either {@link Vector2D Vector2D}, {@link Line Line} or {@link org.apache.commons.math3.geometry.partitioning.SubHyperplaneSubHyperplane} instances</return>
      <exception>MathIllegalArgumentException if the transform is non invertible</exception>
    </javadoc>
    <method type="Transform<Euclidean2D,Euclidean1D>" name="getTransform" startLine="339" endLine="341" />
    <class name="LineTransform" startLine="343">
      <implements name="Transform<Euclidean2D,Euclidean1D>" />
      <javadoc>
        <text>* Class embedding an affine transform.
 * <p>This class is used in order to apply an affine transform to a
 * line. Using a specific object allow to perform some computations
 * on the transform only once even if the same transform is to be
 * applied to a large number of lines (for example to a large
 * polygon)./<p></text>
      </javadoc>
      <declaration type="double" name="cXX" />
      <declaration type="double" name="cXY" />
      <declaration type="double" name="cX1" />
      <declaration type="double" name="cYX" />
      <declaration type="double" name="cYY" />
      <declaration type="double" name="cY1" />
      <declaration type="double" name="c1Y" />
      <declaration type="double" name="c1X" />
      <declaration type="double" name="c11" />
      <javadoc>
        <text>* Build an affine line transform from a n {@code AffineTransform}.</text>
        <param>transform transform to use (must be invertible otherwise
 * the {@link LineTransform#apply(Hyperplane)} method would work
 * only for some lines, and fail for other ones)</param>
        <exception>MathIllegalArgumentException if the transform is non invertible</exception>
      </javadoc>
      <method type="constructor" name="LineTransform" startLine="371" endLine="390">
        <declaration type="double[]" name="m" />
        <scope startLine="386" endLine="388" />
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Vector2D" name="apply" startLine="393" endLine="399">
        <declaration type="Vector2D" name="p2D" />
        <declaration type="double" name="x" />
        <declaration type="double" name="y" />
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Line" name="apply" startLine="402" endLine="411">
        <declaration type="Line" name="line" />
        <declaration type="double" name="rOffset" />
        <declaration type="double" name="rCos" />
        <declaration type="double" name="rSin" />
        <declaration type="double" name="inv" />
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="SubHyperplane<Euclidean1D>" name="apply" startLine="416" endLine="423">
        <declaration type="OrientedPoint" name="op" />
        <declaration type="Line" name="originalLine" />
        <declaration type="Line" name="transformedLine" />
        <declaration type="Vector1D" name="newLoc" />
      </method>
    </class>
    <comment>CHECKSTYLE: stop JavadocVariable check</comment>
    <comment>CHECKSTYLE: resume JavadocVariable check</comment>
  </class>
</source>
