<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.stat.clustering">
  <import name="java.util.ArrayList" />
  <import name="java.util.Collection" />
  <import name="java.util.Collections" />
  <import name="java.util.List" />
  <import name="java.util.Random" />
  <import name="org.apache.commons.math3.exception.ConvergenceException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.Variance" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="KMeansPlusPlusClusterer" startLine="33">
    <javadoc>
      <text>* Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.</text>
      <param><T>
 *  type of the points to cluster</param>
      <see><a href="http://en.wikipedia.org/wiki/K-means%2B%2B">K-means++ (wikipedia)</a></see>
      <version>$Id: KMeansPlusPlusClusterer.java 1461871 2013-03-27 22:01:25Z tn $</version>
      <since>2.0</since>
      <deprecated>As of 3.2 (to be removed in 4.0),
 * use {@link org.apache.commons.math3.ml.clustering.KMeansPlusPlusClusterer} instead</deprecated>
    </javadoc>
    <javadoc>
      <text>* Strategies to use for replacing an empty cluster.</text>
    </javadoc>
    <javadoc>
      <text>* Split the cluster with largest distance variance.</text>
    </javadoc>
    <javadoc>
      <text>* Split the cluster with largest number of points.</text>
    </javadoc>
    <javadoc>
      <text>* Create a cluster around the point farthest from its centroid.</text>
    </javadoc>
    <javadoc>
      <text>* Generate an error.</text>
    </javadoc>
    <javadoc>
      <text>* Random generator for choosing initial centers.</text>
    </javadoc>
    <declaration type="Random" name="random" />
    <javadoc>
      <text>* Selected strategy for empty clusters.</text>
    </javadoc>
    <declaration type="EmptyClusterStrategy" name="emptyStrategy" />
    <javadoc>
      <text>* Build a clusterer.
 * <p>
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.
 * </p></text>
      <param>random random generator to use for choosing initial centers</param>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="75" endLine="77" />
    <javadoc>
      <text>* Build a clusterer.</text>
      <param>random random generator to use for choosing initial centers</param>
      <param>emptyStrategy strategy to use for handling empty clusters that
 * may appear during algorithm iterations</param>
      <since>2.2</since>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="85" endLine="88" />
    <javadoc>
      <text>* Runs the K-means++ clustering algorithm.</text>
      <param>points the points to cluster</param>
      <param>k the number of clusters to split the data into</param>
      <param>numTrials number of trial runs</param>
      <param>maxIterationsPerTrial the maximum number of iterations to run the algorithm
 * for at each trial run.  If negative, no maximum will be used</param>
      <return>a list of clusters containing the points</return>
      <throws>MathIllegalArgumentException if the data points are null or the number
 * of clusters is larger than the number of data points</throws>
      <throws>ConvergenceException if an empty cluster is encountered and the{@link #emptyStrategy} is set to {@code ERROR}</throws>
    </javadoc>
    <method type="List<Cluster<T>>" name="cluster" startLine="106" endLine="145">
      <declaration type="List<Cluster<T>>" name="best" />
      <declaration type="double" name="bestVarianceSum" />
      <scope startLine="113" endLine="140">
        <declaration type="List<Cluster<T>>" name="clusters" />
        <declaration type="double" name="varianceSum" />
        <scope startLine="120" endLine="132">
          <scope startLine="121" endLine="131">
            <declaration type="T" name="center" />
            <declaration type="Variance" name="stat" />
            <scope startLine="126" endLine="128" />
          </scope>
        </scope>
        <scope startLine="134" endLine="138" />
        <comment>compute a clusters list</comment>
        <comment>compute the variance of the current list</comment>
        <comment>compute the distance variance of the current cluster</comment>
        <comment>this one is the best we have found so far, remember it</comment>
      </scope>
      <comment>at first, we have not found any clusters list yet</comment>
      <comment>do several clustering trials</comment>
      <comment>return the best clusters list found</comment>
    </method>
    <javadoc>
      <text>* Runs the K-means++ clustering algorithm.</text>
      <param>points the points to cluster</param>
      <param>k the number of clusters to split the data into</param>
      <param>maxIterations the maximum number of iterations to run the algorithm
 * for.  If negative, no maximum will be used</param>
      <return>a list of clusters containing the points</return>
      <throws>MathIllegalArgumentException if the data points are null or the number
 * of clusters is larger than the number of data points</throws>
      <throws>ConvergenceException if an empty cluster is encountered and the{@link #emptyStrategy} is set to {@code ERROR}</throws>
    </javadoc>
    <method type="List<Cluster<T>>" name="cluster" startLine="162" endLine="217">
      <scope startLine="168" endLine="170" />
      <declaration type="List<Cluster<T>>" name="clusters" />
      <declaration type="int[]" name="assignments" />
      <declaration type="int" name="max" />
      <scope startLine="182" endLine="215">
        <declaration type="boolean" name="emptyCluster" />
        <declaration type="List<Cluster<T>>" name="newClusters" />
        <scope startLine="185" endLine="206">
          <declaration type="T" name="newCenter" />
          <scope startLine="187" endLine="202" />
          <scope startLine="202" endLine="204" />
        </scope>
        <declaration type="int" name="changes" />
        <scope startLine="212" endLine="214" />
        <comment>if there were no more changes in the point-to-cluster assignment</comment>
        <comment>and there are no empty clusters left, return the current clusters</comment>
      </scope>
      <comment>sanity checks</comment>
      <comment>number of clusters has to be smaller or equal the number of data points</comment>
      <comment>create the initial clusters</comment>
      <comment>create an array containing the latest assignment of a point to a cluster</comment>
      <comment>no need to initialize the array, as it will be filled with the first assignment</comment>
      <comment>iterate through updating the centers until we're done</comment>
    </method>
    <javadoc>
      <text>* Adds the given points to the closest {@link Cluster}.</text>
      <param><T>
 *  type of the points to cluster</param>
      <param>clusters the {@link Cluster}s to add the points to</param>
      <param>points the points to add to the given {@link Cluster}s</param>
      <param>assignments points assignments to clusters</param>
      <return>the number of points assigned to different clusters as the iteration before</return>
    </javadoc>
    <method type="int" name="assignPointsToClusters" startLine="230" endLine="245">
      <declaration type="int" name="assignedDifferently" />
      <declaration type="int" name="pointIndex" />
      <scope startLine="233" endLine="242">
        <declaration type="int" name="clusterIndex" />
        <scope startLine="235" endLine="237" />
        <declaration type="Cluster<T>" name="cluster" />
      </scope>
    </method>
    <javadoc>
      <text>* Use K-means++ to choose the initial centers.</text>
      <param><T>
 *  type of the points to cluster</param>
      <param>points the points to choose the initial centers from</param>
      <param>k the number of centers to choose</param>
      <param>random random generator to use</param>
      <return>the initial centers</return>
    </javadoc>
    <method type="List<Cluster<T>>" name="chooseInitialCenters" startLine="257" endLine="374">
      <declaration type="List<T>" name="pointList" />
      <declaration type="int" name="numPoints" />
      <declaration type="boolean[]" name="taken" />
      <declaration type="List<Cluster<T>>" name="resultSet" />
      <declaration type="int" name="firstPointIndex" />
      <declaration type="T" name="firstPoint" />
      <declaration type="double[]" name="minDistSquared" />
      <scope startLine="289" endLine="294">
        <scope startLine="290" endLine="293">
          <declaration type="double" name="d" />
        </scope>
        <comment>That point isn't considered</comment>
      </scope>
      <scope startLine="296" endLine="371">
        <declaration type="double" name="distSqSum" />
        <scope startLine="302" endLine="306">
          <scope startLine="303" endLine="305" />
        </scope>
        <declaration type="double" name="r" />
        <declaration type="int" name="nextPointIndex" />
        <declaration type="double" name="sum" />
        <scope startLine="318" endLine="326">
          <scope startLine="319" endLine="325">
            <scope startLine="321" endLine="324" />
          </scope>
        </scope>
        <scope startLine="331" endLine="338">
          <scope startLine="332" endLine="337">
            <scope startLine="333" endLine="336" />
          </scope>
        </scope>
        <scope startLine="341" endLine="365">
          <declaration type="T" name="p" />
          <scope startLine="350" endLine="363">
            <scope startLine="353" endLine="362">
              <scope startLine="355" endLine="361">
                <declaration type="double" name="d" />
                <declaration type="double" name="d2" />
                <scope startLine="358" endLine="360" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope startLine="365" endLine="370" />
        <comment>Sum up the squared distances for the points in pointList not</comment>
        <comment>already taken.</comment>
        <comment>Add one new data point as a center. Each point x is chosen with</comment>
        <comment>probability proportional to D(x)2</comment>
        <comment>The index of the next point to be added to the resultSet.</comment>
        <comment>Sum through the squared min distances again, stopping when</comment>
        <comment>sum >= r.</comment>
        <comment>If it's not set to >= 0, the point wasn't found in the previous</comment>
        <comment>for loop, probably because distances are extremely small.  Just pick</comment>
        <comment>the last available point.</comment>
        <comment>We found one.</comment>
        <comment>Mark it as taken.</comment>
        <comment>Now update elements of minDistSquared.  We only have to compute</comment>
        <comment>the distance to the new center to do this.</comment>
        <comment>Only have to worry about the points still not taken.</comment>
        <comment>None found --</comment>
        <comment>Break from the while loop to prevent</comment>
        <comment>an infinite loop.</comment>
      </scope>
      <comment>Convert to list for indexed access. Make it unmodifiable, since removal of items</comment>
      <comment>would screw up the logic of this method.</comment>
      <comment>The number of points in the list.</comment>
      <comment>Set the corresponding element in this array to indicate when</comment>
      <comment>elements of pointList are no longer available.</comment>
      <comment>The resulting list of initial centers.</comment>
      <comment>Choose one center uniformly at random from among the data points.</comment>
      <comment>Must mark it as taken</comment>
      <comment>To keep track of the minimum distance squared of elements of</comment>
      <comment>pointList to elements of resultSet.</comment>
      <comment>Initialize the elements.  Since the only point in resultSet is firstPoint,</comment>
      <comment>this is very easy.</comment>
    </method>
    <javadoc>
      <text>* Get a random point from the {@link Cluster} with the largest distance variance.</text>
      <param>clusters the {@link Cluster}s to search</param>
      <return>a random point from the selected cluster</return>
      <throws>ConvergenceException if clusters are all empty</throws>
    </javadoc>
    <method type="T" name="getPointFromLargestVarianceCluster" startLine="384" endLine="417">
      <declaration type="double" name="maxVariance" />
      <declaration type="Cluster<T>" name="selected" />
      <scope startLine="388" endLine="406">
        <scope startLine="389" endLine="405">
          <declaration type="T" name="center" />
          <declaration type="Variance" name="stat" />
          <scope startLine="394" endLine="396" />
          <declaration type="double" name="variance" />
          <scope startLine="400" endLine="403" />
        </scope>
        <comment>compute the distance variance of the current cluster</comment>
        <comment>select the cluster with the largest variance</comment>
      </scope>
      <scope startLine="409" endLine="411" />
      <declaration type="List<T>" name="selectedPoints" />
      <comment>did we find at least one non-empty cluster ?</comment>
      <comment>extract a random point from the cluster</comment>
    </method>
    <javadoc>
      <text>* Get a random point from the {@link Cluster} with the largest number of points</text>
      <param>clusters the {@link Cluster}s to search</param>
      <return>a random point from the selected cluster</return>
      <throws>ConvergenceException if clusters are all empty</throws>
    </javadoc>
    <method type="T" name="getPointFromLargestNumberCluster" startLine="426" endLine="452">
      <declaration type="int" name="maxNumber" />
      <declaration type="Cluster<T>" name="selected" />
      <scope startLine="430" endLine="441">
        <declaration type="int" name="number" />
        <scope startLine="436" endLine="439" />
        <comment>get the number of points of the current cluster</comment>
        <comment>select the cluster with the largest number of points</comment>
      </scope>
      <scope startLine="444" endLine="446" />
      <declaration type="List<T>" name="selectedPoints" />
      <comment>did we find at least one non-empty cluster ?</comment>
      <comment>extract a random point from the cluster</comment>
    </method>
    <javadoc>
      <text>* Get the point farthest to its cluster center</text>
      <param>clusters the {@link Cluster}s to search</param>
      <return>point farthest to its cluster center</return>
      <throws>ConvergenceException if clusters are all empty</throws>
    </javadoc>
    <method type="T" name="getFarthestPoint" startLine="461" endLine="489">
      <declaration type="double" name="maxDistance" />
      <declaration type="Cluster<T>" name="selectedCluster" />
      <declaration type="int" name="selectedPoint" />
      <scope startLine="466" endLine="480">
        <declaration type="T" name="center" />
        <declaration type="List<T>" name="points" />
        <scope startLine="471" endLine="478">
          <declaration type="double" name="distance" />
          <scope startLine="473" endLine="477" />
        </scope>
        <comment>get the farthest point</comment>
      </scope>
      <scope startLine="483" endLine="485" />
      <comment>did we find at least one non-empty cluster ?</comment>
    </method>
    <javadoc>
      <text>* Returns the nearest {@link Cluster} to the given point</text>
      <param><T>
 *  type of the points to cluster</param>
      <param>clusters the {@link Cluster}s to search</param>
      <param>point the point to find the nearest {@link Cluster} for</param>
      <return>the index of the nearest {@link Cluster} to the given point</return>
    </javadoc>
    <method type="int" name="getNearestCluster" startLine="500" endLine="513">
      <declaration type="double" name="minDistance" />
      <declaration type="int" name="clusterIndex" />
      <declaration type="int" name="minCluster" />
      <scope startLine="504" endLine="511">
        <declaration type="double" name="distance" />
        <scope startLine="506" endLine="509" />
      </scope>
    </method>
  </class>
</source>
