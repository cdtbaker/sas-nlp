<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.events">
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.analysis.solvers.AllowedSolution" />
  <import name="org.apache.commons.math3.analysis.solvers.BracketedUnivariateSolver" />
  <import name="org.apache.commons.math3.analysis.solvers.PegasusSolver" />
  <import name="org.apache.commons.math3.analysis.solvers.UnivariateSolver" />
  <import name="org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.ode.sampling.StepInterpolator" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="EventState" startLine="31">
    <javadoc>
      <text>* This class handles the state for one {@link EventHandlerevent handler} during integration steps.
 * <p>Each time the integrator proposes a step, the event handler
 * switching function should be checked. This class handles the state
 * of one handler during one integration step, with references to the
 * state at the end of the preceding step. This information is used to
 * decide if the handler should trigger an event or not during the
 * proposed step.</p></text>
      <version>$Id: EventState.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Event handler.</text>
    </javadoc>
    <declaration type="EventHandler" name="handler" />
    <javadoc>
      <text>* Maximal time interval between events handler checks.</text>
    </javadoc>
    <declaration type="double" name="maxCheckInterval" />
    <javadoc>
      <text>* Convergence threshold for event localization.</text>
    </javadoc>
    <declaration type="double" name="convergence" />
    <javadoc>
      <text>* Upper limit in the iteration count for event localization.</text>
    </javadoc>
    <declaration type="int" name="maxIterationCount" />
    <javadoc>
      <text>* Time at the beginning of the step.</text>
    </javadoc>
    <declaration type="double" name="t0" />
    <javadoc>
      <text>* Value of the events handler at the beginning of the step.</text>
    </javadoc>
    <declaration type="double" name="g0" />
    <javadoc>
      <text>* Simulated sign of g0 (we cheat when crossing events).</text>
    </javadoc>
    <declaration type="boolean" name="g0Positive" />
    <javadoc>
      <text>* Indicator of event expected during the step.</text>
    </javadoc>
    <declaration type="boolean" name="pendingEvent" />
    <javadoc>
      <text>* Occurrence time of the pending event.</text>
    </javadoc>
    <declaration type="double" name="pendingEventTime" />
    <javadoc>
      <text>* Occurrence time of the previous event.</text>
    </javadoc>
    <declaration type="double" name="previousEventTime" />
    <javadoc>
      <text>* Integration direction.</text>
    </javadoc>
    <declaration type="boolean" name="forward" />
    <javadoc>
      <text>* Variation direction around pending event.
 * (this is considered with respect to the integration direction)</text>
    </javadoc>
    <declaration type="boolean" name="increasing" />
    <javadoc>
      <text>* Next action indicator.</text>
    </javadoc>
    <declaration type="EventHandler.Action" name="nextAction" />
    <javadoc>
      <text>* Root-finding algorithm to use to detect state events.</text>
    </javadoc>
    <declaration type="UnivariateSolver" name="solver" />
    <javadoc>
      <text>* Simple constructor.</text>
      <param>handler event handler</param>
      <param>maxCheckInterval maximal time interval between switching
 * function checks (this interval prevents missing sign changes in
 * case the integration steps becomes very large)</param>
      <param>convergence convergence threshold in the event time search</param>
      <param>maxIterationCount upper limit of the iteration count in
 * the event time search</param>
      <param>solver Root-finding algorithm to use to detect state events</param>
    </javadoc>
    <method type="constructor" name="EventState" startLine="102" endLine="119">
      <comment>some dummy values ...</comment>
    </method>
    <javadoc>
      <text>* Get the underlying event handler.</text>
      <return>underlying event handler</return>
    </javadoc>
    <method type="EventHandler" name="getEventHandler" startLine="124" endLine="126" />
    <javadoc>
      <text>* Get the maximal time interval between events handler checks.</text>
      <return>maximal time interval between events handler checks</return>
    </javadoc>
    <method type="double" name="getMaxCheckInterval" startLine="131" endLine="133" />
    <javadoc>
      <text>* Get the convergence threshold for event localization.</text>
      <return>convergence threshold for event localization</return>
    </javadoc>
    <method type="double" name="getConvergence" startLine="138" endLine="140" />
    <javadoc>
      <text>* Get the upper limit in the iteration count for event localization.</text>
      <return>upper limit in the iteration count for event localization</return>
    </javadoc>
    <method type="int" name="getMaxIterationCount" startLine="145" endLine="147" />
    <javadoc>
      <text>* Reinitialize the beginning of the step.</text>
      <param>interpolator valid for the current step</param>
      <exception>MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method type="void" name="reinitializeBegin" startLine="155" endLine="182">
      <scope startLine="160" endLine="179">
        <declaration type="double" name="epsilon" />
        <declaration type="double" name="tStart" />
        <comment>excerpt from MATH-421 issue:</comment>
        <comment>If an ODE solver is setup with an EventHandler that return STOP</comment>
        <comment>when the even is triggered, the integrator stops (which is exactly</comment>
        <comment>the expected behavior). If however the user wants to restart the</comment>
        <comment>solver from the final state reached at the event with the same</comment>
        <comment>configuration (expecting the event to be triggered again at a</comment>
        <comment>later time), then the integrator may fail to start. It can get stuck</comment>
        <comment>at the previous event. The use case for the bug MATH-421 is fairly</comment>
        <comment>general, so events occurring exactly at start in the first step should</comment>
        <comment>be ignored.</comment>
        <comment>extremely rare case: there is a zero EXACTLY at interval start</comment>
        <comment>we will use the sign slightly after step beginning to force ignoring this zero</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Evaluate the impact of the proposed step on the event handler.</text>
      <param>interpolator step interpolator for the proposed step</param>
      <return>true if the event handler triggers an event before
 * the end of the proposed step</return>
      <exception>MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded</exception>
      <exception>NoBracketingException if the event cannot be bracketed</exception>
    </javadoc>
    <method type="boolean" name="evaluateStep" startLine="193" endLine="292">
      <scope startLine="195" endLine="288">
        <declaration type="double" name="t1" />
        <declaration type="double" name="dt" />
        <scope startLine="199" endLine="202" />
        <declaration type="int" name="n" />
        <declaration type="double" name="h" />
        <declaration type="UnivariateFunction" name="f" />
        <method type="double" name="value" startLine="207" endLine="214">
          <scope startLine="208" endLine="211" />
          <scope startLine="211" endLine="213" />
        </method>
        <declaration type="double" name="ta" />
        <declaration type="double" name="ga" />
        <scope startLine="219" endLine="281">
          <declaration type="double" name="tb" />
          <declaration type="double" name="gb" />
          <scope startLine="227" endLine="275">
            <declaration type="double" name="root" />
            <scope startLine="235" endLine="242">
              <declaration type="BracketedUnivariateSolver<UnivariateFunction>" name="bracketing" />
            </scope>
            <scope startLine="242" endLine="254">
              <declaration type="double" name="baseRoot" />
              <declaration type="int" name="remainingEval" />
              <declaration type="BracketedUnivariateSolver<UnivariateFunction>" name="bracketing" />
            </scope>
            <scope startLine="258" endLine="264" />
            <scope startLine="265" endLine="269" />
            <scope startLine="269" endLine="273" />
          </scope>
          <scope startLine="275" endLine="279" />
        </scope>
        <comment>we cannot do anything on such a small step, don't trigger any events</comment>
        <comment>evaluate handler value at the end of the substep</comment>
        <comment>check events occurrence</comment>
        <comment>there is a sign change: an event is expected during this step</comment>
        <comment>variation direction, with respect to the integration direction</comment>
        <comment>find the event time making sure we select a solution just at or past the exact root</comment>
        <comment>we have either found nothing or found (again ?) a past event,</comment>
        <comment>retry the substep excluding this value</comment>
        <comment>no sign change: there is no event for now</comment>
        <comment>no sign change: there is no event for now</comment>
        <comment>no event during the whole step</comment>
      </scope>
      <scope startLine="288" endLine="290" />
    </method>
    <javadoc>
      <text>* Get the occurrence time of the event triggered in the current step.</text>
      <return>occurrence time of the event triggered in the current
 * step or infinity if no events are triggered</return>
    </javadoc>
    <method type="double" name="getEventTime" startLine="298" endLine="302" />
    <javadoc>
      <text>* Acknowledge the fact the step has been accepted by the integrator.</text>
      <param>t value of the independent <i>time</i> variable at the
 * end of the step</param>
      <param>y array containing the current value of the state vector
 * at the end of the step</param>
    </javadoc>
    <method type="void" name="stepAccepted" startLine="310" endLine="324">
      <scope startLine="315" endLine="320">
        <comment>force the sign to its value "just after the event"</comment>
      </scope>
      <scope startLine="320" endLine="323" />
    </method>
    <javadoc>
      <text>* Check if the integration should be stopped at the end of the
 * current step.</text>
      <return>true if the integration should be stopped</return>
    </javadoc>
    <method type="boolean" name="stop" startLine="330" endLine="332" />
    <javadoc>
      <text>* Let the event handler reset the state if it wants.</text>
      <param>t value of the independent <i>time</i> variable at the
 * beginning of the next step</param>
      <param>y array were to put the desired state vector at the beginning
 * of the next step</param>
      <return>true if the integrator should reset the derivatives too</return>
    </javadoc>
    <method type="boolean" name="reset" startLine="341" endLine="356">
      <scope startLine="343" endLine="345" />
      <scope startLine="347" endLine="349" />
    </method>
    <class name="LocalMaxCountExceededException" extends="RuntimeException" startLine="358">
      <javadoc>
        <text>* Local wrapper to propagate exceptions.</text>
      </javadoc>
      <javadoc>
        <text>* Serializable UID.</text>
      </javadoc>
      <declaration type="long" name="serialVersionUID" />
      <javadoc>
        <text>* Wrapped exception.</text>
      </javadoc>
      <declaration type="MaxCountExceededException" name="wrapped" />
      <javadoc>
        <text>* Simple constructor.</text>
        <param>exception exception to wrap</param>
      </javadoc>
      <method type="constructor" name="LocalMaxCountExceededException" startLine="370" endLine="372" />
      <javadoc>
        <text>* Get the wrapped exception.</text>
        <return>wrapped exception</return>
      </javadoc>
      <method type="MaxCountExceededException" name="getException" startLine="377" endLine="379" />
    </class>
  </class>
</source>
