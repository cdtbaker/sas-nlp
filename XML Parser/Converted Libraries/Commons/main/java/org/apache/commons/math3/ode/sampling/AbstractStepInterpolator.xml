<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.sampling">
  <import name="java.io.IOException" />
  <import name="java.io.ObjectInput" />
  <import name="java.io.ObjectOutput" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.ode.EquationsMapper" />
  <class name="AbstractStepInterpolator" startLine="27">
    <implements name="StepInterpolator" />
    <javadoc>
      <text>* This abstract class represents an interpolator over the last step
 * during an ODE integration.
 * <p>The various ODE integrators provide objects extending this class
 * to the step handlers. The handlers can use these objects to
 * retrieve the state vector at intermediate times between the
 * previous and the current grid points (dense output).</p></text>
      <see>org.apache.commons.math3.ode.FirstOrderIntegrator</see>
      <see>org.apache.commons.math3.ode.SecondOrderIntegrator</see>
      <see>StepHandler</see>
      <version>$Id: AbstractStepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* current time step</text>
    </javadoc>
    <declaration type="double" name="h" />
    <javadoc>
      <text>* current state</text>
    </javadoc>
    <declaration type="double[]" name="currentState" />
    <javadoc>
      <text>* interpolated time</text>
    </javadoc>
    <declaration type="double" name="interpolatedTime" />
    <javadoc>
      <text>* interpolated state</text>
    </javadoc>
    <declaration type="double[]" name="interpolatedState" />
    <javadoc>
      <text>* interpolated derivatives</text>
    </javadoc>
    <declaration type="double[]" name="interpolatedDerivatives" />
    <javadoc>
      <text>* interpolated primary state</text>
    </javadoc>
    <declaration type="double[]" name="interpolatedPrimaryState" />
    <javadoc>
      <text>* interpolated primary derivatives</text>
    </javadoc>
    <declaration type="double[]" name="interpolatedPrimaryDerivatives" />
    <javadoc>
      <text>* interpolated secondary state</text>
    </javadoc>
    <declaration type="double[][]" name="interpolatedSecondaryState" />
    <javadoc>
      <text>* interpolated secondary derivatives</text>
    </javadoc>
    <declaration type="double[][]" name="interpolatedSecondaryDerivatives" />
    <javadoc>
      <text>* global previous time</text>
    </javadoc>
    <declaration type="double" name="globalPreviousTime" />
    <javadoc>
      <text>* global current time</text>
    </javadoc>
    <declaration type="double" name="globalCurrentTime" />
    <javadoc>
      <text>* soft previous time</text>
    </javadoc>
    <declaration type="double" name="softPreviousTime" />
    <javadoc>
      <text>* soft current time</text>
    </javadoc>
    <declaration type="double" name="softCurrentTime" />
    <javadoc>
      <text>* indicate if the step has been finalized or not.</text>
    </javadoc>
    <declaration type="boolean" name="finalized" />
    <javadoc>
      <text>* integration direction.</text>
    </javadoc>
    <declaration type="boolean" name="forward" />
    <javadoc>
      <text>* indicator for dirty state.</text>
    </javadoc>
    <declaration type="boolean" name="dirtyState" />
    <javadoc>
      <text>* Equations mapper for the primary equations set.</text>
    </javadoc>
    <declaration type="EquationsMapper" name="primaryMapper" />
    <javadoc>
      <text>* Equations mappers for the secondary equations sets.</text>
    </javadoc>
    <declaration type="EquationsMapper[]" name="secondaryMappers" />
    <javadoc>
      <text>* Simple constructor.
 * This constructor builds an instance that is not usable yet, the{@link #reinitialize} method should be called before using the
 * instance in order to initialize the internal arrays. This
 * constructor is used only in order to delay the initialization in
 * some cases. As an example, the {@link org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator}class uses the prototyping design pattern to create the step
 * interpolators by cloning an uninitialized model and latter
 * initializing the copy.</text>
    </javadoc>
    <method type="constructor" name="AbstractStepInterpolator" startLine="112" endLine="126" />
    <javadoc>
      <text>* Simple constructor.</text>
      <param>y reference to the integrator array holding the state at
 * the end of the step</param>
      <param>forward integration direction indicator</param>
      <param>primaryMapper equations mapper for the primary equations set</param>
      <param>secondaryMappers equations mappers for the secondary equations sets</param>
    </javadoc>
    <method type="constructor" name="AbstractStepInterpolator" startLine="137" endLine="153" />
    <javadoc>
      <text>* Copy constructor.
 * <p>The copied interpolator should have been finalized before the
 * copy, otherwise the copy will not be able to perform correctly
 * any derivative computation and will throw a {@link NullPointerException} later. Since we don't want this constructor
 * to throw the exceptions finalization may involve and since we
 * don't want this method to modify the state of the copied
 * interpolator, finalization is <strong>not</strong> done
 * automatically, it remains under user control.</p>
 * <p>The copy is a deep copy: its arrays are separated from the
 * original arrays of the instance.</p></text>
      <param>interpolator interpolator to copy from.</param>
    </javadoc>
    <method type="constructor" name="AbstractStepInterpolator" startLine="172" endLine="207">
      <scope startLine="181" endLine="186" />
      <scope startLine="186" endLine="198">
        <scope startLine="194" endLine="197" />
      </scope>
    </method>
    <javadoc>
      <text>* Allocate the various interpolated states arrays.</text>
      <param>dimension total dimension (negative if arrays should be set to null)</param>
    </javadoc>
    <method type="void" name="allocateInterpolatedArrays" startLine="212" endLine="237">
      <scope startLine="213" endLine="220" />
      <scope startLine="220" endLine="236">
        <scope startLine="225" endLine="228" />
        <scope startLine="228" endLine="235">
          <scope startLine="231" endLine="234" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Reinitialize the instance</text>
      <param>y reference to the integrator array holding the state at the end of the step</param>
      <param>isForward integration direction indicator</param>
      <param>primary equations mapper for the primary equations set</param>
      <param>secondary equations mappers for the secondary equations sets</param>
    </javadoc>
    <method type="void" name="reinitialize" startLine="247" endLine="263" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="StepInterpolator" name="copy" startLine="266" endLine="274">
      <comment>finalize the step before performing copy</comment>
      <comment>create the new independent instance</comment>
    </method>
    <method name="doCopy" type="StepInterpolator" startLine="276" endLine="283" />
    <javadoc>
      <text>* Really copy the finalized instance.
 * <p>This method is called by {@link #copy()} after the
 * step has been finalized. It must perform a deep copy
 * to have an new instance completely independent for the
 * original instance.</text>
      <return>a copy of the finalized instance</return>
    </javadoc>
    <javadoc>
      <text>* Shift one step forward.
 * Copy the current time into the previous time, hence preparing the
 * interpolator for future calls to {@link #storeTime storeTime}</text>
    </javadoc>
    <method type="void" name="shift" startLine="289" endLine="293" />
    <javadoc>
      <text>* Store the current step time.</text>
      <param>t current time</param>
    </javadoc>
    <method type="void" name="storeTime" startLine="298" endLine="308">
      <comment>the step is not finalized anymore</comment>
    </method>
    <javadoc>
      <text>* Restrict step range to a limited part of the global step.
 * <p>
 * This method can be used to restrict a step and make it appear
 * as if the original step was smaller. Calling this method
 * <em>only</em> changes the value returned by {@link #getPreviousTime()},
 * it does not change any other property
 * </p></text>
      <param>softPreviousTime start of the restricted step</param>
      <since>2.2</since>
    </javadoc>
    <method type="void" name="setSoftPreviousTime" startLine="320" endLine="322" />
    <javadoc>
      <text>* Restrict step range to a limited part of the global step.
 * <p>
 * This method can be used to restrict a step and make it appear
 * as if the original step was smaller. Calling this method
 * <em>only</em> changes the value returned by {@link #getCurrentTime()},
 * it does not change any other property
 * </p></text>
      <param>softCurrentTime end of the restricted step</param>
      <since>2.2</since>
    </javadoc>
    <method type="void" name="setSoftCurrentTime" startLine="334" endLine="336" />
    <javadoc>
      <text>* Get the previous global grid point time.</text>
      <return>previous global grid point time</return>
    </javadoc>
    <method type="double" name="getGlobalPreviousTime" startLine="342" endLine="344" />
    <javadoc>
      <text>* Get the current global grid point time.</text>
      <return>current global grid point time</return>
    </javadoc>
    <method type="double" name="getGlobalCurrentTime" startLine="350" endLine="352" />
    <javadoc>
      <text>* Get the previous soft grid point time.</text>
      <return>previous soft grid point time</return>
      <see>#setSoftPreviousTime(double)</see>
    </javadoc>
    <method type="double" name="getPreviousTime" startLine="359" endLine="361" />
    <javadoc>
      <text>* Get the current soft grid point time.</text>
      <return>current soft grid point time</return>
      <see>#setSoftCurrentTime(double)</see>
    </javadoc>
    <method type="double" name="getCurrentTime" startLine="368" endLine="370" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getInterpolatedTime" startLine="373" endLine="375" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="setInterpolatedTime" startLine="378" endLine="381" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isForward" startLine="384" endLine="386" />
    <method name="computeInterpolatedStateAndDerivatives" type="void" startLine="388" endLine="399" />
    <javadoc>
      <text>* Compute the state and derivatives at the interpolated time.
 * This is the main processing method that should be implemented by
 * the derived classes to perform the interpolation.</text>
      <param>theta normalized interpolation abscissa within the step
 * (theta is zero at the previous time step and one at the current time step)</param>
      <param>oneMinusThetaH time gap between the interpolated time and
 * the current time</param>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <javadoc>
      <text>* Lazy evaluation of complete interpolated state.</text>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method type="void" name="evaluateCompleteInterpolatedState" startLine="405" endLine="413">
      <scope startLine="407" endLine="412">
        <declaration type="double" name="oneMinusThetaH" />
        <declaration type="double" name="theta" />
      </scope>
      <comment>lazy evaluation of the state</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double[]" name="getInterpolatedState" startLine="416" endLine="421" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double[]" name="getInterpolatedDerivatives" startLine="424" endLine="429" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double[]" name="getInterpolatedSecondaryState" startLine="432" endLine="437" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double[]" name="getInterpolatedSecondaryDerivatives" startLine="440" endLine="445" />
    <javadoc>
      <text>* Finalize the step.
 * <p>Some embedded Runge-Kutta integrators need fewer functions
 * evaluations than their counterpart step interpolators. These
 * interpolators should perform the last evaluations they need by
 * themselves only if they need them. This method triggers these
 * extra evaluations. It can be called directly by the user step
 * handler and it is called automatically if {@link #setInterpolatedTime} is called.</p>
 * <p>Once this method has been called, <strong>no</strong> other
 * evaluation will be performed on this step. If there is a need to
 * have some side effects between the step handler and the
 * differential equations (for example update some data in the
 * equations once the step has been done), it is advised to call
 * this method explicitly from the step handler before these side
 * effects are set up. If the step handler induces no side effect,
 * then this method can safely be ignored, it will be called
 * transparently as needed.</p>
 * <p><strong>Warning</strong>: since the step interpolator provided
 * to the step handler as a parameter of the {@link StepHandler#handleStep handleStep} is valid only for the duration
 * of the {@link StepHandler#handleStep handleStep} call, one cannot
 * simply store a reference and reuse it later. One should first
 * finalize the instance, then copy this finalized instance into a
 * new object that can be kept.</p>
 * <p>This method calls the protected <code>doFinalize</code> method
 * if it has never been called during this step and set a flag
 * indicating that it has been called once. It is the <code>
 * doFinalize</code> method which should perform the evaluations.
 * This wrapping prevents from calling <code>doFinalize</code> several
 * times and hence evaluating the differential equations too often.
 * Therefore, subclasses are not allowed not reimplement it, they
 * should rather reimplement <code>doFinalize</code>.</p></text>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method type="void" name="finalizeStep" startLine="488" endLine="493">
      <scope startLine="489" endLine="492" />
    </method>
    <javadoc>
      <text>* Really finalize the step.
 * The default implementation of this method does nothing.</text>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method type="void" name="doFinalize" startLine="500" endLine="501" />
    <method name="writeExternal" type="void" startLine="503" endLine="505" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method name="readExternal" type="void" startLine="507" endLine="509" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <javadoc>
      <text>* Save the base state of the instance.
 * This method performs step finalization if it has not been done
 * before.</text>
      <param>out stream where to save the state</param>
      <exception>IOException in case of write error</exception>
    </javadoc>
    <method type="void" name="writeBaseExternal" startLine="518" endLine="557">
      <scope startLine="520" endLine="522" />
      <scope startLine="522" endLine="524" />
      <scope startLine="533" endLine="535" />
      <scope startLine="537" endLine="541">
        <scope startLine="538" endLine="540" />
      </scope>
      <scope startLine="548" endLine="551">
        <comment>finalize the step (and don't bother saving the now true flag)</comment>
      </scope>
      <scope startLine="551" endLine="555">
        <declaration type="IOException" name="ioe" />
      </scope>
      <comment>we do not store the interpolated state,</comment>
      <comment>it will be recomputed as needed after reading</comment>
    </method>
    <javadoc>
      <text>* Read the base state of the instance.
 * This method does <strong>neither</strong> set the interpolated
 * time nor state. It is up to the derived class to reset it
 * properly calling the {@link #setInterpolatedTime} method later,
 * once all rest of the object state has been set up properly.</text>
      <param>in stream where to read the state from</param>
      <return>interpolated time to be set later by the caller</return>
      <exception>IOException in case of read error</exception>
      <exception>ClassNotFoundException if an equation mapper class
 * cannot be found</exception>
    </javadoc>
    <method type="double" name="readBaseExternal" startLine="571" endLine="604">
      <declaration type="int" name="dimension" />
      <scope startLine="582" endLine="584" />
      <scope startLine="587" endLine="589" />
      <scope startLine="589" endLine="594">
        <scope startLine="591" endLine="593" />
      </scope>
      <comment>we do NOT handle the interpolated time and state here</comment>
    </method>
  </class>
</source>
