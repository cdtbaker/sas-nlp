<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.io.IOException" />
  <import name="java.io.ObjectInputStream" />
  <import name="java.io.Serializable" />
  <import name="java.lang.reflect.Array" />
  <import name="java.util.ConcurrentModificationException" />
  <import name="java.util.NoSuchElementException" />
  <import name="org.apache.commons.math3.Field" />
  <import name="org.apache.commons.math3.FieldElement" />
  <class name="OpenIntToFieldHashMap" startLine="29">
    <implements name="Serializable" />
    <javadoc>
      <text>* Open addressed map from int to FieldElement.
 * <p>This class provides a dedicated map from integers to FieldElements with a
 * much smaller memory overhead than standard <code>java.util.Map</code>.</p>
 * <p>This class is not synchronized. The specialized iterators returned by{@link #iterator()} are fail-fast: they throw a
 * <code>ConcurrentModificationException</code> when they detect the map has been
 * modified during iteration.</p></text>
      <param><T>
 *  the type of the field elements</param>
      <version>$Id: OpenIntToFieldHashMap.java 1421448 2012-12-13 19:45:57Z tn $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Status indicator for free table entries.</text>
    </javadoc>
    <declaration type="byte" name="FREE" />
    <javadoc>
      <text>* Status indicator for full table entries.</text>
    </javadoc>
    <declaration type="byte" name="FULL" />
    <javadoc>
      <text>* Status indicator for removed table entries.</text>
    </javadoc>
    <declaration type="byte" name="REMOVED" />
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Load factor for the map.</text>
    </javadoc>
    <declaration type="float" name="LOAD_FACTOR" />
    <javadoc>
      <text>* Default starting size.
 * <p>This must be a power of two for bit mask to work properly. </p></text>
    </javadoc>
    <declaration type="int" name="DEFAULT_EXPECTED_SIZE" />
    <javadoc>
      <text>* Multiplier for size growth when map fills up.
 * <p>This must be a power of two for bit mask to work properly. </p></text>
    </javadoc>
    <declaration type="int" name="RESIZE_MULTIPLIER" />
    <javadoc>
      <text>* Number of bits to perturb the index when probing for collision resolution.</text>
    </javadoc>
    <declaration type="int" name="PERTURB_SHIFT" />
    <javadoc>
      <text>* Field to which the elements belong.</text>
    </javadoc>
    <declaration type="Field<T>" name="field" />
    <javadoc>
      <text>* Keys table.</text>
    </javadoc>
    <declaration type="int[]" name="keys" />
    <javadoc>
      <text>* Values table.</text>
    </javadoc>
    <declaration type="T[]" name="values" />
    <javadoc>
      <text>* States table.</text>
    </javadoc>
    <declaration type="byte[]" name="states" />
    <javadoc>
      <text>* Return value for missing entries.</text>
    </javadoc>
    <declaration type="T" name="missingEntries" />
    <javadoc>
      <text>* Current size of the map.</text>
    </javadoc>
    <declaration type="int" name="size" />
    <javadoc>
      <text>* Bit mask for hash values.</text>
    </javadoc>
    <declaration type="int" name="mask" />
    <javadoc>
      <text>* Modifications count.</text>
    </javadoc>
    <declaration type="int" name="count" />
    <javadoc>
      <text>* Build an empty map with default size and using zero for missing entries.</text>
      <param>field field to which the elements belong</param>
    </javadoc>
    <method type="constructor" name="OpenIntToFieldHashMap" startLine="99" endLine="101" />
    <javadoc>
      <text>* Build an empty map with default size</text>
      <param>field field to which the elements belong</param>
      <param>missingEntries value to return when a missing entry is fetched</param>
    </javadoc>
    <method type="constructor" name="OpenIntToFieldHashMap" startLine="108" endLine="110" />
    <javadoc>
      <text>* Build an empty map with specified size and using zero for missing entries.</text>
      <param>field field to which the elements belong</param>
      <param>expectedSize expected number of elements in the map</param>
    </javadoc>
    <method type="constructor" name="OpenIntToFieldHashMap" startLine="117" endLine="119" />
    <javadoc>
      <text>* Build an empty map with specified size.</text>
      <param>field field to which the elements belong</param>
      <param>expectedSize expected number of elements in the map</param>
      <param>missingEntries value to return when a missing entry is fetched</param>
    </javadoc>
    <method type="constructor" name="OpenIntToFieldHashMap" startLine="128" endLine="136">
      <declaration type="int" name="capacity" />
    </method>
    <javadoc>
      <text>* Copy constructor.</text>
      <param>source map to copy</param>
    </javadoc>
    <method type="constructor" name="OpenIntToFieldHashMap" startLine="142" endLine="155">
      <declaration type="int" name="length" />
    </method>
    <javadoc>
      <text>* Compute the capacity needed for a given size.</text>
      <param>expectedSize expected size of the map</param>
      <return>capacity to use for the specified size</return>
    </javadoc>
    <method type="int" name="computeCapacity" startLine="162" endLine="172">
      <scope startLine="163" endLine="165" />
      <declaration type="int" name="capacity" />
      <declaration type="int" name="powerOfTwo" />
      <scope startLine="168" endLine="170" />
    </method>
    <javadoc>
      <text>* Find the smallest power of two greater than the input value</text>
      <param>i input value</param>
      <return>smallest power of two greater than the input value</return>
    </javadoc>
    <method type="int" name="nextPowerOfTwo" startLine="179" endLine="181" />
    <javadoc>
      <text>* Get the stored value associated with the given key</text>
      <param>key key associated with the data</param>
      <return>data associated with the key</return>
    </javadoc>
    <method type="T" name="get" startLine="188" endLine="211">
      <declaration type="int" name="hash" />
      <declaration type="int" name="index" />
      <scope startLine="192" endLine="194" />
      <scope startLine="196" endLine="198" />
      <declaration type="int" name="j" />
      <scope startLine="201" endLine="207">
        <scope startLine="204" endLine="206" />
      </scope>
    </method>
    <javadoc>
      <text>* Check if a value is associated with a key.</text>
      <param>key key to check</param>
      <return>true if a value is associated with key</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="218" endLine="241">
      <declaration type="int" name="hash" />
      <declaration type="int" name="index" />
      <scope startLine="222" endLine="224" />
      <scope startLine="226" endLine="228" />
      <declaration type="int" name="j" />
      <scope startLine="231" endLine="237">
        <scope startLine="234" endLine="236" />
      </scope>
    </method>
    <javadoc>
      <text>* Get an iterator over map elements.
 * <p>The specialized iterators returned are fail-fast: they throw a
 * <code>ConcurrentModificationException</code> when they detect the map
 * has been modified during iteration.</p></text>
      <return>iterator over the map elements</return>
    </javadoc>
    <method type="Iterator" name="iterator" startLine="250" endLine="252" />
    <javadoc>
      <text>* Perturb the hash for starting probing.</text>
      <param>hash initial hash</param>
      <return>perturbed hash</return>
    </javadoc>
    <method type="int" name="perturb" startLine="259" endLine="261" />
    <javadoc>
      <text>* Find the index at which a key should be inserted</text>
      <param>key key to lookup</param>
      <return>index at which key should be inserted</return>
    </javadoc>
    <method type="int" name="findInsertionIndex" startLine="268" endLine="270" />
    <javadoc>
      <text>* Find the index at which a key should be inserted</text>
      <param>keys keys table</param>
      <param>states states table</param>
      <param>key key to lookup</param>
      <param>mask bit mask for hash values</param>
      <return>index at which key should be inserted</return>
    </javadoc>
    <method type="int" name="findInsertionIndex" startLine="281" endLine="327">
      <declaration type="int" name="hash" />
      <declaration type="int" name="index" />
      <scope startLine="284" endLine="286" />
      <scope startLine="286" endLine="288" />
      <declaration type="int" name="perturb" />
      <declaration type="int" name="j" />
      <scope startLine="292" endLine="302">
        <scope startLine="293" endLine="301">
          <scope startLine="298" endLine="300" />
        </scope>
      </scope>
      <scope startLine="304" endLine="306" />
      <scope startLine="306" endLine="310">
        <comment>due to the loop exit condition,</comment>
        <comment>if (states[index] == FULL) then keys[index] == key</comment>
      </scope>
      <declaration type="int" name="firstRemoved" />
      <scope startLine="313" endLine="325">
        <scope startLine="317" endLine="319" />
        <scope startLine="319" endLine="321" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute next probe for collision resolution</text>
      <param>perturb perturbed hash</param>
      <param>j previous probe</param>
      <return>next probe</return>
    </javadoc>
    <method type="int" name="probe" startLine="335" endLine="337" />
    <javadoc>
      <text>* Change the index sign</text>
      <param>index initial index</param>
      <return>changed index</return>
    </javadoc>
    <method type="int" name="changeIndexSign" startLine="344" endLine="346" />
    <javadoc>
      <text>* Get the number of elements stored in the map.</text>
      <return>number of elements stored in the map</return>
    </javadoc>
    <method type="int" name="size" startLine="352" endLine="354" />
    <javadoc>
      <text>* Remove the value associated with a key.</text>
      <param>key key to which the value is associated</param>
      <return>removed value</return>
    </javadoc>
    <method type="T" name="remove" startLine="362" endLine="385">
      <declaration type="int" name="hash" />
      <declaration type="int" name="index" />
      <scope startLine="366" endLine="368" />
      <scope startLine="370" endLine="372" />
      <declaration type="int" name="j" />
      <scope startLine="375" endLine="381">
        <scope startLine="378" endLine="380" />
      </scope>
    </method>
    <javadoc>
      <text>* Check if the tables contain an element associated with specified key
 * at specified index.</text>
      <param>key key to check</param>
      <param>index index to check</param>
      <return>true if an element is associated with key at index</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="394" endLine="396" />
    <javadoc>
      <text>* Remove an element at specified index.</text>
      <param>index index of the element to remove</param>
      <return>removed value</return>
    </javadoc>
    <method type="T" name="doRemove" startLine="403" endLine="411">
      <declaration type="T" name="previous" />
    </method>
    <javadoc>
      <text>* Put a value associated with a key in the map.</text>
      <param>key key to which value is associated</param>
      <param>value value to put in the map</param>
      <return>previous value associated with the key</return>
    </javadoc>
    <method type="T" name="put" startLine="419" endLine="440">
      <declaration type="int" name="index" />
      <declaration type="T" name="previous" />
      <declaration type="boolean" name="newMapping" />
      <scope startLine="423" endLine="427" />
      <scope startLine="431" endLine="437">
        <scope startLine="433" endLine="435" />
      </scope>
    </method>
    <javadoc>
      <text>* Grow the tables.</text>
    </javadoc>
    <method type="void" name="growTable" startLine="445" endLine="472">
      <declaration type="int" name="oldLength" />
      <declaration type="int[]" name="oldKeys" />
      <declaration type="T[]" name="oldValues" />
      <declaration type="byte[]" name="oldStates" />
      <declaration type="int" name="newLength" />
      <declaration type="int[]" name="newKeys" />
      <declaration type="T[]" name="newValues" />
      <declaration type="byte[]" name="newStates" />
      <declaration type="int" name="newMask" />
      <scope startLine="457" endLine="465">
        <scope startLine="458" endLine="464">
          <declaration type="int" name="key" />
          <declaration type="int" name="index" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Check if tables should grow due to increased size.</text>
      <return>true if  tables should grow</return>
    </javadoc>
    <method type="boolean" name="shouldGrowTable" startLine="478" endLine="480" />
    <javadoc>
      <text>* Compute the hash value of a key</text>
      <param>key key to hash</param>
      <return>hash value of the key</return>
    </javadoc>
    <method type="int" name="hashOf" startLine="487" endLine="490">
      <declaration type="int" name="h" />
    </method>
    <class name="Iterator" startLine="493">
      <javadoc>
        <text>* Iterator class for the map.</text>
      </javadoc>
      <javadoc>
        <text>* Reference modification count.</text>
      </javadoc>
      <declaration type="int" name="referenceCount" />
      <javadoc>
        <text>* Index of current element.</text>
      </javadoc>
      <declaration type="int" name="current" />
      <javadoc>
        <text>* Index of next element.</text>
      </javadoc>
      <declaration type="int" name="next" />
      <javadoc>
        <text>* Simple constructor.</text>
      </javadoc>
      <method type="constructor" name="Iterator" startLine="508" endLine="521">
        <scope startLine="515" endLine="517">
          <comment>NOPMD</comment>
        </scope>
        <scope startLine="517" endLine="519">
          <comment>ignored</comment>
        </scope>
        <comment>preserve the modification count of the map to detect concurrent modifications later</comment>
        <comment>initialize current index</comment>
      </method>
      <javadoc>
        <text>* Check if there is a next element in the map.</text>
        <return>true if there is a next element</return>
      </javadoc>
      <method type="boolean" name="hasNext" startLine="527" endLine="529" />
      <javadoc>
        <text>* Get the key of current entry.</text>
        <return>key of current entry</return>
        <exception>ConcurrentModificationException if the map is modified during iteration</exception>
        <exception>NoSuchElementException if there is no element left in the map</exception>
      </javadoc>
      <method type="int" name="key" startLine="538" endLine="546">
        <scope startLine="539" endLine="541" />
        <scope startLine="542" endLine="544" />
      </method>
      <javadoc>
        <text>* Get the value of current entry.</text>
        <return>value of current entry</return>
        <exception>ConcurrentModificationException if the map is modified during iteration</exception>
        <exception>NoSuchElementException if there is no element left in the map</exception>
      </javadoc>
      <method type="T" name="value" startLine="555" endLine="563">
        <scope startLine="556" endLine="558" />
        <scope startLine="559" endLine="561" />
      </method>
      <javadoc>
        <text>* Advance iterator one step further.</text>
        <exception>ConcurrentModificationException if the map is modified during iteration</exception>
        <exception>NoSuchElementException if there is no element left in the map</exception>
      </javadoc>
      <method type="void" name="advance" startLine="571" endLine="592">
        <scope startLine="573" endLine="575" />
        <scope startLine="581" endLine="585">
          <scope startLine="582" endLine="584" />
          <comment>NOPMD</comment>
          <comment>nothing to do</comment>
        </scope>
        <scope startLine="585" endLine="590">
          <scope startLine="587" endLine="589" />
        </scope>
        <comment>advance on step</comment>
        <comment>prepare next step</comment>
      </method>
      <javadoc>
        <text>* Read a serialized object.</text>
        <param>stream input stream</param>
        <throws>IOException if object cannot be read</throws>
        <throws>ClassNotFoundException if the class corresponding
 * to the serialized object cannot be found</throws>
      </javadoc>
      <method type="void" name="readObject" startLine="604" endLine="607" />
      <javadoc>
        <text>* Build an array of elements.</text>
        <param>length size of the array to build</param>
        <return>a new array</return>
      </javadoc>
      <method type="T[]" name="buildArray" startLine="614" endLine="616" />
    </class>
    <comment>field is of type T</comment>
  </class>
</source>
