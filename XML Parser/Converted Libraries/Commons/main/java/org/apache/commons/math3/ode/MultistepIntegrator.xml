<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator" />
  <import name="org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator" />
  <import name="org.apache.commons.math3.ode.sampling.StepHandler" />
  <import name="org.apache.commons.math3.ode.sampling.StepInterpolator" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="MultistepIntegrator" extends="AdaptiveStepsizeIntegrator" startLine="32">
    <javadoc>
      <text>* This class is the base class for multistep integrators for Ordinary
 * Differential Equations.
 * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:
 * <pre>
 * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative
 * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative
 * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative
 * ...
 * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative
 * </pre></p>
 * <p>Rather than storing several previous steps separately, this implementation uses
 * the Nordsieck vector with higher degrees scaled derivatives all taken at the same
 * step (y<sub>n</sub>, s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:
 * <pre>
 * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>
 * </pre>
 * (we omit the k index in the notation for clarity)</p>
 * <p>
 * Multistep integrators with Nordsieck representation are highly sensitive to
 * large step changes because when the step is multiplied by factor a, the
 * k<sup>th</sup> component of the Nordsieck vector is multiplied by a<sup>k</sup>
 * and the last components are the least accurate ones. The default max growth
 * factor is therefore set to a quite low value: 2<sup>1/order</sup>.
 * </p></text>
      <see>org.apache.commons.math3.ode.nonstiff.AdamsBashforthIntegrator</see>
      <see>org.apache.commons.math3.ode.nonstiff.AdamsMoultonIntegrator</see>
      <version>$Id: MultistepIntegrator.java 1463684 2013-04-02 19:04:13Z luc $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* First scaled derivative (h y').</text>
    </javadoc>
    <declaration type="double[]" name="scaled" />
    <javadoc>
      <text>* Nordsieck matrix of the higher scaled derivatives.
 * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y<sup>(k)</sup>)</p></text>
    </javadoc>
    <declaration type="Array2DRowRealMatrix" name="nordsieck" />
    <javadoc>
      <text>* Starter integrator.</text>
    </javadoc>
    <declaration type="FirstOrderIntegrator" name="starter" />
    <javadoc>
      <text>* Number of steps of the multistep method (excluding the one being computed).</text>
    </javadoc>
    <declaration type="int" name="nSteps" />
    <javadoc>
      <text>* Stepsize control exponent.</text>
    </javadoc>
    <declaration type="double" name="exp" />
    <javadoc>
      <text>* Safety factor for stepsize control.</text>
    </javadoc>
    <declaration type="double" name="safety" />
    <javadoc>
      <text>* Minimal reduction factor for stepsize control.</text>
    </javadoc>
    <declaration type="double" name="minReduction" />
    <javadoc>
      <text>* Maximal growth factor for stepsize control.</text>
    </javadoc>
    <declaration type="double" name="maxGrowth" />
    <javadoc>
      <text>* Build a multistep integrator with the given stepsize bounds.
 * <p>The default starter integrator is set to the {@link DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with
 * some defaults settings.</p>
 * <p>
 * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.
 * </p></text>
      <param>name name of the method</param>
      <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
      <param>order order of the method</param>
      <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
      <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
      <param>scalAbsoluteTolerance allowed absolute error</param>
      <param>scalRelativeTolerance allowed relative error</param>
      <exception>NumberIsTooSmallException if number of steps is smaller than 2</exception>
    </javadoc>
    <method type="constructor" name="MultistepIntegrator" startLine="116" endLine="138">
      <scope startLine="120" endLine="124" />
      <comment>set the default values of the algorithm control parameters</comment>
    </method>
    <javadoc>
      <text>* Build a multistep integrator with the given stepsize bounds.
 * <p>The default starter integrator is set to the {@link DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with
 * some defaults settings.</p>
 * <p>
 * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.
 * </p></text>
      <param>name name of the method</param>
      <param>nSteps number of steps of the multistep method
 * (excluding the one being computed)</param>
      <param>order order of the method</param>
      <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
      <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
      <param>vecAbsoluteTolerance allowed absolute error</param>
      <param>vecRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="MultistepIntegrator" startLine="163" endLine="177">
      <comment>set the default values of the algorithm control parameters</comment>
    </method>
    <javadoc>
      <text>* Get the starter integrator.</text>
      <return>starter integrator</return>
    </javadoc>
    <method type="ODEIntegrator" name="getStarterIntegrator" startLine="183" endLine="185" />
    <javadoc>
      <text>* Set the starter integrator.
 * <p>The various step and event handlers for this starter integrator
 * will be managed automatically by the multi-step integrator. Any
 * user configuration for these elements will be cleared before use.</p></text>
      <param>starterIntegrator starter integrator</param>
    </javadoc>
    <method type="void" name="setStarterIntegrator" startLine="194" endLine="196" />
    <javadoc>
      <text>* Start the integration.
 * <p>This method computes one step using the underlying starter integrator,
 * and initializes the Nordsieck vector at step start. The starter integrator
 * purpose is only to establish initial conditions, it does not really change
 * time by itself. The top level multistep integrator remains in charge of
 * handling time propagation and events handling as it will starts its own
 * computation right from the beginning. In a sense, the starter integrator
 * can be seen as a dummy one and so it will never trigger any user event nor
 * call any user step handler.</p></text>
      <param>t0 initial time</param>
      <param>y0 initial value of the state vector at t0</param>
      <param>t target time for the integration
 * (can be set to a value smaller than <code>t0</code> for backward integration)</param>
      <exception>DimensionMismatchException if arrays dimension do not match equations settings</exception>
      <exception>NumberIsTooSmallException if integration step is too small</exception>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
      <exception>NoBracketingException if the location of an event cannot be bracketed</exception>
    </javadoc>
    <method type="void" name="start" startLine="218" endLine="261">
      <scope startLine="230" endLine="250">
        <scope startLine="232" endLine="234" />
        <scope startLine="234" endLine="248">
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="int" name="getDimension" startLine="238" endLine="240" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="void" name="computeDerivatives" startLine="243" endLine="245" />
        </scope>
        <comment>NOPMD</comment>
      </scope>
      <scope startLine="250" endLine="256">
        <comment>this is the expected nominal interruption of the start integrator</comment>
        <comment>count the evaluations used by the starter</comment>
      </scope>
      <comment>make sure NO user event nor user step handler is triggered,</comment>
      <comment>this is the task of the top level integrator, not the task</comment>
      <comment>of the starter integrator</comment>
      <comment>set up one specific step handler to extract initial Nordsieck vector</comment>
      <comment>start integration, expecting a InitializationCompletedMarkerException</comment>
      <comment>remove the specific step handler</comment>
    </method>
    <method name="initializeHighOrderDerivatives" type="Array2DRowRealMatrix" startLine="263" endLine="273" />
    <javadoc>
      <text>* Initialize the high order scaled derivatives at step start.</text>
      <param>h step size to use for scaling</param>
      <param>t first steps times</param>
      <param>y first steps states</param>
      <param>yDot first steps derivatives</param>
      <return>Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,
 * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)</return>
    </javadoc>
    <javadoc>
      <text>* Get the minimal reduction factor for stepsize control.</text>
      <return>minimal reduction factor</return>
    </javadoc>
    <method type="double" name="getMinReduction" startLine="278" endLine="280" />
    <javadoc>
      <text>* Set the minimal reduction factor for stepsize control.</text>
      <param>minReduction minimal reduction factor</param>
    </javadoc>
    <method type="void" name="setMinReduction" startLine="285" endLine="287" />
    <javadoc>
      <text>* Get the maximal growth factor for stepsize control.</text>
      <return>maximal growth factor</return>
    </javadoc>
    <method type="double" name="getMaxGrowth" startLine="292" endLine="294" />
    <javadoc>
      <text>* Set the maximal growth factor for stepsize control.</text>
      <param>maxGrowth maximal growth factor</param>
    </javadoc>
    <method type="void" name="setMaxGrowth" startLine="299" endLine="301" />
    <javadoc>
      <text>* Get the safety factor for stepsize control.</text>
      <return>safety factor</return>
    </javadoc>
    <method type="double" name="getSafety" startLine="306" endLine="308" />
    <javadoc>
      <text>* Set the safety factor for stepsize control.</text>
      <param>safety safety factor</param>
    </javadoc>
    <method type="void" name="setSafety" startLine="313" endLine="315" />
    <javadoc>
      <text>* Compute step grow/shrink factor according to normalized error.</text>
      <param>error normalized error of the current step</param>
      <return>grow/shrink factor for next step</return>
    </javadoc>
    <method type="double" name="computeStepGrowShrinkFactor" startLine="321" endLine="323" />
    <interface name="NordsieckTransformer" startLine="325">
      <javadoc>
        <text>* Transformer used to convert the first step to Nordsieck representation.</text>
      </javadoc>
      <method name="initializeHighOrderDerivatives" type="Array2DRowRealMatrix" startLine="327" endLine="337" />
      <javadoc>
        <text>* Initialize the high order scaled derivatives at step start.</text>
        <param>h step size to use for scaling</param>
        <param>t first steps times</param>
        <param>y first steps states</param>
        <param>yDot first steps derivatives</param>
        <return>Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,
 * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)</return>
      </javadoc>
      <class name="NordsieckInitializer" startLine="340">
        <implements name="StepHandler" />
        <javadoc>
          <text>* Specialized step handler storing the first step.</text>
        </javadoc>
        <javadoc>
          <text>* Steps counter.</text>
        </javadoc>
        <declaration type="int" name="count" />
        <javadoc>
          <text>* First steps times.</text>
        </javadoc>
        <declaration type="double[]" name="t" />
        <javadoc>
          <text>* First steps states.</text>
        </javadoc>
        <declaration type="double[][]" name="y" />
        <javadoc>
          <text>* First steps derivatives.</text>
        </javadoc>
        <declaration type="double[][]" name="yDot" />
        <javadoc>
          <text>* Simple constructor.</text>
          <param>nSteps number of steps of the multistep method (excluding the one being computed)</param>
          <param>n problem dimension</param>
        </javadoc>
        <method type="constructor" name="NordsieckInitializer" startLine="359" endLine="364" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="handleStep" startLine="368" endLine="425">
          <declaration type="double" name="prev" />
          <declaration type="double" name="curr" />
          <scope startLine="373" endLine="387">
            <declaration type="ExpandableStatefulODE" name="expandable" />
            <declaration type="EquationsMapper" name="primary" />
            <declaration type="int" name="index" />
            <scope startLine="382" endLine="386" />
            <comment>first step, we need to store also the beginning of the step</comment>
          </scope>
          <declaration type="ExpandableStatefulODE" name="expandable" />
          <declaration type="EquationsMapper" name="primary" />
          <declaration type="int" name="index" />
          <scope startLine="399" endLine="403" />
          <scope startLine="405" endLine="423">
            <scope startLine="413" endLine="415" />
            <comment>this was the last step we needed, we can compute the derivatives</comment>
            <comment>first scaled derivative</comment>
            <comment>higher order derivatives</comment>
            <comment>stop the integrator now that all needed steps have been handled</comment>
          </scope>
          <comment>store the end of the step</comment>
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="init" startLine="428" endLine="430">
          <comment>nothing to do</comment>
        </method>
        <class name="InitializationCompletedMarkerException" extends="RuntimeException" startLine="434">
          <javadoc>
            <text>* Marker exception used ONLY to stop the starter integrator after first step.</text>
          </javadoc>
          <javadoc>
            <text>* Serializable version identifier.</text>
          </javadoc>
          <declaration type="long" name="serialVersionUID" />
          <javadoc>
            <text>* Simple constructor.</text>
          </javadoc>
          <method type="constructor" name="InitializationCompletedMarkerException" startLine="442" endLine="444" />
        </class>
      </class>
    </interface>
  </class>
</source>
