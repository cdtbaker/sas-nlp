<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.dfp">
  <class name="DfpMath" startLine="20">
    <javadoc>
      <text>* Mathematical routines for use with {@link Dfp}.
 * The constants are defined in {@link DfpField}</text>
      <version>$Id: DfpMath.java 1462503 2013-03-29 15:48:27Z luc $</version>
      <since>2.2</since>
    </javadoc>
    <javadoc>
      <text>* Name for traps triggered by pow.</text>
    </javadoc>
    <declaration type="String" name="POW_TRAP" />
    <javadoc>
      <text>* Private Constructor.</text>
    </javadoc>
    <method type="constructor" name="DfpMath" startLine="33" endLine="34" />
    <javadoc>
      <text>* Breaks a string representation up into two dfp's.
 * <p>The two dfp are such that the sum of them is equivalent
 * to the input string, but has higher precision than using a
 * single dfp. This is useful for improving accuracy of
 * exponentiation and critical multiplies.</text>
      <param>field field to which the Dfp must belong</param>
      <param>a string representation to split</param>
      <return>an array of two {@link Dfp} which sum is a</return>
    </javadoc>
    <method type="Dfp[]" name="split" startLine="45" endLine="88">
      <declaration type="Dfp[]" name="result" />
      <declaration type="char[]" name="buf" />
      <declaration type="boolean" name="leading" />
      <declaration type="int" name="sp" />
      <declaration type="int" name="sig" />
      <scope startLine="54" endLine="74">
        <scope startLine="57" endLine="59" />
        <scope startLine="61" endLine="64" />
        <scope startLine="66" endLine="69" />
        <scope startLine="71" endLine="73" />
      </scope>
      <scope startLine="78" endLine="83">
        <scope startLine="80" endLine="82" />
      </scope>
    </method>
    <javadoc>
      <text>* Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.</text>
      <param>a number to split</param>
      <return>two elements array containing the split number</return>
    </javadoc>
    <method type="Dfp[]" name="split" startLine="94" endLine="100">
      <declaration type="Dfp[]" name="result" />
      <declaration type="Dfp" name="shift" />
    </method>
    <javadoc>
      <text>* Multiply two numbers that are split in to two pieces that are
 * meant to be added together.
 * Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1
 * Store the first term in result0, the rest in result1</text>
      <param>a first factor of the multiplication, in split form</param>
      <param>b second factor of the multiplication, in split form</param>
      <return>a &times; b, in split form</return>
    </javadoc>
    <method type="Dfp[]" name="splitMult" startLine="110" endLine="127">
      <declaration type="Dfp[]" name="result" />
      <scope startLine="120" endLine="122" />
      <comment>If result[0] is infinite or zero, don't compute result[1].
 Attempting to do so may produce NaNs.</comment>
    </method>
    <javadoc>
      <text>* Divide two numbers that are split in to two pieces that are meant to be added together.
 * Inverse of split multiply above:
 * (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )</text>
      <param>a dividend, in split form</param>
      <param>b divisor, in split form</param>
      <return>a / b, in split form</return>
    </javadoc>
    <method type="Dfp[]" name="splitDiv" startLine="136" endLine="146">
      <declaration type="Dfp[]" name="result" />
    </method>
    <javadoc>
      <text>* Raise a split base to the a power.</text>
      <param>base number to raise</param>
      <param>a power</param>
      <return>base<sup>a</sup></return>
    </javadoc>
    <method type="Dfp" name="splitPow" startLine="153" endLine="204">
      <declaration type="boolean" name="invert" />
      <declaration type="Dfp[]" name="r" />
      <declaration type="Dfp[]" name="result" />
      <scope startLine="162" endLine="165">
        <comment>Special case a = 0</comment>
      </scope>
      <scope startLine="167" endLine="171">
        <comment>If a is less than zero</comment>
      </scope>
      <scope startLine="174" endLine="194">
        <declaration type="int" name="trial" />
        <declaration type="int" name="prevtrial" />
        <scope startLine="180" endLine="187">
          <scope startLine="183" endLine="185" />
        </scope>
      </scope>
      <scope startLine="198" endLine="200" />
      <comment>Exponentiate by successive squaring</comment>
    </method>
    <javadoc>
      <text>* Raises base to the power a by successive squaring.</text>
      <param>base number to raise</param>
      <param>a power</param>
      <return>base<sup>a</sup></return>
    </javadoc>
    <method type="Dfp" name="pow" startLine="212" endLine="255">
      <declaration type="boolean" name="invert" />
      <declaration type="Dfp" name="result" />
      <scope startLine="217" endLine="220">
        <comment>Special case</comment>
      </scope>
      <scope startLine="222" endLine="225" />
      <scope startLine="228" endLine="247">
        <declaration type="Dfp" name="r" />
        <declaration type="Dfp" name="prevr" />
        <declaration type="int" name="trial" />
        <declaration type="int" name="prevtrial" />
        <scope startLine="234" endLine="239" />
      </scope>
      <scope startLine="249" endLine="251" />
      <comment>Exponentiate by successive squaring</comment>
    </method>
    <javadoc>
      <text>* Computes e to the given power.
 * a is broken into two parts, such that a = n+m  where n is an integer.
 * We use pow() to compute e<sup>n</sup> and a Taylor series to compute
 * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup></text>
      <param>a power at which e should be raised</param>
      <return>e<sup>a</sup></return>
    </javadoc>
    <method type="Dfp" name="exp" startLine="264" endLine="284">
      <declaration type="Dfp" name="inta" />
      <declaration type="Dfp" name="fraca" />
      <declaration type="int" name="ia" />
      <scope startLine="270" endLine="273">
        <comment>return +Infinity</comment>
      </scope>
      <scope startLine="275" endLine="278">
        <comment>return 0;</comment>
      </scope>
      <declaration type="Dfp" name="einta" />
      <declaration type="Dfp" name="efraca" />
    </method>
    <javadoc>
      <text>* Computes e to the given power.
 * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...</text>
      <param>a power at which e should be raised</param>
      <return>e<sup>a</sup></return>
    </javadoc>
    <method type="Dfp" name="expInternal" startLine="291" endLine="308">
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="x" />
      <declaration type="Dfp" name="fact" />
      <declaration type="Dfp" name="py" />
      <scope startLine="297" endLine="305">
        <scope startLine="301" endLine="303" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the natural logarithm of a.
 * a is first split into three parts such that  a = (10000^h)(2^j)k.
 * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)
 * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.</text>
      <param>a number from which logarithm is requested</param>
      <return>log(a)</return>
    </javadoc>
    <method type="Dfp" name="log" startLine="317" endLine="378">
      <declaration type="int" name="lr" />
      <declaration type="Dfp" name="x" />
      <declaration type="int" name="ix" />
      <declaration type="int" name="p2" />
      <scope startLine="324" endLine="328">
        <comment>negative, zero or NaN</comment>
      </scope>
      <scope startLine="330" endLine="332" />
      <scope startLine="340" endLine="343" />
      <declaration type="Dfp[]" name="spx" />
      <declaration type="Dfp[]" name="spy" />
      <scope startLine="353" endLine="357" />
      <declaration type="Dfp[]" name="spz" />
      <comment>Check the arguments somewhat here</comment>
      <comment>x = x.divide(pow(a.newInstance(10000), lr));   This puts x in the range 0-10000</comment>
      <comment>use spy[0] temporarily as a divisor</comment>
      <comment>Use spy[0] for comparison</comment>
      <comment>X is now in the range of 2/3 < x < 4/3</comment>
    </method>
    <javadoc>
      <text>* Computes the natural log of a number between 0 and 2.
 * Let f(x) = ln(x),
 * We know that f'(x) = 1/x, thus from Taylor's theorum we have:
 * -----          n+1         n
 * f(x) =   \           (-1)    (x - 1)
 * /          ----------------    for 1 <= n <= infinity
 * -----             n
 * or
 * 2        3       4
 * (x-1)   (x-1)    (x-1)
 * ln(x) =  (x-1) - ----- + ------ - ------ + ...
 * 2       3        4
 * alternatively,
 * 2    3   4
 * x    x   x
 * ln(x+1) =  x - -  + - - - + ...
 * 2    3   4
 * This series can be used to compute ln(x), but it converges too slowly.
 * If we substitute -x for x above, we get
 * 2    3    4
 * x    x    x
 * ln(1-x) =  -x - -  - -  - - + ...
 * 2    3    4
 * Note that all terms are now negative.  Because the even powered ones
 * absorbed the sign.  Now, subtract the series above from the previous
 * one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
 * only the odd ones
 * 3     5      7
 * 2x    2x     2x
 * ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
 * 3     5      7
 * By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
 * 3        5        7
 * x+1           /          x        x        x          \
 * ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
 * x-1           \          3        5        7          /
 * But now we want to find ln(a), so we need to find the value of x
 * such that a = (x+1)/(x-1).   This is easily solved to find that
 * x = (a-1)/(a+1).</text>
      <param>a number from which logarithm is requested, in split form</param>
      <return>log(a)</return>
    </javadoc>
    <method type="Dfp[]" name="logInternal" startLine="435" endLine="463">
      <declaration type="Dfp" name="t" />
      <declaration type="Dfp" name="x" />
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="num" />
      <declaration type="Dfp" name="py" />
      <declaration type="int" name="den" />
      <scope startLine="447" endLine="457">
        <scope startLine="453" endLine="455" />
      </scope>
      <comment>Now we want to compute x = (a-1)(a+1) but this is prone to
 loss of precision.  So instead, compute x = (a4 - 14)  (a4 + 14)</comment>
    </method>
    <javadoc>
      <text>* Computes x to the y power.<p>
 * Uses the following method:<p>
 * <ol>
 * <li> Set u = rint(y), v = y-u
 * <li> Compute a = v * ln(x)
 * <li> Compute b = rint( a/ln(2) )
 * <li> Compute c = a - b*ln(2)
 * <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>
 * </ol>
 * if |y| > 1e8, then we compute by exp(y*ln(x))   <p>
 * <b>Special Cases</b><p>
 * <ul>
 * <li>  if y is 0.0 or -0.0 then result is 1.0
 * <li>  if y is 1.0 then result is x
 * <li>  if y is NaN then result is NaN
 * <li>  if x is NaN and y is not zero then result is NaN
 * <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity
 * <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity
 * <li>  if |x| > 1.0 and y is -Infinity then result is +0
 * <li>  if |x| < 1.0 and y is +Infinity then result is +0
 * <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN
 * <li>  if x = +0 and y > 0 then result is +0
 * <li>  if x = +Inf and y < 0 then result is +0
 * <li>  if x = +0 and y < 0 then result is +Inf
 * <li>  if x = +Inf and y > 0 then result is +Inf
 * <li>  if x = -0 and y > 0, finite, not odd integer then result is +0
 * <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf
 * <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf
 * <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf
 * <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf
 * <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)
 * <li>  if x < 0 and y > 0, finite, and not integer then result is NaN
 * </ul></text>
      <param>x base to be raised</param>
      <param>y power to which base should be raised</param>
      <return>x<sup>y</sup></return>
    </javadoc>
    <method type="Dfp" name="pow" startLine="505" endLine="663">
      <scope startLine="508" endLine="513">
        <declaration type="Dfp" name="result" />
      </scope>
      <declaration type="Dfp" name="zero" />
      <declaration type="Dfp" name="one" />
      <declaration type="Dfp" name="two" />
      <declaration type="boolean" name="invert" />
      <declaration type="int" name="ui" />
      <scope startLine="522" endLine="524" />
      <scope startLine="526" endLine="533">
        <scope startLine="527" endLine="531" />
        <comment>Test for NaNs</comment>
      </scope>
      <scope startLine="535" endLine="539">
        <comment>Test for NaNs</comment>
      </scope>
      <scope startLine="542" endLine="568">
        <scope startLine="543" endLine="550">
          <scope startLine="545" endLine="547" />
          <scope startLine="547" endLine="549" />
        </scope>
        <scope startLine="550" endLine="567">
          <scope startLine="552" endLine="559">
            <scope startLine="554" endLine="556" />
            <scope startLine="556" endLine="558" />
          </scope>
          <scope startLine="559" endLine="566">
            <scope startLine="561" endLine="563" />
            <scope startLine="563" endLine="565" />
          </scope>
        </scope>
        <comment>X == +0</comment>
        <comment>X == -0</comment>
        <comment>If y is odd integer</comment>
        <comment>Y is not odd integer</comment>
      </scope>
      <scope startLine="570" endLine="574">
        <comment>Make x positive, but keep track of it</comment>
      </scope>
      <scope startLine="576" endLine="582">
        <scope startLine="577" endLine="579" />
        <scope startLine="579" endLine="581" />
      </scope>
      <scope startLine="584" endLine="590">
        <scope startLine="585" endLine="587" />
        <scope startLine="587" endLine="589" />
      </scope>
      <scope startLine="592" endLine="595" />
      <scope startLine="597" endLine="624">
        <scope startLine="599" endLine="616">
          <scope startLine="601" endLine="608">
            <scope startLine="603" endLine="605" />
            <scope startLine="605" endLine="607" />
          </scope>
          <scope startLine="608" endLine="615">
            <scope startLine="610" endLine="612" />
            <scope startLine="612" endLine="614" />
          </scope>
        </scope>
        <scope startLine="616" endLine="623">
          <scope startLine="618" endLine="620" />
          <scope startLine="620" endLine="622" />
        </scope>
        <comment>x = +/- inf</comment>
        <comment>negative infinity</comment>
        <comment>If y is odd integer</comment>
        <comment>Y is not odd integer</comment>
        <comment>positive infinity</comment>
      </scope>
      <scope startLine="626" endLine="629" />
      <declaration type="Dfp" name="r" />
      <scope startLine="634" endLine="651">
        <declaration type="Dfp" name="u" />
        <declaration type="Dfp" name="v" />
        <scope startLine="640" endLine="648">
          <declaration type="Dfp" name="a" />
          <declaration type="Dfp" name="b" />
          <declaration type="Dfp" name="c" />
        </scope>
        <scope startLine="648" endLine="650" />
      </scope>
      <scope startLine="651" endLine="654">
        <comment>very large exponent.  |y| > 1e8</comment>
      </scope>
      <scope startLine="656" endLine="659">
        <comment>if y is odd integer</comment>
      </scope>
      <comment>make sure we don't mix number with different precision</comment>
      <comment>Check for special cases</comment>
      <comment>X == 0</comment>
      <comment>End special cases</comment>
    </method>
    <javadoc>
      <text>* Computes sin(a)  Used when 0 < a < pi/4.
 * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...</text>
      <param>a number from which sine is desired, in split form</param>
      <return>sin(a)</return>
    </javadoc>
    <method type="Dfp" name="sinInternal" startLine="670" endLine="693">
      <declaration type="Dfp" name="c" />
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="x" />
      <declaration type="Dfp" name="fact" />
      <declaration type="Dfp" name="py" />
      <scope startLine="679" endLine="689">
        <scope startLine="685" endLine="687" />
        <comment>1 over fact</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Computes cos(a)  Used when 0 < a < pi/4.
 * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...</text>
      <param>a number from which cosine is desired, in split form</param>
      <return>cos(a)</return>
    </javadoc>
    <method type="Dfp" name="cosInternal" startLine="700" endLine="727">
      <declaration type="Dfp" name="one" />
      <declaration type="Dfp" name="x" />
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="c" />
      <declaration type="Dfp" name="fact" />
      <declaration type="Dfp" name="py" />
      <scope startLine="712" endLine="723">
        <scope startLine="719" endLine="721" />
        <comment>1 over fact</comment>
      </scope>
    </method>
    <javadoc>
      <text>* computes the sine of the argument.</text>
      <param>a number from which sine is desired</param>
      <return>sin(a)</return>
    </javadoc>
    <method type="Dfp" name="sin" startLine="733" endLine="778">
      <declaration type="Dfp" name="pi" />
      <declaration type="Dfp" name="zero" />
      <declaration type="boolean" name="neg" />
      <declaration type="Dfp" name="x" />
      <scope startLine="743" endLine="746" />
      <scope startLine="752" endLine="754" />
      <declaration type="Dfp" name="y" />
      <scope startLine="757" endLine="764">
        <declaration type="Dfp[]" name="c" />
        <comment>y = sinInternal(c);</comment>
      </scope>
      <scope startLine="764" endLine="770">
        <declaration type="Dfp[]" name="c" />
        <declaration type="Dfp[]" name="piSplit" />
      </scope>
      <scope startLine="772" endLine="774" />
      <comment>First reduce the argument to the range of +- PI</comment>
      <comment>if x < 0 then apply identity sin(-x) = -sin(x)</comment>
      <comment>This puts x in the range 0 < x < PI</comment>
      <comment>Since sine(x) = sine(pi - x) we can reduce the range to
 0 < x < pi2</comment>
    </method>
    <javadoc>
      <text>* computes the cosine of the argument.</text>
      <param>a number from which cosine is desired</param>
      <return>cos(a)</return>
    </javadoc>
    <method type="Dfp" name="cos" startLine="784" endLine="828">
      <declaration type="Dfp" name="pi" />
      <declaration type="Dfp" name="zero" />
      <declaration type="boolean" name="neg" />
      <declaration type="Dfp" name="x" />
      <scope startLine="794" endLine="796" />
      <scope startLine="802" endLine="805" />
      <declaration type="Dfp" name="y" />
      <scope startLine="808" endLine="814">
        <declaration type="Dfp[]" name="c" />
      </scope>
      <scope startLine="814" endLine="820">
        <declaration type="Dfp[]" name="c" />
        <declaration type="Dfp[]" name="piSplit" />
      </scope>
      <scope startLine="822" endLine="824" />
      <comment>First reduce the argument to the range of +- PI</comment>
      <comment>if x < 0 then apply identity cos(-x) = cos(x)</comment>
      <comment>This puts x in the range 0 < x < PI</comment>
      <comment>Since cos(x) = -cos(pi - x) we can reduce the range to
 0 < x < pi2</comment>
    </method>
    <javadoc>
      <text>* computes the tangent of the argument.</text>
      <param>a number from which tangent is desired</param>
      <return>tan(a)</return>
    </javadoc>
    <method type="Dfp" name="tan" startLine="834" endLine="836" />
    <javadoc>
      <text>* computes the arc-tangent of the argument.</text>
      <param>a number from which arc-tangent is desired</param>
      <return>atan(a)</return>
    </javadoc>
    <method type="Dfp" name="atanInternal" startLine="842" endLine="861">
      <declaration type="Dfp" name="y" />
      <declaration type="Dfp" name="x" />
      <declaration type="Dfp" name="py" />
      <scope startLine="848" endLine="857">
        <scope startLine="853" endLine="855" />
      </scope>
    </method>
    <javadoc>
      <text>* computes the arc tangent of the argument
 * Uses the typical taylor series
 * but may reduce arguments using the following identity
 * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))
 * since tan(PI/8) = sqrt(2)-1,
 * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0</text>
      <param>a number from which arc-tangent is desired</param>
      <return>atan(a)</return>
    </javadoc>
    <method type="Dfp" name="atan" startLine="876" endLine="935">
      <declaration type="Dfp" name="zero" />
      <declaration type="Dfp" name="one" />
      <declaration type="Dfp[]" name="sqr2Split" />
      <declaration type="Dfp[]" name="piSplit" />
      <declaration type="boolean" name="recp" />
      <declaration type="boolean" name="neg" />
      <declaration type="boolean" name="sub" />
      <declaration type="Dfp" name="ty" />
      <declaration type="Dfp" name="x" />
      <scope startLine="888" endLine="891" />
      <scope startLine="893" endLine="896" />
      <scope startLine="898" endLine="917">
        <declaration type="Dfp[]" name="sty" />
        <declaration type="Dfp[]" name="xs" />
        <declaration type="Dfp[]" name="ds" />
        <comment>x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));</comment>
      </scope>
      <declaration type="Dfp" name="y" />
      <scope startLine="921" endLine="923" />
      <scope startLine="925" endLine="927" />
      <scope startLine="929" endLine="931" />
    </method>
    <javadoc>
      <text>* computes the arc-sine of the argument.</text>
      <param>a number from which arc-sine is desired</param>
      <return>asin(a)</return>
    </javadoc>
    <method type="Dfp" name="asin" startLine="941" endLine="943" />
    <javadoc>
      <text>* computes the arc-cosine of the argument.</text>
      <param>a number from which arc-cosine is desired</param>
      <return>acos(a)</return>
    </javadoc>
    <method type="Dfp" name="acos" startLine="949" endLine="966">
      <declaration type="Dfp" name="result" />
      <declaration type="boolean" name="negative" />
      <scope startLine="953" endLine="955" />
      <scope startLine="961" endLine="963" />
      <comment>absolute value</comment>
    </method>
  </class>
</source>
