<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.nonstiff">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.ode.EquationsMapper" />
  <import name="org.apache.commons.math3.ode.ExpandableStatefulODE" />
  <import name="org.apache.commons.math3.ode.sampling.NordsieckStepInterpolator" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="AdamsBashforthIntegrator" extends="AdamsIntegrator" startLine="31">
    <javadoc>
      <text>* This class implements explicit Adams-Bashforth integrators for Ordinary
 * Differential Equations.
 * <p>Adams-Bashforth methods (in fact due to Adams alone) are explicit
 * multistep ODE solvers. This implementation is a variation of the classical
 * one: it uses adaptive stepsize to implement error control, whereas
 * classical implementations are fixed step size. The value of state vector
 * at step n+1 is a simple combination of the value at step n and of the
 * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous
 * steps one wants to use for computing the next value, different formulas
 * are available:</p>
 * <ul>
 * <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n</sub></li>
 * <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3y'<sub>n</sub>-y'<sub>n-1</sub>)/2</li>
 * <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23y'<sub>n</sub>-16y'<sub>n-1</sub>+5y'<sub>n-2</sub>)/12</li>
 * <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55y'<sub>n</sub>-59y'<sub>n-1</sub>+37y'<sub>n-2</sub>-9y'<sub>n-3</sub>)/24</li>
 * <li>...</li>
 * </ul>
 * <p>A k-steps Adams-Bashforth method is of order k.</p>
 * <h3>Implementation details</h3>
 * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:
 * <pre>
 * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative
 * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative
 * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative
 * ...
 * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative
 * </pre></p>
 * <p>The definitions above use the classical representation with several previous first
 * derivatives. Lets define
 * <pre>
 * q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>
 * </pre>
 * (we omit the k index in the notation for clarity). With these definitions,
 * Adams-Bashforth methods can be written:
 * <ul>
 * <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n)</li>
 * <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 3/2 s<sub>1</sub>(n) + [ -1/2 ] q<sub>n</sub></li>
 * <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 23/12 s<sub>1</sub>(n) + [ -16/12 5/12 ] q<sub>n</sub></li>
 * <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 55/24 s<sub>1</sub>(n) + [ -59/24 37/24 -9/24 ] q<sub>n</sub></li>
 * <li>...</li>
 * </ul></p>
 * <p>Instead of using the classical representation with first derivatives only (y<sub>n</sub>,
 * s<sub>1</sub>(n) and q<sub>n</sub>), our implementation uses the Nordsieck vector with
 * higher degrees scaled derivatives all taken at the same step (y<sub>n</sub>, s<sub>1</sub>(n)
 * and r<sub>n</sub>) where r<sub>n</sub> is defined as:
 * <pre>
 * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>
 * </pre>
 * (here again we omit the k index in the notation for clarity)
 * </p>
 * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be
 * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact
 * for degree k polynomials.
 * <pre>
 * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)
 * </pre>
 * The previous formula can be used with several values for i to compute the transform between
 * classical representation and Nordsieck vector. The transform between r<sub>n</sub>
 * and q<sub>n</sub> resulting from the Taylor series formulas above is:
 * <pre>
 * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>
 * </pre>
 * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built
 * with the j (-i)<sup>j-1</sup> terms:
 * <pre>
 * [  -2   3   -4    5  ... ]
 * [  -4  12  -32   80  ... ]
 * P =  [  -6  27 -108  405  ... ]
 * [  -8  48 -256 1280  ... ]
 * [          ...           ]
 * </pre></p>
 * <p>Using the Nordsieck vector has several advantages:
 * <ul>
 * <li>it greatly simplifies step interpolation as the interpolator mainly applies
 * Taylor series formulas,</li>
 * <li>it simplifies step changes that occur when discrete events that truncate
 * the step are triggered,</li>
 * <li>it allows to extend the methods in order to support adaptive stepsize.</li>
 * </ul></p>
 * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:
 * <ul>
 * <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>
 * <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>
 * <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>
 * </ul>
 * where A is a rows shifting matrix (the lower left part is an identity matrix):
 * <pre>
 * [ 0 0   ...  0 0 | 0 ]
 * [ ---------------+---]
 * [ 1 0   ...  0 0 | 0 ]
 * A = [ 0 1   ...  0 0 | 0 ]
 * [       ...      | 0 ]
 * [ 0 0   ...  1 0 | 0 ]
 * [ 0 0   ...  0 1 | 0 ]
 * </pre></p>
 * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state,
 * they only depend on k and therefore are precomputed once for all.</p></text>
      <version>$Id: AdamsBashforthIntegrator.java 1463684 2013-04-02 19:04:13Z luc $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Integrator method name.</text>
    </javadoc>
    <declaration type="String" name="METHOD_NAME" />
    <javadoc>
      <text>* Build an Adams-Bashforth integrator with the given order and step control parameters.</text>
      <param>nSteps number of steps of the method excluding the one being computed</param>
      <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>scalAbsoluteTolerance allowed absolute error</param>
      <param>scalRelativeTolerance allowed relative error</param>
      <exception>NumberIsTooSmallException if order is 1 or less</exception>
    </javadoc>
    <method type="constructor" name="AdamsBashforthIntegrator" startLine="165" endLine="168" />
    <javadoc>
      <text>* Build an Adams-Bashforth integrator with the given order and step control parameters.</text>
      <param>nSteps number of steps of the method excluding the one being computed</param>
      <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>vecAbsoluteTolerance allowed absolute error</param>
      <param>vecRelativeTolerance allowed relative error</param>
      <exception>IllegalArgumentException if order is 1 or less</exception>
    </javadoc>
    <method type="constructor" name="AdamsBashforthIntegrator" startLine="187" endLine="190" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="integrate" startLine="196" endLine="324">
      <declaration type="boolean" name="forward" />
      <declaration type="double[]" name="y0" />
      <declaration type="double[]" name="y" />
      <declaration type="double[]" name="yDot" />
      <declaration type="NordsieckStepInterpolator" name="interpolator" />
      <declaration type="int" name="lastRow" />
      <declaration type="double" name="hNew" />
      <scope startLine="227" endLine="316">
        <declaration type="double" name="error" />
        <scope startLine="230" endLine="253">
          <scope startLine="236" endLine="243">
            <declaration type="double" name="yScale" />
            <declaration type="double" name="tol" />
            <declaration type="double" name="ratio" />
          </scope>
          <scope startLine="246" endLine="252">
            <declaration type="double" name="factor" />
          </scope>
        </scope>
        <declaration type="double" name="stepEnd" />
        <declaration type="ExpandableStatefulODE" name="expandable" />
        <declaration type="EquationsMapper" name="primary" />
        <declaration type="int" name="index" />
        <scope startLine="263" endLine="266" />
        <declaration type="double[]" name="predictedScaled" />
        <scope startLine="273" endLine="275" />
        <declaration type="Array2DRowRealMatrix" name="nordsieckTmp" />
        <scope startLine="287" endLine="314">
          <scope startLine="292" endLine="297" />
          <declaration type="double" name="factor" />
          <declaration type="double" name="scaledH" />
          <declaration type="double" name="nextT" />
          <declaration type="boolean" name="nextIsLast" />
          <declaration type="double" name="filteredNextT" />
          <declaration type="boolean" name="filteredNextIsLast" />
          <scope startLine="308" endLine="310" />
        </scope>
        <comment>evaluate error using the last term of the Taylor expansion</comment>
        <comment>reject the step and attempt to reduce error by stepsize control</comment>
        <comment>predict a first estimate of the state at step end</comment>
        <comment>evaluate the derivative</comment>
        <comment>update Nordsieck vector</comment>
        <comment>discrete events handling</comment>
        <comment>prepare next step</comment>
        <comment>some events handler has triggered changes that</comment>
        <comment>invalidate the derivatives, we need to restart from scratch</comment>
        <comment>stepsize control for next step</comment>
      </scope>
      <comment>initialize working arrays</comment>
      <comment>set up an interpolator sharing the integrator arrays</comment>
      <comment>set up integration control objects</comment>
      <comment>compute the initial Nordsieck vector using the configured starter integrator</comment>
      <comment>reuse the step that was chosen by the starter integrator</comment>
      <comment>main integration loop</comment>
      <comment>dispatch results</comment>
    </method>
  </class>
</source>
