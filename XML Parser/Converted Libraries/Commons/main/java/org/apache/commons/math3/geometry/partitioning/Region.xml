<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.partitioning">
  <import name="org.apache.commons.math3.geometry.Space" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <interface name="Region" startLine="22">
    <javadoc>
      <text>* This interface represents a region of a space as a partition.
 * <p>Region are subsets of a space, they can be infinite (whole
 * space, half space, infinite stripe ...) or finite (polygons in 2D,
 * polyhedrons in 3D ...). Their main characteristic is to separate
 * points that are considered to be <em>inside</em> the region from
 * points considered to be <em>outside</em> of it. In between, there
 * may be points on the <em>boundary</em> of the region.</p>
 * <p>This implementation is limited to regions for which the boundary
 * is composed of several {@link SubHyperplane sub-hyperplanes},
 * including regions with no boundary at all: the whole space and the
 * empty region. They are not necessarily finite and not necessarily
 * path-connected. They can contain holes.</p>
 * <p>Regions can be combined using the traditional sets operations :
 * union, intersection, difference and symetric difference (exclusive
 * or) for the binary operations, complement for the unary
 * operation.</p></text>
      <param><S>
 *  Type of the space.</param>
      <version>$Id: Region.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Enumerate for the location of a point with respect to the region.</text>
    </javadoc>
    <javadoc>
      <text>* Code for points inside the partition.</text>
    </javadoc>
    <javadoc>
      <text>* Code for points outside of the partition.</text>
    </javadoc>
    <javadoc>
      <text>* Code for points on the partition boundary.</text>
    </javadoc>
    <method name="buildNew" type="Region<S>" startLine="61" endLine="77" />
    <javadoc>
      <text>* Build a region using the instance as a prototype.
 * <p>This method allow to create new instances without knowing
 * exactly the type of the region. It is an application of the
 * prototype design pattern.</p>
 * <p>The leaf nodes of the BSP tree <em>must</em> have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
 * tree also <em>must</em> have either null internal nodes or
 * internal nodes representing the boundary as specified in the{@link #getTree getTree} method).</p></text>
      <param>newTree inside/outside BSP tree representing the new region</param>
      <return>the built region</return>
    </javadoc>
    <method name="copySelf" type="Region<S>" startLine="79" endLine="86" />
    <javadoc>
      <text>* Copy the instance.
 * <p>The instance created is completely independant of the original
 * one. A deep copy is used, none of the underlying objects are
 * shared (except for the underlying tree {@code Boolean}attributes and immutable objects).</p></text>
      <return>a new region, copy of the instance</return>
    </javadoc>
    <method name="isEmpty" type="boolean" startLine="88" endLine="91" />
    <javadoc>
      <text>* Check if the instance is empty.</text>
      <return>true if the instance is empty</return>
    </javadoc>
    <method name="isEmpty" type="boolean" startLine="93" endLine="100" />
    <javadoc>
      <text>* Check if the sub-tree starting at a given node is empty.</text>
      <param>node root node of the sub-tree (<em>must</em> have {@link Region Region} tree semantics, i.e. the leaf nodes must have{@code Boolean} attributes representing an inside/outside
 * property)</param>
      <return>true if the sub-tree starting at the given node is empty</return>
    </javadoc>
    <method name="contains" type="boolean" startLine="102" endLine="106" />
    <javadoc>
      <text>* Check if the instance entirely contains another region.</text>
      <param>region region to check against the instance</param>
      <return>true if the instance contains the specified tree</return>
    </javadoc>
    <method name="checkPoint" type="Location" startLine="108" endLine="113" />
    <javadoc>
      <text>* Check a point with respect to the region.</text>
      <param>point point to check</param>
      <return>a code representing the point status: either {@link Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}</return>
    </javadoc>
    <method name="getTree" type="BSPTree<S>" startLine="115" endLine="154" />
    <javadoc>
      <text>* Get the underlying BSP tree.
 * <p>Regions are represented by an underlying inside/outside BSP
 * tree whose leaf attributes are {@code Boolean} instances
 * representing inside leaf cells if the attribute value is{@code true} and outside leaf cells if the attribute is{@code false}. These leaf attributes are always present and
 * guaranteed to be non null.</p>
 * <p>In addition to the leaf attributes, the internal nodes which
 * correspond to cells split by cut sub-hyperplanes may contain{@link BoundaryAttribute BoundaryAttribute} objects representing
 * the parts of the corresponding cut sub-hyperplane that belong to
 * the boundary. When the boundary attributes have been computed,
 * all internal nodes are guaranteed to have non-null
 * attributes, however some {@link BoundaryAttributeBoundaryAttribute} instances may have their {@link BoundaryAttribute#plusInside plusInside} and {@link BoundaryAttribute#plusOutside plusOutside} fields both null if
 * the corresponding cut sub-hyperplane does not have any parts
 * belonging to the boundary.</p>
 * <p>Since computing the boundary is not always required and can be
 * time-consuming for large trees, these internal nodes attributes
 * are computed using lazy evaluation only when required by setting
 * the {@code includeBoundaryAttributes} argument to{@code true}. Once computed, these attributes remain in the
 * tree, which implies that in this case, further calls to the
 * method for the same region will always include these attributes
 * regardless of the value of the{@code includeBoundaryAttributes} argument.</p></text>
      <param>includeBoundaryAttributes if true, the boundary attributes
 * at internal nodes are guaranteed to be included (they may be
 * included even if the argument is false, if they have already been
 * computed due to a previous call)</param>
      <return>underlying BSP tree</return>
      <see>BoundaryAttribute</see>
    </javadoc>
    <method name="getBoundarySize" type="double" startLine="156" endLine="160" />
    <javadoc>
      <text>* Get the size of the boundary.</text>
      <return>the size of the boundary (this is 0 in 1D, a length in
 * 2D, an area in 3D ...)</return>
    </javadoc>
    <method name="getSize" type="double" startLine="162" endLine="166" />
    <javadoc>
      <text>* Get the size of the instance.</text>
      <return>the size of the instance (this is a length in 1D, an area
 * in 2D, a volume in 3D ...)</return>
    </javadoc>
    <method name="getBarycenter" type="Vector<S>" startLine="168" endLine="171" />
    <javadoc>
      <text>* Get the barycenter of the instance.</text>
      <return>an object representing the barycenter</return>
    </javadoc>
    <method name="side" type="Side" startLine="173" endLine="181" />
    <javadoc>
      <text>* Compute the relative position of the instance with respect to an
 * hyperplane.</text>
      <param>hyperplane reference hyperplane</param>
      <return>one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUSSide.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPERSide.HYPER} (the latter result can occur only if the tree
 * contains only one cut hyperplane)</return>
    </javadoc>
    <method name="intersection" type="SubHyperplane<S>" startLine="183" endLine="189" />
    <javadoc>
      <text>* Get the parts of a sub-hyperplane that are contained in the region.
 * <p>The parts of the sub-hyperplane that belong to the boundary are
 * <em>not</em> included in the resulting parts.</p></text>
      <param>sub sub-hyperplane traversing the region</param>
      <return>filtered sub-hyperplane</return>
    </javadoc>
  </interface>
</source>
