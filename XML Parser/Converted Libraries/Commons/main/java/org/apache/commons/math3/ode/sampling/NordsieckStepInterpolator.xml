<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.sampling">
  <import name="java.io.IOException" />
  <import name="java.io.ObjectInput" />
  <import name="java.io.ObjectOutput" />
  <import name="java.util.Arrays" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.ode.EquationsMapper" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="NordsieckStepInterpolator" extends="AbstractStepInterpolator" startLine="30">
    <javadoc>
      <text>* This class implements an interpolator for integrators using Nordsieck representation.
 * <p>This interpolator computes dense output around the current point.
 * The interpolation equation is based on Taylor series formulas.</text>
      <see>org.apache.commons.math3.ode.nonstiff.AdamsBashforthIntegrator</see>
      <see>org.apache.commons.math3.ode.nonstiff.AdamsMoultonIntegrator</see>
      <version>$Id: NordsieckStepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* State variation.</text>
    </javadoc>
    <declaration type="double[]" name="stateVariation" />
    <javadoc>
      <text>* Step size used in the first scaled derivative and Nordsieck vector.</text>
    </javadoc>
    <declaration type="double" name="scalingH" />
    <javadoc>
      <text>* Reference time for all arrays.
 * <p>Sometimes, the reference time is the same as previousTime,
 * sometimes it is the same as currentTime, so we use a separate
 * field to avoid any confusion.
 * </p></text>
    </javadoc>
    <declaration type="double" name="referenceTime" />
    <javadoc>
      <text>* First scaled derivative.</text>
    </javadoc>
    <declaration type="double[]" name="scaled" />
    <javadoc>
      <text>* Nordsieck vector.</text>
    </javadoc>
    <declaration type="Array2DRowRealMatrix" name="nordsieck" />
    <javadoc>
      <text>* Simple constructor.
 * This constructor builds an instance that is not usable yet, the{@link AbstractStepInterpolator#reinitialize} method should be called
 * before using the instance in order to initialize the internal arrays. This
 * constructor is used only in order to delay the initialization in
 * some cases.</text>
    </javadoc>
    <method type="constructor" name="NordsieckStepInterpolator" startLine="74" endLine="75" />
    <javadoc>
      <text>* Copy constructor.</text>
      <param>interpolator interpolator to copy from. The copy is a deep
 * copy: its arrays are separated from the original arrays of the
 * instance</param>
    </javadoc>
    <method type="constructor" name="NordsieckStepInterpolator" startLine="82" endLine="95">
      <scope startLine="86" endLine="88" />
      <scope startLine="89" endLine="91" />
      <scope startLine="92" endLine="94" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="StepInterpolator" name="doCopy" startLine="99" endLine="101" />
    <javadoc>
      <text>* Reinitialize the instance.
 * <p>Beware that all arrays <em>must</em> be references to integrator
 * arrays, in order to ensure proper update without copy.</p></text>
      <param>y reference to the integrator array holding the state at
 * the end of the step</param>
      <param>forward integration direction indicator</param>
      <param>primaryMapper equations mapper for the primary equations set</param>
      <param>secondaryMappers equations mappers for the secondary equations sets</param>
    </javadoc>
    <method type="void" name="reinitialize" startLine="115" endLine="118" />
    <javadoc>
      <text>* Reinitialize the instance.
 * <p>Beware that all arrays <em>must</em> be references to integrator
 * arrays, in order to ensure proper update without copy.</p></text>
      <param>time time at which all arrays are defined</param>
      <param>stepSize step size used in the scaled and nordsieck arrays</param>
      <param>scaledDerivative reference to the integrator array holding the first
 * scaled derivative</param>
      <param>nordsieckVector reference to the integrator matrix holding the
 * nordsieck vector</param>
    </javadoc>
    <method type="void" name="reinitialize" startLine="132" endLine="141">
      <comment>make sure the state and derivatives will depend on the new arrays</comment>
    </method>
    <javadoc>
      <text>* Rescale the instance.
 * <p>Since the scaled and Nordiseck arrays are shared with the caller,
 * this method has the side effect of rescaling this arrays in the caller too.</p></text>
      <param>stepSize new step size to use in the scaled and nordsieck arrays</param>
    </javadoc>
    <method type="void" name="rescale" startLine="148" endLine="167">
      <declaration type="double" name="ratio" />
      <scope startLine="151" endLine="153" />
      <declaration type="double[][]" name="nData" />
      <declaration type="double" name="power" />
      <scope startLine="157" endLine="163">
        <declaration type="double[]" name="nDataI" />
        <scope startLine="160" endLine="162" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the state vector variation from current to interpolated state.
 * <p>This method is aimed at computing y(t<sub>interpolation</sub>)
 * -y(t<sub>current</sub>) accurately by avoiding the cancellation errors
 * that would occur if the subtraction were performed explicitly.</p>
 * <p>The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.</p></text>
      <return>state vector at time {@link #getInterpolatedTime}</return>
      <see>#getInterpolatedDerivatives()</see>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method type="double[]" name="getInterpolatedStateVariation" startLine="181" endLine="186">
      <comment>compute and ignore interpolated state</comment>
      <comment>to make sure state variation is computed as a side effect</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="computeInterpolatedStateAndDerivatives" startLine="190" endLine="219">
      <declaration type="double" name="x" />
      <declaration type="double" name="normalizedAbscissa" />
      <declaration type="double[][]" name="nData" />
      <scope startLine="201" endLine="210">
        <declaration type="int" name="order" />
        <declaration type="double[]" name="nDataI" />
        <declaration type="double" name="power" />
        <scope startLine="205" endLine="209">
          <declaration type="double" name="d" />
        </scope>
      </scope>
      <scope startLine="212" endLine="217" />
      <comment>apply Taylor formula from high order to low order,</comment>
      <comment>for the sake of numerical accuracy</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="writeExternal" startLine="224" endLine="252">
      <declaration type="int" name="n" />
      <scope startLine="234" endLine="236" />
      <scope startLine="236" endLine="241">
        <scope startLine="238" endLine="240" />
      </scope>
      <scope startLine="243" endLine="245" />
      <scope startLine="245" endLine="248" />
      <comment>save the state of the base class</comment>
      <comment>save the local attributes</comment>
      <comment>we don't save state variation, it will be recomputed</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="readExternal" startLine="257" endLine="292">
      <declaration type="double" name="t" />
      <declaration type="int" name="n" />
      <declaration type="boolean" name="hasScaled" />
      <scope startLine="268" endLine="273">
        <scope startLine="270" endLine="272" />
      </scope>
      <scope startLine="273" endLine="275" />
      <declaration type="boolean" name="hasNordsieck" />
      <scope startLine="278" endLine="280" />
      <scope startLine="280" endLine="282" />
      <scope startLine="284" endLine="288">
        <comment>we can now set the interpolated time and state</comment>
      </scope>
      <scope startLine="288" endLine="290" />
      <comment>read the base class</comment>
      <comment>read the local attributes</comment>
    </method>
  </class>
</source>
