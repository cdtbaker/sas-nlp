<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.linear">
  <import name="org.apache.commons.math3.complex.Complex" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.MathUnsupportedOperationException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.Precision" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="EigenDecomposition" startLine="29">
    <javadoc>
      <text>* Calculates the eigen decomposition of a real matrix.
 * <p>The eigen decomposition of matrix A is a set of two matrices:
 * V and D such that A = V &times; D &times; V<sup>T</sup>.
 * A, V and D are all m &times; m matrices.</p>
 * <p>This class is similar in spirit to the <code>EigenvalueDecomposition</code>
 * class from the <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a>
 * library, with the following changes:</p>
 * <ul>
 * <li>a {@link #getVT() getVt} method has been added,</li>
 * <li>two {@link #getRealEigenvalue(int) getRealEigenvalue} and {@link #getImagEigenvalue(int)getImagEigenvalue} methods to pick up a single eigenvalue have been added,</li>
 * <li>a {@link #getEigenvector(int) getEigenvector} method to pick up a single
 * eigenvector has been added,</li>
 * <li>a {@link #getDeterminant() getDeterminant} method has been added.</li>
 * <li>a {@link #getSolver() getSolver} method has been added.</li>
 * </ul>
 * <p>
 * As of 3.1, this class supports general real matrices (both symmetric and non-symmetric):
 * </p>
 * <p>
 * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector
 * matrix V is orthogonal, i.e. A = V.multiply(D.multiply(V.transpose())) and
 * V.multiply(V.transpose()) equals the identity matrix.
 * </p>
 * <p>
 * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues
 * in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks:
 * <pre>
 * [lambda, mu    ]
 * [   -mu, lambda]
 * </pre>
 * The columns of V represent the eigenvectors in the sense that A*V = V*D,
 * i.e. A.multiply(V) equals V.multiply(D).
 * The matrix V may be badly conditioned, or even singular, so the validity of the equation
 * A = V*D*inverse(V) depends upon the condition of V.
 * </p>
 * <p>
 * This implementation is based on the paper by A. Drubrulle, R.S. Martin and
 * J.H. Wilkinson "The Implicit QL Algorithm" in Wilksinson and Reinsch (1971)
 * Handbook for automatic computation, vol. 2, Linear algebra, Springer-Verlag,
 * New-York
 * </p></text>
      <see><a href="http://mathworld.wolfram.com/EigenDecomposition.html">MathWorld</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">Wikipedia</a></see>
      <version>$Id: EigenDecomposition.java 1452595 2013-03-04 23:29:39Z tn $</version>
      <since>2.0 (changed to concrete class in 3.0)</since>
    </javadoc>
    <javadoc>
      <text>* Internally used epsilon criteria.</text>
    </javadoc>
    <declaration type="double" name="EPSILON" />
    <javadoc>
      <text>* Maximum number of iterations accepted in the implicit QL transformation</text>
    </javadoc>
    <declaration type="byte" name="maxIter" />
    <javadoc>
      <text>* Main diagonal of the tridiagonal matrix.</text>
    </javadoc>
    <declaration type="double[]" name="main" />
    <javadoc>
      <text>* Secondary diagonal of the tridiagonal matrix.</text>
    </javadoc>
    <declaration type="double[]" name="secondary" />
    <javadoc>
      <text>* Transformer to tridiagonal (may be null if matrix is already
 * tridiagonal).</text>
    </javadoc>
    <declaration type="TriDiagonalTransformer" name="transformer" />
    <javadoc>
      <text>* Real part of the realEigenvalues.</text>
    </javadoc>
    <declaration type="double[]" name="realEigenvalues" />
    <javadoc>
      <text>* Imaginary part of the realEigenvalues.</text>
    </javadoc>
    <declaration type="double[]" name="imagEigenvalues" />
    <javadoc>
      <text>* Eigenvectors.</text>
    </javadoc>
    <declaration type="ArrayRealVector[]" name="eigenvectors" />
    <javadoc>
      <text>* Cached value of V.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedV" />
    <javadoc>
      <text>* Cached value of D.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedD" />
    <javadoc>
      <text>* Cached value of Vt.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedVt" />
    <javadoc>
      <text>* Whether the matrix is symmetric.</text>
    </javadoc>
    <declaration type="boolean" name="isSymmetric" />
    <javadoc>
      <text>* Calculates the eigen decomposition of the given real matrix.
 * <p>
 * Supports decomposition of a general matrix since 3.1.</text>
      <param>matrix Matrix to decompose.</param>
      <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
      <throws>MathArithmeticException if the decomposition of a general matrix
 * results in a matrix with zero norm</throws>
      <since>3.1</since>
    </javadoc>
    <method type="constructor" name="EigenDecomposition" startLine="118" endLine="128">
      <declaration type="double" name="symTol" />
      <scope startLine="121" endLine="124" />
      <scope startLine="124" endLine="127">
        <declaration type="SchurTransformer" name="t" />
      </scope>
    </method>
    <javadoc>
      <text>* Calculates the eigen decomposition of the given real matrix.</text>
      <param>matrix Matrix to decompose.</param>
      <param>splitTolerance Dummy parameter (present for backward
 * compatibility only).</param>
      <throws>MathArithmeticException  if the decomposition of a general matrix
 * results in a matrix with zero norm</throws>
      <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
      <deprecated>in 3.1 (to be removed in 4.0) due to unused parameter</deprecated>
    </javadoc>
    <method type="constructor" name="EigenDecomposition" startLine="144" endLine="146" />
    <javadoc>
      <text>* Calculates the eigen decomposition of the symmetric tridiagonal
 * matrix.  The Householder matrix is assumed to be the identity matrix.</text>
      <param>main Main diagonal of the symmetric tridiagonal form.</param>
      <param>secondary Secondary of the tridiagonal form.</param>
      <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="constructor" name="EigenDecomposition" startLine="157" endLine="168">
      <declaration type="int" name="size" />
      <declaration type="double[][]" name="z" />
      <scope startLine="164" endLine="166" />
    </method>
    <javadoc>
      <text>* Calculates the eigen decomposition of the symmetric tridiagonal
 * matrix.  The Householder matrix is assumed to be the identity matrix.</text>
      <param>main Main diagonal of the symmetric tridiagonal form.</param>
      <param>secondary Secondary of the tridiagonal form.</param>
      <param>splitTolerance Dummy parameter (present for backward
 * compatibility only).</param>
      <throws>MaxCountExceededException if the algorithm fails to converge.</throws>
      <deprecated>in 3.1 (to be removed in 4.0) due to unused parameter</deprecated>
    </javadoc>
    <method type="constructor" name="EigenDecomposition" startLine="183" endLine="185" />
    <javadoc>
      <text>* Gets the matrix V of the decomposition.
 * V is an orthogonal matrix, i.e. its transpose is also its inverse.
 * The columns of V are the eigenvectors of the original matrix.
 * No assumption is made about the orientation of the system axes formed
 * by the columns of V (e.g. in a 3-dimension space, V can form a left-
 * or right-handed system).</text>
      <return>the V matrix.</return>
    </javadoc>
    <method type="RealMatrix" name="getV" startLine="197" endLine="208">
      <scope startLine="199" endLine="205">
        <declaration type="int" name="m" />
        <scope startLine="202" endLine="204" />
      </scope>
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Gets the block diagonal matrix D of the decomposition.
 * D is a block diagonal matrix.
 * Real eigenvalues are on the diagonal while complex values are on
 * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.</text>
      <return>the D matrix.</return>
      <see>#getRealEigenvalues()</see>
      <see>#getImagEigenvalues()</see>
    </javadoc>
    <method type="RealMatrix" name="getD" startLine="221" endLine="236">
      <scope startLine="223" endLine="234">
        <scope startLine="227" endLine="233">
          <scope startLine="228" endLine="230" />
          <scope startLine="230" endLine="232" />
        </scope>
        <comment>cache the matrix for subsequent calls</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Gets the transpose of the matrix V of the decomposition.
 * V is an orthogonal matrix, i.e. its transpose is also its inverse.
 * The columns of V are the eigenvectors of the original matrix.
 * No assumption is made about the orientation of the system axes formed
 * by the columns of V (e.g. in a 3-dimension space, V can form a left-
 * or right-handed system).</text>
      <return>the transpose of the V matrix.</return>
    </javadoc>
    <method type="RealMatrix" name="getVT" startLine="248" endLine="260">
      <scope startLine="250" endLine="256">
        <declaration type="int" name="m" />
        <scope startLine="253" endLine="255" />
      </scope>
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Returns whether the calculated eigen values are complex or real.
 * <p>The method performs a zero check for each element of the{@link #getImagEigenvalues()} array and returns {@code true} if any
 * element is not equal to zero.</text>
      <return>{@code true} if the eigen values are complex, {@code false} otherwise</return>
      <since>3.1</since>
    </javadoc>
    <method type="boolean" name="hasComplexEigenvalues" startLine="271" endLine="278">
      <scope startLine="272" endLine="276">
        <scope startLine="273" endLine="275" />
      </scope>
    </method>
    <javadoc>
      <text>* Gets a copy of the real parts of the eigenvalues of the original matrix.</text>
      <return>a copy of the real parts of the eigenvalues of the original matrix.</return>
      <see>#getD()</see>
      <see>#getRealEigenvalue(int)</see>
      <see>#getImagEigenvalues()</see>
    </javadoc>
    <method type="double[]" name="getRealEigenvalues" startLine="289" endLine="291" />
    <javadoc>
      <text>* Returns the real part of the i<sup>th</sup> eigenvalue of the original
 * matrix.</text>
      <param>i index of the eigenvalue (counting from 0)</param>
      <return>real part of the i<sup>th</sup> eigenvalue of the original
 * matrix.</return>
      <see>#getD()</see>
      <see>#getRealEigenvalues()</see>
      <see>#getImagEigenvalue(int)</see>
    </javadoc>
    <method type="double" name="getRealEigenvalue" startLine="305" endLine="307" />
    <javadoc>
      <text>* Gets a copy of the imaginary parts of the eigenvalues of the original
 * matrix.</text>
      <return>a copy of the imaginary parts of the eigenvalues of the original
 * matrix.</return>
      <see>#getD()</see>
      <see>#getImagEigenvalue(int)</see>
      <see>#getRealEigenvalues()</see>
    </javadoc>
    <method type="double[]" name="getImagEigenvalues" startLine="320" endLine="322" />
    <javadoc>
      <text>* Gets the imaginary part of the i<sup>th</sup> eigenvalue of the original
 * matrix.</text>
      <param>i Index of the eigenvalue (counting from 0).</param>
      <return>the imaginary part of the i<sup>th</sup> eigenvalue of the original
 * matrix.</return>
      <see>#getD()</see>
      <see>#getImagEigenvalues()</see>
      <see>#getRealEigenvalue(int)</see>
    </javadoc>
    <method type="double" name="getImagEigenvalue" startLine="336" endLine="338" />
    <javadoc>
      <text>* Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.</text>
      <param>i Index of the eigenvector (counting from 0).</param>
      <return>a copy of the i<sup>th</sup> eigenvector of the original matrix.</return>
      <see>#getD()</see>
    </javadoc>
    <method type="RealVector" name="getEigenvector" startLine="347" endLine="349" />
    <javadoc>
      <text>* Computes the determinant of the matrix.</text>
      <return>the determinant of the matrix.</return>
    </javadoc>
    <method type="double" name="getDeterminant" startLine="356" endLine="362">
      <declaration type="double" name="determinant" />
      <scope startLine="358" endLine="360" />
    </method>
    <javadoc>
      <text>* Computes the square-root of the matrix.
 * This implementation assumes that the matrix is symmetric and positive
 * definite.</text>
      <return>the square-root of the matrix.</return>
      <throws>MathUnsupportedOperationException if the matrix is not
 * symmetric or not positive definite.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="RealMatrix" name="getSquareRoot" startLine="374" endLine="392">
      <scope startLine="375" endLine="377" />
      <declaration type="double[]" name="sqrtEigenValues" />
      <scope startLine="380" endLine="386">
        <declaration type="double" name="eigen" />
        <scope startLine="382" endLine="384" />
      </scope>
      <declaration type="RealMatrix" name="sqrtEigen" />
      <declaration type="RealMatrix" name="v" />
      <declaration type="RealMatrix" name="vT" />
    </method>
    <javadoc>
      <text>* Gets a solver for finding the A &times; X = B solution in exact
 * linear sense.
 * <p>
 * Since 3.1, eigen decomposition of a general matrix is supported,
 * but the {@link DecompositionSolver} only supports real eigenvalues.</text>
      <return>a solver</return>
      <throws>MathUnsupportedOperationException if the decomposition resulted in
 * complex eigenvalues</throws>
    </javadoc>
    <method type="DecompositionSolver" name="getSolver" startLine="405" endLine="410">
      <scope startLine="406" endLine="408" />
    </method>
    <class name="Solver" startLine="412">
      <implements name="DecompositionSolver" />
      <javadoc>
        <text>* Specialized solver.</text>
      </javadoc>
      <javadoc>
        <text>* Real part of the realEigenvalues.</text>
      </javadoc>
      <declaration type="double[]" name="realEigenvalues" />
      <javadoc>
        <text>* Imaginary part of the realEigenvalues.</text>
      </javadoc>
      <declaration type="double[]" name="imagEigenvalues" />
      <javadoc>
        <text>* Eigenvectors.</text>
      </javadoc>
      <declaration type="ArrayRealVector[]" name="eigenvectors" />
      <javadoc>
        <text>* Builds a solver from decomposed matrix.</text>
        <param>realEigenvalues Real parts of the eigenvalues.</param>
        <param>imagEigenvalues Imaginary parts of the eigenvalues.</param>
        <param>eigenvectors Eigenvectors.</param>
      </javadoc>
      <method type="constructor" name="Solver" startLine="430" endLine="434" />
      <javadoc>
        <text>* Solves the linear equation A &times; X = B for symmetric matrices A.
 * <p>
 * This method only finds exact linear solutions, i.e. solutions for
 * which ||A &times; X - B|| is exactly 0.
 * </p></text>
        <param>b Right-hand side of the equation A &times; X = B.</param>
        <return>a Vector X that minimizes the two norm of A &times; X - B.</return>
        <throws>DimensionMismatchException if the matrices dimensions do not match.</throws>
        <throws>SingularMatrixException if the decomposed matrix is singular.</throws>
      </javadoc>
      <method type="RealVector" name="solve" startLine="449" endLine="470">
        <scope startLine="450" endLine="452" />
        <declaration type="int" name="m" />
        <scope startLine="455" endLine="457" />
        <declaration type="double[]" name="bp" />
        <scope startLine="460" endLine="467">
          <declaration type="ArrayRealVector" name="v" />
          <declaration type="double[]" name="vData" />
          <declaration type="double" name="s" />
          <scope startLine="464" endLine="466" />
        </scope>
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="RealMatrix" name="solve" startLine="473" endLine="508">
        <scope startLine="475" endLine="477" />
        <declaration type="int" name="m" />
        <scope startLine="480" endLine="482" />
        <declaration type="int" name="nColB" />
        <declaration type="double[][]" name="bp" />
        <declaration type="double[]" name="tmpCol" />
        <scope startLine="487" endLine="504">
          <scope startLine="488" endLine="491" />
          <scope startLine="492" endLine="503">
            <declaration type="ArrayRealVector" name="v" />
            <declaration type="double[]" name="vData" />
            <declaration type="double" name="s" />
            <scope startLine="496" endLine="498" />
            <scope startLine="500" endLine="502" />
          </scope>
        </scope>
      </method>
      <javadoc>
        <text>* Checks whether the decomposed matrix is non-singular.</text>
        <return>true if the decomposed matrix is non-singular.</return>
      </javadoc>
      <method type="boolean" name="isNonSingular" startLine="515" endLine="523">
        <scope startLine="516" endLine="521">
          <scope startLine="518" endLine="520" />
        </scope>
      </method>
      <javadoc>
        <text>* Get the inverse of the decomposed matrix.</text>
        <return>the inverse matrix.</return>
        <throws>SingularMatrixException if the decomposed matrix is singular.</throws>
      </javadoc>
      <method type="RealMatrix" name="getInverse" startLine="531" endLine="551">
        <scope startLine="532" endLine="534" />
        <declaration type="int" name="m" />
        <declaration type="double[][]" name="invData" />
        <scope startLine="539" endLine="549">
          <declaration type="double[]" name="invI" />
          <scope startLine="541" endLine="548">
            <declaration type="double" name="invIJ" />
            <scope startLine="543" endLine="546">
              <declaration type="double[]" name="vK" />
            </scope>
          </scope>
        </scope>
      </method>
      <javadoc>
        <text>* Transforms the matrix to tridiagonal form.</text>
        <param>matrix Matrix to transform.</param>
      </javadoc>
      <method type="void" name="transformToTridiagonal" startLine="559" endLine="564">
        <comment>transform the matrix to tridiagonal</comment>
      </method>
      <javadoc>
        <text>* Find eigenvalues and eigenvectors (Dubrulle et al., 1971)</text>
        <param>householderMatrix Householder matrix of the transformation
 * to tridiagonal form.</param>
      </javadoc>
      <method type="void" name="findEigenVectors" startLine="572" endLine="721">
        <declaration type="double[][]" name="z" />
        <declaration type="int" name="n" />
        <declaration type="double[]" name="e" />
        <scope startLine="578" endLine="581" />
        <declaration type="double" name="maxAbsoluteValue" />
        <scope startLine="587" endLine="594">
          <scope startLine="588" endLine="590" />
          <scope startLine="591" endLine="593" />
        </scope>
        <scope startLine="596" endLine="605">
          <scope startLine="597" endLine="604">
            <scope startLine="598" endLine="600" />
            <scope startLine="601" endLine="603" />
          </scope>
        </scope>
        <scope startLine="607" endLine="675">
          <declaration type="int" name="its" />
          <declaration type="int" name="m" />
          <scope startLine="610" endLine="674">
            <scope startLine="611" endLine="617">
              <declaration type="double" name="delta" />
              <scope startLine="614" endLine="616" />
            </scope>
            <scope startLine="618" endLine="673">
              <scope startLine="619" endLine="622" />
              <declaration type="double" name="q" />
              <declaration type="double" name="t" />
              <scope startLine="626" endLine="628" />
              <scope startLine="628" endLine="630" />
              <declaration type="double" name="u" />
              <declaration type="double" name="s" />
              <declaration type="double" name="c" />
              <declaration type="int" name="i" />
              <scope startLine="635" endLine="666">
                <declaration type="double" name="p" />
                <declaration type="double" name="h" />
                <scope startLine="638" endLine="644" />
                <scope startLine="644" endLine="650" />
                <scope startLine="651" endLine="655" />
                <scope startLine="661" endLine="665" />
              </scope>
              <scope startLine="667" endLine="669" />
            </scope>
          </scope>
        </scope>
        <scope startLine="678" endLine="696">
          <declaration type="int" name="k" />
          <declaration type="double" name="p" />
          <scope startLine="681" endLine="686">
            <scope startLine="682" endLine="685" />
          </scope>
          <scope startLine="687" endLine="695">
            <scope startLine="690" endLine="694" />
          </scope>
        </scope>
        <scope startLine="700" endLine="704">
          <scope startLine="701" endLine="703" />
        </scope>
        <scope startLine="706" endLine="712">
          <scope startLine="707" endLine="711">
            <scope startLine="708" endLine="710" />
          </scope>
        </scope>
        <declaration type="double[]" name="tmp" />
        <scope startLine="715" endLine="720">
          <scope startLine="716" endLine="718" />
        </scope>
        <comment>Determine the largest main and secondary value in absolute term.</comment>
        <comment>Make null any main and secondary value too small to be significant</comment>
        <comment>Sort the eigen values (and vectors) in increase order</comment>
        <comment>Determine the largest eigen value in absolute term.</comment>
        <comment>Make null any eigen value too small to be significant</comment>
      </method>
      <javadoc>
        <text>* Transforms the matrix to Schur form and calculates the eigenvalues.</text>
        <param>matrix Matrix to transform.</param>
        <return>the {@link SchurTransformer Shur transform} for this matrix</return>
      </javadoc>
      <method type="SchurTransformer" name="transformToSchur" startLine="729" endLine="752">
        <declaration type="SchurTransformer" name="schurTransform" />
        <declaration type="double[][]" name="matT" />
        <scope startLine="736" endLine="750">
          <scope startLine="738" endLine="740" />
          <scope startLine="740" endLine="749">
            <declaration type="double" name="x" />
            <declaration type="double" name="p" />
            <declaration type="double" name="z" />
          </scope>
        </scope>
      </method>
      <javadoc>
        <text>* Performs a division of two complex numbers.</text>
        <param>xr real part of the first number</param>
        <param>xi imaginary part of the first number</param>
        <param>yr real part of the second number</param>
        <param>yi imaginary part of the second number</param>
        <return>result of the complex division</return>
      </javadoc>
      <method type="Complex" name="cdiv" startLine="764" endLine="766" />
      <javadoc>
        <text>* Find eigenvectors from a matrix transformed to Schur form.</text>
        <param>schur the schur transformation of the matrix</param>
        <throws>MathArithmeticException if the Schur form has a norm of zero</throws>
      </javadoc>
      <method type="void" name="findEigenVectorsFromSchur" startLine="775" endLine="958">
        <declaration type="double[][]" name="matrixT" />
        <declaration type="double[][]" name="matrixP" />
        <declaration type="int" name="n" />
        <declaration type="double" name="norm" />
        <scope startLine="783" endLine="787">
          <scope startLine="784" endLine="786" />
        </scope>
        <scope startLine="790" endLine="792" />
        <declaration type="double" name="r" />
        <declaration type="double" name="s" />
        <declaration type="double" name="z" />
        <scope startLine="800" endLine="928">
          <declaration type="double" name="p" />
          <declaration type="double" name="q" />
          <scope startLine="804" endLine="849">
            <declaration type="int" name="l" />
            <scope startLine="808" endLine="848">
              <declaration type="double" name="w" />
              <scope startLine="811" endLine="813" />
              <scope startLine="814" endLine="817" />
              <scope startLine="817" endLine="847">
                <scope startLine="819" endLine="825">
                  <scope startLine="820" endLine="822" />
                  <scope startLine="822" endLine="824" />
                </scope>
                <scope startLine="825" endLine="838">
                  <declaration type="double" name="x" />
                  <declaration type="double" name="y" />
                  <declaration type="double" name="t" />
                  <scope startLine="833" endLine="835" />
                  <scope startLine="835" endLine="837" />
                </scope>
                <declaration type="double" name="t" />
                <scope startLine="842" endLine="846">
                  <scope startLine="843" endLine="845" />
                </scope>
              </scope>
            </scope>
          </scope>
          <scope startLine="849" endLine="927">
            <declaration type="int" name="l" />
            <scope startLine="854" endLine="857" />
            <scope startLine="857" endLine="862">
              <declaration type="Complex" name="result" />
            </scope>
            <scope startLine="867" endLine="926">
              <declaration type="double" name="ra" />
              <declaration type="double" name="sa" />
              <scope startLine="870" endLine="873" />
              <declaration type="double" name="w" />
              <scope startLine="876" endLine="880" />
              <scope startLine="880" endLine="925">
                <scope startLine="882" endLine="886">
                  <declaration type="Complex" name="c" />
                </scope>
                <scope startLine="886" endLine="914">
                  <declaration type="double" name="x" />
                  <declaration type="double" name="y" />
                  <declaration type="double" name="vr" />
                  <declaration type="double" name="vi" />
                  <scope startLine="893" endLine="897" />
                  <declaration type="Complex" name="c" />
                  <scope startLine="903" endLine="908" />
                  <scope startLine="908" endLine="913">
                    <declaration type="Complex" name="c2" />
                  </scope>
                </scope>
                <declaration type="double" name="t" />
                <scope startLine="919" endLine="924">
                  <scope startLine="920" endLine="923" />
                </scope>
              </scope>
            </scope>
          </scope>
          <comment>Real vector</comment>
          <comment>Solve real equations</comment>
          <comment>Overflow control</comment>
          <comment>Complex vector</comment>
          <comment>Last vector component imaginary so matrix is triangular</comment>
          <comment>Solve complex equations</comment>
          <comment>Overflow control</comment>
        </scope>
        <scope startLine="931" endLine="937">
          <scope startLine="932" endLine="936">
            <scope startLine="933" endLine="935" />
          </scope>
        </scope>
        <scope startLine="940" endLine="948">
          <scope startLine="941" endLine="947">
            <scope startLine="943" endLine="945" />
          </scope>
        </scope>
        <declaration type="double[]" name="tmp" />
        <scope startLine="952" endLine="957">
          <scope startLine="953" endLine="955" />
        </scope>
        <comment>compute matrix norm</comment>
        <comment>we can not handle a matrix with zero norm</comment>
        <comment>Backsubstitute to find vectors of upper triangular form</comment>
        <comment>Vectors of isolated roots</comment>
        <comment>Back transformation to get eigenvectors of original matrix</comment>
      </method>
    </class>
  </class>
</source>
