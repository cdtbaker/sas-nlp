<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optimization.direct">
  <import name="java.util.ArrayList" />
  <import name="java.util.Arrays" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.exception.TooManyEvaluationsException" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.linear.EigenDecomposition" />
  <import name="org.apache.commons.math3.linear.MatrixUtils" />
  <import name="org.apache.commons.math3.linear.RealMatrix" />
  <import name="org.apache.commons.math3.optimization.ConvergenceChecker" />
  <import name="org.apache.commons.math3.optimization.OptimizationData" />
  <import name="org.apache.commons.math3.optimization.GoalType" />
  <import name="org.apache.commons.math3.optimization.MultivariateOptimizer" />
  <import name="org.apache.commons.math3.optimization.PointValuePair" />
  <import name="org.apache.commons.math3.optimization.SimpleValueChecker" />
  <import name="org.apache.commons.math3.random.MersenneTwister" />
  <import name="org.apache.commons.math3.random.RandomGenerator" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="CMAESOptimizer" extends="BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>" startLine="44">
    <implements name="MultivariateOptimizer" />
    <javadoc>
      <text>* <p>An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES)
 * for non-linear, non-convex, non-smooth, global function minimization.
 * The CMA-Evolution Strategy (CMA-ES) is a reliable stochastic optimization method
 * which should be applied if derivative-based methods, e.g. quasi-Newton BFGS or
 * conjugate gradient, fail due to a rugged search landscape (e.g. noise, local
 * optima, outlier, etc.) of the objective function. Like a
 * quasi-Newton method, the CMA-ES learns and applies a variable metric
 * on the underlying search space. Unlike a quasi-Newton method, the
 * CMA-ES neither estimates nor uses gradients, making it considerably more
 * reliable in terms of finding a good, or even close to optimal, solution.</p>
 * <p>In general, on smooth objective functions the CMA-ES is roughly ten times
 * slower than BFGS (counting objective function evaluations, no gradients provided).
 * For up to <math>N=10</math> variables also the derivative-free simplex
 * direct search method (Nelder and Mead) can be faster, but it is
 * far less reliable than CMA-ES.</p>
 * <p>The CMA-ES is particularly well suited for non-separable
 * and/or badly conditioned problems. To observe the advantage of CMA compared
 * to a conventional evolution strategy, it will usually take about
 * <math>30 N</math> function evaluations. On difficult problems the complete
 * optimization (a single run) is expected to take <em>roughly</em> between
 * <math>30 N</math> and <math>300 N<sup>2</sup></math>
 * function evaluations.</p>
 * <p>This implementation is translated and adapted from the Matlab version
 * of the CMA-ES algorithm as implemented in module {@code cmaes.m} version 3.51.</p>
 * For more information, please refer to the following links:
 * <ul>
 * <li><a href="http://www.lri.fr/~hansen/cmaes.m">Matlab code</a></li>
 * <li><a href="http://www.lri.fr/~hansen/cmaesintro.html">Introduction to CMA-ES</a></li>
 * <li><a href="http://en.wikipedia.org/wiki/CMA-ES">Wikipedia</a></li>
 * </ul></text>
      <version>$Id: CMAESOptimizer.java 1462503 2013-03-29 15:48:27Z luc $</version>
      <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Default value for {@link #checkFeasableCount}: {@value}.</text>
    </javadoc>
    <declaration type="int" name="DEFAULT_CHECKFEASABLECOUNT" />
    <javadoc>
      <text>* Default value for {@link #stopFitness}: {@value}.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_STOPFITNESS" />
    <javadoc>
      <text>* Default value for {@link #isActiveCMA}: {@value}.</text>
    </javadoc>
    <declaration type="boolean" name="DEFAULT_ISACTIVECMA" />
    <javadoc>
      <text>* Default value for {@link #maxIterations}: {@value}.</text>
    </javadoc>
    <declaration type="int" name="DEFAULT_MAXITERATIONS" />
    <javadoc>
      <text>* Default value for {@link #diagonalOnly}: {@value}.</text>
    </javadoc>
    <declaration type="int" name="DEFAULT_DIAGONALONLY" />
    <javadoc>
      <text>* Default value for {@link #random}.</text>
    </javadoc>
    <declaration type="RandomGenerator" name="DEFAULT_RANDOMGENERATOR" />
    <javadoc>
      <text>* Population size, offspring number. The primary strategy parameter to play
 * with, which can be increased from its default value. Increasing the
 * population size improves global search properties in exchange to speed.
 * Speed decreases, as a rule, at most linearly with increasing population
 * size. It is advisable to begin with the default small population size.</text>
    </javadoc>
    <declaration type="int" name="lambda" />
    <javadoc>
      <text>* Covariance update mechanism, default is active CMA. isActiveCMA = true
 * turns on "active CMA" with a negative update of the covariance matrix and
 * checks for positive definiteness. OPTS.CMA.active = 2 does not check for
 * pos. def. and is numerically faster. Active CMA usually speeds up the
 * adaptation.</text>
    </javadoc>
    <declaration type="boolean" name="isActiveCMA" />
    <javadoc>
      <text>* Determines how often a new random offspring is generated in case it is
 * not feasible / beyond the defined limits, default is 0.</text>
    </javadoc>
    <declaration type="int" name="checkFeasableCount" />
    <javadoc>
      <see>Sigma</see>
    </javadoc>
    <declaration type="double[]" name="inputSigma" />
    <javadoc>
      <text>* Number of objective variables/problem dimension</text>
    </javadoc>
    <declaration type="int" name="dimension" />
    <javadoc>
      <text>* Defines the number of initial iterations, where the covariance matrix
 * remains diagonal and the algorithm has internally linear time complexity.
 * diagonalOnly = 1 means keeping the covariance matrix always diagonal and
 * this setting also exhibits linear space complexity. This can be
 * particularly useful for dimension > 100.</text>
      <see><a href="http://hal.archives-ouvertes.fr/inria-00287367/en">A Simple Modification in CMA-ES</a></see>
    </javadoc>
    <declaration type="int" name="diagonalOnly" />
    <javadoc>
      <text>* Number of objective variables/problem dimension</text>
    </javadoc>
    <declaration type="boolean" name="isMinimize" />
    <javadoc>
      <text>* Indicates whether statistic data is collected.</text>
    </javadoc>
    <declaration type="boolean" name="generateStatistics" />
    <javadoc>
      <text>* Maximal number of iterations allowed.</text>
    </javadoc>
    <declaration type="int" name="maxIterations" />
    <javadoc>
      <text>* Limit for fitness value.</text>
    </javadoc>
    <declaration type="double" name="stopFitness" />
    <javadoc>
      <text>* Stop if x-changes larger stopTolUpX.</text>
    </javadoc>
    <declaration type="double" name="stopTolUpX" />
    <javadoc>
      <text>* Stop if x-change smaller stopTolX.</text>
    </javadoc>
    <declaration type="double" name="stopTolX" />
    <javadoc>
      <text>* Stop if fun-changes smaller stopTolFun.</text>
    </javadoc>
    <declaration type="double" name="stopTolFun" />
    <javadoc>
      <text>* Stop if back fun-changes smaller stopTolHistFun.</text>
    </javadoc>
    <declaration type="double" name="stopTolHistFun" />
    <javadoc>
      <text>* Number of parents/points for recombination.</text>
    </javadoc>
    <declaration type="int" name="mu" />
    <javadoc>
      <text>* log(mu + 0.5), stored for efficiency.</text>
    </javadoc>
    <declaration type="double" name="logMu2" />
    <javadoc>
      <text>* Array for weighted recombination.</text>
    </javadoc>
    <declaration type="RealMatrix" name="weights" />
    <javadoc>
      <text>* Variance-effectiveness of sum w_i x_i.</text>
    </javadoc>
    <declaration type="double" name="mueff" />
    <javadoc>
      <text>* Overall standard deviation - search volume.</text>
    </javadoc>
    <declaration type="double" name="sigma" />
    <javadoc>
      <text>* Cumulation constant.</text>
    </javadoc>
    <declaration type="double" name="cc" />
    <javadoc>
      <text>* Cumulation constant for step-size.</text>
    </javadoc>
    <declaration type="double" name="cs" />
    <javadoc>
      <text>* Damping for step-size.</text>
    </javadoc>
    <declaration type="double" name="damps" />
    <javadoc>
      <text>* Learning rate for rank-one update.</text>
    </javadoc>
    <declaration type="double" name="ccov1" />
    <javadoc>
      <text>* Learning rate for rank-mu update'</text>
    </javadoc>
    <declaration type="double" name="ccovmu" />
    <javadoc>
      <text>* Expectation of ||N(0,I)|| == norm(randn(N,1)).</text>
    </javadoc>
    <declaration type="double" name="chiN" />
    <javadoc>
      <text>* Learning rate for rank-one update - diagonalOnly</text>
    </javadoc>
    <declaration type="double" name="ccov1Sep" />
    <javadoc>
      <text>* Learning rate for rank-mu update - diagonalOnly</text>
    </javadoc>
    <declaration type="double" name="ccovmuSep" />
    <javadoc>
      <text>* Objective variables.</text>
    </javadoc>
    <declaration type="RealMatrix" name="xmean" />
    <javadoc>
      <text>* Evolution path.</text>
    </javadoc>
    <declaration type="RealMatrix" name="pc" />
    <javadoc>
      <text>* Evolution path for sigma.</text>
    </javadoc>
    <declaration type="RealMatrix" name="ps" />
    <javadoc>
      <text>* Norm of ps, stored for efficiency.</text>
    </javadoc>
    <declaration type="double" name="normps" />
    <javadoc>
      <text>* Coordinate system.</text>
    </javadoc>
    <declaration type="RealMatrix" name="B" />
    <javadoc>
      <text>* Scaling.</text>
    </javadoc>
    <declaration type="RealMatrix" name="D" />
    <javadoc>
      <text>* B*D, stored for efficiency.</text>
    </javadoc>
    <declaration type="RealMatrix" name="BD" />
    <javadoc>
      <text>* Diagonal of sqrt(D), stored for efficiency.</text>
    </javadoc>
    <declaration type="RealMatrix" name="diagD" />
    <javadoc>
      <text>* Covariance matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="C" />
    <javadoc>
      <text>* Diagonal of C, used for diagonalOnly.</text>
    </javadoc>
    <declaration type="RealMatrix" name="diagC" />
    <javadoc>
      <text>* Number of iterations already performed.</text>
    </javadoc>
    <declaration type="int" name="iterations" />
    <javadoc>
      <text>* History queue of best values.</text>
    </javadoc>
    <declaration type="double[]" name="fitnessHistory" />
    <javadoc>
      <text>* Size of history queue of best values.</text>
    </javadoc>
    <declaration type="int" name="historySize" />
    <javadoc>
      <text>* Random generator.</text>
    </javadoc>
    <declaration type="RandomGenerator" name="random" />
    <javadoc>
      <text>* History of sigma values.</text>
    </javadoc>
    <declaration type="List<Double>" name="statisticsSigmaHistory" />
    <javadoc>
      <text>* History of mean matrix.</text>
    </javadoc>
    <declaration type="List<RealMatrix>" name="statisticsMeanHistory" />
    <javadoc>
      <text>* History of fitness values.</text>
    </javadoc>
    <declaration type="List<Double>" name="statisticsFitnessHistory" />
    <javadoc>
      <text>* History of D matrix.</text>
    </javadoc>
    <declaration type="List<RealMatrix>" name="statisticsDHistory" />
    <javadoc>
      <text>* Default constructor, uses default parameters</text>
      <deprecated>As of version 3.1: Parameter {@code lambda} must be
 * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])optimize} (whereas in the current code it is set to an undocumented value).</deprecated>
    </javadoc>
    <method type="constructor" name="CMAESOptimizer" startLine="236" endLine="238" />
    <javadoc>
      <param>lambda Population size.</param>
      <deprecated>As of version 3.1: Parameter {@code lambda} must be
 * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])optimize} (whereas in the current code it is set to an undocumented value)..</deprecated>
    </javadoc>
    <method type="constructor" name="CMAESOptimizer" startLine="246" endLine="251" />
    <javadoc>
      <param>lambda Population size.</param>
      <param>inputSigma Initial standard deviations to sample new points
 * around the initial guess.</param>
      <deprecated>As of version 3.1: Parameters {@code lambda} and {@code inputSigma} must be
 * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])optimize}.</deprecated>
    </javadoc>
    <method type="constructor" name="CMAESOptimizer" startLine="262" endLine="266" />
    <javadoc>
      <param>lambda Population size.</param>
      <param>inputSigma Initial standard deviations to sample new points
 * around the initial guess.</param>
      <param>maxIterations Maximal number of iterations.</param>
      <param>stopFitness Whether to stop if objective function value is smaller than{@code stopFitness}.</param>
      <param>isActiveCMA Chooses the covariance matrix update method.</param>
      <param>diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.</param>
      <param>checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.</param>
      <param>random Random generator.</param>
      <param>generateStatistics Whether statistic data is collected.</param>
      <deprecated>See {@link SimpleValueChecker#SimpleValueChecker()}</deprecated>
    </javadoc>
    <method type="constructor" name="CMAESOptimizer" startLine="288" endLine="292" />
    <javadoc>
      <param>lambda Population size.</param>
      <param>inputSigma Initial standard deviations to sample new points
 * around the initial guess.</param>
      <param>maxIterations Maximal number of iterations.</param>
      <param>stopFitness Whether to stop if objective function value is smaller than{@code stopFitness}.</param>
      <param>isActiveCMA Chooses the covariance matrix update method.</param>
      <param>diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.</param>
      <param>checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.</param>
      <param>random Random generator.</param>
      <param>generateStatistics Whether statistic data is collected.</param>
      <param>checker Convergence checker.</param>
      <deprecated>As of version 3.1: Parameters {@code lambda} and {@code inputSigma} must be
 * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])optimize}.</deprecated>
    </javadoc>
    <method type="constructor" name="CMAESOptimizer" startLine="318" endLine="329" />
    <javadoc>
      <param>maxIterations Maximal number of iterations.</param>
      <param>stopFitness Whether to stop if objective function value is smaller than{@code stopFitness}.</param>
      <param>isActiveCMA Chooses the covariance matrix update method.</param>
      <param>diagonalOnly Number of initial iterations, where the covariance matrix
 * remains diagonal.</param>
      <param>checkFeasableCount Determines how often new random objective variables are
 * generated in case they are out of bounds.</param>
      <param>random Random generator.</param>
      <param>generateStatistics Whether statistic data is collected.</param>
      <param>checker Convergence checker.</param>
      <since>3.1</since>
    </javadoc>
    <method type="constructor" name="CMAESOptimizer" startLine="353" endLine="362" />
    <javadoc>
      <return>History of sigma values.</return>
    </javadoc>
    <method type="List<Double>" name="getStatisticsSigmaHistory" startLine="367" endLine="369" />
    <javadoc>
      <return>History of mean matrix.</return>
    </javadoc>
    <method type="List<RealMatrix>" name="getStatisticsMeanHistory" startLine="374" endLine="376" />
    <javadoc>
      <return>History of fitness values.</return>
    </javadoc>
    <method type="List<Double>" name="getStatisticsFitnessHistory" startLine="381" endLine="383" />
    <javadoc>
      <return>History of D matrix.</return>
    </javadoc>
    <method type="List<RealMatrix>" name="getStatisticsDHistory" startLine="388" endLine="390" />
    <class name="Sigma" startLine="392">
      <implements name="OptimizationData" />
      <javadoc>
        <text>* Input sigma values.
 * They define the initial coordinate-wise standard deviations for
 * sampling new search points around the initial guess.
 * It is suggested to set them to the estimated distance from the
 * initial to the desired optimum.
 * Small values induce the search to be more local (and very small
 * values are more likely to find a local optimum close to the initial
 * guess).
 * Too small values might however lead to early termination.</text>
        <since>3.1</since>
      </javadoc>
      <javadoc>
        <text>* Sigma values.</text>
      </javadoc>
      <declaration type="double[]" name="sigma" />
      <javadoc>
        <param>s Sigma values.</param>
        <throws>NotPositiveException if any of the array entries is smaller
 * than zero.</throws>
      </javadoc>
      <method type="constructor" name="Sigma" startLine="414" endLine="422">
        <scope startLine="415" endLine="419">
          <scope startLine="416" endLine="418" />
        </scope>
      </method>
      <javadoc>
        <return>the sigma values.</return>
      </javadoc>
      <method type="double[]" name="getSigma" startLine="427" endLine="429" />
      <class name="PopulationSize" startLine="432">
        <implements name="OptimizationData" />
        <javadoc>
          <text>* Population size.
 * The number of offspring is the primary strategy parameter.
 * In the absence of better clues, a good default could be an
 * integer close to {@code 4 + 3 ln(n)}, where {@code n} is the
 * number of optimized parameters.
 * Increasing the population size improves global search properties
 * at the expense of speed (which in general decreases at most
 * linearly with increasing population size).</text>
          <since>3.1</since>
        </javadoc>
        <javadoc>
          <text>* Population size.</text>
        </javadoc>
        <declaration type="int" name="lambda" />
        <javadoc>
          <param>size Population size.</param>
          <throws>NotStrictlyPositiveException if {@code size <= 0}.</throws>
        </javadoc>
        <method type="constructor" name="PopulationSize" startLine="452" endLine="457">
          <scope startLine="453" endLine="455" />
        </method>
        <javadoc>
          <return>the population size.</return>
        </javadoc>
        <method type="int" name="getPopulationSize" startLine="462" endLine="464" />
        <javadoc>
          <text>* Optimize an objective function.</text>
          <param>maxEval Allowed number of evaluations of the objective function.</param>
          <param>f Objective function.</param>
          <param>goalType Optimization type.</param>
          <param>optData Optimization data. The following data will be looked for:
 * <ul>
 * <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>
 * <li>{@link Sigma}</li>
 * <li>{@link PopulationSize}</li>
 * </ul></param>
          <return>the point/value pair giving the optimal value for objective
 * function.</return>
        </javadoc>
        <method type="PointValuePair" name="optimizeInternal" startLine="485" endLine="492">
          <comment>Scan "optData" for the input specific to this optimizer.</comment>
          <comment>The parent's method will retrieve the common parameters from</comment>
          <comment>"optData" and call "doOptimize".</comment>
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="PointValuePair" name="doOptimize" startLine="496" endLine="638">
          <declaration type="FitnessFunction" name="fitfun" />
          <declaration type="double[]" name="guess" />
          <declaration type="double" name="bestValue" />
          <declaration type="PointValuePair" name="optimum" />
          <declaration type="PointValuePair" name="lastResult" />
          <scope startLine="515" endLine="636">
            <declaration type="RealMatrix" name="arz" />
            <declaration type="RealMatrix" name="arx" />
            <declaration type="double[]" name="fitness" />
            <scope startLine="521" endLine="544">
              <declaration type="RealMatrix" name="arxk" />
              <scope startLine="523" endLine="537">
                <scope startLine="524" endLine="527" />
                <scope startLine="527" endLine="530" />
                <scope startLine="532" endLine="534" />
              </scope>
              <scope startLine="539" endLine="541" />
              <scope startLine="541" endLine="543" />
            </scope>
            <declaration type="int[]" name="arindex" />
            <declaration type="RealMatrix" name="xold" />
            <declaration type="RealMatrix" name="bestArx" />
            <declaration type="RealMatrix" name="bestArz" />
            <declaration type="RealMatrix" name="zmean" />
            <declaration type="boolean" name="hsig" />
            <scope startLine="554" endLine="556" />
            <scope startLine="556" endLine="558" />
            <declaration type="double" name="bestFitness" />
            <declaration type="double" name="worstFitness" />
            <scope startLine="563" endLine="572">
              <scope startLine="569" endLine="571" />
            </scope>
            <scope startLine="575" endLine="577" />
            <declaration type="double[]" name="sqrtDiagC" />
            <declaration type="double[]" name="pcCol" />
            <scope startLine="580" endLine="587">
              <scope startLine="581" endLine="583" />
              <scope startLine="584" endLine="586" />
            </scope>
            <scope startLine="588" endLine="592">
              <scope startLine="589" endLine="591" />
            </scope>
            <declaration type="double" name="historyBest" />
            <declaration type="double" name="historyWorst" />
            <scope startLine="597" endLine="599" />
            <scope startLine="601" endLine="603" />
            <scope startLine="605" endLine="607" />
            <scope startLine="609" endLine="618">
              <declaration type="PointValuePair" name="current" />
              <scope startLine="614" endLine="616" />
            </scope>
            <scope startLine="620" endLine="622" />
            <scope startLine="624" endLine="626" />
            <scope startLine="630" endLine="635" />
            <comment>Generate and evaluate lambda offspring</comment>
            <comment>generate random offspring</comment>
            <comment>m + sig * Normal(0,C)</comment>
            <comment>regenerate random arguments for row</comment>
            <comment>compute fitness</comment>
            <comment>Sort by fitness and compute weighted mean into xmean</comment>
            <comment>Calculate new xmean, this is selection and recombination</comment>
            <comment>for speed up of Eq. (2) and (3)</comment>
            <comment>Adapt step size sigma - Eq. (5)</comment>
            <comment>handle termination criteria</comment>
            <comment>Break, if fitness is good enough</comment>
            <comment>condition number of the covariance matrix exceeds 1e14</comment>
            <comment>user defined termination</comment>
            <comment>Adjust step size in case of equal function values (flat fitness)</comment>
            <comment>store best in history</comment>
          </scope>
          <comment>-------------------- Initialization --------------------------------</comment>
          <comment>number of objective variables/problem dimension</comment>
          <comment>-------------------- Generation Loop --------------------------------</comment>
        </method>
        <javadoc>
          <text>* Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
          <param>optData Optimization data. The following data will be looked for:
 * <ul>
 * <li>{@link Sigma}</li>
 * <li>{@link PopulationSize}</li>
 * </ul></param>
        </javadoc>
        <method type="void" name="parseOptimizationData" startLine="650" endLine="663">
          <scope startLine="653" endLine="662">
            <scope startLine="654" endLine="657" />
            <scope startLine="658" endLine="661" />
          </scope>
          <comment>The existing values (as set by the previous call) are reused if</comment>
          <comment>not provided in the argument list.</comment>
        </method>
        <javadoc>
          <text>* Checks dimensions and values of boundaries and inputSigma if defined.</text>
        </javadoc>
        <method type="void" name="checkParameters" startLine="668" endLine="687">
          <declaration type="double[]" name="init" />
          <declaration type="double[]" name="lB" />
          <declaration type="double[]" name="uB" />
          <scope startLine="673" endLine="686">
            <scope startLine="674" endLine="676" />
            <scope startLine="677" endLine="685">
              <scope startLine="678" endLine="681" />
              <scope startLine="682" endLine="684" />
            </scope>
            <comment>XXX Remove this block in 4.0 (check performed in "Sigma" class).</comment>
          </scope>
        </method>
        <javadoc>
          <text>* Initialization of the dynamic search parameters</text>
          <param>guess Initial guess for the arguments of the fitness function.</param>
        </javadoc>
        <method type="void" name="initializeCMA" startLine="694" endLine="762">
          <scope startLine="695" endLine="699">
            <comment>XXX Line below to replace the current one in 4.0 (MATH-879).</comment>
            <comment>throw new NotStrictlyPositiveException(lambda);</comment>
          </scope>
          <declaration type="double[][]" name="sigmaArray" />
          <scope startLine="702" endLine="706">
            <comment>XXX Line below to replace the current one in 4.0 (MATH-868).</comment>
            <comment>sigmaArray[i][0] = inputSigma[i];</comment>
          </scope>
          <declaration type="RealMatrix" name="insigma" />
          <declaration type="double" name="sumw" />
          <declaration type="double" name="sumwq" />
          <scope startLine="722" endLine="726">
            <declaration type="double" name="w" />
          </scope>
          <scope startLine="759" endLine="761" />
          <comment>initialize sigma</comment>
          <comment>overall standard deviation</comment>
          <comment>initialize termination criteria</comment>
          <comment>initialize selection strategy parameters</comment>
          <comment>number of parents/points for recombination</comment>
          <comment>variance-effectiveness of sum w_i x_i</comment>
          <comment>initialize dynamic strategy parameters and constants</comment>
          <comment>minor increment</comment>
          <comment>intialize CMA internal values - updated each generation</comment>
          <comment>objective variables</comment>
          <comment>evolution paths for C and sigma</comment>
          <comment>B defines the coordinate system</comment>
          <comment>diagonal D defines the scaling</comment>
          <comment>covariance</comment>
          <comment>history of fitness values</comment>
        </method>
        <javadoc>
          <text>* Update of the evolution paths ps and pc.</text>
          <param>zmean Weighted row matrix of the gaussian random numbers generating
 * the current offspring.</param>
          <param>xold xmean matrix of the previous generation.</param>
          <return>hsig flag indicating a small correction.</return>
        </javadoc>
        <method type="boolean" name="updateEvolutionPaths" startLine="772" endLine="785">
          <declaration type="boolean" name="hsig" />
          <scope startLine="781" endLine="783" />
        </method>
        <javadoc>
          <text>* Update of the covariance matrix C for diagonalOnly > 0</text>
          <param>hsig Flag indicating a small correction.</param>
          <param>bestArz Fitness-sorted matrix of the gaussian random values of the
 * current offspring.</param>
        </javadoc>
        <method type="void" name="updateCovarianceDiagonalOnly" startLine="795" endLine="812">
          <declaration type="double" name="oldFac" />
          <scope startLine="805" endLine="811">
            <comment>full covariance matrix from now on</comment>
          </scope>
          <comment>minor correction if hsig==false</comment>
          <comment>regard old matrix</comment>
          <comment>plus rank one update</comment>
          <comment>plus rank mu update</comment>
          <comment>replaces eig(C)</comment>
        </method>
        <javadoc>
          <text>* Update of the covariance matrix C.</text>
          <param>hsig Flag indicating a small correction.</param>
          <param>bestArx Fitness-sorted matrix of the argument vectors producing the
 * current offspring.</param>
          <param>arz Unsorted matrix containing the gaussian random values of the
 * current offspring.</param>
          <param>arindex Indices indicating the fitness-order of the current offspring.</param>
          <param>xold xmean matrix of the previous generation.</param>
        </javadoc>
        <method type="void" name="updateCovariance" startLine="827" endLine="884">
          <declaration type="double" name="negccov" />
          <scope startLine="829" endLine="882">
            <declaration type="RealMatrix" name="arpos" />
            <declaration type="RealMatrix" name="roneu" />
            <declaration type="double" name="oldFac" />
            <scope startLine="837" endLine="874">
              <declaration type="double" name="negminresidualvariance" />
              <declaration type="double" name="negalphaold" />
              <declaration type="int[]" name="arReverseIndex" />
              <declaration type="RealMatrix" name="arzneg" />
              <declaration type="RealMatrix" name="arnorms" />
              <declaration type="int[]" name="idxnorms" />
              <declaration type="RealMatrix" name="arnormsSorted" />
              <declaration type="int[]" name="idxReverse" />
              <declaration type="RealMatrix" name="arnormsReverse" />
              <declaration type="int[]" name="idxInv" />
              <declaration type="RealMatrix" name="arnormsInv" />
              <declaration type="double" name="negcovMax" />
              <scope startLine="860" endLine="862" />
              <declaration type="RealMatrix" name="artmp" />
              <declaration type="RealMatrix" name="Cneg" />
            </scope>
            <scope startLine="874" endLine="881" />
            <comment>mu difference vectors</comment>
            <comment>rank one update</comment>
            <comment>minor correction if hsig==false</comment>
            <comment>Adapt covariance matrix C active CMA</comment>
            <comment>keep at least 0.66 in all directions, small popsize are most</comment>
            <comment>critical</comment>
            <comment>where to make up for the variance loss</comment>
            <comment>prepare vectors, compute negative updating matrix Cneg</comment>
            <comment>check and set learning rate negccov</comment>
            <comment>regard old matrix</comment>
            <comment>plus rank one update</comment>
            <comment>plus rank mu update</comment>
            <comment>Adapt covariance matrix C - nonactive</comment>
            <comment>regard old matrix</comment>
            <comment>plus rank one update</comment>
            <comment>plus rank mu update</comment>
          </scope>
        </method>
        <javadoc>
          <text>* Update B and D from C.</text>
          <param>negccov Negative covariance factor.</param>
        </javadoc>
        <method type="void" name="updateBD" startLine="891" endLine="920">
          <scope startLine="893" endLine="919">
            <declaration type="EigenDecomposition" name="eig" />
            <scope startLine="901" endLine="910">
              <scope startLine="902" endLine="906">
                <scope startLine="903" endLine="905" />
              </scope>
              <declaration type="double" name="tfac" />
            </scope>
            <scope startLine="911" endLine="915">
              <declaration type="double" name="tfac" />
            </scope>
            <comment>to achieve O(N^2)</comment>
            <comment>enforce symmetry to prevent complex numbers</comment>
            <comment>eigen decomposition, B==normalized eigenvectors</comment>
            <comment>D contains standard deviations now</comment>
            <comment>O(n^2)</comment>
          </scope>
        </method>
        <javadoc>
          <text>* Pushes the current best fitness value in a history queue.</text>
          <param>vals History queue.</param>
          <param>val Current best fitness value.</param>
        </javadoc>
        <method type="void" name="push" startLine="928" endLine="933">
          <scope startLine="929" endLine="931" />
        </method>
        <javadoc>
          <text>* Sorts fitness values.</text>
          <param>doubles Array of values to be sorted.</param>
          <return>a sorted array of indices pointing into doubles.</return>
        </javadoc>
        <method type="int[]" name="sortedIndices" startLine="941" endLine="952">
          <declaration type="DoubleIndex[]" name="dis" />
          <scope startLine="943" endLine="945" />
          <declaration type="int[]" name="indices" />
          <scope startLine="948" endLine="950" />
        </method>
        <class name="DoubleIndex" startLine="954">
          <implements name="Comparable<DoubleIndex>" />
          <javadoc>
            <text>* Used to sort fitness values. Sorting is always in lower value first
 * order.</text>
          </javadoc>
          <javadoc>
            <text>* Value to compare.</text>
          </javadoc>
          <declaration type="double" name="value" />
          <javadoc>
            <text>* Index into sorted array.</text>
          </javadoc>
          <declaration type="int" name="index" />
          <javadoc>
            <param>value Value to compare.</param>
            <param>index Index into sorted array.</param>
          </javadoc>
          <method type="constructor" name="DoubleIndex" startLine="968" endLine="971" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="int" name="compareTo" startLine="974" endLine="976" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="boolean" name="equals" startLine="980" endLine="991">
            <scope startLine="982" endLine="984" />
            <scope startLine="986" endLine="988" />
          </method>
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="int" name="hashCode" startLine="995" endLine="998">
            <declaration type="long" name="bits" />
          </method>
          <class name="FitnessFunction" startLine="1001">
            <javadoc>
              <text>* Normalizes fitness values to the range [0,1]. Adds a penalty to the
 * fitness value if out of range. The penalty is adjusted by calling
 * setValueRange().</text>
            </javadoc>
            <javadoc>
              <text>* Determines the penalty for boundary violations</text>
            </javadoc>
            <declaration type="double" name="valueRange" />
            <javadoc>
              <text>* Flag indicating whether the objective variables are forced into their
 * bounds if defined</text>
            </javadoc>
            <declaration type="boolean" name="isRepairMode" />
            <javadoc>
              <text>* Simple constructor.</text>
            </javadoc>
            <method type="constructor" name="FitnessFunction" startLine="1017" endLine="1020" />
            <javadoc>
              <param>point Normalized objective variables.</param>
              <return>the objective value + penalty for violated bounds.</return>
            </javadoc>
            <method type="double" name="value" startLine="1026" endLine="1036">
              <declaration type="double" name="value" />
              <scope startLine="1028" endLine="1032">
                <declaration type="double[]" name="repaired" />
              </scope>
              <scope startLine="1032" endLine="1034" />
            </method>
            <javadoc>
              <param>x Normalized objective variables.</param>
              <return>{@code true} if in bounds.</return>
            </javadoc>
            <method type="boolean" name="isFeasible" startLine="1042" endLine="1055">
              <declaration type="double[]" name="lB" />
              <declaration type="double[]" name="uB" />
              <scope startLine="1046" endLine="1053">
                <scope startLine="1047" endLine="1049" />
                <scope startLine="1050" endLine="1052" />
              </scope>
            </method>
            <javadoc>
              <param>valueRange Adjusts the penalty computation.</param>
            </javadoc>
            <method type="void" name="setValueRange" startLine="1060" endLine="1062" />
            <javadoc>
              <param>x Normalized objective variables.</param>
              <return>the repaired (i.e. all in bounds) objective variables.</return>
            </javadoc>
            <method type="double[]" name="repair" startLine="1068" endLine="1083">
              <declaration type="double[]" name="lB" />
              <declaration type="double[]" name="uB" />
              <declaration type="double[]" name="repaired" />
              <scope startLine="1073" endLine="1081">
                <scope startLine="1074" endLine="1076" />
                <scope startLine="1076" endLine="1078" />
                <scope startLine="1078" endLine="1080" />
              </scope>
            </method>
            <javadoc>
              <param>x Normalized objective variables.</param>
              <param>repaired Repaired objective variables.</param>
              <return>Penalty value according to the violation of the bounds.</return>
            </javadoc>
            <method type="double" name="penalty" startLine="1090" endLine="1097">
              <declaration type="double" name="penalty" />
              <scope startLine="1092" endLine="1095">
                <declaration type="double" name="diff" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix</param>
              <return>Matrix representing the element-wise logarithm of m.</return>
            </javadoc>
            <method type="RealMatrix" name="log" startLine="1106" endLine="1114">
              <declaration type="double[][]" name="d" />
              <scope startLine="1108" endLine="1112">
                <scope startLine="1109" endLine="1111" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <return>Matrix representing the element-wise square root of m.</return>
            </javadoc>
            <method type="RealMatrix" name="sqrt" startLine="1120" endLine="1128">
              <declaration type="double[][]" name="d" />
              <scope startLine="1122" endLine="1126">
                <scope startLine="1123" endLine="1125" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <return>Matrix representing the element-wise square of m.</return>
            </javadoc>
            <method type="RealMatrix" name="square" startLine="1134" endLine="1143">
              <declaration type="double[][]" name="d" />
              <scope startLine="1136" endLine="1141">
                <scope startLine="1137" endLine="1140">
                  <declaration type="double" name="e" />
                </scope>
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix 1.</param>
              <param>n Input matrix 2.</param>
              <return>the matrix where the elements of m and n are element-wise multiplied.</return>
            </javadoc>
            <method type="RealMatrix" name="times" startLine="1150" endLine="1158">
              <declaration type="double[][]" name="d" />
              <scope startLine="1152" endLine="1156">
                <scope startLine="1153" endLine="1155" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix 1.</param>
              <param>n Input matrix 2.</param>
              <return>Matrix where the elements of m and n are element-wise divided.</return>
            </javadoc>
            <method type="RealMatrix" name="divide" startLine="1165" endLine="1173">
              <declaration type="double[][]" name="d" />
              <scope startLine="1167" endLine="1171">
                <scope startLine="1168" endLine="1170" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <param>cols Columns to select.</param>
              <return>Matrix representing the selected columns.</return>
            </javadoc>
            <method type="RealMatrix" name="selectColumns" startLine="1180" endLine="1188">
              <declaration type="double[][]" name="d" />
              <scope startLine="1182" endLine="1186">
                <scope startLine="1183" endLine="1185" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <param>k Diagonal position.</param>
              <return>Upper triangular part of matrix.</return>
            </javadoc>
            <method type="RealMatrix" name="triu" startLine="1195" endLine="1203">
              <declaration type="double[][]" name="d" />
              <scope startLine="1197" endLine="1201">
                <scope startLine="1198" endLine="1200" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <return>Row matrix representing the sums of the rows.</return>
            </javadoc>
            <method type="RealMatrix" name="sumRows" startLine="1209" endLine="1219">
              <declaration type="double[][]" name="d" />
              <scope startLine="1211" endLine="1217">
                <declaration type="double" name="sum" />
                <scope startLine="1213" endLine="1215" />
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <return>the diagonal n-by-n matrix if m is a column matrix or the column
 * matrix representing the diagonal if m is a n-by-n matrix.</return>
            </javadoc>
            <method type="RealMatrix" name="diag" startLine="1226" endLine="1240">
              <scope startLine="1227" endLine="1233">
                <declaration type="double[][]" name="d" />
                <scope startLine="1229" endLine="1231" />
              </scope>
              <scope startLine="1233" endLine="1239">
                <declaration type="double[][]" name="d" />
                <scope startLine="1235" endLine="1237" />
              </scope>
            </method>
            <javadoc>
              <text>* Copies a column from m1 to m2.</text>
              <param>m1 Source matrix.</param>
              <param>col1 Source column.</param>
              <param>m2 Target matrix.</param>
              <param>col2 Target column.</param>
            </javadoc>
            <method type="void" name="copyColumn" startLine="1251" endLine="1255">
              <scope startLine="1252" endLine="1254" />
            </method>
            <javadoc>
              <param>n Number of rows.</param>
              <param>m Number of columns.</param>
              <return>n-by-m matrix filled with 1.</return>
            </javadoc>
            <method type="RealMatrix" name="ones" startLine="1262" endLine="1268">
              <declaration type="double[][]" name="d" />
              <scope startLine="1264" endLine="1266" />
            </method>
            <javadoc>
              <param>n Number of rows.</param>
              <param>m Number of columns.</param>
              <return>n-by-m matrix of 0 values out of diagonal, and 1 values on
 * the diagonal.</return>
            </javadoc>
            <method type="RealMatrix" name="eye" startLine="1276" endLine="1284">
              <declaration type="double[][]" name="d" />
              <scope startLine="1278" endLine="1282">
                <scope startLine="1279" endLine="1281" />
              </scope>
            </method>
            <javadoc>
              <param>n Number of rows.</param>
              <param>m Number of columns.</param>
              <return>n-by-m matrix of zero values.</return>
            </javadoc>
            <method type="RealMatrix" name="zeros" startLine="1291" endLine="1293" />
            <javadoc>
              <param>mat Input matrix.</param>
              <param>n Number of row replicates.</param>
              <param>m Number of column replicates.</param>
              <return>a matrix which replicates the input matrix in both directions.</return>
            </javadoc>
            <method type="RealMatrix" name="repmat" startLine="1301" endLine="1311">
              <declaration type="int" name="rd" />
              <declaration type="int" name="cd" />
              <declaration type="double[][]" name="d" />
              <scope startLine="1305" endLine="1309">
                <scope startLine="1306" endLine="1308" />
              </scope>
            </method>
            <javadoc>
              <param>start Start value.</param>
              <param>end End value.</param>
              <param>step Step size.</param>
              <return>a sequence as column matrix.</return>
            </javadoc>
            <method type="RealMatrix" name="sequence" startLine="1319" endLine="1328">
              <declaration type="int" name="size" />
              <declaration type="double[][]" name="d" />
              <declaration type="double" name="value" />
              <scope startLine="1323" endLine="1326" />
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <return>the maximum of the matrix element values.</return>
            </javadoc>
            <method type="double" name="max" startLine="1334" endLine="1345">
              <declaration type="double" name="max" />
              <scope startLine="1336" endLine="1343">
                <scope startLine="1337" endLine="1342">
                  <declaration type="double" name="e" />
                  <scope startLine="1339" endLine="1341" />
                </scope>
              </scope>
            </method>
            <javadoc>
              <param>m Input matrix.</param>
              <return>the minimum of the matrix element values.</return>
            </javadoc>
            <method type="double" name="min" startLine="1351" endLine="1362">
              <declaration type="double" name="min" />
              <scope startLine="1353" endLine="1360">
                <scope startLine="1354" endLine="1359">
                  <declaration type="double" name="e" />
                  <scope startLine="1356" endLine="1358" />
                </scope>
              </scope>
            </method>
            <javadoc>
              <param>m Input array.</param>
              <return>the maximum of the array values.</return>
            </javadoc>
            <method type="double" name="max" startLine="1368" endLine="1376">
              <declaration type="double" name="max" />
              <scope startLine="1370" endLine="1374">
                <scope startLine="1371" endLine="1373" />
              </scope>
            </method>
            <javadoc>
              <param>m Input array.</param>
              <return>the minimum of the array values.</return>
            </javadoc>
            <method type="double" name="min" startLine="1382" endLine="1390">
              <declaration type="double" name="min" />
              <scope startLine="1384" endLine="1388">
                <scope startLine="1385" endLine="1387" />
              </scope>
            </method>
            <javadoc>
              <param>indices Input index array.</param>
              <return>the inverse of the mapping defined by indices.</return>
            </javadoc>
            <method type="int[]" name="inverse" startLine="1396" endLine="1402">
              <declaration type="int[]" name="inverse" />
              <scope startLine="1398" endLine="1400" />
            </method>
            <javadoc>
              <param>indices Input index array.</param>
              <return>the indices in inverse order (last is first).</return>
            </javadoc>
            <method type="int[]" name="reverse" startLine="1408" endLine="1414">
              <declaration type="int[]" name="reverse" />
              <scope startLine="1410" endLine="1412" />
            </method>
            <javadoc>
              <param>size Length of random array.</param>
              <return>an array of Gaussian random numbers.</return>
            </javadoc>
            <method type="double[]" name="randn" startLine="1420" endLine="1426">
              <declaration type="double[]" name="randn" />
              <scope startLine="1422" endLine="1424" />
            </method>
            <javadoc>
              <param>size Number of rows.</param>
              <param>popSize Population size.</param>
              <return>a 2-dimensional matrix of Gaussian random numbers.</return>
            </javadoc>
            <method type="RealMatrix" name="randn1" startLine="1433" endLine="1441">
              <declaration type="double[][]" name="d" />
              <scope startLine="1435" endLine="1439">
                <scope startLine="1436" endLine="1438" />
              </scope>
            </method>
          </class>
        </class>
      </class>
    </class>
    <comment>global search parameters</comment>
    <comment>population size</comment>
    <comment>termination criteria</comment>
    <comment>selection strategy parameters</comment>
    <comment />
    <comment />
    <comment>dynamic strategy parameters and constants</comment>
    <comment>CMA internal values - updated each generation</comment>
    <comment>-----Matrix utility functions similar to the Matlab build in functions------</comment>
  </class>
</source>
