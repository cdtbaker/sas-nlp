<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.partitioning">
  <import name="org.apache.commons.math3.geometry.Space" />
  <class name="AbstractSubHyperplane" startLine="21">
    <implements name="SubHyperplane<S>" />
    <javadoc>
      <text>* This class implements the dimension-independent parts of {@link SubHyperplane}.
 * <p>sub-hyperplanes are obtained when parts of an {@link Hyperplane hyperplane} are chopped off by other hyperplanes that
 * intersect it. The remaining part is a convex region. Such objects
 * appear in {@link BSPTree BSP trees} as the intersection of a cut
 * hyperplane with the convex region which it splits, the chopping
 * hyperplanes are the cut hyperplanes closer to the tree root.</p></text>
      <param><S>
 *  Type of the embedding space.</param>
      <param><T>
 *  Type of the embedded sub-space.</param>
      <version>$Id: AbstractSubHyperplane.java 1421448 2012-12-13 19:45:57Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Underlying hyperplane.</text>
    </javadoc>
    <declaration type="Hyperplane<S>" name="hyperplane" />
    <javadoc>
      <text>* Remaining region of the hyperplane.</text>
    </javadoc>
    <declaration type="Region<T>" name="remainingRegion" />
    <javadoc>
      <text>* Build a sub-hyperplane from an hyperplane and a region.</text>
      <param>hyperplane underlying hyperplane</param>
      <param>remainingRegion remaining region of the hyperplane</param>
    </javadoc>
    <method type="constructor" name="AbstractSubHyperplane" startLine="50" endLine="53" />
    <method name="buildNew" type="AbstractSubHyperplane<S,T>" startLine="55" endLine="61" />
    <javadoc>
      <text>* Build a sub-hyperplane from an hyperplane and a region.</text>
      <param>hyper underlying hyperplane</param>
      <param>remaining remaining region of the hyperplane</param>
      <return>a new sub-hyperplane</return>
    </javadoc>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="AbstractSubHyperplane<S,T>" name="copySelf" startLine="64" endLine="66" />
    <javadoc>
      <text>* Get the underlying hyperplane.</text>
      <return>underlying hyperplane</return>
    </javadoc>
    <method type="Hyperplane<S>" name="getHyperplane" startLine="71" endLine="73" />
    <javadoc>
      <text>* Get the remaining region of the hyperplane.
 * <p>The returned region is expressed in the canonical hyperplane
 * frame and has the hyperplane dimension. For example a chopped
 * hyperplane in the 3D euclidean is a 2D plane and the
 * corresponding region is a convex 2D polygon.</p></text>
      <return>remaining region of the hyperplane</return>
    </javadoc>
    <method type="Region<T>" name="getRemainingRegion" startLine="82" endLine="84" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getSize" startLine="87" endLine="89" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="AbstractSubHyperplane<S,T>" name="reunite" startLine="92" endLine="97">
      <declaration type="AbstractSubHyperplane<S,T>" name="o" />
    </method>
    <javadoc>
      <text>* Apply a transform to the instance.
 * <p>The instance must be a (D-1)-dimension sub-hyperplane with
 * respect to the transform <em>not</em> a (D-2)-dimension
 * sub-hyperplane the transform knows how to transform by
 * itself. The transform will consist in transforming first the
 * hyperplane and then the all region using the various methods
 * provided by the transform.</p></text>
      <param>transform D-dimension transform to apply</param>
      <return>the transformed instance</return>
    </javadoc>
    <method type="AbstractSubHyperplane<S,T>" name="applyTransform" startLine="109" endLine="114">
      <declaration type="Hyperplane<S>" name="tHyperplane" />
      <declaration type="BSPTree<T>" name="tTree" />
    </method>
    <javadoc>
      <text>* Recursively transform a BSP-tree from a sub-hyperplane.</text>
      <param>node current BSP tree node</param>
      <param>transformed image of the instance hyperplane by the transform</param>
      <param>transform transform to apply</param>
      <return>a new tree</return>
    </javadoc>
    <method type="BSPTree<T>" name="recurseTransform" startLine="124" endLine="145">
      <scope startLine="125" endLine="127" />
      <declaration type="BoundaryAttribute<T>" name="attribute" />
      <scope startLine="132" endLine="138">
        <declaration type="SubHyperplane<T>" name="tPO" />
        <declaration type="SubHyperplane<T>" name="tPI" />
      </scope>
    </method>
    <method name="side" type="Side" startLine="147" endLine="148" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method name="split" type="SplitSubHyperplane<S>" startLine="150" endLine="151" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isEmpty" startLine="154" endLine="156" />
  </class>
</source>
