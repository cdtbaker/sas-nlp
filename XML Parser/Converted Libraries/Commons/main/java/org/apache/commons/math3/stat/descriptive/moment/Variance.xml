<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.stat.descriptive.moment">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.stat.descriptive.WeightedEvaluation" />
  <import name="org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="Variance" extends="AbstractStorelessUnivariateStatistic" startLine="28">
    <implements name="Serializable" />
    <implements name="WeightedEvaluation" />
    <javadoc>
      <text>* Computes the variance of the available values.  By default, the unbiased
 * "sample variance" definitional formula is used:
 * <p>
 * variance = sum((x_i - mean)^2) / (n - 1) </p>
 * <p>
 * where mean is the {@link Mean} and <code>n</code> is the number
 * of sample observations.</p>
 * <p>
 * The definitional formula does not have good numerical properties, so
 * this implementation does not compute the statistic using the definitional
 * formula. <ul>
 * <li> The <code>getResult</code> method computes the variance using
 * updating formulas based on West's algorithm, as described in
 * <a href="http://doi.acm.org/10.1145/359146.359152"> Chan, T. F. and
 * J. G. Lewis 1979, <i>Communications of the ACM</i>,
 * vol. 22 no. 9, pp. 526-531.</a></li>
 * <li> The <code>evaluate</code> methods leverage the fact that they have the
 * full array of values in memory to execute a two-pass algorithm.
 * Specifically, these methods use the "corrected two-pass algorithm" from
 * Chan, Golub, Levesque, <i>Algorithms for Computing the Sample Variance</i>,
 * American Statistician, vol. 37, no. 3 (1983) pp. 242-247.</li></ul>
 * Note that adding values using <code>increment</code> or
 * <code>incrementAll</code> and then executing <code>getResult</code> will
 * sometimes give a different, less accurate, result than executing
 * <code>evaluate</code> with the full array of values. The former approach
 * should only be used when the full array of values is not available.</p>
 * <p>
 * The "population variance"  ( sum((x_i - mean)^2) / n ) can also
 * be computed using this statistic.  The <code>isBiasCorrected</code>
 * property determines whether the "population" or "sample" value is
 * returned by the <code>evaluate</code> and <code>getResult</code> methods.
 * To compute population variances, set this property to <code>false.</code>
 * </p>
 * <p>
 * <strong>Note that this implementation is not synchronized.</strong> If
 * multiple threads access an instance of this class concurrently, and at least
 * one of the threads invokes the <code>increment()</code> or
 * <code>clear()</code> method, it must be synchronized externally.</p></text>
      <version>$Id: Variance.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* SecondMoment is used in incremental calculation of Variance</text>
    </javadoc>
    <declaration type="SecondMoment" name="moment" />
    <javadoc>
      <text>* Whether or not {@link #increment(double)} should increment
 * the internal second moment. When a Variance is constructed with an
 * external SecondMoment as a constructor parameter, this property is
 * set to false and increments must be applied to the second moment
 * directly.</text>
    </javadoc>
    <declaration type="boolean" name="incMoment" />
    <javadoc>
      <text>* Whether or not bias correction is applied when computing the
 * value of the statistic. True means that bias is corrected.  See{@link Variance} for details on the formula.</text>
    </javadoc>
    <declaration type="boolean" name="isBiasCorrected" />
    <javadoc>
      <text>* Constructs a Variance with default (true) <code>isBiasCorrected</code>
 * property.</text>
    </javadoc>
    <method type="constructor" name="Variance" startLine="98" endLine="100" />
    <javadoc>
      <text>* Constructs a Variance based on an external second moment.
 * When this constructor is used, the statistic may only be
 * incremented via the moment, i.e., {@link #increment(double)}does nothing; whereas {@code m2.increment(value)} increments
 * both {@code m2} and the Variance instance constructed from it.</text>
      <param>m2 the SecondMoment (Third or Fourth moments work
 * here as well.)</param>
    </javadoc>
    <method type="constructor" name="Variance" startLine="112" endLine="115" />
    <javadoc>
      <text>* Constructs a Variance with the specified <code>isBiasCorrected</code>
 * property</text>
      <param>isBiasCorrected  setting for bias correction - true means
 * bias will be corrected and is equivalent to using the argumentless
 * constructor</param>
    </javadoc>
    <method type="constructor" name="Variance" startLine="125" endLine="128" />
    <javadoc>
      <text>* Constructs a Variance with the specified <code>isBiasCorrected</code>
 * property and the supplied external second moment.</text>
      <param>isBiasCorrected  setting for bias correction - true means
 * bias will be corrected</param>
      <param>m2 the SecondMoment (Third or Fourth moments work
 * here as well.)</param>
    </javadoc>
    <method type="constructor" name="Variance" startLine="139" endLine="143" />
    <javadoc>
      <text>* Copy constructor, creates a new {@code Variance} identical
 * to the {@code original}</text>
      <param>original the {@code Variance} instance to copy</param>
      <throws>NullArgumentException if original is null</throws>
    </javadoc>
    <method type="constructor" name="Variance" startLine="152" endLine="154" />
    <javadoc>
      <text>* {@inheritDoc}<p>If all values are available, it is more accurate to use{@link #evaluate(double[])} rather than adding values one at a time
 * using this method and then executing {@link #getResult}, since
 * <code>evaluate</code> leverages the fact that is has the full
 * list of values together to execute a two-pass algorithm.
 * See {@link Variance}.</p>
 * <p>Note also that when {@link #Variance(SecondMoment)} is used to
 * create a Variance, this method does nothing. In that case, the
 * SecondMoment should be incremented directly.</p></text>
    </javadoc>
    <method type="void" name="increment" startLine="170" endLine="174">
      <scope startLine="171" endLine="173" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getResult" startLine="180" endLine="192">
      <scope startLine="181" endLine="183" />
      <scope startLine="183" endLine="185" />
      <scope startLine="185" endLine="191">
        <scope startLine="186" endLine="188" />
        <scope startLine="188" endLine="190" />
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="long" name="getN" startLine="197" endLine="199" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="clear" startLine="205" endLine="209">
      <scope startLine="206" endLine="208" />
    </method>
    <javadoc>
      <text>* Returns the variance of the entries in the input array, or
 * <code>Double.NaN</code> if the array is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p></text>
      <param>values the input array</param>
      <return>the variance of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the array is null</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="228" endLine="233">
      <scope startLine="229" endLine="231" />
    </method>
    <javadoc>
      <text>* Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if the array is null.</p></text>
      <param>values the input array</param>
      <param>begin index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the variance of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the array is null or the array index
 * parameters are not valid</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="257" endLine="272">
      <declaration type="double" name="var" />
      <scope startLine="261" endLine="270">
        <scope startLine="263" endLine="265" />
        <scope startLine="265" endLine="269">
          <declaration type="Mean" name="mean" />
          <declaration type="double" name="m" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 * &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 * <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 * <li>the weights array is null</li>
 * <li>the weights array does not have the same length as the values array</li>
 * <li>the weights array contains one or more infinite values</li>
 * <li>the weights array contains one or more NaN values</li>
 * <li>the weights array contains negative values</li>
 * <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if either array is null.</p></text>
      <param>values the input array</param>
      <param>weights the weights array</param>
      <param>begin index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the weighted variance of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double" name="evaluate" startLine="317" endLine="332">
      <declaration type="double" name="var" />
      <scope startLine="321" endLine="330">
        <scope startLine="323" endLine="325" />
        <scope startLine="325" endLine="329">
          <declaration type="Mean" name="mean" />
          <declaration type="double" name="m" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 * &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 * <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 * <li>the weights array is null</li>
 * <li>the weights array does not have the same length as the values array</li>
 * <li>the weights array contains one or more infinite values</li>
 * <li>the weights array contains one or more NaN values</li>
 * <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if either array is null.</p></text>
      <param>values the input array</param>
      <param>weights the weights array</param>
      <return>the weighted variance of the values</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double" name="evaluate" startLine="373" endLine="375" />
    <javadoc>
      <text>* Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p></text>
      <param>values the input array</param>
      <param>mean the precomputed mean value</param>
      <param>begin index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the variance of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the array is null or the array index
 * parameters are not valid</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="404" endLine="429">
      <declaration type="double" name="var" />
      <scope startLine="408" endLine="427">
        <scope startLine="409" endLine="411" />
        <scope startLine="411" endLine="426">
          <declaration type="double" name="accum" />
          <declaration type="double" name="dev" />
          <declaration type="double" name="accum2" />
          <scope startLine="415" endLine="419" />
          <declaration type="double" name="len" />
          <scope startLine="421" endLine="423" />
          <scope startLine="423" endLine="425" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the variance of the entries in the input array, using the
 * precomputed mean value.  Returns <code>Double.NaN</code> if the array
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * If <code>isBiasCorrected</code> is <code>true</code> the formula used
 * assumes that the supplied mean value is the arithmetic mean of the
 * sample data, not a known population parameter.  If the mean is a known
 * population parameter, or if the "population" version of the variance is
 * desired, set <code>isBiasCorrected</code> to <code>false</code> before
 * invoking this method.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p></text>
      <param>values the input array</param>
      <param>mean the precomputed mean value</param>
      <return>the variance of the values or Double.NaN if the array is empty</return>
      <throws>MathIllegalArgumentException if the array is null</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="456" endLine="458" />
    <javadoc>
      <text>* Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 * &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 * <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 * <li>the weights array is null</li>
 * <li>the weights array does not have the same length as the values array</li>
 * <li>the weights array contains one or more infinite values</li>
 * <li>the weights array contains one or more NaN values</li>
 * <li>the weights array contains negative values</li>
 * <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p></text>
      <param>values the input array</param>
      <param>weights the weights array</param>
      <param>mean the precomputed weighted mean value</param>
      <param>begin index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the variance of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double" name="evaluate" startLine="507" endLine="537">
      <declaration type="double" name="var" />
      <scope startLine="511" endLine="535">
        <scope startLine="512" endLine="514" />
        <scope startLine="514" endLine="534">
          <declaration type="double" name="accum" />
          <declaration type="double" name="dev" />
          <declaration type="double" name="accum2" />
          <scope startLine="518" endLine="522" />
          <declaration type="double" name="sumWts" />
          <scope startLine="525" endLine="527" />
          <scope startLine="529" endLine="531" />
          <scope startLine="531" endLine="533" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 * &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as "expansion values," as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 * <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 * <li>the weights array is null</li>
 * <li>the weights array does not have the same length as the values array</li>
 * <li>the weights array contains one or more infinite values</li>
 * <li>the weights array contains one or more NaN values</li>
 * <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p></text>
      <param>values the input array</param>
      <param>weights the weights array</param>
      <param>mean the precomputed weighted mean value</param>
      <return>the variance of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double" name="evaluate" startLine="581" endLine="583" />
    <javadoc>
      <return>Returns the isBiasCorrected.</return>
    </javadoc>
    <method type="boolean" name="isBiasCorrected" startLine="588" endLine="590" />
    <javadoc>
      <param>biasCorrected The isBiasCorrected to set.</param>
    </javadoc>
    <method type="void" name="setBiasCorrected" startLine="595" endLine="597" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Variance" name="copy" startLine="603" endLine="608">
      <declaration type="Variance" name="result" />
      <comment>No try-catch or advertised exception because parameters are guaranteed non-null</comment>
    </method>
    <javadoc>
      <text>* Copies source to dest.
 * <p>Neither source nor dest can be null.</p></text>
      <param>source Variance to copy</param>
      <param>dest Variance to copy to</param>
      <throws>NullArgumentException if either source or dest is null</throws>
    </javadoc>
    <method type="void" name="copy" startLine="619" endLine="626" />
  </class>
</source>
