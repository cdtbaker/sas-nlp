<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.special">
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="Erf" startLine="21">
    <javadoc>
      <text>* This is a utility class that provides computation methods related to the
 * error functions.</text>
      <version>$Id: Erf.java 1456905 2013-03-15 11:37:35Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* The number {@code X_CRIT} is used by {@link #erf(double,double)} internally.
 * This number solves {@code erf(x)=0.5} within 1ulp.
 * More precisely, the current implementations of{@link #erf(double)} and {@link #erfc(double)} satisfy:<br/>{@code erf(X_CRIT) < 0.5},<br/>{@code erf(Math.nextUp(X_CRIT) > 0.5},<br/>{@code erfc(X_CRIT) = 0.5}, and<br/>{@code erfc(Math.nextUp(X_CRIT) < 0.5}</text>
    </javadoc>
    <declaration type="double" name="X_CRIT" />
    <javadoc>
      <text>* Default constructor.  Prohibit instantiation.</text>
    </javadoc>
    <method type="constructor" name="Erf" startLine="44" endLine="44" />
    <javadoc>
      <text>* Returns the error function.
 * <p>erf(x) = 2/&radic;&pi; <sub>0</sub>&int;<sup>x</sup> e<sup>-t<sup>2</sup></sup>dt </p>
 * <p>This implementation computes erf(x) using the{@link Gamma#regularizedGammaP(double,double,double,int) regularized gamma function},
 * following <a href="http://mathworld.wolfram.com/Erf.html"> Erf</a>, equation (3)</p>
 * <p>The value returned is always between -1 and 1 (inclusive).
 * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from
 * either 1 or -1 as a double, so the appropriate extreme value is returned.
 * </p></text>
      <param>x the value.</param>
      <return>the error function erf(x)</return>
      <throws>org.apache.commons.math3.exception.MaxCountExceededExceptionif the algorithm fails to converge.</throws>
      <see>Gamma#regularizedGammaP(double,double,double,int)</see>
    </javadoc>
    <method type="double" name="erf" startLine="66" endLine="72">
      <scope startLine="67" endLine="69" />
      <declaration type="double" name="ret" />
    </method>
    <javadoc>
      <text>* Returns the complementary error function.
 * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt
 * <br/>
 * = 1 - {@link #erf(double) erf(x)} </p>
 * <p>This implementation computes erfc(x) using the{@link Gamma#regularizedGammaQ(double,double,double,int) regularized gamma function},
 * following <a href="http://mathworld.wolfram.com/Erf.html"> Erf</a>, equation (3).</p>
 * <p>The value returned is always between 0 and 2 (inclusive).
 * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from
 * either 0 or 2 as a double, so the appropriate extreme value is returned.
 * </p></text>
      <param>x the value</param>
      <return>the complementary error function erfc(x)</return>
      <throws>org.apache.commons.math3.exception.MaxCountExceededExceptionif the algorithm fails to converge.</throws>
      <see>Gamma#regularizedGammaQ(double,double,double,int)</see>
      <since>2.2</since>
    </javadoc>
    <method type="double" name="erfc" startLine="97" endLine="103">
      <scope startLine="98" endLine="100" />
      <declaration type="double" name="ret" />
    </method>
    <javadoc>
      <text>* Returns the difference between erf(x1) and erf(x2).
 * The implementation uses either erf(double) or erfc(double)
 * depending on which provides the most precise result.</text>
      <param>x1 the first value</param>
      <param>x2 the second value</param>
      <return>erf(x2) - erf(x1)</return>
    </javadoc>
    <method type="double" name="erf" startLine="115" endLine="128">
      <scope startLine="116" endLine="118" />
    </method>
    <javadoc>
      <text>* Returns the inverse erf.
 * <p>
 * This implementation is described in the paper:
 * <a href="http://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf">Approximating
 * the erfinv function</a> by Mike Giles, Oxford-Man Institute of Quantitative Finance,
 * which was published in GPU Computing Gems, volume 2, 2010.
 * The source code is available <a href="http://gpucomputing.net/?q=node/1828">here</a>.
 * </p></text>
      <param>x the value</param>
      <return>t such that x = erf(t)</return>
      <since>3.2</since>
    </javadoc>
    <method type="double" name="erfInv" startLine="143" endLine="231">
      <declaration type="double" name="w" />
      <declaration type="double" name="p" />
      <scope startLine="152" endLine="177" />
      <scope startLine="177" endLine="198" />
      <scope startLine="198" endLine="217" />
      <scope startLine="217" endLine="227">
        <comment>this branch does not appears in the original code, it</comment>
        <comment>was added because the previous branch does not handle</comment>
        <comment>x = +/-1 correctly. In this case, w is positive infinity</comment>
        <comment>and as the first coefficient (-2.71e-11) is negative.</comment>
        <comment>Once the first multiplication is done, p becomes negative</comment>
        <comment>infinity and remains so throughout the polynomial evaluation.</comment>
        <comment>So the branch above incorrectly returns negative infinity</comment>
        <comment>instead of the correct positive infinity.</comment>
      </scope>
      <comment>beware that the logarithm argument must be</comment>
      <comment>commputed as (1.0 - x) * (1.0 + x),</comment>
      <comment>it must NOT be simplified as 1.0 - x * x as this</comment>
      <comment>would induce rounding errors near the boundaries +/-1</comment>
    </method>
    <javadoc>
      <text>* Returns the inverse erfc.</text>
      <param>x the value</param>
      <return>t such that x = erfc(t)</return>
      <since>3.2</since>
    </javadoc>
    <method type="double" name="erfcInv" startLine="239" endLine="241" />
  </class>
</source>
