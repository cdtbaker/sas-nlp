<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.vector.jacobian">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.TooManyEvaluationsException" />
  <import name="org.apache.commons.math3.linear.ArrayRealVector" />
  <import name="org.apache.commons.math3.linear.RealMatrix" />
  <import name="org.apache.commons.math3.linear.DiagonalMatrix" />
  <import name="org.apache.commons.math3.linear.DecompositionSolver" />
  <import name="org.apache.commons.math3.linear.MatrixUtils" />
  <import name="org.apache.commons.math3.linear.QRDecomposition" />
  <import name="org.apache.commons.math3.linear.EigenDecomposition" />
  <import name="org.apache.commons.math3.optim.OptimizationData" />
  <import name="org.apache.commons.math3.optim.ConvergenceChecker" />
  <import name="org.apache.commons.math3.optim.PointVectorValuePair" />
  <import name="org.apache.commons.math3.optim.nonlinear.vector.Weight" />
  <import name="org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="AbstractLeastSquaresOptimizer" extends="JacobianMultivariateVectorOptimizer" startLine="35">
    <javadoc>
      <text>* Base class for implementing least-squares optimizers.
 * It provides methods for error estimation.</text>
      <version>$Id: AbstractLeastSquaresOptimizer.java 1443444 2013-02-07 12:41:36Z erans $</version>
      <since>3.1</since>
    </javadoc>
    <javadoc>
      <text>* Square-root of the weight matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="weightMatrixSqrt" />
    <javadoc>
      <text>* Cost value (square root of the sum of the residuals).</text>
    </javadoc>
    <declaration type="double" name="cost" />
    <javadoc>
      <param>checker Convergence checker.</param>
    </javadoc>
    <method type="constructor" name="AbstractLeastSquaresOptimizer" startLine="52" endLine="54" />
    <javadoc>
      <text>* Computes the weighted Jacobian matrix.</text>
      <param>params Model parameters at which to compute the Jacobian.</param>
      <return>the weighted Jacobian: W<sup>1/2</sup> J.</return>
      <throws>DimensionMismatchException if the Jacobian dimension does not
 * match problem dimension.</throws>
    </javadoc>
    <method type="RealMatrix" name="computeWeightedJacobian" startLine="64" endLine="66" />
    <javadoc>
      <text>* Computes the cost.</text>
      <param>residuals Residuals.</param>
      <return>the cost.</return>
      <see>#computeResiduals(double[])</see>
    </javadoc>
    <method type="double" name="computeCost" startLine="75" endLine="78">
      <declaration type="ArrayRealVector" name="r" />
    </method>
    <javadoc>
      <text>* Gets the root-mean-square (RMS) value.
 * The RMS the root of the arithmetic mean of the square of all weighted
 * residuals.
 * This is related to the criterion that is minimized by the optimizer
 * as follows: If <em>c</em> if the criterion, and <em>n</em> is the
 * number of measurements, then the RMS is <em>sqrt (c/n)</em>.</text>
      <return>the RMS value.</return>
    </javadoc>
    <method type="double" name="getRMS" startLine="91" endLine="93" />
    <javadoc>
      <text>* Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.</text>
      <return>chi-square value</return>
    </javadoc>
    <method type="double" name="getChiSquare" startLine="101" endLine="103" />
    <javadoc>
      <text>* Gets the square-root of the weight matrix.</text>
      <return>the square-root of the weight matrix.</return>
    </javadoc>
    <method type="RealMatrix" name="getWeightSquareRoot" startLine="110" endLine="112" />
    <javadoc>
      <text>* Sets the cost.</text>
      <param>cost Cost value.</param>
    </javadoc>
    <method type="void" name="setCost" startLine="119" endLine="121" />
    <javadoc>
      <text>* Get the covariance matrix of the optimized parameters.
 * <br/>
 * Note that this operation involves the inversion of the
 * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the
 * Jacobian matrix.
 * The {@code threshold} parameter is a way for the caller to specify
 * that the result of this computation should be considered meaningless,
 * and thus trigger an exception.</text>
      <param>params Model parameters.</param>
      <param>threshold Singularity threshold.</param>
      <return>the covariance matrix.</return>
      <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed (singular problem).</throws>
    </javadoc>
    <method type="double[][]" name="computeCovariances" startLine="140" endLine="151">
      <declaration type="RealMatrix" name="j" />
      <declaration type="RealMatrix" name="jTj" />
      <declaration type="DecompositionSolver" name="solver" />
      <comment>Set up the Jacobian.</comment>
      <comment>Compute transpose(J)J.</comment>
      <comment>Compute the covariances matrix.</comment>
    </method>
    <javadoc>
      <text>* Computes an estimate of the standard deviation of the parameters. The
 * returned values are the square root of the diagonal coefficients of the
 * covariance matrix, {@code sd(a[i]) ~= sqrt(C[i][i])}, where {@code a[i]}is the optimized value of the {@code i}-th parameter, and {@code C} is
 * the covariance matrix.</text>
      <param>params Model parameters.</param>
      <param>covarianceSingularityThreshold Singularity threshold (see{@link #computeCovariances(double[],double) computeCovariances}).</param>
      <return>an estimate of the standard deviation of the optimized parameters</return>
      <throws>org.apache.commons.math3.linear.SingularMatrixExceptionif the covariance matrix cannot be computed.</throws>
    </javadoc>
    <method type="double[]" name="computeSigma" startLine="168" endLine="176">
      <declaration type="int" name="nC" />
      <declaration type="double[]" name="sig" />
      <declaration type="double[][]" name="cov" />
      <scope startLine="172" endLine="174" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
      <param>optData Optimization data. In addition to those documented in{@link JacobianMultivariateVectorOptimizer#parseOptimizationData(OptimizationData[])JacobianMultivariateVectorOptimizer}, this method will register the following data:
 * <ul>
 * <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>
 * </ul></param>
      <return>{@inheritDoc}</return>
      <throws>TooManyEvaluationsException if the maximal number of
 * evaluations is exceeded.</throws>
      <throws>DimensionMismatchException if the initial guess, target, and weight
 * arguments have inconsistent dimensions.</throws>
    </javadoc>
    <method type="PointVectorValuePair" name="optimize" startLine="195" endLine="198">
      <comment>Set up base class and perform computation.</comment>
    </method>
    <javadoc>
      <text>* Computes the residuals.
 * The residual is the difference between the observed (target)
 * values and the model (objective function) value.
 * There is one residual for each element of the vector-valued
 * function.</text>
      <param>objectiveValue Value of the the objective function. This is
 * the value returned from a call to{@link #computeObjectiveValue(double[]) computeObjectiveValue}(whose array argument contains the model parameters).</param>
      <return>the residuals.</return>
      <throws>DimensionMismatchException if {@code params} has a wrong
 * length.</throws>
    </javadoc>
    <method type="double[]" name="computeResiduals" startLine="215" endLine="228">
      <declaration type="double[]" name="target" />
      <scope startLine="217" endLine="220" />
      <declaration type="double[]" name="residuals" />
      <scope startLine="223" endLine="225" />
    </method>
    <javadoc>
      <text>* Scans the list of (required and optional) optimization data that
 * characterize the problem.
 * If the weight matrix is specified, the {@link #weightMatrixSqrt}field is recomputed.</text>
      <param>optData Optimization data. The following data will be looked for:
 * <ul>
 * <li>{@link Weight}</li>
 * </ul></param>
    </javadoc>
    <method type="void" name="parseOptimizationData" startLine="242" endLine="256">
      <scope startLine="248" endLine="255">
        <scope startLine="249" endLine="254" />
        <comment>If more data must be parsed, this statement _must_ be</comment>
        <comment>changed to "continue".</comment>
      </scope>
      <comment>Allow base class to register its own data.</comment>
      <comment>The existing values (as set by the previous call) are reused if</comment>
      <comment>not provided in the argument list.</comment>
    </method>
    <javadoc>
      <text>* Computes the square-root of the weight matrix.</text>
      <param>m Symmetric, positive-definite (weight) matrix.</param>
      <return>the square-root of the weight matrix.</return>
    </javadoc>
    <method type="RealMatrix" name="squareRoot" startLine="264" endLine="276">
      <scope startLine="265" endLine="272">
        <declaration type="int" name="dim" />
        <declaration type="RealMatrix" name="sqrtM" />
        <scope startLine="268" endLine="270" />
      </scope>
      <scope startLine="272" endLine="275">
        <declaration type="EigenDecomposition" name="dec" />
      </scope>
    </method>
  </class>
</source>
