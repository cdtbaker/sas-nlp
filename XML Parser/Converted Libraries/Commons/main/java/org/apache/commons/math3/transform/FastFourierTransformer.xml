<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.transform">
  <import name="java.io.Serializable" />
  <import name="java.lang.reflect.Array" />
  <import name="org.apache.commons.math3.analysis.FunctionUtils" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.complex.Complex" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.ArithmeticUtils" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="FastFourierTransformer" startLine="33">
    <implements name="Serializable" />
    <javadoc>
      <text>* Implements the Fast Fourier Transform for transformation of one-dimensional
 * real or complex data sets. For reference, see <em>Applied Numerical Linear
 * Algebra</em>, ISBN 0898713897, chapter 6.
 * <p>
 * There are several variants of the discrete Fourier transform, with various
 * normalization conventions, which are specified by the parameter{@link DftNormalization}.
 * <p>
 * The current implementation of the discrete Fourier transform as a fast
 * Fourier transform requires the length of the data set to be a power of 2.
 * This greatly simplifies and speeds up the code. Users can pad the data with
 * zeros to meet this requirement. There are other flavors of FFT, for
 * reference, see S. Winograd,
 * <i>On computing the discrete Fourier transform</i>, Mathematics of
 * Computation, 32 (1978), 175 - 199.</text>
      <see>DftNormalization</see>
      <version>$Id: FastFourierTransformer.java 1385310 2012-09-16 16:32:10Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* {@code W_SUB_N_R[i]} is the real part of{@code exp(- 2 * i * pi / n)}:{@code W_SUB_N_R[i] = cos(2 * pi/ n)}, where {@code n = 2^i}.</text>
    </javadoc>
    <declaration type="double[]" name="W_SUB_N_R" />
    <javadoc>
      <text>* {@code W_SUB_N_I[i]} is the imaginary part of{@code exp(- 2 * i * pi / n)}:{@code W_SUB_N_I[i] = -sin(2 * pi/ n)}, where {@code n = 2^i}.</text>
    </javadoc>
    <declaration type="double[]" name="W_SUB_N_I" />
    <javadoc>
      <text>* The type of DFT to be performed.</text>
    </javadoc>
    <declaration type="DftNormalization" name="normalization" />
    <javadoc>
      <text>* Creates a new instance of this class, with various normalization
 * conventions.</text>
      <param>normalization the type of normalization to be applied to the
 * transformed data</param>
    </javadoc>
    <method type="constructor" name="FastFourierTransformer" startLine="115" endLine="117" />
    <javadoc>
      <text>* Performs identical index bit reversal shuffles on two arrays of identical
 * size. Each element in the array is swapped with another element based on
 * the bit-reversal of the index. For example, in an array with length 16,
 * item at binary index 0011 (decimal 3) would be swapped with the item at
 * binary index 1100 (decimal 12).</text>
      <param>a the first array to be shuffled</param>
      <param>b the second array to be shuffled</param>
    </javadoc>
    <method type="void" name="bitReversalShuffle2" startLine="129" endLine="154">
      <declaration type="int" name="n" />
      <declaration type="int" name="halfOfN" />
      <declaration type="int" name="j" />
      <scope startLine="135" endLine="153">
        <scope startLine="136" endLine="145">
          <declaration type="double" name="temp" />
        </scope>
        <declaration type="int" name="k" />
        <scope startLine="148" endLine="151" />
        <comment>swap indices i & j</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Applies the proper normalization to the specified transformed data.</text>
      <param>dataRI the unscaled transformed data</param>
      <param>normalization the normalization to be applied</param>
      <param>type the type of transform (forward, inverse) which resulted in the specified data</param>
    </javadoc>
    <method type="void" name="normalizeTransformedData" startLine="164" endLine="197">
      <declaration type="double[]" name="dataR" />
      <declaration type="double[]" name="dataI" />
      <declaration type="int" name="n" />
      <scope startLine="173" endLine="179">
        <declaration type="double" name="scaleFactor" />
        <scope startLine="175" endLine="178" />
      </scope>
      <declaration type="double" name="scaleFactor" />
      <scope startLine="183" endLine="186" />
      <comment>This should never occur in normal conditions. However this
 clause has been added as a safeguard if other types of
 normalizations are ever implemented, and the corresponding
 test is forgotten in the present switch.</comment>
    </method>
    <javadoc>
      <text>* Computes the standard transform of the specified complex data. The
 * computation is done in place. The input data is laid out as follows
 * <ul>
 * <li>{@code dataRI[0][i]} is the real part of the {@code i}-th data point,</li>
 * <li>{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data point.</li>
 * </ul></text>
      <param>dataRI the two dimensional array of real and imaginary parts of the data</param>
      <param>normalization the normalization to be applied to the transformed data</param>
      <param>type the type of transform (forward, inverse) to be performed</param>
      <throws>DimensionMismatchException if the number of rows of the specified
 * array is not two, or the array is not rectangular</throws>
      <throws>MathIllegalArgumentException if the number of data points is not
 * a power of two</throws>
    </javadoc>
    <method type="void" name="transformInPlace" startLine="216" endLine="360">
      <scope startLine="218" endLine="220" />
      <declaration type="double[]" name="dataR" />
      <declaration type="double[]" name="dataI" />
      <scope startLine="223" endLine="225" />
      <declaration type="int" name="n" />
      <scope startLine="228" endLine="232" />
      <scope startLine="234" endLine="236" />
      <scope startLine="236" endLine="251">
        <declaration type="double" name="srcR0" />
        <declaration type="double" name="srcI0" />
        <declaration type="double" name="srcR1" />
        <declaration type="double" name="srcI1" />
        <comment>X_0 = x_0 + x_1</comment>
        <comment>X_1 = x_0 - x_1</comment>
      </scope>
      <scope startLine="256" endLine="285">
        <scope startLine="257" endLine="284">
          <declaration type="int" name="i1" />
          <declaration type="int" name="i2" />
          <declaration type="int" name="i3" />
          <declaration type="double" name="srcR0" />
          <declaration type="double" name="srcI0" />
          <declaration type="double" name="srcR1" />
          <declaration type="double" name="srcI1" />
          <declaration type="double" name="srcR2" />
          <declaration type="double" name="srcI2" />
          <declaration type="double" name="srcR3" />
          <declaration type="double" name="srcI3" />
        </scope>
        <comment>4-term DFT</comment>
        <comment>X_0 = x_0 + x_1 + x_2 + x_3</comment>
        <comment>X_1 = x_0 - x_2 + j * (x_3 - x_1)</comment>
        <comment>X_2 = x_0 - x_1 + x_2 - x_3</comment>
        <comment>X_3 = x_0 - x_2 + j * (x_1 - x_3)</comment>
      </scope>
      <scope startLine="285" endLine="314">
        <scope startLine="286" endLine="313">
          <declaration type="int" name="i1" />
          <declaration type="int" name="i2" />
          <declaration type="int" name="i3" />
          <declaration type="double" name="srcR0" />
          <declaration type="double" name="srcI0" />
          <declaration type="double" name="srcR1" />
          <declaration type="double" name="srcI1" />
          <declaration type="double" name="srcR2" />
          <declaration type="double" name="srcI2" />
          <declaration type="double" name="srcR3" />
          <declaration type="double" name="srcI3" />
        </scope>
        <comment>4-term DFT</comment>
        <comment>X_0 = x_0 + x_1 + x_2 + x_3</comment>
        <comment>X_1 = x_0 - x_2 + j * (x_3 - x_1)</comment>
        <comment>X_2 = x_0 - x_1 + x_2 - x_3</comment>
        <comment>X_3 = x_0 - x_2 + j * (x_1 - x_3)</comment>
      </scope>
      <declaration type="int" name="lastN0" />
      <declaration type="int" name="lastLogN0" />
      <scope startLine="318" endLine="357">
        <declaration type="int" name="n0" />
        <declaration type="int" name="logN0" />
        <declaration type="double" name="wSubN0R" />
        <declaration type="double" name="wSubN0I" />
        <scope startLine="323" endLine="325" />
        <scope startLine="328" endLine="353">
          <declaration type="int" name="destOddStartIndex" />
          <declaration type="double" name="wSubN0ToRR" />
          <declaration type="double" name="wSubN0ToRI" />
          <scope startLine="334" endLine="352">
            <declaration type="double" name="grR" />
            <declaration type="double" name="grI" />
            <declaration type="double" name="hrR" />
            <declaration type="double" name="hrI" />
            <declaration type="double" name="nextWsubN0ToRR" />
            <declaration type="double" name="nextWsubN0ToRI" />
          </scope>
        </scope>
        <comment>Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).</comment>
        <comment>dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr</comment>
        <comment>dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr</comment>
        <comment>WsubN0ToR *= WsubN0R</comment>
      </scope>
      <comment>Do 4-term DFT.</comment>
    </method>
    <javadoc>
      <text>* Returns the (forward, inverse) transform of the specified real data set.</text>
      <param>f the real data array to be transformed</param>
      <param>type the type of transform (forward, inverse) to be performed</param>
      <return>the complex transformed array</return>
      <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
    </javadoc>
    <method type="Complex[]" name="transform" startLine="370" endLine="378">
      <declaration type="double[][][]" name="dataRI" />
    </method>
    <javadoc>
      <text>* Returns the (forward, inverse) transform of the specified real function,
 * sampled on the specified interval.</text>
      <param>f the function to be sampled and transformed</param>
      <param>min the (inclusive) lower bound for the interval</param>
      <param>max the (exclusive) upper bound for the interval</param>
      <param>n the number of sample points</param>
      <param>type the type of transform (forward, inverse) to be performed</param>
      <return>the complex transformed array</return>
      <throws>org.apache.commons.math3.exception.NumberIsTooLargeExceptionif the lower bound is greater than, or equal to the upper bound</throws>
      <throws>org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points {@code n} is negative</throws>
      <throws>MathIllegalArgumentException if the number of sample points{@code n} is not a power of two</throws>
    </javadoc>
    <method type="Complex[]" name="transform" startLine="399" endLine="403">
      <declaration type="double[]" name="data" />
    </method>
    <javadoc>
      <text>* Returns the (forward, inverse) transform of the specified complex data set.</text>
      <param>f the complex data array to be transformed</param>
      <param>type the type of transform (forward, inverse) to be performed</param>
      <return>the complex transformed array</return>
      <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
    </javadoc>
    <method type="Complex[]" name="transform" startLine="413" endLine="419">
      <declaration type="double[][]" name="dataRI" />
    </method>
    <javadoc>
      <text>* Performs a multi-dimensional Fourier transform on a given array. Use{@link #transform(Complex[],TransformType)} in a row-column
 * implementation in any number of dimensions with
 * O(N&times;log(N)) complexity with
 * N = n<sub>1</sub> &times; n<sub>2</sub> &times;n<sub>3</sub> &times; ...
 * &times; n<sub>d</sub>, where n<sub>k</sub> is the number of elements in
 * dimension k, and d is the total number of dimensions.</text>
      <param>mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}</param>
      <param>type the type of transform (forward, inverse) to be performed</param>
      <return>transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}</return>
      <throws>IllegalArgumentException if any dimension is not a power of two</throws>
      <deprecated>see MATH-736</deprecated>
    </javadoc>
    <method type="Object" name="mdfft" startLine="437" endLine="446">
      <declaration type="MultiDimensionalComplexMatrix" name="mdcm" />
      <declaration type="int[]" name="dimensionSize" />
      <scope startLine="442" endLine="444" />
      <comment>cycle through each dimension</comment>
    </method>
    <javadoc>
      <text>* Performs one dimension of a multi-dimensional Fourier transform.</text>
      <param>mdcm input matrix</param>
      <param>type the type of transform (forward, inverse) to be performed</param>
      <param>d index of the dimension to process</param>
      <param>subVector recursion subvector</param>
      <throws>IllegalArgumentException if any dimension is not a power of two</throws>
      <deprecated>see MATH-736</deprecated>
    </javadoc>
    <method type="void" name="mdfft" startLine="460" endLine="494">
      <declaration type="int[]" name="dimensionSize" />
      <scope startLine="464" endLine="478">
        <declaration type="Complex[]" name="temp" />
        <scope startLine="466" endLine="470" />
        <scope startLine="474" endLine="477" />
        <comment>fft along dimension d</comment>
      </scope>
      <scope startLine="478" endLine="493">
        <declaration type="int[]" name="vector" />
        <scope startLine="481" endLine="486" />
        <scope startLine="486" endLine="492">
          <scope startLine="487" endLine="491" />
        </scope>
        <comment>value is not important once the recursion is done.</comment>
        <comment>then an fft will be applied along the dimension d.</comment>
        <comment>further split along the next dimension</comment>
      </scope>
      <comment>if done</comment>
    </method>
    <class name="MultiDimensionalComplexMatrix" startLine="496">
      <implements name="Cloneable" />
      <javadoc>
        <text>* Complex matrix implementation. Not designed for synchronized access may
 * eventually be replaced by jsr-83 of the java community process
 * http://jcp.org/en/jsr/detail?id=83
 * may require additional exception throws for other basic requirements.</text>
        <deprecated>see MATH-736</deprecated>
      </javadoc>
      <javadoc>
        <text>* Size in all dimensions.</text>
      </javadoc>
      <declaration type="int[]" name="dimensionSize" />
      <javadoc>
        <text>* Storage array.</text>
      </javadoc>
      <declaration type="Object" name="multiDimensionalComplexArray" />
      <javadoc>
        <text>* Simple constructor.</text>
        <param>multiDimensionalComplexArray array containing the matrix
 * elements</param>
      </javadoc>
      <method type="constructor" name="MultiDimensionalComplexMatrix" startLine="521" endLine="546">
        <declaration type="int" name="numOfDimensions" />
        <scope startLine="528" endLine="532">
          <declaration type="Object[][]" name="array" />
        </scope>
        <scope startLine="540" endLine="544">
          <declaration type="Object[][]" name="array" />
        </scope>
        <comment>count dimensions</comment>
        <comment>allocate array with exact count</comment>
        <comment>fill array</comment>
      </method>
      <javadoc>
        <text>* Get a matrix element.</text>
        <param>vector indices of the element</param>
        <return>matrix element</return>
        <exception>DimensionMismatchException if dimensions do not match</exception>
      </javadoc>
      <method type="Complex" name="get" startLine="556" endLine="578">
        <scope startLine="558" endLine="565">
          <scope startLine="559" endLine="563" />
        </scope>
        <scope startLine="566" endLine="570" />
        <declaration type="Object" name="lastDimension" />
        <scope startLine="574" endLine="576" />
      </method>
      <javadoc>
        <text>* Set a matrix element.</text>
        <param>magnitude magnitude of the element</param>
        <param>vector indices of the element</param>
        <return>the previous value</return>
        <exception>DimensionMismatchException if dimensions do not match</exception>
      </javadoc>
      <method type="Complex" name="set" startLine="589" endLine="614">
        <scope startLine="591" endLine="598">
          <scope startLine="592" endLine="596" />
        </scope>
        <scope startLine="599" endLine="603" />
        <declaration type="Object[][]" name="lastDimension" />
        <scope startLine="606" endLine="608" />
        <declaration type="Complex" name="lastValue" />
      </method>
      <javadoc>
        <text>* Get the size in all dimensions.</text>
        <return>size in all dimensions</return>
      </javadoc>
      <method type="int[]" name="getDimensionSizes" startLine="621" endLine="623" />
      <javadoc>
        <text>* Get the underlying storage array.</text>
        <return>underlying storage array</return>
      </javadoc>
      <method type="Object" name="getArray" startLine="630" endLine="632" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Object" name="clone" startLine="636" endLine="642">
        <declaration type="MultiDimensionalComplexMatrix" name="mdcm" />
      </method>
      <javadoc>
        <text>* Copy contents of current array into mdcm.</text>
        <param>mdcm array where to copy data</param>
      </javadoc>
      <method type="void" name="clone" startLine="649" endLine="673">
        <declaration type="int[]" name="vector" />
        <declaration type="int" name="size" />
        <scope startLine="653" endLine="655" />
        <declaration type="int[][]" name="vectorList" />
        <scope startLine="657" endLine="668">
          <scope startLine="660" endLine="667">
            <scope startLine="662" endLine="664" />
            <scope startLine="664" endLine="666" />
          </scope>
        </scope>
        <scope startLine="670" endLine="672" />
      </method>
    </class>
  </class>
</source>
