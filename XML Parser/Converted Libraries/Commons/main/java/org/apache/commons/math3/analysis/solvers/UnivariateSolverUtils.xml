<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.solvers">
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="UnivariateSolverUtils" startLine="27">
    <javadoc>
      <text>* Utility routines for {@link UnivariateSolver} objects.</text>
      <version>$Id: UnivariateSolverUtils.java 1400850 2012-10-22 11:57:17Z erans $</version>
    </javadoc>
    <javadoc>
      <text>* Class contains only static methods.</text>
    </javadoc>
    <method type="constructor" name="UnivariateSolverUtils" startLine="36" endLine="36" />
    <javadoc>
      <text>* Convenience method to find a zero of a univariate real function.  A default
 * solver is used.</text>
      <param>function Function.</param>
      <param>x0 Lower bound for the interval.</param>
      <param>x1 Upper bound for the interval.</param>
      <return>a value where the function is zero.</return>
      <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
      <throws>NullArgumentException if {@code function} is {@code null}.</throws>
    </javadoc>
    <method type="double" name="solve" startLine="52" endLine="58">
      <scope startLine="53" endLine="55" />
      <declaration type="UnivariateSolver" name="solver" />
    </method>
    <javadoc>
      <text>* Convenience method to find a zero of a univariate real function.  A default
 * solver is used.</text>
      <param>function Function.</param>
      <param>x0 Lower bound for the interval.</param>
      <param>x1 Upper bound for the interval.</param>
      <param>absoluteAccuracy Accuracy to be used by the solver.</param>
      <return>a value where the function is zero.</return>
      <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
      <throws>NullArgumentException if {@code function} is {@code null}.</throws>
    </javadoc>
    <method type="double" name="solve" startLine="77" endLine="83">
      <scope startLine="78" endLine="80" />
      <declaration type="UnivariateSolver" name="solver" />
    </method>
    <javadoc>
      <text>* Force a root found by a non-bracketing solver to lie on a specified side,
 * as if the solver was a bracketing one.</text>
      <param>maxEval maximal number of new evaluations of the function
 * (evaluations already done for finding the root should have already been subtracted
 * from this number)</param>
      <param>f function to solve</param>
      <param>bracketing bracketing solver to use for shifting the root</param>
      <param>baseRoot original root found by a previous non-bracketing solver</param>
      <param>min minimal bound of the search interval</param>
      <param>max maximal bound of the search interval</param>
      <param>allowedSolution the kind of solutions that the root-finding algorithm may
 * accept as solutions.</param>
      <return>a root approximation, on the specified side of the exact root</return>
      <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
    </javadoc>
    <method type="double" name="forceSide" startLine="105" endLine="171">
      <scope startLine="107" endLine="110">
        <comment>no further bracketing required</comment>
      </scope>
      <declaration type="double" name="step" />
      <declaration type="double" name="xLo" />
      <declaration type="double" name="fLo" />
      <declaration type="double" name="xHi" />
      <declaration type="double" name="fHi" />
      <declaration type="int" name="remainingEval" />
      <scope startLine="120" endLine="164">
        <scope startLine="122" endLine="125" />
        <declaration type="boolean" name="changeLo" />
        <declaration type="boolean" name="changeHi" />
        <scope startLine="130" endLine="137">
          <scope startLine="132" endLine="134" />
          <scope startLine="134" endLine="136" />
        </scope>
        <scope startLine="137" endLine="144">
          <scope startLine="139" endLine="141" />
          <scope startLine="141" endLine="143" />
        </scope>
        <scope startLine="144" endLine="148" />
        <scope startLine="151" endLine="155" />
        <scope startLine="158" endLine="162" />
        <comment>compute the root on the selected side</comment>
        <comment>try increasing the interval</comment>
        <comment>increasing function</comment>
        <comment>decreasing function</comment>
        <comment>unknown variation</comment>
        <comment>update the lower bound</comment>
        <comment>update the higher bound</comment>
      </scope>
      <comment>find a very small interval bracketing the root</comment>
    </method>
    <javadoc>
      <text>* This method attempts to find two values a and b satisfying <ul>
 * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>
 * <li> <code> f(a) * f(b) < 0 </code></li>
 * </ul>
 * If f is continuous on <code>[a,b],</code> this means that <code>a</code>
 * and <code>b</code> bracket a root of f.
 * <p>
 * The algorithm starts by setting
 * <code>a := initial -1; b := initial +1,</code> examines the value of the
 * function at <code>a</code> and <code>b</code> and keeps moving
 * the endpoints out by one unit each time through a loop that terminates
 * when one of the following happens: <ul>
 * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>
 * <li> <code> a = lower </code> and <code> b = upper</code>
 * -- NoBracketingException </li>
 * <li> <code> Integer.MAX_VALUE</code> iterations elapse
 * -- NoBracketingException </li>
 * </ul></p>
 * <p>
 * <strong>Note: </strong> this method can take
 * <code>Integer.MAX_VALUE</code> iterations to throw a
 * <code>ConvergenceException.</code>  Unless you are confident that there
 * is a root between <code>lowerBound</code> and <code>upperBound</code>
 * near <code>initial,</code> it is better to use{@link #bracket(UnivariateFunction,double,double,double,int)},
 * explicitly specifying the maximum number of iterations.</p></text>
      <param>function Function.</param>
      <param>initial Initial midpoint of interval being expanded to
 * bracket a root.</param>
      <param>lowerBound Lower bound (a is never lower than this value)</param>
      <param>upperBound Upper bound (b never is greater than this
 * value).</param>
      <return>a two-element array holding a and b.</return>
      <throws>NoBracketingException if a root cannot be bracketted.</throws>
      <throws>NotStrictlyPositiveException if {@code maximumIterations <= 0}.</throws>
      <throws>NullArgumentException if {@code function} is {@code null}.</throws>
    </javadoc>
    <method type="double[]" name="bracket" startLine="217" endLine="219" />
    <javadoc>
      <text>* This method attempts to find two values a and b satisfying <ul>
 * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>
 * <li> <code> f(a) * f(b) <= 0 </code> </li>
 * </ul>
 * If f is continuous on <code>[a,b],</code> this means that <code>a</code>
 * and <code>b</code> bracket a root of f.
 * <p>
 * The algorithm starts by setting
 * <code>a := initial -1; b := initial +1,</code> examines the value of the
 * function at <code>a</code> and <code>b</code> and keeps moving
 * the endpoints out by one unit each time through a loop that terminates
 * when one of the following happens: <ul>
 * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>
 * <li> <code> a = lower </code> and <code> b = upper</code>
 * -- NoBracketingException </li>
 * <li> <code> maximumIterations</code> iterations elapse
 * -- NoBracketingException </li></ul></p></text>
      <param>function Function.</param>
      <param>initial Initial midpoint of interval being expanded to
 * bracket a root.</param>
      <param>lowerBound Lower bound (a is never lower than this value).</param>
      <param>upperBound Upper bound (b never is greater than this
 * value).</param>
      <param>maximumIterations Maximum number of iterations to perform</param>
      <return>a two element array holding a and b.</return>
      <throws>NoBracketingException if the algorithm fails to find a and b
 * satisfying the desired conditions.</throws>
      <throws>NotStrictlyPositiveException if {@code maximumIterations <= 0}.</throws>
      <throws>NullArgumentException if {@code function} is {@code null}.</throws>
    </javadoc>
    <method type="double[]" name="bracket" startLine="259" endLine="292">
      <scope startLine="260" endLine="262" />
      <scope startLine="263" endLine="265" />
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="fa" />
      <declaration type="double" name="fb" />
      <declaration type="int" name="numIterations" />
      <scope startLine="274" endLine="281" />
      <scope startLine="284" endLine="289" />
    </method>
    <javadoc>
      <text>* Compute the midpoint of two values.</text>
      <param>a first value.</param>
      <param>b second value.</param>
      <return>the midpoint.</return>
    </javadoc>
    <method type="double" name="midpoint" startLine="301" endLine="303" />
    <javadoc>
      <text>* Check whether the interval bounds bracket a root. That is, if the
 * values at the endpoints are not equal to zero, then the function takes
 * opposite signs at the endpoints.</text>
      <param>function Function.</param>
      <param>lower Lower endpoint.</param>
      <param>upper Upper endpoint.</param>
      <return>{@code true} if the function values have opposite signs at the
 * given points.</return>
      <throws>NullArgumentException if {@code function} is {@code null}.</throws>
    </javadoc>
    <method type="boolean" name="isBracketing" startLine="320" endLine="327">
      <scope startLine="321" endLine="323" />
      <declaration type="double" name="fLo" />
      <declaration type="double" name="fHi" />
    </method>
    <javadoc>
      <text>* Check whether the arguments form a (strictly) increasing sequence.</text>
      <param>start First number.</param>
      <param>mid Second number.</param>
      <param>end Third number.</param>
      <return>{@code true} if the arguments form an increasing sequence.</return>
    </javadoc>
    <method type="boolean" name="isSequence" startLine="339" endLine="341" />
    <javadoc>
      <text>* Check that the endpoints specify an interval.</text>
      <param>lower Lower endpoint.</param>
      <param>upper Upper endpoint.</param>
      <throws>NumberIsTooLargeException if {@code lower >= upper}.</throws>
    </javadoc>
    <method type="void" name="verifyInterval" startLine="352" endLine="357">
      <scope startLine="353" endLine="356" />
    </method>
    <javadoc>
      <text>* Check that {@code lower < initial < upper}.</text>
      <param>lower Lower endpoint.</param>
      <param>initial Initial value.</param>
      <param>upper Upper endpoint.</param>
      <throws>NumberIsTooLargeException if {@code lower >= initial} or{@code initial >= upper}.</throws>
    </javadoc>
    <method type="void" name="verifySequence" startLine="371" endLine="374" />
    <javadoc>
      <text>* Check that the endpoints specify an interval and the end points
 * bracket a root.</text>
      <param>function Function.</param>
      <param>lower Lower endpoint.</param>
      <param>upper Upper endpoint.</param>
      <throws>NoBracketingException if the function has the same sign at the
 * endpoints.</throws>
      <throws>NullArgumentException if {@code function} is {@code null}.</throws>
    </javadoc>
    <method type="void" name="verifyBracketing" startLine="391" endLine="401">
      <scope startLine="392" endLine="394" />
      <scope startLine="396" endLine="400" />
    </method>
  </class>
</source>
