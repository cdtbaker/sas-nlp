<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.solvers">
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.TooManyEvaluationsException" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.Precision" />
  <class name="BracketingNthOrderBrentSolver" extends="AbstractUnivariateSolver" startLine="29">
    <implements name="BracketedUnivariateSolver<UnivariateFunction>" />
    <javadoc>
      <text>* This class implements a modification of the <a
 * href="http://mathworld.wolfram.com/BrentsMethod.html"> Brent algorithm</a>.
 * <p>
 * The changes with respect to the original Brent algorithm are:
 * <ul>
 * <li>the returned value is chosen in the current interval according
 * to user specified {@link AllowedSolution},</li>
 * <li>the maximal order for the invert polynomial root search is
 * user-specified instead of being invert quadratic only</li>
 * </ul>
 * </p>
 * The given interval must bracket the root.</text>
      <version>$Id: BracketingNthOrderBrentSolver.java 1379560 2012-08-31 19:40:30Z erans $</version>
    </javadoc>
    <javadoc>
      <text>* Default absolute accuracy.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_ABSOLUTE_ACCURACY" />
    <javadoc>
      <text>* Default maximal order.</text>
    </javadoc>
    <declaration type="int" name="DEFAULT_MAXIMAL_ORDER" />
    <javadoc>
      <text>* Maximal aging triggering an attempt to balance the bracketing interval.</text>
    </javadoc>
    <declaration type="int" name="MAXIMAL_AGING" />
    <javadoc>
      <text>* Reduction factor for attempts to balance the bracketing interval.</text>
    </javadoc>
    <declaration type="double" name="REDUCTION_FACTOR" />
    <javadoc>
      <text>* Maximal order.</text>
    </javadoc>
    <declaration type="int" name="maximalOrder" />
    <javadoc>
      <text>* The kinds of solutions that the algorithm may accept.</text>
    </javadoc>
    <declaration type="AllowedSolution" name="allowed" />
    <javadoc>
      <text>* Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)</text>
    </javadoc>
    <method type="constructor" name="BracketingNthOrderBrentSolver" startLine="70" endLine="72" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>absoluteAccuracy Absolute accuracy.</param>
      <param>maximalOrder maximal order.</param>
      <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
    </javadoc>
    <method type="constructor" name="BracketingNthOrderBrentSolver" startLine="83" endLine="90">
      <scope startLine="85" endLine="87" />
    </method>
    <javadoc>
      <text>* Construct a solver.</text>
      <param>relativeAccuracy Relative accuracy.</param>
      <param>absoluteAccuracy Absolute accuracy.</param>
      <param>maximalOrder maximal order.</param>
      <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
    </javadoc>
    <method type="constructor" name="BracketingNthOrderBrentSolver" startLine="103" endLine="110">
      <scope startLine="105" endLine="107" />
    </method>
    <javadoc>
      <text>* Construct a solver.</text>
      <param>relativeAccuracy Relative accuracy.</param>
      <param>absoluteAccuracy Absolute accuracy.</param>
      <param>functionValueAccuracy Function value accuracy.</param>
      <param>maximalOrder maximal order.</param>
      <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
    </javadoc>
    <method type="constructor" name="BracketingNthOrderBrentSolver" startLine="125" endLine="132">
      <scope startLine="127" endLine="129" />
    </method>
    <javadoc>
      <text>* Get the maximal order.</text>
      <return>maximal order</return>
    </javadoc>
    <method type="int" name="getMaximalOrder" startLine="137" endLine="139" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="doSolve" startLine="148" endLine="355">
      <declaration type="double[]" name="x" />
      <declaration type="double[]" name="y" />
      <scope startLine="159" endLine="162">
        <comment>return the initial guess if it is a perfect root.</comment>
      </scope>
      <scope startLine="166" endLine="169">
        <comment>return the first endpoint if it is a perfect root.</comment>
      </scope>
      <declaration type="int" name="nbPoints" />
      <declaration type="int" name="signChangeIndex" />
      <scope startLine="173" endLine="179">
        <comment>reduce interval if it brackets the root</comment>
      </scope>
      <scope startLine="179" endLine="196">
        <scope startLine="183" endLine="186" />
        <scope startLine="188" endLine="192" />
        <scope startLine="192" endLine="194" />
        <comment>evaluate second endpoint</comment>
        <comment>return the second endpoint if it is a perfect root.</comment>
        <comment>use all computed point as a start sampling array for solving</comment>
      </scope>
      <declaration type="double[]" name="tmpX" />
      <declaration type="double" name="xA" />
      <declaration type="double" name="yA" />
      <declaration type="double" name="absYA" />
      <declaration type="int" name="agingA" />
      <declaration type="double" name="xB" />
      <declaration type="double" name="yB" />
      <declaration type="double" name="absYB" />
      <declaration type="int" name="agingB" />
      <scope startLine="212" endLine="353">
        <declaration type="double" name="xTol" />
        <scope startLine="217" endLine="233" />
        <declaration type="double" name="targetY" />
        <scope startLine="237" endLine="243">
          <declaration type="int" name="p" />
          <declaration type="double" name="weightA" />
          <declaration type="double" name="weightB" />
        </scope>
        <scope startLine="243" endLine="249">
          <declaration type="int" name="p" />
          <declaration type="double" name="weightA" />
          <declaration type="double" name="weightB" />
        </scope>
        <scope startLine="249" endLine="252" />
        <declaration type="double" name="nextX" />
        <declaration type="int" name="start" />
        <declaration type="int" name="end" />
        <scope startLine="258" endLine="283">
          <scope startLine="264" endLine="281">
            <scope startLine="270" endLine="273" />
            <scope startLine="273" endLine="276" />
          </scope>
        </scope>
        <scope startLine="285" endLine="290" />
        <declaration type="double" name="nextY" />
        <scope startLine="294" endLine="298" />
        <scope startLine="300" endLine="309" />
        <scope startLine="309" endLine="322">
          <scope startLine="315" endLine="320" />
        </scope>
        <scope startLine="333" endLine="340" />
        <scope startLine="340" endLine="351" />
        <comment>check convergence of bracketing interval</comment>
        <comment>this should never happen</comment>
        <comment>target for the next evaluation point</comment>
        <comment>we keep updating the high bracket, try to compensate this</comment>
        <comment>we keep updating the low bracket, try to compensate this</comment>
        <comment>bracketing is balanced, try to find the root itself</comment>
        <comment>make a few attempts to guess a root,</comment>
        <comment>guess a value for current target, using inverse polynomial interpolation</comment>
        <comment>the guessed root is not strictly inside of the tightest bracketing interval</comment>
        <comment>the guessed root is either not strictly inside the interval or it</comment>
        <comment>is a NaN (which occurs when some sampling points share the same y)</comment>
        <comment>we try again with a lower interpolation order</comment>
        <comment>we have more points before the sign change, drop the lowest point</comment>
        <comment>we have more points after sign change, drop the highest point</comment>
        <comment>we need to do one more attempt</comment>
        <comment>fall back to bisection</comment>
        <comment>evaluate the function at the guessed root</comment>
        <comment>we have found an exact root, since it is not an approximation</comment>
        <comment>we don't need to bother about the allowed solutions setting</comment>
        <comment>we have been forced to ignore some points to keep bracketing,</comment>
        <comment>they are probably too far from the root, drop them from now on</comment>
        <comment>we have to drop one point in order to insert the new one</comment>
        <comment>keep the tightest bracketing interval as centered as possible</comment>
        <comment>we drop the lowest point, we have to shift the arrays and the index</comment>
        <comment>insert the last computed point</comment>
        <comment>(by construction, we know it lies inside the tightest bracketing interval)</comment>
        <comment>update the bracketing interval</comment>
        <comment>the sign change occurs before the inserted point</comment>
        <comment>the sign change occurs after the inserted point</comment>
        <comment>update the sign change index</comment>
      </scope>
      <comment>prepare arrays with the first points</comment>
      <comment>evaluate initial guess</comment>
      <comment>evaluate first  endpoint</comment>
      <comment>prepare a work array for inverse polynomial interpolation</comment>
      <comment>current tightest bracketing of the root</comment>
      <comment>search loop</comment>
    </method>
    <javadoc>
      <text>* Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.
 * <p>
 * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
 * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),
 * Q(y<sub>i</sub>) = x<sub>i</sub>.
 * </p></text>
      <param>targetY target value for y</param>
      <param>x reference points abscissas for interpolation,
 * note that this array <em>is</em> modified during computation</param>
      <param>y reference points ordinates for interpolation</param>
      <param>start start index of the points to consider (inclusive)</param>
      <param>end end index of the points to consider (exclusive)</param>
      <return>guessed root (will be a NaN if two points share the same y)</return>
    </javadoc>
    <method type="double" name="guessX" startLine="372" endLine="390">
      <scope startLine="375" endLine="380">
        <declaration type="int" name="delta" />
        <scope startLine="377" endLine="379" />
      </scope>
      <declaration type="double" name="x0" />
      <scope startLine="384" endLine="386" />
      <comment>compute Q Newton coefficients by divided differences</comment>
      <comment>evaluate Q(targetY)</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="solve" startLine="397" endLine="400" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="solve" startLine="408" endLine="411" />
  </class>
</source>
