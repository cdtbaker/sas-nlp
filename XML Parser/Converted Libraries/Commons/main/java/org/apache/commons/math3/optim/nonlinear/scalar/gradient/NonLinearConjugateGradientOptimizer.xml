<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.scalar.gradient">
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.analysis.solvers.BrentSolver" />
  <import name="org.apache.commons.math3.analysis.solvers.UnivariateSolver" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.TooManyEvaluationsException" />
  <import name="org.apache.commons.math3.exception.MathUnsupportedOperationException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.optim.OptimizationData" />
  <import name="org.apache.commons.math3.optim.PointValuePair" />
  <import name="org.apache.commons.math3.optim.ConvergenceChecker" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.GoalType" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="NonLinearConjugateGradientOptimizer" extends="GradientMultivariateOptimizer" startLine="35">
    <javadoc>
      <text>* Non-linear conjugate gradient optimizer.
 * <br/>
 * This class supports both the Fletcher-Reeves and the Polak-Ribière
 * update formulas for the conjugate search directions.
 * It also supports optional preconditioning.
 * <br/>
 * Constraints are not supported: the call to{@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.</text>
      <version>$Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Update formula for the beta parameter.</text>
    </javadoc>
    <declaration type="Formula" name="updateFormula" />
    <javadoc>
      <text>* Preconditioner (may be null).</text>
    </javadoc>
    <declaration type="Preconditioner" name="preconditioner" />
    <javadoc>
      <text>* solver to use in the line search (may be null).</text>
    </javadoc>
    <declaration type="UnivariateSolver" name="solver" />
    <javadoc>
      <text>* Initial step used to bracket the optimum in line search.</text>
    </javadoc>
    <declaration type="double" name="initialStep" />
    <javadoc>
      <text>* Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.</text>
      <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.</param>
      <param>checker Convergence checker.</param>
    </javadoc>
    <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="70" endLine="75" />
    <javadoc>
      <text>* Available choices of update formulas for the updating the parameter
 * that is used to compute the successive conjugate search directions.
 * For non-linear conjugate gradients, there are
 * two formulas:
 * <ul>
 * <li>Fletcher-Reeves formula</li>
 * <li>Polak-Ribière formula</li>
 * </ul>
 * On the one hand, the Fletcher-Reeves formula is guaranteed to converge
 * if the start point is close enough of the optimum whether the
 * Polak-Ribière formula may not converge in rare cases. On the
 * other hand, the Polak-Ribière formula is often faster when it
 * does converge. Polak-Ribière is often used.</text>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Fletcher-Reeves formula.</text>
    </javadoc>
    <javadoc>
      <text>* Polak-Ribière formula.</text>
    </javadoc>
    <class name="BracketingStep" startLine="102">
      <implements name="OptimizationData" />
      <javadoc>
        <text>* The initial step is a factor with respect to the search direction
 * (which itself is roughly related to the gradient of the function).
 * <br/>
 * It is used to find an interval that brackets the optimum in line
 * search.</text>
        <since>3.1</since>
      </javadoc>
      <javadoc>
        <text>* Initial step.</text>
      </javadoc>
      <declaration type="double" name="initialStep" />
      <javadoc>
        <param>step Initial step for the bracket search.</param>
      </javadoc>
      <method type="constructor" name="BracketingStep" startLine="118" endLine="120" />
      <javadoc>
        <text>* Gets the initial step.</text>
        <return>the initial step.</return>
      </javadoc>
      <method type="double" name="getBracketingStep" startLine="127" endLine="129" />
      <javadoc>
        <text>* Constructor with default {@link IdentityPreconditioner preconditioner}.</text>
        <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.</param>
        <param>checker Convergence checker.</param>
        <param>lineSearchSolver Solver to use during line search.</param>
      </javadoc>
      <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="143" endLine="148" />
      <javadoc>
        <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.</param>
        <param>checker Convergence checker.</param>
        <param>lineSearchSolver Solver to use during line search.</param>
        <param>preconditioner Preconditioner.</param>
      </javadoc>
      <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="161" endLine="168" />
      <javadoc>
        <text>* {@inheritDoc}</text>
        <param>optData Optimization data. In addition to those documented in{@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])GradientMultivariateOptimizer}, this method will register the following data:
 * <ul>
 * <li>{@link BracketingStep}</li>
 * </ul></param>
        <return>{@inheritDoc}</return>
        <throws>TooManyEvaluationsException if the maximal number of
 * evaluations (of the objective function) is exceeded.</throws>
      </javadoc>
      <method type="PointValuePair" name="optimize" startLine="185" endLine="188">
        <comment>Set up base class and perform computation.</comment>
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="PointValuePair" name="doOptimize" startLine="192" endLine="285">
        <declaration type="ConvergenceChecker<PointValuePair>" name="checker" />
        <declaration type="double[]" name="point" />
        <declaration type="GoalType" name="goal" />
        <declaration type="int" name="n" />
        <declaration type="double[]" name="r" />
        <scope startLine="198" endLine="202">
          <scope startLine="199" endLine="201" />
        </scope>
        <declaration type="double[]" name="steepestDescent" />
        <declaration type="double[]" name="searchDirection" />
        <declaration type="double" name="delta" />
        <scope startLine="209" endLine="211" />
        <declaration type="PointValuePair" name="current" />
        <declaration type="int" name="maxEval" />
        <scope startLine="215" endLine="284">
          <declaration type="double" name="objective" />
          <declaration type="PointValuePair" name="previous" />
          <scope startLine="221" endLine="224" />
          <declaration type="UnivariateFunction" name="lsf" />
          <declaration type="double" name="uB" />
          <declaration type="double" name="step" />
          <scope startLine="236" endLine="238" />
          <scope startLine="241" endLine="245">
            <scope startLine="242" endLine="244" />
          </scope>
          <declaration type="double" name="deltaOld" />
          <declaration type="double[]" name="newSteepestDescent" />
          <scope startLine="251" endLine="253" />
          <declaration type="double" name="beta" />
          <declaration type="double" name="deltaMid" />
          <scope startLine="262" endLine="264" />
          <scope startLine="275" endLine="278" />
          <scope startLine="278" endLine="283">
            <scope startLine="280" endLine="282" />
          </scope>
          <comment>We have found an optimum.</comment>
          <comment>Find the optimal step in the search direction.</comment>
          <comment>XXX Last parameters is set to a value close to zero in order to</comment>
          <comment>work around the divergence problem in the "testCircleFitting"</comment>
          <comment>unit test (see MATH-439).</comment>
          <comment>Subtract used up evaluations.</comment>
          <comment>Validate new point.</comment>
          <comment>Compute beta.</comment>
          <comment>Should never happen.</comment>
          <comment>Compute conjugate search direction.</comment>
          <comment>Break conjugation: reset search direction.</comment>
          <comment>Compute new conjugate search direction.</comment>
        </scope>
        <comment>Initial search direction.</comment>
      </method>
      <javadoc>
        <text>* Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
        <param>optData Optimization data.
 * The following data will be looked for:
 * <ul>
 * <li>{@link BracketingStep}</li>
 * </ul></param>
      </javadoc>
      <method type="void" name="parseOptimizationData" startLine="298" endLine="314">
        <scope startLine="304" endLine="311">
          <scope startLine="305" endLine="310" />
          <comment>If more data must be parsed, this statement _must_ be</comment>
          <comment>changed to "continue".</comment>
        </scope>
        <comment>Allow base class to register its own data.</comment>
        <comment>The existing values (as set by the previous call) are reused if</comment>
        <comment>not provided in the argument list.</comment>
      </method>
      <javadoc>
        <text>* Finds the upper bound b ensuring bracketing of a root between a and b.</text>
        <param>f function whose root must be bracketed.</param>
        <param>a lower bound of the interval.</param>
        <param>h initial step to try.</param>
        <return>b such that f(a) and f(b) have opposite signs.</return>
        <throws>MathIllegalStateException if no bracket can be found.</throws>
      </javadoc>
      <method type="double" name="findUpperBound" startLine="326" endLine="337">
        <declaration type="double" name="yA" />
        <declaration type="double" name="yB" />
        <scope startLine="329" endLine="335">
          <declaration type="double" name="b" />
          <scope startLine="332" endLine="334" />
        </scope>
      </method>
      <class name="IdentityPreconditioner" startLine="339">
        <implements name="Preconditioner" />
        <javadoc>
          <text>* Default identity preconditioner.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="double[]" name="precondition" startLine="342" endLine="344" />
        <class name="LineSearchFunction" startLine="347">
          <implements name="UnivariateFunction" />
          <javadoc>
            <text>* Internal class for line search.
 * <p>
 * The function represented by this class is the dot product of
 * the objective function gradient and the search direction. Its
 * value is zero when the gradient is orthogonal to the search
 * direction, i.e. when the objective function value is a local
 * extremum along the search direction.
 * </p></text>
          </javadoc>
          <javadoc>
            <text>* Current point.</text>
          </javadoc>
          <declaration type="double[]" name="currentPoint" />
          <javadoc>
            <text>* Search direction.</text>
          </javadoc>
          <declaration type="double[]" name="searchDirection" />
          <javadoc>
            <param>point Current point.</param>
            <param>direction Search direction.</param>
          </javadoc>
          <method type="constructor" name="LineSearchFunction" startLine="368" endLine="371" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="value" startLine="374" endLine="391">
            <declaration type="double[]" name="shiftedPoint" />
            <scope startLine="377" endLine="379" />
            <declaration type="double[]" name="gradient" />
            <declaration type="double" name="dotProduct" />
            <scope startLine="386" endLine="388" />
            <comment>current point in the search direction</comment>
            <comment>gradient of the objective function</comment>
            <comment>dot product with the search direction</comment>
          </method>
          <javadoc>
            <throws>MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.</throws>
          </javadoc>
          <method type="void" name="checkParameters" startLine="398" endLine="403">
            <scope startLine="400" endLine="402" />
          </method>
        </class>
      </class>
    </class>
  </class>
</source>
