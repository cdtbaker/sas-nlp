<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optimization.general">
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.analysis.solvers.BrentSolver" />
  <import name="org.apache.commons.math3.analysis.solvers.UnivariateSolver" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.optimization.GoalType" />
  <import name="org.apache.commons.math3.optimization.PointValuePair" />
  <import name="org.apache.commons.math3.optimization.SimpleValueChecker" />
  <import name="org.apache.commons.math3.optimization.ConvergenceChecker" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="NonLinearConjugateGradientOptimizer" extends="AbstractScalarDifferentiableOptimizer" startLine="31">
    <javadoc>
      <text>* Non-linear conjugate gradient optimizer.
 * <p>
 * This class supports both the Fletcher-Reeves and the Polak-Ribi&egrave;re
 * update formulas for the conjugate search directions. It also supports
 * optional preconditioning.
 * </p></text>
      <version>$Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $</version>
      <deprecated>As of 3.1 (to be removed in 4.0).</deprecated>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Update formula for the beta parameter.</text>
    </javadoc>
    <declaration type="ConjugateGradientFormula" name="updateFormula" />
    <javadoc>
      <text>* Preconditioner (may be null).</text>
    </javadoc>
    <declaration type="Preconditioner" name="preconditioner" />
    <javadoc>
      <text>* solver to use in the line search (may be null).</text>
    </javadoc>
    <declaration type="UnivariateSolver" name="solver" />
    <javadoc>
      <text>* Initial step used to bracket the optimum in line search.</text>
    </javadoc>
    <declaration type="double" name="initialStep" />
    <javadoc>
      <text>* Current point.</text>
    </javadoc>
    <declaration type="double[]" name="point" />
    <javadoc>
      <text>* Constructor with default {@link SimpleValueChecker checker},{@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.</text>
      <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
      <deprecated>See {@link SimpleValueChecker#SimpleValueChecker()}</deprecated>
    </javadoc>
    <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="69" endLine="72" />
    <javadoc>
      <text>* Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.</text>
      <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
      <param>checker Convergence checker.</param>
    </javadoc>
    <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="84" endLine="89" />
    <javadoc>
      <text>* Constructor with default {@link IdentityPreconditioner preconditioner}.</text>
      <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
      <param>checker Convergence checker.</param>
      <param>lineSearchSolver Solver to use during line search.</param>
    </javadoc>
    <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="103" endLine="108" />
    <javadoc>
      <param>updateFormula formula to use for updating the &beta; parameter,
 * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.</param>
      <param>checker Convergence checker.</param>
      <param>lineSearchSolver Solver to use during line search.</param>
      <param>preconditioner Preconditioner.</param>
    </javadoc>
    <method type="constructor" name="NonLinearConjugateGradientOptimizer" startLine="121" endLine="128" />
    <javadoc>
      <text>* Set the initial step used to bracket the optimum in line search.
 * <p>
 * The initial step is a factor with respect to the search direction,
 * which itself is roughly related to the gradient of the function
 * </p></text>
      <param>initialStep initial step used to bracket the optimum in line search,
 * if a non-positive value is used, the initial step is reset to its
 * default value of 1.0</param>
    </javadoc>
    <method type="void" name="setInitialStep" startLine="140" endLine="146">
      <scope startLine="141" endLine="143" />
      <scope startLine="143" endLine="145" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="PointValuePair" name="doOptimize" startLine="150" endLine="238">
      <declaration type="ConvergenceChecker<PointValuePair>" name="checker" />
      <declaration type="GoalType" name="goal" />
      <declaration type="int" name="n" />
      <declaration type="double[]" name="r" />
      <scope startLine="156" endLine="160">
        <scope startLine="157" endLine="159" />
      </scope>
      <declaration type="double[]" name="steepestDescent" />
      <declaration type="double[]" name="searchDirection" />
      <declaration type="double" name="delta" />
      <scope startLine="167" endLine="169" />
      <declaration type="PointValuePair" name="current" />
      <declaration type="int" name="iter" />
      <declaration type="int" name="maxEval" />
      <scope startLine="174" endLine="237">
        <declaration type="double" name="objective" />
        <declaration type="PointValuePair" name="previous" />
        <scope startLine="180" endLine="183" />
        <declaration type="UnivariateFunction" name="lsf" />
        <declaration type="double" name="uB" />
        <declaration type="double" name="step" />
        <scope startLine="195" endLine="197" />
        <scope startLine="200" endLine="204">
          <scope startLine="201" endLine="203" />
        </scope>
        <declaration type="double" name="deltaOld" />
        <declaration type="double[]" name="newSteepestDescent" />
        <scope startLine="210" endLine="212" />
        <declaration type="double" name="beta" />
        <scope startLine="215" endLine="217" />
        <scope startLine="217" endLine="223">
          <declaration type="double" name="deltaMid" />
          <scope startLine="219" endLine="221" />
        </scope>
        <scope startLine="228" endLine="231" />
        <scope startLine="231" endLine="236">
          <scope startLine="233" endLine="235" />
        </scope>
        <comment>We have found an optimum.</comment>
        <comment>Find the optimal step in the search direction.</comment>
        <comment>XXX Last parameters is set to a value close to zero in order to</comment>
        <comment>work around the divergence problem in the "testCircleFitting"</comment>
        <comment>unit test (see MATH-439).</comment>
        <comment>Subtract used up evaluations.</comment>
        <comment>Validate new point.</comment>
        <comment>Compute beta.</comment>
        <comment>Compute conjugate search direction.</comment>
        <comment>Break conjugation: reset search direction.</comment>
        <comment>Compute new conjugate search direction.</comment>
      </scope>
      <comment>Initial search direction.</comment>
    </method>
    <javadoc>
      <text>* Find the upper bound b ensuring bracketing of a root between a and b.</text>
      <param>f function whose root must be bracketed.</param>
      <param>a lower bound of the interval.</param>
      <param>h initial step to try.</param>
      <return>b such that f(a) and f(b) have opposite signs.</return>
      <throws>MathIllegalStateException if no bracket can be found.</throws>
    </javadoc>
    <method type="double" name="findUpperBound" startLine="250" endLine="261">
      <declaration type="double" name="yA" />
      <declaration type="double" name="yB" />
      <scope startLine="253" endLine="259">
        <declaration type="double" name="b" />
        <scope startLine="256" endLine="258" />
      </scope>
    </method>
    <class name="IdentityPreconditioner" startLine="263">
      <implements name="Preconditioner" />
      <javadoc>
        <text>* Default identity preconditioner.</text>
      </javadoc>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="double[]" name="precondition" startLine="267" endLine="269" />
      <class name="LineSearchFunction" startLine="272">
        <implements name="UnivariateFunction" />
        <javadoc>
          <text>* Internal class for line search.
 * <p>
 * The function represented by this class is the dot product of
 * the objective function gradient and the search direction. Its
 * value is zero when the gradient is orthogonal to the search
 * direction, i.e. when the objective function value is a local
 * extremum along the search direction.
 * </p></text>
        </javadoc>
        <javadoc>
          <text>* Search direction.</text>
        </javadoc>
        <declaration type="double[]" name="searchDirection" />
        <javadoc>
          <text>* Simple constructor.</text>
          <param>searchDirection search direction</param>
        </javadoc>
        <method type="constructor" name="LineSearchFunction" startLine="288" endLine="290" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="double" name="value" startLine="293" endLine="310">
          <declaration type="double[]" name="shiftedPoint" />
          <scope startLine="296" endLine="298" />
          <declaration type="double[]" name="gradient" />
          <declaration type="double" name="dotProduct" />
          <scope startLine="305" endLine="307" />
          <comment>current point in the search direction</comment>
          <comment>gradient of the objective function</comment>
          <comment>dot product with the search direction</comment>
        </method>
      </class>
    </class>
  </class>
</source>
