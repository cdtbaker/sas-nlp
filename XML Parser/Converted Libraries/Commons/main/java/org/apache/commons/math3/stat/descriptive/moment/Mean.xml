<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.stat.descriptive.moment">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic" />
  <import name="org.apache.commons.math3.stat.descriptive.WeightedEvaluation" />
  <import name="org.apache.commons.math3.stat.descriptive.summary.Sum" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="Mean" extends="AbstractStorelessUnivariateStatistic" startLine="28">
    <implements name="Serializable" />
    <implements name="WeightedEvaluation" />
    <javadoc>
      <text>* <p>Computes the arithmetic mean of a set of values. Uses the definitional
 * formula:</p>
 * <p>
 * mean = sum(x_i) / n
 * </p>
 * <p>where <code>n</code> is the number of observations.
 * </p>
 * <p>When {@link #increment(double)} is used to add data incrementally from a
 * stream of (unstored) values, the value of the statistic that{@link #getResult()} returns is computed using the following recursive
 * updating algorithm: </p>
 * <ol>
 * <li>Initialize <code>m = </code> the first value</li>
 * <li>For each additional value, update using <br>
 * <code>m = m + (new value - m) / (number of observations)</code></li>
 * </ol>
 * <p> If {@link #evaluate(double[])} is used to compute the mean of an array
 * of stored values, a two-pass, corrected algorithm is used, starting with
 * the definitional formula computed using the array of stored values and then
 * correcting this by adding the mean deviation of the data values from the
 * arithmetic mean. See, e.g. "Comparison of Several Algorithms for Computing
 * Sample Means and Variances," Robert F. Ling, Journal of the American
 * Statistical Association, Vol. 69, No. 348 (Dec., 1974), pp. 859-866. </p>
 * <p>
 * Returns <code>Double.NaN</code> if the dataset is empty.
 * </p>
 * <strong>Note that this implementation is not synchronized.</strong> If
 * multiple threads access an instance of this class concurrently, and at least
 * one of the threads invokes the <code>increment()</code> or
 * <code>clear()</code> method, it must be synchronized externally.</text>
      <version>$Id: Mean.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* First moment on which this statistic is based.</text>
    </javadoc>
    <declaration type="FirstMoment" name="moment" />
    <javadoc>
      <text>* Determines whether or not this statistic can be incremented or cleared.
 * <p>
 * Statistics based on (constructed from) external moments cannot
 * be incremented or cleared.</p></text>
    </javadoc>
    <declaration type="boolean" name="incMoment" />
    <javadoc>
      <text>* Constructs a Mean.</text>
    </javadoc>
    <method type="constructor" name="Mean" startLine="80" endLine="83" />
    <javadoc>
      <text>* Constructs a Mean with an External Moment.</text>
      <param>m1 the moment</param>
    </javadoc>
    <method type="constructor" name="Mean" startLine="90" endLine="93" />
    <javadoc>
      <text>* Copy constructor, creates a new {@code Mean} identical
 * to the {@code original}</text>
      <param>original the {@code Mean} instance to copy</param>
      <throws>NullArgumentException if original is null</throws>
    </javadoc>
    <method type="constructor" name="Mean" startLine="102" endLine="104" />
    <javadoc>
      <text>* {@inheritDoc}<p>Note that when {@link #Mean(FirstMoment)} is used to
 * create a Mean, this method does nothing. In that case, the
 * FirstMoment should be incremented directly.</p></text>
    </javadoc>
    <method type="void" name="increment" startLine="113" endLine="117">
      <scope startLine="114" endLine="116" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="clear" startLine="123" endLine="127">
      <scope startLine="124" endLine="126" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getResult" startLine="133" endLine="135" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="long" name="getN" startLine="140" endLine="142" />
    <javadoc>
      <text>* Returns the arithmetic mean of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * See {@link Mean} for details on the computing algorithm.</p></text>
      <param>values the input array</param>
      <param>begin index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the mean of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the array is null or the array index
 * parameters are not valid</throws>
    </javadoc>
    <method type="double" name="evaluate" startLine="162" endLine="178">
      <scope startLine="163" endLine="176">
        <declaration type="Sum" name="sum" />
        <declaration type="double" name="sampleSize" />
        <declaration type="double" name="xbar" />
        <declaration type="double" name="correction" />
        <scope startLine="172" endLine="174" />
        <comment>Compute initial estimate using definitional formula</comment>
        <comment>Compute correction factor in second pass</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the weighted arithmetic mean of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 * <p>
 * See {@link Mean} for details on the computing algorithm. The two-pass algorithm
 * described above is used here, with weights applied in computing both the original
 * estimate and the correction factor.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 * <li>the weights array is null</li>
 * <li>the weights array does not have the same length as the values array</li>
 * <li>the weights array contains one or more infinite values</li>
 * <li>the weights array contains one or more NaN values</li>
 * <li>the weights array contains negative values</li>
 * <li>the start and length arguments do not determine a valid array</li>
 * </ul></p></text>
      <param>values the input array</param>
      <param>weights the weights array</param>
      <param>begin index of the first array element to include</param>
      <param>length the number of elements to include</param>
      <return>the mean of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double" name="evaluate" startLine="210" endLine="226">
      <scope startLine="211" endLine="224">
        <declaration type="Sum" name="sum" />
        <declaration type="double" name="sumw" />
        <declaration type="double" name="xbarw" />
        <declaration type="double" name="correction" />
        <scope startLine="220" endLine="222" />
        <comment>Compute initial estimate using definitional formula</comment>
        <comment>Compute correction factor in second pass</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the weighted arithmetic mean of the entries in the input array.
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if either array is null.</p>
 * <p>
 * See {@link Mean} for details on the computing algorithm. The two-pass algorithm
 * described above is used here, with weights applied in computing both the original
 * estimate and the correction factor.</p>
 * <p>
 * Throws <code>MathIllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 * <li>the weights array is null</li>
 * <li>the weights array does not have the same length as the values array</li>
 * <li>the weights array contains one or more infinite values</li>
 * <li>the weights array contains one or more NaN values</li>
 * <li>the weights array contains negative values</li>
 * </ul></p></text>
      <param>values the input array</param>
      <param>weights the weights array</param>
      <return>the mean of the values or Double.NaN if length = 0</return>
      <throws>MathIllegalArgumentException if the parameters are not valid</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double" name="evaluate" startLine="253" endLine="255" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Mean" name="copy" startLine="261" endLine="266">
      <declaration type="Mean" name="result" />
      <comment>No try-catch or advertised exception because args are guaranteed non-null</comment>
    </method>
    <javadoc>
      <text>* Copies source to dest.
 * <p>Neither source nor dest can be null.</p></text>
      <param>source Mean to copy</param>
      <param>dest Mean to copy to</param>
      <throws>NullArgumentException if either source or dest is null</throws>
    </javadoc>
    <method type="void" name="copy" startLine="278" endLine="284" />
  </class>
</source>
