<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.nonstiff">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.ode.AbstractIntegrator" />
  <import name="org.apache.commons.math3.ode.ExpandableStatefulODE" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="AdaptiveStepsizeIntegrator" extends="AbstractIntegrator" startLine="29">
    <javadoc>
      <text>* This abstract class holds the common part of all adaptive
 * stepsize integrators for Ordinary Differential Equations.
 * <p>These algorithms perform integration with stepsize control, which
 * means the user does not specify the integration step but rather a
 * tolerance on error. The error threshold is computed as
 * <pre>
 * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))
 * </pre>
 * where absTol_i is the absolute tolerance for component i of the
 * state vector and relTol_i is the relative tolerance for the same
 * component. The user can also use only two scalar values absTol and
 * relTol which will be used for all components.
 * </p>
 * <p>
 * If the Ordinary Differential Equations is an {@link ExpandableStatefulODEextended ODE} rather than a {@link org.apache.commons.math3.ode.FirstOrderDifferentialEquations basic ODE}, then
 * <em>only</em> the {@link ExpandableStatefulODE#getPrimaryState() primary part}of the state vector is used for stepsize control, not the complete state vector.
 * </p>
 * <p>If the estimated error for ym+1 is such that
 * <pre>
 * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1
 * </pre>
 * (where n is the main set dimension) then the step is accepted,
 * otherwise the step is rejected and a new attempt is made with a new
 * stepsize.</p></text>
      <version>$Id: AdaptiveStepsizeIntegrator.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Allowed absolute scalar error.</text>
    </javadoc>
    <declaration type="double" name="scalAbsoluteTolerance" />
    <javadoc>
      <text>* Allowed relative scalar error.</text>
    </javadoc>
    <declaration type="double" name="scalRelativeTolerance" />
    <javadoc>
      <text>* Allowed absolute vectorial error.</text>
    </javadoc>
    <declaration type="double[]" name="vecAbsoluteTolerance" />
    <javadoc>
      <text>* Allowed relative vectorial error.</text>
    </javadoc>
    <declaration type="double[]" name="vecRelativeTolerance" />
    <javadoc>
      <text>* Main set dimension.</text>
    </javadoc>
    <declaration type="int" name="mainSetDimension" />
    <javadoc>
      <text>* User supplied initial step.</text>
    </javadoc>
    <declaration type="double" name="initialStep" />
    <javadoc>
      <text>* Minimal step.</text>
    </javadoc>
    <declaration type="double" name="minStep" />
    <javadoc>
      <text>* Maximal step.</text>
    </javadoc>
    <declaration type="double" name="maxStep" />
    <javadoc>
      <text>* Build an integrator with the given stepsize bounds.
 * The default step handler does nothing.</text>
      <param>name name of the method</param>
      <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>scalAbsoluteTolerance allowed absolute error</param>
      <param>scalRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="AdaptiveStepsizeIntegrator" startLine="108" endLine="114" />
    <javadoc>
      <text>* Build an integrator with the given stepsize bounds.
 * The default step handler does nothing.</text>
      <param>name name of the method</param>
      <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>vecAbsoluteTolerance allowed absolute error</param>
      <param>vecRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="AdaptiveStepsizeIntegrator" startLine="131" endLine="137" />
    <javadoc>
      <text>* Set the adaptive step size control parameters.
 * <p>
 * A side effect of this method is to also reset the initial
 * step so it will be automatically computed by the integrator
 * if {@link #setInitialStepSize(double) setInitialStepSize}is not called by the user.
 * </p></text>
      <param>minimalStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
      <param>maximalStep maximal step (must be positive even for backward
 * integration)</param>
      <param>absoluteTolerance allowed absolute error</param>
      <param>relativeTolerance allowed relative error</param>
    </javadoc>
    <method type="void" name="setStepSizeControl" startLine="155" endLine="166" />
    <javadoc>
      <text>* Set the adaptive step size control parameters.
 * <p>
 * A side effect of this method is to also reset the initial
 * step so it will be automatically computed by the integrator
 * if {@link #setInitialStepSize(double) setInitialStepSize}is not called by the user.
 * </p></text>
      <param>minimalStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
      <param>maximalStep maximal step (must be positive even for backward
 * integration)</param>
      <param>absoluteTolerance allowed absolute error</param>
      <param>relativeTolerance allowed relative error</param>
    </javadoc>
    <method type="void" name="setStepSizeControl" startLine="184" endLine="195" />
    <javadoc>
      <text>* Set the initial step size.
 * <p>This method allows the user to specify an initial positive
 * step size instead of letting the integrator guess it by
 * itself. If this method is not called before integration is
 * started, the initial step size will be estimated by the
 * integrator.</p></text>
      <param>initialStepSize initial step size to use (must be positive even
 * for backward integration ; providing a negative value or a value
 * outside of the min/max step interval will lead the integrator to
 * ignore the value and compute the initial step size by itself)</param>
    </javadoc>
    <method type="void" name="setInitialStepSize" startLine="208" endLine="214">
      <scope startLine="209" endLine="211" />
      <scope startLine="211" endLine="213" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="sanityChecks" startLine="219" endLine="233">
      <scope startLine="225" endLine="227" />
      <scope startLine="229" endLine="231" />
    </method>
    <javadoc>
      <text>* Initialize the integration step.</text>
      <param>forward forward integration indicator</param>
      <param>order order of the method</param>
      <param>scale scaling vector for the state vector (can be shorter than state vector)</param>
      <param>t0 start time</param>
      <param>y0 state vector at t0</param>
      <param>yDot0 first time derivative of y0</param>
      <param>y1 work array for a state vector</param>
      <param>yDot1 work array for the first time derivative of y1</param>
      <return>first integration step</return>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
      <exception>DimensionMismatchException if arrays dimensions do not match equations settings</exception>
    </javadoc>
    <method type="double" name="initializeStep" startLine="251" endLine="310">
      <scope startLine="253" endLine="256">
        <comment>use the user provided value</comment>
      </scope>
      <declaration type="double" name="ratio" />
      <declaration type="double" name="yOnScale2" />
      <declaration type="double" name="yDotOnScale2" />
      <scope startLine="263" endLine="268" />
      <declaration type="double" name="h" />
      <scope startLine="272" endLine="274" />
      <scope startLine="277" endLine="279" />
      <declaration type="double" name="yDDotOnScale" />
      <scope startLine="284" endLine="287" />
      <declaration type="double" name="maxInv2" />
      <declaration type="double" name="h1" />
      <scope startLine="298" endLine="300" />
      <scope startLine="301" endLine="303" />
      <scope startLine="304" endLine="306" />
      <comment>very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||</comment>
      <comment>this guess will be used to perform an Euler step</comment>
      <comment>perform an Euler step using the preceding rough guess</comment>
      <comment>estimate the second derivative of the solution</comment>
      <comment>step size is computed such that</comment>
      <comment>h^order * max (||y'/tol||, ||y''/tol||) = 0.01</comment>
      <comment>avoids cancellation when computing t1 - t0</comment>
    </method>
    <javadoc>
      <text>* Filter the integration step.</text>
      <param>h signed step</param>
      <param>forward forward integration indicator</param>
      <param>acceptSmall if true, steps smaller than the minimal value
 * are silently increased up to this value, if false such small
 * steps generate an exception</param>
      <return>a bounded integration step (h if no bound is reach, or a bounded value)</return>
      <exception>NumberIsTooSmallException if the step is too small and acceptSmall is false</exception>
    </javadoc>
    <method type="double" name="filterStep" startLine="322" endLine="342">
      <declaration type="double" name="filteredH" />
      <scope startLine="325" endLine="332">
        <scope startLine="326" endLine="328" />
        <scope startLine="328" endLine="331" />
      </scope>
      <scope startLine="334" endLine="336" />
      <scope startLine="336" endLine="338" />
    </method>
    <method name="integrate" type="void" startLine="344" endLine="348" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getCurrentStepStart" startLine="352" endLine="354" />
    <javadoc>
      <text>* Reset internal state to dummy values.</text>
    </javadoc>
    <method type="void" name="resetInternalState" startLine="357" endLine="360" />
    <javadoc>
      <text>* Get the minimal step.</text>
      <return>minimal step</return>
    </javadoc>
    <method type="double" name="getMinStep" startLine="365" endLine="367" />
    <javadoc>
      <text>* Get the maximal step.</text>
      <return>maximal step</return>
    </javadoc>
    <method type="double" name="getMaxStep" startLine="372" endLine="374" />
  </class>
</source>
