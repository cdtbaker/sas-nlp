<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.distribution">
  <import name="java.io.Serializable" />
  <import name="java.math.BigDecimal" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.fraction.BigFraction" />
  <import name="org.apache.commons.math3.fraction.BigFractionField" />
  <import name="org.apache.commons.math3.fraction.FractionConversionException" />
  <import name="org.apache.commons.math3.linear.Array2DRowFieldMatrix" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.linear.FieldMatrix" />
  <import name="org.apache.commons.math3.linear.RealMatrix" />
  <class name="KolmogorovSmirnovDistribution" startLine="35">
    <implements name="Serializable" />
    <javadoc>
      <text>* Implementation of the Kolmogorov-Smirnov distribution.
 * <p>
 * Treats the distribution of the two-sided {@code P(D_n < d)} where{@code D_n = sup_x |G(x) - G_n (x)|} for the theoretical cdf {@code G} and
 * the empirical cdf {@code G_n}.
 * </p>
 * <p>
 * This implementation is based on [1] with certain quick decisions for extreme
 * values given in [2].
 * </p>
 * <p>
 * In short, when wanting to evaluate {@code P(D_n < d)}, the method in [1] is
 * to write {@code d = (k - h) / n} for positive integer {@code k} and{@code 0 <= h < 1}. Then {@code P(D_n < d) = (n! / n^n) * t_kk}, where{@code t_kk} is the {@code (k, k)}'th entry in the special matrix{@code H^n}, i.e. {@code H} to the {@code n}'th power.
 * </p>
 * <p>
 * References:
 * <ul>
 * <li>[1] <a href="http://www.jstatsoft.org/v08/i18/">
 * Evaluating Kolmogorov's Distribution</a> by George Marsaglia, Wai
 * Wan Tsang, and Jingbo Wang</li>
 * <li>[2] <a href="http://www.jstatsoft.org/v39/i11/">
 * Computing the Two-Sided Kolmogorov-Smirnov Distribution</a> by Richard Simard
 * and Pierre L'Ecuyer</li>
 * </ul>
 * Note that [1] contains an error in computing h, refer to
 * <a href="https://issues.apache.org/jira/browse/MATH-437">MATH-437</a> for details.
 * </p></text>
      <see><a href="http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test">
 * Kolmogorov-Smirnov test (Wikipedia)</a></see>
      <version>$Id: KolmogorovSmirnovDistribution.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Number of observations.</text>
    </javadoc>
    <declaration type="int" name="n" />
    <javadoc>
      <param>n Number of observations</param>
      <throws>NotStrictlyPositiveException if {@code n <= 0}</throws>
    </javadoc>
    <method type="constructor" name="KolmogorovSmirnovDistribution" startLine="85" endLine="91">
      <scope startLine="86" endLine="88" />
    </method>
    <javadoc>
      <text>* Calculates {@code P(D_n < d)} using method described in [1] with quick
 * decisions for extreme values given in [2] (see above). The result is not
 * exact as with{@link KolmogorovSmirnovDistribution#cdfExact(double)} because
 * calculations are based on {@code double} rather than{@link org.apache.commons.math3.fraction.BigFraction}.</text>
      <param>d statistic</param>
      <return>the two-sided probability of {@code P(D_n < d)}</return>
      <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.</throws>
    </javadoc>
    <method type="double" name="cdf" startLine="108" endLine="110" />
    <javadoc>
      <text>* Calculates {@code P(D_n < d)} using method described in [1] with quick
 * decisions for extreme values given in [2] (see above). The result is
 * exact in the sense that BigFraction/BigReal is used everywhere at the
 * expense of very slow execution time. Almost never choose this in real
 * applications unless you are very sure; this is almost solely for
 * verification purposes. Normally, you would choose{@link KolmogorovSmirnovDistribution#cdf(double)}</text>
      <param>d statistic</param>
      <return>the two-sided probability of {@code P(D_n < d)}</return>
      <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.</throws>
    </javadoc>
    <method type="double" name="cdfExact" startLine="128" endLine="130" />
    <javadoc>
      <text>* Calculates {@code P(D_n < d)} using method described in [1] with quick
 * decisions for extreme values given in [2] (see above).</text>
      <param>d statistic</param>
      <param>exact whether the probability should be calculated exact using{@link org.apache.commons.math3.fraction.BigFraction} everywhere at the
 * expense of very slow execution time, or if {@code double} should be used
 * convenient places to gain speed. Almost never choose {@code true} in real
 * applications unless you are very sure; {@code true} is almost solely for
 * verification purposes.</param>
      <return>the two-sided probability of {@code P(D_n < d)}</return>
      <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.</throws>
    </javadoc>
    <method type="double" name="cdf" startLine="149" endLine="180">
      <declaration type="double" name="ninv" />
      <declaration type="double" name="ninvhalf" />
      <scope startLine="154" endLine="158" />
      <scope startLine="158" endLine="170">
        <declaration type="double" name="res" />
        <declaration type="double" name="f" />
        <scope startLine="164" endLine="166" />
        <comment>n! f^n = n*f * (n-1)*f * ... * 1*x</comment>
      </scope>
      <scope startLine="170" endLine="174" />
      <scope startLine="174" endLine="177" />
    </method>
    <javadoc>
      <text>* Calculates the exact value of {@code P(D_n < d)} using method described
 * in [1] and {@link org.apache.commons.math3.fraction.BigFraction} (see
 * above).</text>
      <param>d statistic</param>
      <return>the two-sided probability of {@code P(D_n < d)}</return>
      <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.</throws>
    </javadoc>
    <method type="double" name="exactK" startLine="194" endLine="213">
      <declaration type="int" name="k" />
      <declaration type="FieldMatrix<BigFraction>" name="H" />
      <declaration type="FieldMatrix<BigFraction>" name="Hpower" />
      <declaration type="BigFraction" name="pFrac" />
      <scope startLine="203" endLine="205" />
      <comment>BigFraction.doubleValue converts numerator to double and the
 denominator to double and divides afterwards. That gives NaN quite
 easy. This does not (scale is the number of digits):</comment>
    </method>
    <javadoc>
      <text>* Calculates {@code P(D_n < d)} using method described in [1] and doubles
 * (see above).</text>
      <param>d statistic</param>
      <return>the two-sided probability of {@code P(D_n < d)}</return>
      <throws>MathArithmeticException if algorithm fails to convert {@code h}to a {@link org.apache.commons.math3.fraction.BigFraction} in expressing{@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.</throws>
    </javadoc>
    <method type="double" name="roundedK" startLine="226" endLine="253">
      <declaration type="int" name="k" />
      <declaration type="FieldMatrix<BigFraction>" name="HBigFraction" />
      <declaration type="int" name="m" />
      <declaration type="RealMatrix" name="H" />
      <scope startLine="238" endLine="242">
        <scope startLine="239" endLine="241" />
      </scope>
      <declaration type="RealMatrix" name="Hpower" />
      <declaration type="double" name="pFrac" />
      <scope startLine="248" endLine="250" />
      <comment>Here the rounding part comes into play: use
 RealMatrix instead of FieldMatrix<BigFraction></comment>
    </method>
    <javadoc>
      <text>* Creates {@code H} of size {@code m x m} as described in [1] (see above).</text>
      <param>d statistic</param>
      <return>H matrix</return>
      <throws>NumberIsTooLargeException if fractional part is greater than 1</throws>
      <throws>FractionConversionException if algorithm fails to convert{@code h} to a {@link org.apache.commons.math3.fraction.BigFraction} in
 * expressing {@code d} as {@code (k - h) / m} for integer {@code k, m} and{@code 0 <= h < 1}.</throws>
    </javadoc>
    <method type="FieldMatrix<BigFraction>" name="createH" startLine="267" endLine="354">
      <declaration type="int" name="k" />
      <declaration type="int" name="m" />
      <declaration type="double" name="hDouble" />
      <scope startLine="274" endLine="276" />
      <declaration type="BigFraction" name="h" />
      <scope startLine="280" endLine="282" />
      <scope startLine="282" endLine="288">
        <scope startLine="283" endLine="285" />
        <scope startLine="285" endLine="287" />
      </scope>
      <declaration type="BigFraction[][]" name="Hdata" />
      <scope startLine="295" endLine="303">
        <scope startLine="296" endLine="302">
          <scope startLine="297" endLine="299" />
          <scope startLine="299" endLine="301" />
        </scope>
      </scope>
      <declaration type="BigFraction[]" name="hPowers" />
      <scope startLine="311" endLine="313" />
      <scope startLine="318" endLine="321" />
      <scope startLine="328" endLine="330" />
      <scope startLine="343" endLine="351">
        <scope startLine="344" endLine="350">
          <scope startLine="345" endLine="349">
            <scope startLine="346" endLine="348" />
          </scope>
        </scope>
      </scope>
      <comment>Start by filling everything with either 0 or 1.</comment>
      <comment>Setting up power-array to avoid calculating the same value twice:
 hPowers[0] = h^1 ... hPowers[m-1] = h^m</comment>
      <comment>First column and last row has special values (each other reversed).</comment>
      <comment>[1] states: "For 12 < h < 1 the bottom left element of the matrix
 should be (1 - 2h^m + (2h - 1)^m )m!" Since 0 <= h < 1, then if h >
 12 is sufficient to check:</comment>
      <comment>Aside from the first column and last row, the (i, j)-th element is
 1(i - j + 1)! if i - j + 1 >= 0, else 0. 1's and 0's are already
 put, so only division with (i - j + 1)! is needed in the elements
 that have 1's. There is no need to calculate (i - j + 1)! and then
 divide - small steps avoid overflows.

 Note that i - j + 1 > 0 <=> i + 1 > j instead of j'ing all the way to
 m. Also note that it is started at g = 2 because dividing by 1 isn't
 really necessary.</comment>
    </method>
  </class>
</source>
