<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="java.io.Serializable" />
  <import name="java.text.NumberFormat" />
  <import name="org.apache.commons.math3.RealFieldElement" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="FieldVector3D" startLine="30">
    <implements name="Serializable" />
    <javadoc>
      <text>* This class is a re-implementation of {@link Vector3D} using {@link RealFieldElement}.
 * <p>Instance of this class are guaranteed to be immutable.</p></text>
      <param><T>
 *  the type of the field elements</param>
      <version>$Id: FieldVector3D.java 1454903 2013-03-10 19:44:31Z luc $</version>
      <since>3.2</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Abscissa.</text>
    </javadoc>
    <declaration type="T" name="x" />
    <javadoc>
      <text>* Ordinate.</text>
    </javadoc>
    <declaration type="T" name="y" />
    <javadoc>
      <text>* Height.</text>
    </javadoc>
    <declaration type="T" name="z" />
    <javadoc>
      <text>* Simple constructor.
 * Build a vector from its coordinates</text>
      <param>x abscissa</param>
      <param>y ordinate</param>
      <param>z height</param>
      <see>#getX()</see>
      <see>#getY()</see>
      <see>#getZ()</see>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="60" endLine="64" />
    <javadoc>
      <text>* Simple constructor.
 * Build a vector from its coordinates</text>
      <param>v coordinates array</param>
      <exception>DimensionMismatchException if array does not have 3 elements</exception>
      <see>#toArray()</see>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="72" endLine="79">
      <scope startLine="73" endLine="75" />
    </method>
    <javadoc>
      <text>* Simple constructor.
 * Build a vector from its azimuthal coordinates</text>
      <param>alpha azimuth (&alpha;) around Z
 * (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)</param>
      <param>delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2</param>
      <see>#getAlpha()</see>
      <see>#getDelta()</see>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="89" endLine="94">
      <declaration type="T" name="cosDelta" />
    </method>
    <javadoc>
      <text>* Multiplicative constructor
 * Build a vector from another one and a scale factor.
 * The vector built will be a * u</text>
      <param>a scale factor</param>
      <param>u base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="102" endLine="106" />
    <javadoc>
      <text>* Multiplicative constructor
 * Build a vector from another one and a scale factor.
 * The vector built will be a * u</text>
      <param>a scale factor</param>
      <param>u base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="114" endLine="118" />
    <javadoc>
      <text>* Multiplicative constructor
 * Build a vector from another one and a scale factor.
 * The vector built will be a * u</text>
      <param>a scale factor</param>
      <param>u base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="126" endLine="130" />
    <javadoc>
      <text>* Linear constructor
 * Build a vector from two other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="141" endLine="146">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from two other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="157" endLine="162">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from two other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="173" endLine="178">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from three other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="192" endLine="197">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from three other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="211" endLine="216">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from three other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="230" endLine="235">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from four other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
      <param>a4 fourth scale factor</param>
      <param>u4 fourth base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="252" endLine="257">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from four other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
      <param>a4 fourth scale factor</param>
      <param>u4 fourth base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="274" endLine="279">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Linear constructor
 * Build a vector from four other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
      <param>a4 fourth scale factor</param>
      <param>u4 fourth base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="FieldVector3D" startLine="296" endLine="301">
      <declaration type="T" name="prototype" />
    </method>
    <javadoc>
      <text>* Get the abscissa of the vector.</text>
      <return>abscissa of the vector</return>
      <see>#FieldVector3D(RealFieldElement,RealFieldElement,RealFieldElement)</see>
    </javadoc>
    <method type="T" name="getX" startLine="307" endLine="309" />
    <javadoc>
      <text>* Get the ordinate of the vector.</text>
      <return>ordinate of the vector</return>
      <see>#FieldVector3D(RealFieldElement,RealFieldElement,RealFieldElement)</see>
    </javadoc>
    <method type="T" name="getY" startLine="315" endLine="317" />
    <javadoc>
      <text>* Get the height of the vector.</text>
      <return>height of the vector</return>
      <see>#FieldVector3D(RealFieldElement,RealFieldElement,RealFieldElement)</see>
    </javadoc>
    <method type="T" name="getZ" startLine="323" endLine="325" />
    <javadoc>
      <text>* Get the vector coordinates as a dimension 3 array.</text>
      <return>vector coordinates</return>
      <see>#FieldVector3D(RealFieldElement[])</see>
    </javadoc>
    <method type="T[]" name="toArray" startLine="331" endLine="337">
      <declaration type="T[]" name="array" />
    </method>
    <javadoc>
      <text>* Convert to a constant vector without derivatives.</text>
      <return>a constant vector</return>
    </javadoc>
    <method type="Vector3D" name="toVector3D" startLine="342" endLine="344" />
    <javadoc>
      <text>* Get the L<sub>1</sub> norm for the vector.</text>
      <return>L<sub>1</sub> norm for the vector</return>
    </javadoc>
    <method type="T" name="getNorm1" startLine="349" endLine="351" />
    <javadoc>
      <text>* Get the L<sub>2</sub> norm for the vector.</text>
      <return>Euclidean norm for the vector</return>
    </javadoc>
    <method type="T" name="getNorm" startLine="356" endLine="359">
      <comment>there are no cancellation problems here, so we use the straightforward formula</comment>
    </method>
    <javadoc>
      <text>* Get the square of the norm for the vector.</text>
      <return>square of the Euclidean norm for the vector</return>
    </javadoc>
    <method type="T" name="getNormSq" startLine="364" endLine="367">
      <comment>there are no cancellation problems here, so we use the straightforward formula</comment>
    </method>
    <javadoc>
      <text>* Get the L<sub>&infin;</sub> norm for the vector.</text>
      <return>L<sub>&infin;</sub> norm for the vector</return>
    </javadoc>
    <method type="T" name="getNormInf" startLine="372" endLine="389">
      <declaration type="T" name="xAbs" />
      <declaration type="T" name="yAbs" />
      <declaration type="T" name="zAbs" />
      <scope startLine="376" endLine="382">
        <scope startLine="377" endLine="379" />
        <scope startLine="379" endLine="381" />
      </scope>
      <scope startLine="382" endLine="388">
        <scope startLine="383" endLine="385" />
        <scope startLine="385" endLine="387" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the azimuth of the vector.</text>
      <return>azimuth (&alpha;) of the vector, between -&pi; and +&pi;</return>
      <see>#FieldVector3D(RealFieldElement,RealFieldElement)</see>
    </javadoc>
    <method type="T" name="getAlpha" startLine="395" endLine="397" />
    <javadoc>
      <text>* Get the elevation of the vector.</text>
      <return>elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2</return>
      <see>#FieldVector3D(RealFieldElement,RealFieldElement)</see>
    </javadoc>
    <method type="T" name="getDelta" startLine="403" endLine="405" />
    <javadoc>
      <text>* Add a vector to the instance.</text>
      <param>v vector to add</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="add" startLine="411" endLine="413" />
    <javadoc>
      <text>* Add a vector to the instance.</text>
      <param>v vector to add</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="add" startLine="419" endLine="421" />
    <javadoc>
      <text>* Add a scaled vector to the instance.</text>
      <param>factor scale factor to apply to v before adding it</param>
      <param>v vector to add</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="add" startLine="428" endLine="430" />
    <javadoc>
      <text>* Add a scaled vector to the instance.</text>
      <param>factor scale factor to apply to v before adding it</param>
      <param>v vector to add</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="add" startLine="437" endLine="441" />
    <javadoc>
      <text>* Add a scaled vector to the instance.</text>
      <param>factor scale factor to apply to v before adding it</param>
      <param>v vector to add</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="add" startLine="448" endLine="450" />
    <javadoc>
      <text>* Add a scaled vector to the instance.</text>
      <param>factor scale factor to apply to v before adding it</param>
      <param>v vector to add</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="add" startLine="457" endLine="461" />
    <javadoc>
      <text>* Subtract a vector from the instance.</text>
      <param>v vector to subtract</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="subtract" startLine="467" endLine="469" />
    <javadoc>
      <text>* Subtract a vector from the instance.</text>
      <param>v vector to subtract</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="subtract" startLine="475" endLine="477" />
    <javadoc>
      <text>* Subtract a scaled vector from the instance.</text>
      <param>factor scale factor to apply to v before subtracting it</param>
      <param>v vector to subtract</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="subtract" startLine="484" endLine="486" />
    <javadoc>
      <text>* Subtract a scaled vector from the instance.</text>
      <param>factor scale factor to apply to v before subtracting it</param>
      <param>v vector to subtract</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="subtract" startLine="493" endLine="497" />
    <javadoc>
      <text>* Subtract a scaled vector from the instance.</text>
      <param>factor scale factor to apply to v before subtracting it</param>
      <param>v vector to subtract</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="subtract" startLine="504" endLine="506" />
    <javadoc>
      <text>* Subtract a scaled vector from the instance.</text>
      <param>factor scale factor to apply to v before subtracting it</param>
      <param>v vector to subtract</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="subtract" startLine="513" endLine="517" />
    <javadoc>
      <text>* Get a normalized vector aligned with the instance.</text>
      <return>a new normalized vector</return>
      <exception>MathArithmeticException if the norm is zero</exception>
    </javadoc>
    <method type="FieldVector3D<T>" name="normalize" startLine="523" endLine="529">
      <declaration type="T" name="s" />
      <scope startLine="525" endLine="527" />
    </method>
    <javadoc>
      <text>* Get a vector orthogonal to the instance.
 * <p>There are an infinite number of normalized vectors orthogonal
 * to the instance. This method picks up one of them almost
 * arbitrarily. It is useful when one needs to compute a reference
 * frame with one of the axes in a predefined direction. The
 * following example shows how to build a frame having the k axis
 * aligned with the known vector u :
 * <pre><code>
 * Vector3D k = u.normalize();
 * Vector3D i = k.orthogonal();
 * Vector3D j = Vector3D.crossProduct(k, i);
 * </code></pre></p></text>
      <return>a new normalized vector orthogonal to the instance</return>
      <exception>MathArithmeticException if the norm of the instance is null</exception>
    </javadoc>
    <method type="FieldVector3D<T>" name="orthogonal" startLine="546" endLine="564">
      <declaration type="double" name="threshold" />
      <scope startLine="549" endLine="551" />
      <scope startLine="553" endLine="556">
        <declaration type="T" name="inverse" />
      </scope>
      <scope startLine="556" endLine="559">
        <declaration type="T" name="inverse" />
      </scope>
      <scope startLine="559" endLine="562">
        <declaration type="T" name="inverse" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the angular separation between two vectors.
 * <p>This method computes the angular separation between two
 * vectors using the dot product for well separated vectors and the
 * cross product for almost aligned vectors. This allows to have a
 * good accuracy in all cases, even for vectors very close to each
 * other.</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>angular separation between v1 and v2</return>
      <exception>MathArithmeticException if either vector has a null norm</exception>
    </javadoc>
    <method type="T" name="angle" startLine="579" endLine="600">
      <declaration type="T" name="normProduct" />
      <scope startLine="582" endLine="584" />
      <declaration type="T" name="dot" />
      <declaration type="double" name="threshold" />
      <scope startLine="588" endLine="595">
        <declaration type="FieldVector3D<T>" name="v3" />
        <scope startLine="591" endLine="593" />
        <comment>the vectors are almost aligned, compute using the sine</comment>
      </scope>
      <comment>the vectors are sufficiently separated to use the cosine</comment>
    </method>
    <javadoc>
      <text>* Compute the angular separation between two vectors.
 * <p>This method computes the angular separation between two
 * vectors using the dot product for well separated vectors and the
 * cross product for almost aligned vectors. This allows to have a
 * good accuracy in all cases, even for vectors very close to each
 * other.</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>angular separation between v1 and v2</return>
      <exception>MathArithmeticException if either vector has a null norm</exception>
    </javadoc>
    <method type="T" name="angle" startLine="615" endLine="636">
      <declaration type="T" name="normProduct" />
      <scope startLine="618" endLine="620" />
      <declaration type="T" name="dot" />
      <declaration type="double" name="threshold" />
      <scope startLine="624" endLine="631">
        <declaration type="FieldVector3D<T>" name="v3" />
        <scope startLine="627" endLine="629" />
        <comment>the vectors are almost aligned, compute using the sine</comment>
      </scope>
      <comment>the vectors are sufficiently separated to use the cosine</comment>
    </method>
    <javadoc>
      <text>* Compute the angular separation between two vectors.
 * <p>This method computes the angular separation between two
 * vectors using the dot product for well separated vectors and the
 * cross product for almost aligned vectors. This allows to have a
 * good accuracy in all cases, even for vectors very close to each
 * other.</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>angular separation between v1 and v2</return>
      <exception>MathArithmeticException if either vector has a null norm</exception>
    </javadoc>
    <method type="T" name="angle" startLine="651" endLine="653" />
    <javadoc>
      <text>* Get the opposite of the instance.</text>
      <return>a new vector which is opposite to the instance</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="negate" startLine="658" endLine="660" />
    <javadoc>
      <text>* Multiply the instance by a scalar.</text>
      <param>a scalar</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="scalarMultiply" startLine="666" endLine="668" />
    <javadoc>
      <text>* Multiply the instance by a scalar.</text>
      <param>a scalar</param>
      <return>a new vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="scalarMultiply" startLine="674" endLine="676" />
    <javadoc>
      <text>* Returns true if any coordinate of this vector is NaN; false otherwise</text>
      <return>true if any coordinate of this vector is NaN; false otherwise</return>
    </javadoc>
    <method type="boolean" name="isNaN" startLine="682" endLine="684" />
    <javadoc>
      <text>* Returns true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise</text>
      <return>true if any coordinate of this vector is infinite and none are NaN;
 * false otherwise</return>
    </javadoc>
    <method type="boolean" name="isInfinite" startLine="692" endLine="694" />
    <javadoc>
      <text>* Test for the equality of two 3D vectors.
 * <p>
 * If all coordinates of two 3D vectors are exactly the same, and none of their{@link RealFieldElement#getReal() real part} are <code>NaN</code>, the
 * two 3D vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) real part of the
 * coordinates of the 3D vector are <code>NaN</code>, the 3D vector is <code>NaN</code>.
 * </p></text>
      <param>other Object to test for equality to this</param>
      <return>true if two 3D vector objects are equal, false if
 * object is null, not an instance of Vector3D, or
 * not equal to this Vector3D instance</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="716" endLine="733">
      <scope startLine="718" endLine="720" />
      <scope startLine="722" endLine="731">
        <declaration type="FieldVector3D<T>" name="rhs" />
        <scope startLine="725" endLine="727" />
      </scope>
    </method>
    <javadoc>
      <text>* Get a hashCode for the 3D vector.
 * <p>
 * All NaN values have the same hash code.</p></text>
      <return>a hash code value for this object</return>
    </javadoc>
    <method type="int" name="hashCode" startLine="743" endLine="748">
      <scope startLine="744" endLine="746" />
    </method>
    <javadoc>
      <text>* Compute the dot-product of the instance and another vector.
 * <p>
 * The implementation uses specific multiplication and addition
 * algorithms to preserve accuracy and reduce cancellation effects.
 * It should be very accurate even for nearly orthogonal vectors.
 * </p></text>
      <see>MathArrays#linearCombination(double,double,double,double,double,double)</see>
      <param>v second vector</param>
      <return>the dot product this.v</return>
    </javadoc>
    <method type="T" name="dotProduct" startLine="760" endLine="762" />
    <javadoc>
      <text>* Compute the dot-product of the instance and another vector.
 * <p>
 * The implementation uses specific multiplication and addition
 * algorithms to preserve accuracy and reduce cancellation effects.
 * It should be very accurate even for nearly orthogonal vectors.
 * </p></text>
      <see>MathArrays#linearCombination(double,double,double,double,double,double)</see>
      <param>v second vector</param>
      <return>the dot product this.v</return>
    </javadoc>
    <method type="T" name="dotProduct" startLine="774" endLine="776" />
    <javadoc>
      <text>* Compute the cross-product of the instance with another vector.</text>
      <param>v other vector</param>
      <return>the cross product this ^ v as a new Vector3D</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="crossProduct" startLine="782" endLine="786" />
    <javadoc>
      <text>* Compute the cross-product of the instance with another vector.</text>
      <param>v other vector</param>
      <return>the cross product this ^ v as a new Vector3D</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="crossProduct" startLine="792" endLine="796" />
    <javadoc>
      <text>* Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNorm1()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the distance between the instance and p according to the L<sub>1</sub> norm</return>
    </javadoc>
    <method type="T" name="distance1" startLine="805" endLine="810">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNorm1()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the distance between the instance and p according to the L<sub>1</sub> norm</return>
    </javadoc>
    <method type="T" name="distance1" startLine="819" endLine="824">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNorm()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the distance between the instance and p according to the L<sub>2</sub> norm</return>
    </javadoc>
    <method type="T" name="distance" startLine="833" endLine="838">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNorm()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the distance between the instance and p according to the L<sub>2</sub> norm</return>
    </javadoc>
    <method type="T" name="distance" startLine="847" endLine="852">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNormInf()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the distance between the instance and p according to the L<sub>&infin;</sub> norm</return>
    </javadoc>
    <method type="T" name="distanceInf" startLine="861" endLine="878">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
      <scope startLine="865" endLine="871">
        <scope startLine="866" endLine="868" />
        <scope startLine="868" endLine="870" />
      </scope>
      <scope startLine="871" endLine="877">
        <scope startLine="872" endLine="874" />
        <scope startLine="874" endLine="876" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNormInf()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the distance between the instance and p according to the L<sub>&infin;</sub> norm</return>
    </javadoc>
    <method type="T" name="distanceInf" startLine="887" endLine="904">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
      <scope startLine="891" endLine="897">
        <scope startLine="892" endLine="894" />
        <scope startLine="894" endLine="896" />
      </scope>
      <scope startLine="897" endLine="903">
        <scope startLine="898" endLine="900" />
        <scope startLine="900" endLine="902" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute the square of the distance between the instance and another vector.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNormSq()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the square of the distance between the instance and p</return>
    </javadoc>
    <method type="T" name="distanceSq" startLine="913" endLine="918">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the square of the distance between the instance and another vector.
 * <p>Calling this method is equivalent to calling:
 * <code>q.subtract(p).getNormSq()</code> except that no intermediate
 * vector is built</p></text>
      <param>v second vector</param>
      <return>the square of the distance between the instance and p</return>
    </javadoc>
    <method type="T" name="distanceSq" startLine="927" endLine="932">
      <declaration type="T" name="dx" />
      <declaration type="T" name="dy" />
      <declaration type="T" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the dot-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the dot product v1.v2</return>
    </javadoc>
    <method type="T" name="dotProduct" startLine="941" endLine="943" />
    <javadoc>
      <text>* Compute the dot-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the dot product v1.v2</return>
    </javadoc>
    <method type="T" name="dotProduct" startLine="952" endLine="954" />
    <javadoc>
      <text>* Compute the dot-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the dot product v1.v2</return>
    </javadoc>
    <method type="T" name="dotProduct" startLine="963" endLine="965" />
    <javadoc>
      <text>* Compute the cross-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the cross product v1 ^ v2 as a new Vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="crossProduct" startLine="974" endLine="976" />
    <javadoc>
      <text>* Compute the cross-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the cross product v1 ^ v2 as a new Vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="crossProduct" startLine="985" endLine="987" />
    <javadoc>
      <text>* Compute the cross-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the cross product v1 ^ v2 as a new Vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="crossProduct" startLine="996" endLine="1000" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>1</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>1</sub> norm</return>
    </javadoc>
    <method type="T" name="distance1" startLine="1012" endLine="1014" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>1</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>1</sub> norm</return>
    </javadoc>
    <method type="T" name="distance1" startLine="1026" endLine="1028" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>1</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>1</sub> norm</return>
    </javadoc>
    <method type="T" name="distance1" startLine="1040" endLine="1042" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>2</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>2</sub> norm</return>
    </javadoc>
    <method type="T" name="distance" startLine="1054" endLine="1056" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>2</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>2</sub> norm</return>
    </javadoc>
    <method type="T" name="distance" startLine="1068" endLine="1070" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>2</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>2</sub> norm</return>
    </javadoc>
    <method type="T" name="distance" startLine="1082" endLine="1084" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>&infin;</sub> norm</return>
    </javadoc>
    <method type="T" name="distanceInf" startLine="1096" endLine="1098" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>&infin;</sub> norm</return>
    </javadoc>
    <method type="T" name="distanceInf" startLine="1110" endLine="1112" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the distance between v1 and v2 according to the L<sub>&infin;</sub> norm</return>
    </javadoc>
    <method type="T" name="distanceInf" startLine="1124" endLine="1126" />
    <javadoc>
      <text>* Compute the square of the distance between two vectors.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the square of the distance between v1 and v2</return>
    </javadoc>
    <method type="T" name="distanceSq" startLine="1138" endLine="1140" />
    <javadoc>
      <text>* Compute the square of the distance between two vectors.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the square of the distance between v1 and v2</return>
    </javadoc>
    <method type="T" name="distanceSq" startLine="1152" endLine="1154" />
    <javadoc>
      <text>* Compute the square of the distance between two vectors.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <param><T>
 *  the type of the field elements</param>
      <return>the square of the distance between v1 and v2</return>
    </javadoc>
    <method type="T" name="distanceSq" startLine="1166" endLine="1168" />
    <javadoc>
      <text>* Get a string representation of this vector.</text>
      <return>a string representation of this vector</return>
    </javadoc>
    <method type="String" name="toString" startLine="1174" endLine="1176" />
    <javadoc>
      <text>* Get a string representation of this vector.</text>
      <param>format the custom format for components</param>
      <return>a string representation of this vector</return>
    </javadoc>
    <method type="String" name="toString" startLine="1182" endLine="1184" />
  </class>
</source>
