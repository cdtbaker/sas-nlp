<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.nonstiff">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.ode.ExpandableStatefulODE" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="EmbeddedRungeKuttaIntegrator" extends="AdaptiveStepsizeIntegrator" startLine="27">
    <javadoc>
      <text>* This class implements the common part of all embedded Runge-Kutta
 * integrators for Ordinary Differential Equations.
 * <p>These methods are embedded explicit Runge-Kutta methods with two
 * sets of coefficients allowing to estimate the error, their Butcher
 * arrays are as follows :
 * <pre>
 * 0  |
 * c2  | a21
 * c3  | a31  a32
 * ... |        ...
 * cs  | as1  as2  ...  ass-1
 * |--------------------------
 * |  b1   b2  ...   bs-1  bs
 * |  b'1  b'2 ...   b's-1 b's
 * </pre>
 * </p>
 * <p>In fact, we rather use the array defined by ej = bj - b'j to
 * compute directly the error rather than computing two estimates and
 * then comparing them.</p>
 * <p>Some methods are qualified as <i>fsal</i> (first same as last)
 * methods. This means the last evaluation of the derivatives in one
 * step is the same as the first in the next step. Then, this
 * evaluation can be reused from one step to the next one and the cost
 * of such a method is really s-1 evaluations despite the method still
 * has s stages. This behaviour is true only for successful steps, if
 * the step is rejected after the error estimation phase, no
 * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and
 * asi = bi for all i.</p></text>
      <version>$Id: EmbeddedRungeKuttaIntegrator.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Indicator for <i>fsal</i> methods.</text>
    </javadoc>
    <declaration type="boolean" name="fsal" />
    <javadoc>
      <text>* Time steps from Butcher array (without the first zero).</text>
    </javadoc>
    <declaration type="double[]" name="c" />
    <javadoc>
      <text>* Internal weights from Butcher array (without the first empty row).</text>
    </javadoc>
    <declaration type="double[][]" name="a" />
    <javadoc>
      <text>* External weights for the high order method from Butcher array.</text>
    </javadoc>
    <declaration type="double[]" name="b" />
    <javadoc>
      <text>* Prototype of the step interpolator.</text>
    </javadoc>
    <declaration type="RungeKuttaStepInterpolator" name="prototype" />
    <javadoc>
      <text>* Stepsize control exponent.</text>
    </javadoc>
    <declaration type="double" name="exp" />
    <javadoc>
      <text>* Safety factor for stepsize control.</text>
    </javadoc>
    <declaration type="double" name="safety" />
    <javadoc>
      <text>* Minimal reduction factor for stepsize control.</text>
    </javadoc>
    <declaration type="double" name="minReduction" />
    <javadoc>
      <text>* Maximal growth factor for stepsize control.</text>
    </javadoc>
    <declaration type="double" name="maxGrowth" />
    <javadoc>
      <text>* Build a Runge-Kutta integrator with the given Butcher array.</text>
      <param>name name of the method</param>
      <param>fsal indicate that the method is an <i>fsal</i></param>
      <param>c time steps from Butcher array (without the first zero)</param>
      <param>a internal weights from Butcher array (without the first empty row)</param>
      <param>b propagation weights for the high order method from Butcher array</param>
      <param>prototype prototype of the step interpolator to use</param>
      <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>scalAbsoluteTolerance allowed absolute error</param>
      <param>scalRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="EmbeddedRungeKuttaIntegrator" startLine="115" endLine="132">
      <comment>set the default values of the algorithm control parameters</comment>
    </method>
    <javadoc>
      <text>* Build a Runge-Kutta integrator with the given Butcher array.</text>
      <param>name name of the method</param>
      <param>fsal indicate that the method is an <i>fsal</i></param>
      <param>c time steps from Butcher array (without the first zero)</param>
      <param>a internal weights from Butcher array (without the first empty row)</param>
      <param>b propagation weights for the high order method from Butcher array</param>
      <param>prototype prototype of the step interpolator to use</param>
      <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
      <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
      <param>vecAbsoluteTolerance allowed absolute error</param>
      <param>vecRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="EmbeddedRungeKuttaIntegrator" startLine="153" endLine="170">
      <comment>set the default values of the algorithm control parameters</comment>
    </method>
    <method name="getOrder" type="int" startLine="172" endLine="175" />
    <javadoc>
      <text>* Get the order of the method.</text>
      <return>order of the method</return>
    </javadoc>
    <javadoc>
      <text>* Get the safety factor for stepsize control.</text>
      <return>safety factor</return>
    </javadoc>
    <method type="double" name="getSafety" startLine="180" endLine="182" />
    <javadoc>
      <text>* Set the safety factor for stepsize control.</text>
      <param>safety safety factor</param>
    </javadoc>
    <method type="void" name="setSafety" startLine="187" endLine="189" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="integrate" startLine="195" endLine="340">
      <declaration type="boolean" name="forward" />
      <declaration type="double[]" name="y0" />
      <declaration type="double[]" name="y" />
      <declaration type="int" name="stages" />
      <declaration type="double[][]" name="yDotK" />
      <declaration type="double[]" name="yTmp" />
      <declaration type="double[]" name="yDotTmp" />
      <declaration type="RungeKuttaStepInterpolator" name="interpolator" />
      <declaration type="double" name="hNew" />
      <declaration type="boolean" name="firstTime" />
      <scope startLine="223" endLine="332">
        <declaration type="double" name="error" />
        <scope startLine="229" endLine="297">
          <scope startLine="231" endLine="234" />
          <scope startLine="236" endLine="250">
            <declaration type="double[]" name="scale" />
            <scope startLine="238" endLine="242">
              <scope startLine="239" endLine="241" />
            </scope>
            <scope startLine="242" endLine="246">
              <scope startLine="243" endLine="245" />
            </scope>
          </scope>
          <scope startLine="253" endLine="257">
            <scope startLine="254" endLine="256" />
          </scope>
          <scope startLine="257" endLine="261">
            <scope startLine="258" endLine="260" />
          </scope>
          <scope startLine="264" endLine="276">
            <scope startLine="266" endLine="272">
              <declaration type="double" name="sum" />
              <scope startLine="268" endLine="270" />
            </scope>
          </scope>
          <scope startLine="279" endLine="285">
            <declaration type="double" name="sum" />
            <scope startLine="281" endLine="283" />
          </scope>
          <scope startLine="289" endLine="295">
            <declaration type="double" name="factor" />
          </scope>
        </scope>
        <scope startLine="306" endLine="330">
          <scope startLine="311" endLine="314" />
          <declaration type="double" name="factor" />
          <declaration type="double" name="scaledH" />
          <declaration type="double" name="nextT" />
          <declaration type="boolean" name="nextIsLast" />
          <declaration type="double" name="filteredNextT" />
          <declaration type="boolean" name="filteredNextIsLast" />
          <scope startLine="326" endLine="328" />
        </scope>
        <comment>iterate over step size, ensuring local normalized error is smaller than 1</comment>
        <comment>first stage</comment>
        <comment>next stages</comment>
        <comment>estimate the state at the end of the step</comment>
        <comment>estimate the error at the end of the step</comment>
        <comment>reject the step and attempt to reduce error by stepsize control</comment>
        <comment>local error is small enough: accept the step, trigger events and step handlers</comment>
        <comment>prepare next step</comment>
        <comment>save the last evaluation for the next step</comment>
        <comment>stepsize control for next step</comment>
      </scope>
      <comment>create some internal working arrays</comment>
      <comment>set up an interpolator sharing the integrator arrays</comment>
      <comment>set up integration control objects</comment>
      <comment>main integration loop</comment>
      <comment>dispatch results</comment>
    </method>
    <javadoc>
      <text>* Get the minimal reduction factor for stepsize control.</text>
      <return>minimal reduction factor</return>
    </javadoc>
    <method type="double" name="getMinReduction" startLine="345" endLine="347" />
    <javadoc>
      <text>* Set the minimal reduction factor for stepsize control.</text>
      <param>minReduction minimal reduction factor</param>
    </javadoc>
    <method type="void" name="setMinReduction" startLine="352" endLine="354" />
    <javadoc>
      <text>* Get the maximal growth factor for stepsize control.</text>
      <return>maximal growth factor</return>
    </javadoc>
    <method type="double" name="getMaxGrowth" startLine="359" endLine="361" />
    <javadoc>
      <text>* Set the maximal growth factor for stepsize control.</text>
      <param>maxGrowth maximal growth factor</param>
    </javadoc>
    <method type="void" name="setMaxGrowth" startLine="366" endLine="368" />
    <method name="estimateError" type="double" startLine="370" endLine="379" />
    <javadoc>
      <text>* Compute the error ratio.</text>
      <param>yDotK derivatives computed during the first stages</param>
      <param>y0 estimate of the step at the start of the step</param>
      <param>y1 estimate of the step at the end of the step</param>
      <param>h  current step</param>
      <return>error ratio, greater than 1 if step should be rejected</return>
    </javadoc>
  </class>
</source>
