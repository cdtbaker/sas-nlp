<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.scalar">
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.analysis.function.Logit" />
  <import name="org.apache.commons.math3.analysis.function.Sigmoid" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="MultivariateFunctionMappingAdapter" startLine="28">
    <implements name="MultivariateFunction" />
    <javadoc>
      <text>* <p>Adapter for mapping bounded {@link MultivariateFunction} to unbounded ones.</p>
 * <p>
 * This adapter can be used to wrap functions subject to simple bounds on
 * parameters so they can be used by optimizers that do <em>not</em> directly
 * support simple bounds.
 * </p>
 * <p>
 * The principle is that the user function that will be wrapped will see its
 * parameters bounded as required, i.e when its {@code value} method is called
 * with argument array {@code point}, the elements array will fulfill requirement{@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components
 * may be unbounded or bounded only on one side if the corresponding bound is
 * set to an infinite value. The optimizer will not manage the user function by
 * itself, but it will handle this adapter and it is this adapter that will take
 * care the bounds are fulfilled. The adapter {@link #value(double[])} method will
 * be called by the optimizer with unbound parameters, and the adapter will map
 * the unbounded value to the bounded range using appropriate functions like{@link Sigmoid} for double bounded elements for example.
 * </p>
 * <p>
 * As the optimizer sees only unbounded parameters, it should be noted that the
 * start point or simplex expected by the optimizer should be unbounded, so the
 * user is responsible for converting his bounded point to unbounded by calling{@link #boundedToUnbounded(double[])} before providing them to the optimizer.
 * For the same reason, the point returned by the {@link org.apache.commons.math3.optimization.BaseMultivariateOptimizer#optimize(int,MultivariateFunction,org.apache.commons.math3.optimization.GoalType,double[])}method is unbounded. So to convert this point to bounded, users must call{@link #unboundedToBounded(double[])} by themselves!</p>
 * <p>
 * This adapter is only a poor man solution to simple bounds optimization constraints
 * that can be used with simple optimizers like{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerSimplexOptimizer}.
 * A better solution is to use an optimizer that directly supports simple bounds like{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerCMAESOptimizer} or{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.BOBYQAOptimizerBOBYQAOptimizer}.
 * One caveat of this poor-man's solution is that behavior near the bounds may be
 * numerically unstable as bounds are mapped from infinite values.
 * Another caveat is that convergence values are evaluated by the optimizer with
 * respect to unbounded variables, so there will be scales differences when
 * converted to bounded variables.
 * </p></text>
      <see>MultivariateFunctionPenaltyAdapter</see>
      <version>$Id: MultivariateFunctionMappingAdapter.java 1435539 2013-01-19 13:27:24Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Underlying bounded function.</text>
    </javadoc>
    <declaration type="MultivariateFunction" name="bounded" />
    <javadoc>
      <text>* Mapping functions.</text>
    </javadoc>
    <declaration type="Mapper[]" name="mappers" />
    <javadoc>
      <text>* Simple constructor.</text>
      <param>bounded bounded function</param>
      <param>lower lower bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for
 * unbounded values)</param>
      <param>upper upper bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.POSITIVE_INFINITY} for
 * unbounded values)</param>
      <exception>DimensionMismatchException if lower and upper bounds are not
 * consistent, either according to dimension or to values</exception>
    </javadoc>
    <method type="constructor" name="MultivariateFunctionMappingAdapter" startLine="100" endLine="135">
      <scope startLine="104" endLine="106" />
      <scope startLine="107" endLine="112">
        <scope startLine="109" endLine="111" />
        <comment>note the following test is written in such a way it also fails for NaN</comment>
      </scope>
      <scope startLine="116" endLine="134">
        <scope startLine="117" endLine="125">
          <scope startLine="118" endLine="121" />
          <scope startLine="121" endLine="124" />
        </scope>
        <scope startLine="125" endLine="133">
          <scope startLine="126" endLine="129" />
          <scope startLine="129" endLine="132" />
        </scope>
        <comment>element is unbounded, no transformation is needed</comment>
        <comment>element is simple-bounded on the upper side</comment>
        <comment>element is simple-bounded on the lower side</comment>
        <comment>element is double-bounded</comment>
      </scope>
      <comment>safety checks</comment>
    </method>
    <javadoc>
      <text>* Maps an array from unbounded to bounded.</text>
      <param>point Unbounded values.</param>
      <return>the bounded values.</return>
    </javadoc>
    <method type="double[]" name="unboundedToBounded" startLine="143" endLine="151">
      <declaration type="double[]" name="mapped" />
      <scope startLine="146" endLine="148" />
      <comment>Map unbounded input point to bounded point.</comment>
    </method>
    <javadoc>
      <text>* Maps an array from bounded to unbounded.</text>
      <param>point Bounded values.</param>
      <return>the unbounded values.</return>
    </javadoc>
    <method type="double[]" name="boundedToUnbounded" startLine="159" endLine="167">
      <declaration type="double[]" name="mapped" />
      <scope startLine="162" endLine="164" />
      <comment>Map bounded input point to unbounded point.</comment>
    </method>
    <javadoc>
      <text>* Compute the underlying function value from an unbounded point.
 * <p>
 * This method simply bounds the unbounded point using the mappings
 * set up at construction and calls the underlying function using
 * the bounded point.
 * </p></text>
      <param>point unbounded value</param>
      <return>underlying function value</return>
      <see>#unboundedToBounded(double[])</see>
    </javadoc>
    <method type="double" name="value" startLine="180" endLine="182" />
    <interface name="Mapper" startLine="184">
      <javadoc>
        <text>* Mapping interface.</text>
      </javadoc>
      <method name="unboundedToBounded" type="double" startLine="186" endLine="192" />
      <javadoc>
        <text>* Maps a value from unbounded to bounded.</text>
        <param>y Unbounded value.</param>
        <return>the bounded value.</return>
      </javadoc>
      <method name="boundedToUnbounded" type="double" startLine="194" endLine="200" />
      <javadoc>
        <text>* Maps a value from bounded to unbounded.</text>
        <param>x Bounded value.</param>
        <return>the unbounded value.</return>
      </javadoc>
      <class name="NoBoundsMapper" startLine="203">
        <implements name="Mapper" />
        <javadoc>
          <text>* Local class for no bounds mapping.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="double" name="unboundedToBounded" startLine="206" endLine="208" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="double" name="boundedToUnbounded" startLine="211" endLine="213" />
        <class name="LowerBoundMapper" startLine="216">
          <implements name="Mapper" />
          <javadoc>
            <text>* Local class for lower bounds mapping.</text>
          </javadoc>
          <javadoc>
            <text>* Low bound.</text>
          </javadoc>
          <declaration type="double" name="lower" />
          <javadoc>
            <text>* Simple constructor.</text>
            <param>lower lower bound</param>
          </javadoc>
          <method type="constructor" name="LowerBoundMapper" startLine="226" endLine="228" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="unboundedToBounded" startLine="231" endLine="233" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="double" name="boundedToUnbounded" startLine="236" endLine="238" />
          <class name="UpperBoundMapper" startLine="242">
            <implements name="Mapper" />
            <javadoc>
              <text>* Local class for upper bounds mapping.</text>
            </javadoc>
            <javadoc>
              <text>* Upper bound.</text>
            </javadoc>
            <declaration type="double" name="upper" />
            <javadoc>
              <text>* Simple constructor.</text>
              <param>upper upper bound</param>
            </javadoc>
            <method type="constructor" name="UpperBoundMapper" startLine="251" endLine="253" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="double" name="unboundedToBounded" startLine="256" endLine="258" />
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="double" name="boundedToUnbounded" startLine="261" endLine="263" />
            <class name="LowerUpperBoundMapper" startLine="267">
              <implements name="Mapper" />
              <javadoc>
                <text>* Local class for lower and bounds mapping.</text>
              </javadoc>
              <javadoc>
                <text>* Function from unbounded to bounded.</text>
              </javadoc>
              <declaration type="UnivariateFunction" name="boundingFunction" />
              <javadoc>
                <text>* Function from bounded to unbounded.</text>
              </javadoc>
              <declaration type="UnivariateFunction" name="unboundingFunction" />
              <javadoc>
                <text>* Simple constructor.</text>
                <param>lower lower bound</param>
                <param>upper upper bound</param>
              </javadoc>
              <method type="constructor" name="LowerUpperBoundMapper" startLine="280" endLine="283" />
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="double" name="unboundedToBounded" startLine="286" endLine="288" />
              <javadoc>
                <text>* {@inheritDoc}</text>
              </javadoc>
              <method type="double" name="boundedToUnbounded" startLine="291" endLine="293" />
            </class>
          </class>
        </class>
      </class>
    </interface>
  </class>
</source>
