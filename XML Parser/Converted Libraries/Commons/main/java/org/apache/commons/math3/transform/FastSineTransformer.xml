<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.transform">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.analysis.FunctionUtils" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.complex.Complex" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.ArithmeticUtils" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="FastSineTransformer" startLine="29">
    <implements name="RealTransformer" />
    <implements name="Serializable" />
    <javadoc>
      <text>* Implements the Fast Sine Transform for transformation of one-dimensional real
 * data sets. For reference, see James S. Walker, <em>Fast Fourier
 * Transforms</em>, chapter 3 (ISBN 0849371635).
 * <p>
 * There are several variants of the discrete sine transform. The present
 * implementation corresponds to DST-I, with various normalization conventions,
 * which are specified by the parameter {@link DstNormalization}.
 * <strong>It should be noted that regardless to the convention, the first
 * element of the dataset to be transformed must be zero.</strong>
 * <p>
 * DST-I is equivalent to DFT of an <em>odd extension</em> of the data series.
 * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set
 * to be sine transformed, the extended data set x<sub>0</sub><sup>&#35;</sup>,
 * &hellip;, x<sub>2N-1</sub><sup>&#35;</sup> is defined as follows
 * <ul>
 * <li>x<sub>0</sub><sup>&#35;</sup> = x<sub>0</sub> = 0,</li>
 * <li>x<sub>k</sub><sup>&#35;</sup> = x<sub>k</sub> if 1 &le; k &lt; N,</li>
 * <li>x<sub>N</sub><sup>&#35;</sup> = 0,</li>
 * <li>x<sub>k</sub><sup>&#35;</sup> = -x<sub>2N-k</sub> if N + 1 &le; k &lt;
 * 2N.</li>
 * </ul>
 * <p>
 * Then, the standard DST-I y<sub>0</sub>, &hellip;, y<sub>N-1</sub> of the real
 * data set x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is equal to <em>half</em>
 * of i (the pure imaginary number) times the N first elements of the DFT of the
 * extended data set x<sub>0</sub><sup>&#35;</sup>, &hellip;,
 * x<sub>2N-1</sub><sup>&#35;</sup> <br />
 * y<sub>n</sub> = (i / 2) &sum;<sub>k=0</sub><sup>2N-1</sup>
 * x<sub>k</sub><sup>&#35;</sup> exp[-2&pi;i nk / (2N)]
 * &nbsp;&nbsp;&nbsp;&nbsp;k = 0, &hellip;, N-1.
 * <p>
 * The present implementation of the discrete sine transform as a fast sine
 * transform requires the length of the data to be a power of two. Besides,
 * it implicitly assumes that the sampled function is odd. In particular, the
 * first element of the data set must be 0, which is enforced in{@link #transform(UnivariateFunction,double,double,int,TransformType)},
 * after sampling.</text>
      <version>$Id: FastSineTransformer.java 1385310 2012-09-16 16:32:10Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* The type of DST to be performed.</text>
    </javadoc>
    <declaration type="DstNormalization" name="normalization" />
    <javadoc>
      <text>* Creates a new instance of this class, with various normalization conventions.</text>
      <param>normalization the type of normalization to be applied to the transformed data</param>
    </javadoc>
    <method type="constructor" name="FastSineTransformer" startLine="84" endLine="86" />
    <javadoc>
      <text>* {@inheritDoc}The first element of the specified data set is required to be {@code 0}.</text>
      <throws>MathIllegalArgumentException if the length of the data array is
 * not a power of two, or the first element of the data array is not zero</throws>
    </javadoc>
    <method type="double[]" name="transform" startLine="96" endLine="106">
      <scope startLine="97" endLine="100">
        <declaration type="double" name="s" />
      </scope>
      <scope startLine="101" endLine="103" />
      <declaration type="double" name="s" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}This implementation enforces {@code f(x) = 0.0} at {@code x = 0.0}.</text>
      <throws>org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif the lower bound is greater than, or equal to the upper bound</throws>
      <throws>org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points is negative</throws>
      <throws>MathIllegalArgumentException if the number of sample points is not a power of two</throws>
    </javadoc>
    <method type="double[]" name="transform" startLine="121" endLine="126">
      <declaration type="double[]" name="data" />
    </method>
    <javadoc>
      <text>* Perform the FST algorithm (including inverse). The first element of the
 * data set is required to be {@code 0}.</text>
      <param>f the real data array to be transformed</param>
      <return>the real transformed array</return>
      <throws>MathIllegalArgumentException if the length of the data array is
 * not a power of two, or the first element of the data array is not zero</throws>
    </javadoc>
    <method type="double[]" name="fst" startLine="137" endLine="180">
      <declaration type="double[]" name="transformed" />
      <scope startLine="141" endLine="145" />
      <scope startLine="146" endLine="150" />
      <declaration type="int" name="n" />
      <scope startLine="152" endLine="155">
        <comment>trivial case</comment>
      </scope>
      <declaration type="double[]" name="x" />
      <scope startLine="161" endLine="166">
        <declaration type="double" name="a" />
        <declaration type="double" name="b" />
      </scope>
      <declaration type="FastFourierTransformer" name="transformer" />
      <declaration type="Complex[]" name="y" />
      <scope startLine="174" endLine="177" />
      <comment>construct a new array and perform FFT on it</comment>
      <comment>reconstruct the FST result for the original array</comment>
    </method>
  </class>
</source>
