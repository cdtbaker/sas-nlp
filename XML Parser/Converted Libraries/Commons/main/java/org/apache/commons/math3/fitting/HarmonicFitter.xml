<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.fitting">
  <import name="org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer" />
  <import name="org.apache.commons.math3.analysis.function.HarmonicOscillator" />
  <import name="org.apache.commons.math3.exception.ZeroException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="HarmonicFitter" extends="CurveFitter<HarmonicOscillator.Parametric>" startLine="27">
    <javadoc>
      <text>* Class that implements a curve fitting specialized for sinusoids.
 * Harmonic fitting is a very simple case of curve fitting. The
 * estimated coefficients are the amplitude a, the pulsation &omega; and
 * the phase &phi;: <code>f (t) = a cos (&omega; t + &phi;)</code>. They are
 * searched by a least square estimator initialized with a rough guess
 * based on integrals.</text>
      <version>$Id: HarmonicFitter.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Simple constructor.</text>
      <param>optimizer Optimizer to use for the fitting.</param>
    </javadoc>
    <method type="constructor" name="HarmonicFitter" startLine="44" endLine="46" />
    <javadoc>
      <text>* Fit an harmonic function to the observed points.</text>
      <param>initialGuess First guess values in the following order:
 * <ul>
 * <li>Amplitude</li>
 * <li>Angular frequency</li>
 * <li>Phase</li>
 * </ul></param>
      <return>the parameters of the harmonic function that best fits the
 * observed points (in the same order as above).</return>
    </javadoc>
    <method type="double[]" name="fit" startLine="60" endLine="62" />
    <javadoc>
      <text>* Fit an harmonic function to the observed points.
 * An initial guess will be automatically computed.</text>
      <return>the parameters of the harmonic function that best fits the
 * observed points (see the other {@link #fit(double[]) fit} method.</return>
      <throws>NumberIsTooSmallException if the sample is too short for the
 * the first guess to be computed.</throws>
      <throws>ZeroException if the first guess cannot be computed because
 * the abscissa range is zero.</throws>
    </javadoc>
    <method type="double[]" name="fit" startLine="75" endLine="77" />
    <class name="ParameterGuesser" startLine="79">
      <javadoc>
        <text>* This class guesses harmonic coefficients from a sample.
 * <p>The algorithm used to guess the coefficients is as follows:</p>
 * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,
 * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).
 * </p>
 * <p>From the analytical expression, we can compute two primitives :
 * <pre>
 * If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2
 * If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2
 * where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)
 * </pre>
 * </p>
 * <p>We can remove S between these expressions :
 * <pre>
 * If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)
 * </pre>
 * </p>
 * <p>The preceding expression shows that If'2 (t) is a linear
 * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)
 * </p>
 * <p>From the primitive, we can deduce the same form for definite
 * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :
 * <pre>
 * If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))
 * </pre>
 * </p>
 * <p>We can find the coefficients A and B that best fit the sample
 * to this linear expression by computing the definite integrals for
 * each sample points.
 * </p>
 * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the
 * coefficients A and B that minimize a least square criterion
 * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>
 * <pre>
 * &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>
 * A = ------------------------
 * &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>
 * &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>
 * B = ------------------------
 * &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>
 * </pre>
 * </p>
 * <p>In fact, we can assume both a and &omega; are positive and
 * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that
 * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>
 * <pre>
 * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:
 * f  (t<sub>i</sub>)
 * f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)
 * x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>
 * y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>
 * z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>
 * update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>
 * end for
 * |--------------------------
 * \  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>
 * a     =  \ | ------------------------
 * \| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>
 * |--------------------------
 * \  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>
 * &omega;     =  \ | ------------------------
 * \| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>
 * </pre>
 * </p>
 * <p>Once we know &omega;, we can compute:
 * <pre>
 * fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)
 * fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)
 * </pre>
 * </p>
 * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and
 * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these
 * expressions to compute &phi;. The best estimate over the sample is
 * given by averaging these expressions.
 * </p>
 * <p>Since integrals and means are involved in the preceding
 * estimations, these operations run in O(n) time, where n is the
 * number of measurements.</p></text>
      </javadoc>
      <javadoc>
        <text>* Amplitude.</text>
      </javadoc>
      <declaration type="double" name="a" />
      <javadoc>
        <text>* Angular frequency.</text>
      </javadoc>
      <declaration type="double" name="omega" />
      <javadoc>
        <text>* Phase.</text>
      </javadoc>
      <declaration type="double" name="phi" />
      <javadoc>
        <text>* Simple constructor.</text>
        <param>observations Sampled observations.</param>
        <throws>NumberIsTooSmallException if the sample is too short.</throws>
        <throws>ZeroException if the abscissa range is zero.</throws>
        <throws>MathIllegalStateException when the guessing procedure cannot
 * produce sensible results.</throws>
      </javadoc>
      <method type="constructor" name="ParameterGuesser" startLine="195" endLine="208">
        <scope startLine="196" endLine="199" />
        <declaration type="WeightedObservedPoint[]" name="sorted" />
        <declaration type="double[]" name="aOmega" />
      </method>
      <javadoc>
        <text>* Gets an estimation of the parameters.</text>
        <return>the guessed parameters, in the following order:
 * <ul>
 * <li>Amplitude</li>
 * <li>Angular frequency</li>
 * <li>Phase</li>
 * </ul></return>
      </javadoc>
      <method type="double[]" name="guess" startLine="220" endLine="222" />
      <javadoc>
        <text>* Sort the observations with respect to the abscissa.</text>
        <param>unsorted Input observations.</param>
        <return>the input observations, sorted.</return>
      </javadoc>
      <method type="WeightedObservedPoint[]" name="sortObservations" startLine="230" endLine="256">
        <declaration type="WeightedObservedPoint[]" name="observations" />
        <declaration type="WeightedObservedPoint" name="curr" />
        <scope startLine="237" endLine="253">
          <declaration type="WeightedObservedPoint" name="prec" />
          <scope startLine="240" endLine="252">
            <declaration type="int" name="i" />
            <declaration type="WeightedObservedPoint" name="mI" />
            <scope startLine="244" endLine="249">
              <scope startLine="246" endLine="248" />
            </scope>
          </scope>
          <comment>the current element should be inserted closer to the beginning</comment>
        </scope>
        <comment>Since the samples are almost always already sorted, this</comment>
        <comment>method is implemented as an insertion sort that reorders the</comment>
        <comment>elements in place. Insertion sort is very efficient in this case.</comment>
      </method>
      <javadoc>
        <text>* Estimate a first guess of the amplitude and angular frequency.
 * This method assumes that the {@link #sortObservations()} method
 * has been called previously.</text>
        <param>observations Observations, sorted w.r.t. abscissa.</param>
        <throws>ZeroException if the abscissa range is zero.</throws>
        <throws>MathIllegalStateException when the guessing procedure cannot
 * produce sensible results.</throws>
        <return>the guessed amplitude (at index 0) and circular frequency
 * (at index 1).</return>
      </javadoc>
      <method type="double[]" name="guessAOmega" startLine="270" endLine="349">
        <declaration type="double[]" name="aOmega" />
        <declaration type="double" name="sx2" />
        <declaration type="double" name="sy2" />
        <declaration type="double" name="sxy" />
        <declaration type="double" name="sxz" />
        <declaration type="double" name="syz" />
        <declaration type="double" name="currentX" />
        <declaration type="double" name="currentY" />
        <declaration type="double" name="f2Integral" />
        <declaration type="double" name="fPrime2Integral" />
        <declaration type="double" name="startX" />
        <scope startLine="285" endLine="309">
          <declaration type="double" name="previousX" />
          <declaration type="double" name="previousY" />
          <declaration type="double" name="dx" />
          <declaration type="double" name="dy" />
          <declaration type="double" name="f2StepIntegral" />
          <declaration type="double" name="fPrime2StepIntegral" />
          <declaration type="double" name="x" />
          <comment>one step forward</comment>
          <comment>update the integrals of f<sup>2</sup> and f'<sup>2</sup></comment>
          <comment>considering a linear model for f (and therefore constant f')</comment>
        </scope>
        <declaration type="double" name="c1" />
        <declaration type="double" name="c2" />
        <declaration type="double" name="c3" />
        <scope startLine="315" endLine="337">
          <declaration type="int" name="last" />
          <declaration type="double" name="xRange" />
          <scope startLine="320" endLine="322" />
          <declaration type="double" name="yMin" />
          <declaration type="double" name="yMax" />
          <scope startLine="327" endLine="335">
            <declaration type="double" name="y" />
            <scope startLine="329" endLine="331" />
            <scope startLine="332" endLine="334" />
          </scope>
          <comment>Range of the observations, assuming that the</comment>
          <comment>observations are sorted.</comment>
        </scope>
        <scope startLine="337" endLine="346">
          <scope startLine="338" endLine="342" />
          <comment>In some ill-conditioned cases (cf. MATH-844), the guesser</comment>
          <comment>procedure cannot produce sensible results.</comment>
        </scope>
        <comment>initialize the sums for the linear model between the two integrals</comment>
        <comment>compute the amplitude and pulsation coefficients</comment>
      </method>
      <javadoc>
        <text>* Estimate a first guess of the phase.</text>
        <param>observations Observations, sorted w.r.t. abscissa.</param>
        <return>the guessed phase.</return>
      </javadoc>
      <method type="double" name="guessPhi" startLine="357" endLine="380">
        <declaration type="double" name="fcMean" />
        <declaration type="double" name="fsMean" />
        <declaration type="double" name="currentX" />
        <declaration type="double" name="currentY" />
        <scope startLine="364" endLine="377">
          <declaration type="double" name="previousX" />
          <declaration type="double" name="previousY" />
          <declaration type="double" name="currentYPrime" />
          <declaration type="double" name="omegaX" />
          <declaration type="double" name="cosine" />
          <declaration type="double" name="sine" />
          <comment>one step forward</comment>
        </scope>
        <comment>initialize the means</comment>
      </method>
    </class>
  </class>
</source>
