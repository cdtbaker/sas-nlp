<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ml.clustering">
  <import name="java.util.ArrayList" />
  <import name="java.util.Collection" />
  <import name="java.util.Collections" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.exception.ConvergenceException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.ml.distance.DistanceMeasure" />
  <import name="org.apache.commons.math3.ml.distance.EuclideanDistance" />
  <import name="org.apache.commons.math3.random.JDKRandomGenerator" />
  <import name="org.apache.commons.math3.random.RandomGenerator" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.Variance" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="KMeansPlusPlusClusterer" extends="Clusterer<T>" startLine="36">
    <javadoc>
      <text>* Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.</text>
      <param><T>
 *  type of the points to cluster</param>
      <see><a href="http://en.wikipedia.org/wiki/K-means%2B%2B">K-means++ (wikipedia)</a></see>
      <version>$Id: KMeansPlusPlusClusterer.java 1461866 2013-03-27 21:54:36Z tn $</version>
      <since>3.2</since>
    </javadoc>
    <javadoc>
      <text>* Strategies to use for replacing an empty cluster.</text>
    </javadoc>
    <javadoc>
      <text>* Split the cluster with largest distance variance.</text>
    </javadoc>
    <javadoc>
      <text>* Split the cluster with largest number of points.</text>
    </javadoc>
    <javadoc>
      <text>* Create a cluster around the point farthest from its centroid.</text>
    </javadoc>
    <javadoc>
      <text>* Generate an error.</text>
    </javadoc>
    <javadoc>
      <text>* The number of clusters.</text>
    </javadoc>
    <declaration type="int" name="k" />
    <javadoc>
      <text>* The maximum number of iterations.</text>
    </javadoc>
    <declaration type="int" name="maxIterations" />
    <javadoc>
      <text>* Random generator for choosing initial centers.</text>
    </javadoc>
    <declaration type="RandomGenerator" name="random" />
    <javadoc>
      <text>* Selected strategy for empty clusters.</text>
    </javadoc>
    <declaration type="EmptyClusterStrategy" name="emptyStrategy" />
    <javadoc>
      <text>* Build a clusterer.
 * <p>
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.
 * <p>
 * The euclidean distance will be used as default distance measure.</text>
      <param>k the number of clusters to split the data into</param>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="83" endLine="85" />
    <javadoc>
      <text>* Build a clusterer.
 * <p>
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.
 * <p>
 * The euclidean distance will be used as default distance measure.</text>
      <param>k the number of clusters to split the data into</param>
      <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="98" endLine="100" />
    <javadoc>
      <text>* Build a clusterer.
 * <p>
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.</text>
      <param>k the number of clusters to split the data into</param>
      <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
      <param>measure the distance measure to use</param>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="112" endLine="114" />
    <javadoc>
      <text>* Build a clusterer.
 * <p>
 * The default strategy for handling empty clusters that may appear during
 * algorithm iterations is to split the cluster with largest distance variance.</text>
      <param>k the number of clusters to split the data into</param>
      <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
      <param>measure the distance measure to use</param>
      <param>random random generator to use for choosing initial centers</param>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="129" endLine="131" />
    <javadoc>
      <text>* Build a clusterer.</text>
      <param>k the number of clusters to split the data into</param>
      <param>maxIterations the maximum number of iterations to run the algorithm for.
 * If negative, no maximum will be used.</param>
      <param>measure the distance measure to use</param>
      <param>random random generator to use for choosing initial centers</param>
      <param>emptyStrategy strategy to use for handling empty clusters that
 * may appear during algorithm iterations</param>
    </javadoc>
    <method type="constructor" name="KMeansPlusPlusClusterer" startLine="146" endLine="152" />
    <javadoc>
      <text>* Return the number of clusters this instance will use.</text>
      <return>the number of clusters</return>
    </javadoc>
    <method type="int" name="getK" startLine="158" endLine="160" />
    <javadoc>
      <text>* Returns the maximum number of iterations this instance will use.</text>
      <return>the maximum number of iterations, or -1 if no maximum is set</return>
    </javadoc>
    <method type="int" name="getMaxIterations" startLine="166" endLine="168" />
    <javadoc>
      <text>* Returns the random generator this instance will use.</text>
      <return>the random generator</return>
    </javadoc>
    <method type="RandomGenerator" name="getRandomGenerator" startLine="174" endLine="176" />
    <javadoc>
      <text>* Returns the {@link EmptyClusterStrategy} used by this instance.</text>
      <return>the {@link EmptyClusterStrategy}</return>
    </javadoc>
    <method type="EmptyClusterStrategy" name="getEmptyClusterStrategy" startLine="182" endLine="184" />
    <javadoc>
      <text>* Runs the K-means++ clustering algorithm.</text>
      <param>points the points to cluster</param>
      <return>a list of clusters containing the points</return>
      <throws>MathIllegalArgumentException if the data points are null or the number
 * of clusters is larger than the number of data points</throws>
      <throws>ConvergenceException if an empty cluster is encountered and the{@link #emptyStrategy} is set to {@code ERROR}</throws>
    </javadoc>
    <method type="List<CentroidCluster<T>>" name="cluster" startLine="197" endLine="252">
      <scope startLine="203" endLine="205" />
      <declaration type="List<CentroidCluster<T>>" name="clusters" />
      <declaration type="int[]" name="assignments" />
      <declaration type="int" name="max" />
      <scope startLine="217" endLine="250">
        <declaration type="boolean" name="emptyCluster" />
        <declaration type="List<CentroidCluster<T>>" name="newClusters" />
        <scope startLine="220" endLine="241">
          <declaration type="Clusterable" name="newCenter" />
          <scope startLine="222" endLine="237" />
          <scope startLine="237" endLine="239" />
        </scope>
        <declaration type="int" name="changes" />
        <scope startLine="247" endLine="249" />
        <comment>if there were no more changes in the point-to-cluster assignment</comment>
        <comment>and there are no empty clusters left, return the current clusters</comment>
      </scope>
      <comment>sanity checks</comment>
      <comment>number of clusters has to be smaller or equal the number of data points</comment>
      <comment>create the initial clusters</comment>
      <comment>create an array containing the latest assignment of a point to a cluster</comment>
      <comment>no need to initialize the array, as it will be filled with the first assignment</comment>
      <comment>iterate through updating the centers until we're done</comment>
    </method>
    <javadoc>
      <text>* Adds the given points to the closest {@link Cluster}.</text>
      <param>clusters the {@link Cluster}s to add the points to</param>
      <param>points the points to add to the given {@link Cluster}s</param>
      <param>assignments points assignments to clusters</param>
      <return>the number of points assigned to different clusters as the iteration before</return>
    </javadoc>
    <method type="int" name="assignPointsToClusters" startLine="264" endLine="279">
      <declaration type="int" name="assignedDifferently" />
      <declaration type="int" name="pointIndex" />
      <scope startLine="267" endLine="276">
        <declaration type="int" name="clusterIndex" />
        <scope startLine="269" endLine="271" />
        <declaration type="CentroidCluster<T>" name="cluster" />
      </scope>
    </method>
    <javadoc>
      <text>* Use K-means++ to choose the initial centers.</text>
      <param>points the points to choose the initial centers from</param>
      <return>the initial centers</return>
    </javadoc>
    <method type="List<CentroidCluster<T>>" name="chooseInitialCenters" startLine="287" endLine="404">
      <declaration type="List<T>" name="pointList" />
      <declaration type="int" name="numPoints" />
      <declaration type="boolean[]" name="taken" />
      <declaration type="List<CentroidCluster<T>>" name="resultSet" />
      <declaration type="int" name="firstPointIndex" />
      <declaration type="T" name="firstPoint" />
      <declaration type="double[]" name="minDistSquared" />
      <scope startLine="319" endLine="324">
        <scope startLine="320" endLine="323">
          <declaration type="double" name="d" />
        </scope>
        <comment>That point isn't considered</comment>
      </scope>
      <scope startLine="326" endLine="401">
        <declaration type="double" name="distSqSum" />
        <scope startLine="332" endLine="336">
          <scope startLine="333" endLine="335" />
        </scope>
        <declaration type="double" name="r" />
        <declaration type="int" name="nextPointIndex" />
        <declaration type="double" name="sum" />
        <scope startLine="348" endLine="356">
          <scope startLine="349" endLine="355">
            <scope startLine="351" endLine="354" />
          </scope>
        </scope>
        <scope startLine="361" endLine="368">
          <scope startLine="362" endLine="367">
            <scope startLine="363" endLine="366" />
          </scope>
        </scope>
        <scope startLine="371" endLine="395">
          <declaration type="T" name="p" />
          <scope startLine="380" endLine="393">
            <scope startLine="383" endLine="392">
              <scope startLine="385" endLine="391">
                <declaration type="double" name="d" />
                <declaration type="double" name="d2" />
                <scope startLine="388" endLine="390" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope startLine="395" endLine="400" />
        <comment>Sum up the squared distances for the points in pointList not</comment>
        <comment>already taken.</comment>
        <comment>Add one new data point as a center. Each point x is chosen with</comment>
        <comment>probability proportional to D(x)2</comment>
        <comment>The index of the next point to be added to the resultSet.</comment>
        <comment>Sum through the squared min distances again, stopping when</comment>
        <comment>sum >= r.</comment>
        <comment>If it's not set to >= 0, the point wasn't found in the previous</comment>
        <comment>for loop, probably because distances are extremely small.  Just pick</comment>
        <comment>the last available point.</comment>
        <comment>We found one.</comment>
        <comment>Mark it as taken.</comment>
        <comment>Now update elements of minDistSquared.  We only have to compute</comment>
        <comment>the distance to the new center to do this.</comment>
        <comment>Only have to worry about the points still not taken.</comment>
        <comment>None found --</comment>
        <comment>Break from the while loop to prevent</comment>
        <comment>an infinite loop.</comment>
      </scope>
      <comment>Convert to list for indexed access. Make it unmodifiable, since removal of items</comment>
      <comment>would screw up the logic of this method.</comment>
      <comment>The number of points in the list.</comment>
      <comment>Set the corresponding element in this array to indicate when</comment>
      <comment>elements of pointList are no longer available.</comment>
      <comment>The resulting list of initial centers.</comment>
      <comment>Choose one center uniformly at random from among the data points.</comment>
      <comment>Must mark it as taken</comment>
      <comment>To keep track of the minimum distance squared of elements of</comment>
      <comment>pointList to elements of resultSet.</comment>
      <comment>Initialize the elements.  Since the only point in resultSet is firstPoint,</comment>
      <comment>this is very easy.</comment>
    </method>
    <javadoc>
      <text>* Get a random point from the {@link Cluster} with the largest distance variance.</text>
      <param>clusters the {@link Cluster}s to search</param>
      <return>a random point from the selected cluster</return>
      <throws>ConvergenceException if clusters are all empty</throws>
    </javadoc>
    <method type="T" name="getPointFromLargestVarianceCluster" startLine="414" endLine="447">
      <declaration type="double" name="maxVariance" />
      <declaration type="Cluster<T>" name="selected" />
      <scope startLine="418" endLine="436">
        <scope startLine="419" endLine="435">
          <declaration type="Clusterable" name="center" />
          <declaration type="Variance" name="stat" />
          <scope startLine="424" endLine="426" />
          <declaration type="double" name="variance" />
          <scope startLine="430" endLine="433" />
        </scope>
        <comment>compute the distance variance of the current cluster</comment>
        <comment>select the cluster with the largest variance</comment>
      </scope>
      <scope startLine="439" endLine="441" />
      <declaration type="List<T>" name="selectedPoints" />
      <comment>did we find at least one non-empty cluster ?</comment>
      <comment>extract a random point from the cluster</comment>
    </method>
    <javadoc>
      <text>* Get a random point from the {@link Cluster} with the largest number of points</text>
      <param>clusters the {@link Cluster}s to search</param>
      <return>a random point from the selected cluster</return>
      <throws>ConvergenceException if clusters are all empty</throws>
    </javadoc>
    <method type="T" name="getPointFromLargestNumberCluster" startLine="457" endLine="483">
      <declaration type="int" name="maxNumber" />
      <declaration type="Cluster<T>" name="selected" />
      <scope startLine="461" endLine="472">
        <declaration type="int" name="number" />
        <scope startLine="467" endLine="470" />
        <comment>get the number of points of the current cluster</comment>
        <comment>select the cluster with the largest number of points</comment>
      </scope>
      <scope startLine="475" endLine="477" />
      <declaration type="List<T>" name="selectedPoints" />
      <comment>did we find at least one non-empty cluster ?</comment>
      <comment>extract a random point from the cluster</comment>
    </method>
    <javadoc>
      <text>* Get the point farthest to its cluster center</text>
      <param>clusters the {@link Cluster}s to search</param>
      <return>point farthest to its cluster center</return>
      <throws>ConvergenceException if clusters are all empty</throws>
    </javadoc>
    <method type="T" name="getFarthestPoint" startLine="492" endLine="520">
      <declaration type="double" name="maxDistance" />
      <declaration type="Cluster<T>" name="selectedCluster" />
      <declaration type="int" name="selectedPoint" />
      <scope startLine="497" endLine="511">
        <declaration type="Clusterable" name="center" />
        <declaration type="List<T>" name="points" />
        <scope startLine="502" endLine="509">
          <declaration type="double" name="distance" />
          <scope startLine="504" endLine="508" />
        </scope>
        <comment>get the farthest point</comment>
      </scope>
      <scope startLine="514" endLine="516" />
      <comment>did we find at least one non-empty cluster ?</comment>
    </method>
    <javadoc>
      <text>* Returns the nearest {@link Cluster} to the given point</text>
      <param>clusters the {@link Cluster}s to search</param>
      <param>point the point to find the nearest {@link Cluster} for</param>
      <return>the index of the nearest {@link Cluster} to the given point</return>
    </javadoc>
    <method type="int" name="getNearestCluster" startLine="529" endLine="542">
      <declaration type="double" name="minDistance" />
      <declaration type="int" name="clusterIndex" />
      <declaration type="int" name="minCluster" />
      <scope startLine="533" endLine="540">
        <declaration type="double" name="distance" />
        <scope startLine="535" endLine="538" />
      </scope>
    </method>
    <javadoc>
      <text>* Computes the centroid for a set of points.</text>
      <param>points the set of points</param>
      <param>dimension the point dimension</param>
      <return>the computed centroid for the set of points</return>
    </javadoc>
    <method type="Clusterable" name="centroidOf" startLine="551" endLine="563">
      <declaration type="double[]" name="centroid" />
      <scope startLine="553" endLine="558">
        <declaration type="double[]" name="point" />
        <scope startLine="555" endLine="557" />
      </scope>
      <scope startLine="559" endLine="561" />
    </method>
  </class>
</source>
