<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.oned">
  <import name="java.util.ArrayList" />
  <import name="java.util.Collection" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.geometry.partitioning.AbstractRegion" />
  <import name="org.apache.commons.math3.geometry.partitioning.BSPTree" />
  <import name="org.apache.commons.math3.geometry.partitioning.SubHyperplane" />
  <import name="org.apache.commons.math3.util.Precision" />
  <class name="IntervalsSet" extends="AbstractRegion<Euclidean1D,Euclidean1D>" startLine="28">
    <javadoc>
      <text>* This class represents a 1D region: a set of intervals.</text>
      <version>$Id: IntervalsSet.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Build an intervals set representing the whole real line.</text>
    </javadoc>
    <method type="constructor" name="IntervalsSet" startLine="36" endLine="38" />
    <javadoc>
      <text>* Build an intervals set corresponding to a single interval.</text>
      <param>lower lower bound of the interval, must be lesser or equal
 * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})</param>
      <param>upper upper bound of the interval, must be greater or equal
 * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})</param>
    </javadoc>
    <method type="constructor" name="IntervalsSet" startLine="46" endLine="48" />
    <javadoc>
      <text>* Build an intervals set from an inside/outside BSP tree.
 * <p>The leaf nodes of the BSP tree <em>must</em> have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}</p></text>
      <param>tree inside/outside BSP tree representing the intervals set</param>
    </javadoc>
    <method type="constructor" name="IntervalsSet" startLine="59" endLine="61" />
    <javadoc>
      <text>* Build an intervals set from a Boundary REPresentation (B-rep).
 * <p>The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.</p>
 * <p>The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polygons with holes
 * or a set of disjoints polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)checkPoint} method will not be meaningful anymore.</p>
 * <p>If the boundary is empty, the region will represent the whole
 * space.</p></text>
      <param>boundary collection of boundary elements</param>
    </javadoc>
    <method type="constructor" name="IntervalsSet" startLine="82" endLine="84" />
    <javadoc>
      <text>* Build an inside/outside tree representing a single interval.</text>
      <param>lower lower bound of the interval, must be lesser or equal
 * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})</param>
      <param>upper upper bound of the interval, must be greater or equal
 * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})</param>
      <return>the built tree</return>
    </javadoc>
    <method type="BSPTree<Euclidean1D>" name="buildTree" startLine="93" endLine="128">
      <scope startLine="94" endLine="106">
        <scope startLine="95" endLine="98" />
        <declaration type="SubHyperplane<Euclidean1D>" name="upperCut" />
        <comment>the tree must cover the whole real line</comment>
        <comment>the tree must be open on the negative infinity side</comment>
      </scope>
      <declaration type="SubHyperplane<Euclidean1D>" name="lowerCut" />
      <scope startLine="109" endLine="115">
        <comment>the tree must be open on the positive infinity side</comment>
      </scope>
      <declaration type="SubHyperplane<Euclidean1D>" name="upperCut" />
      <comment>the tree must be bounded on the two sides</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="IntervalsSet" name="buildNew" startLine="132" endLine="134" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="computeGeometricalProperties" startLine="138" endLine="158">
      <scope startLine="139" endLine="142" />
      <scope startLine="142" endLine="157">
        <declaration type="double" name="size" />
        <declaration type="double" name="sum" />
        <scope startLine="145" endLine="148" />
        <scope startLine="150" endLine="152" />
        <scope startLine="152" endLine="154" />
        <scope startLine="154" endLine="156" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the lowest value belonging to the instance.</text>
      <return>lowest value belonging to the instance
 * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't
 * have any low bound, {@code Double.POSITIVE_INFINITY} if the
 * instance is empty)</return>
    </javadoc>
    <method type="double" name="getInf" startLine="166" endLine="175">
      <declaration type="BSPTree<Euclidean1D>" name="node" />
      <declaration type="double" name="inf" />
      <scope startLine="169" endLine="173">
        <declaration type="OrientedPoint" name="op" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the highest value belonging to the instance.</text>
      <return>highest value belonging to the instance
 * ({@code Double.POSITIVE_INFINITY} if the instance doesn't
 * have any high bound, {@code Double.NEGATIVE_INFINITY} if the
 * instance is empty)</return>
    </javadoc>
    <method type="double" name="getSup" startLine="183" endLine="192">
      <declaration type="BSPTree<Euclidean1D>" name="node" />
      <declaration type="double" name="sup" />
      <scope startLine="186" endLine="190">
        <declaration type="OrientedPoint" name="op" />
      </scope>
    </method>
    <javadoc>
      <text>* Build an ordered list of intervals representing the instance.
 * <p>This method builds this intervals set as an ordered list of{@link Interval Interval} elements. If the intervals set has no
 * lower limit, the first interval will have its low bound equal to{@code Double.NEGATIVE_INFINITY}. If the intervals set has
 * no upper limit, the last interval will have its upper bound equal
 * to {@code Double.POSITIVE_INFINITY}. An empty tree will
 * build an empty list while a tree representing the whole real line
 * will build a one element list with both bounds beeing
 * infinite.</p></text>
      <return>a new ordered list containing {@link Interval Interval}elements</return>
    </javadoc>
    <method type="List<Interval>" name="asList" startLine="207" endLine="212">
      <declaration type="List<Interval>" name="list" />
    </method>
    <javadoc>
      <text>* Update an intervals list.</text>
      <param>node current node</param>
      <param>list list to update</param>
      <param>lower lower bound of the current convex cell</param>
      <param>upper upper bound of the current convex cell</param>
    </javadoc>
    <method type="void" name="recurseList" startLine="222" endLine="250">
      <scope startLine="224" endLine="229">
        <scope startLine="225" endLine="228" />
        <comment>this leaf cell is an inside cell: an interval</comment>
      </scope>
      <scope startLine="229" endLine="248">
        <declaration type="OrientedPoint" name="op" />
        <declaration type="Vector1D" name="loc" />
        <declaration type="double" name="x" />
        <declaration type="BSPTree<Euclidean1D>" name="low" />
        <declaration type="BSPTree<Euclidean1D>" name="high" />
        <scope startLine="242" endLine="245" />
        <comment>make sure we explore the tree in increasing order</comment>
        <comment>merge the last interval added and the first one of the high sub-tree</comment>
      </scope>
    </method>
  </class>
</source>
