<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.sampling">
  <import name="java.io.Externalizable" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <interface name="StepInterpolator" startLine="24">
    <implements name="Externalizable" />
    <javadoc>
      <text>* This interface represents an interpolator over the last step
 * during an ODE integration.
 * <p>The various ODE integrators provide objects implementing this
 * interface to the step handlers. These objects are often custom
 * objects tightly bound to the integrator internal algorithms. The
 * handlers can use these objects to retrieve the state vector at
 * intermediate times between the previous and the current grid points
 * (this feature is often called dense output).</p>
 * <p>One important thing to note is that the step handlers may be so
 * tightly bound to the integrators that they often share some internal
 * state arrays. This imply that one should <em>never</em> use a direct
 * reference to a step interpolator outside of the step handler, either
 * for future use or for use in another thread. If such a need arise, the
 * step interpolator <em>must</em> be copied using the dedicated{@link #copy()} method.
 * </p></text>
      <see>org.apache.commons.math3.ode.FirstOrderIntegrator</see>
      <see>org.apache.commons.math3.ode.SecondOrderIntegrator</see>
      <see>StepHandler</see>
      <version>$Id: StepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <method name="getPreviousTime" type="double" startLine="51" endLine="55" />
    <javadoc>
      <text>* Get the previous grid point time.</text>
      <return>previous grid point time</return>
    </javadoc>
    <method name="getCurrentTime" type="double" startLine="57" endLine="61" />
    <javadoc>
      <text>* Get the current grid point time.</text>
      <return>current grid point time</return>
    </javadoc>
    <method name="getInterpolatedTime" type="double" startLine="63" endLine="69" />
    <javadoc>
      <text>* Get the time of the interpolated point.
 * If {@link #setInterpolatedTime} has not been called, it returns
 * the current grid point time.</text>
      <return>interpolation point time</return>
    </javadoc>
    <method name="setInterpolatedTime" type="void" startLine="71" endLine="83" />
    <javadoc>
      <text>* Set the time of the interpolated point.
 * <p>Setting the time outside of the current step is now allowed, but
 * should be used with care since the accuracy of the interpolator will
 * probably be very poor far from this step. This allowance has been
 * added to simplify implementation of search algorithms near the
 * step endpoints.</p>
 * <p>Setting the time changes the instance internal state. If a
 * specific state must be preserved, a copy of the instance must be
 * created using {@link #copy()}.</p></text>
      <param>time time of the interpolated point</param>
    </javadoc>
    <method name="getInterpolatedState" type="double[]" startLine="85" endLine="94" />
    <javadoc>
      <text>* Get the state vector of the interpolated point.
 * <p>The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.</p></text>
      <return>state vector at time {@link #getInterpolatedTime}</return>
      <see>#getInterpolatedDerivatives()</see>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method name="getInterpolatedDerivatives" type="double[]" startLine="96" endLine="106" />
    <javadoc>
      <text>* Get the derivatives of the state vector of the interpolated point.
 * <p>The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.</p></text>
      <return>derivatives of the state vector at time {@link #getInterpolatedTime}</return>
      <see>#getInterpolatedState()</see>
      <since>2.0</since>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method name="getInterpolatedSecondaryState" type="double[]" startLine="108" endLine="124" />
    <javadoc>
      <text>* Get the interpolated secondary state corresponding to the secondary equations.
 * <p>The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.</p></text>
      <param>index index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}</param>
      <return>interpolated secondary state at the current interpolation date</return>
      <see>#getInterpolatedState()</see>
      <see>#getInterpolatedDerivatives()</see>
      <see>#getInterpolatedSecondaryDerivatives(int)</see>
      <see>#setInterpolatedTime(double)</see>
      <since>3.0</since>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method name="getInterpolatedSecondaryDerivatives" type="double[]" startLine="126" endLine="142" />
    <javadoc>
      <text>* Get the interpolated secondary derivatives corresponding to the secondary equations.
 * <p>The returned vector is a reference to a reused array, so
 * it should not be modified and it should be copied if it needs
 * to be preserved across several calls.</p></text>
      <param>index index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}</param>
      <return>interpolated secondary derivatives at the current interpolation date</return>
      <see>#getInterpolatedState()</see>
      <see>#getInterpolatedDerivatives()</see>
      <see>#getInterpolatedSecondaryState(int)</see>
      <see>#setInterpolatedTime(double)</see>
      <since>3.0</since>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method name="isForward" type="boolean" startLine="144" endLine="153" />
    <javadoc>
      <text>* Check if the natural integration direction is forward.
 * <p>This method provides the integration direction as specified by
 * the integrator itself, it avoid some nasty problems in
 * degenerated cases like null steps due to cancellation at step
 * initialization, step control or discrete events
 * triggering.</p></text>
      <return>true if the integration variable (time) increases during
 * integration</return>
    </javadoc>
    <method name="copy" type="StepInterpolator" startLine="155" endLine="164" />
    <javadoc>
      <text>* Copy the instance.
 * <p>The copied instance is guaranteed to be independent from the
 * original one. Both can be used with different settings for
 * interpolated time without any side effect.</p></text>
      <return>a deep copy of the instance, which can be used independently.</return>
      <see>#setInterpolatedTime(double)</see>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded
 * during step finalization</exception>
    </javadoc>
  </interface>
</source>
