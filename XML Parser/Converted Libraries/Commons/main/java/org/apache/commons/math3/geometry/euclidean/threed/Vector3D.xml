<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="java.io.Serializable" />
  <import name="java.text.NumberFormat" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <import name="org.apache.commons.math3.geometry.Space" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="Vector3D" startLine="32">
    <implements name="Serializable" />
    <implements name="Vector<Euclidean3D>" />
    <javadoc>
      <text>* This class implements vectors in a three-dimensional space.
 * <p>Instance of this class are guaranteed to be immutable.</p></text>
      <version>$Id: Vector3D.java 1447259 2013-02-18 13:56:39Z luc $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Null vector (coordinates: 0, 0, 0).</text>
    </javadoc>
    <declaration type="Vector3D" name="ZERO" />
    <javadoc>
      <text>* First canonical vector (coordinates: 1, 0, 0).</text>
    </javadoc>
    <declaration type="Vector3D" name="PLUS_I" />
    <javadoc>
      <text>* Opposite of the first canonical vector (coordinates: -1, 0, 0).</text>
    </javadoc>
    <declaration type="Vector3D" name="MINUS_I" />
    <javadoc>
      <text>* Second canonical vector (coordinates: 0, 1, 0).</text>
    </javadoc>
    <declaration type="Vector3D" name="PLUS_J" />
    <javadoc>
      <text>* Opposite of the second canonical vector (coordinates: 0, -1, 0).</text>
    </javadoc>
    <declaration type="Vector3D" name="MINUS_J" />
    <javadoc>
      <text>* Third canonical vector (coordinates: 0, 0, 1).</text>
    </javadoc>
    <declaration type="Vector3D" name="PLUS_K" />
    <javadoc>
      <text>* Opposite of the third canonical vector (coordinates: 0, 0, -1).</text>
    </javadoc>
    <declaration type="Vector3D" name="MINUS_K" />
    <javadoc>
      <text>* A vector with all coordinates set to NaN.</text>
    </javadoc>
    <declaration type="Vector3D" name="NaN" />
    <javadoc>
      <text>* A vector with all coordinates set to positive infinity.</text>
    </javadoc>
    <declaration type="Vector3D" name="POSITIVE_INFINITY" />
    <javadoc>
      <text>* A vector with all coordinates set to negative infinity.</text>
    </javadoc>
    <declaration type="Vector3D" name="NEGATIVE_INFINITY" />
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Abscissa.</text>
    </javadoc>
    <declaration type="double" name="x" />
    <javadoc>
      <text>* Ordinate.</text>
    </javadoc>
    <declaration type="double" name="y" />
    <javadoc>
      <text>* Height.</text>
    </javadoc>
    <declaration type="double" name="z" />
    <javadoc>
      <text>* Simple constructor.
 * Build a vector from its coordinates</text>
      <param>x abscissa</param>
      <param>y ordinate</param>
      <param>z height</param>
      <see>#getX()</see>
      <see>#getY()</see>
      <see>#getZ()</see>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="95" endLine="99" />
    <javadoc>
      <text>* Simple constructor.
 * Build a vector from its coordinates</text>
      <param>v coordinates array</param>
      <exception>DimensionMismatchException if array does not have 3 elements</exception>
      <see>#toArray()</see>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="107" endLine="114">
      <scope startLine="108" endLine="110" />
    </method>
    <javadoc>
      <text>* Simple constructor.
 * Build a vector from its azimuthal coordinates</text>
      <param>alpha azimuth (&alpha;) around Z
 * (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)</param>
      <param>delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2</param>
      <see>#getAlpha()</see>
      <see>#getDelta()</see>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="124" endLine="129">
      <declaration type="double" name="cosDelta" />
    </method>
    <javadoc>
      <text>* Multiplicative constructor
 * Build a vector from another one and a scale factor.
 * The vector built will be a * u</text>
      <param>a scale factor</param>
      <param>u base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="137" endLine="141" />
    <javadoc>
      <text>* Linear constructor
 * Build a vector from two other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="151" endLine="155" />
    <javadoc>
      <text>* Linear constructor
 * Build a vector from three other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="168" endLine="172" />
    <javadoc>
      <text>* Linear constructor
 * Build a vector from four other ones and corresponding scale factors.
 * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4</text>
      <param>a1 first scale factor</param>
      <param>u1 first base (unscaled) vector</param>
      <param>a2 second scale factor</param>
      <param>u2 second base (unscaled) vector</param>
      <param>a3 third scale factor</param>
      <param>u3 third base (unscaled) vector</param>
      <param>a4 fourth scale factor</param>
      <param>u4 fourth base (unscaled) vector</param>
    </javadoc>
    <method type="constructor" name="Vector3D" startLine="187" endLine="191" />
    <javadoc>
      <text>* Get the abscissa of the vector.</text>
      <return>abscissa of the vector</return>
      <see>#Vector3D(double,double,double)</see>
    </javadoc>
    <method type="double" name="getX" startLine="197" endLine="199" />
    <javadoc>
      <text>* Get the ordinate of the vector.</text>
      <return>ordinate of the vector</return>
      <see>#Vector3D(double,double,double)</see>
    </javadoc>
    <method type="double" name="getY" startLine="205" endLine="207" />
    <javadoc>
      <text>* Get the height of the vector.</text>
      <return>height of the vector</return>
      <see>#Vector3D(double,double,double)</see>
    </javadoc>
    <method type="double" name="getZ" startLine="213" endLine="215" />
    <javadoc>
      <text>* Get the vector coordinates as a dimension 3 array.</text>
      <return>vector coordinates</return>
      <see>#Vector3D(double[])</see>
    </javadoc>
    <method type="double[]" name="toArray" startLine="221" endLine="223" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Space" name="getSpace" startLine="226" endLine="228" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="getZero" startLine="231" endLine="233" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getNorm1" startLine="236" endLine="238" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getNorm" startLine="241" endLine="244">
      <comment>there are no cancellation problems here, so we use the straightforward formula</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getNormSq" startLine="247" endLine="250">
      <comment>there are no cancellation problems here, so we use the straightforward formula</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="getNormInf" startLine="253" endLine="255" />
    <javadoc>
      <text>* Get the azimuth of the vector.</text>
      <return>azimuth (&alpha;) of the vector, between -&pi; and +&pi;</return>
      <see>#Vector3D(double,double)</see>
    </javadoc>
    <method type="double" name="getAlpha" startLine="261" endLine="263" />
    <javadoc>
      <text>* Get the elevation of the vector.</text>
      <return>elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2</return>
      <see>#Vector3D(double,double)</see>
    </javadoc>
    <method type="double" name="getDelta" startLine="269" endLine="271" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="add" startLine="274" endLine="277">
      <declaration type="Vector3D" name="v3" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="add" startLine="280" endLine="282" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="subtract" startLine="285" endLine="288">
      <declaration type="Vector3D" name="v3" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="subtract" startLine="291" endLine="293" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="normalize" startLine="296" endLine="302">
      <declaration type="double" name="s" />
      <scope startLine="298" endLine="300" />
    </method>
    <javadoc>
      <text>* Get a vector orthogonal to the instance.
 * <p>There are an infinite number of normalized vectors orthogonal
 * to the instance. This method picks up one of them almost
 * arbitrarily. It is useful when one needs to compute a reference
 * frame with one of the axes in a predefined direction. The
 * following example shows how to build a frame having the k axis
 * aligned with the known vector u :
 * <pre><code>
 * Vector3D k = u.normalize();
 * Vector3D i = k.orthogonal();
 * Vector3D j = Vector3D.crossProduct(k, i);
 * </code></pre></p></text>
      <return>a new normalized vector orthogonal to the instance</return>
      <exception>MathArithmeticException if the norm of the instance is null</exception>
    </javadoc>
    <method type="Vector3D" name="orthogonal" startLine="319" endLine="336">
      <declaration type="double" name="threshold" />
      <scope startLine="322" endLine="324" />
      <scope startLine="326" endLine="329">
        <declaration type="double" name="inverse" />
      </scope>
      <scope startLine="329" endLine="332">
        <declaration type="double" name="inverse" />
      </scope>
      <declaration type="double" name="inverse" />
    </method>
    <javadoc>
      <text>* Compute the angular separation between two vectors.
 * <p>This method computes the angular separation between two
 * vectors using the dot product for well separated vectors and the
 * cross product for almost aligned vectors. This allows to have a
 * good accuracy in all cases, even for vectors very close to each
 * other.</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>angular separation between v1 and v2</return>
      <exception>MathArithmeticException if either vector has a null norm</exception>
    </javadoc>
    <method type="double" name="angle" startLine="349" endLine="370">
      <declaration type="double" name="normProduct" />
      <scope startLine="352" endLine="354" />
      <declaration type="double" name="dot" />
      <declaration type="double" name="threshold" />
      <scope startLine="358" endLine="365">
        <declaration type="Vector3D" name="v3" />
        <scope startLine="361" endLine="363" />
        <comment>the vectors are almost aligned, compute using the sine</comment>
      </scope>
      <comment>the vectors are sufficiently separated to use the cosine</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="negate" startLine="373" endLine="375" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Vector3D" name="scalarMultiply" startLine="378" endLine="380" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isNaN" startLine="383" endLine="385" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="isInfinite" startLine="388" endLine="390" />
    <javadoc>
      <text>* Test for the equality of two 3D vectors.
 * <p>
 * If all coordinates of two 3D vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to{@link #NaN}.
 * </p></text>
      <param>other Object to test for equality to this</param>
      <return>true if two 3D vector objects are equal, false if
 * object is null, not an instance of Vector3D, or
 * not equal to this Vector3D instance</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="412" endLine="427">
      <scope startLine="414" endLine="416" />
      <scope startLine="418" endLine="425">
        <declaration type="Vector3D" name="rhs" />
        <scope startLine="420" endLine="422" />
      </scope>
    </method>
    <javadoc>
      <text>* Get a hashCode for the 3D vector.
 * <p>
 * All NaN values have the same hash code.</p></text>
      <return>a hash code value for this object</return>
    </javadoc>
    <method type="int" name="hashCode" startLine="437" endLine="442">
      <scope startLine="438" endLine="440" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * The implementation uses specific multiplication and addition
 * algorithms to preserve accuracy and reduce cancellation effects.
 * It should be very accurate even for nearly orthogonal vectors.
 * </p></text>
      <see>MathArrays#linearCombination(double,double,double,double,double,double)</see>
    </javadoc>
    <method type="double" name="dotProduct" startLine="452" endLine="455">
      <declaration type="Vector3D" name="v3" />
    </method>
    <javadoc>
      <text>* Compute the cross-product of the instance with another vector.</text>
      <param>v other vector</param>
      <return>the cross product this ^ v as a new Vector3D</return>
    </javadoc>
    <method type="Vector3D" name="crossProduct" startLine="461" endLine="466">
      <declaration type="Vector3D" name="v3" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="distance1" startLine="469" endLine="475">
      <declaration type="Vector3D" name="v3" />
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
      <declaration type="double" name="dz" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="distance" startLine="478" endLine="484">
      <declaration type="Vector3D" name="v3" />
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
      <declaration type="double" name="dz" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="distanceInf" startLine="487" endLine="493">
      <declaration type="Vector3D" name="v3" />
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
      <declaration type="double" name="dz" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="distanceSq" startLine="496" endLine="502">
      <declaration type="Vector3D" name="v3" />
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
      <declaration type="double" name="dz" />
    </method>
    <javadoc>
      <text>* Compute the dot-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>the dot product v1.v2</return>
    </javadoc>
    <method type="double" name="dotProduct" startLine="509" endLine="511" />
    <javadoc>
      <text>* Compute the cross-product of two vectors.</text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>the cross product v1 ^ v2 as a new Vector</return>
    </javadoc>
    <method type="Vector3D" name="crossProduct" startLine="518" endLine="520" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>1</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>the distance between v1 and v2 according to the L<sub>1</sub> norm</return>
    </javadoc>
    <method type="double" name="distance1" startLine="530" endLine="532" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>2</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNorm()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>the distance between v1 and v2 according to the L<sub>2</sub> norm</return>
    </javadoc>
    <method type="double" name="distance" startLine="542" endLine="544" />
    <javadoc>
      <text>* Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>the distance between v1 and v2 according to the L<sub>&infin;</sub> norm</return>
    </javadoc>
    <method type="double" name="distanceInf" startLine="554" endLine="556" />
    <javadoc>
      <text>* Compute the square of the distance between two vectors.
 * <p>Calling this method is equivalent to calling:
 * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate
 * vector is built</p></text>
      <param>v1 first vector</param>
      <param>v2 second vector</param>
      <return>the square of the distance between v1 and v2</return>
    </javadoc>
    <method type="double" name="distanceSq" startLine="566" endLine="568" />
    <javadoc>
      <text>* Get a string representation of this vector.</text>
      <return>a string representation of this vector</return>
    </javadoc>
    <method type="String" name="toString" startLine="574" endLine="576" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="String" name="toString" startLine="579" endLine="581" />
    <comment>CHECKSTYLE: stop ConstantName</comment>
    <comment>CHECKSTYLE: resume ConstantName</comment>
  </class>
</source>
