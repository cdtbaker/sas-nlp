<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="SphericalCoordinates" startLine="24">
    <implements name="Serializable" />
    <javadoc>
      <text>* This class provides conversions related to <a
 * href="http://mathworld.wolfram.com/SphericalCoordinates.html">spherical coordinates</a>.
 * <p>
 * The conventions used here are the mathematical ones, i.e. spherical coordinates are
 * related to Cartesian coordinates as follows:
 * </p>
 * <ul>
 * <li>x = r cos(&theta;) sin(&Phi;)</li>
 * <li>y = r sin(&theta;) sin(&Phi;)</li>
 * <li>z = r cos(&Phi;)</li>
 * </ul>
 * <ul>
 * <li>r       = &radic;(x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>)</li>
 * <li>&theta; = atan2(y, x)</li>
 * <li>&Phi;   = acos(z/r)</li>
 * </ul>
 * <p>
 * r is the radius, &theta; is the azimuthal angle in the x-y plane and &Phi; is the polar
 * (co-latitude) angle. These conventions are <em>different</em> from the conventions used
 * in physics (and in particular in spherical harmonics) where the meanings of &theta; and
 * &Phi; are reversed.
 * </p>
 * <p>
 * This class provides conversion of coordinates and also of gradient and Hessian
 * between spherical and Cartesian coordinates.
 * </p></text>
      <since>3.2</since>
      <version>$Id: SphericalCoordinates.java 1443364 2013-02-07 09:28:04Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* Serializable UID.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Cartesian coordinates.</text>
    </javadoc>
    <declaration type="Vector3D" name="v" />
    <javadoc>
      <text>* Radius.</text>
    </javadoc>
    <declaration type="double" name="r" />
    <javadoc>
      <text>* Azimuthal angle in the x-y plane &theta;.</text>
    </javadoc>
    <declaration type="double" name="theta" />
    <javadoc>
      <text>* Polar angle (co-latitude) &Phi;.</text>
    </javadoc>
    <declaration type="double" name="phi" />
    <javadoc>
      <text>* Jacobian of (r, &theta; &Phi).</text>
    </javadoc>
    <declaration type="double[][]" name="jacobian" />
    <javadoc>
      <text>* Hessian of radius.</text>
    </javadoc>
    <declaration type="double[][]" name="rHessian" />
    <javadoc>
      <text>* Hessian of azimuthal angle in the x-y plane &theta;.</text>
    </javadoc>
    <declaration type="double[][]" name="thetaHessian" />
    <javadoc>
      <text>* Hessian of polar (co-latitude) angle &Phi;.</text>
    </javadoc>
    <declaration type="double[][]" name="phiHessian" />
    <javadoc>
      <text>* Build a spherical coordinates transformer from Cartesian coordinates.</text>
      <param>v Cartesian coordinates</param>
    </javadoc>
    <method type="constructor" name="SphericalCoordinates" startLine="85" endLine="95">
      <comment>Cartesian coordinates</comment>
      <comment>remaining spherical coordinates</comment>
    </method>
    <javadoc>
      <text>* Build a spherical coordinates transformer from spherical coordinates.</text>
      <param>r radius</param>
      <param>theta azimuthal angle in x-y plane</param>
      <param>phi polar (co-latitude) angle</param>
    </javadoc>
    <method type="constructor" name="SphericalCoordinates" startLine="102" endLine="119">
      <declaration type="double" name="cosTheta" />
      <declaration type="double" name="sinTheta" />
      <declaration type="double" name="cosPhi" />
      <declaration type="double" name="sinPhi" />
      <comment>spherical coordinates</comment>
      <comment>Cartesian coordinates</comment>
    </method>
    <javadoc>
      <text>* Get the Cartesian coordinates.</text>
      <return>Cartesian coordinates</return>
    </javadoc>
    <method type="Vector3D" name="getCartesian" startLine="124" endLine="126" />
    <javadoc>
      <text>* Get the radius.</text>
      <return>radius r</return>
      <see>#getTheta()</see>
      <see>#getPhi()</see>
    </javadoc>
    <method type="double" name="getR" startLine="133" endLine="135" />
    <javadoc>
      <text>* Get the azimuthal angle in x-y plane.</text>
      <return>azimuthal angle in x-y plane &theta;</return>
      <see>#getR()</see>
      <see>#getPhi()</see>
    </javadoc>
    <method type="double" name="getTheta" startLine="142" endLine="144" />
    <javadoc>
      <text>* Get the polar (co-latitude) angle.</text>
      <return>polar (co-latitude) angle &Phi;</return>
      <see>#getR()</see>
      <see>#getTheta()</see>
    </javadoc>
    <method type="double" name="getPhi" startLine="151" endLine="153" />
    <javadoc>
      <text>* Convert a gradient with respect to spherical coordinates into a gradient
 * with respect to Cartesian coordinates.</text>
      <param>sGradient gradient with respect to spherical coordinates
 * {df/dr, df/d&theta;, df/d&Phi;}</param>
      <return>gradient with respect to Cartesian coordinates
 * {df/dx, df/dy, df/dz}</return>
    </javadoc>
    <method type="double[]" name="toCartesianGradient" startLine="162" endLine="175">
      <comment>lazy evaluation of Jacobian</comment>
      <comment>compose derivatives as gradient^T . J</comment>
      <comment>the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0</comment>
    </method>
    <javadoc>
      <text>* Convert a Hessian with respect to spherical coordinates into a Hessian
 * with respect to Cartesian coordinates.
 * <p>
 * As Hessian are always symmetric, we use only the lower left part of the provided
 * spherical Hessian, so the upper part may not be initialized. However, we still
 * do fill up the complete array we create, with guaranteed symmetry.
 * </p></text>
      <param>sHessian Hessian with respect to spherical coordinates
 * {{d<sup>2</sup>f/dr<sup>2</sup>, d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/drd&Phi;},
 * {d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/d&theta;<sup>2</sup>, d<sup>2</sup>f/d&theta;d&Phi;},
 * {d<sup>2</sup>f/drd&Phi;, d<sup>2</sup>f/d&theta;d&Phi;, d<sup>2</sup>f/d&Phi;<sup>2</sup>}</param>
      <param>sGradient gradient with respect to spherical coordinates
 * {df/dr, df/d&theta;, df/d&Phi;}</param>
      <return>Hessian with respect to Cartesian coordinates
 * {{d<sup>2</sup>f/dx<sup>2</sup>, d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dxdz},
 * {d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dy<sup>2</sup>, d<sup>2</sup>f/dydz},
 * {d<sup>2</sup>f/dxdz, d<sup>2</sup>f/dydz, d<sup>2</sup>f/dz<sup>2</sup>}}</return>
    </javadoc>
    <method type="double[][]" name="toCartesianHessian" startLine="195" endLine="241">
      <declaration type="double[][]" name="hj" />
      <declaration type="double[][]" name="cHessian" />
      <comment>compose derivative as J^T . H_f . J + df/dr H_r + df/dtheta H_theta + df/dphi H_phi</comment>
      <comment>the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0</comment>
      <comment>and H_theta is only a 2x2 matrix as it does not depend on z</comment>
      <comment>compute H_f . J</comment>
      <comment>beware we use ONLY the lower-left part of sHessian</comment>
      <comment>don't compute hj[1][2] as it is not used below</comment>
      <comment>compute lower-left part of J^T . H_f . J</comment>
      <comment>add gradient contribution</comment>
      <comment>ensure symmetry</comment>
    </method>
    <javadoc>
      <text>* Lazy evaluation of (r, &theta;, &phi;) Jacobian.</text>
    </javadoc>
    <method type="void" name="computeJacobian" startLine="245" endLine="274">
      <scope startLine="246" endLine="273">
        <declaration type="double" name="x" />
        <declaration type="double" name="y" />
        <declaration type="double" name="z" />
        <declaration type="double" name="rho2" />
        <declaration type="double" name="rho" />
        <declaration type="double" name="r2" />
        <comment>intermediate variables</comment>
        <comment>row representing the gradient of r</comment>
        <comment>row representing the gradient of theta</comment>
        <comment>jacobian[1][2] is already set to 0 at allocation time</comment>
        <comment>row representing the gradient of phi</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Lazy evaluation of Hessians.</text>
    </javadoc>
    <method type="void" name="computeHessians" startLine="278" endLine="345">
      <scope startLine="280" endLine="343">
        <declaration type="double" name="x" />
        <declaration type="double" name="y" />
        <declaration type="double" name="z" />
        <declaration type="double" name="x2" />
        <declaration type="double" name="y2" />
        <declaration type="double" name="z2" />
        <declaration type="double" name="rho2" />
        <declaration type="double" name="rho" />
        <declaration type="double" name="r2" />
        <declaration type="double" name="xOr" />
        <declaration type="double" name="yOr" />
        <declaration type="double" name="zOr" />
        <declaration type="double" name="xOrho2" />
        <declaration type="double" name="yOrho2" />
        <declaration type="double" name="xOr3" />
        <declaration type="double" name="yOr3" />
        <declaration type="double" name="zOr3" />
        <declaration type="double" name="rhor2" />
        <declaration type="double" name="rho2r2" />
        <declaration type="double" name="rhor4" />
        <declaration type="double" name="rho3r4" />
        <declaration type="double" name="r2P2rho2" />
        <comment>intermediate variables</comment>
        <comment>lower-left part of Hessian of r</comment>
        <comment>upper-right part is symmetric</comment>
        <comment>lower-left part of Hessian of azimuthal angle theta</comment>
        <comment>upper-right part is symmetric</comment>
        <comment>lower-left part of Hessian of polar (co-latitude) angle phi</comment>
        <comment>upper-right part is symmetric</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Replace the instance with a data transfer object for serialization.</text>
      <return>data transfer object that will be serialized</return>
    </javadoc>
    <method type="Object" name="writeReplace" startLine="351" endLine="353" />
    <class name="DataTransferObject" startLine="355">
      <implements name="Serializable" />
      <javadoc>
        <text>* Internal class used only for serialization.</text>
      </javadoc>
      <javadoc>
        <text>* Serializable UID.</text>
      </javadoc>
      <declaration type="long" name="serialVersionUID" />
      <javadoc>
        <text>* Abscissa.</text>
        <serial />
      </javadoc>
      <declaration type="double" name="x" />
      <javadoc>
        <text>* Ordinate.</text>
        <serial />
      </javadoc>
      <declaration type="double" name="y" />
      <javadoc>
        <text>* Height.</text>
        <serial />
      </javadoc>
      <declaration type="double" name="z" />
      <javadoc>
        <text>* Simple constructor.</text>
        <param>x abscissa</param>
        <param>y ordinate</param>
        <param>z height</param>
      </javadoc>
      <method type="constructor" name="DataTransferObject" startLine="381" endLine="385" />
      <javadoc>
        <text>* Replace the deserialized data transfer object with a {@link SphericalCoordinates}.</text>
        <return>replacement {@link SphericalCoordinates}</return>
      </javadoc>
      <method type="Object" name="readResolve" startLine="390" endLine="392" />
    </class>
  </class>
</source>
