<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.sampling">
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <interface name="StepHandler" startLine="23">
    <javadoc>
      <text>* This interface represents a handler that should be called after
 * each successful step.
 * <p>The ODE integrators compute the evolution of the state vector at
 * some grid points that depend on their own internal algorithm. Once
 * they have found a new grid point (possibly after having computed
 * several evaluation of the derivative at intermediate points), they
 * provide it to objects implementing this interface. These objects
 * typically either ignore the intermediate steps and wait for the
 * last one, store the points in an ephemeris, or forward them to
 * specialized processing or output methods.</p></text>
      <see>org.apache.commons.math3.ode.FirstOrderIntegrator</see>
      <see>org.apache.commons.math3.ode.SecondOrderIntegrator</see>
      <see>StepInterpolator</see>
      <version>$Id: StepHandler.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <method name="init" type="void" startLine="45" endLine="55" />
    <javadoc>
      <text>* Initialize step handler at the start of an ODE integration.
 * <p>
 * This method is called once at the start of the integration. It
 * may be used by the step handler to initialize some internal data
 * if needed.
 * </p></text>
      <param>t0 start value of the independent <i>time</i> variable</param>
      <param>y0 array containing the start value of the state vector</param>
      <param>t target time for the integration</param>
    </javadoc>
    <method name="handleStep" type="void" startLine="57" endLine="74" />
    <javadoc>
      <text>* Handle the last accepted step</text>
      <param>interpolator interpolator for the last accepted step. For
 * efficiency purposes, the various integrators reuse the same
 * object on each call, so if the instance wants to keep it across
 * all calls (for example to provide at the end of the integration a
 * continuous model valid throughout the integration range, as the{@link org.apache.commons.math3.ode.ContinuousOutputModelContinuousOutputModel} class does), it should build a local copy
 * using the clone method of the interpolator and store this copy.
 * Keeping only a reference to the interpolator and reusing it will
 * result in unpredictable behavior (potentially crashing the application).</param>
      <param>isLast true if the step is the last one</param>
      <exception>MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded</exception>
    </javadoc>
  </interface>
</source>
