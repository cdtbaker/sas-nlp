<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.genetics">
  <import name="java.util.ArrayList" />
  <import name="java.util.Arrays" />
  <import name="java.util.Collections" />
  <import name="java.util.Comparator" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="RandomKey" extends="AbstractListChromosome<Double>" startLine="29">
    <implements name="PermutationChromosome<T>" />
    <javadoc>
      <text>* Random Key chromosome is used for permutation representation. It is a vector
 * of a fixed length of real numbers in [0,1] interval. The index of the i-th
 * smallest value in the vector represents an i-th member of the permutation.
 * <p>
 * For example, the random key [0.2, 0.3, 0.8, 0.1] corresponds to the
 * permutation of indices (3,0,1,2). If the original (unpermuted) sequence would
 * be (a,b,c,d), this would mean the sequence (d,a,b,c).
 * <p>
 * With this representation, common operators like n-point crossover can be
 * used, because any such chromosome represents a valid permutation.
 * <p>
 * Since the chromosome (and thus its arrayRepresentation) is immutable, the
 * array representation is sorted only once in the constructor.
 * <p>
 * For details, see:
 * <ul>
 * <li>Bean, J.C.: Genetic algorithms and random keys for sequencing and
 * optimization. ORSA Journal on Computing 6 (1994) 154-160</li>
 * <li>Rothlauf, F.: Representations for Genetic and Evolutionary Algorithms.
 * Volume 104 of Studies in Fuzziness and Soft Computing. Physica-Verlag,
 * Heidelberg (2002)</li>
 * </ul></text>
      <param><T>
 *  type of the permuted objects</param>
      <since>2.0</since>
      <version>$Id: RandomKey.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* Cache of sorted representation (unmodifiable).</text>
    </javadoc>
    <declaration type="List<Double>" name="sortedRepresentation" />
    <javadoc>
      <text>* Base sequence [0,1,...,n-1], permuted accorting to the representation (unmodifiable).</text>
    </javadoc>
    <declaration type="List<Integer>" name="baseSeqPermutation" />
    <javadoc>
      <text>* Constructor.</text>
      <param>representation list of [0,1] values representing the permutation</param>
      <throws>InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome</throws>
    </javadoc>
    <method type="constructor" name="RandomKey" startLine="73" endLine="83">
      <declaration type="List<Double>" name="sortedRepr" />
      <comment>store the sorted representation</comment>
      <comment>store the permutation of [0,1,...,n-1] list for toString() and isSame() methods</comment>
    </method>
    <javadoc>
      <text>* Constructor.</text>
      <param>representation array of [0,1] values representing the permutation</param>
      <throws>InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome</throws>
    </javadoc>
    <method type="constructor" name="RandomKey" startLine="91" endLine="93" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="List<T>" name="decode" startLine="98" endLine="100" />
    <javadoc>
      <text>* Decodes a permutation represented by <code>representation</code> and
 * returns a (generic) list with the permuted values.</text>
      <param><S>
 *  generic type of the sequence values</param>
      <param>sequence the unpermuted sequence</param>
      <param>representation representation of the permutation ([0,1] vector)</param>
      <param>sortedRepr sorted <code>representation</code></param>
      <return>list with the sequence values permuted according to the representation</return>
      <throws>DimensionMismatchException iff the length of the <code>sequence</code>,
 * <code>representation</code> or <code>sortedRepr</code> lists are not equal</throws>
    </javadoc>
    <method type="List<S>" name="decodeGeneric" startLine="116" endLine="139">
      <declaration type="int" name="l" />
      <scope startLine="121" endLine="123" />
      <scope startLine="124" endLine="126" />
      <declaration type="List<Double>" name="reprCopy" />
      <declaration type="List<S>" name="res" />
      <scope startLine="133" endLine="137">
        <declaration type="int" name="index" />
      </scope>
      <comment>the size of the three lists must be equal</comment>
      <comment>do not modify the original representation</comment>
      <comment>now find the indices in the original repr and use them for permuting</comment>
    </method>
    <javadoc>
      <text>* Returns <code>true</code> iff <code>another</code> is a RandomKey and
 * encodes the same permutation.</text>
      <param>another chromosome to compare</param>
      <return>true iff chromosomes encode the same permutation</return>
    </javadoc>
    <method type="boolean" name="isSame" startLine="149" endLine="172">
      <scope startLine="151" endLine="153" />
      <declaration type="RandomKey<?>" name="anotherRk" />
      <scope startLine="156" endLine="158" />
      <declaration type="List<Integer>" name="thisPerm" />
      <declaration type="List<Integer>" name="anotherPerm" />
      <scope startLine="165" endLine="169">
        <scope startLine="166" endLine="168" />
      </scope>
      <comment>type check</comment>
      <comment>size check</comment>
      <comment>two different representations can still encode the same permutation</comment>
      <comment>the ordering is what counts</comment>
      <comment>the permutations are the same</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="checkValidity" startLine="179" endLine="187">
      <scope startLine="181" endLine="186">
        <scope startLine="182" endLine="185" />
      </scope>
    </method>
    <javadoc>
      <text>* Generates a representation corresponding to a random permutation of
 * length l which can be passed to the RandomKey constructor.</text>
      <param>l length of the permutation</param>
      <return>representation of a random permutation</return>
    </javadoc>
    <method type="List<Double>" name="randomPermutation" startLine="197" endLine="203">
      <declaration type="List<Double>" name="repr" />
      <scope startLine="199" endLine="201" />
    </method>
    <javadoc>
      <text>* Generates a representation corresponding to an identity permutation of
 * length l which can be passed to the RandomKey constructor.</text>
      <param>l length of the permutation</param>
      <return>representation of an identity permutation</return>
    </javadoc>
    <method type="List<Double>" name="identityPermutation" startLine="212" endLine="218">
      <declaration type="List<Double>" name="repr" />
      <scope startLine="214" endLine="216" />
    </method>
    <javadoc>
      <text>* Generates a representation of a permutation corresponding to the
 * <code>data</code> sorted by <code>comparator</code>. The
 * <code>data</code> is not modified during the process.
 * This is useful if you want to inject some permutations to the initial
 * population.</text>
      <param><S>
 *  type of the data</param>
      <param>data list of data determining the order</param>
      <param>comparator how the data will be compared</param>
      <return>list representation of the permutation corresponding to the parameters</return>
    </javadoc>
    <method type="List<Double>" name="comparatorPermutation" startLine="234" endLine="239">
      <declaration type="List<S>" name="sortedData" />
    </method>
    <javadoc>
      <text>* Generates a representation of a permutation corresponding to a
 * permutation which yields <code>permutedData</code> when applied to
 * <code>originalData</code>.
 * This method can be viewed as an inverse to {@link #decode(List)}.</text>
      <param><S>
 *  type of the data</param>
      <param>originalData the original, unpermuted data</param>
      <param>permutedData the data, somehow permuted</param>
      <return>representation of a permutation corresponding to the permutation
 * <code>originalData -> permutedData</code></return>
      <throws>DimensionMismatchException iff the length of <code>originalData</code>
 * and <code>permutedData</code> lists are not equal</throws>
      <throws>MathIllegalArgumentException iff the <code>permutedData</code> and
 * <code>originalData</code> lists contain different data</throws>
    </javadoc>
    <method type="List<Double>" name="inducedPermutation" startLine="260" endLine="279">
      <scope startLine="262" endLine="264" />
      <declaration type="int" name="l" />
      <declaration type="List<S>" name="origDataCopy" />
      <declaration type="Double[]" name="res" />
      <scope startLine="270" endLine="277">
        <declaration type="int" name="index" />
        <scope startLine="272" endLine="274" />
      </scope>
    </method>
    <method type="String" name="toString" startLine="282" endLine="284" />
    <javadoc>
      <text>* Helper for constructor. Generates a list of natural numbers (0,1,...,l-1).</text>
      <param>l length of list to generate</param>
      <return>list of integers from 0 to l-1</return>
    </javadoc>
    <method type="List<Integer>" name="baseSequence" startLine="292" endLine="298">
      <declaration type="List<Integer>" name="baseSequence" />
      <scope startLine="294" endLine="296" />
    </method>
  </class>
</source>
