<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.random">
  <import name="java.io.Serializable" />
  <import name="java.security.MessageDigest" />
  <import name="java.security.NoSuchAlgorithmException" />
  <import name="java.security.NoSuchProviderException" />
  <import name="java.security.SecureRandom" />
  <import name="java.util.Collection" />
  <import name="org.apache.commons.math3.distribution.BetaDistribution" />
  <import name="org.apache.commons.math3.distribution.BinomialDistribution" />
  <import name="org.apache.commons.math3.distribution.CauchyDistribution" />
  <import name="org.apache.commons.math3.distribution.ChiSquaredDistribution" />
  <import name="org.apache.commons.math3.distribution.ExponentialDistribution" />
  <import name="org.apache.commons.math3.distribution.FDistribution" />
  <import name="org.apache.commons.math3.distribution.GammaDistribution" />
  <import name="org.apache.commons.math3.distribution.HypergeometricDistribution" />
  <import name="org.apache.commons.math3.distribution.PascalDistribution" />
  <import name="org.apache.commons.math3.distribution.PoissonDistribution" />
  <import name="org.apache.commons.math3.distribution.TDistribution" />
  <import name="org.apache.commons.math3.distribution.WeibullDistribution" />
  <import name="org.apache.commons.math3.distribution.ZipfDistribution" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.exception.NotANumberException" />
  <import name="org.apache.commons.math3.exception.NotFiniteNumberException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="RandomDataGenerator" startLine="49">
    <implements name="RandomData" />
    <implements name="Serializable" />
    <javadoc>
      <text>* Implements the {@link RandomData} interface using a {@link RandomGenerator}instance to generate non-secure data and a {@link java.security.SecureRandom}instance to provide data for the <code>nextSecureXxx</code> methods. If no
 * <code>RandomGenerator</code> is provided in the constructor, the default is
 * to use a {@link Well19937c} generator. To plug in a different
 * implementation, either implement <code>RandomGenerator</code> directly or
 * extend {@link AbstractRandomGenerator}.
 * <p>
 * Supports reseeding the underlying pseudo-random number generator (PRNG). The
 * <code>SecurityProvider</code> and <code>Algorithm</code> used by the
 * <code>SecureRandom</code> instance can also be reset.
 * </p>
 * <p>
 * For details on the default PRNGs, see {@link java.util.Random} and{@link java.security.SecureRandom}.
 * </p>
 * <p>
 * <strong>Usage Notes</strong>:
 * <ul>
 * <li>
 * Instance variables are used to maintain <code>RandomGenerator</code> and
 * <code>SecureRandom</code> instances used in data generation. Therefore, to
 * generate a random sequence of values or strings, you should use just
 * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>
 * <li>
 * The "secure" methods are *much* slower. These should be used only when a
 * cryptographically secure random sequence is required. A secure random
 * sequence is a sequence of pseudo-random values which, in addition to being
 * well-dispersed (so no subsequence of values is an any more likely than other
 * subsequence of the the same length), also has the additional property that
 * knowledge of values generated up to any point in the sequence does not make
 * it any easier to predict subsequent values.</li>
 * <li>
 * When a new <code>RandomDataImpl</code> is created, the underlying random
 * number generators are <strong>not</strong> initialized. If you do not
 * explicitly seed the default non-secure generator, it is seeded with the
 * current time in milliseconds plus the system identity hash code on first use.
 * The same holds for the secure generator. If you provide a <code>RandomGenerator</code>
 * to the constructor, however, this generator is not reseeded by the constructor
 * nor is it reseeded on first use.</li>
 * <li>
 * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate to the
 * corresponding methods on the underlying <code>RandomGenerator</code> and
 * <code>SecureRandom</code> instances. Therefore, <code>reSeed(long)</code>
 * fully resets the initial state of the non-secure random number generator (so
 * that reseeding with a specific value always results in the same subsequent
 * random sequence); whereas reSeedSecure(long) does <strong>not</strong>
 * reinitialize the secure random number generator (so secure sequences started
 * with calls to reseedSecure(long) won't be identical).</li>
 * <li>
 * This implementation is not synchronized. The underlying <code>RandomGenerator</code>
 * or <code>SecureRandom</code> instances are not protected by synchronization and
 * are not guaranteed to be thread-safe.  Therefore, if an instance of this class
 * is concurrently utilized by multiple threads, it is the responsibility of
 * client code to synchronize access to seeding and data generation methods.
 * </li>
 * </ul>
 * </p></text>
      <since>3.1</since>
      <version>$Id: RandomDataGenerator.java 1462423 2013-03-29 07:25:18Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* underlying random number generator</text>
    </javadoc>
    <declaration type="RandomGenerator" name="rand" />
    <javadoc>
      <text>* underlying secure random number generator</text>
    </javadoc>
    <declaration type="SecureRandom" name="secRand" />
    <javadoc>
      <text>* Construct a RandomDataGenerator, using a default random generator as the source
 * of randomness.
 * <p>The default generator is a {@link Well19937c} seeded
 * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.
 * The generator is initialized and seeded on first use.</p></text>
    </javadoc>
    <method type="constructor" name="RandomDataGenerator" startLine="130" endLine="131" />
    <javadoc>
      <text>* Construct a RandomDataGenerator using the supplied {@link RandomGenerator} as
 * the source of (non-secure) random data.</text>
      <param>rand the source of (non-secure) random data
 * (may be null, resulting in the default generator)</param>
    </javadoc>
    <method type="constructor" name="RandomDataGenerator" startLine="140" endLine="142" />
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description:</strong> hex strings are generated using a
 * 2-step process.
 * <ol>
 * <li>{@code len / 2 + 1} binary bytes are generated using the underlying
 * Random</li>
 * <li>Each binary byte is translated into 2 hex digits</li>
 * </ol>
 * </p></text>
      <param>len the desired string length.</param>
      <return>the random string.</return>
      <throws>NotStrictlyPositiveException if {@code len <= 0}.</throws>
    </javadoc>
    <method type="String" name="nextHexString" startLine="160" endLine="193">
      <scope startLine="161" endLine="163" />
      <declaration type="RandomGenerator" name="ran" />
      <declaration type="StringBuilder" name="outBuffer" />
      <declaration type="byte[]" name="randomBytes" />
      <scope startLine="176" endLine="191">
        <declaration type="Integer" name="c" />
        <declaration type="String" name="hex" />
        <scope startLine="187" endLine="189" />
        <comment>Add 128 to byte value to make interval 0-255 before doing hex
 conversion. This guarantees <= 2 hex digits from toHexString()
 toHexString would otherwise add 2^32 to negative arguments.</comment>
        <comment>Make sure we add 2 hex digits for each byte</comment>
      </scope>
      <comment>Get a random number generator</comment>
      <comment>Initialize output buffer</comment>
      <comment>Get int(len/2)+1 random bytes</comment>
      <comment>Convert each byte to 2 hex digits</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="int" name="nextInt" startLine="196" endLine="216">
      <scope startLine="197" endLine="200" />
      <declaration type="int" name="max" />
      <scope startLine="202" endLine="212">
        <declaration type="RandomGenerator" name="rng" />
        <scope startLine="206" endLine="211">
          <declaration type="int" name="r" />
          <scope startLine="208" endLine="210" />
        </scope>
        <comment>the range is too wide to fit in a positive int (larger than 2^31); as it covers</comment>
        <comment>more than half the integer range, we use directly a simple rejection method</comment>
      </scope>
      <scope startLine="212" endLine="215">
        <comment>we can shift the range and generate directly a positive int</comment>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="long" name="nextLong" startLine="219" endLine="242">
      <scope startLine="220" endLine="223" />
      <declaration type="long" name="max" />
      <scope startLine="225" endLine="235">
        <declaration type="RandomGenerator" name="rng" />
        <scope startLine="229" endLine="234">
          <declaration type="long" name="r" />
          <scope startLine="231" endLine="233" />
        </scope>
        <comment>the range is too wide to fit in a positive long (larger than 2^63); as it covers</comment>
        <comment>more than half the long range, we use directly a simple rejection method</comment>
      </scope>
      <scope startLine="235" endLine="238">
        <comment>we can shift the range and generate directly a positive int</comment>
      </scope>
      <scope startLine="238" endLine="241">
        <comment>we can shift the range and generate directly a positive long</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a pseudorandom, uniformly distributed <tt>long</tt> value
 * between 0 (inclusive) and the specified value (exclusive), drawn from
 * this random number generator's sequence.</text>
      <param>rng random generator to use</param>
      <param>n the bound on the random number to be returned.  Must be
 * positive.</param>
      <return>a pseudorandom, uniformly distributed <tt>long</tt>
 * value between 0 (inclusive) and n (exclusive).</return>
      <throws>IllegalArgumentException  if n is not positive.</throws>
    </javadoc>
    <method type="long" name="nextLong" startLine="256" endLine="273">
      <scope startLine="257" endLine="271">
        <declaration type="byte[]" name="byteArray" />
        <declaration type="long" name="bits" />
        <declaration type="long" name="val" />
        <scope startLine="261" endLine="269">
          <scope startLine="264" endLine="266" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description:</strong> hex strings are generated in
 * 40-byte segments using a 3-step process.
 * <ol>
 * <li>
 * 20 random bytes are generated using the underlying
 * <code>SecureRandom</code>.</li>
 * <li>
 * SHA-1 hash is applied to yield a 20-byte binary digest.</li>
 * <li>
 * Each byte of the binary digest is converted to 2 hex digits.</li>
 * </ol>
 * </p></text>
      <throws>NotStrictlyPositiveException if {@code len <= 0}</throws>
    </javadoc>
    <method type="String" name="nextSecureHexString" startLine="292" endLine="339">
      <scope startLine="293" endLine="295" />
      <declaration type="SecureRandom" name="secRan" />
      <declaration type="MessageDigest" name="alg" />
      <scope startLine="300" endLine="302" />
      <scope startLine="302" endLine="305">
        <comment>this should never happen</comment>
      </scope>
      <declaration type="int" name="numIter" />
      <declaration type="StringBuilder" name="outBuffer" />
      <scope startLine="312" endLine="337">
        <declaration type="byte[]" name="randomBytes" />
        <declaration type="byte[]" name="hash" />
        <scope startLine="321" endLine="336">
          <declaration type="Integer" name="c" />
          <declaration type="String" name="hex" />
          <scope startLine="332" endLine="334" />
        </scope>
        <comment>Compute hash -- will create 20-byte binary hash</comment>
        <comment>Loop over the hash, converting each byte to 2 hex digits</comment>
        <comment>Add 128 to byte value to make interval 0-255 This guarantees
 <= 2 hex digits from toHexString() toHexString would
 otherwise add 2^32 to negative arguments</comment>
        <comment>Keep strings uniform length -- guarantees 40 bytes</comment>
      </scope>
      <comment>Get SecureRandom and setup Digest provider</comment>
      <comment>Compute number of iterations required (40 bytes each)</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="int" name="nextSecureInt" startLine="342" endLine="362">
      <scope startLine="343" endLine="346" />
      <declaration type="int" name="max" />
      <scope startLine="348" endLine="358">
        <declaration type="SecureRandom" name="rng" />
        <scope startLine="352" endLine="357">
          <declaration type="int" name="r" />
          <scope startLine="354" endLine="356" />
        </scope>
        <comment>the range is too wide to fit in a positive int (larger than 2^31); as it covers</comment>
        <comment>more than half the integer range, we use directly a simple rejection method</comment>
      </scope>
      <scope startLine="358" endLine="361">
        <comment>we can shift the range and generate directly a positive int</comment>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="long" name="nextSecureLong" startLine="365" endLine="388">
      <scope startLine="366" endLine="369" />
      <declaration type="long" name="max" />
      <scope startLine="371" endLine="381">
        <declaration type="SecureRandom" name="rng" />
        <scope startLine="375" endLine="380">
          <declaration type="long" name="r" />
          <scope startLine="377" endLine="379" />
        </scope>
        <comment>the range is too wide to fit in a positive long (larger than 2^63); as it covers</comment>
        <comment>more than half the long range, we use directly a simple rejection method</comment>
      </scope>
      <scope startLine="381" endLine="384">
        <comment>we can shift the range and generate directly a positive int</comment>
      </scope>
      <scope startLine="384" endLine="387">
        <comment>we can shift the range and generate directly a positive long</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a pseudorandom, uniformly distributed <tt>long</tt> value
 * between 0 (inclusive) and the specified value (exclusive), drawn from
 * this random number generator's sequence.</text>
      <param>rng random generator to use</param>
      <param>n the bound on the random number to be returned.  Must be
 * positive.</param>
      <return>a pseudorandom, uniformly distributed <tt>long</tt>
 * value between 0 (inclusive) and n (exclusive).</return>
      <throws>IllegalArgumentException  if n is not positive.</throws>
    </javadoc>
    <method type="long" name="nextLong" startLine="402" endLine="419">
      <scope startLine="403" endLine="417">
        <declaration type="byte[]" name="byteArray" />
        <declaration type="long" name="bits" />
        <declaration type="long" name="val" />
        <scope startLine="407" endLine="415">
          <scope startLine="410" endLine="412" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description</strong>:
 * <ul><li> For small means, uses simulation of a Poisson process
 * using Uniform deviates, as described
 * <a href="http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm"> here.</a>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li>
 * <li> For large means, uses the rejection algorithm described in <br/>
 * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>
 * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p></text>
      <throws>NotStrictlyPositiveException if {@code len <= 0}</throws>
    </javadoc>
    <method type="long" name="nextPoisson" startLine="435" endLine="439" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="nextGaussian" startLine="442" endLine="447">
      <scope startLine="443" endLine="445" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description</strong>: Uses the Algorithm SA (Ahrens)
 * from p. 876 in:
 * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for
 * sampling from the exponential and normal distributions.
 * Communications of the ACM, 15, 873-882.
 * </p></text>
    </javadoc>
    <method type="double" name="nextExponential" startLine="460" endLine="463" />
    <javadoc>
      <text>* <p>Generates a random value from the{@link org.apache.commons.math3.distribution.GammaDistribution Gamma Distribution}.</p>
 * <p>This implementation uses the following algorithms: </p>
 * <p>For 0 < shape < 1: <br/>
 * Ahrens, J. H. and Dieter, U., <i>Computer methods for
 * sampling from gamma, beta, Poisson and binomial distributions.</i>
 * Computing, 12, 223-246, 1974.</p>
 * <p>For shape >= 1: <br/>
 * Marsaglia and Tsang, <i>A Simple Method for Generating
 * Gamma Variables.</i> ACM Transactions on Mathematical Software,
 * Volume 26 Issue 3, September, 2000.</p></text>
      <param>shape the median of the Gamma distribution</param>
      <param>scale the scale parameter of the Gamma distribution</param>
      <return>random value sampled from the Gamma(shape, scale) distribution</return>
      <throws>NotStrictlyPositiveException if {@code shape <= 0} or{@code scale <= 0}.</throws>
    </javadoc>
    <method type="double" name="nextGamma" startLine="487" endLine="490" />
    <javadoc>
      <text>* Generates a random value from the {@link HypergeometricDistribution Hypergeometric Distribution}.</text>
      <param>populationSize the population size of the Hypergeometric distribution</param>
      <param>numberOfSuccesses number of successes in the population of the Hypergeometric distribution</param>
      <param>sampleSize the sample size of the Hypergeometric distribution</param>
      <return>random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution</return>
      <throws>NumberIsTooLargeException  if {@code numberOfSuccesses > populationSize},
 * or {@code sampleSize > populationSize}.</throws>
      <throws>NotStrictlyPositiveException if {@code populationSize <= 0}.</throws>
      <throws>NotPositiveException  if {@code numberOfSuccesses < 0}.</throws>
    </javadoc>
    <method type="int" name="nextHypergeometric" startLine="504" endLine="507" />
    <javadoc>
      <text>* Generates a random value from the {@link PascalDistribution Pascal Distribution}.</text>
      <param>r the number of successes of the Pascal distribution</param>
      <param>p the probability of success of the Pascal distribution</param>
      <return>random value sampled from the Pascal(r, p) distribution</return>
      <throws>NotStrictlyPositiveException if the number of successes is not positive</throws>
      <throws>OutOfRangeException if the probability of success is not in the
 * range {@code [0, 1]}.</throws>
    </javadoc>
    <method type="int" name="nextPascal" startLine="519" endLine="521" />
    <javadoc>
      <text>* Generates a random value from the {@link TDistribution T Distribution}.</text>
      <param>df the degrees of freedom of the T distribution</param>
      <return>random value from the T(df) distribution</return>
      <throws>NotStrictlyPositiveException if {@code df <= 0}</throws>
    </javadoc>
    <method type="double" name="nextT" startLine="530" endLine="533" />
    <javadoc>
      <text>* Generates a random value from the {@link WeibullDistribution Weibull Distribution}.</text>
      <param>shape the shape parameter of the Weibull distribution</param>
      <param>scale the scale parameter of the Weibull distribution</param>
      <return>random value sampled from the Weibull(shape, size) distribution</return>
      <throws>NotStrictlyPositiveException if {@code shape <= 0} or{@code scale <= 0}.</throws>
    </javadoc>
    <method type="double" name="nextWeibull" startLine="544" endLine="547" />
    <javadoc>
      <text>* Generates a random value from the {@link ZipfDistribution Zipf Distribution}.</text>
      <param>numberOfElements the number of elements of the ZipfDistribution</param>
      <param>exponent the exponent of the ZipfDistribution</param>
      <return>random value sampled from the Zipf(numberOfElements, exponent) distribution</return>
      <exception>NotStrictlyPositiveException if {@code numberOfElements <= 0}or {@code exponent <= 0}.</exception>
    </javadoc>
    <method type="int" name="nextZipf" startLine="558" endLine="560" />
    <javadoc>
      <text>* Generates a random value from the {@link BetaDistribution Beta Distribution}.</text>
      <param>alpha first distribution shape parameter</param>
      <param>beta second distribution shape parameter</param>
      <return>random value sampled from the beta(alpha, beta) distribution</return>
    </javadoc>
    <method type="double" name="nextBeta" startLine="569" endLine="572" />
    <javadoc>
      <text>* Generates a random value from the {@link BinomialDistribution Binomial Distribution}.</text>
      <param>numberOfTrials number of trials of the Binomial distribution</param>
      <param>probabilityOfSuccess probability of success of the Binomial distribution</param>
      <return>random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution</return>
    </javadoc>
    <method type="int" name="nextBinomial" startLine="581" endLine="583" />
    <javadoc>
      <text>* Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.</text>
      <param>median the median of the Cauchy distribution</param>
      <param>scale the scale parameter of the Cauchy distribution</param>
      <return>random value sampled from the Cauchy(median, scale) distribution</return>
    </javadoc>
    <method type="double" name="nextCauchy" startLine="592" endLine="595" />
    <javadoc>
      <text>* Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.</text>
      <param>df the degrees of freedom of the ChiSquare distribution</param>
      <return>random value sampled from the ChiSquare(df) distribution</return>
    </javadoc>
    <method type="double" name="nextChiSquare" startLine="603" endLine="606" />
    <javadoc>
      <text>* Generates a random value from the {@link FDistribution F Distribution}.</text>
      <param>numeratorDf the numerator degrees of freedom of the F distribution</param>
      <param>denominatorDf the denominator degrees of freedom of the F distribution</param>
      <return>random value sampled from the F(numeratorDf, denominatorDf) distribution</return>
      <throws>NotStrictlyPositiveException if{@code numeratorDf <= 0} or {@code denominatorDf <= 0}.</throws>
    </javadoc>
    <method type="double" name="nextF" startLine="617" endLine="620" />
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description</strong>: scales the output of
 * Random.nextDouble(), but rejects 0 values (i.e., will generate another
 * random double if Random.nextDouble() returns 0). This is necessary to
 * provide a symmetric output interval (both endpoints excluded).
 * </p></text>
      <throws>NumberIsTooLargeException if {@code lower >= upper}</throws>
      <throws>NotFiniteNumberException if one of the bounds is infinite</throws>
      <throws>NotANumberException if one of the bounds is NaN</throws>
    </javadoc>
    <method type="double" name="nextUniform" startLine="636" endLine="638" />
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description</strong>: if the lower bound is excluded,
 * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,
 * will generate another random double if Random.nextDouble() returns 0).
 * This is necessary to provide a symmetric output interval (both
 * endpoints excluded).
 * </p></text>
      <throws>NumberIsTooLargeException if {@code lower >= upper}</throws>
      <throws>NotFiniteNumberException if one of the bounds is infinite</throws>
      <throws>NotANumberException if one of the bounds is NaN</throws>
    </javadoc>
    <method type="double" name="nextUniform" startLine="656" endLine="683">
      <scope startLine="658" endLine="661" />
      <scope startLine="663" endLine="665" />
      <scope startLine="666" endLine="668" />
      <scope startLine="670" endLine="672" />
      <declaration type="RandomGenerator" name="generator" />
      <declaration type="double" name="u" />
      <scope startLine="678" endLine="680" />
      <comment>ensure nextDouble() isn't 0.0</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * Uses a 2-cycle permutation shuffle. The shuffling process is described <a
 * href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html">
 * here</a>.
 * </p></text>
      <throws>NumberIsTooLargeException if {@code k > n}.</throws>
      <throws>NotStrictlyPositiveException if {@code k <= 0}.</throws>
    </javadoc>
    <method type="int[]" name="nextPermutation" startLine="697" endLine="715">
      <scope startLine="698" endLine="701" />
      <scope startLine="702" endLine="705" />
      <declaration type="int[]" name="index" />
      <declaration type="int[]" name="result" />
      <scope startLine="710" endLine="712" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation
 * shuffle to generate a random permutation of <code>c.size()</code> and
 * then returns the elements whose indexes correspond to the elements of the
 * generated permutation. This technique is described, and proven to
 * generate random samples <a
 * href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html">
 * here</a>
 * </p></text>
    </javadoc>
    <method type="Object[]" name="nextSample" startLine="730" endLine="748">
      <declaration type="int" name="len" />
      <scope startLine="733" endLine="736" />
      <scope startLine="737" endLine="739" />
      <declaration type="Object[]" name="objects" />
      <declaration type="int[]" name="index" />
      <declaration type="Object[]" name="result" />
      <scope startLine="744" endLine="746" />
    </method>
    <javadoc>
      <text>* Reseeds the random number generator with the supplied seed.
 * <p>
 * Will create and initialize if null.
 * </p></text>
      <param>seed the seed value to use</param>
    </javadoc>
    <method type="void" name="reSeed" startLine="760" endLine="762" />
    <javadoc>
      <text>* Reseeds the secure random number generator with the current time in
 * milliseconds.
 * <p>
 * Will create and initialize if null.
 * </p></text>
    </javadoc>
    <method type="void" name="reSeedSecure" startLine="771" endLine="773" />
    <javadoc>
      <text>* Reseeds the secure random number generator with the supplied seed.
 * <p>
 * Will create and initialize if null.
 * </p></text>
      <param>seed the seed value to use</param>
    </javadoc>
    <method type="void" name="reSeedSecure" startLine="783" endLine="785" />
    <javadoc>
      <text>* Reseeds the random number generator with{@code System.currentTimeMillis() + System.identityHashCode(this))}.</text>
    </javadoc>
    <method type="void" name="reSeed" startLine="791" endLine="793" />
    <javadoc>
      <text>* Sets the PRNG algorithm for the underlying SecureRandom instance using
 * the Security Provider API. The Security Provider API is defined in <a
 * href =
 * "http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA">
 * Java Cryptography Architecture API Specification & Reference.</a>
 * <p>
 * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>
 * overhead and may take several seconds to execute.
 * </p></text>
      <param>algorithm the name of the PRNG algorithm</param>
      <param>provider the name of the provider</param>
      <throws>NoSuchAlgorithmException if the specified algorithm is not available</throws>
      <throws>NoSuchProviderException if the specified provider is not installed</throws>
    </javadoc>
    <method type="void" name="setSecureAlgorithm" startLine="812" endLine="814" />
    <javadoc>
      <text>* Returns the RandomGenerator used to generate non-secure random data.
 * <p>
 * Creates and initializes a default generator if null. Uses a {@link Well19937c}generator with {@code System.currentTimeMillis() + System.identityHashCode(this))}as the default seed.
 * </p></text>
      <return>the Random used to generate random data</return>
      <since>3.2</since>
    </javadoc>
    <method type="RandomGenerator" name="getRandomGenerator" startLine="827" endLine="832">
      <scope startLine="828" endLine="830" />
    </method>
    <javadoc>
      <text>* Sets the default generator to a {@link Well19937c} generator seeded with{@code System.currentTimeMillis() + System.identityHashCode(this))}.</text>
    </javadoc>
    <method type="void" name="initRan" startLine="838" endLine="840" />
    <javadoc>
      <text>* Returns the SecureRandom used to generate secure random data.
 * <p>
 * Creates and initializes if null.  Uses{@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.
 * </p></text>
      <return>the SecureRandom used to generate secure random data</return>
    </javadoc>
    <method type="SecureRandom" name="getSecRan" startLine="851" endLine="857">
      <scope startLine="852" endLine="855" />
    </method>
    <javadoc>
      <text>* Uses a 2-cycle permutation shuffle to randomly re-order the last elements
 * of list.</text>
      <param>list list to be shuffled</param>
      <param>end element past which shuffling begins</param>
    </javadoc>
    <method type="void" name="shuffle" startLine="866" endLine="879">
      <declaration type="int" name="target" />
      <scope startLine="868" endLine="878">
        <scope startLine="869" endLine="871" />
        <scope startLine="871" endLine="874" />
        <declaration type="int" name="temp" />
        <comment>NumberIsTooLargeException cannot occur</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns an array representing n.</text>
      <param>n the natural number to represent</param>
      <return>array with entries = elements of n</return>
    </javadoc>
    <method type="int[]" name="getNatural" startLine="887" endLine="893">
      <declaration type="int[]" name="natural" />
      <scope startLine="889" endLine="891" />
    </method>
  </class>
</source>
