<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.linear">
  <import name="org.apache.commons.math3.Field" />
  <import name="org.apache.commons.math3.FieldElement" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NoDataException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <interface name="FieldMatrix" startLine="31">
    <implements name="AnyMatrix" />
    <javadoc>
      <text>* Interface defining field-valued matrix with basic algebraic operations.
 * <p>
 * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>
 * returns the element in the first row, first column of the matrix.</p></text>
      <param><T>
 *  the type of the field elements</param>
      <version>$Id: FieldMatrix.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <method name="getField" type="Field<T>" startLine="41" endLine="46" />
    <javadoc>
      <text>* Get the type of field elements of the matrix.</text>
      <return>the type of field elements of the matrix.</return>
    </javadoc>
    <method name="createMatrix" type="FieldMatrix<T>" startLine="48" endLine="60" />
    <javadoc>
      <text>* Create a new FieldMatrix<T> of the same type as the instance with
 * the supplied row and column dimensions.</text>
      <param>rowDimension  the number of rows in the new matrix</param>
      <param>columnDimension  the number of columns in the new matrix</param>
      <return>a new matrix of the same type as the instance</return>
      <throws>NotStrictlyPositiveException if row or column dimension is not
 * positive.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="copy" type="FieldMatrix<T>" startLine="62" endLine="67" />
    <javadoc>
      <text>* Make a (deep) copy of this.</text>
      <return>a copy of this matrix.</return>
    </javadoc>
    <method name="add" type="FieldMatrix<T>" startLine="69" endLine="77" />
    <javadoc>
      <text>* Compute the sum of this and m.</text>
      <param>m Matrix to be added.</param>
      <return>{@code this} + {@code m}.</return>
      <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this} matrix.</throws>
    </javadoc>
    <method name="subtract" type="FieldMatrix<T>" startLine="79" endLine="87" />
    <javadoc>
      <text>* Subtract {@code m} from this matrix.</text>
      <param>m Matrix to be subtracted.</param>
      <return>{@code this} - {@code m}.</return>
      <throws>MatrixDimensionMismatchException if {@code m} is not the same
 * size as {@code this} matrix.</throws>
    </javadoc>
    <method name="scalarAdd" type="FieldMatrix<T>" startLine="89" endLine="95" />
    <javadoc>
      <text>* Increment each entry of this matrix.</text>
      <param>d Value to be added to each entry.</param>
      <return>{@code d} + {@code this}.</return>
    </javadoc>
    <method name="scalarMultiply" type="FieldMatrix<T>" startLine="97" endLine="103" />
    <javadoc>
      <text>* Multiply each entry by {@code d}.</text>
      <param>d Value to multiply all entries by.</param>
      <return>{@code d} * {@code this}.</return>
    </javadoc>
    <method name="multiply" type="FieldMatrix<T>" startLine="105" endLine="114" />
    <javadoc>
      <text>* Postmultiply this matrix by {@code m}.</text>
      <param>m  Matrix to postmultiply by.</param>
      <return>{@code this} * {@code m}.</return>
      <throws>DimensionMismatchException if the number of columns of{@code this} matrix is not equal to the number of rows of matrix{@code m}.</throws>
    </javadoc>
    <method name="preMultiply" type="FieldMatrix<T>" startLine="116" endLine="124" />
    <javadoc>
      <text>* Premultiply this matrix by {@code m}.</text>
      <param>m Matrix to premultiply by.</param>
      <return>{@code m} * {@code this}.</return>
      <throws>DimensionMismatchException if the number of columns of {@code m}differs from the number of rows of {@code this} matrix.</throws>
    </javadoc>
    <method name="power" type="FieldMatrix<T>" startLine="126" endLine="137" />
    <javadoc>
      <text>* Returns the result multiplying this with itself <code>p</code> times.
 * Depending on the type of the field elements, T, instability for high
 * powers might occur.</text>
      <param>p raise this to power p</param>
      <return>this^p</return>
      <throws>NotPositiveException if {@code p < 0}</throws>
      <throws>NonSquareMatrixException if {@code this matrix} is not square</throws>
    </javadoc>
    <method name="getData" type="T[][]" startLine="139" endLine="144" />
    <javadoc>
      <text>* Returns matrix entries as a two-dimensional array.</text>
      <return>a 2-dimensional array of entries.</return>
    </javadoc>
    <method name="getSubMatrix" type="FieldMatrix<T>" startLine="146" endLine="160" />
    <javadoc>
      <text>* Get a submatrix. Rows and columns are indicated
 * counting from 0 to n - 1.</text>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <return>the matrix containing the data of the specified rows and columns.</return>
      <throws>NumberIsTooSmallException is {@code endRow < startRow} of{@code endColumn < startColumn}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
    </javadoc>
    <method name="getSubMatrix" type="FieldMatrix<T>" startLine="162" endLine="177" />
    <javadoc>
      <text>* Get a submatrix. Rows and columns are indicated
 * counting from 0 to n - 1.</text>
      <param>selectedRows Array of row indices.</param>
      <param>selectedColumns Array of column indices.</param>
      <return>the matrix containing the data in the
 * specified rows and columns.</return>
      <throws>NoDataException if {@code selectedRows} or{@code selectedColumns} is empty</throws>
      <throws>NullArgumentException if {@code selectedRows} or{@code selectedColumns} is {@code null}.</throws>
      <throws>OutOfRangeException if row or column selections are not valid.</throws>
    </javadoc>
    <method name="copySubMatrix" type="void" startLine="179" endLine="199" />
    <javadoc>
      <text>* Copy a submatrix. Rows and columns are indicated
 * counting from 0 to n-1.</text>
      <param>startRow Initial row index.</param>
      <param>endRow Final row index (inclusive).</param>
      <param>startColumn Initial column index.</param>
      <param>endColumn Final column index (inclusive).</param>
      <param>destination The arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be used).</param>
      <throws>MatrixDimensionMismatchException if the dimensions of{@code destination} do not match those of {@code this}.</throws>
      <throws>NumberIsTooSmallException is {@code endRow < startRow} of{@code endColumn < startColumn}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <exception>IllegalArgumentException if the destination array is too small.</exception>
    </javadoc>
    <method name="copySubMatrix" type="void" startLine="201" endLine="219" />
    <javadoc>
      <text>* Copy a submatrix. Rows and columns are indicated
 * counting from 0 to n - 1.</text>
      <param>selectedRows Array of row indices.</param>
      <param>selectedColumns Array of column indices.</param>
      <param>destination Arrays where the submatrix data should be copied
 * (if larger than rows/columns counts, only the upper-left part will be used)</param>
      <throws>MatrixDimensionMismatchException if the dimensions of{@code destination} do not match those of {@code this}.</throws>
      <throws>NoDataException if {@code selectedRows} or{@code selectedColumns} is empty</throws>
      <throws>NullArgumentException if {@code selectedRows} or{@code selectedColumns} is {@code null}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
    </javadoc>
    <method name="setSubMatrix" type="void" startLine="221" endLine="258" />
    <javadoc>
      <text>* Replace the submatrix starting at {@code (row, column)} using data in the
 * input {@code subMatrix} array. Indexes are 0-based.
 * <p>
 * Example:<br>
 * Starting with
 * <pre>
 * 1  2  3  4
 * 5  6  7  8
 * 9  0  1  2
 * </pre>
 * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking
 * <code>setSubMatrix(subMatrix,1,1))</code> will result in
 * <pre>
 * 1  2  3  4
 * 5  3  4  8
 * 9  5  6  2
 * </pre>
 * </p></text>
      <param>subMatrix Array containing the submatrix replacement data.</param>
      <param>row Row coordinate of the top-left element to be replaced.</param>
      <param>column Column coordinate of the top-left element to be replaced.</param>
      <throws>OutOfRangeException if {@code subMatrix} does not fit into this
 * matrix from element in {@code (row, column)}.</throws>
      <throws>NoDataException if a row or column of {@code subMatrix} is empty.</throws>
      <throws>DimensionMismatchException if {@code subMatrix} is not
 * rectangular (not all rows have the same length).</throws>
      <throws>NullArgumentException if {@code subMatrix} is {@code null}.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="getRowMatrix" type="FieldMatrix<T>" startLine="260" endLine="268" />
    <javadoc>
      <text>* Get the entries in row number {@code row}as a row matrix.</text>
      <param>row Row to be fetched.</param>
      <return>a row matrix.</return>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
    </javadoc>
    <method name="setRowMatrix" type="void" startLine="270" endLine="282" />
    <javadoc>
      <text>* Set the entries in row number {@code row}as a row matrix.</text>
      <param>row Row to be set.</param>
      <param>matrix Row matrix (must have one row and the same number
 * of columns as the instance).</param>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
      <throws>MatrixDimensionMismatchExceptionif the matrix dimensions do not match one instance row.</throws>
    </javadoc>
    <method name="getColumnMatrix" type="FieldMatrix<T>" startLine="284" endLine="292" />
    <javadoc>
      <text>* Get the entries in column number {@code column}as a column matrix.</text>
      <param>column Column to be fetched.</param>
      <return>a column matrix.</return>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
    </javadoc>
    <method name="setColumnMatrix" type="void" startLine="294" endLine="306" />
    <javadoc>
      <text>* Set the entries in column number {@code column}as a column matrix.</text>
      <param>column Column to be set.</param>
      <param>matrix column matrix (must have one column and the same
 * number of rows as the instance).</param>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the matrix dimensions do
 * not match one instance column.</throws>
    </javadoc>
    <method name="getRowVector" type="FieldVector<T>" startLine="308" endLine="316" />
    <javadoc>
      <text>* Get the entries in row number {@code row}as a vector.</text>
      <param>row Row to be fetched</param>
      <return>a row vector.</return>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
    </javadoc>
    <method name="setRowVector" type="void" startLine="318" endLine="330" />
    <javadoc>
      <text>* Set the entries in row number {@code row}as a vector.</text>
      <param>row Row to be set.</param>
      <param>vector row vector (must have the same number of columns
 * as the instance).</param>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the vector dimension does not
 * match one instance row.</throws>
    </javadoc>
    <method name="getColumnVector" type="FieldVector<T>" startLine="332" endLine="340" />
    <javadoc>
      <text>* Returns the entries in column number {@code column}as a vector.</text>
      <param>column Column to be fetched.</param>
      <return>a column vector.</return>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
    </javadoc>
    <method name="setColumnVector" type="void" startLine="342" endLine="354" />
    <javadoc>
      <text>* Set the entries in column number {@code column}as a vector.</text>
      <param>column Column to be set.</param>
      <param>vector Column vector (must have the same number of rows
 * as the instance).</param>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the vector dimension does not
 * match one instance column.</throws>
    </javadoc>
    <method name="getRow" type="T[]" startLine="356" endLine="363" />
    <javadoc>
      <text>* Get the entries in row number {@code row} as an array.</text>
      <param>row Row to be fetched.</param>
      <return>array of entries in the row.</return>
      <throws>OutOfRangeException if the specified row index is not valid.</throws>
    </javadoc>
    <method name="setRow" type="void" startLine="365" endLine="377" />
    <javadoc>
      <text>* Set the entries in row number {@code row}as a row matrix.</text>
      <param>row Row to be set.</param>
      <param>array Row matrix (must have the same number of columns as
 * the instance).</param>
      <throws>OutOfRangeException if the specified row index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the array size does not match
 * one instance row.</throws>
    </javadoc>
    <method name="getColumn" type="T[]" startLine="379" endLine="386" />
    <javadoc>
      <text>* Get the entries in column number {@code col} as an array.</text>
      <param>column the column to be fetched</param>
      <return>array of entries in the column</return>
      <throws>OutOfRangeException if the specified column index is not valid.</throws>
    </javadoc>
    <method name="setColumn" type="void" startLine="388" endLine="399" />
    <javadoc>
      <text>* Set the entries in column number {@code column}as a column matrix.</text>
      <param>column the column to be set</param>
      <param>array column array (must have the same number of rows as the instance)</param>
      <throws>OutOfRangeException if the specified column index is invalid.</throws>
      <throws>MatrixDimensionMismatchException if the array size does not match
 * one instance column.</throws>
    </javadoc>
    <method name="getEntry" type="T" startLine="401" endLine="409" />
    <javadoc>
      <text>* Returns the entry in the specified row and column.</text>
      <param>row  row location of entry to be fetched</param>
      <param>column  column location of entry to be fetched</param>
      <return>matrix entry in row,column</return>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
    </javadoc>
    <method name="setEntry" type="void" startLine="411" endLine="420" />
    <javadoc>
      <text>* Set the entry in the specified row and column.</text>
      <param>row  row location of entry to be set</param>
      <param>column  column location of entry to be set</param>
      <param>value matrix entry to be set in row,column</param>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="addToEntry" type="void" startLine="422" endLine="432" />
    <javadoc>
      <text>* Change an entry in the specified row and column.</text>
      <param>row Row location of entry to be set.</param>
      <param>column Column location of entry to be set.</param>
      <param>increment Value to add to the current matrix entry in{@code (row, column)}.</param>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="multiplyEntry" type="void" startLine="434" endLine="444" />
    <javadoc>
      <text>* Change an entry in the specified row and column.</text>
      <param>row Row location of entry to be set.</param>
      <param>column Column location of entry to be set.</param>
      <param>factor Multiplication factor for the current matrix entry
 * in {@code (row,column)}</param>
      <throws>OutOfRangeException if the row or column index is not valid.</throws>
      <since>2.0</since>
    </javadoc>
    <method name="transpose" type="FieldMatrix<T>" startLine="446" endLine="451" />
    <javadoc>
      <text>* Returns the transpose of this matrix.</text>
      <return>transpose matrix</return>
    </javadoc>
    <method name="getTrace" type="T" startLine="453" endLine="460" />
    <javadoc>
      <text>* Returns the <a href="http://mathworld.wolfram.com/MatrixTrace.html">
 * trace</a> of the matrix (the sum of the elements on the main diagonal).</text>
      <return>trace</return>
      <throws>NonSquareMatrixException if the matrix is not square.</throws>
    </javadoc>
    <method name="operate" type="T[]" startLine="462" endLine="470" />
    <javadoc>
      <text>* Returns the result of multiplying this by the vector {@code v}.</text>
      <param>v the vector to operate on</param>
      <return>{@code this * v}</return>
      <throws>DimensionMismatchException if the number of columns of{@code this} matrix is not equal to the size of the vector {@code v}.</throws>
    </javadoc>
    <method name="operate" type="FieldVector<T>" startLine="472" endLine="480" />
    <javadoc>
      <text>* Returns the result of multiplying this by the vector {@code v}.</text>
      <param>v the vector to operate on</param>
      <return>{@code this * v}</return>
      <throws>DimensionMismatchException if the number of columns of{@code this} matrix is not equal to the size of the vector {@code v}.</throws>
    </javadoc>
    <method name="preMultiply" type="T[]" startLine="482" endLine="491" />
    <javadoc>
      <text>* Returns the (row) vector result of premultiplying this by the vector{@code v}.</text>
      <param>v the row vector to premultiply by</param>
      <return>{@code v * this}</return>
      <throws>DimensionMismatchException if the number of rows of {@code this}matrix is not equal to the size of the vector {@code v}</throws>
    </javadoc>
    <method name="preMultiply" type="FieldVector<T>" startLine="493" endLine="502" />
    <javadoc>
      <text>* Returns the (row) vector result of premultiplying this by the vector{@code v}.</text>
      <param>v the row vector to premultiply by</param>
      <return>{@code v * this}</return>
      <throws>DimensionMismatchException if the number of rows of {@code this}matrix is not equal to the size of the vector {@code v}</throws>
    </javadoc>
    <method name="walkInRowOrder" type="T" startLine="504" endLine="524" />
    <javadoc>
      <text>* Visit (and possibly change) all matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInRowOrder" type="T" startLine="526" endLine="546" />
    <javadoc>
      <text>* Visit (but don't change) all matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInRowOrder" type="T" startLine="548" endLine="577" />
    <javadoc>
      <text>* Visit (and possibly change) some matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInRowOrder" type="T" startLine="579" endLine="608" />
    <javadoc>
      <text>* Visit (but don't change) some matrix entries in row order.
 * <p>Row order starts at upper left and iterating through all elements
 * of a row from left to right before going to the leftmost element
 * of the next row.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="T" startLine="610" endLine="630" />
    <javadoc>
      <text>* Visit (and possibly change) all matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="T" startLine="632" endLine="652" />
    <javadoc>
      <text>* Visit (but don't change) all matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="T" startLine="654" endLine="683" />
    <javadoc>
      <text>* Visit (and possibly change) some matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInColumnOrder" type="T" startLine="685" endLine="714" />
    <javadoc>
      <text>* Visit (but don't change) some matrix entries in column order.
 * <p>Column order starts at upper left and iterating through all elements
 * of a column from top to bottom before going to the topmost element
 * of the next column.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index</param>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="T" startLine="716" endLine="735" />
    <javadoc>
      <text>* Visit (and possibly change) all matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="T" startLine="737" endLine="756" />
    <javadoc>
      <text>* Visit (but don't change) all matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="T" startLine="758" endLine="786" />
    <javadoc>
      <text>* Visit (and possibly change) some matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixChangingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
    <method name="walkInOptimizedOrder" type="T" startLine="788" endLine="816" />
    <javadoc>
      <text>* Visit (but don't change) some matrix entries using the fastest possible order.
 * <p>The fastest walking order depends on the exact matrix class. It may be
 * different from traditional row or column orders.</p></text>
      <param>visitor visitor used to process all matrix entries</param>
      <param>startRow Initial row index</param>
      <param>endRow Final row index (inclusive)</param>
      <param>startColumn Initial column index</param>
      <param>endColumn Final column index (inclusive)</param>
      <throws>NumberIsTooSmallException if {@code endRow < startRow} or{@code endColumn < startColumn}.</throws>
      <throws>OutOfRangeException if the indices are not valid.</throws>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInRowOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInRowOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInColumnOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <see>#walkInColumnOrder(FieldMatrixPreservingVisitor,int,int,int,int)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixPreservingVisitor)</see>
      <see>#walkInOptimizedOrder(FieldMatrixChangingVisitor,int,int,int,int)</see>
      <return>the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end
 * of the walk</return>
    </javadoc>
  </interface>
</source>
