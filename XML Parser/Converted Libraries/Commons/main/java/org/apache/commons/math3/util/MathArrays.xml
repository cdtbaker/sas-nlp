<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.lang.reflect.Array" />
  <import name="java.util.ArrayList" />
  <import name="java.util.Arrays" />
  <import name="java.util.Collections" />
  <import name="java.util.Comparator" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.Field" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.exception.NonMonotonicSequenceException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="MathArrays" startLine="38">
    <javadoc>
      <text>* Arrays utilities.</text>
      <since>3.0</since>
      <version>$Id: MathArrays.java 1462423 2013-03-29 07:25:18Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* Factor used for splitting double numbers: n = 2^27 + 1 (i.e. {@value}).</text>
    </javadoc>
    <declaration type="int" name="SPLIT_FACTOR" />
    <javadoc>
      <text>* Private constructor.</text>
    </javadoc>
    <method type="constructor" name="MathArrays" startLine="51" endLine="51" />
    <interface name="Function" startLine="53">
      <javadoc>
        <text>* Real-valued function that operate on an array or a part of it.</text>
        <since>3.1</since>
      </javadoc>
      <method name="evaluate" type="double" startLine="58" endLine="64" />
      <javadoc>
        <text>* Operates on an entire array.</text>
        <param>array Array to operate on.</param>
        <return>the result of the operation.</return>
      </javadoc>
      <method name="evaluate" type="double" startLine="65" endLine="73" />
      <javadoc>
        <param>array Array to operate on.</param>
        <param>startIndex Index of the first element to take into account.</param>
        <param>numElements Number of elements to take into account.</param>
        <return>the result of the operation.</return>
      </javadoc>
      <javadoc>
        <text>* Create a copy of an array scaled by a value.</text>
        <param>arr Array to scale.</param>
        <param>val Scalar.</param>
        <return>scaled copy of array with each entry multiplied by val.</return>
        <since>3.2</since>
      </javadoc>
      <method type="double[]" name="scale" startLine="84" endLine="90">
        <declaration type="double[]" name="newArr" />
        <scope startLine="86" endLine="88" />
      </method>
      <javadoc>
        <text>* <p>Multiply each element of an array by a value.</p>
 * <p>The array is modified in place (no copy is created).</p></text>
        <param>arr Array to scale</param>
        <param>val Scalar</param>
        <since>3.2</since>
      </javadoc>
      <method type="void" name="scaleInPlace" startLine="101" endLine="105">
        <scope startLine="102" endLine="104" />
      </method>
      <javadoc>
        <text>* Creates an array whose contents will be the element-by-element
 * addition of the arguments.</text>
        <param>a First term of the addition.</param>
        <param>b Second term of the addition.</param>
        <return>a new array {@code r} where {@code r[i] = a[i] + b[i]}.</return>
        <throws>DimensionMismatchException if the array lengths differ.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="double[]" name="ebeAdd" startLine="118" endLine="128">
        <scope startLine="119" endLine="121" />
        <declaration type="double[]" name="result" />
        <scope startLine="124" endLine="126" />
      </method>
      <javadoc>
        <text>* Creates an array whose contents will be the element-by-element
 * subtraction of the second argument from the first.</text>
        <param>a First term.</param>
        <param>b Element to be subtracted.</param>
        <return>a new array {@code r} where {@code r[i] = a[i] - b[i]}.</return>
        <throws>DimensionMismatchException if the array lengths differ.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="double[]" name="ebeSubtract" startLine="140" endLine="150">
        <scope startLine="141" endLine="143" />
        <declaration type="double[]" name="result" />
        <scope startLine="146" endLine="148" />
      </method>
      <javadoc>
        <text>* Creates an array whose contents will be the element-by-element
 * multiplication of the arguments.</text>
        <param>a First factor of the multiplication.</param>
        <param>b Second factor of the multiplication.</param>
        <return>a new array {@code r} where {@code r[i] = a[i] * b[i]}.</return>
        <throws>DimensionMismatchException if the array lengths differ.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="double[]" name="ebeMultiply" startLine="162" endLine="172">
        <scope startLine="163" endLine="165" />
        <declaration type="double[]" name="result" />
        <scope startLine="168" endLine="170" />
      </method>
      <javadoc>
        <text>* Creates an array whose contents will be the element-by-element
 * division of the first argument by the second.</text>
        <param>a Numerator of the division.</param>
        <param>b Denominator of the division.</param>
        <return>a new array {@code r} where {@code r[i] = a[i] / b[i]}.</return>
        <throws>DimensionMismatchException if the array lengths differ.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="double[]" name="ebeDivide" startLine="184" endLine="194">
        <scope startLine="185" endLine="187" />
        <declaration type="double[]" name="result" />
        <scope startLine="190" endLine="192" />
      </method>
      <javadoc>
        <text>* Calculates the L<sub>1</sub> (sum of abs) distance between two points.</text>
        <param>p1 the first point</param>
        <param>p2 the second point</param>
        <return>the L<sub>1</sub> distance between the two points</return>
      </javadoc>
      <method type="double" name="distance1" startLine="203" endLine="209">
        <declaration type="double" name="sum" />
        <scope startLine="205" endLine="207" />
      </method>
      <javadoc>
        <text>* Calculates the L<sub>1</sub> (sum of abs) distance between two points.</text>
        <param>p1 the first point</param>
        <param>p2 the second point</param>
        <return>the L<sub>1</sub> distance between the two points</return>
      </javadoc>
      <method type="int" name="distance1" startLine="218" endLine="224">
        <declaration type="int" name="sum" />
        <scope startLine="220" endLine="222" />
      </method>
      <javadoc>
        <text>* Calculates the L<sub>2</sub> (Euclidean) distance between two points.</text>
        <param>p1 the first point</param>
        <param>p2 the second point</param>
        <return>the L<sub>2</sub> distance between the two points</return>
      </javadoc>
      <method type="double" name="distance" startLine="233" endLine="240">
        <declaration type="double" name="sum" />
        <scope startLine="235" endLine="238">
          <declaration type="double" name="dp" />
        </scope>
      </method>
      <javadoc>
        <text>* Calculates the L<sub>2</sub> (Euclidean) distance between two points.</text>
        <param>p1 the first point</param>
        <param>p2 the second point</param>
        <return>the L<sub>2</sub> distance between the two points</return>
      </javadoc>
      <method type="double" name="distance" startLine="249" endLine="256">
        <declaration type="double" name="sum" />
        <scope startLine="251" endLine="254">
          <declaration type="double" name="dp" />
        </scope>
      </method>
      <javadoc>
        <text>* Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.</text>
        <param>p1 the first point</param>
        <param>p2 the second point</param>
        <return>the L<sub>&infin;</sub> distance between the two points</return>
      </javadoc>
      <method type="double" name="distanceInf" startLine="265" endLine="271">
        <declaration type="double" name="max" />
        <scope startLine="267" endLine="269" />
      </method>
      <javadoc>
        <text>* Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.</text>
        <param>p1 the first point</param>
        <param>p2 the second point</param>
        <return>the L<sub>&infin;</sub> distance between the two points</return>
      </javadoc>
      <method type="int" name="distanceInf" startLine="280" endLine="286">
        <declaration type="int" name="max" />
        <scope startLine="282" endLine="284" />
      </method>
      <javadoc>
        <text>* Specification of ordering direction.</text>
      </javadoc>
      <javadoc>
        <text>* Constant for increasing direction.</text>
      </javadoc>
      <javadoc>
        <text>* Constant for decreasing direction.</text>
      </javadoc>
      <javadoc>
        <text>* Check that an array is monotonically increasing or decreasing.</text>
        <param><T>
 *  the type of the elements in the specified array</param>
        <param>val Values.</param>
        <param>dir Ordering direction.</param>
        <param>strict Whether the order should be strict.</param>
        <return>{@code true} if sorted, {@code false} otherwise.</return>
      </javadoc>
      <method type="boolean" name="isMonotonic" startLine="309" endLine="347">
        <declaration type="T" name="previous" />
        <declaration type="int" name="max" />
        <scope startLine="312" endLine="345">
          <declaration type="int" name="comp" />
          <scope startLine="317" endLine="321">
            <scope startLine="318" endLine="320" />
          </scope>
          <scope startLine="321" endLine="325">
            <scope startLine="322" endLine="324" />
          </scope>
          <scope startLine="329" endLine="333">
            <scope startLine="330" endLine="332" />
          </scope>
          <scope startLine="333" endLine="337">
            <scope startLine="334" endLine="336" />
          </scope>
          <comment>Should never happen.</comment>
        </scope>
      </method>
      <javadoc>
        <text>* Check that an array is monotonically increasing or decreasing.</text>
        <param>val Values.</param>
        <param>dir Ordering direction.</param>
        <param>strict Whether the order should be strict.</param>
        <return>{@code true} if sorted, {@code false} otherwise.</return>
      </javadoc>
      <method type="boolean" name="isMonotonic" startLine="357" endLine="359" />
      <javadoc>
        <text>* Check that the given array is sorted.</text>
        <param>val Values.</param>
        <param>dir Ordering direction.</param>
        <param>strict Whether the order should be strict.</param>
        <param>abort Whether to throw an exception if the check fails.</param>
        <return>{@code true} if the array is sorted.</return>
        <throws>NonMonotonicSequenceException if the array is not sorted
 * and {@code abort} is {@code true}.</throws>
      </javadoc>
      <method type="boolean" name="checkOrder" startLine="374" endLine="423">
        <declaration type="double" name="previous" />
        <declaration type="int" name="max" />
        <declaration type="int" name="index" />
        <scope startLine="380" endLine="410">
          <scope startLine="383" endLine="387">
            <scope startLine="384" endLine="386" />
          </scope>
          <scope startLine="387" endLine="391">
            <scope startLine="388" endLine="390" />
          </scope>
          <scope startLine="394" endLine="398">
            <scope startLine="395" endLine="397" />
          </scope>
          <scope startLine="398" endLine="402">
            <scope startLine="399" endLine="401" />
          </scope>
          <comment>Should never happen.</comment>
        </scope>
        <scope startLine="412" endLine="415">
          <comment>Loop completed.</comment>
        </scope>
        <scope startLine="418" endLine="420" />
        <scope startLine="420" endLine="422" />
        <comment>Loop early exit means wrong ordering.</comment>
      </method>
      <javadoc>
        <text>* Check that the given array is sorted.</text>
        <param>val Values.</param>
        <param>dir Ordering direction.</param>
        <param>strict Whether the order should be strict.</param>
        <throws>NonMonotonicSequenceException if the array is not sorted.</throws>
        <since>2.2</since>
      </javadoc>
      <method type="void" name="checkOrder" startLine="435" endLine="437" />
      <javadoc>
        <text>* Check that the given array is sorted in strictly increasing order.</text>
        <param>val Values.</param>
        <throws>NonMonotonicSequenceException if the array is not sorted.</throws>
        <since>2.2</since>
      </javadoc>
      <method type="void" name="checkOrder" startLine="446" endLine="448" />
      <javadoc>
        <text>* Throws DimensionMismatchException if the input array is not rectangular.</text>
        <param>in array to be tested</param>
        <throws>NullArgumentException if input array is null</throws>
        <throws>DimensionMismatchException if input array is not rectangular</throws>
        <since>3.1</since>
      </javadoc>
      <method type="void" name="checkRectangular" startLine="459" endLine="468">
        <scope startLine="461" endLine="467">
          <scope startLine="462" endLine="466" />
        </scope>
      </method>
      <javadoc>
        <text>* Check that all entries of the input array are strictly positive.</text>
        <param>in Array to be tested</param>
        <throws>NotStrictlyPositiveException if any entries of the array are not
 * strictly positive.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="void" name="checkPositive" startLine="479" endLine="485">
        <scope startLine="480" endLine="484">
          <scope startLine="481" endLine="483" />
        </scope>
      </method>
      <javadoc>
        <text>* Check that all entries of the input array are >= 0.</text>
        <param>in Array to be tested</param>
        <throws>NotPositiveException if any array entries are less than 0.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="void" name="checkNonNegative" startLine="495" endLine="501">
        <scope startLine="496" endLine="500">
          <scope startLine="497" endLine="499" />
        </scope>
      </method>
      <javadoc>
        <text>* Check all entries of the input array are >= 0.</text>
        <param>in Array to be tested</param>
        <throws>NotPositiveException if any array entries are less than 0.</throws>
        <since>3.1</since>
      </javadoc>
      <method type="void" name="checkNonNegative" startLine="511" endLine="519">
        <scope startLine="512" endLine="518">
          <scope startLine="513" endLine="517">
            <scope startLine="514" endLine="516" />
          </scope>
        </scope>
      </method>
      <javadoc>
        <text>* Returns the Cartesian norm (2-norm), handling both overflow and underflow.
 * Translation of the minpack enorm subroutine.
 * The redistribution policy for MINPACK is available
 * <a href="http://www.netlib.org/minpack/disclaimer">here</a>, for
 * convenience, it is reproduced below.</p>
 * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0">
 * <tr><td>
 * Minpack Copyright Notice (1999) University of Chicago.
 * All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 * <li>Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 * must include the following acknowledgment:{@code This product includes software developed by the University of
 * Chicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself,
 * if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"
 * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 * BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table></text>
        <param>v Vector of doubles.</param>
        <return>the 2-norm of the vector.</return>
        <since>2.2</since>
      </javadoc>
      <method type="double" name="safeNorm" startLine="581" endLine="634">
        <declaration type="double" name="rdwarf" />
        <declaration type="double" name="rgiant" />
        <declaration type="double" name="s1" />
        <declaration type="double" name="s2" />
        <declaration type="double" name="s3" />
        <declaration type="double" name="x1max" />
        <declaration type="double" name="x3max" />
        <declaration type="double" name="floatn" />
        <declaration type="double" name="agiant" />
        <scope startLine="591" endLine="618">
          <declaration type="double" name="xabs" />
          <scope startLine="593" endLine="615">
            <scope startLine="594" endLine="603">
              <scope startLine="595" endLine="599">
                <declaration type="double" name="r" />
              </scope>
              <scope startLine="599" endLine="602">
                <declaration type="double" name="r" />
              </scope>
            </scope>
            <scope startLine="603" endLine="614">
              <scope startLine="604" endLine="608">
                <declaration type="double" name="r" />
              </scope>
              <scope startLine="608" endLine="613">
                <scope startLine="609" endLine="612">
                  <declaration type="double" name="r" />
                </scope>
              </scope>
            </scope>
          </scope>
          <scope startLine="615" endLine="617" />
        </scope>
        <declaration type="double" name="norm" />
        <scope startLine="620" endLine="622" />
        <scope startLine="622" endLine="632">
          <scope startLine="623" endLine="625" />
          <scope startLine="625" endLine="631">
            <scope startLine="626" endLine="628" />
            <scope startLine="628" endLine="630" />
          </scope>
        </scope>
      </method>
      <javadoc>
        <text>* Sort an array in ascending order in place and perform the same reordering
 * of entries on other arrays. For example, if{@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then{@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},{@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.</text>
        <param>x Array to be sorted and used as a pattern for permutation
 * of the other arrays.</param>
        <param>yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.</param>
        <throws>DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.</throws>
        <throws>NullArgumentException if {@code x} or any {@code y} is null.</throws>
        <since>3.0</since>
      </javadoc>
      <method type="void" name="sortInPlace" startLine="653" endLine="655" />
      <javadoc>
        <text>* Sort an array in place and perform the same reordering of entries on
 * other arrays.  This method works the same as the other{@link #sortInPlace(double[],double[][]) sortInPlace} method, but
 * allows the order of the sort to be provided in the {@code dir}parameter.</text>
        <param>x Array to be sorted and used as a pattern for permutation
 * of the other arrays.</param>
        <param>dir Order direction.</param>
        <param>yList Set of arrays whose permutations of entries will follow
 * those performed on {@code x}.</param>
        <throws>DimensionMismatchException if any {@code y} is not the same
 * size as {@code x}.</throws>
        <throws>NullArgumentException if {@code x} or any {@code y} is null</throws>
        <since>3.0</since>
      </javadoc>
      <method type="void" name="sortInPlace" startLine="677" endLine="732">
        <scope startLine="678" endLine="680" />
        <declaration type="int" name="len" />
        <declaration type="List<Pair<Double,double[]>>[]" name="list" />
        <declaration type="int" name="yListLen" />
        <scope startLine="687" endLine="700">
          <declaration type="double[]" name="yValues" />
          <scope startLine="689" endLine="698">
            <declaration type="double[]" name="y" />
            <scope startLine="691" endLine="693" />
            <scope startLine="694" endLine="696" />
          </scope>
        </scope>
        <declaration type="Comparator<Pair<Double,double[]>>[]" name="comp" />
        <method type="int" name="compare" startLine="705" endLine="719">
          <declaration type="int" name="val" />
        </method>
        <scope startLine="724" endLine="731">
          <declaration type="Pair<Double,double[]>" name="e" />
          <declaration type="double[]" name="yValues" />
          <scope startLine="728" endLine="730" />
        </scope>
        <comment>Should never happen.</comment>
      </method>
      <javadoc>
        <text>* Creates a copy of the {@code source} array.</text>
        <param>source Array to be copied.</param>
        <return>the copied array.</return>
      </javadoc>
      <method type="int[]" name="copyOf" startLine="740" endLine="742" />
      <javadoc>
        <text>* Creates a copy of the {@code source} array.</text>
        <param>source Array to be copied.</param>
        <return>the copied array.</return>
      </javadoc>
      <method type="double[]" name="copyOf" startLine="750" endLine="752" />
      <javadoc>
        <text>* Creates a copy of the {@code source} array.</text>
        <param>source Array to be copied.</param>
        <param>len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.</param>
        <return>the copied array.</return>
      </javadoc>
      <method type="int[]" name="copyOf" startLine="763" endLine="767">
        <declaration type="int[]" name="output" />
      </method>
      <javadoc>
        <text>* Creates a copy of the {@code source} array.</text>
        <param>source Array to be copied.</param>
        <param>len Number of entries to copy. If smaller then the source
 * length, the copy will be truncated, if larger it will padded with
 * zeroes.</param>
        <return>the copied array.</return>
      </javadoc>
      <method type="double[]" name="copyOf" startLine="778" endLine="782">
        <declaration type="double[]" name="output" />
      </method>
      <javadoc>
        <text>* Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.</text>
        <param>a Factors.</param>
        <param>b Factors.</param>
        <return><code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.</return>
        <throws>DimensionMismatchException if arrays dimensions don't match</throws>
      </javadoc>
      <method type="double" name="linearCombination" startLine="802" endLine="857">
        <declaration type="int" name="len" />
        <scope startLine="804" endLine="806" />
        <declaration type="double[]" name="prodHigh" />
        <declaration type="double" name="prodLowSum" />
        <scope startLine="811" endLine="827">
          <declaration type="double" name="ai" />
          <declaration type="double" name="ca" />
          <declaration type="double" name="aHigh" />
          <declaration type="double" name="aLow" />
          <declaration type="double" name="bi" />
          <declaration type="double" name="cb" />
          <declaration type="double" name="bHigh" />
          <declaration type="double" name="bLow" />
          <declaration type="double" name="prodLow" />
        </scope>
        <declaration type="double" name="prodHighCur" />
        <declaration type="double" name="prodHighNext" />
        <declaration type="double" name="sHighPrev" />
        <declaration type="double" name="sPrime" />
        <declaration type="double" name="sLowSum" />
        <declaration type="int" name="lenMinusOne" />
        <scope startLine="837" endLine="843">
          <declaration type="double" name="sHighCur" />
        </scope>
        <declaration type="double" name="result" />
        <scope startLine="847" endLine="854">
          <scope startLine="851" endLine="853" />
          <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
          <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
        </scope>
      </method>
      <javadoc>
        <text>* Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does
 * so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects. It is based
 * on the 2005 paper <a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p></text>
        <param>a1 first factor of the first term</param>
        <param>b1 second factor of the first term</param>
        <param>a2 first factor of the second term</param>
        <param>b2 second factor of the second term</param>
        <return>a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub></return>
        <see>#linearCombination(double,double,double,double,double,double)</see>
        <see>#linearCombination(double,double,double,double,double,double,double,double)</see>
      </javadoc>
      <method type="double" name="linearCombination" startLine="881" endLine="934">
        <declaration type="double" name="ca1" />
        <declaration type="double" name="a1High" />
        <declaration type="double" name="a1Low" />
        <declaration type="double" name="cb1" />
        <declaration type="double" name="b1High" />
        <declaration type="double" name="b1Low" />
        <declaration type="double" name="prod1High" />
        <declaration type="double" name="prod1Low" />
        <declaration type="double" name="ca2" />
        <declaration type="double" name="a2High" />
        <declaration type="double" name="a2Low" />
        <declaration type="double" name="cb2" />
        <declaration type="double" name="b2High" />
        <declaration type="double" name="b2Low" />
        <declaration type="double" name="prod2High" />
        <declaration type="double" name="prod2Low" />
        <declaration type="double" name="s12High" />
        <declaration type="double" name="s12Prime" />
        <declaration type="double" name="s12Low" />
        <declaration type="double" name="result" />
        <scope startLine="927" endLine="931">
          <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
          <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
        </scope>
        <comment>the code below is split in many additions/subtractions that may</comment>
        <comment>appear redundant. However, they should NOT be simplified, as they</comment>
        <comment>use IEEE754 floating point arithmetic rounding properties.</comment>
        <comment>as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1"</comment>
        <comment>The variable naming conventions are that xyzHigh contains the most significant</comment>
        <comment>bits of xyz and xyzLow contains its least significant bits. So theoretically</comment>
        <comment>xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot</comment>
        <comment>be represented in only one double precision number so we preserve two numbers</comment>
        <comment>to hold it as long as we can, combining the high and low order bits together</comment>
        <comment>only at the end, after cancellation may have occurred on high order bits</comment>
        <comment>split a1 and b1 as two 26 bits numbers</comment>
        <comment>accurate multiplication a1 * b1</comment>
        <comment>split a2 and b2 as two 26 bits numbers</comment>
        <comment>accurate multiplication a2 * b2</comment>
        <comment>accurate addition a1 * b1 + a2 * b2</comment>
        <comment>final rounding, s12 may have suffered many cancellations, we try</comment>
        <comment>to recover some bits from the extra words we have saved up to now</comment>
      </method>
      <javadoc>
        <text>* Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p></text>
        <param>a1 first factor of the first term</param>
        <param>b1 second factor of the first term</param>
        <param>a2 first factor of the second term</param>
        <param>b2 second factor of the second term</param>
        <param>a3 first factor of the third term</param>
        <param>b3 second factor of the third term</param>
        <return>a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub></return>
        <see>#linearCombination(double,double,double,double)</see>
        <see>#linearCombination(double,double,double,double,double,double,double,double)</see>
      </javadoc>
      <method type="double" name="linearCombination" startLine="961" endLine="1031">
        <declaration type="double" name="ca1" />
        <declaration type="double" name="a1High" />
        <declaration type="double" name="a1Low" />
        <declaration type="double" name="cb1" />
        <declaration type="double" name="b1High" />
        <declaration type="double" name="b1Low" />
        <declaration type="double" name="prod1High" />
        <declaration type="double" name="prod1Low" />
        <declaration type="double" name="ca2" />
        <declaration type="double" name="a2High" />
        <declaration type="double" name="a2Low" />
        <declaration type="double" name="cb2" />
        <declaration type="double" name="b2High" />
        <declaration type="double" name="b2Low" />
        <declaration type="double" name="prod2High" />
        <declaration type="double" name="prod2Low" />
        <declaration type="double" name="ca3" />
        <declaration type="double" name="a3High" />
        <declaration type="double" name="a3Low" />
        <declaration type="double" name="cb3" />
        <declaration type="double" name="b3High" />
        <declaration type="double" name="b3Low" />
        <declaration type="double" name="prod3High" />
        <declaration type="double" name="prod3Low" />
        <declaration type="double" name="s12High" />
        <declaration type="double" name="s12Prime" />
        <declaration type="double" name="s12Low" />
        <declaration type="double" name="s123High" />
        <declaration type="double" name="s123Prime" />
        <declaration type="double" name="s123Low" />
        <declaration type="double" name="result" />
        <scope startLine="1024" endLine="1028">
          <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
          <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
        </scope>
        <comment>the code below is split in many additions/subtractions that may</comment>
        <comment>appear redundant. However, they should NOT be simplified, as they</comment>
        <comment>do use IEEE754 floating point arithmetic rounding properties.</comment>
        <comment>as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1"</comment>
        <comment>The variables naming conventions are that xyzHigh contains the most significant</comment>
        <comment>bits of xyz and xyzLow contains its least significant bits. So theoretically</comment>
        <comment>xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot</comment>
        <comment>be represented in only one double precision number so we preserve two numbers</comment>
        <comment>to hold it as long as we can, combining the high and low order bits together</comment>
        <comment>only at the end, after cancellation may have occurred on high order bits</comment>
        <comment>split a1 and b1 as two 26 bits numbers</comment>
        <comment>accurate multiplication a1 * b1</comment>
        <comment>split a2 and b2 as two 26 bits numbers</comment>
        <comment>accurate multiplication a2 * b2</comment>
        <comment>split a3 and b3 as two 26 bits numbers</comment>
        <comment>accurate multiplication a3 * b3</comment>
        <comment>accurate addition a1 * b1 + a2 * b2</comment>
        <comment>accurate addition a1 * b1 + a2 * b2 + a3 * b3</comment>
        <comment>final rounding, s123 may have suffered many cancellations, we try</comment>
        <comment>to recover some bits from the extra words we have saved up to now</comment>
      </method>
      <javadoc>
        <text>* Compute a linear combination accurately.
 * <p>
 * This method computes a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub>
 * to high accuracy. It does so by using specific multiplication and
 * addition algorithms to preserve accuracy and reduce cancellation effects.
 * It is based on the 2005 paper <a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita,
 * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 * </p></text>
        <param>a1 first factor of the first term</param>
        <param>b1 second factor of the first term</param>
        <param>a2 first factor of the second term</param>
        <param>b2 second factor of the second term</param>
        <param>a3 first factor of the third term</param>
        <param>b3 second factor of the third term</param>
        <param>a4 first factor of the third term</param>
        <param>b4 second factor of the third term</param>
        <return>a<sub>1</sub>&times;b<sub>1</sub> +
 * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +
 * a<sub>4</sub>&times;b<sub>4</sub></return>
        <see>#linearCombination(double,double,double,double)</see>
        <see>#linearCombination(double,double,double,double,double,double)</see>
      </javadoc>
      <method type="double" name="linearCombination" startLine="1063" endLine="1150">
        <declaration type="double" name="ca1" />
        <declaration type="double" name="a1High" />
        <declaration type="double" name="a1Low" />
        <declaration type="double" name="cb1" />
        <declaration type="double" name="b1High" />
        <declaration type="double" name="b1Low" />
        <declaration type="double" name="prod1High" />
        <declaration type="double" name="prod1Low" />
        <declaration type="double" name="ca2" />
        <declaration type="double" name="a2High" />
        <declaration type="double" name="a2Low" />
        <declaration type="double" name="cb2" />
        <declaration type="double" name="b2High" />
        <declaration type="double" name="b2Low" />
        <declaration type="double" name="prod2High" />
        <declaration type="double" name="prod2Low" />
        <declaration type="double" name="ca3" />
        <declaration type="double" name="a3High" />
        <declaration type="double" name="a3Low" />
        <declaration type="double" name="cb3" />
        <declaration type="double" name="b3High" />
        <declaration type="double" name="b3Low" />
        <declaration type="double" name="prod3High" />
        <declaration type="double" name="prod3Low" />
        <declaration type="double" name="ca4" />
        <declaration type="double" name="a4High" />
        <declaration type="double" name="a4Low" />
        <declaration type="double" name="cb4" />
        <declaration type="double" name="b4High" />
        <declaration type="double" name="b4Low" />
        <declaration type="double" name="prod4High" />
        <declaration type="double" name="prod4Low" />
        <declaration type="double" name="s12High" />
        <declaration type="double" name="s12Prime" />
        <declaration type="double" name="s12Low" />
        <declaration type="double" name="s123High" />
        <declaration type="double" name="s123Prime" />
        <declaration type="double" name="s123Low" />
        <declaration type="double" name="s1234High" />
        <declaration type="double" name="s1234Prime" />
        <declaration type="double" name="s1234Low" />
        <declaration type="double" name="result" />
        <scope startLine="1143" endLine="1147">
          <comment>either we have split infinite numbers or some coefficients were NaNs,</comment>
          <comment>just rely on the naive implementation and let IEEE754 handle this</comment>
        </scope>
        <comment>the code below is split in many additions/subtractions that may</comment>
        <comment>appear redundant. However, they should NOT be simplified, as they</comment>
        <comment>do use IEEE754 floating point arithmetic rounding properties.</comment>
        <comment>as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1"</comment>
        <comment>The variables naming conventions are that xyzHigh contains the most significant</comment>
        <comment>bits of xyz and xyzLow contains its least significant bits. So theoretically</comment>
        <comment>xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot</comment>
        <comment>be represented in only one double precision number so we preserve two numbers</comment>
        <comment>to hold it as long as we can, combining the high and low order bits together</comment>
        <comment>only at the end, after cancellation may have occurred on high order bits</comment>
        <comment>split a1 and b1 as two 26 bits numbers</comment>
        <comment>accurate multiplication a1 * b1</comment>
        <comment>split a2 and b2 as two 26 bits numbers</comment>
        <comment>accurate multiplication a2 * b2</comment>
        <comment>split a3 and b3 as two 26 bits numbers</comment>
        <comment>accurate multiplication a3 * b3</comment>
        <comment>split a4 and b4 as two 26 bits numbers</comment>
        <comment>accurate multiplication a4 * b4</comment>
        <comment>accurate addition a1 * b1 + a2 * b2</comment>
        <comment>accurate addition a1 * b1 + a2 * b2 + a3 * b3</comment>
        <comment>accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4</comment>
        <comment>final rounding, s1234 may have suffered many cancellations, we try</comment>
        <comment>to recover some bits from the extra words we have saved up to now</comment>
      </method>
      <javadoc>
        <text>* Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by{@link Precision#equals(float,float)}.</text>
        <param>x first array</param>
        <param>y second array</param>
        <return>true if the values are both null or have same dimension
 * and equal elements.</return>
      </javadoc>
      <method type="boolean" name="equals" startLine="1162" endLine="1175">
        <scope startLine="1163" endLine="1165" />
        <scope startLine="1166" endLine="1168" />
        <scope startLine="1169" endLine="1173">
          <scope startLine="1170" endLine="1172" />
        </scope>
      </method>
      <javadoc>
        <text>* Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.</text>
        <param>x first array</param>
        <param>y second array</param>
        <return>true if the values are both null or have same dimension and
 * equal elements</return>
        <since>2.2</since>
      </javadoc>
      <method type="boolean" name="equalsIncludingNaN" startLine="1188" endLine="1201">
        <scope startLine="1189" endLine="1191" />
        <scope startLine="1192" endLine="1194" />
        <scope startLine="1195" endLine="1199">
          <scope startLine="1196" endLine="1198" />
        </scope>
      </method>
      <javadoc>
        <text>* Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by{@link Precision#equals(double,double)}.</text>
        <param>x First array.</param>
        <param>y Second array.</param>
        <return>{@code true} if the values are both {@code null} or have same
 * dimension and equal elements.</return>
      </javadoc>
      <method type="boolean" name="equals" startLine="1213" endLine="1226">
        <scope startLine="1214" endLine="1216" />
        <scope startLine="1217" endLine="1219" />
        <scope startLine="1220" endLine="1224">
          <scope startLine="1221" endLine="1223" />
        </scope>
      </method>
      <javadoc>
        <text>* Returns {@code true} iff both arguments are {@code null} or have same
 * dimensions and all their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.</text>
        <param>x First array.</param>
        <param>y Second array.</param>
        <return>{@code true} if the values are both {@code null} or have same
 * dimension and equal elements.</return>
        <since>2.2</since>
      </javadoc>
      <method type="boolean" name="equalsIncludingNaN" startLine="1239" endLine="1252">
        <scope startLine="1240" endLine="1242" />
        <scope startLine="1243" endLine="1245" />
        <scope startLine="1246" endLine="1250">
          <scope startLine="1247" endLine="1249" />
        </scope>
      </method>
      <javadoc>
        <text>* Normalizes an array to make it sum to a specified value.
 * Returns the result of the transformation <pre>
 * x |-> x * normalizedSum / sum
 * </pre>
 * applied to each non-NaN element x of the input array, where sum is the
 * sum of the non-NaN entries in the input array.</p>
 * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite
 * or NaN and ArithmeticException if the input array contains any infinite elements
 * or sums to 0.</p>
 * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p></text>
        <param>values Input array to be normalized</param>
        <param>normalizedSum Target sum for the normalized array</param>
        <return>the normalized array.</return>
        <throws>MathArithmeticException if the input array contains infinite
 * elements or sums to zero.</throws>
        <throws>MathIllegalArgumentException if the target sum is infinite or {@code NaN}.</throws>
        <since>2.1</since>
      </javadoc>
      <method type="double[]" name="normalizeArray" startLine="1277" endLine="1306">
        <scope startLine="1278" endLine="1280" />
        <scope startLine="1281" endLine="1283" />
        <declaration type="double" name="sum" />
        <declaration type="int" name="len" />
        <declaration type="double[]" name="out" />
        <scope startLine="1287" endLine="1294">
          <scope startLine="1288" endLine="1290" />
          <scope startLine="1291" endLine="1293" />
        </scope>
        <scope startLine="1295" endLine="1297" />
        <scope startLine="1298" endLine="1304">
          <scope startLine="1299" endLine="1301" />
          <scope startLine="1301" endLine="1303" />
        </scope>
      </method>
      <javadoc>
        <text>* Build an array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p></text>
        <param><T>
 *  the type of the field elements</param>
        <param>field field to which array elements belong</param>
        <param>length of the array</param>
        <return>a new array</return>
        <since>3.2</since>
      </javadoc>
      <method type="T[]" name="buildArray" startLine="1318" endLine="1323">
        <declaration type="T[][]" name="array" />
        <comment>OK because field must be correct class</comment>
      </method>
      <javadoc>
        <text>* Build a double dimension  array of elements.
 * <p>
 * Arrays are filled with field.getZero()
 * </p></text>
        <param><T>
 *  the type of the field elements</param>
        <param>field field to which array elements belong</param>
        <param>rows number of rows in the array</param>
        <param>columns number of columns (may be negative to build partial
 * arrays in the same way <code>new Field[rows][]</code> works)</param>
        <return>a new array</return>
        <since>3.2</since>
      </javadoc>
      <method type="T[][]" name="buildArray" startLine="1338" endLine="1353">
        <declaration type="T[][]" name="array" />
        <scope startLine="1340" endLine="1343">
          <declaration type="T[]" name="dummyRow" />
        </scope>
        <scope startLine="1343" endLine="1351">
          <scope startLine="1348" endLine="1350" />
        </scope>
      </method>
    </interface>
  </class>
</source>
