<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.interpolation">
  <import name="java.io.Serializable" />
  <import name="java.util.Arrays" />
  <import name="org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NoDataException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.NonMonotonicSequenceException" />
  <import name="org.apache.commons.math3.exception.NotFiniteNumberException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="LoessInterpolator" startLine="35">
    <implements name="UnivariateInterpolator" />
    <implements name="Serializable" />
    <javadoc>
      <text>* Implements the <a href="http://en.wikipedia.org/wiki/Local_regression">
 * Local Regression Algorithm</a> (also Loess, Lowess) for interpolation of
 * real univariate functions.
 * <p/>
 * For reference, see
 * <a href="http://www.math.tau.ac.il/~yekutiel/MA seminar/Cleveland 1979.pdf">
 * William S. Cleveland - Robust Locally Weighted Regression and Smoothing
 * Scatterplots</a>
 * <p/>
 * This class implements both the loess method and serves as an interpolation
 * adapter to it, allowing one to build a spline on the obtained loess fit.</text>
      <version>$Id: LoessInterpolator.java 1379904 2012-09-01 23:54:52Z erans $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Default value of the bandwidth parameter.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_BANDWIDTH" />
    <javadoc>
      <text>* Default value of the number of robustness iterations.</text>
    </javadoc>
    <declaration type="int" name="DEFAULT_ROBUSTNESS_ITERS" />
    <javadoc>
      <text>* Default value for accuracy.</text>
      <since>2.1</since>
    </javadoc>
    <declaration type="double" name="DEFAULT_ACCURACY" />
    <javadoc>
      <text>* serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* The bandwidth parameter: when computing the loess fit at
 * a particular point, this fraction of source points closest
 * to the current point is taken into account for computing
 * a least-squares regression.
 * <p/>
 * A sensible value is usually 0.25 to 0.5.</text>
    </javadoc>
    <declaration type="double" name="bandwidth" />
    <javadoc>
      <text>* The number of robustness iterations parameter: this many
 * robustness iterations are done.
 * <p/>
 * A sensible value is usually 0 (just the initial fit without any
 * robustness iterations) to 4.</text>
    </javadoc>
    <declaration type="int" name="robustnessIters" />
    <javadoc>
      <text>* If the median residual at a certain robustness iteration
 * is less than this amount, no more iterations are done.</text>
    </javadoc>
    <declaration type="double" name="accuracy" />
    <javadoc>
      <text>* Constructs a new {@link LoessInterpolator}with a bandwidth of {@link #DEFAULT_BANDWIDTH},{@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations
 * and an accuracy of {#link #DEFAULT_ACCURACY}.
 * See {@link #LoessInterpolator(double,int,double)} for an explanation of
 * the parameters.</text>
    </javadoc>
    <method type="constructor" name="LoessInterpolator" startLine="95" endLine="99" />
    <javadoc>
      <text>* Construct a new {@link LoessInterpolator}with given bandwidth and number of robustness iterations.
 * <p>
 * Calling this constructor is equivalent to calling {link {@link #LoessInterpolator(double,int,double) LoessInterpolator(bandwidth,
 * robustnessIters, LoessInterpolator.DEFAULT_ACCURACY)}</p></text>
      <param>bandwidth  when computing the loess fit at
 * a particular point, this fraction of source points closest
 * to the current point is taken into account for computing
 * a least-squares regression.</br>
 * A sensible value is usually 0.25 to 0.5, the default value is{@link #DEFAULT_BANDWIDTH}.</param>
      <param>robustnessIters This many robustness iterations are done.</br>
 * A sensible value is usually 0 (just the initial fit without any
 * robustness iterations) to 4, the default value is{@link #DEFAULT_ROBUSTNESS_ITERS}.</param>
      <see>#LoessInterpolator(double,int,double)</see>
    </javadoc>
    <method type="constructor" name="LoessInterpolator" startLine="123" endLine="125" />
    <javadoc>
      <text>* Construct a new {@link LoessInterpolator}with given bandwidth, number of robustness iterations and accuracy.</text>
      <param>bandwidth  when computing the loess fit at
 * a particular point, this fraction of source points closest
 * to the current point is taken into account for computing
 * a least-squares regression.</br>
 * A sensible value is usually 0.25 to 0.5, the default value is{@link #DEFAULT_BANDWIDTH}.</param>
      <param>robustnessIters This many robustness iterations are done.</br>
 * A sensible value is usually 0 (just the initial fit without any
 * robustness iterations) to 4, the default value is{@link #DEFAULT_ROBUSTNESS_ITERS}.</param>
      <param>accuracy If the median residual at a certain robustness iteration
 * is less than this amount, no more iterations are done.</param>
      <throws>OutOfRangeException if bandwidth does not lie in the interval [0,1].</throws>
      <throws>NotPositiveException if {@code robustnessIters} is negative.</throws>
      <see>#LoessInterpolator(double,int)</see>
      <since>2.1</since>
    </javadoc>
    <method type="constructor" name="LoessInterpolator" startLine="150" endLine="161">
      <scope startLine="152" endLine="154" />
      <scope startLine="156" endLine="158" />
    </method>
    <javadoc>
      <text>* Compute an interpolating function by performing a loess fit
 * on the data at the original abscissae and then building a cubic spline
 * with a{@link org.apache.commons.math3.analysis.interpolation.SplineInterpolator}on the resulting fit.</text>
      <param>xval the arguments for the interpolation points</param>
      <param>yval the values for the interpolation points</param>
      <return>A cubic spline built upon a loess fit to the data at the original abscissae</return>
      <throws>NonMonotonicSequenceException if {@code xval} not sorted in
 * strictly increasing order.</throws>
      <throws>DimensionMismatchException if {@code xval} and {@code yval} have
 * different sizes.</throws>
      <throws>NoDataException if {@code xval} or {@code yval} has zero size.</throws>
      <throws>NotFiniteNumberException if any of the arguments and values are
 * not finite real numbers.</throws>
      <throws>NumberIsTooSmallException if the bandwidth is too small to
 * accomodate the size of the input data (i.e. the bandwidth must be
 * larger than 2/n).</throws>
    </javadoc>
    <method type="PolynomialSplineFunction" name="interpolate" startLine="190" endLine="192" />
    <javadoc>
      <text>* Compute a weighted loess fit on the data at the original abscissae.</text>
      <param>xval Arguments for the interpolation points.</param>
      <param>yval Values for the interpolation points.</param>
      <param>weights point weights: coefficients by which the robustness weight
 * of a point is multiplied.</param>
      <return>the values of the loess fit at corresponding original abscissae.</return>
      <throws>NonMonotonicSequenceException if {@code xval} not sorted in
 * strictly increasing order.</throws>
      <throws>DimensionMismatchException if {@code xval} and {@code yval} have
 * different sizes.</throws>
      <throws>NoDataException if {@code xval} or {@code yval} has zero size.</throws>
      <throws>NotFiniteNumberException if any of the arguments and values are
 * not finite real numbers.</throws>
      <throws>NumberIsTooSmallException if the bandwidth is too small to
 * accomodate the size of the input data (i.e. the bandwidth must be
 * larger than 2/n).</throws>
      <since>2.1</since>
    </javadoc>
    <method type="double[]" name="smooth" startLine="220" endLine="363">
      <scope startLine="221" endLine="223" />
      <declaration type="int" name="n" />
      <scope startLine="227" endLine="229" />
      <scope startLine="237" endLine="239" />
      <scope startLine="241" endLine="243" />
      <declaration type="int" name="bandwidthInPoints" />
      <scope startLine="247" endLine="250" />
      <declaration type="double[]" name="res" />
      <declaration type="double[]" name="residuals" />
      <declaration type="double[]" name="sortedResiduals" />
      <declaration type="double[]" name="robustnessWeights" />
      <scope startLine="264" endLine="360">
        <declaration type="int[]" name="bandwidthInterval" />
        <scope startLine="267" endLine="330">
          <declaration type="double" name="x" />
          <scope startLine="272" endLine="274" />
          <declaration type="int" name="ileft" />
          <declaration type="int" name="iright" />
          <declaration type="int" name="edge" />
          <scope startLine="282" endLine="284" />
          <scope startLine="284" endLine="286" />
          <declaration type="double" name="sumWeights" />
          <declaration type="double" name="sumX" />
          <declaration type="double" name="sumXSquared" />
          <declaration type="double" name="sumY" />
          <declaration type="double" name="sumXY" />
          <declaration type="double" name="denom" />
          <scope startLine="301" endLine="312">
            <declaration type="double" name="xk" />
            <declaration type="double" name="yk" />
            <declaration type="double" name="dist" />
            <declaration type="double" name="w" />
            <declaration type="double" name="xkw" />
          </scope>
          <declaration type="double" name="meanX" />
          <declaration type="double" name="meanY" />
          <declaration type="double" name="meanXY" />
          <declaration type="double" name="meanXSquared" />
          <declaration type="double" name="beta" />
          <scope startLine="320" endLine="322" />
          <scope startLine="322" endLine="324" />
          <declaration type="double" name="alpha" />
        </scope>
        <scope startLine="334" endLine="336" />
        <declaration type="double" name="medianResidual" />
        <scope startLine="347" endLine="349" />
        <scope startLine="351" endLine="359">
          <declaration type="double" name="arg" />
          <scope startLine="353" endLine="355" />
          <scope startLine="355" endLine="358">
            <declaration type="double" name="w" />
          </scope>
        </scope>
        <comment>At each x, compute a local weighted linear regression</comment>
        <comment>Find out the interval of source points on which</comment>
        <comment>a regression is to be made.</comment>
        <comment>Compute the point of the bandwidth interval that is</comment>
        <comment>farthest from x</comment>
        <comment>Compute a least-squares linear fit weighted by</comment>
        <comment>the product of robustness weights and the tricube</comment>
        <comment>weight function.</comment>
        <comment>See http:en.wikipedia.org/wiki/Linear_regression</comment>
        <comment>(section "Univariate linear case")</comment>
        <comment>and http:en.wikipedia.org/wiki/Weighted_least_squares</comment>
        <comment>(section "Weighted least squares")</comment>
        <comment>No need to recompute the robustness weights at the last</comment>
        <comment>iteration, they won't be needed anymore</comment>
        <comment>Recompute the robustness weights.</comment>
        <comment>Find the median residual.</comment>
        <comment>An arraycopy and a sort are completely tractable here,</comment>
        <comment>because the preceding loop is a lot more expensive</comment>
      </scope>
      <comment>Do an initial fit and 'robustnessIters' robustness iterations.</comment>
      <comment>This is equivalent to doing 'robustnessIters+1' robustness iterations</comment>
      <comment>starting with all robustness weights set to 1.</comment>
    </method>
    <javadoc>
      <text>* Compute a loess fit on the data at the original abscissae.</text>
      <param>xval the arguments for the interpolation points</param>
      <param>yval the values for the interpolation points</param>
      <return>values of the loess fit at corresponding original abscissae</return>
      <throws>NonMonotonicSequenceException if {@code xval} not sorted in
 * strictly increasing order.</throws>
      <throws>DimensionMismatchException if {@code xval} and {@code yval} have
 * different sizes.</throws>
      <throws>NoDataException if {@code xval} or {@code yval} has zero size.</throws>
      <throws>NotFiniteNumberException if any of the arguments and values are
 * not finite real numbers.</throws>
      <throws>NumberIsTooSmallException if the bandwidth is too small to
 * accomodate the size of the input data (i.e. the bandwidth must be
 * larger than 2/n).</throws>
    </javadoc>
    <method type="double[]" name="smooth" startLine="387" endLine="396">
      <scope startLine="388" endLine="390" />
      <declaration type="double[]" name="unitWeights" />
    </method>
    <javadoc>
      <text>* Given an index interval into xval that embraces a certain number of
 * points closest to {@code xval[i-1]}, update the interval so that it
 * embraces the same number of points closest to {@code xval[i]},
 * ignoring zero weights.</text>
      <param>xval Arguments array.</param>
      <param>weights Weights array.</param>
      <param>i Index around which the new interval should be computed.</param>
      <param>bandwidthInterval a two-element array {left, right} such that:{@code (left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])}and{@code (right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])}.
 * The array will be updated.</param>
    </javadoc>
    <method type="void" name="updateBandwidthInterval" startLine="415" endLine="427">
      <declaration type="int" name="left" />
      <declaration type="int" name="right" />
      <declaration type="int" name="nextRight" />
      <scope startLine="422" endLine="426">
        <declaration type="int" name="nextLeft" />
      </scope>
      <comment>The right edge should be adjusted if the next point to the right</comment>
      <comment>is closer to xval[i] than the leftmost point of the current interval</comment>
    </method>
    <javadoc>
      <text>* Return the smallest index {@code j} such that{@code j > i && (j == weights.length || weights[j] != 0)}.</text>
      <param>weights Weights array.</param>
      <param>i Index from which to start search.</param>
      <return>the smallest compliant index.</return>
    </javadoc>
    <method type="int" name="nextNonzero" startLine="437" endLine="443">
      <declaration type="int" name="j" />
      <scope startLine="439" endLine="441" />
    </method>
    <javadoc>
      <text>* Compute the
 * <a href="http://en.wikipedia.org/wiki/Local_regression#Weight_function">tricube</a>
 * weight function</text>
      <param>x Argument.</param>
      <return><code>(1 - |x|<sup>3</sup>)<sup>3</sup></code> for |x| &lt; 1, 0 otherwise.</return>
    </javadoc>
    <method type="double" name="tricube" startLine="453" endLine="460">
      <declaration type="double" name="absX" />
      <scope startLine="455" endLine="457" />
      <declaration type="double" name="tmp" />
    </method>
    <javadoc>
      <text>* Check that all elements of an array are finite real numbers.</text>
      <param>values Values array.</param>
      <throws>org.apache.commons.math3.exception.NotFiniteNumberExceptionif one of the values is not a finite real number.</throws>
    </javadoc>
    <method type="void" name="checkAllFiniteReal" startLine="469" endLine="473">
      <scope startLine="470" endLine="472" />
    </method>
  </class>
</source>
