<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.scalar.noderiv">
  <import name="java.util.Comparator" />
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.MathUnsupportedOperationException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.GoalType" />
  <import name="org.apache.commons.math3.optim.ConvergenceChecker" />
  <import name="org.apache.commons.math3.optim.PointValuePair" />
  <import name="org.apache.commons.math3.optim.SimpleValueChecker" />
  <import name="org.apache.commons.math3.optim.OptimizationData" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer" />
  <class name="SimplexOptimizer" extends="MultivariateOptimizer" startLine="31">
    <javadoc>
      <text>* This class implements simplex-based direct search optimization.
 * <p>
 * Direct search methods only use objective function values, they do
 * not need derivatives and don't either try to compute approximation
 * of the derivatives. According to a 1996 paper by Margaret H. Wright
 * (<a href="http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz">Direct
 * Search Methods: Once Scorned, Now Respectable</a>), they are used
 * when either the computation of the derivative is impossible (noisy
 * functions, unpredictable discontinuities) or difficult (complexity,
 * computation cost). In the first cases, rather than an optimum, a
 * <em>not too bad</em> point is desired. In the latter cases, an
 * optimum is desired but cannot be reasonably found. In all cases
 * direct search methods can be useful.
 * </p>
 * <p>
 * Simplex-based direct search methods are based on comparison of
 * the objective function values at the vertices of a simplex (which is a
 * set of n+1 points in dimension n) that is updated by the algorithms
 * steps.
 * <p>
 * <p>
 * The simplex update procedure ({@link NelderMeadSimplex} or{@link MultiDirectionalSimplex})  must be passed to the{@code optimize} method.
 * </p>
 * <p>
 * Each call to {@code optimize} will re-use the start configuration of
 * the current simplex and move it such that its first vertex is at the
 * provided start point of the optimization.
 * If the {@code optimize} method is called to solve a different problem
 * and the number of parameters change, the simplex must be re-initialized
 * to one with the appropriate dimensions.
 * </p>
 * <p>
 * Convergence is checked by providing the <em>worst</em> points of
 * previous and current simplex to the convergence checker, not the best
 * ones.
 * </p>
 * <p>
 * This simplex optimizer implementation does not directly support constrained
 * optimization with simple bounds; so, for such optimizations, either a more
 * dedicated algorithm must be used like{@link CMAESOptimizer} or {@link BOBYQAOptimizer}, or the objective
 * function must be wrapped in an adapter like{@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionMappingAdapterMultivariateFunctionMappingAdapter} or{@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapterMultivariateFunctionPenaltyAdapter}.
 * <br/>
 * The call to {@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.
 * </p></text>
      <version>$Id: SimplexOptimizer.java 1458323 2013-03-19 14:51:30Z erans $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Simplex update rule.</text>
    </javadoc>
    <declaration type="AbstractSimplex" name="simplex" />
    <javadoc>
      <param>checker Convergence checker.</param>
    </javadoc>
    <method type="constructor" name="SimplexOptimizer" startLine="96" endLine="98" />
    <javadoc>
      <param>rel Relative threshold.</param>
      <param>abs Absolute threshold.</param>
    </javadoc>
    <method type="constructor" name="SimplexOptimizer" startLine="104" endLine="106" />
    <javadoc>
      <text>* {@inheritDoc}</text>
      <param>optData Optimization data. In addition to those documented in{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])MultivariateOptimizer}, this method will register the following data:
 * <ul>
 * <li>{@link AbstractSimplex}</li>
 * </ul></param>
      <return>{@inheritDoc}</return>
    </javadoc>
    <method type="PointValuePair" name="optimize" startLine="120" endLine="123">
      <comment>Set up base class and perform computation.</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="PointValuePair" name="doOptimize" startLine="127" endLine="177">
      <declaration type="MultivariateFunction[]" name="evalFunc" />
      <method type="double" name="value" startLine="134" endLine="136" />
      <declaration type="boolean" name="isMinim" />
      <declaration type="Comparator<PointValuePair>" name="comparator" />
      <method type="int" name="compare" startLine="143" endLine="147">
        <declaration type="double" name="v1" />
        <declaration type="double" name="v2" />
      </method>
      <declaration type="PointValuePair[]" name="previous" />
      <declaration type="int" name="iteration" />
      <declaration type="ConvergenceChecker<PointValuePair>" name="checker" />
      <scope startLine="157" endLine="176">
        <scope startLine="158" endLine="169">
          <declaration type="boolean" name="converged" />
          <scope startLine="160" endLine="164">
            <declaration type="PointValuePair" name="prev" />
          </scope>
          <scope startLine="165" endLine="168" />
        </scope>
        <comment>We have found an optimum.</comment>
        <comment>We still need to search.</comment>
      </scope>
      <comment>Indirect call to "computeObjectiveValue" in order to update the</comment>
      <comment>evaluations counter.</comment>
      <comment>Initialize search.</comment>
    </method>
    <javadoc>
      <text>* Scans the list of (required and optional) optimization data that
 * characterize the problem.</text>
      <param>optData Optimization data.
 * The following data will be looked for:
 * <ul>
 * <li>{@link AbstractSimplex}</li>
 * </ul></param>
    </javadoc>
    <method type="void" name="parseOptimizationData" startLine="190" endLine="204">
      <scope startLine="196" endLine="203">
        <scope startLine="197" endLine="202" />
        <comment>If more data must be parsed, this statement _must_ be</comment>
        <comment>changed to "continue".</comment>
      </scope>
      <comment>Allow base class to register its own data.</comment>
      <comment>The existing values (as set by the previous call) are reused if</comment>
      <comment>not provided in the argument list.</comment>
    </method>
    <javadoc>
      <throws>MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.</throws>
      <throws>NullArgumentException if no initial simplex was passed to the{@link #optimize(OptimizationData[]) optimize} method.</throws>
    </javadoc>
    <method type="void" name="checkParameters" startLine="212" endLine="220">
      <scope startLine="213" endLine="215" />
      <scope startLine="217" endLine="219" />
    </method>
  </class>
</source>
