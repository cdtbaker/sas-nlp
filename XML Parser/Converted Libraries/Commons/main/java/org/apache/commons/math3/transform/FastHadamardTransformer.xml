<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.transform">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.analysis.FunctionUtils" />
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.ArithmeticUtils" />
  <class name="FastHadamardTransformer" startLine="27">
    <implements name="RealTransformer" />
    <implements name="Serializable" />
    <javadoc>
      <text>* Implements the <a href="http://www.archive.chipcenter.com/dsp/DSP000517F1.html">Fast Hadamard Transform</a> (FHT).
 * Transformation of an input vector x to the output vector y.
 * <p>
 * In addition to transformation of real vectors, the Hadamard transform can
 * transform integer vectors into integer vectors. However, this integer transform
 * cannot be inverted directly. Due to a scaling factor it may lead to rational results.
 * As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational
 * vector (1/2, -1/2, 0, 0).</text>
      <version>$Id: FastHadamardTransformer.java 1385310 2012-09-16 16:32:10Z tn $</version>
      <since>2.0</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* {@inheritDoc}</text>
      <throws>MathIllegalArgumentException if the length of the data array is
 * not a power of two</throws>
    </javadoc>
    <method type="double[]" name="transform" startLine="51" endLine="56">
      <scope startLine="52" endLine="54" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
      <throws>org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif the lower bound is greater than, or equal to the upper bound</throws>
      <throws>org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points is negative</throws>
      <throws>MathIllegalArgumentException if the number of sample points is not a power of two</throws>
    </javadoc>
    <method type="double[]" name="transform" startLine="69" endLine="72" />
    <javadoc>
      <text>* Returns the forward transform of the specified integer data set.The
 * integer transform cannot be inverted directly, due to a scaling factor
 * which may lead to double results.</text>
      <param>f the integer data array to be transformed (signal)</param>
      <return>the integer transformed array (spectrum)</return>
      <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
    </javadoc>
    <method type="int[]" name="transform" startLine="83" endLine="85" />
    <javadoc>
      <text>* The FHT (Fast Hadamard Transformation) which uses only subtraction and
 * addition. Requires {@code N * log2(N) = n * 2^n} additions.
 * <h3>Short Table of manual calculation for N=8</h3>
 * <ol>
 * <li><b>x</b> is the input vector to be transformed,</li>
 * <li><b>y</b> is the output vector (Fast Hadamard transform of <b>x</b>),</li>
 * <li>a and b are helper rows.</li>
 * </ol>
 * <table align="center" border="1" cellpadding="3">
 * <tbody align="center">
 * <tr>
 * <th>x</th>
 * <th>a</th>
 * <th>b</th>
 * <th>y</th>
 * </tr>
 * <tr>
 * <th>x<sub>0</sub></th>
 * <td>a<sub>0</sub> = x<sub>0</sub> + x<sub>1</sub></td>
 * <td>b<sub>0</sub> = a<sub>0</sub> + a<sub>1</sub></td>
 * <td>y<sub>0</sub> = b<sub>0</sub >+ b<sub>1</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>1</sub></th>
 * <td>a<sub>1</sub> = x<sub>2</sub> + x<sub>3</sub></td>
 * <td>b<sub>0</sub> = a<sub>2</sub> + a<sub>3</sub></td>
 * <td>y<sub>0</sub> = b<sub>2</sub> + b<sub>3</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>2</sub></th>
 * <td>a<sub>2</sub> = x<sub>4</sub> + x<sub>5</sub></td>
 * <td>b<sub>0</sub> = a<sub>4</sub> + a<sub>5</sub></td>
 * <td>y<sub>0</sub> = b<sub>4</sub> + b<sub>5</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>3</sub></th>
 * <td>a<sub>3</sub> = x<sub>6</sub> + x<sub>7</sub></td>
 * <td>b<sub>0</sub> = a<sub>6</sub> + a<sub>7</sub></td>
 * <td>y<sub>0</sub> = b<sub>6</sub> + b<sub>7</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>4</sub></th>
 * <td>a<sub>0</sub> = x<sub>0</sub> - x<sub>1</sub></td>
 * <td>b<sub>0</sub> = a<sub>0</sub> - a<sub>1</sub></td>
 * <td>y<sub>0</sub> = b<sub>0</sub> - b<sub>1</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>5</sub></th>
 * <td>a<sub>1</sub> = x<sub>2</sub> - x<sub>3</sub></td>
 * <td>b<sub>0</sub> = a<sub>2</sub> - a<sub>3</sub></td>
 * <td>y<sub>0</sub> = b<sub>2</sub> - b<sub>3</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>6</sub></th>
 * <td>a<sub>2</sub> = x<sub>4</sub> - x<sub>5</sub></td>
 * <td>b<sub>0</sub> = a<sub>4</sub> - a<sub>5</sub></td>
 * <td>y<sub>0</sub> = b<sub>4</sub> - b<sub>5</sub></td>
 * </tr>
 * <tr>
 * <th>x<sub>7</sub></th>
 * <td>a<sub>3</sub> = x<sub>6</sub> - x<sub>7</sub></td>
 * <td>b<sub>0</sub> = a<sub>6</sub> - a<sub>7</sub></td>
 * <td>y<sub>0</sub> = b<sub>6</sub> - b<sub>7</sub></td>
 * </tr>
 * </tbody>
 * </table>
 * <h3>How it works</h3>
 * <ol>
 * <li>Construct a matrix with {@code N} rows and {@code n + 1} columns,{@code hadm[n+1][N]}.<br/>
 * <em>(If I use [x][y] it always means [row-offset][column-offset] of a
 * Matrix with n rows and m columns. Its entries go from M[0][0]
 * to M[n][N])</em></li>
 * <li>Place the input vector {@code x[N]} in the first column of the
 * matrix {@code hadm}.</li>
 * <li>The entries of the submatrix {@code D_top} are calculated as follows
 * <ul>
 * <li>{@code D_top} goes from entry {@code [0][1]} to{@code [N / 2 - 1][n + 1]},</li>
 * <li>the columns of {@code D_top} are the pairwise mutually
 * exclusive sums of the previous column.</li>
 * </ul>
 * </li>
 * <li>The entries of the submatrix {@code D_bottom} are calculated as
 * follows
 * <ul>
 * <li>{@code D_bottom} goes from entry {@code [N / 2][1]} to{@code [N][n + 1]},</li>
 * <li>the columns of {@code D_bottom} are the pairwise differences
 * of the previous column.</li>
 * </ul>
 * </li>
 * <li>The consputation of {@code D_top} and {@code D_bottom} are best
 * understood with the above example (for {@code N = 8}).
 * <li>The output vector {@code y} is now in the last column of{@code hadm}.</li>
 * <li><em>Algorithm from <a href="http://www.archive.chipcenter.com/dsp/DSP000517F1.html">chipcenter</a>.</em></li>
 * </ol>
 * <h3>Visually</h3>
 * <table border="1" align="center" cellpadding="3">
 * <tbody align="center">
 * <tr>
 * <td></td><th>0</th><th>1</th><th>2</th><th>3</th>
 * <th>&hellip;</th>
 * <th>n + 1</th>
 * </tr>
 * <tr>
 * <th>0</th>
 * <td>x<sub>0</sub></td>
 * <td colspan="5" rowspan="5" align="center" valign="middle">
 * &uarr;<br/>
 * &larr; D<sub>top</sub> &rarr;<br/>
 * &darr;
 * </td>
 * </tr>
 * <tr><th>1</th><td>x<sub>1</sub></td></tr>
 * <tr><th>2</th><td>x<sub>2</sub></td></tr>
 * <tr><th>&hellip;</th><td>&hellip;</td></tr>
 * <tr><th>N / 2 - 1</th><td>x<sub>N/2-1</sub></td></tr>
 * <tr>
 * <th>N / 2</th>
 * <td>x<sub>N/2</sub></td>
 * <td colspan="5" rowspan="5" align="center" valign="middle">
 * &uarr;<br/>
 * &larr; D<sub>bottom</sub> &rarr;<br/>
 * &darr;
 * </td>
 * </tr>
 * <tr><th>N / 2 + 1</th><td>x<sub>N/2+1</sub></td></tr>
 * <tr><th>N / 2 + 2</th><td>x<sub>N/2+2</sub></td></tr>
 * <tr><th>&hellip;</th><td>&hellip;</td></tr>
 * <tr><th>N</th><td>x<sub>N</sub></td></tr>
 * </tbody>
 * </table></text>
      <param>x the real data array to be transformed</param>
      <return>the real transformed array, {@code y}</return>
      <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
    </javadoc>
    <method type="double[]" name="fht" startLine="229" endLine="270">
      <declaration type="int" name="n" />
      <declaration type="int" name="halfN" />
      <scope startLine="234" endLine="238" />
      <declaration type="double[]" name="yPrevious" />
      <declaration type="double[]" name="yCurrent" />
      <scope startLine="248" endLine="266">
        <declaration type="double[]" name="yTmp" />
        <scope startLine="256" endLine="260">
          <declaration type="int" name="twoI" />
        </scope>
        <scope startLine="261" endLine="265">
          <declaration type="int" name="twoI" />
        </scope>
        <comment>switch columns</comment>
        <comment>iterate from top to bottom (row)</comment>
        <comment>Dtop: the top part works with addition</comment>
        <comment>Dbottom: the bottom part works with subtraction</comment>
      </scope>
      <comment>Instead of creating a matrix with p+1 columns and n rows, we use two
 one dimension arrays which we are used in an alternating way.</comment>
      <comment>iterate from left to right (column)</comment>
    </method>
    <javadoc>
      <text>* Returns the forward transform of the specified integer data set. The FHT
 * (Fast Hadamard Transform) uses only subtraction and addition.</text>
      <param>x the integer data array to be transformed</param>
      <return>the integer transformed array, {@code y}</return>
      <throws>MathIllegalArgumentException if the length of the data array is not a power of two</throws>
    </javadoc>
    <method type="int[]" name="fht" startLine="280" endLine="322">
      <declaration type="int" name="n" />
      <declaration type="int" name="halfN" />
      <scope startLine="285" endLine="289" />
      <declaration type="int[]" name="yPrevious" />
      <declaration type="int[]" name="yCurrent" />
      <scope startLine="299" endLine="317">
        <declaration type="int[]" name="yTmp" />
        <scope startLine="307" endLine="311">
          <declaration type="int" name="twoI" />
        </scope>
        <scope startLine="312" endLine="316">
          <declaration type="int" name="twoI" />
        </scope>
        <comment>switch columns</comment>
        <comment>iterate from top to bottom (row)</comment>
        <comment>Dtop: the top part works with addition</comment>
        <comment>Dbottom: the bottom part works with subtraction</comment>
      </scope>
      <comment>Instead of creating a matrix with p+1 columns and n rows, we use two
 one dimension arrays which we are used in an alternating way.</comment>
      <comment>iterate from left to right (column)</comment>
      <comment>return the last computed output vector y</comment>
    </method>
  </class>
</source>
