<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.integration.gauss">
  <import name="java.math.BigDecimal" />
  <import name="java.math.MathContext" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.util.Pair" />
  <class name="LegendreHighPrecisionRuleFactory" extends="BaseRuleFactory<BigDecimal>" startLine="25">
    <javadoc>
      <text>* Factory that creates Gauss-type quadrature rule using Legendre polynomials.
 * In this implementation, the lower and upper bounds of the natural interval
 * of integration are -1 and 1, respectively.
 * The Legendre polynomials are evaluated using the recurrence relation
 * presented in <a href="http://en.wikipedia.org/wiki/Abramowitz_and_Stegun"
 * Abramowitz and Stegun, 1964</a>.</text>
      <since>3.1</since>
      <version>$Id: LegendreHighPrecisionRuleFactory.java 1455194 2013-03-11 15:45:54Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* Settings for enhanced precision computations.</text>
    </javadoc>
    <declaration type="MathContext" name="mContext" />
    <javadoc>
      <text>* The number {@code 2}.</text>
    </javadoc>
    <declaration type="BigDecimal" name="two" />
    <javadoc>
      <text>* The number {@code -1}.</text>
    </javadoc>
    <declaration type="BigDecimal" name="minusOne" />
    <javadoc>
      <text>* The number {@code 0.5}.</text>
    </javadoc>
    <declaration type="BigDecimal" name="oneHalf" />
    <javadoc>
      <text>* Default precision is {@link MathContext#DECIMAL128 DECIMAL128}.</text>
    </javadoc>
    <method type="constructor" name="LegendreHighPrecisionRuleFactory" startLine="49" endLine="51" />
    <javadoc>
      <param>mContext Precision setting for computing the quadrature rules.</param>
    </javadoc>
    <method type="constructor" name="LegendreHighPrecisionRuleFactory" startLine="56" endLine="61" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="Pair<BigDecimal[],BigDecimal[]>" name="computeRule" startLine="66" endLine="215">
      <scope startLine="68" endLine="72">
        <comment>Break recursion.</comment>
      </scope>
      <declaration type="BigDecimal[]" name="previousPoints" />
      <declaration type="BigDecimal[]" name="points" />
      <declaration type="BigDecimal[]" name="weights" />
      <declaration type="int" name="iMax" />
      <scope startLine="85" endLine="187">
        <declaration type="BigDecimal" name="a" />
        <declaration type="BigDecimal" name="b" />
        <declaration type="BigDecimal" name="pma" />
        <declaration type="BigDecimal" name="pa" />
        <declaration type="BigDecimal" name="pmb" />
        <declaration type="BigDecimal" name="pb" />
        <scope startLine="98" endLine="127">
          <declaration type="BigDecimal" name="b_two_j_p_1" />
          <declaration type="BigDecimal" name="b_j" />
          <declaration type="BigDecimal" name="b_j_p_1" />
          <declaration type="BigDecimal" name="tmp1" />
          <declaration type="BigDecimal" name="tmp2" />
          <declaration type="BigDecimal" name="ppa" />
          <declaration type="BigDecimal" name="ppb" />
        </scope>
        <declaration type="BigDecimal" name="c" />
        <declaration type="BigDecimal" name="pmc" />
        <declaration type="BigDecimal" name="pc" />
        <declaration type="boolean" name="done" />
        <scope startLine="136" endLine="171">
          <declaration type="BigDecimal" name="tmp1" />
          <declaration type="BigDecimal" name="tmp2" />
          <scope startLine="142" endLine="157">
            <declaration type="BigDecimal" name="b_two_j_p_1" />
            <declaration type="BigDecimal" name="b_j" />
            <declaration type="BigDecimal" name="b_j_p_1" />
            <declaration type="BigDecimal" name="ppc" />
          </scope>
          <scope startLine="159" endLine="170">
            <scope startLine="160" endLine="164" />
            <scope startLine="164" endLine="168" />
          </scope>
        </scope>
        <declaration type="BigDecimal" name="nP" />
        <declaration type="BigDecimal" name="tmp1" />
        <declaration type="BigDecimal" name="tmp2" />
        <declaration type="int" name="idx" />
        <comment>Lower-bound of the interval.</comment>
        <comment>Upper-bound of the interval.</comment>
        <comment>P[j-1](a)</comment>
        <comment>P[j](a)</comment>
        <comment>P[j-1](b)</comment>
        <comment>P[j](b)</comment>
        <comment>Compute P[j+1](a)</comment>
        <comment>ppa = ((2 * j + 1) * a * pa - j * pma) / (j + 1);</comment>
        <comment>P[j+1](a)</comment>
        <comment>Compute P[j+1](b)</comment>
        <comment>ppb = ((2 * j + 1) * b * pb - j * pmb) / (j + 1);</comment>
        <comment>P[j+1](b)</comment>
        <comment>Now pa = P[n+1](a), and pma = P[n](a). Same holds for b.</comment>
        <comment>Middle of the interval.</comment>
        <comment>P[j-1](c)</comment>
        <comment>P[j](c)</comment>
        <comment>Compute P[j+1](c)</comment>
        <comment>P[j+1](c)</comment>
        <comment>Now pc = P[n+1](c) and pmc = P[n](c).</comment>
      </scope>
      <scope startLine="192" endLine="212">
        <declaration type="BigDecimal" name="pmc" />
        <scope startLine="194" endLine="202">
          <declaration type="BigDecimal" name="b_j" />
          <declaration type="BigDecimal" name="b_j_p_1" />
        </scope>
        <declaration type="BigDecimal" name="nP" />
        <declaration type="BigDecimal" name="tmp1" />
        <declaration type="BigDecimal" name="tmp2" />
        <comment>pmc = -j * pmc / (j + 1);</comment>
        <comment>2 / pow(numberOfPoints * pmc, 2);</comment>
      </scope>
      <comment>Get previous rule.</comment>
      <comment>If it has not been computed yet it will trigger a recursive call</comment>
      <comment>to this method.</comment>
      <comment>Compute next rule.</comment>
      <comment>Find i-th root of P[n+1] by bracketing.</comment>
      <comment>If "numberOfPoints" is odd, 0 is a root.</comment>
      <comment>Note: as written, the test for oddness will work for negative</comment>
      <comment>integers too (although it is not necessary here), preventing</comment>
      <comment>a FindBugs warning.</comment>
    </method>
  </class>
</source>
