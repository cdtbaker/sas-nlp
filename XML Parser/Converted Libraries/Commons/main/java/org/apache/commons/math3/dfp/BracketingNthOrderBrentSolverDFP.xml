<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.dfp">
  <import name="org.apache.commons.math3.analysis.solvers.AllowedSolution" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.util.Incrementor" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="BracketingNthOrderBrentSolverDFP" startLine="28">
    <javadoc>
      <text>* This class implements a modification of the <a
 * href="http://mathworld.wolfram.com/BrentsMethod.html"> Brent algorithm</a>.
 * <p>
 * The changes with respect to the original Brent algorithm are:
 * <ul>
 * <li>the returned value is chosen in the current interval according
 * to user specified {@link AllowedSolution},</li>
 * <li>the maximal order for the invert polynomial root search is
 * user-specified instead of being invert quadratic only</li>
 * </ul>
 * </p>
 * The given interval must bracket the root.</text>
      <version>$Id: BracketingNthOrderBrentSolverDFP.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* Maximal aging triggering an attempt to balance the bracketing interval.</text>
    </javadoc>
    <declaration type="int" name="MAXIMAL_AGING" />
    <javadoc>
      <text>* Maximal order.</text>
    </javadoc>
    <declaration type="int" name="maximalOrder" />
    <javadoc>
      <text>* Function value accuracy.</text>
    </javadoc>
    <declaration type="Dfp" name="functionValueAccuracy" />
    <javadoc>
      <text>* Absolute accuracy.</text>
    </javadoc>
    <declaration type="Dfp" name="absoluteAccuracy" />
    <javadoc>
      <text>* Relative accuracy.</text>
    </javadoc>
    <declaration type="Dfp" name="relativeAccuracy" />
    <javadoc>
      <text>* Evaluations counter.</text>
    </javadoc>
    <declaration type="Incrementor" name="evaluations" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>relativeAccuracy Relative accuracy.</param>
      <param>absoluteAccuracy Absolute accuracy.</param>
      <param>functionValueAccuracy Function value accuracy.</param>
      <param>maximalOrder maximal order.</param>
      <exception>NumberIsTooSmallException if maximal order is lower than 2</exception>
    </javadoc>
    <method type="constructor" name="BracketingNthOrderBrentSolverDFP" startLine="77" endLine="85">
      <scope startLine="78" endLine="80" />
    </method>
    <javadoc>
      <text>* Get the maximal order.</text>
      <return>maximal order</return>
    </javadoc>
    <method type="int" name="getMaximalOrder" startLine="90" endLine="92" />
    <javadoc>
      <text>* Get the maximal number of function evaluations.</text>
      <return>the maximal number of function evaluations.</return>
    </javadoc>
    <method type="int" name="getMaxEvaluations" startLine="99" endLine="101" />
    <javadoc>
      <text>* Get the number of evaluations of the objective function.
 * The number of evaluations corresponds to the last call to the{@code optimize} method. It is 0 if the method has not been
 * called yet.</text>
      <return>the number of evaluations of the objective function.</return>
    </javadoc>
    <method type="int" name="getEvaluations" startLine="111" endLine="113" />
    <javadoc>
      <text>* Get the absolute accuracy.</text>
      <return>absolute accuracy</return>
    </javadoc>
    <method type="Dfp" name="getAbsoluteAccuracy" startLine="119" endLine="121" />
    <javadoc>
      <text>* Get the relative accuracy.</text>
      <return>relative accuracy</return>
    </javadoc>
    <method type="Dfp" name="getRelativeAccuracy" startLine="127" endLine="129" />
    <javadoc>
      <text>* Get the function accuracy.</text>
      <return>function accuracy</return>
    </javadoc>
    <method type="Dfp" name="getFunctionValueAccuracy" startLine="135" endLine="137" />
    <javadoc>
      <text>* Solve for a zero in the given interval.
 * A solver may require that the interval brackets a single zero root.
 * Solvers that do require bracketing should be able to handle the case
 * where one of the endpoints is itself a root.</text>
      <param>maxEval Maximum number of evaluations.</param>
      <param>f Function to solve.</param>
      <param>min Lower bound for the interval.</param>
      <param>max Upper bound for the interval.</param>
      <param>allowedSolution The kind of solutions that the root-finding algorithm may
 * accept as solutions.</param>
      <return>a value where the function is zero.</return>
      <exception>NullArgumentException if f is null.</exception>
      <exception>NoBracketingException if root cannot be bracketed</exception>
    </javadoc>
    <method type="Dfp" name="solve" startLine="157" endLine="159" />
    <javadoc>
      <text>* Solve for a zero in the given interval, start at {@code startValue}.
 * A solver may require that the interval brackets a single zero root.
 * Solvers that do require bracketing should be able to handle the case
 * where one of the endpoints is itself a root.</text>
      <param>maxEval Maximum number of evaluations.</param>
      <param>f Function to solve.</param>
      <param>min Lower bound for the interval.</param>
      <param>max Upper bound for the interval.</param>
      <param>startValue Start value to use.</param>
      <param>allowedSolution The kind of solutions that the root-finding algorithm may
 * accept as solutions.</param>
      <return>a value where the function is zero.</return>
      <exception>NullArgumentException if f is null.</exception>
      <exception>NoBracketingException if root cannot be bracketed</exception>
    </javadoc>
    <method type="Dfp" name="solve" startLine="181" endLine="400">
      <declaration type="Dfp" name="zero" />
      <declaration type="Dfp" name="nan" />
      <declaration type="Dfp[]" name="x" />
      <declaration type="Dfp[]" name="y" />
      <scope startLine="202" endLine="205">
        <comment>return the initial guess if it is a perfect root.</comment>
      </scope>
      <scope startLine="210" endLine="213">
        <comment>return the first endpoint if it is a perfect root.</comment>
      </scope>
      <declaration type="int" name="nbPoints" />
      <declaration type="int" name="signChangeIndex" />
      <scope startLine="217" endLine="223">
        <comment>reduce interval if it brackets the root</comment>
      </scope>
      <scope startLine="223" endLine="242">
        <scope startLine="228" endLine="231" />
        <scope startLine="233" endLine="237" />
        <scope startLine="237" endLine="240" />
        <comment>evaluate second endpoint</comment>
        <comment>return the second endpoint if it is a perfect root.</comment>
        <comment>use all computed point as a start sampling array for solving</comment>
      </scope>
      <declaration type="Dfp[]" name="tmpX" />
      <declaration type="Dfp" name="xA" />
      <declaration type="Dfp" name="yA" />
      <declaration type="Dfp" name="absXA" />
      <declaration type="Dfp" name="absYA" />
      <declaration type="int" name="agingA" />
      <declaration type="Dfp" name="xB" />
      <declaration type="Dfp" name="yB" />
      <declaration type="Dfp" name="absXB" />
      <declaration type="Dfp" name="absYB" />
      <declaration type="int" name="agingB" />
      <scope startLine="260" endLine="398">
        <declaration type="Dfp" name="maxX" />
        <declaration type="Dfp" name="maxY" />
        <declaration type="Dfp" name="xTol" />
        <scope startLine="267" endLine="283" />
        <declaration type="Dfp" name="targetY" />
        <scope startLine="287" endLine="290" />
        <scope startLine="290" endLine="293" />
        <scope startLine="293" endLine="296" />
        <declaration type="Dfp" name="nextX" />
        <declaration type="int" name="start" />
        <declaration type="int" name="end" />
        <scope startLine="302" endLine="327">
          <scope startLine="308" endLine="325">
            <scope startLine="314" endLine="317" />
            <scope startLine="317" endLine="320" />
          </scope>
        </scope>
        <scope startLine="329" endLine="334" />
        <declaration type="Dfp" name="nextY" />
        <scope startLine="339" endLine="343" />
        <scope startLine="345" endLine="354" />
        <scope startLine="354" endLine="367">
          <scope startLine="360" endLine="365" />
        </scope>
        <scope startLine="378" endLine="385" />
        <scope startLine="385" endLine="396" />
        <comment>check convergence of bracketing interval</comment>
        <comment>this should never happen</comment>
        <comment>target for the next evaluation point</comment>
        <comment>we keep updating the high bracket, try to compensate this</comment>
        <comment>we keep updating the low bracket, try to compensate this</comment>
        <comment>bracketing is balanced, try to find the root itself</comment>
        <comment>make a few attempts to guess a root,</comment>
        <comment>guess a value for current target, using inverse polynomial interpolation</comment>
        <comment>the guessed root is not strictly inside of the tightest bracketing interval</comment>
        <comment>the guessed root is either not strictly inside the interval or it</comment>
        <comment>is a NaN (which occurs when some sampling points share the same y)</comment>
        <comment>we try again with a lower interpolation order</comment>
        <comment>we have more points before the sign change, drop the lowest point</comment>
        <comment>we have more points after sign change, drop the highest point</comment>
        <comment>we need to do one more attempt</comment>
        <comment>fall back to bisection</comment>
        <comment>evaluate the function at the guessed root</comment>
        <comment>we have found an exact root, since it is not an approximation</comment>
        <comment>we don't need to bother about the allowed solutions setting</comment>
        <comment>we have been forced to ignore some points to keep bracketing,</comment>
        <comment>they are probably too far from the root, drop them from now on</comment>
        <comment>we have to drop one point in order to insert the new one</comment>
        <comment>keep the tightest bracketing interval as centered as possible</comment>
        <comment>we drop the lowest point, we have to shift the arrays and the index</comment>
        <comment>insert the last computed point</comment>
        <comment>(by construction, we know it lies inside the tightest bracketing interval)</comment>
        <comment>update the bracketing interval</comment>
        <comment>the sign change occurs before the inserted point</comment>
        <comment>the sign change occurs after the inserted point</comment>
        <comment>update the sign change index</comment>
      </scope>
      <comment>Checks.</comment>
      <comment>Reset.</comment>
      <comment>prepare arrays with the first points</comment>
      <comment>evaluate initial guess</comment>
      <comment>evaluate first  endpoint</comment>
      <comment>prepare a work array for inverse polynomial interpolation</comment>
      <comment>current tightest bracketing of the root</comment>
      <comment>search loop</comment>
    </method>
    <javadoc>
      <text>* Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.
 * <p>
 * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
 * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),
 * Q(y<sub>i</sub>) = x<sub>i</sub>.
 * </p></text>
      <param>targetY target value for y</param>
      <param>x reference points abscissas for interpolation,
 * note that this array <em>is</em> modified during computation</param>
      <param>y reference points ordinates for interpolation</param>
      <param>start start index of the points to consider (inclusive)</param>
      <param>end end index of the points to consider (exclusive)</param>
      <return>guessed root (will be a NaN if two points share the same y)</return>
    </javadoc>
    <method type="Dfp" name="guessX" startLine="417" endLine="435">
      <scope startLine="420" endLine="425">
        <declaration type="int" name="delta" />
        <scope startLine="422" endLine="424" />
      </scope>
      <declaration type="Dfp" name="x0" />
      <scope startLine="429" endLine="431" />
      <comment>compute Q Newton coefficients by divided differences</comment>
      <comment>evaluate Q(targetY)</comment>
    </method>
  </class>
</source>
