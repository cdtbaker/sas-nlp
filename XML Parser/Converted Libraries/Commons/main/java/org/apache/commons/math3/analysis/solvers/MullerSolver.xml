<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.solvers">
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.TooManyEvaluationsException" />
  <class name="MullerSolver" extends="AbstractUnivariateSolver" startLine="24">
    <javadoc>
      <text>* This class implements the <a href="http://mathworld.wolfram.com/MullersMethod.html">
 * Muller's Method</a> for root finding of real univariate functions. For
 * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,
 * chapter 3.
 * <p>
 * Muller's method applies to both real and complex functions, but here we
 * restrict ourselves to real functions.
 * This class differs from {@link MullerSolver} in the way it avoids complex
 * operations.</p>
 * Muller's original method would have function evaluation at complex point.
 * Since our f(x) is real, we have to find ways to avoid that. Bracketing
 * condition is one way to go: by requiring bracketing in every iteration,
 * the newly computed approximation is guaranteed to be real.</p>
 * <p>
 * Normally Muller's method converges quadratically in the vicinity of a
 * zero, however it may be very slow in regions far away from zeros. For
 * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use
 * bisection as a safety backup if it performs very poorly.</p>
 * <p>
 * The formulas here use divided differences directly.</p></text>
      <version>$Id: MullerSolver.java 1391927 2012-09-30 00:03:30Z erans $</version>
      <since>1.2</since>
      <see>MullerSolver2</see>
    </javadoc>
    <javadoc>
      <text>* Default absolute accuracy.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_ABSOLUTE_ACCURACY" />
    <javadoc>
      <text>* Construct a solver with default accuracy (1e-6).</text>
    </javadoc>
    <method type="constructor" name="MullerSolver" startLine="58" endLine="60" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>absoluteAccuracy Absolute accuracy.</param>
    </javadoc>
    <method type="constructor" name="MullerSolver" startLine="66" endLine="68" />
    <javadoc>
      <text>* Construct a solver.</text>
      <param>relativeAccuracy Relative accuracy.</param>
      <param>absoluteAccuracy Absolute accuracy.</param>
    </javadoc>
    <method type="constructor" name="MullerSolver" startLine="76" endLine="78" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="double" name="doSolve" startLine="87" endLine="117">
      <declaration type="double" name="min" />
      <declaration type="double" name="max" />
      <declaration type="double" name="initial" />
      <declaration type="double" name="functionValueAccuracy" />
      <declaration type="double" name="fMin" />
      <scope startLine="98" endLine="100" />
      <declaration type="double" name="fMax" />
      <scope startLine="102" endLine="104" />
      <declaration type="double" name="fInitial" />
      <scope startLine="106" endLine="108" />
      <scope startLine="112" endLine="114" />
      <scope startLine="114" endLine="116" />
      <comment>check for zeros before verifying bracketing</comment>
    </method>
    <javadoc>
      <text>* Find a real root in the given interval.</text>
      <param>min Lower bound for the interval.</param>
      <param>max Upper bound for the interval.</param>
      <param>fMin function value at the lower bound.</param>
      <param>fMax function value at the upper bound.</param>
      <return>the point at which the function value is zero.</return>
      <throws>TooManyEvaluationsException if the allowed number of calls to
 * the function to be solved has been exhausted.</throws>
    </javadoc>
    <method type="double" name="solve" startLine="132" endLine="202">
      <declaration type="double" name="relativeAccuracy" />
      <declaration type="double" name="absoluteAccuracy" />
      <declaration type="double" name="functionValueAccuracy" />
      <declaration type="double" name="x0" />
      <declaration type="double" name="y0" />
      <declaration type="double" name="x2" />
      <declaration type="double" name="y2" />
      <declaration type="double" name="x1" />
      <declaration type="double" name="y1" />
      <declaration type="double" name="oldx" />
      <scope startLine="150" endLine="201">
        <declaration type="double" name="d01" />
        <declaration type="double" name="d12" />
        <declaration type="double" name="d012" />
        <declaration type="double" name="c1" />
        <declaration type="double" name="delta" />
        <declaration type="double" name="xplus" />
        <declaration type="double" name="xminus" />
        <declaration type="double" name="x" />
        <declaration type="double" name="y" />
        <declaration type="double" name="tolerance" />
        <scope startLine="170" endLine="172" />
        <declaration type="boolean" name="bisect" />
        <scope startLine="182" endLine="189" />
        <scope startLine="189" endLine="200">
          <declaration type="double" name="xm" />
          <declaration type="double" name="ym" />
          <scope startLine="192" endLine="194" />
          <scope startLine="194" endLine="196" />
        </scope>
        <comment>Muller's method employs quadratic interpolation through</comment>
        <comment>x0, x1, x2 and x is the zero of the interpolating parabola.</comment>
        <comment>Due to bracketing condition, this parabola must have two</comment>
        <comment>real roots and we choose one in [x0, x2] to be x.</comment>
        <comment>xplus and xminus are two roots of parabola and at least</comment>
        <comment>one of them should lie in (x0, x2)</comment>
        <comment>check for convergence</comment>
        <comment>Bisect if convergence is too slow. Bisection would waste</comment>
        <comment>our calculation of x, hopefully it won't happen often.</comment>
        <comment>the real number equality test x == x1 is intentional and</comment>
        <comment>completes the proximity tests above it</comment>
        <comment>prepare the new bracketing interval for next iteration</comment>
      </scope>
      <comment>[x0, x2] is the bracketing interval in each iteration</comment>
      <comment>x1 is the last approximation and an interpolation point in (x0, x2)</comment>
      <comment>x is the new root approximation and new x1 for next round</comment>
      <comment>d01, d12, d012 are divided differences</comment>
    </method>
  </class>
</source>
