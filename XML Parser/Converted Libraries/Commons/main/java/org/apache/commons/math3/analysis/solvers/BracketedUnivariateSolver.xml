<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.analysis.solvers">
  <import name="org.apache.commons.math3.analysis.UnivariateFunction" />
  <interface name="BracketedUnivariateSolver" startLine="22">
    <implements name="BaseUnivariateSolver<FUNC>" />
    <javadoc>
      <text>* Interface for {@link UnivariateSolver (univariate real) root-finding
 * algorithms} that maintain a bracketed solution. There are several advantages
 * to having such root-finding algorithms:
 * <ul>
 * <li>The bracketed solution guarantees that the root is kept within the
 * interval. As such, these algorithms generally also guarantee
 * convergence.</li>
 * <li>The bracketed solution means that we have the opportunity to only
 * return roots that are greater than or equal to the actual root, or
 * are less than or equal to the actual root. That is, we can control
 * whether under-approximations and over-approximations are{@link AllowedSolution allowed solutions}. Other root-finding
 * algorithms can usually only guarantee that the solution (the root that
 * was found) is around the actual root.</li>
 * </ul>
 * <p>For backwards compatibility, all root-finding algorithms must have{@link AllowedSolution#ANY_SIDE ANY_SIDE} as default for the allowed
 * solutions.</p></text>
      <param><FUNC>
 *  Type of function to solve.</param>
      <see>AllowedSolution</see>
      <since>3.0</since>
      <version>$Id: BracketedUnivariateSolver.java 1364387 2012-07-22 18:14:11Z tn $</version>
    </javadoc>
    <method name="solve" type="double" startLine="50" endLine="69" />
    <javadoc>
      <text>* Solve for a zero in the given interval.
 * A solver may require that the interval brackets a single zero root.
 * Solvers that do require bracketing should be able to handle the case
 * where one of the endpoints is itself a root.</text>
      <param>maxEval Maximum number of evaluations.</param>
      <param>f Function to solve.</param>
      <param>min Lower bound for the interval.</param>
      <param>max Upper bound for the interval.</param>
      <param>allowedSolution The kind of solutions that the root-finding algorithm may
 * accept as solutions.</param>
      <return>A value where the function is zero.</return>
      <throws>org.apache.commons.math3.exception.MathIllegalArgumentExceptionif the arguments do not satisfy the requirements specified by the solver.</throws>
      <throws>org.apache.commons.math3.exception.TooManyEvaluationsException if
 * the allowed number of evaluations is exceeded.</throws>
    </javadoc>
    <method name="solve" type="double" startLine="71" endLine="91" />
    <javadoc>
      <text>* Solve for a zero in the given interval, start at {@code startValue}.
 * A solver may require that the interval brackets a single zero root.
 * Solvers that do require bracketing should be able to handle the case
 * where one of the endpoints is itself a root.</text>
      <param>maxEval Maximum number of evaluations.</param>
      <param>f Function to solve.</param>
      <param>min Lower bound for the interval.</param>
      <param>max Upper bound for the interval.</param>
      <param>startValue Start value to use.</param>
      <param>allowedSolution The kind of solutions that the root-finding algorithm may
 * accept as solutions.</param>
      <return>A value where the function is zero.</return>
      <throws>org.apache.commons.math3.exception.MathIllegalArgumentExceptionif the arguments do not satisfy the requirements specified by the solver.</throws>
      <throws>org.apache.commons.math3.exception.TooManyEvaluationsException if
 * the allowed number of evaluations is exceeded.</throws>
    </javadoc>
  </interface>
</source>
