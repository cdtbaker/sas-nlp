<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.scalar.noderiv">
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.linear.ArrayRealVector" />
  <import name="org.apache.commons.math3.linear.RealVector" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.GoalType" />
  <import name="org.apache.commons.math3.optim.PointValuePair" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer" />
  <class name="BOBYQAOptimizer" extends="MultivariateOptimizer" startLine="31">
    <javadoc>
      <text>* Powell's BOBYQA algorithm. This implementation is translated and
 * adapted from the Fortran version available
 * <a href="http://plato.asu.edu/ftp/other_software/bobyqa.zip">here</a>.
 * See <a href="http://www.optimization-online.org/DB_HTML/2010/05/2616.html">
 * this paper</a> for an introduction.
 * <br/>
 * BOBYQA is particularly well suited for high dimensional problems
 * where derivatives are not available. In most cases it outperforms the{@link PowellOptimizer} significantly. Stochastic algorithms like{@link CMAESOptimizer} succeed more often than BOBYQA, but are more
 * expensive. BOBYQA could also be considered as a replacement of any
 * derivative-based optimizer when the derivatives are approximated by
 * finite differences.</text>
      <version>$Id: BOBYQAOptimizer.java 1462507 2013-03-29 15:50:22Z luc $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Minimum dimension of the problem: {@value}</text>
    </javadoc>
    <declaration type="int" name="MINIMUM_PROBLEM_DIMENSION" />
    <javadoc>
      <text>* Default value for {@link #initialTrustRegionRadius}: {@value} .</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_INITIAL_RADIUS" />
    <javadoc>
      <text>* Default value for {@link #stoppingTrustRegionRadius}: {@value} .</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_STOPPING_RADIUS" />
    <declaration type="double" name="ZERO" />
    <declaration type="double" name="ONE" />
    <declaration type="double" name="TWO" />
    <declaration type="double" name="TEN" />
    <declaration type="double" name="SIXTEEN" />
    <declaration type="double" name="TWO_HUNDRED_FIFTY" />
    <declaration type="double" name="MINUS_ONE" />
    <declaration type="double" name="HALF" />
    <declaration type="double" name="ONE_OVER_FOUR" />
    <declaration type="double" name="ONE_OVER_EIGHT" />
    <declaration type="double" name="ONE_OVER_TEN" />
    <declaration type="double" name="ONE_OVER_A_THOUSAND" />
    <javadoc>
      <text>* numberOfInterpolationPoints XXX</text>
    </javadoc>
    <declaration type="int" name="numberOfInterpolationPoints" />
    <javadoc>
      <text>* initialTrustRegionRadius XXX</text>
    </javadoc>
    <declaration type="double" name="initialTrustRegionRadius" />
    <javadoc>
      <text>* stoppingTrustRegionRadius XXX</text>
    </javadoc>
    <declaration type="double" name="stoppingTrustRegionRadius" />
    <javadoc>
      <text>* Goal type (minimize or maximize).</text>
    </javadoc>
    <declaration type="boolean" name="isMinimize" />
    <javadoc>
      <text>* Current best values for the variables to be optimized.
 * The vector will be changed in-place to contain the values of the least
 * calculated objective function values.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="currentBest" />
    <javadoc>
      <text>* Differences between the upper and lower bounds.</text>
    </javadoc>
    <declaration type="double[]" name="boundDifference" />
    <javadoc>
      <text>* Index of the interpolation point at the trust region center.</text>
    </javadoc>
    <declaration type="int" name="trustRegionCenterInterpolationPointIndex" />
    <javadoc>
      <text>* Last <em>n</em> columns of matrix H (where <em>n</em> is the dimension
 * of the problem).
 * XXX "bmat" in the original code.</text>
    </javadoc>
    <declaration type="Array2DRowRealMatrix" name="bMatrix" />
    <javadoc>
      <text>* Factorization of the leading <em>npt</em> square submatrix of H, this
 * factorization being Z Z<sup>T</sup>, which provides both the correct
 * rank and positive semi-definiteness.
 * XXX "zmat" in the original code.</text>
    </javadoc>
    <declaration type="Array2DRowRealMatrix" name="zMatrix" />
    <javadoc>
      <text>* Coordinates of the interpolation points relative to {@link #originShift}.
 * XXX "xpt" in the original code.</text>
    </javadoc>
    <declaration type="Array2DRowRealMatrix" name="interpolationPoints" />
    <javadoc>
      <text>* Shift of origin that should reduce the contributions from rounding
 * errors to values of the model and Lagrange functions.
 * XXX "xbase" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="originShift" />
    <javadoc>
      <text>* Values of the objective function at the interpolation points.
 * XXX "fval" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="fAtInterpolationPoints" />
    <javadoc>
      <text>* Displacement from {@link #originShift} of the trust region center.
 * XXX "xopt" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="trustRegionCenterOffset" />
    <javadoc>
      <text>* Gradient of the quadratic model at {@link #originShift} +{@link #trustRegionCenterOffset}.
 * XXX "gopt" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="gradientAtTrustRegionCenter" />
    <javadoc>
      <text>* Differences {@link #getLowerBound()} - {@link #originShift}.
 * All the components of every {@link #trustRegionCenterOffset} are going
 * to satisfy the bounds<br/>{@link #getLowerBound() lowerBound}<sub>i</sub> &le;{@link #trustRegionCenterOffset}<sub>i</sub>,<br/>
 * with appropriate equalities when {@link #trustRegionCenterOffset} is
 * on a constraint boundary.
 * XXX "sl" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="lowerDifference" />
    <javadoc>
      <text>* Differences {@link #getUpperBound()} - {@link #originShift}All the components of every {@link #trustRegionCenterOffset} are going
 * to satisfy the bounds<br/>{@link #trustRegionCenterOffset}<sub>i</sub> &le;{@link #getUpperBound() upperBound}<sub>i</sub>,<br/>
 * with appropriate equalities when {@link #trustRegionCenterOffset} is
 * on a constraint boundary.
 * XXX "su" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="upperDifference" />
    <javadoc>
      <text>* Parameters of the implicit second derivatives of the quadratic model.
 * XXX "pq" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="modelSecondDerivativesParameters" />
    <javadoc>
      <text>* Point chosen by function {@link #trsbox(double,ArrayRealVector,ArrayRealVector,ArrayRealVector,ArrayRealVector,ArrayRealVector) trsbox}or {@link #altmov(int,double) altmov}.
 * Usually {@link #originShift} + {@link #newPoint} is the vector of
 * variables for the next evaluation of the objective function.
 * It also satisfies the constraints indicated in {@link #lowerDifference}and {@link #upperDifference}.
 * XXX "xnew" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="newPoint" />
    <javadoc>
      <text>* Alternative to {@link #newPoint}, chosen by{@link #altmov(int,double) altmov}.
 * It may replace {@link #newPoint} in order to increase the denominator
 * in the {@link #update(double,double,int) updating procedure}.
 * XXX "xalt" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="alternativeNewPoint" />
    <javadoc>
      <text>* Trial step from {@link #trustRegionCenterOffset} which is usually{@link #newPoint} - {@link #trustRegionCenterOffset}.
 * XXX "d__" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="trialStepPoint" />
    <javadoc>
      <text>* Values of the Lagrange functions at a new point.
 * XXX "vlag" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="lagrangeValuesAtNewPoint" />
    <javadoc>
      <text>* Explicit second derivatives of the quadratic model.
 * XXX "hq" in the original code.</text>
    </javadoc>
    <declaration type="ArrayRealVector" name="modelSecondDerivativesValues" />
    <javadoc>
      <param>numberOfInterpolationPoints Number of interpolation conditions.
 * For a problem of dimension {@code n}, its value must be in the interval{@code [n+2, (n+1)(n+2)/2]}.
 * Choices that exceed {@code 2n+1} are not recommended.</param>
    </javadoc>
    <method type="constructor" name="BOBYQAOptimizer" startLine="206" endLine="210" />
    <javadoc>
      <param>numberOfInterpolationPoints Number of interpolation conditions.
 * For a problem of dimension {@code n}, its value must be in the interval{@code [n+2, (n+1)(n+2)/2]}.
 * Choices that exceed {@code 2n+1} are not recommended.</param>
      <param>initialTrustRegionRadius Initial trust region radius.</param>
      <param>stoppingTrustRegionRadius Stopping trust region radius.</param>
    </javadoc>
    <method type="constructor" name="BOBYQAOptimizer" startLine="222" endLine="227">
      <comment>No custom convergence criterion.</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="PointValuePair" name="doOptimize" startLine="231" endLine="245">
      <declaration type="double[]" name="lowerBound" />
      <declaration type="double[]" name="upperBound" />
      <declaration type="double" name="value" />
      <comment>Validity checks.</comment>
    </method>
    <javadoc>
      <text>* This subroutine seeks the least value of a function of many variables,
 * by applying a trust region method that forms quadratic models by
 * interpolation. There is usually some freedom in the interpolation
 * conditions, which is taken up by minimizing the Frobenius norm of
 * the change to the second derivative of the model, beginning with the
 * zero matrix. The values of the variables are constrained by upper and
 * lower bounds. The arguments of the subroutine are as follows.
 * N must be set to the number of variables and must be at least two.
 * NPT is the number of interpolation conditions. Its value must be in
 * the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not
 * recommended.
 * Initial values of the variables must be set in X(1),X(2),...,X(N). They
 * will be changed to the values that give the least calculated F.
 * For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper
 * bounds, respectively, on X(I). The construction of quadratic models
 * requires XL(I) to be strictly less than XU(I) for each I. Further,
 * the contribution to a model from changes to the I-th variable is
 * damaged severely by rounding errors if XU(I)-XL(I) is too small.
 * RHOBEG and RHOEND must be set to the initial and final values of a trust
 * region radius, so both must be positive with RHOEND no greater than
 * RHOBEG. Typically, RHOBEG should be about one tenth of the greatest
 * expected change to a variable, while RHOEND should indicate the
 * accuracy that is required in the final values of the variables. An
 * error return occurs if any of the differences XU(I)-XL(I), I=1,...,N,
 * is less than 2*RHOBEG.
 * MAXFUN must be set to an upper bound on the number of calls of CALFUN.
 * The array W will be used for working space. Its length must be at least
 * (NPT+5)*(NPT+N)+3*N*(N+5)/2.</text>
      <param>lowerBound Lower bounds.</param>
      <param>upperBound Upper bounds.</param>
      <return>the value of the objective at the optimum.</return>
    </javadoc>
    <method type="double" name="bobyqa" startLine="283" endLine="330">
      <declaration type="int" name="n" />
      <scope startLine="295" endLine="325">
        <declaration type="double" name="boundDiff" />
        <scope startLine="299" endLine="311">
          <scope startLine="300" endLine="304" />
          <scope startLine="304" endLine="310">
            <declaration type="double" name="deltaOne" />
          </scope>
        </scope>
        <scope startLine="311" endLine="324">
          <scope startLine="312" endLine="316" />
          <scope startLine="316" endLine="323">
            <declaration type="double" name="deltaOne" />
            <declaration type="double" name="deltaTwo" />
          </scope>
        </scope>
        <comment>Computing MAX</comment>
        <comment>Computing MIN</comment>
      </scope>
      <comment>XXX</comment>
      <comment>Return if there is insufficient space between the bounds. Modify the</comment>
      <comment>initial X if necessary in order to avoid conflicts between the bounds</comment>
      <comment>and the construction of the first quadratic model. The lower and upper</comment>
      <comment>bounds on moves from the updated X are set now, in the ISL and ISU</comment>
      <comment>partitions of W, in order to provide useful and exact information about</comment>
      <comment>components of X that become within distance RHOBEG from their bounds.</comment>
      <comment>Make the call of BOBYQB.</comment>
      <comment>bobyqa</comment>
    </method>
    <javadoc>
      <text>* The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN
 * are identical to the corresponding arguments in SUBROUTINE BOBYQA.
 * XBASE holds a shift of origin that should reduce the contributions
 * from rounding errors to values of the model and Lagrange functions.
 * XPT is a two-dimensional array that holds the coordinates of the
 * interpolation points relative to XBASE.
 * FVAL holds the values of F at the interpolation points.
 * XOPT is set to the displacement from XBASE of the trust region centre.
 * GOPT holds the gradient of the quadratic model at XBASE+XOPT.
 * HQ holds the explicit second derivatives of the quadratic model.
 * PQ contains the parameters of the implicit second derivatives of the
 * quadratic model.
 * BMAT holds the last N columns of H.
 * ZMAT holds the factorization of the leading NPT by NPT submatrix of H,
 * this factorization being ZMAT times ZMAT^T, which provides both the
 * correct rank and positive semi-definiteness.
 * NDIM is the first dimension of BMAT and has the value NPT+N.
 * SL and SU hold the differences XL-XBASE and XU-XBASE, respectively.
 * All the components of every XOPT are going to satisfy the bounds
 * SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when
 * XOPT is on a constraint boundary.
 * XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the
 * vector of variables for the next call of CALFUN. XNEW also satisfies
 * the SL and SU constraints in the way that has just been mentioned.
 * XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW
 * in order to increase the denominator in the updating of UPDATE.
 * D is reserved for a trial step from XOPT, which is usually XNEW-XOPT.
 * VLAG contains the values of the Lagrange functions at a new point X.
 * They are part of a product that requires VLAG to be of length NDIM.
 * W is a one-dimensional array that is used for working space. Its length
 * must be at least 3*NDIM = 3*(NPT+N).</text>
      <param>lowerBound Lower bounds.</param>
      <param>upperBound Upper bounds.</param>
      <return>the value of the objective at the optimum.</return>
    </javadoc>
    <method type="double" name="bobyqb" startLine="372" endLine="1216">
      <declaration type="int" name="n" />
      <declaration type="int" name="npt" />
      <declaration type="int" name="np" />
      <declaration type="int" name="nptm" />
      <declaration type="int" name="nh" />
      <declaration type="ArrayRealVector" name="work1" />
      <declaration type="ArrayRealVector" name="work2" />
      <declaration type="ArrayRealVector" name="work3" />
      <declaration type="double" name="cauchy" />
      <declaration type="double" name="alpha" />
      <declaration type="double" name="dsq" />
      <declaration type="double" name="crvmin" />
      <declaration type="double" name="xoptsq" />
      <scope startLine="406" endLine="411">
        <declaration type="double" name="deltaOne" />
        <comment>Computing 2nd power</comment>
      </scope>
      <declaration type="double" name="fsave" />
      <declaration type="int" name="kbase" />
      <declaration type="int" name="ntrits" />
      <declaration type="int" name="itest" />
      <declaration type="int" name="knew" />
      <declaration type="int" name="nfsav" />
      <declaration type="double" name="rho" />
      <declaration type="double" name="delta" />
      <declaration type="double" name="diffa" />
      <declaration type="double" name="diffb" />
      <declaration type="double" name="diffc" />
      <declaration type="double" name="f" />
      <declaration type="double" name="beta" />
      <declaration type="double" name="adelt" />
      <declaration type="double" name="denom" />
      <declaration type="double" name="ratio" />
      <declaration type="double" name="dnorm" />
      <declaration type="double" name="scaden" />
      <declaration type="double" name="biglsq" />
      <declaration type="double" name="distsq" />
      <declaration type="int" name="state" />
      <scope startLine="441" endLine="476">
        <scope startLine="443" endLine="467">
          <declaration type="int" name="ih" />
          <scope startLine="445" endLine="453">
            <scope startLine="446" endLine="452">
              <scope startLine="447" endLine="449" />
            </scope>
          </scope>
          <scope startLine="454" endLine="466">
            <scope startLine="455" endLine="464">
              <declaration type="double" name="temp" />
              <scope startLine="457" endLine="459" />
              <scope startLine="461" endLine="463" />
            </scope>
          </scope>
        </scope>
        <comment>XXX</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>Generate the next point in the trust region that provides a small value</comment>
        <comment>of the quadratic model subject to the constraints on the variables.</comment>
        <comment>The int NTRITS is set to the number "trust region" iterations that</comment>
        <comment>have occurred since the last "alternative" iteration. If the length</comment>
        <comment>of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to</comment>
        <comment>label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.</comment>
      </scope>
      <scope startLine="477" endLine="550">
        <declaration type="ArrayRealVector" name="gnew" />
        <declaration type="ArrayRealVector" name="xbdi" />
        <declaration type="ArrayRealVector" name="s" />
        <declaration type="ArrayRealVector" name="hs" />
        <declaration type="ArrayRealVector" name="hred" />
        <declaration type="double[]" name="dsqCrvmin" />
        <declaration type="double" name="deltaOne" />
        <declaration type="double" name="deltaTwo" />
        <scope startLine="494" endLine="541">
          <scope startLine="499" endLine="501" />
          <declaration type="double" name="errbig" />
          <declaration type="double" name="frhosq" />
          <scope startLine="514" endLine="516" />
          <declaration type="double" name="bdtol" />
          <scope startLine="518" endLine="539">
            <declaration type="double" name="bdtest" />
            <scope startLine="520" endLine="522" />
            <scope startLine="523" endLine="525" />
            <scope startLine="526" endLine="538">
              <declaration type="double" name="curv" />
              <scope startLine="528" endLine="532">
                <declaration type="double" name="d1" />
              </scope>
              <scope startLine="534" endLine="536" />
            </scope>
          </scope>
        </scope>
        <comment>XXX</comment>
        <comment>Computing MIN</comment>
        <comment>Computing 2nd power</comment>
        <comment>The following choice between labels 650 and 680 depends on whether or</comment>
        <comment>not our work with the current RHO seems to be complete. Either RHO is</comment>
        <comment>decreased or termination occurs if the errors in the quadratic model at</comment>
        <comment>the last three interpolation points compare favourably with predictions</comment>
        <comment>of likely improvements to the model within distance HALF*RHO of XOPT.</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>Severe cancellation is likely to occur if XOPT is too far from XBASE.</comment>
        <comment>If the following test holds, then XBASE is shifted so that XOPT becomes</comment>
        <comment>zero. The appropriate changes are made to BMAT and to the second</comment>
        <comment>derivatives of the current model, beginning with the changes to BMAT</comment>
        <comment>that do not depend on ZMAT. VLAG is used temporarily for working space.</comment>
      </scope>
      <scope startLine="551" endLine="655">
        <scope startLine="553" endLine="640">
          <declaration type="double" name="fracsq" />
          <declaration type="double" name="sumpq" />
          <scope startLine="558" endLine="578">
            <declaration type="double" name="sum" />
            <scope startLine="561" endLine="563" />
            <declaration type="double" name="temp" />
            <scope startLine="567" endLine="577">
              <declaration type="int" name="ip" />
              <scope startLine="571" endLine="576" />
            </scope>
          </scope>
          <scope startLine="582" endLine="611">
            <declaration type="double" name="sumz" />
            <declaration type="double" name="sumw" />
            <scope startLine="585" endLine="589" />
            <scope startLine="590" endLine="601">
              <declaration type="double" name="sum" />
              <scope startLine="592" endLine="594" />
              <scope startLine="596" endLine="600" />
            </scope>
            <scope startLine="602" endLine="610">
              <declaration type="int" name="ip" />
              <declaration type="double" name="temp" />
              <scope startLine="605" endLine="609" />
            </scope>
          </scope>
          <declaration type="int" name="ih" />
          <scope startLine="617" endLine="631">
            <scope startLine="619" endLine="622" />
            <scope startLine="623" endLine="630" />
          </scope>
          <scope startLine="632" endLine="638" />
        </scope>
        <scope startLine="641" endLine="643" />
        <comment>XXX</comment>
        <comment>final RealVector sumVector</comment>
        <comment>= new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));</comment>
        <comment>sum = sumVector.getEntry(k);  XXX "testAckley" and "testDiffPow" fail.</comment>
        <comment>Then the revisions of BMAT that depend on ZMAT are calculated.</comment>
        <comment>The following instructions complete the shift, including the changes</comment>
        <comment>to the second derivative parameters of the quadratic model.</comment>
        <comment>XBASE is also moved to XOPT by a call of RESCUE. This calculation is</comment>
        <comment>more expensive than the previous shift, because new matrices BMAT and</comment>
        <comment>ZMAT are generated from scratch, which may include the replacement of</comment>
        <comment>interpolation points whose positions seem to be causing near linear</comment>
        <comment>dependence in the interpolation conditions. Therefore RESCUE is called</comment>
        <comment>only if rounding errors have reduced by at least a factor of two the</comment>
        <comment>denominator of the formula for updating the H matrix. It provides a</comment>
        <comment>useful safeguard, but is not invoked in most applications of BOBYQA.</comment>
      </scope>
      <scope startLine="656" endLine="681">
        <declaration type="double[]" name="alphaCauchy" />
        <scope startLine="673" endLine="675" />
        <comment>XXX</comment>
        <comment>Pick two alternative vectors of variables, relative to XBASE, that</comment>
        <comment>are suitable as new positions of the KNEW-th interpolation point.</comment>
        <comment>Firstly, XNEW is set to the point on a line through XOPT and another</comment>
        <comment>interpolation point that minimizes the predicted value of the next</comment>
        <comment>denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL</comment>
        <comment>and SU bounds. Secondly, XALT is set to the best feasible point on</comment>
        <comment>a constrained version of the Cauchy step of the KNEW-th Lagrange</comment>
        <comment>function, the corresponding value of the square of this function</comment>
        <comment>being returned in CAUCHY. The choice between these alternatives is</comment>
        <comment>going to be made when the denominator is calculated.</comment>
        <comment>Calculate VLAG and BETA for the current choice of D. The scalar</comment>
        <comment>product of D with XPT(K,.) is going to be held in W(NPT+K) for</comment>
        <comment>use when VQUAD is calculated.</comment>
      </scope>
      <scope startLine="682" endLine="804">
        <scope startLine="684" endLine="696">
          <declaration type="double" name="suma" />
          <declaration type="double" name="sumb" />
          <declaration type="double" name="sum" />
          <scope startLine="688" endLine="692" />
        </scope>
        <scope startLine="698" endLine="707">
          <declaration type="double" name="sum" />
          <scope startLine="700" endLine="702" />
          <scope startLine="704" endLine="706" />
        </scope>
        <declaration type="double" name="bsum" />
        <declaration type="double" name="dx" />
        <scope startLine="711" endLine="727">
          <declaration type="double" name="d1" />
          <declaration type="double" name="sum" />
          <scope startLine="716" endLine="718" />
          <declaration type="int" name="jp" />
          <scope startLine="721" endLine="723" />
        </scope>
        <scope startLine="740" endLine="758">
          <declaration type="double" name="d1" />
          <scope startLine="744" endLine="751">
            <scope startLine="745" endLine="748" />
          </scope>
        </scope>
        <scope startLine="758" endLine="796">
          <declaration type="double" name="delsq" />
          <scope startLine="763" endLine="795">
            <scope startLine="764" endLine="766" />
            <declaration type="double" name="hdiag" />
            <scope startLine="768" endLine="772">
              <declaration type="double" name="d1" />
            </scope>
            <declaration type="double" name="d2" />
            <declaration type="double" name="den" />
            <scope startLine="777" endLine="781">
              <declaration type="double" name="d3" />
            </scope>
            <declaration type="double" name="d4" />
            <declaration type="double" name="temp" />
            <scope startLine="786" endLine="790" />
            <declaration type="double" name="d5" />
          </scope>
        </scope>
        <comment>XXX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Original</comment>
        <comment>beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum;  XXX "testAckley" and "testDiffPow" fail.</comment>
        <comment>beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum;  XXX "testDiffPow" fails.</comment>
        <comment>If NTRITS is zero, the denominator may be increased by replacing</comment>
        <comment>the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if</comment>
        <comment>rounding errors have damaged the chosen denominator.</comment>
        <comment>Computing 2nd power</comment>
        <comment>XXX Useful statement?</comment>
        <comment>Alternatively, if NTRITS is positive, then set KNEW to the index of</comment>
        <comment>the next interpolation point to be deleted to make room for a trust</comment>
        <comment>region step. Again RESCUE may be called if rounding errors have damaged_</comment>
        <comment>the chosen denominator, which is the reason for attempting to select</comment>
        <comment>KNEW before calculating the next value of the objective function.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Put the variables for the next calculation of the objective function</comment>
        <comment>in XNEW, with any adjustments for the bounds.</comment>
        <comment>Calculate the value of the objective function at XBASE+XNEW, unless</comment>
        <comment>the limit on the number of calculations of F has been reached.</comment>
      </scope>
      <scope startLine="805" endLine="1113">
        <scope startLine="807" endLine="821">
          <declaration type="double" name="d3" />
          <declaration type="double" name="d4" />
          <declaration type="double" name="d1" />
          <declaration type="double" name="d2" />
          <scope startLine="815" endLine="817" />
          <scope startLine="818" endLine="820" />
        </scope>
        <scope startLine="827" endLine="830" />
        <declaration type="double" name="fopt" />
        <declaration type="double" name="vquad" />
        <declaration type="int" name="ih" />
        <scope startLine="838" endLine="848">
          <scope startLine="840" endLine="847">
            <declaration type="double" name="temp" />
            <scope startLine="842" endLine="844" />
          </scope>
        </scope>
        <scope startLine="849" endLine="854">
          <declaration type="double" name="d1" />
          <declaration type="double" name="d2" />
        </scope>
        <declaration type="double" name="diff" />
        <scope startLine="859" endLine="861" />
        <scope startLine="865" endLine="930">
          <scope startLine="866" endLine="868" />
          <declaration type="double" name="hDelta" />
          <scope startLine="871" endLine="874" />
          <scope startLine="874" endLine="877" />
          <scope startLine="877" endLine="880" />
          <scope startLine="881" endLine="883" />
          <scope startLine="887" endLine="929">
            <declaration type="int" name="ksav" />
            <declaration type="double" name="densav" />
            <declaration type="double" name="delsq" />
            <scope startLine="894" endLine="924">
              <declaration type="double" name="hdiag" />
              <scope startLine="896" endLine="900">
                <declaration type="double" name="d1" />
              </scope>
              <declaration type="double" name="d1" />
              <declaration type="double" name="den" />
              <scope startLine="905" endLine="909">
                <declaration type="double" name="d2" />
              </scope>
              <declaration type="double" name="d3" />
              <declaration type="double" name="temp" />
              <scope startLine="914" endLine="918" />
              <declaration type="double" name="d4" />
              <declaration type="double" name="d5" />
            </scope>
            <scope startLine="925" endLine="928" />
          </scope>
        </scope>
        <declaration type="double" name="pqold" />
        <scope startLine="940" endLine="946">
          <declaration type="double" name="temp" />
          <scope startLine="942" endLine="945" />
        </scope>
        <scope startLine="947" endLine="952">
          <declaration type="double" name="temp" />
          <scope startLine="949" endLine="951" />
        </scope>
        <scope startLine="958" endLine="961" />
        <scope startLine="962" endLine="975">
          <declaration type="double" name="suma" />
          <scope startLine="964" endLine="966" />
          <declaration type="double" name="sumb" />
          <scope startLine="968" endLine="970" />
          <declaration type="double" name="temp" />
          <scope startLine="972" endLine="974" />
        </scope>
        <scope startLine="976" endLine="978" />
        <scope startLine="982" endLine="1009">
          <scope startLine="986" endLine="998">
            <declaration type="double" name="d1" />
            <scope startLine="991" endLine="997">
              <scope startLine="992" endLine="994" />
            </scope>
          </scope>
          <scope startLine="999" endLine="1008">
            <declaration type="double" name="temp" />
            <scope startLine="1001" endLine="1003" />
            <scope startLine="1005" endLine="1007" />
          </scope>
        </scope>
        <scope startLine="1015" endLine="1091">
          <scope startLine="1016" endLine="1019" />
          <scope startLine="1020" endLine="1028">
            <declaration type="double" name="sum" />
            <scope startLine="1022" endLine="1024" />
            <scope startLine="1025" endLine="1027" />
          </scope>
          <scope startLine="1029" endLine="1036">
            <declaration type="double" name="sum" />
            <scope startLine="1031" endLine="1033" />
          </scope>
          <declaration type="double" name="gqsq" />
          <declaration type="double" name="gisq" />
          <scope startLine="1039" endLine="1068">
            <declaration type="double" name="sum" />
            <scope startLine="1041" endLine="1044" />
            <scope startLine="1045" endLine="1053">
              <declaration type="double" name="d1" />
              <declaration type="double" name="d2" />
            </scope>
            <scope startLine="1053" endLine="1061">
              <declaration type="double" name="d1" />
              <declaration type="double" name="d2" />
            </scope>
            <scope startLine="1061" endLine="1066">
              <declaration type="double" name="d1" />
            </scope>
          </scope>
          <scope startLine="1074" endLine="1076" />
          <scope startLine="1077" endLine="1090">
            <scope startLine="1078" endLine="1089">
              <scope startLine="1079" endLine="1081" />
              <scope startLine="1082" endLine="1084" />
              <scope startLine="1085" endLine="1087" />
            </scope>
          </scope>
        </scope>
        <scope startLine="1097" endLine="1099" />
        <scope startLine="1100" endLine="1102" />
        <declaration type="double" name="d1" />
        <declaration type="double" name="d2" />
        <comment>XXX</comment>
        <comment>Computing MIN</comment>
        <comment>Computing MAX</comment>
        <comment>Use the quadratic model to predict the change in F due to the step D,</comment>
        <comment>and set DIFF to the error of this prediction.</comment>
        <comment>Computing 2nd power</comment>
        <comment>"d1" must be squared first to prevent test failures.</comment>
        <comment>Pick the next value of DELTA after a trust region step.</comment>
        <comment>Computing MIN</comment>
        <comment>Computing MAX</comment>
        <comment>Computing MAX</comment>
        <comment>Recalculate KNEW and DENOM if the new F is less than FOPT.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Update BMAT and ZMAT, so that the KNEW-th interpolation point can be</comment>
        <comment>moved. Also update the second derivative terms of the model.</comment>
        <comment>Include the new interpolation point, and make the changes to GOPT at</comment>
        <comment>the old XOPT that are caused by the updating of the quadratic model.</comment>
        <comment>Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Calculate the parameters of the least Frobenius norm interpolant to</comment>
        <comment>the current data, the gradient of this interpolant at XOPT being put</comment>
        <comment>into VLAG(NPT+I), I=1,2,...,N.</comment>
        <comment>Computing MIN</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Test whether to replace the new quadratic model by the least Frobenius</comment>
        <comment>norm interpolant, making the replacement if the test is satisfied.</comment>
        <comment>If a trust region step has provided a sufficient decrease in F, then</comment>
        <comment>branch for another trust region calculation. The case NTRITS=0 occurs</comment>
        <comment>when the new interpolation point was reached by an alternative step.</comment>
        <comment>Alternatively, find out if the interpolation points are close enough</comment>
        <comment>to the best point so far.</comment>
        <comment>Computing MAX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
      </scope>
      <scope startLine="1114" endLine="1165">
        <scope startLine="1117" endLine="1128">
          <declaration type="double" name="sum" />
          <scope startLine="1119" endLine="1123">
            <declaration type="double" name="d1" />
          </scope>
          <scope startLine="1124" endLine="1127" />
        </scope>
        <scope startLine="1136" endLine="1152">
          <declaration type="double" name="dist" />
          <scope startLine="1138" endLine="1144">
            <scope startLine="1141" endLine="1143" />
          </scope>
          <declaration type="double" name="d1" />
        </scope>
        <scope startLine="1153" endLine="1155" />
        <scope startLine="1156" endLine="1158" />
        <scope startLine="1159" endLine="1161" />
        <comment>XXX</comment>
        <comment>Computing 2nd power</comment>
        <comment>If KNEW is positive, then ALTMOV finds alternative new positions for</comment>
        <comment>the KNEW-th interpolation point within distance ADELT of XOPT. It is</comment>
        <comment>reached via label 90. Otherwise, there is a branch to label 60 for</comment>
        <comment>another trust region iteration, unless the calculations with the</comment>
        <comment>current RHO are complete.</comment>
        <comment>Computing MIN</comment>
        <comment>Computing MAX</comment>
        <comment>Computing MIN</comment>
        <comment>The calculations with the current value of RHO are complete. Pick the</comment>
        <comment>next values of RHO and DELTA.</comment>
      </scope>
      <scope startLine="1166" endLine="1190">
        <scope startLine="1168" endLine="1182">
          <scope startLine="1171" endLine="1173" />
          <scope startLine="1173" endLine="1175" />
          <scope startLine="1175" endLine="1177" />
        </scope>
        <scope startLine="1187" endLine="1189" />
        <comment>XXX</comment>
        <comment>Return from the calculation, after another Newton-Raphson step, if</comment>
        <comment>it is too short to have been tried before.</comment>
      </scope>
      <scope startLine="1191" endLine="1212">
        <scope startLine="1193" endLine="1210">
          <scope startLine="1194" endLine="1208">
            <declaration type="double" name="d3" />
            <declaration type="double" name="d4" />
            <declaration type="double" name="d1" />
            <declaration type="double" name="d2" />
            <scope startLine="1202" endLine="1204" />
            <scope startLine="1205" endLine="1207" />
          </scope>
        </scope>
        <comment>XXX</comment>
        <comment>Computing MIN</comment>
        <comment>Computing MAX</comment>
      </scope>
      <scope startLine="1213" endLine="1215" />
      <comment>XXX</comment>
      <comment>Set some constants.</comment>
      <comment>Parameter adjustments</comment>
      <comment>Function Body</comment>
      <comment>The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,</comment>
      <comment>BMAT and ZMAT for the first iteration, with the corresponding values of</comment>
      <comment>of NF and KOPT, which are the number of calls of CALFUN so far and the</comment>
      <comment>index of the interpolation point at the trust region centre. Then the</comment>
      <comment>initial XOPT is set too. The branch to label 720 occurs if MAXFUN is</comment>
      <comment>less than NPT. GOPT will be updated if KOPT is different from KBASE.</comment>
      <comment>Complete the settings that are required for the iterative procedure.</comment>
      <comment>Update GOPT if necessary before the first iteration and after each</comment>
      <comment>call of RESCUE that makes a call of CALFUN.</comment>
      <comment>bobyqb</comment>
    </method>
    <javadoc>
      <text>* The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have
 * the same meanings as the corresponding arguments of BOBYQB.
 * KOPT is the index of the optimal interpolation point.
 * KNEW is the index of the interpolation point that is going to be moved.
 * ADELT is the current trust region bound.
 * XNEW will be set to a suitable new position for the interpolation point
 * XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region
 * bounds and it should provide a large denominator in the next call of
 * UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the
 * straight lines through XOPT and another interpolation point.
 * XALT also provides a large value of the modulus of the KNEW-th Lagrange
 * function subject to the constraints that have been mentioned, its main
 * difference from XNEW being that XALT-XOPT is a constrained version of
 * the Cauchy step within the trust region. An exception is that XALT is
 * not calculated if all components of GLAG (see below) are zero.
 * ALPHA will be set to the KNEW-th diagonal element of the H matrix.
 * CAUCHY will be set to the square of the KNEW-th Lagrange function at
 * the step XALT-XOPT from XOPT for the vector XALT that is returned,
 * except that CAUCHY is set to zero if XALT is not calculated.
 * GLAG is a working space vector of length N for the gradient of the
 * KNEW-th Lagrange function at XOPT.
 * HCOL is a working space vector of length NPT for the second derivative
 * coefficients of the KNEW-th Lagrange function.
 * W is a working space vector of length 2N that is going to hold the
 * constrained Cauchy step from XOPT of the Lagrange function, followed
 * by the downhill version of XALT when the uphill step is calculated.
 * Set the first NPT components of W to the leading elements of the
 * KNEW-th column of the H matrix.</text>
      <param>knew</param>
      <param>adelt</param>
    </javadoc>
    <method type="double[]" name="altmov" startLine="1256" endLine="1553">
      <declaration type="int" name="n" />
      <declaration type="int" name="npt" />
      <declaration type="ArrayRealVector" name="glag" />
      <declaration type="ArrayRealVector" name="hcol" />
      <declaration type="ArrayRealVector" name="work1" />
      <declaration type="ArrayRealVector" name="work2" />
      <scope startLine="1268" endLine="1270" />
      <scope startLine="1271" endLine="1276">
        <declaration type="double" name="tmp" />
        <scope startLine="1273" endLine="1275" />
      </scope>
      <declaration type="double" name="alpha" />
      <declaration type="double" name="ha" />
      <scope startLine="1282" endLine="1284" />
      <scope startLine="1285" endLine="1294">
        <declaration type="double" name="tmp" />
        <scope startLine="1287" endLine="1289" />
        <scope startLine="1291" endLine="1293" />
      </scope>
      <declaration type="double" name="presav" />
      <declaration type="double" name="step" />
      <declaration type="int" name="ksav" />
      <declaration type="int" name="ibdsav" />
      <declaration type="double" name="stpsav" />
      <scope startLine="1307" endLine="1408">
        <scope startLine="1308" endLine="1310" />
        <declaration type="double" name="dderiv" />
        <declaration type="double" name="distsq" />
        <scope startLine="1313" endLine="1317">
          <declaration type="double" name="tmp" />
        </scope>
        <declaration type="double" name="subd" />
        <declaration type="double" name="slbd" />
        <declaration type="int" name="ilbd" />
        <declaration type="int" name="iubd" />
        <declaration type="double" name="sumin" />
        <scope startLine="1326" endLine="1351">
          <declaration type="double" name="tmp" />
          <scope startLine="1328" endLine="1339">
            <scope startLine="1329" endLine="1332" />
            <scope startLine="1333" endLine="1338" />
          </scope>
          <scope startLine="1339" endLine="1350">
            <scope startLine="1340" endLine="1343" />
            <scope startLine="1344" endLine="1349" />
          </scope>
        </scope>
        <declaration type="int" name="isbd" />
        <declaration type="double" name="vlag" />
        <scope startLine="1359" endLine="1382">
          <declaration type="double" name="diff" />
          <declaration type="double" name="d1" />
          <scope startLine="1363" endLine="1367" />
          <declaration type="double" name="d2" />
          <declaration type="double" name="d3" />
          <declaration type="double" name="d4" />
          <scope startLine="1371" endLine="1378">
            <declaration type="double" name="d5" />
            <scope startLine="1373" endLine="1377" />
          </scope>
        </scope>
        <scope startLine="1382" endLine="1396">
          <declaration type="double" name="tmp" />
          <scope startLine="1385" endLine="1389" />
          <scope startLine="1390" endLine="1394" />
        </scope>
        <declaration type="double" name="tmp" />
        <declaration type="double" name="predsq" />
        <scope startLine="1402" endLine="1407" />
        <comment>Revise SLBD and SUBD if necessary because of the bounds in SL and SU.</comment>
        <comment>Computing MAX</comment>
        <comment>Computing MAX</comment>
        <comment>Seek a large modulus of the KNEW-th Lagrange function when the index</comment>
        <comment>of the other interpolation point on the line through XOPT is KNEW.</comment>
        <comment>Search along each of the other lines through XOPT and another point.</comment>
        <comment>Calculate PREDSQ for the current line search and maintain PRESAV.</comment>
      </scope>
      <scope startLine="1412" endLine="1416">
        <declaration type="double" name="tmp" />
      </scope>
      <scope startLine="1417" endLine="1419" />
      <scope startLine="1420" endLine="1422" />
      <declaration type="double" name="bigstp" />
      <declaration type="int" name="iflag" />
      <declaration type="double" name="cauchy" />
      <declaration type="double" name="csave" />
      <scope startLine="1432" endLine="1544">
        <declaration type="double" name="wfixsq" />
        <declaration type="double" name="ggfree" />
        <scope startLine="1435" endLine="1444">
          <declaration type="double" name="glagValue" />
          <scope startLine="1439" endLine="1443" />
        </scope>
        <scope startLine="1445" endLine="1447" />
        <declaration type="double" name="tmp1" />
        <scope startLine="1451" endLine="1474">
          <scope startLine="1454" endLine="1473">
            <scope startLine="1455" endLine="1472">
              <declaration type="double" name="tmp2" />
              <scope startLine="1457" endLine="1462">
                <declaration type="double" name="d1" />
              </scope>
              <scope startLine="1462" endLine="1467">
                <declaration type="double" name="d1" />
              </scope>
              <scope startLine="1467" endLine="1471">
                <declaration type="double" name="d1" />
              </scope>
            </scope>
          </scope>
        </scope>
        <declaration type="double" name="gw" />
        <scope startLine="1480" endLine="1495">
          <declaration type="double" name="glagValue" />
          <scope startLine="1482" endLine="1487">
            <declaration type="double" name="min" />
          </scope>
          <scope startLine="1487" endLine="1489" />
          <scope startLine="1489" endLine="1491" />
          <scope startLine="1491" endLine="1493" />
        </scope>
        <declaration type="double" name="curv" />
        <scope startLine="1503" endLine="1509">
          <declaration type="double" name="tmp" />
          <scope startLine="1505" endLine="1507" />
        </scope>
        <scope startLine="1510" endLine="1512" />
        <scope startLine="1514" endLine="1524">
          <declaration type="double" name="scale" />
          <scope startLine="1516" endLine="1520">
            <declaration type="double" name="tmp" />
          </scope>
          <declaration type="double" name="d1" />
        </scope>
        <scope startLine="1524" endLine="1528">
          <declaration type="double" name="d1" />
        </scope>
        <scope startLine="1534" endLine="1541">
          <scope startLine="1535" endLine="1538" />
        </scope>
        <scope startLine="1541" endLine="1543" />
        <comment>Computing 2nd power</comment>
        <comment>Investigate whether more components of W can be fixed.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Set the remaining free components of W and all components of XALT,</comment>
        <comment>except that W may be scaled later.</comment>
        <comment>Set CURV to the curvature of the KNEW-th Lagrange function along W.</comment>
        <comment>Scale W by a factor less than one if that can reduce the modulus of</comment>
        <comment>the Lagrange function at XOPT+W. Set CAUCHY to the final value of</comment>
        <comment>the square of this function.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>If IFLAG is zero, then XALT is calculated as before after reversing</comment>
        <comment>the sign of GLAG. Thus two XALT vectors become available. The one that</comment>
        <comment>is chosen is the one that gives the larger value of CAUCHY.</comment>
      </scope>
      <scope startLine="1545" endLine="1550">
        <scope startLine="1546" endLine="1548" />
      </scope>
      <comment>XXX</comment>
      <comment>Calculate the gradient of the KNEW-th Lagrange function at XOPT.</comment>
      <comment>Search for a large denominator along the straight lines through XOPT</comment>
      <comment>and another interpolation point. SLBD and SUBD will be lower and upper</comment>
      <comment>bounds on the step along each of these lines in turn. PREDSQ will be</comment>
      <comment>set to the square of the predicted denominator for each line. PRESAV</comment>
      <comment>will be set to the largest admissible value of PREDSQ that occurs.</comment>
      <comment>Construct XNEW in a way that satisfies the bound constraints exactly.</comment>
      <comment>Prepare for the iterative method that assembles the constrained Cauchy</comment>
      <comment>step in W. The sum of squares of the fixed components of W is formed in</comment>
      <comment>WFIXSQ, and the free components of W are set to BIGSTP.</comment>
      <comment>altmov</comment>
    </method>
    <javadoc>
      <text>* SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
 * BMAT and ZMAT for the first iteration, and it maintains the values of
 * NF and KOPT. The vector X is also changed by PRELIM.
 * The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the
 * same as the corresponding arguments in SUBROUTINE BOBYQA.
 * The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU
 * are the same as the corresponding arguments in BOBYQB, the elements
 * of SL and SU being set in BOBYQA.
 * GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but
 * it is set by PRELIM to the gradient of the quadratic model at XBASE.
 * If XOPT is nonzero, BOBYQB will change it to its usual value later.
 * NF is maintaned as the number of calls of CALFUN so far.
 * KOPT will be such that the least calculated value of F so far is at
 * the point XPT(KOPT,.)+XBASE in the space of the variables.</text>
      <param>lowerBound Lower bounds.</param>
      <param>upperBound Upper bounds.</param>
    </javadoc>
    <method type="void" name="prelim" startLine="1578" endLine="1748">
      <declaration type="int" name="n" />
      <declaration type="int" name="npt" />
      <declaration type="int" name="ndim" />
      <declaration type="double" name="rhosq" />
      <declaration type="double" name="recip" />
      <declaration type="int" name="np" />
      <scope startLine="1592" endLine="1600">
        <scope startLine="1594" endLine="1596" />
        <scope startLine="1597" endLine="1599" />
      </scope>
      <scope startLine="1601" endLine="1603" />
      <scope startLine="1604" endLine="1609">
        <scope startLine="1606" endLine="1608" />
      </scope>
      <declaration type="int" name="ipt" />
      <declaration type="int" name="jpt" />
      <declaration type="double" name="fbeg" />
      <scope startLine="1618" endLine="1747">
        <declaration type="int" name="nfm" />
        <declaration type="int" name="nfx" />
        <declaration type="int" name="nfmm" />
        <declaration type="int" name="nfxm" />
        <declaration type="double" name="stepa" />
        <declaration type="double" name="stepb" />
        <scope startLine="1625" endLine="1647">
          <scope startLine="1627" endLine="1634">
            <scope startLine="1629" endLine="1632" />
          </scope>
          <scope startLine="1634" endLine="1646">
            <scope startLine="1637" endLine="1640" />
            <scope startLine="1641" endLine="1644" />
          </scope>
        </scope>
        <scope startLine="1647" endLine="1661">
          <declaration type="int" name="tmp1" />
          <scope startLine="1651" endLine="1656">
            <declaration type="int" name="tmp2" />
          </scope>
          <declaration type="int" name="iptMinus1" />
          <declaration type="int" name="jptMinus1" />
        </scope>
        <scope startLine="1666" endLine="1676">
          <scope startLine="1670" endLine="1672" />
          <scope startLine="1673" endLine="1675" />
        </scope>
        <declaration type="double" name="objectiveValue" />
        <declaration type="double" name="f" />
        <declaration type="int" name="numEval" />
        <scope startLine="1683" endLine="1686" />
        <scope startLine="1686" endLine="1688" />
        <scope startLine="1696" endLine="1736">
          <scope startLine="1698" endLine="1707">
            <scope startLine="1700" endLine="1706">
              <declaration type="double" name="oneOverStepA" />
            </scope>
          </scope>
          <scope startLine="1707" endLine="1731">
            <declaration type="int" name="ih" />
            <declaration type="double" name="tmp" />
            <declaration type="double" name="diff" />
            <scope startLine="1713" endLine="1721">
              <scope startLine="1716" endLine="1718" />
            </scope>
          </scope>
        </scope>
        <scope startLine="1736" endLine="1746">
          <declaration type="int" name="ih" />
          <declaration type="double" name="tmp" />
        </scope>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>Calculate the next value of F. The least function value so far and</comment>
        <comment>its index are required.</comment>
        <comment>nfm + 1</comment>
        <comment>Set the nonzero initial elements of BMAT and the quadratic model in the</comment>
        <comment>cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions</comment>
        <comment>of the NF-th and (NF-N)-th interpolation points may be switched, in</comment>
        <comment>order that the function value at the first of them contributes to the</comment>
        <comment>off-diagonal second derivative terms of the initial quadratic model.</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
        <comment>zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip);  XXX "testAckley" and "testDiffPow" fail.</comment>
        <comment>Set the off-diagonal second derivatives of the Lagrange functions and</comment>
        <comment>the initial quadratic model.</comment>
        <comment>throw new PathIsExploredException();  XXX</comment>
      </scope>
      <comment>XXX</comment>
      <comment>Set XBASE to the initial vector of variables, and set the initial</comment>
      <comment>elements of XPT, BMAT, HQ, PQ and ZMAT to zero.</comment>
      <comment>Begin the initialization procedure. NF becomes one more than the number</comment>
      <comment>of function values so far. The coordinates of the displacement of the</comment>
      <comment>next initial interpolation point from XBASE are set in XPT(NF+1,.).</comment>
      <comment>prelim</comment>
    </method>
    <javadoc>
      <text>* A version of the truncated conjugate gradient is applied. If a line
 * search is restricted by a constraint, then the procedure is restarted,
 * the values of the variables that are at their bounds being fixed. If
 * the trust region boundary is reached, then further changes may be made
 * to D, each one being in the two dimensional space that is spanned
 * by the current D and the gradient of Q at XOPT+D, staying on the trust
 * region boundary. Termination occurs when the reduction in Q seems to
 * be close to the greatest reduction that can be achieved.
 * The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same
 * meanings as the corresponding arguments of BOBYQB.
 * DELTA is the trust region radius for the present calculation, which
 * seeks a small value of the quadratic model within distance DELTA of
 * XOPT subject to the bounds on the variables.
 * XNEW will be set to a new vector of variables that is approximately
 * the one that minimizes the quadratic model within the trust region
 * subject to the SL and SU constraints on the variables. It satisfies
 * as equations the bounds that become active during the calculation.
 * D is the calculated trial step from XOPT, generated iteratively from an
 * initial value of zero. Thus XNEW is XOPT+D after the final iteration.
 * GNEW holds the gradient of the quadratic model at XOPT+D. It is updated
 * when D is updated.
 * xbdi.get( is a working space vector. For I=1,2,...,N, the element xbdi.get((I) is
 * set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the
 * I-th variable has become fixed at a bound, the bound being SL(I) or
 * SU(I) in the case xbdi.get((I)=-1.0 or xbdi.get((I)=1.0, respectively. This
 * information is accumulated during the construction of XNEW.
 * The arrays S, HS and HRED are also used for working space. They hold the
 * current search direction, and the changes in the gradient of Q along S
 * and the reduced D, respectively, where the reduced D is the same as D,
 * except that the components of the fixed variables are zero.
 * DSQ will be set to the square of the length of XNEW-XOPT.
 * CRVMIN is set to zero if D reaches the trust region boundary. Otherwise
 * it is set to the least curvature of H that occurs in the conjugate
 * gradient searches that are not restricted by any constraints. The
 * value CRVMIN=-1.0D0 is set, however, if all of these searches are
 * constrained.</text>
      <param>delta</param>
      <param>gnew</param>
      <param>xbdi</param>
      <param>s</param>
      <param>hs</param>
      <param>hred</param>
    </javadoc>
    <method type="double[]" name="trsbox" startLine="1804" endLine="2270">
      <declaration type="int" name="n" />
      <declaration type="int" name="npt" />
      <declaration type="double" name="dsq" />
      <declaration type="double" name="crvmin" />
      <declaration type="double" name="ds" />
      <declaration type="int" name="iu" />
      <declaration type="double" name="dhd" />
      <declaration type="int" name="iact" />
      <declaration type="int" name="nact" />
      <declaration type="double" name="angt" />
      <declaration type="int" name="isav" />
      <declaration type="double" name="temp" />
      <declaration type="int" name="iterc" />
      <declaration type="double" name="resid" />
      <declaration type="int" name="itcsav" />
      <declaration type="double" name="rdprev" />
      <declaration type="int" name="itermax" />
      <scope startLine="1842" endLine="1857">
        <scope startLine="1844" endLine="1848">
          <scope startLine="1845" endLine="1847" />
        </scope>
        <scope startLine="1849" endLine="1851" />
        <scope startLine="1852" endLine="1854" />
      </scope>
      <declaration type="int" name="state" />
      <scope startLine="1869" endLine="2269">
        <scope startLine="1871" endLine="1874" />
        <scope startLine="1875" endLine="1907">
          <scope startLine="1878" endLine="1889">
            <scope startLine="1879" endLine="1881" />
            <scope startLine="1881" endLine="1883" />
            <scope startLine="1883" endLine="1885" />
            <declaration type="double" name="d1" />
          </scope>
          <scope startLine="1890" endLine="1892" />
          <scope startLine="1893" endLine="1896" />
          <scope startLine="1897" endLine="1899" />
        </scope>
        <scope startLine="1908" endLine="2015">
          <scope startLine="1913" endLine="1921">
            <scope startLine="1914" endLine="1920">
              <declaration type="double" name="d1" />
            </scope>
          </scope>
          <scope startLine="1922" endLine="1924" />
          <scope startLine="1926" endLine="1928" />
          <scope startLine="1928" endLine="1930" />
          <scope startLine="1932" endLine="1935" />
          <scope startLine="1941" endLine="1954">
            <scope startLine="1942" endLine="1953">
              <scope startLine="1944" endLine="1946" />
              <scope startLine="1946" endLine="1948" />
              <scope startLine="1949" endLine="1952" />
            </scope>
          </scope>
          <scope startLine="1959" endLine="1983">
            <scope startLine="1962" endLine="1967">
              <scope startLine="1964" endLine="1966" />
            </scope>
            <scope startLine="1970" endLine="1978">
              <scope startLine="1972" endLine="1976">
                <declaration type="double" name="d1" />
              </scope>
            </scope>
            <declaration type="double" name="d1" />
          </scope>
          <scope startLine="1987" endLine="2000">
            <scope startLine="1990" endLine="1992" />
            <declaration type="double" name="d1" />
            <scope startLine="1996" endLine="1998" />
          </scope>
          <scope startLine="2005" endLine="2014">
            <scope startLine="2006" endLine="2008" />
            <scope startLine="2009" endLine="2011" />
          </scope>
        </scope>
        <scope startLine="2016" endLine="2024" />
        <scope startLine="2025" endLine="2051">
          <scope startLine="2027" endLine="2029" />
          <scope startLine="2033" endLine="2046">
            <scope startLine="2034" endLine="2043">
              <declaration type="double" name="d1" />
            </scope>
            <scope startLine="2043" endLine="2045" />
          </scope>
        </scope>
        <scope startLine="2052" endLine="2122">
          <scope startLine="2056" endLine="2058" />
          <scope startLine="2060" endLine="2066">
            <scope startLine="2061" endLine="2063" />
            <scope startLine="2063" endLine="2065" />
          </scope>
          <scope startLine="2076" endLine="2117">
            <scope startLine="2077" endLine="2116">
              <scope startLine="2080" endLine="2084" />
              <scope startLine="2084" endLine="2088" />
              <declaration type="double" name="d1" />
              <declaration type="double" name="d2" />
              <scope startLine="2097" endLine="2104">
                <scope startLine="2099" endLine="2103" />
              </scope>
              <scope startLine="2108" endLine="2115">
                <scope startLine="2110" endLine="2114" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope startLine="2123" endLine="2207">
          <scope startLine="2128" endLine="2134">
            <scope startLine="2129" endLine="2133" />
          </scope>
          <scope startLine="2144" endLine="2157">
            <scope startLine="2149" endLine="2153" />
            <scope startLine="2153" endLine="2155" />
          </scope>
          <scope startLine="2162" endLine="2164" />
          <scope startLine="2165" endLine="2168" />
          <scope startLine="2173" endLine="2175" />
          <scope startLine="2183" endLine="2193">
            <scope startLine="2185" endLine="2191">
              <declaration type="double" name="d1" />
            </scope>
          </scope>
          <scope startLine="2195" endLine="2199" />
          <scope startLine="2204" endLine="2206" />
        </scope>
        <scope startLine="2208" endLine="2233">
          <scope startLine="2211" endLine="2227">
            <declaration type="double" name="min" />
            <scope startLine="2217" endLine="2219" />
            <scope startLine="2220" endLine="2222" />
            <declaration type="double" name="d1" />
          </scope>
        </scope>
        <scope startLine="2234" endLine="2265">
          <declaration type="int" name="ih" />
          <scope startLine="2237" endLine="2246">
            <scope startLine="2239" endLine="2245">
              <scope startLine="2240" endLine="2242" />
            </scope>
          </scope>
          <declaration type="RealVector" name="tmp" />
          <scope startLine="2248" endLine="2254">
            <scope startLine="2249" endLine="2253">
              <scope startLine="2250" endLine="2252" />
            </scope>
          </scope>
          <scope startLine="2255" endLine="2257" />
          <scope startLine="2258" endLine="2260" />
          <scope startLine="2261" endLine="2263" />
        </scope>
        <scope startLine="2266" endLine="2268" />
        <comment>XXX</comment>
        <comment>XXX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Multiply the search direction by the second derivative matrix of Q and</comment>
        <comment>calculate some scalars for the choice of steplength. Then set BLEN to</comment>
        <comment>the length of the the step to the trust region boundary and STPLEN to</comment>
        <comment>the steplength, ignoring the simple bounds.</comment>
        <comment>XXX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MIN</comment>
        <comment>Reduce STPLEN if necessary in order to preserve the simple bounds,</comment>
        <comment>letting IACT be the index of the new constrained variable.</comment>
        <comment>Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing MAX</comment>
        <comment>Restart the conjugate gradient method if it has hit a new bound.</comment>
        <comment>Computing 2nd power</comment>
        <comment>If STPLEN is less than BLEN, then either apply another conjugate</comment>
        <comment>gradient iteration or RETURN.</comment>
        <comment>XXX</comment>
        <comment>Prepare for the alternative iteration by calculating some scalars</comment>
        <comment>and by multiplying the reduced D by the second derivative matrix of</comment>
        <comment>Q, where S holds the reduced D in the call of GGMULT.</comment>
        <comment>XXX</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Let the search direction S be a linear combination of the reduced D</comment>
        <comment>and the reduced G that is orthogonal to the reduced D.</comment>
        <comment>XXX</comment>
        <comment>By considering the simple bounds on the variables, calculate an upper</comment>
        <comment>bound on the tangent of half the angle of the alternative iteration,</comment>
        <comment>namely ANGBD, except that, if already a free variable has reached a</comment>
        <comment>bound, there is a branch back to label 100 after fixing that variable.</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
        <comment>Calculate HHD and some curvatures for the alternative iteration.</comment>
        <comment>XXX</comment>
        <comment>Seek the greatest reduction in Q for a range of equally spaced values</comment>
        <comment>of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of</comment>
        <comment>the alternative iteration.</comment>
        <comment>Return if the reduction is zero. Otherwise, set the sine and cosine</comment>
        <comment>of the angle of the alternative iteration, and calculate SDEC.</comment>
        <comment>Update GNEW, D and HRED. If the angle of the alternative iteration</comment>
        <comment>is restricted by a bound on a free variable, that variable is fixed</comment>
        <comment>at the bound.</comment>
        <comment>Computing 2nd power</comment>
        <comment>If SDEC is sufficiently small, then RETURN after setting XNEW to</comment>
        <comment>XOPT+D, giving careful attention to the bounds.</comment>
        <comment>XXX</comment>
        <comment>Computing MAX</comment>
        <comment>Computing MIN</comment>
        <comment>Computing 2nd power</comment>
        <comment>The following instructions multiply the current S-vector by the second</comment>
        <comment>derivative matrix of the quadratic model, putting the product in HS.</comment>
        <comment>They are reached from three different parts of the software above and</comment>
        <comment>they can be regarded as an external subroutine.</comment>
        <comment>XXX</comment>
      </scope>
      <comment>XXX</comment>
      <comment>Local variables</comment>
      <comment>Set some constants.</comment>
      <comment>Function Body</comment>
      <comment>The sign of GOPT(I) gives the sign of the change to the I-th variable</comment>
      <comment>that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether</comment>
      <comment>or not to fix the I-th variable at one of its bounds initially, with</comment>
      <comment>NACT being set to the number of fixed variables. D and GNEW are also</comment>
      <comment>set for the first iteration. DELSQ is the upper bound on the sum of</comment>
      <comment>squares of the free variables. QRED is the reduction in Q so far.</comment>
      <comment>Set the next search direction of the conjugate gradient method. It is</comment>
      <comment>the steepest descent direction initially and when the iterations are</comment>
      <comment>restarted because a variable has just been fixed by a bound, and of</comment>
      <comment>course the components of the fixed variables are zero. ITERMAX is an</comment>
      <comment>upper bound on the indices of the conjugate gradient iterations.</comment>
      <comment>trsbox</comment>
    </method>
    <javadoc>
      <text>* The arrays BMAT and ZMAT are updated, as required by the new position
 * of the interpolation point that has the index KNEW. The vector VLAG has
 * N+NPT components, set on entry to the first NPT and last N components
 * of the product Hw in equation (4.11) of the Powell (2006) paper on
 * NEWUOA. Further, BETA is set on entry to the value of the parameter
 * with that name, and DENOM is set to the denominator of the updating
 * formula. Elements of ZMAT may be treated as zero if their moduli are
 * at most ZTEST. The first NDIM elements of W are used for working space.</text>
      <param>beta</param>
      <param>denom</param>
      <param>knew</param>
    </javadoc>
    <method type="void" name="update" startLine="2291" endLine="2366">
      <declaration type="int" name="n" />
      <declaration type="int" name="npt" />
      <declaration type="int" name="nptm" />
      <declaration type="ArrayRealVector" name="work" />
      <declaration type="double" name="ztest" />
      <scope startLine="2302" endLine="2307">
        <scope startLine="2303" endLine="2306" />
        <comment>Computing MAX</comment>
      </scope>
      <scope startLine="2312" endLine="2329">
        <declaration type="double" name="d1" />
        <scope startLine="2314" endLine="2327">
          <declaration type="double" name="d2" />
          <declaration type="double" name="d3" />
          <declaration type="double" name="d4" />
          <declaration type="double" name="d5" />
          <declaration type="double" name="d6" />
          <scope startLine="2322" endLine="2326">
            <declaration type="double" name="d7" />
          </scope>
        </scope>
        <comment>Computing 2nd power</comment>
        <comment>Computing 2nd power</comment>
      </scope>
      <scope startLine="2334" endLine="2336" />
      <declaration type="double" name="alpha" />
      <declaration type="double" name="tau" />
      <declaration type="double" name="sqrtDenom" />
      <declaration type="double" name="d1" />
      <declaration type="double" name="d2" />
      <scope startLine="2346" endLine="2349" />
      <scope startLine="2353" endLine="2365">
        <declaration type="int" name="jp" />
        <declaration type="double" name="d3" />
        <declaration type="double" name="d4" />
        <scope startLine="2358" endLine="2364">
          <scope startLine="2361" endLine="2363" />
        </scope>
      </scope>
      <comment>XXX</comment>
      <comment>XXX Should probably be split into two arrays.</comment>
      <comment>Apply the rotations that put zeros in the KNEW-th row of ZMAT.</comment>
      <comment>Put the first NPT components of the KNEW-th column of HLAG into W,</comment>
      <comment>and calculate the parameters of the updating formula.</comment>
      <comment>Complete the updating of ZMAT.</comment>
      <comment>Finally, update the matrix BMAT.</comment>
      <comment>update</comment>
    </method>
    <javadoc>
      <text>* Performs validity checks.</text>
      <param>lowerBound Lower bounds (constraints) of the objective variables.</param>
      <param>upperBound Upperer bounds (constraints) of the objective variables.</param>
    </javadoc>
    <method type="void" name="setup" startLine="2375" endLine="2427">
      <declaration type="double[]" name="init" />
      <declaration type="int" name="dimension" />
      <scope startLine="2382" endLine="2384" />
      <declaration type="int[]" name="nPointsInterval" />
      <scope startLine="2388" endLine="2393" />
      <declaration type="double" name="requiredMinDiff" />
      <declaration type="double" name="minDiff" />
      <scope startLine="2400" endLine="2403" />
      <scope startLine="2404" endLine="2406" />
      <comment>XXX</comment>
      <comment>Check problem dimension.</comment>
      <comment>Check number of interpolation points.</comment>
      <comment>Initialize bound differences.</comment>
      <comment>Initialize the data structures used by the "bobyqa" method.</comment>
    </method>
    <method type="String" name="caller" startLine="2430" endLine="2435">
      <declaration type="Throwable" name="t" />
      <declaration type="StackTraceElement[]" name="elements" />
      <declaration type="StackTraceElement" name="e" />
    </method>
    <method type="void" name="printState" startLine="2437" endLine="2439">
      <comment>System.out.println(caller(2) + ": state " + s);</comment>
    </method>
    <method type="void" name="printMethod" startLine="2441" endLine="2443">
      <comment>System.out.println(caller(2));</comment>
    </method>
    <class name="PathIsExploredException" extends="RuntimeException" startLine="2445">
      <javadoc>
        <text>* Marker for code paths that are not explored with the current unit tests.
 * If the path becomes explored, it should just be removed from the code.</text>
      </javadoc>
      <declaration type="long" name="serialVersionUID" />
      <declaration type="String" name="PATH_IS_EXPLORED" />
      <method type="constructor" name="PathIsExploredException" startLine="2455" endLine="2457" />
    </class>
    <comment>----------------------------------------------------------------------------------------</comment>
    <comment>----------------------------------------------------------------------------------------</comment>
    <comment>----------------------------------------------------------------------------------------</comment>
    <comment>----------------------------------------------------------------------------------------</comment>
    <comment>----------------------------------------------------------------------------------------</comment>
    <comment>XXX utility for figuring out call sequence.</comment>
    <comment>XXX utility for figuring out call sequence.</comment>
    <comment>XXX utility for figuring out call sequence.</comment>
    <comment>CHECKSTYLE: resume all</comment>
  </class>
</source>
