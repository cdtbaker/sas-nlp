<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.io.Serializable" />
  <import name="java.util.Arrays" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.MathInternalError" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.NotStrictlyPositiveException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="ResizableDoubleArray" startLine="30">
    <implements name="DoubleArray" />
    <implements name="Serializable" />
    <javadoc>
      <text>* <p>
 * A variable length {@link DoubleArray} implementation that automatically
 * handles expanding and contracting its internal storage array as elements
 * are added and removed.
 * </p>
 * <h3>Important note: Usage should not assume that this class is thread-safe
 * even though some of the methods are {@code synchronized}.
 * This qualifier will be dropped in the next major release (4.0).</h3>
 * <p>
 * The internal storage array starts with capacity determined by the{@code initialCapacity} property, which can be set by the constructor.
 * The default initial capacity is 16.  Adding elements using{@link #addElement(double)} appends elements to the end of the array.
 * When there are no open entries at the end of the internal storage array,
 * the array is expanded.  The size of the expanded array depends on the{@code expansionMode} and {@code expansionFactor} properties.
 * The {@code expansionMode} determines whether the size of the array is
 * multiplied by the {@code expansionFactor}({@link ExpansionMode#MULTIPLICATIVE}) or if the expansion is additive
 * ({@link ExpansionMode#ADDITIVE} -- {@code expansionFactor} storage
 * locations added).
 * The default {@code expansionMode} is {@code MULTIPLICATIVE} and the default{@code expansionFactor} is 2.
 * </p>
 * <p>
 * The {@link #addElementRolling(double)} method adds a new element to the end
 * of the internal storage array and adjusts the "usable window" of the
 * internal array forward by one position (effectively making what was the
 * second element the first, and so on).  Repeated activations of this method
 * (or activation of {@link #discardFrontElements(int)}) will effectively orphan
 * the storage locations at the beginning of the internal storage array.  To
 * reclaim this storage, each time one of these methods is activated, the size
 * of the internal storage array is compared to the number of addressable
 * elements (the {@code numElements} property) and if the difference
 * is too large, the internal array is contracted to size{@code numElements + 1}.  The determination of when the internal
 * storage array is "too large" depends on the {@code expansionMode} and{@code contractionFactor} properties.  If  the {@code expansionMode}is {@code MULTIPLICATIVE}, contraction is triggered when the
 * ratio between storage array length and {@code numElements} exceeds{@code contractionFactor.}  If the {@code expansionMode}is {@code ADDITIVE}, the number of excess storage locations
 * is compared to {@code contractionFactor}.
 * </p>
 * <p>
 * To avoid cycles of expansions and contractions, the{@code expansionFactor} must not exceed the {@code contractionFactor}.
 * Constructors and mutators for both of these properties enforce this
 * requirement, throwing a {@code MathIllegalArgumentException} if it is
 * violated.
 * </p></text>
      <version>$Id: ResizableDoubleArray.java 1462504 2013-03-29 15:48:57Z luc $</version>
    </javadoc>
    <javadoc>
      <text>* Additive expansion mode.</text>
      <deprecated>As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.</deprecated>
    </javadoc>
    <declaration type="int" name="ADDITIVE_MODE" />
    <javadoc>
      <text>* Multiplicative expansion mode.</text>
      <deprecated>As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.</deprecated>
    </javadoc>
    <declaration type="int" name="MULTIPLICATIVE_MODE" />
    <javadoc>
      <text>* Serializable version identifier.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Default value for initial capacity.</text>
    </javadoc>
    <declaration type="int" name="DEFAULT_INITIAL_CAPACITY" />
    <javadoc>
      <text>* Default value for array size modifier.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_EXPANSION_FACTOR" />
    <javadoc>
      <text>* Default value for the difference between {@link #contractionCriterion}and {@link #expansionFactor}.</text>
    </javadoc>
    <declaration type="double" name="DEFAULT_CONTRACTION_DELTA" />
    <javadoc>
      <text>* The contraction criteria determines when the internal array will be
 * contracted to fit the number of elements contained in the element
 * array + 1.</text>
    </javadoc>
    <declaration type="double" name="contractionCriterion" />
    <javadoc>
      <text>* The expansion factor of the array.  When the array needs to be expanded,
 * the new array size will be{@code internalArray.length * expansionFactor}if {@code expansionMode} is set to MULTIPLICATIVE_MODE, or{@code internalArray.length + expansionFactor} if{@code expansionMode} is set to ADDITIVE_MODE.</text>
    </javadoc>
    <declaration type="double" name="expansionFactor" />
    <javadoc>
      <text>* Determines whether array expansion by {@code expansionFactor}is additive or multiplicative.</text>
    </javadoc>
    <declaration type="ExpansionMode" name="expansionMode" />
    <javadoc>
      <text>* The internal storage array.</text>
    </javadoc>
    <declaration type="double[]" name="internalArray" />
    <javadoc>
      <text>* The number of addressable elements in the array.  Note that this
 * has nothing to do with the length of the internal storage array.</text>
    </javadoc>
    <declaration type="int" name="numElements" />
    <javadoc>
      <text>* The position of the first addressable element in the internal storage
 * array.  The addressable elements in the array are{@code internalArray[startIndex],...,internalArray[startIndex + numElements - 1]}.</text>
    </javadoc>
    <declaration type="int" name="startIndex" />
    <javadoc>
      <text>* Specification of expansion algorithm.</text>
      <since>3.1</since>
    </javadoc>
    <javadoc>
      <text>* Multiplicative expansion mode.</text>
    </javadoc>
    <javadoc>
      <text>* Additive expansion mode.</text>
    </javadoc>
    <javadoc>
      <text>* Creates an instance with default properties.
 * <ul>
 * <li>{@code initialCapacity = 16}</li>
 * <li>{@code expansionMode = MULTIPLICATIVE}</li>
 * <li>{@code expansionFactor = 2.0}</li>
 * <li>{@code contractionCriterion = 2.5}</li>
 * </ul></text>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="169" endLine="171" />
    <javadoc>
      <text>* Creates an instance with the specified initial capacity.
 * Other properties take default values:
 * <ul>
 * <li>{@code expansionMode = MULTIPLICATIVE}</li>
 * <li>{@code expansionFactor = 2.0}</li>
 * <li>{@code contractionCriterion = 2.5}</li>
 * </ul></text>
      <param>initialCapacity Initial size of the internal storage array.</param>
      <throws>MathIllegalArgumentException if {@code initialCapacity <= 0}.</throws>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="185" endLine="187" />
    <javadoc>
      <text>* Creates an instance from an existing {@code double[]} with the
 * initial capacity and numElements corresponding to the size of
 * the supplied {@code double[]} array.
 * If the supplied array is null, a new empty array with the default
 * initial capacity will be created.
 * The input array is copied, not referenced.
 * Other properties take default values:
 * <ul>
 * <li>{@code initialCapacity = 16}</li>
 * <li>{@code expansionMode = MULTIPLICATIVE}</li>
 * <li>{@code expansionFactor = 2.0}</li>
 * <li>{@code contractionCriterion = 2.5}</li>
 * </ul></text>
      <param>initialArray initial array</param>
      <since>2.2</since>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="207" endLine="213" />
    <javadoc>
      <text>* Creates an instance with the specified initial capacity
 * and expansion factor.
 * The remaining properties take default values:
 * <ul>
 * <li>{@code expansionMode = MULTIPLICATIVE}</li>
 * <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>
 * </ul>
 * <br/>
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * <ul>
 * <li>{@code initialCapacity > 0}</li>
 * <li>{@code expansionFactor > 1}</li>
 * </ul></text>
      <param>initialCapacity Initial size of the internal storage array.</param>
      <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
      <throws>MathIllegalArgumentException if parameters are not valid.</throws>
      <deprecated>As of 3.1. Please use{@link #ResizableDoubleArray(int,double)} instead.</deprecated>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="241" endLine="244" />
    <javadoc>
      <text>* Creates an instance with the specified initial capacity
 * and expansion factor.
 * The remaining properties take default values:
 * <ul>
 * <li>{@code expansionMode = MULTIPLICATIVE}</li>
 * <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>
 * </ul>
 * <br/>
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * <ul>
 * <li>{@code initialCapacity > 0}</li>
 * <li>{@code expansionFactor > 1}</li>
 * </ul></text>
      <param>initialCapacity Initial size of the internal storage array.</param>
      <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
      <throws>MathIllegalArgumentException if parameters are not valid.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="270" endLine="274" />
    <javadoc>
      <text>* Creates an instance with the specified initialCapacity,
 * expansionFactor, and contractionCriterion.
 * The expansion mode will default to {@code MULTIPLICATIVE}.
 * <br/>
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * <ul>
 * <li>{@code initialCapacity > 0}</li>
 * <li>{@code expansionFactor > 1}</li>
 * <li>{@code contractionCriterion >= expansionFactor}</li>
 * </ul></text>
      <param>initialCapacity Initial size of the internal storage array..</param>
      <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
      <param>contractionCriteria Contraction criteria.</param>
      <throws>MathIllegalArgumentException if parameters are not valid.</throws>
      <deprecated>As of 3.1. Please use{@link #ResizableDoubleArray(int,double,double)} instead.</deprecated>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="301" endLine="305" />
    <javadoc>
      <text>* Creates an instance with the specified initial capacity,
 * expansion factor, and contraction criteria.
 * The expansion mode will default to {@code MULTIPLICATIVE}.
 * <br/>
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * <ul>
 * <li>{@code initialCapacity > 0}</li>
 * <li>{@code expansionFactor > 1}</li>
 * <li>{@code contractionCriterion >= expansionFactor}</li>
 * </ul></text>
      <param>initialCapacity Initial size of the internal storage array..</param>
      <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
      <param>contractionCriterion Contraction criterion.</param>
      <throws>MathIllegalArgumentException if the parameters are not valid.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="330" endLine="336" />
    <javadoc>
      <text>* <p>
 * Create a ResizableArray with the specified properties.</p>
 * <p>
 * Throws IllegalArgumentException if the following conditions are
 * not met:
 * <ul>
 * <li><code>initialCapacity > 0</code></li>
 * <li><code>expansionFactor > 1</code></li>
 * <li><code>contractionFactor >= expansionFactor</code></li>
 * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>
 * </li>
 * </ul></p></text>
      <param>initialCapacity the initial size of the internal storage array</param>
      <param>expansionFactor the array will be expanded based on this
 * parameter</param>
      <param>contractionCriteria the contraction Criteria</param>
      <param>expansionMode  the expansion mode</param>
      <throws>MathIllegalArgumentException if parameters are not valid</throws>
      <deprecated>As of 3.1. Please use{@link #ResizableDoubleArray(int,double,double,ExpansionMode,double[])}instead.</deprecated>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="363" endLine="374">
      <comment>XXX Just ot retain the expected failure in a unit test.</comment>
      <comment>With the new "enum", that test will become obsolete.</comment>
    </method>
    <javadoc>
      <text>* Creates an instance with the specified properties.
 * <br/>
 * Throws MathIllegalArgumentException if the following conditions are
 * not met:
 * <ul>
 * <li>{@code initialCapacity > 0}</li>
 * <li>{@code expansionFactor > 1}</li>
 * <li>{@code contractionCriterion >= expansionFactor}</li>
 * </ul></text>
      <param>initialCapacity Initial size of the internal storage array.</param>
      <param>expansionFactor The array will be expanded based on this
 * parameter.</param>
      <param>contractionCriterion Contraction criteria.</param>
      <param>expansionMode Expansion mode.</param>
      <param>data Initial contents of the array.</param>
      <throws>MathIllegalArgumentException if the parameters are not valid.</throws>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="400" endLine="417">
      <scope startLine="401" endLine="404" />
      <scope startLine="414" endLine="416" />
    </method>
    <javadoc>
      <text>* Copy constructor.  Creates a new ResizableDoubleArray that is a deep,
 * fresh copy of the original. Needs to acquire synchronization lock
 * on original.  Original may not be null; otherwise a {@link NullArgumentException}is thrown.</text>
      <param>original array to copy</param>
      <exception>NullArgumentException if original is null</exception>
      <since>2.0</since>
    </javadoc>
    <method type="constructor" name="ResizableDoubleArray" startLine="430" endLine="433" />
    <javadoc>
      <text>* Adds an element to the end of this expandable array.</text>
      <param>value Value to be added to end of array.</param>
    </javadoc>
    <method type="void" name="addElement" startLine="440" endLine="445">
      <scope startLine="441" endLine="443" />
    </method>
    <javadoc>
      <text>* Adds several element to the end of this expandable array.</text>
      <param>values Values to be added to end of array.</param>
      <since>2.2</since>
    </javadoc>
    <method type="void" name="addElements" startLine="453" endLine="460">
      <declaration type="double[]" name="tempArray" />
    </method>
    <javadoc>
      <text>* <p>
 * Adds an element to the end of the array and removes the first
 * element in the array.  Returns the discarded first element.
 * The effect is similar to a push operation in a FIFO queue.
 * </p>
 * <p>
 * Example: If the array contains the elements 1, 2, 3, 4 (in that order)
 * and addElementRolling(5) is invoked, the result is an array containing
 * the entries 2, 3, 4, 5 and the value returned is 1.
 * </p></text>
      <param>value Value to be added to the array.</param>
      <return>the value which has been discarded or "pushed" out of the array
 * by this rolling insert.</return>
    </javadoc>
    <method type="double" name="addElementRolling" startLine="478" endLine="495">
      <declaration type="double" name="discarded" />
      <scope startLine="481" endLine="483" />
      <scope startLine="491" endLine="493" />
      <comment>Increment the start index</comment>
      <comment>Add the new value</comment>
      <comment>Check the contraction criterion.</comment>
    </method>
    <javadoc>
      <text>* Substitutes <code>value</code> for the most recently added value.
 * Returns the value that has been replaced. If the array is empty (i.e.
 * if {@link #numElements} is zero), an IllegalStateException is thrown.</text>
      <param>value New value to substitute for the most recently added value</param>
      <return>the value that has been replaced in the array.</return>
      <throws>MathIllegalStateException if the array is empty</throws>
      <since>2.0</since>
    </javadoc>
    <method type="double" name="substituteMostRecentElement" startLine="508" endLine="520">
      <scope startLine="509" endLine="512" />
      <declaration type="int" name="substIndex" />
      <declaration type="double" name="discarded" />
    </method>
    <javadoc>
      <text>* Checks the expansion factor and the contraction criterion and throws an
 * IllegalArgumentException if the contractionCriteria is less than the
 * expansionCriteria</text>
      <param>expansion factor to be checked</param>
      <param>contraction criteria to be checked</param>
      <throws>MathIllegalArgumentException if the contractionCriteria is less than
 * the expansionCriteria.</throws>
      <deprecated>As of 3.1. Please use{@link #checkContractExpand(double,double)} instead.</deprecated>
    </javadoc>
    <method type="void" name="checkContractExpand" startLine="535" endLine="538" />
    <javadoc>
      <text>* Checks the expansion factor and the contraction criterion and raises
 * an exception if the contraction criterion is smaller than the
 * expansion criterion.</text>
      <param>contraction Criterion to be checked.</param>
      <param>expansion Factor to be checked.</param>
      <throws>NumberIsTooSmallException if {@code contraction < expansion}.</throws>
      <throws>NumberIsTooSmallException if {@code contraction <= 1}.</throws>
      <throws>NumberIsTooSmallException if {@code expansion <= 1 }.</throws>
      <since>3.1</since>
    </javadoc>
    <method type="void" name="checkContractExpand" startLine="554" endLine="575">
      <scope startLine="555" endLine="560">
        <declaration type="NumberIsTooSmallException" name="e" />
      </scope>
      <scope startLine="562" endLine="567">
        <declaration type="NumberIsTooSmallException" name="e" />
      </scope>
      <scope startLine="569" endLine="574">
        <declaration type="NumberIsTooSmallException" name="e" />
      </scope>
    </method>
    <javadoc>
      <text>* Clear the array contents, resetting the number of elements to zero.</text>
    </javadoc>
    <method type="void" name="clear" startLine="580" endLine="583" />
    <javadoc>
      <text>* Contracts the storage array to the (size of the element set) + 1 - to
 * avoid a zero length array. This function also resets the startIndex to
 * zero.</text>
    </javadoc>
    <method type="void" name="contract" startLine="590" endLine="599">
      <declaration type="double[]" name="tempArray" />
      <comment>Copy and swap - copy only the element array from the src array.</comment>
      <comment>Reset the start index to zero</comment>
    </method>
    <javadoc>
      <text>* Discards the <code>i</code> initial elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * <code>discardFrontElements(2)</code> will cause the first two elements
 * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.</text>
      <param>i  the number of elements to discard from the front of the array</param>
      <throws>MathIllegalArgumentException if i is greater than numElements.</throws>
      <since>2.0</since>
    </javadoc>
    <method type="void" name="discardFrontElements" startLine="613" endLine="615" />
    <javadoc>
      <text>* Discards the <code>i</code> last elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * <code>discardMostRecentElements(2)</code> will cause the last two elements
 * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.</text>
      <param>i  the number of elements to discard from the end of the array</param>
      <throws>MathIllegalArgumentException if i is greater than numElements.</throws>
      <since>2.0</since>
    </javadoc>
    <method type="void" name="discardMostRecentElements" startLine="629" endLine="631" />
    <javadoc>
      <text>* Discards the <code>i</code> first or last elements of the array,
 * depending on the value of <code>front</code>.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * <code>discardExtremeElements(2,false)</code> will cause the last two elements
 * to be discarded, leaving 1,2 in the array.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * <code>discardExtremeElements(2,true)</code> will cause the first two elements
 * to be discarded, leaving 3,4 in the array.
 * Throws illegalArgumentException
 * if i exceeds numElements.</text>
      <param>i  the number of elements to discard from the front/end of the array</param>
      <param>front true if elements are to be discarded from the front
 * of the array, false if elements are to be discarded from the end
 * of the array</param>
      <throws>MathIllegalArgumentException if i is greater than numElements.</throws>
      <since>2.0</since>
    </javadoc>
    <method type="void" name="discardExtremeElements" startLine="654" endLine="673">
      <scope startLine="655" endLine="659" />
      <scope startLine="659" endLine="663" />
      <scope startLine="663" endLine="669">
        <scope startLine="666" endLine="668" />
        <comment>"Subtract" this number of discarded from numElements</comment>
      </scope>
      <scope startLine="670" endLine="672" />
    </method>
    <javadoc>
      <text>* Expands the internal storage array using the expansion factor.
 * <p>
 * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,
 * the new array size will be <code>internalArray.length * expansionFactor.</code>
 * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length
 * after expansion will be <code>internalArray.length + expansionFactor</code>
 * </p></text>
    </javadoc>
    <method type="void" name="expand" startLine="684" endLine="701">
      <declaration type="int" name="newSize" />
      <scope startLine="691" endLine="693" />
      <scope startLine="693" endLine="695" />
      <declaration type="double[]" name="tempArray" />
      <comment>notice the use of FastMath.ceil(), this guarantees that we will always</comment>
      <comment>have an array of at least currentSize + 1.   Assume that the</comment>
      <comment>current initial capacity is 1 and the expansion factor</comment>
      <comment>is 1.000000000000000001.  The newly calculated size will be</comment>
      <comment>rounded up to 2 after the multiplication is performed.</comment>
      <comment>Copy and swap</comment>
    </method>
    <javadoc>
      <text>* Expands the internal storage array to the specified size.</text>
      <param>size Size of the new internal storage array.</param>
    </javadoc>
    <method type="void" name="expandTo" startLine="708" endLine="713">
      <declaration type="double[]" name="tempArray" />
      <comment>Copy and swap</comment>
    </method>
    <javadoc>
      <text>* The contraction criteria defines when the internal array will contract
 * to store only the number of elements in the element array.
 * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,
 * contraction is triggered when the ratio between storage array length
 * and <code>numElements</code> exceeds <code>contractionFactor</code>.
 * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the
 * number of excess storage locations is compared to
 * <code>contractionFactor.</code></text>
      <return>the contraction criteria used to reclaim memory.</return>
      <deprecated>As of 3.1. Please use {@link #getContractionCriterion()}instead.</deprecated>
    </javadoc>
    <method type="float" name="getContractionCriteria" startLine="730" endLine="732" />
    <javadoc>
      <text>* The contraction criterion defines when the internal array will contract
 * to store only the number of elements in the element array.
 * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,
 * contraction is triggered when the ratio between storage array length
 * and <code>numElements</code> exceeds <code>contractionFactor</code>.
 * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the
 * number of excess storage locations is compared to
 * <code>contractionFactor.</code></text>
      <return>the contraction criterion used to reclaim memory.</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="getContractionCriterion" startLine="747" endLine="749" />
    <javadoc>
      <text>* Returns the element at the specified index</text>
      <param>index index to fetch a value from</param>
      <return>value stored at the specified index</return>
      <throws>ArrayIndexOutOfBoundsException if <code>index</code> is less than
 * zero or is greater than <code>getNumElements() - 1</code>.</throws>
    </javadoc>
    <method type="double" name="getElement" startLine="759" endLine="767">
      <scope startLine="760" endLine="762" />
      <scope startLine="762" endLine="764" />
      <scope startLine="764" endLine="766" />
    </method>
    <javadoc>
      <text>* Returns a double array containing the elements of this
 * <code>ResizableArray</code>.  This method returns a copy, not a
 * reference to the underlying array, so that changes made to the returned
 * array have no effect on this <code>ResizableArray.</code></text>
      <return>the double array.</return>
    </javadoc>
    <method type="double[]" name="getElements" startLine="776" endLine="780">
      <declaration type="double[]" name="elementArray" />
    </method>
    <javadoc>
      <text>* The expansion factor controls the size of a new array when an array
 * needs to be expanded.  The <code>expansionMode</code>
 * determines whether the size of the array is multiplied by the
 * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if
 * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>
 * storage locations added).  The default <code>expansionMode</code> is
 * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>
 * is 2.0.</text>
      <return>the expansion factor of this expandable double array</return>
      <deprecated>As of 3.1. Return type will be changed to "double" in 4.0.</deprecated>
    </javadoc>
    <method type="float" name="getExpansionFactor" startLine="796" endLine="798" />
    <javadoc>
      <text>* The expansion mode determines whether the internal storage
 * array grows additively or multiplicatively when it is expanded.</text>
      <return>the expansion mode.</return>
      <deprecated>As of 3.1. Return value to be changed to{@link ExpansionMode} in 4.0.</deprecated>
    </javadoc>
    <method type="int" name="getExpansionMode" startLine="808" endLine="817">
      <comment>Should never happen.</comment>
    </method>
    <javadoc>
      <text>* Notice the package scope on this method.   This method is simply here
 * for the JUnit test, it allows us check if the expansion is working
 * properly after a number of expansions.  This is not meant to be a part
 * of the public interface of this class.</text>
      <return>the length of the internal storage array.</return>
      <deprecated>As of 3.1. Please use {@link #getCapacity()} instead.</deprecated>
    </javadoc>
    <method type="int" name="getInternalLength" startLine="829" endLine="831" />
    <javadoc>
      <text>* Gets the currently allocated size of the internal data structure used
 * for storing elements.
 * This is not to be confused with {@link #getNumElements() the number of
 * elements actually stored}.</text>
      <return>the length of the internal array.</return>
      <since>3.1</since>
    </javadoc>
    <method type="int" name="getCapacity" startLine="842" endLine="844" />
    <javadoc>
      <text>* Returns the number of elements currently in the array.  Please note
 * that this is different from the length of the internal storage array.</text>
      <return>the number of elements.</return>
    </javadoc>
    <method type="int" name="getNumElements" startLine="852" endLine="854" />
    <javadoc>
      <text>* Returns the internal storage array.  Note that this method returns
 * a reference to the internal storage array, not a copy, and to correctly
 * address elements of the array, the <code>startIndex</code> is
 * required (available via the {@link #start} method).  This method should
 * only be used in cases where copying the internal array is not practical.
 * The {@link #getElements} method should be used in all other cases.</text>
      <return>the internal storage array used by this object</return>
      <since>2.0</since>
      <deprecated>As of 3.1.</deprecated>
    </javadoc>
    <method type="double[]" name="getInternalValues" startLine="870" endLine="872" />
    <javadoc>
      <text>* Provides <em>direct</em> access to the internal storage array.
 * Please note that this method returns a reference to this object's
 * storage array, not a copy.
 * <br/>
 * To correctly address elements of the array, the "start index" is
 * required (available via the {@link #getStartIndex() getStartIndex}method.
 * <br/>
 * This method should only be used to avoid copying the internal array.
 * The returned value <em>must</em> be used for reading only; other
 * uses could lead to this object becoming inconsistent.
 * <br/>
 * The {@link #getElements} method has no such limitation since it
 * returns a copy of this array's addressable elements.</text>
      <return>the internal storage array used by this object.</return>
      <since>3.1</since>
    </javadoc>
    <method type="double[]" name="getArrayRef" startLine="893" endLine="895" />
    <javadoc>
      <text>* Returns the "start index" of the internal array.
 * This index is the position of the first addressable element in the
 * internal storage array.
 * The addressable elements in the array are at indices contained in
 * the interval [{@link #getStartIndex()},{@link #getStartIndex()} + {@link #getNumElements()} - 1].</text>
      <return>the start index.</return>
      <since>3.1</since>
    </javadoc>
    <method type="int" name="getStartIndex" startLine="908" endLine="910" />
    <javadoc>
      <text>* Sets the contraction criteria.</text>
      <param>contractionCriteria contraction criteria</param>
      <throws>MathIllegalArgumentException if the contractionCriteria is less than
 * the expansionCriteria.</throws>
      <deprecated>As of 3.1 (to be removed in 4.0 as field will become "final").</deprecated>
    </javadoc>
    <method type="void" name="setContractionCriteria" startLine="922" endLine="927">
      <scope startLine="924" endLine="926" />
    </method>
    <javadoc>
      <text>* Performs an operation on the addressable elements of the array.</text>
      <param>f Function to be applied on this array.</param>
      <return>the result.</return>
      <since>3.1</since>
    </javadoc>
    <method type="double" name="compute" startLine="936" endLine="946">
      <declaration type="double[]" name="array" />
      <declaration type="int" name="start" />
      <declaration type="int" name="num" />
      <scope startLine="940" endLine="944" />
    </method>
    <javadoc>
      <text>* Sets the element at the specified index.  If the specified index is greater than
 * <code>getNumElements() - 1</code>, the <code>numElements</code> property
 * is increased to <code>index +1</code> and additional storage is allocated
 * (if necessary) for the new element and all  (uninitialized) elements
 * between the new element and the previous end of the array).</text>
      <param>index index to store a value in</param>
      <param>value value to store at the specified index</param>
      <throws>ArrayIndexOutOfBoundsException if {@code index < 0}.</throws>
    </javadoc>
    <method type="void" name="setElement" startLine="959" endLine="970">
      <scope startLine="960" endLine="962" />
      <scope startLine="963" endLine="965" />
      <scope startLine="966" endLine="968" />
    </method>
    <javadoc>
      <text>* Sets the expansionFactor.  Throws IllegalArgumentException if the
 * the following conditions are not met:
 * <ul>
 * <li><code>expansionFactor > 1</code></li>
 * <li><code>contractionFactor >= expansionFactor</code></li>
 * </ul></text>
      <param>expansionFactor the new expansion factor value.</param>
      <throws>MathIllegalArgumentException if expansionFactor is <= 1 or greater
 * than contractionFactor</throws>
      <deprecated>As of 3.1 (to be removed in 4.0 as field will become "final").</deprecated>
    </javadoc>
    <method type="void" name="setExpansionFactor" startLine="985" endLine="991">
      <scope startLine="988" endLine="990" />
      <comment>The check above verifies that the expansion factor is > 1.0;</comment>
    </method>
    <javadoc>
      <text>* Sets the <code>expansionMode</code>. The specified value must be one of
 * ADDITIVE_MODE, MULTIPLICATIVE_MODE.</text>
      <param>expansionMode The expansionMode to set.</param>
      <throws>MathIllegalArgumentException if the specified mode value is not valid.</throws>
      <deprecated>As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.</deprecated>
    </javadoc>
    <method type="void" name="setExpansionMode" startLine="1003" endLine="1017">
      <scope startLine="1005" endLine="1009" />
      <scope startLine="1010" endLine="1016">
        <scope startLine="1011" endLine="1013" />
        <scope startLine="1013" endLine="1015" />
      </scope>
    </method>
    <javadoc>
      <text>* Sets the {@link ExpansionMode expansion mode}.</text>
      <param>expansionMode Expansion mode to use for resizing the array.</param>
      <deprecated>As of 3.1 (to be removed in 4.0 as field will become "final").</deprecated>
    </javadoc>
    <method type="void" name="setExpansionMode" startLine="1026" endLine="1028" />
    <javadoc>
      <text>* Sets the initial capacity.  Should only be invoked by constructors.</text>
      <param>initialCapacity of the array</param>
      <throws>MathIllegalArgumentException if <code>initialCapacity</code> is not
 * positive.</throws>
      <deprecated>As of 3.1, this is a no-op.</deprecated>
    </javadoc>
    <method type="void" name="setInitialCapacity" startLine="1040" endLine="1042">
      <comment>Body removed in 3.1.</comment>
    </method>
    <javadoc>
      <text>* This function allows you to control the number of elements contained
 * in this array, and can be used to "throw out" the last n values in an
 * array. This function will also expand the internal array as needed.</text>
      <param>i a new number of elements</param>
      <throws>MathIllegalArgumentException if <code>i</code> is negative.</throws>
    </javadoc>
    <method type="void" name="setNumElements" startLine="1053" endLine="1070">
      <scope startLine="1055" endLine="1059" />
      <declaration type="int" name="newSize" />
      <scope startLine="1064" endLine="1066" />
      <comment>If index is negative thrown an error.</comment>
      <comment>Test the new num elements, check to see if the array needs to be</comment>
      <comment>expanded to accommodate this new number of elements.</comment>
      <comment>Set the new number of elements to new value.</comment>
    </method>
    <javadoc>
      <text>* Returns true if the internal storage array has too many unused
 * storage positions.</text>
      <return>true if array satisfies the contraction criteria</return>
    </javadoc>
    <method type="boolean" name="shouldContract" startLine="1078" endLine="1084">
      <scope startLine="1079" endLine="1081" />
      <scope startLine="1081" endLine="1083" />
    </method>
    <javadoc>
      <text>* Returns the starting index of the internal array.  The starting index is
 * the position of the first addressable element in the internal storage
 * array.  The addressable elements in the array are <code>
 * internalArray[startIndex],...,internalArray[startIndex + numElements -1]
 * </code></text>
      <return>the starting index.</return>
      <deprecated>As of 3.1.</deprecated>
    </javadoc>
    <method type="int" name="start" startLine="1097" endLine="1099" />
    <javadoc>
      <text>* <p>Copies source to dest, copying the underlying data, so dest is
 * a new, independent copy of source.  Does not contract before
 * the copy.</p>
 * <p>Obtains synchronization locks on both source and dest
 * (in that order) before performing the copy.</p>
 * <p>Neither source nor dest may be null; otherwise a {@link NullArgumentException}is thrown</p></text>
      <param>source ResizableDoubleArray to copy</param>
      <param>dest ResizableArray to replace with a copy of the source array</param>
      <exception>NullArgumentException if either source or dest is null</exception>
      <since>2.0</since>
    </javadoc>
    <method type="void" name="copy" startLine="1120" endLine="1135">
      <scope startLine="1123" endLine="1134">
        <scope startLine="1124" endLine="1133" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a copy of the ResizableDoubleArray.  Does not contract before
 * the copy, so the returned object is an exact copy of this.</text>
      <return>a new ResizableDoubleArray with the same data and configuration
 * properties as this</return>
      <since>2.0</since>
    </javadoc>
    <method type="ResizableDoubleArray" name="copy" startLine="1145" endLine="1149">
      <declaration type="ResizableDoubleArray" name="result" />
    </method>
    <javadoc>
      <text>* Returns true iff object is a ResizableDoubleArray with the same properties
 * as this and an identical internal storage array.</text>
      <param>object object to be compared for equality with this</param>
      <return>true iff object is a ResizableDoubleArray with the same data and
 * properties as this</return>
      <since>2.0</since>
    </javadoc>
    <method type="boolean" name="equals" startLine="1161" endLine="1184">
      <scope startLine="1162" endLine="1164" />
      <scope startLine="1165" endLine="1167" />
      <scope startLine="1168" endLine="1183">
        <scope startLine="1169" endLine="1182">
          <declaration type="boolean" name="result" />
          <declaration type="ResizableDoubleArray" name="other" />
          <scope startLine="1177" endLine="1179" />
          <scope startLine="1179" endLine="1181" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a hash code consistent with equals.</text>
      <return>the hash code representing this {@code ResizableDoubleArray}.</return>
      <since>2.0</since>
    </javadoc>
    <method type="int" name="hashCode" startLine="1193" endLine="1202">
      <declaration type="int[]" name="hashData" />
    </method>
  </class>
</source>
