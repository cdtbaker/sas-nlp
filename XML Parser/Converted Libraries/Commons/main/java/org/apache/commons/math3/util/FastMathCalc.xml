<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.util">
  <import name="java.io.PrintStream" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <class name="FastMathCalc" startLine="23">
    <javadoc>
      <text>* Class used to compute the classical functions tables.</text>
      <version>$Id: FastMathCalc.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
 * Equivalent to 2^30.</text>
    </javadoc>
    <declaration type="long" name="HEX_40000000" />
    <javadoc>
      <text>* Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19!</text>
    </javadoc>
    <declaration type="double" name="FACT" />
    <javadoc>
      <text>* Coefficients for slowLog.</text>
    </javadoc>
    <declaration type="double" name="LN_SPLIT_COEF" />
    <javadoc>
      <text>* Table start declaration.</text>
    </javadoc>
    <declaration type="String" name="TABLE_START_DECL" />
    <javadoc>
      <text>* Table end declaration.</text>
    </javadoc>
    <declaration type="String" name="TABLE_END_DECL" />
    <javadoc>
      <text>* Private Constructor.</text>
    </javadoc>
    <method type="constructor" name="FastMathCalc" startLine="89" endLine="90" />
    <javadoc>
      <text>* Build the sine and cosine tables.</text>
      <param>SINE_TABLE_A table of the most significant part of the sines</param>
      <param>SINE_TABLE_B table of the least significant part of the sines</param>
      <param>COSINE_TABLE_A table of the most significant part of the cosines</param>
      <param>COSINE_TABLE_B table of the most significant part of the cosines</param>
      <param>SINE_TABLE_LEN length of the tables</param>
      <param>TANGENT_TABLE_A table of the most significant part of the tangents</param>
      <param>TANGENT_TABLE_B table of the most significant part of the tangents</param>
    </javadoc>
    <method type="void" name="buildSinCosTables" startLine="104" endLine="196">
      <declaration type="double[]" name="result" />
      <scope startLine="108" endLine="118">
        <declaration type="double" name="x" />
      </scope>
      <scope startLine="121" endLine="174">
        <declaration type="double[]" name="xs" />
        <declaration type="double[]" name="ys" />
        <declaration type="double[]" name="as" />
        <declaration type="double[]" name="bs" />
        <declaration type="double[]" name="temps" />
        <scope startLine="128" endLine="148" />
        <scope startLine="148" endLine="173" />
        <comment>Even, use double angle</comment>
        <comment>compute sine</comment>
        <comment>Compute cosine</comment>
        <comment>compute sine</comment>
        <comment>Compute cosine</comment>
      </scope>
      <scope startLine="177" endLine="194">
        <declaration type="double[]" name="xs" />
        <declaration type="double[]" name="ys" />
        <declaration type="double[]" name="as" />
      </scope>
      <comment>Use taylor series for 0 <= x <= 68</comment>
      <comment>Use angle addition formula to complete table to 138, just beyond pi2</comment>
      <comment>Compute tangent = sinecosine</comment>
    </method>
    <javadoc>
      <text>* For x between 0 and pi/4 compute cosine using Talor series
 * cos(x) = 1 - x^2/2! + x^4/4! ...</text>
      <param>x number from which cosine is requested</param>
      <param>result placeholder where to put the result in extended precision
 * (may be null)</param>
      <return>cos(x)</return>
    </javadoc>
    <method type="double" name="slowCos" startLine="206" endLine="241">
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="ys" />
      <declaration type="double[]" name="facts" />
      <declaration type="double[]" name="as" />
      <scope startLine="215" endLine="233">
        <scope startLine="219" endLine="221" />
        <scope startLine="226" endLine="229" />
        <comment>skip odd entries</comment>
        <comment>alternate terms are negative</comment>
      </scope>
      <scope startLine="235" endLine="238" />
    </method>
    <javadoc>
      <text>* For x between 0 and pi/4 compute sine using Taylor expansion:
 * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...</text>
      <param>x number from which sine is requested</param>
      <param>result placeholder where to put the result in extended precision
 * (may be null)</param>
      <return>sin(x)</return>
    </javadoc>
    <method type="double" name="slowSin" startLine="251" endLine="285">
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="ys" />
      <declaration type="double[]" name="facts" />
      <declaration type="double[]" name="as" />
      <scope startLine="259" endLine="277">
        <scope startLine="263" endLine="265" />
        <scope startLine="270" endLine="273" />
        <comment>Ignore even numbers</comment>
        <comment>alternate terms are negative</comment>
      </scope>
      <scope startLine="279" endLine="282" />
    </method>
    <javadoc>
      <text>* For x between 0 and 1, returns exp(x), uses extended precision</text>
      <param>x argument of exponential</param>
      <param>result placeholder where to place exp(x) split in two terms
 * for extra precision (i.e. exp(x) = result[0] + result[1]</param>
      <return>exp(x)</return>
    </javadoc>
    <method type="double" name="slowexp" startLine="295" endLine="322">
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="ys" />
      <declaration type="double[]" name="facts" />
      <declaration type="double[]" name="as" />
      <scope startLine="303" endLine="314" />
      <scope startLine="316" endLine="319" />
    </method>
    <javadoc>
      <text>* Compute split[0], split[1] such that their sum is equal to d,
 * and split[0] has its 30 least significant bits as zero.</text>
      <param>d number to split</param>
      <param>split placeholder where to place the result</param>
    </javadoc>
    <method type="void" name="split" startLine="329" endLine="339">
      <scope startLine="330" endLine="334">
        <declaration type="double" name="a" />
      </scope>
      <scope startLine="334" endLine="338">
        <declaration type="double" name="a" />
      </scope>
    </method>
    <javadoc>
      <text>* Recompute a split.</text>
      <param>a input/out array containing the split, changed
 * on output</param>
    </javadoc>
    <method type="void" name="resplit" startLine="345" endLine="358">
      <declaration type="double" name="c" />
      <declaration type="double" name="d" />
      <scope startLine="349" endLine="353">
        <declaration type="double" name="z" />
        <comment>MAGIC NUMBER</comment>
      </scope>
      <scope startLine="353" endLine="357">
        <declaration type="double" name="z" />
      </scope>
    </method>
    <javadoc>
      <text>* Multiply two numbers in split form.</text>
      <param>a first term of multiplication</param>
      <param>b second term of multiplication</param>
      <param>ans placeholder where to put the result</param>
    </javadoc>
    <method type="void" name="splitMult" startLine="365" endLine="371">
      <comment>Resplit</comment>
    </method>
    <javadoc>
      <text>* Add two numbers in split form.</text>
      <param>a first term of addition</param>
      <param>b second term of addition</param>
      <param>ans placeholder where to put the result</param>
    </javadoc>
    <method type="void" name="splitAdd" startLine="378" endLine="383" />
    <javadoc>
      <text>* Compute the reciprocal of in.  Use the following algorithm.
 * in = c + d.
 * want to find x + y such that x+y = 1/(c+d) and x is much
 * larger than y and x has several zero bits on the right.
 * Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.
 * Use following identity to compute (a+b)/(c+d)
 * (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)
 * set x = a/c  and y = (bc - ad) / (c^2 + cd)
 * This will be close to the right answer, but there will be
 * some rounding in the calculation of X.  So by carefully
 * computing 1 - (c+d)(x+y) we can compute an error and
 * add that back in.   This is done carefully so that terms
 * of similar size are subtracted first.</text>
      <param>in initial number, in split form</param>
      <param>result placeholder where to put the result</param>
    </javadoc>
    <method type="void" name="splitReciprocal" startLine="403" endLine="431">
      <declaration type="double" name="b" />
      <declaration type="double" name="a" />
      <scope startLine="407" endLine="410" />
      <scope startLine="415" endLine="417">
        <comment>can happen if result[1] is NAN</comment>
      </scope>
      <scope startLine="422" endLine="430">
        <declaration type="double" name="err" />
        <comment>this may be overkill, probably once is enough</comment>
        <comment>err = 1.0 - err;</comment>
        <comment>printf("err = %16e\n", err);</comment>
      </scope>
      <comment>Resplit</comment>
    </method>
    <javadoc>
      <text>* Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.</text>
      <param>a first term of the multiplication</param>
      <param>b second term of the multiplication</param>
      <param>result placeholder where to put the result</param>
    </javadoc>
    <method type="void" name="quadMult" startLine="438" endLine="485">
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="ys" />
      <declaration type="double[]" name="zs" />
      <declaration type="double" name="tmp" />
      <comment>a[0]  b[0]</comment>
      <comment>a[0]  b[1]</comment>
      <comment>a[1]  b[0]</comment>
      <comment>a[1]  b[0]</comment>
    </method>
    <javadoc>
      <text>* Compute exp(p) for a integer p in extended precision.</text>
      <param>p integer whose exponential is requested</param>
      <param>result placeholder where to put the result in extended precision</param>
      <return>exp(p) in standard precision (equal to result[0] + result[1])</return>
    </javadoc>
    <method type="double" name="expint" startLine="492" endLine="530">
      <declaration type="double[]" name="xs" />
      <declaration type="double[]" name="as" />
      <declaration type="double[]" name="ys" />
      <scope startLine="510" endLine="520">
        <scope startLine="511" endLine="514" />
      </scope>
      <scope startLine="522" endLine="527" />
      <comment>double x = M_E;</comment>
      <comment>split(x, xs);</comment>
      <comment>xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);</comment>
      <comment>xs[0] = 2.71827697753906250000;</comment>
      <comment>xs[1] = 4.85091998273542816811e-06;</comment>
      <comment>xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);</comment>
      <comment>xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);</comment>
      <comment>E</comment>
    </method>
    <javadoc>
      <text>* xi in the range of [1, 2].
 * 3        5        7
 * x+1           /          x        x        x          \
 * ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
 * 1-x           \          3        5        7          /
 * So, compute a Remez approximation of the following function
 * ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x
 * This will be an even function with only positive coefficents.
 * x is in the range [0 - 1/3].
 * Transform xi for input to the above function by setting
 * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then
 * the result is multiplied by x.</text>
      <param>xi number from which log is requested</param>
      <return>log(xi)</return>
    </javadoc>
    <method type="double[]" name="slowLog" startLine="550" endLine="592">
      <declaration type="double[]" name="x" />
      <declaration type="double[]" name="x2" />
      <declaration type="double[]" name="y" />
      <declaration type="double[]" name="a" />
      <scope startLine="578" endLine="585" />
      <comment>Set X = (x-1)(x+1)</comment>
      <comment>Square X -> X2</comment>
      <comment>x[0] -= 1.0;</comment>
      <comment>resplit(x);</comment>
    </method>
    <javadoc>
      <text>* Print an array.</text>
      <param>out text output stream where output should be printed</param>
      <param>name array name</param>
      <param>expectedLen expected length of the array</param>
      <param>array2d array data</param>
    </javadoc>
    <method type="void" name="printarray" startLine="602" endLine="615">
      <declaration type="int" name="i" />
      <scope startLine="607" endLine="613">
        <scope startLine="609" endLine="611" />
        <comment>"double array[]" causes PMD parsing error</comment>
        <comment>assume inner array has very few entries</comment>
        <comment>multiple entries per line</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Print an array.</text>
      <param>out text output stream where output should be printed</param>
      <param>name array name</param>
      <param>expectedLen expected length of the array</param>
      <param>array array data</param>
    </javadoc>
    <method type="void" name="printarray" startLine="624" endLine="632">
      <scope startLine="628" endLine="630">
        <comment>one entry per line</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Format a double.</text>
      <param>d double number to format</param>
      <return>formatted number</return>
    </javadoc>
    <method type="String" name="format" startLine="638" endLine="644">
      <scope startLine="639" endLine="641" />
      <scope startLine="641" endLine="643" />
    </method>
    <javadoc>
      <text>* Check two lengths are equal.</text>
      <param>expectedLen expected length</param>
      <param>actual actual length</param>
      <exception>DimensionMismatchException if the two lengths are not equal</exception>
    </javadoc>
    <method type="void" name="checkLen" startLine="653" endLine="657">
      <scope startLine="654" endLine="656" />
    </method>
    <comment>1073741824L</comment>
    <comment>0</comment>
    <comment>1</comment>
    <comment>2</comment>
    <comment>3</comment>
    <comment>4</comment>
    <comment>5</comment>
    <comment>6</comment>
    <comment>7</comment>
    <comment>8</comment>
    <comment>9</comment>
    <comment>10</comment>
    <comment>11</comment>
    <comment>12</comment>
    <comment>13</comment>
    <comment>14</comment>
    <comment>15</comment>
    <comment>16</comment>
    <comment>17</comment>
    <comment>18</comment>
    <comment>19</comment>
  </class>
</source>
