<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="Rotation" startLine="28">
    <implements name="Serializable" />
    <javadoc>
      <text>* This class implements rotations in a three-dimensional space.
 * <p>Rotations can be represented by several different mathematical
 * entities (matrices, axe and angle, Cardan or Euler angles,
 * quaternions). This class presents an higher level abstraction, more
 * user-oriented and hiding this implementation details. Well, for the
 * curious, we use quaternions for the internal representation. The
 * user can build a rotation from any of these representations, and
 * any of these representations can be retrieved from a
 * <code>Rotation</code> instance (see the various constructors and
 * getters). In addition, a rotation can also be built implicitly
 * from a set of vectors and their image.</p>
 * <p>This implies that this class can be used to convert from one
 * representation to another one. For example, converting a rotation
 * matrix into a set of Cardan angles from can be done using the
 * following single line of code:</p>
 * <pre>
 * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);
 * </pre>
 * <p>Focus is oriented on what a rotation <em>do</em> rather than on its
 * underlying representation. Once it has been built, and regardless of its
 * internal representation, a rotation is an <em>operator</em> which basically
 * transforms three dimensional {@link Vector3D vectors} into other three
 * dimensional {@link Vector3D vectors}. Depending on the application, the
 * meaning of these vectors may vary and the semantics of the rotation also.</p>
 * <p>For example in an spacecraft attitude simulation tool, users will often
 * consider the vectors are fixed (say the Earth direction for example) and the
 * frames change. The rotation transforms the coordinates of the vector in inertial
 * frame into the coordinates of the same vector in satellite frame. In this
 * case, the rotation implicitly defines the relation between the two frames.</p>
 * <p>Another example could be a telescope control application, where the rotation
 * would transform the sighting direction at rest into the desired observing
 * direction when the telescope is pointed towards an object of interest. In this
 * case the rotation transforms the direction at rest in a topocentric frame
 * into the sighting direction in the same topocentric frame. This implies in this
 * case the frame is fixed and the vector moves.</p>
 * <p>In many case, both approaches will be combined. In our telescope example,
 * we will probably also need to transform the observing direction in the topocentric
 * frame into the observing direction in inertial frame taking into account the observatory
 * location and the Earth rotation, which would essentially be an application of the
 * first approach.</p>
 * <p>These examples show that a rotation is what the user wants it to be. This
 * class does not push the user towards one specific definition and hence does not
 * provide methods like <code>projectVectorIntoDestinationFrame</code> or
 * <code>computeTransformedDirection</code>. It provides simpler and more generic
 * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>
 * <p>Since a rotation is basically a vectorial operator, several rotations can be
 * composed together and the composite operation <code>r = r<sub>1</sub> o
 * r<sub>2</sub></code> (which means that for each vector <code>u</code>,
 * <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence
 * we can consider that in addition to vectors, a rotation can be applied to other
 * rotations as well (or to itself). With our previous notations, we would say we
 * can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result
 * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the
 * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and{@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>
 * <p>Rotations are guaranteed to be immutable objects.</p></text>
      <version>$Id: Rotation.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <see>Vector3D</see>
      <see>RotationOrder</see>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Identity rotation.</text>
    </javadoc>
    <declaration type="Rotation" name="IDENTITY" />
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Scalar coordinate of the quaternion.</text>
    </javadoc>
    <declaration type="double" name="q0" />
    <javadoc>
      <text>* First coordinate of the vectorial part of the quaternion.</text>
    </javadoc>
    <declaration type="double" name="q1" />
    <javadoc>
      <text>* Second coordinate of the vectorial part of the quaternion.</text>
    </javadoc>
    <declaration type="double" name="q2" />
    <javadoc>
      <text>* Third coordinate of the vectorial part of the quaternion.</text>
    </javadoc>
    <declaration type="double" name="q3" />
    <javadoc>
      <text>* Build a rotation from the quaternion coordinates.
 * <p>A rotation can be built from a <em>normalized</em> quaternion,
 * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +
 * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +
 * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,
 * the constructor can normalize it in a preprocessing step.</p>
 * <p>Note that some conventions put the scalar part of the quaternion
 * as the 4<sup>th</sup> component and the vector part as the first three
 * components. This is <em>not</em> our convention. We put the scalar part
 * as the first component.</p></text>
      <param>q0 scalar part of the quaternion</param>
      <param>q1 first coordinate of the vectorial part of the quaternion</param>
      <param>q2 second coordinate of the vectorial part of the quaternion</param>
      <param>q3 third coordinate of the vectorial part of the quaternion</param>
      <param>needsNormalization if true, the coordinates are considered
 * not to be normalized, a normalization preprocessing step is performed
 * before using them</param>
    </javadoc>
    <method type="constructor" name="Rotation" startLine="136" endLine="152">
      <scope startLine="138" endLine="145">
        <declaration type="double" name="inv" />
        <comment>normalization preprocessing</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Build a rotation from an axis and an angle.
 * <p>We use the convention that angles are oriented according to
 * the effect of the rotation on vectors around the axis. That means
 * that if (i, j, k) is a direct frame and if we first provide +k as
 * the axis and &pi;/2 as the angle to this constructor, and then{@link #applyTo(Vector3D) apply} the instance to +i, we will get
 * +j.</p>
 * <p>Another way to represent our convention is to say that a rotation
 * of angle &theta; about the unit vector (x, y, z) is the same as the
 * rotation build from quaternion components { cos(-&theta;/2),
 * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.
 * Note the minus sign on the angle!</p>
 * <p>On the one hand this convention is consistent with a vectorial
 * perspective (moving vectors in fixed frames), on the other hand it
 * is different from conventions with a frame perspective (fixed vectors
 * viewed from different frames) like the ones used for example in spacecraft
 * attitude community or in the graphics community.</p></text>
      <param>axis axis around which to rotate</param>
      <param>angle rotation angle.</param>
      <exception>MathIllegalArgumentException if the axis norm is zero</exception>
    </javadoc>
    <method type="constructor" name="Rotation" startLine="175" endLine="190">
      <declaration type="double" name="norm" />
      <scope startLine="178" endLine="180" />
      <declaration type="double" name="halfAngle" />
      <declaration type="double" name="coeff" />
    </method>
    <javadoc>
      <text>* Build a rotation from a 3X3 matrix.
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p></text>
      <param>m rotation matrix</param>
      <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
      <exception>NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative</exception>
    </javadoc>
    <method type="constructor" name="Rotation" startLine="223" endLine="252">
      <scope startLine="227" endLine="231" />
      <declaration type="double[][]" name="ort" />
      <declaration type="double" name="det" />
      <scope startLine="240" endLine="244" />
      <declaration type="double[]" name="quat" />
      <comment>dimension check</comment>
      <comment>compute a "close" orthogonal matrix</comment>
      <comment>check the sign of the determinant</comment>
    </method>
    <javadoc>
      <text>* Build the rotation that transforms a pair of vector into another pair.
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p></text>
      <param>u1 first vector of the origin pair</param>
      <param>u2 second vector of the origin pair</param>
      <param>v1 desired image of u1 by the rotation</param>
      <param>v2 desired image of u2 by the rotation</param>
      <exception>MathArithmeticException if the norm of one of the vectors is zero,
 * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)</exception>
    </javadoc>
    <method type="constructor" name="Rotation" startLine="274" endLine="313">
      <declaration type="Vector3D" name="u3" />
      <declaration type="Vector3D" name="v3" />
      <declaration type="double[][][]" name="m" />
      <declaration type="double[]" name="quat" />
      <comment>build orthonormalized base from u1, u2</comment>
      <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
      <comment>build an orthonormalized base from v1, v2</comment>
      <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
      <comment>buid a matrix transforming the first base into the second one</comment>
    </method>
    <javadoc>
      <text>* Build one of the rotations that transform one vector into another one.
 * <p>Except for a possible scale factor, if the instance were
 * applied to the vector u it will produce the vector v. There is an
 * infinite number of such rotations, this constructor choose the
 * one with the smallest associated angle (i.e. the one whose axis
 * is orthogonal to the (u, v) plane). If u and v are colinear, an
 * arbitrary rotation axis is chosen.</p></text>
      <param>u origin vector</param>
      <param>v desired image of u by the rotation</param>
      <exception>MathArithmeticException if the norm of one of the vectors is zero</exception>
    </javadoc>
    <method type="constructor" name="Rotation" startLine="328" endLine="356">
      <declaration type="double" name="normProduct" />
      <scope startLine="331" endLine="333" />
      <declaration type="double" name="dot" />
      <scope startLine="337" endLine="345">
        <declaration type="Vector3D" name="w" />
        <comment>special case u = -v: we select a PI angle rotation around</comment>
        <comment>an arbitrary vector orthogonal to u</comment>
      </scope>
      <scope startLine="345" endLine="354">
        <declaration type="double" name="coeff" />
        <declaration type="Vector3D" name="q" />
        <comment>general case: (u, v) defines a plane, we select</comment>
        <comment>the shortest possible rotation: axis orthogonal to this plane</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Build a rotation from three Cardan or Euler elementary rotations.
 * <p>Cardan rotations are three successive rotations around the
 * canonical axes X, Y and Z, each axis being used once. There are
 * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
 * rotations are three successive rotations around the canonical
 * axes X, Y and Z, the first and last rotations being around the
 * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
 * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>
 * <p>Beware that many people routinely use the term Euler angles even
 * for what really are Cardan angles (this confusion is especially
 * widespread in the aerospace business where Roll, Pitch and Yaw angles
 * are often wrongly tagged as Euler angles).</p></text>
      <param>order order of rotations to use</param>
      <param>alpha1 angle of the first elementary rotation</param>
      <param>alpha2 angle of the second elementary rotation</param>
      <param>alpha3 angle of the third elementary rotation</param>
    </javadoc>
    <method type="constructor" name="Rotation" startLine="378" endLine="387">
      <declaration type="Rotation" name="r1" />
      <declaration type="Rotation" name="r2" />
      <declaration type="Rotation" name="r3" />
      <declaration type="Rotation" name="composed" />
    </method>
    <javadoc>
      <text>* Convert an orthogonal rotation matrix to a quaternion.</text>
      <param>ort orthogonal rotation matrix</param>
      <return>quaternion corresponding to the matrix</return>
    </javadoc>
    <method type="double[]" name="mat2quat" startLine="393" endLine="448">
      <declaration type="double[]" name="quat" />
      <declaration type="double" name="s" />
      <scope startLine="409" endLine="416">
        <declaration type="double" name="inv" />
        <comment>compute q0 and deduce q1, q2 and q3</comment>
      </scope>
      <scope startLine="416" endLine="444">
        <scope startLine="418" endLine="425">
          <declaration type="double" name="inv" />
        </scope>
        <scope startLine="425" endLine="443">
          <scope startLine="427" endLine="434">
            <declaration type="double" name="inv" />
          </scope>
          <scope startLine="434" endLine="442">
            <declaration type="double" name="inv" />
          </scope>
        </scope>
        <comment>compute q1 and deduce q0, q2 and q3</comment>
        <comment>compute q2 and deduce q0, q1 and q3</comment>
        <comment>compute q3 and deduce q0, q1 and q2</comment>
      </scope>
      <comment>There are different ways to compute the quaternions elements</comment>
      <comment>from the matrix. They all involve computing one element from</comment>
      <comment>the diagonal of the matrix, and computing the three other ones</comment>
      <comment>using a formula involving a division by the first element,</comment>
      <comment>which unfortunately can be zero. Since the norm of the</comment>
      <comment>quaternion is 1, we know at least one element has an absolute</comment>
      <comment>value greater or equal to 0.5, so it is always possible to</comment>
      <comment>select the right formula and avoid division by zero and even</comment>
      <comment>numerical inaccuracy. Checking the elements in turn and using</comment>
      <comment>the first one greater than 0.45 is safe (this leads to a simple</comment>
      <comment>test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)</comment>
    </method>
    <javadoc>
      <text>* Revert a rotation.
 * Build a rotation which reverse the effect of another
 * rotation. This means that if r(u) = v, then r.revert(v) = u. The
 * instance is not changed.</text>
      <return>a new rotation whose effect is the reverse of the effect
 * of the instance</return>
    </javadoc>
    <method type="Rotation" name="revert" startLine="457" endLine="459" />
    <javadoc>
      <text>* Get the scalar coordinate of the quaternion.</text>
      <return>scalar coordinate of the quaternion</return>
    </javadoc>
    <method type="double" name="getQ0" startLine="464" endLine="466" />
    <javadoc>
      <text>* Get the first coordinate of the vectorial part of the quaternion.</text>
      <return>first coordinate of the vectorial part of the quaternion</return>
    </javadoc>
    <method type="double" name="getQ1" startLine="471" endLine="473" />
    <javadoc>
      <text>* Get the second coordinate of the vectorial part of the quaternion.</text>
      <return>second coordinate of the vectorial part of the quaternion</return>
    </javadoc>
    <method type="double" name="getQ2" startLine="478" endLine="480" />
    <javadoc>
      <text>* Get the third coordinate of the vectorial part of the quaternion.</text>
      <return>third coordinate of the vectorial part of the quaternion</return>
    </javadoc>
    <method type="double" name="getQ3" startLine="485" endLine="487" />
    <javadoc>
      <text>* Get the normalized axis of the rotation.</text>
      <return>normalized axis of the rotation</return>
      <see>#Rotation(Vector3D,double)</see>
    </javadoc>
    <method type="Vector3D" name="getAxis" startLine="493" endLine="503">
      <declaration type="double" name="squaredSine" />
      <scope startLine="495" endLine="497" />
      <scope startLine="497" endLine="500">
        <declaration type="double" name="inverse" />
      </scope>
      <declaration type="double" name="inverse" />
    </method>
    <javadoc>
      <text>* Get the angle of the rotation.</text>
      <return>angle of the rotation (between 0 and &pi;)</return>
      <see>#Rotation(Vector3D,double)</see>
    </javadoc>
    <method type="double" name="getAngle" startLine="509" endLine="516">
      <scope startLine="510" endLine="512" />
      <scope startLine="512" endLine="514" />
    </method>
    <javadoc>
      <text>* Get the Cardan or Euler angles corresponding to the instance.
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 * <li>for Cardan angles, the chosen set is the one for which the
 * second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 * positive),</li>
 * <li>for Euler angles, the chosen set is the one for which the
 * second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p></text>
      <param>order rotation order to use</param>
      <return>an array of three angles, in the order specified by the set</return>
      <exception>CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified</exception>
    </javadoc>
    <method type="double[]" name="getAngles" startLine="554" endLine="774">
      <scope startLine="556" endLine="574">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="565" endLine="567" />
        <comment>r (Vector3D.plusK) coordinates are :</comment>
        <comment>sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)</comment>
        <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)</comment>
        <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="574" endLine="592">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="583" endLine="585" />
        <comment>r (Vector3D.plusJ) coordinates are :</comment>
        <comment>-sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)</comment>
        <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)</comment>
        <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="592" endLine="610">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="601" endLine="603" />
        <comment>r (Vector3D.plusK) coordinates are :</comment>
        <comment>cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)</comment>
        <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
        <comment>sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)</comment>
        <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="610" endLine="628">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="619" endLine="621" />
        <comment>r (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)</comment>
        <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
        <comment>sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)</comment>
        <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="628" endLine="646">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="637" endLine="639" />
        <comment>r (Vector3D.plusJ) coordinates are :</comment>
        <comment>-cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)</comment>
        <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
        <comment>-sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)</comment>
        <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="646" endLine="664">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="655" endLine="657" />
        <comment>r (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)</comment>
        <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
        <comment>-sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)</comment>
        <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="664" endLine="682">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="673" endLine="675" />
        <comment>r (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)</comment>
        <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)</comment>
        <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="682" endLine="700">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="691" endLine="693" />
        <comment>r (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)</comment>
        <comment>(-r) (Vector3D.plusI) coordinates are :</comment>
        <comment>cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)</comment>
        <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="700" endLine="718">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="709" endLine="711" />
        <comment>r (Vector3D.plusJ) coordinates are :</comment>
        <comment>sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)</comment>
        <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
        <comment>sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)</comment>
        <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="718" endLine="736">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="727" endLine="729" />
        <comment>r (Vector3D.plusJ) coordinates are :</comment>
        <comment>-cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)</comment>
        <comment>(-r) (Vector3D.plusJ) coordinates are :</comment>
        <comment>sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)</comment>
        <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="736" endLine="754">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="745" endLine="747" />
        <comment>r (Vector3D.plusK) coordinates are :</comment>
        <comment>sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)</comment>
        <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
        <comment>sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)</comment>
        <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
        <comment>last possibility is ZYZ</comment>
      </scope>
      <scope startLine="754" endLine="772">
        <declaration type="Vector3D" name="v1" />
        <declaration type="Vector3D" name="v2" />
        <scope startLine="763" endLine="765" />
        <comment>r (Vector3D.plusK) coordinates are :</comment>
        <comment>cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)</comment>
        <comment>(-r) (Vector3D.plusK) coordinates are :</comment>
        <comment>-sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)</comment>
        <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Get the 3X3 matrix corresponding to the instance</text>
      <return>the matrix corresponding to the instance</return>
    </javadoc>
    <method type="double[][]" name="getMatrix" startLine="779" endLine="813">
      <declaration type="double" name="q0q0" />
      <declaration type="double" name="q0q1" />
      <declaration type="double" name="q0q2" />
      <declaration type="double" name="q0q3" />
      <declaration type="double" name="q1q1" />
      <declaration type="double" name="q1q2" />
      <declaration type="double" name="q1q3" />
      <declaration type="double" name="q2q2" />
      <declaration type="double" name="q2q3" />
      <declaration type="double" name="q3q3" />
      <declaration type="double[][][]" name="m" />
      <comment>products</comment>
      <comment>create the matrix</comment>
    </method>
    <javadoc>
      <text>* Apply the rotation to a vector.</text>
      <param>u vector to apply the rotation to</param>
      <return>a new vector which is the image of u by the rotation</return>
    </javadoc>
    <method type="Vector3D" name="applyTo" startLine="819" endLine="831">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="double" name="s" />
    </method>
    <javadoc>
      <text>* Apply the rotation to a vector stored in an array.</text>
      <param>in an array with three items which stores vector to rotate</param>
      <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
    </javadoc>
    <method type="void" name="applyTo" startLine="838" endLine="850">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="double" name="s" />
    </method>
    <javadoc>
      <text>* Apply the inverse of the rotation to a vector.</text>
      <param>u vector to apply the inverse of the rotation to</param>
      <return>a new vector which such that u is its image by the rotation</return>
    </javadoc>
    <method type="Vector3D" name="applyInverseTo" startLine="856" endLine="869">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="double" name="s" />
      <declaration type="double" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the inverse of the rotation to a vector stored in an array.</text>
      <param>in an array with three items which stores vector to rotate</param>
      <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
    </javadoc>
    <method type="void" name="applyInverseTo" startLine="876" endLine="889">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="double" name="s" />
      <declaration type="double" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).</text>
      <param>r rotation to apply the rotation to</param>
      <return>a new rotation which is the composition of r by the instance</return>
    </javadoc>
    <method type="Rotation" name="applyTo" startLine="900" endLine="906" />
    <javadoc>
      <text>* Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).</text>
      <param>r rotation to apply the rotation to</param>
      <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
    </javadoc>
    <method type="Rotation" name="applyInverseTo" startLine="919" endLine="925" />
    <javadoc>
      <text>* Perfect orthogonality on a 3X3 matrix.</text>
      <param>m initial matrix (not exactly orthogonal)</param>
      <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
      <return>an orthogonal matrix close to m</return>
      <exception>NotARotationMatrixException if the matrix cannot be
 * orthogonalized with the given threshold after 10 iterations</exception>
    </javadoc>
    <method type="double[][]" name="orthogonalizeMatrix" startLine="938" endLine="1024">
      <declaration type="double[]" name="m0" />
      <declaration type="double[]" name="m1" />
      <declaration type="double[]" name="m2" />
      <declaration type="double" name="x00" />
      <declaration type="double" name="x01" />
      <declaration type="double" name="x02" />
      <declaration type="double" name="x10" />
      <declaration type="double" name="x11" />
      <declaration type="double" name="x12" />
      <declaration type="double" name="x20" />
      <declaration type="double" name="x21" />
      <declaration type="double" name="x22" />
      <declaration type="double" name="fn" />
      <declaration type="double" name="fn1" />
      <declaration type="double[][]" name="o" />
      <declaration type="double[]" name="o0" />
      <declaration type="double[]" name="o1" />
      <declaration type="double[]" name="o2" />
      <declaration type="int" name="i" />
      <scope startLine="961" endLine="1018">
        <declaration type="double" name="mx00" />
        <declaration type="double" name="mx10" />
        <declaration type="double" name="mx20" />
        <declaration type="double" name="mx01" />
        <declaration type="double" name="mx11" />
        <declaration type="double" name="mx21" />
        <declaration type="double" name="mx02" />
        <declaration type="double" name="mx12" />
        <declaration type="double" name="mx22" />
        <declaration type="double" name="corr00" />
        <declaration type="double" name="corr01" />
        <declaration type="double" name="corr02" />
        <declaration type="double" name="corr10" />
        <declaration type="double" name="corr11" />
        <declaration type="double" name="corr12" />
        <declaration type="double" name="corr20" />
        <declaration type="double" name="corr21" />
        <declaration type="double" name="corr22" />
        <scope startLine="1002" endLine="1004" />
        <comment>Mt.Xn</comment>
        <comment>Xn+1</comment>
        <comment>correction on each elements</comment>
        <comment>Frobenius norm of the correction</comment>
        <comment>convergence test</comment>
        <comment>prepare next iteration</comment>
      </scope>
      <comment>iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)</comment>
      <comment>the algorithm did not converge after 10 iterations</comment>
    </method>
    <javadoc>
      <text>* Compute the <i>distance</i> between two rotations.
 * <p>The <i>distance</i> is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:</p>
 * <pre>
 * r<sub>1</sub>(r) = r<sub>2</sub>
 * </pre>
 * <p>This distance is an angle between 0 and &pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r<sub>1</sub>(v)
 * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.</p>
 * <p>Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).</p></text>
      <param>r1 first rotation</param>
      <param>r2 second rotation</param>
      <return><i>distance</i> between r1 and r2</return>
    </javadoc>
    <method type="double" name="distance" startLine="1050" endLine="1052" />
  </class>
</source>
