<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="java.io.Serializable" />
  <import name="org.apache.commons.math3.RealFieldElement" />
  <import name="org.apache.commons.math3.Field" />
  <import name="org.apache.commons.math3.exception.MathArithmeticException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathArrays" />
  <class name="FieldRotation" startLine="30">
    <implements name="Serializable" />
    <javadoc>
      <text>* This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.
 * <p>Instance of this class are guaranteed to be immutable.</p></text>
      <param><T>
 *  the type of the field elements</param>
      <version>$Id: FieldRotation.java 1454903 2013-03-10 19:44:31Z luc $</version>
      <see>FieldVector3D</see>
      <see>RotationOrder</see>
      <since>3.2</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Scalar coordinate of the quaternion.</text>
    </javadoc>
    <declaration type="T" name="q0" />
    <javadoc>
      <text>* First coordinate of the vectorial part of the quaternion.</text>
    </javadoc>
    <declaration type="T" name="q1" />
    <javadoc>
      <text>* Second coordinate of the vectorial part of the quaternion.</text>
    </javadoc>
    <declaration type="T" name="q2" />
    <javadoc>
      <text>* Third coordinate of the vectorial part of the quaternion.</text>
    </javadoc>
    <declaration type="T" name="q3" />
    <javadoc>
      <text>* Build a rotation from the quaternion coordinates.
 * <p>A rotation can be built from a <em>normalized</em> quaternion,
 * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +
 * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +
 * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,
 * the constructor can normalize it in a preprocessing step.</p>
 * <p>Note that some conventions put the scalar part of the quaternion
 * as the 4<sup>th</sup> component and the vector part as the first three
 * components. This is <em>not</em> our convention. We put the scalar part
 * as the first component.</p></text>
      <param>q0 scalar part of the quaternion</param>
      <param>q1 first coordinate of the vectorial part of the quaternion</param>
      <param>q2 second coordinate of the vectorial part of the quaternion</param>
      <param>q3 third coordinate of the vectorial part of the quaternion</param>
      <param>needsNormalization if true, the coordinates are considered
 * not to be normalized, a normalization preprocessing step is performed
 * before using them</param>
    </javadoc>
    <method type="constructor" name="FieldRotation" startLine="76" endLine="93">
      <scope startLine="78" endLine="86">
        <declaration type="T" name="inv" />
        <comment>normalization preprocessing</comment>
      </scope>
      <scope startLine="86" endLine="91" />
    </method>
    <javadoc>
      <text>* Build a rotation from an axis and an angle.
 * <p>We use the convention that angles are oriented according to
 * the effect of the rotation on vectors around the axis. That means
 * that if (i, j, k) is a direct frame and if we first provide +k as
 * the axis and &pi;/2 as the angle to this constructor, and then{@link #applyTo(FieldVector3D) apply} the instance to +i, we will get
 * +j.</p>
 * <p>Another way to represent our convention is to say that a rotation
 * of angle &theta; about the unit vector (x, y, z) is the same as the
 * rotation build from quaternion components { cos(-&theta;/2),
 * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.
 * Note the minus sign on the angle!</p>
 * <p>On the one hand this convention is consistent with a vectorial
 * perspective (moving vectors in fixed frames), on the other hand it
 * is different from conventions with a frame perspective (fixed vectors
 * viewed from different frames) like the ones used for example in spacecraft
 * attitude community or in the graphics community.</p></text>
      <param>axis axis around which to rotate</param>
      <param>angle rotation angle.</param>
      <exception>MathIllegalArgumentException if the axis norm is zero</exception>
    </javadoc>
    <method type="constructor" name="FieldRotation" startLine="117" endLine="132">
      <declaration type="T" name="norm" />
      <scope startLine="120" endLine="122" />
      <declaration type="T" name="halfAngle" />
      <declaration type="T" name="coeff" />
    </method>
    <javadoc>
      <text>* Build a rotation from a 3X3 matrix.
 * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices
 * (which are matrices for which m.m<sup>T</sup> = I) with real
 * coefficients. The module of the determinant of unit matrices is
 * 1, among the orthogonal 3X3 matrices, only the ones having a
 * positive determinant (+1) are rotation matrices.</p>
 * <p>When a rotation is defined by a matrix with truncated values
 * (typically when it is extracted from a technical sheet where only
 * four to five significant digits are available), the matrix is not
 * orthogonal anymore. This constructor handles this case
 * transparently by using a copy of the given matrix and applying a
 * correction to the copy in order to perfect its orthogonality. If
 * the Frobenius norm of the correction needed is above the given
 * threshold, then the matrix is considered to be too far from a
 * true rotation matrix and an exception is thrown.<p></text>
      <param>m rotation matrix</param>
      <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
      <exception>NotARotationMatrixException if the matrix is not a 3X3
 * matrix, or if it cannot be transformed into an orthogonal matrix
 * with the given threshold, or if the determinant of the resulting
 * orthogonal matrix is negative</exception>
    </javadoc>
    <method type="constructor" name="FieldRotation" startLine="165" endLine="196">
      <scope startLine="169" endLine="173" />
      <declaration type="T[][]" name="ort" />
      <declaration type="T" name="d0" />
      <declaration type="T" name="d1" />
      <declaration type="T" name="d2" />
      <declaration type="T" name="det" />
      <scope startLine="184" endLine="188" />
      <declaration type="T[]" name="quat" />
      <comment>dimension check</comment>
      <comment>compute a "close" orthogonal matrix</comment>
      <comment>check the sign of the determinant</comment>
    </method>
    <javadoc>
      <text>* Build the rotation that transforms a pair of vector into another pair.
 * <p>Except for possible scale factors, if the instance were applied to
 * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair
 * (v<sub>1</sub>, v<sub>2</sub>).</p>
 * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is
 * not the same as the angular separation between v<sub>1</sub> and
 * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than
 * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,
 * v<sub>2</sub>) plane.</p></text>
      <param>u1 first vector of the origin pair</param>
      <param>u2 second vector of the origin pair</param>
      <param>v1 desired image of u1 by the rotation</param>
      <param>v2 desired image of u2 by the rotation</param>
      <exception>MathArithmeticException if the norm of one of the vectors is zero,
 * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)</exception>
    </javadoc>
    <method type="constructor" name="FieldRotation" startLine="218" endLine="250">
      <declaration type="FieldVector3D<T>" name="u3" />
      <declaration type="FieldVector3D<T>" name="v3" />
      <declaration type="T[][]" name="array" />
      <declaration type="T[]" name="quat" />
      <comment>build orthonormalized base from u1, u2</comment>
      <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
      <comment>build an orthonormalized base from v1, v2</comment>
      <comment>this fails when vectors are null or colinear, which is forbidden to define a rotation</comment>
      <comment>buid a matrix transforming the first base into the second one</comment>
    </method>
    <javadoc>
      <text>* Build one of the rotations that transform one vector into another one.
 * <p>Except for a possible scale factor, if the instance were
 * applied to the vector u it will produce the vector v. There is an
 * infinite number of such rotations, this constructor choose the
 * one with the smallest associated angle (i.e. the one whose axis
 * is orthogonal to the (u, v) plane). If u and v are colinear, an
 * arbitrary rotation axis is chosen.</p></text>
      <param>u origin vector</param>
      <param>v desired image of u by the rotation</param>
      <exception>MathArithmeticException if the norm of one of the vectors is zero</exception>
    </javadoc>
    <method type="constructor" name="FieldRotation" startLine="265" endLine="293">
      <declaration type="T" name="normProduct" />
      <scope startLine="268" endLine="270" />
      <declaration type="T" name="dot" />
      <scope startLine="274" endLine="282">
        <declaration type="FieldVector3D<T>" name="w" />
        <comment>special case u = -v: we select a PI angle rotation around</comment>
        <comment>an arbitrary vector orthogonal to u</comment>
      </scope>
      <scope startLine="282" endLine="291">
        <declaration type="T" name="coeff" />
        <declaration type="FieldVector3D<T>" name="q" />
        <comment>general case: (u, v) defines a plane, we select</comment>
        <comment>the shortest possible rotation: axis orthogonal to this plane</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Build a rotation from three Cardan or Euler elementary rotations.
 * <p>Cardan rotations are three successive rotations around the
 * canonical axes X, Y and Z, each axis being used once. There are
 * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
 * rotations are three successive rotations around the canonical
 * axes X, Y and Z, the first and last rotations being around the
 * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
 * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>
 * <p>Beware that many people routinely use the term Euler angles even
 * for what really are Cardan angles (this confusion is especially
 * widespread in the aerospace business where Roll, Pitch and Yaw angles
 * are often wrongly tagged as Euler angles).</p></text>
      <param>order order of rotations to use</param>
      <param>alpha1 angle of the first elementary rotation</param>
      <param>alpha2 angle of the second elementary rotation</param>
      <param>alpha3 angle of the third elementary rotation</param>
    </javadoc>
    <method type="constructor" name="FieldRotation" startLine="314" endLine="324">
      <declaration type="T" name="one" />
      <declaration type="FieldRotation<T>" name="r1" />
      <declaration type="FieldRotation<T>" name="r2" />
      <declaration type="FieldRotation<T>" name="r3" />
      <declaration type="FieldRotation<T>" name="composed" />
    </method>
    <javadoc>
      <text>* Convert an orthogonal rotation matrix to a quaternion.</text>
      <param>ort orthogonal rotation matrix</param>
      <return>quaternion corresponding to the matrix</return>
    </javadoc>
    <method type="T[]" name="mat2quat" startLine="330" endLine="385">
      <declaration type="T[]" name="quat" />
      <declaration type="T" name="s" />
      <scope startLine="346" endLine="353">
        <declaration type="T" name="inv" />
        <comment>compute q0 and deduce q1, q2 and q3</comment>
      </scope>
      <scope startLine="353" endLine="381">
        <scope startLine="355" endLine="362">
          <declaration type="T" name="inv" />
        </scope>
        <scope startLine="362" endLine="380">
          <scope startLine="364" endLine="371">
            <declaration type="T" name="inv" />
          </scope>
          <scope startLine="371" endLine="379">
            <declaration type="T" name="inv" />
          </scope>
        </scope>
        <comment>compute q1 and deduce q0, q2 and q3</comment>
        <comment>compute q2 and deduce q0, q1 and q3</comment>
        <comment>compute q3 and deduce q0, q1 and q2</comment>
      </scope>
      <comment>There are different ways to compute the quaternions elements</comment>
      <comment>from the matrix. They all involve computing one element from</comment>
      <comment>the diagonal of the matrix, and computing the three other ones</comment>
      <comment>using a formula involving a division by the first element,</comment>
      <comment>which unfortunately can be zero. Since the norm of the</comment>
      <comment>quaternion is 1, we know at least one element has an absolute</comment>
      <comment>value greater or equal to 0.5, so it is always possible to</comment>
      <comment>select the right formula and avoid division by zero and even</comment>
      <comment>numerical inaccuracy. Checking the elements in turn and using</comment>
      <comment>the first one greater than 0.45 is safe (this leads to a simple</comment>
      <comment>test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)</comment>
    </method>
    <javadoc>
      <text>* Revert a rotation.
 * Build a rotation which reverse the effect of another
 * rotation. This means that if r(u) = v, then r.revert(v) = u. The
 * instance is not changed.</text>
      <return>a new rotation whose effect is the reverse of the effect
 * of the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="revert" startLine="394" endLine="396" />
    <javadoc>
      <text>* Get the scalar coordinate of the quaternion.</text>
      <return>scalar coordinate of the quaternion</return>
    </javadoc>
    <method type="T" name="getQ0" startLine="401" endLine="403" />
    <javadoc>
      <text>* Get the first coordinate of the vectorial part of the quaternion.</text>
      <return>first coordinate of the vectorial part of the quaternion</return>
    </javadoc>
    <method type="T" name="getQ1" startLine="408" endLine="410" />
    <javadoc>
      <text>* Get the second coordinate of the vectorial part of the quaternion.</text>
      <return>second coordinate of the vectorial part of the quaternion</return>
    </javadoc>
    <method type="T" name="getQ2" startLine="415" endLine="417" />
    <javadoc>
      <text>* Get the third coordinate of the vectorial part of the quaternion.</text>
      <return>third coordinate of the vectorial part of the quaternion</return>
    </javadoc>
    <method type="T" name="getQ3" startLine="422" endLine="424" />
    <javadoc>
      <text>* Get the normalized axis of the rotation.</text>
      <return>normalized axis of the rotation</return>
      <see>#FieldRotation(FieldVector3D,RealFieldElement)</see>
    </javadoc>
    <method type="FieldVector3D<T>" name="getAxis" startLine="430" endLine="441">
      <declaration type="T" name="squaredSine" />
      <scope startLine="432" endLine="435">
        <declaration type="Field<T>" name="field" />
      </scope>
      <scope startLine="435" endLine="438">
        <declaration type="T" name="inverse" />
      </scope>
      <declaration type="T" name="inverse" />
    </method>
    <javadoc>
      <text>* Get the angle of the rotation.</text>
      <return>angle of the rotation (between 0 and &pi;)</return>
      <see>#FieldRotation(FieldVector3D,RealFieldElement)</see>
    </javadoc>
    <method type="T" name="getAngle" startLine="447" endLine="454">
      <scope startLine="448" endLine="450" />
      <scope startLine="450" endLine="452" />
    </method>
    <javadoc>
      <text>* Get the Cardan or Euler angles corresponding to the instance.
 * <p>The equations show that each rotation can be defined by two
 * different values of the Cardan or Euler angles set. For example
 * if Cardan angles are used, the rotation defined by the angles
 * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as
 * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;
 * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements
 * the following arbitrary choices:</p>
 * <ul>
 * <li>for Cardan angles, the chosen set is the one for which the
 * second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is
 * positive),</li>
 * <li>for Euler angles, the chosen set is the one for which the
 * second angle is between 0 and &pi; (i.e its sine is positive).</li>
 * </ul>
 * <p>Cardan and Euler angle have a very disappointing drawback: all
 * of them have singularities. This means that if the instance is
 * too close to the singularities corresponding to the given
 * rotation order, it will be impossible to retrieve the angles. For
 * Cardan angles, this is often called gimbal lock. There is
 * <em>nothing</em> to do to prevent this, it is an intrinsic problem
 * with Cardan and Euler representation (but not a problem with the
 * rotation itself, which is perfectly well defined). For Cardan
 * angles, singularities occur when the second angle is close to
 * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the
 * second angle is close to 0 or &pi;, this implies that the identity
 * rotation is always singular for Euler angles!</p></text>
      <param>order rotation order to use</param>
      <return>an array of three angles, in the order specified by the set</return>
      <exception>CardanEulerSingularityException if the rotation is
 * singular with respect to the angles set specified</exception>
    </javadoc>
    <method type="T[]" name="getAngles" startLine="492" endLine="688">
      <scope startLine="494" endLine="510">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="503" endLine="505" />
        <comment>r (+K) coordinates are :</comment>
        <comment>sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)</comment>
        <comment>(-r) (+I) coordinates are :</comment>
        <comment>cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)</comment>
        <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="510" endLine="526">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="519" endLine="521" />
        <comment>r (+J) coordinates are :</comment>
        <comment>-sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)</comment>
        <comment>(-r) (+I) coordinates are :</comment>
        <comment>cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)</comment>
        <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="526" endLine="542">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="535" endLine="537" />
        <comment>r (+K) coordinates are :</comment>
        <comment>cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)</comment>
        <comment>(-r) (+J) coordinates are :</comment>
        <comment>sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)</comment>
        <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="542" endLine="558">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="551" endLine="553" />
        <comment>r (+I) coordinates are :</comment>
        <comment>cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)</comment>
        <comment>(-r) (+J) coordinates are :</comment>
        <comment>sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)</comment>
        <comment>and we can choose to have psi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="558" endLine="574">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="567" endLine="569" />
        <comment>r (+J) coordinates are :</comment>
        <comment>-cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)</comment>
        <comment>(-r) (+K) coordinates are :</comment>
        <comment>-sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)</comment>
        <comment>and we can choose to have phi in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="574" endLine="590">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="583" endLine="585" />
        <comment>r (+I) coordinates are :</comment>
        <comment>cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)</comment>
        <comment>(-r) (+K) coordinates are :</comment>
        <comment>-sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)</comment>
        <comment>and we can choose to have theta in the interval [-PI/2 ; +PI/2]</comment>
      </scope>
      <scope startLine="590" endLine="606">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="599" endLine="601" />
        <comment>r (+I) coordinates are :</comment>
        <comment>cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)</comment>
        <comment>(-r) (+I) coordinates are :</comment>
        <comment>cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)</comment>
        <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="606" endLine="622">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="615" endLine="617" />
        <comment>r (+I) coordinates are :</comment>
        <comment>cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)</comment>
        <comment>(-r) (+I) coordinates are :</comment>
        <comment>cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)</comment>
        <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="622" endLine="638">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="631" endLine="633" />
        <comment>r (+J) coordinates are :</comment>
        <comment>sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)</comment>
        <comment>(-r) (+J) coordinates are :</comment>
        <comment>sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)</comment>
        <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="638" endLine="654">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="647" endLine="649" />
        <comment>r (+J) coordinates are :</comment>
        <comment>-cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)</comment>
        <comment>(-r) (+J) coordinates are :</comment>
        <comment>sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)</comment>
        <comment>and we can choose to have psi in the interval [0 ; PI]</comment>
      </scope>
      <scope startLine="654" endLine="670">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="663" endLine="665" />
        <comment>r (+K) coordinates are :</comment>
        <comment>sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)</comment>
        <comment>(-r) (+K) coordinates are :</comment>
        <comment>sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)</comment>
        <comment>and we can choose to have phi in the interval [0 ; PI]</comment>
        <comment>last possibility is ZYZ</comment>
      </scope>
      <scope startLine="670" endLine="686">
        <declaration type="FieldVector3D<T>" name="v1" />
        <declaration type="FieldVector3D<T>" name="v2" />
        <scope startLine="679" endLine="681" />
        <comment>r (+K) coordinates are :</comment>
        <comment>cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)</comment>
        <comment>(-r) (+K) coordinates are :</comment>
        <comment>-sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)</comment>
        <comment>and we can choose to have theta in the interval [0 ; PI]</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Create a dimension 3 array.</text>
      <param>a0 first array element</param>
      <param>a1 second array element</param>
      <param>a2 third array element</param>
      <return>new array</return>
    </javadoc>
    <method type="T[]" name="buildArray" startLine="696" endLine="702">
      <declaration type="T[]" name="array" />
    </method>
    <javadoc>
      <text>* Create a constant vector.</text>
      <param>x abscissa</param>
      <param>y ordinate</param>
      <param>z height</param>
      <return>a constant vector</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="vector" startLine="710" endLine="713">
      <declaration type="T" name="zero" />
    </method>
    <javadoc>
      <text>* Get the 3X3 matrix corresponding to the instance</text>
      <return>the matrix corresponding to the instance</return>
    </javadoc>
    <method type="T[][]" name="getMatrix" startLine="718" endLine="749">
      <declaration type="T" name="q0q0" />
      <declaration type="T" name="q0q1" />
      <declaration type="T" name="q0q2" />
      <declaration type="T" name="q0q3" />
      <declaration type="T" name="q1q1" />
      <declaration type="T" name="q1q2" />
      <declaration type="T" name="q1q3" />
      <declaration type="T" name="q2q2" />
      <declaration type="T" name="q2q3" />
      <declaration type="T" name="q3q3" />
      <declaration type="T[][]" name="m" />
      <comment>products</comment>
      <comment>create the matrix</comment>
    </method>
    <javadoc>
      <text>* Convert to a constant vector without derivatives.</text>
      <return>a constant vector</return>
    </javadoc>
    <method type="Rotation" name="toRotation" startLine="754" endLine="756" />
    <javadoc>
      <text>* Apply the rotation to a vector.</text>
      <param>u vector to apply the rotation to</param>
      <return>a new vector which is the image of u by the rotation</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="applyTo" startLine="762" endLine="774">
      <declaration type="T" name="x" />
      <declaration type="T" name="y" />
      <declaration type="T" name="z" />
      <declaration type="T" name="s" />
    </method>
    <javadoc>
      <text>* Apply the rotation to a vector.</text>
      <param>u vector to apply the rotation to</param>
      <return>a new vector which is the image of u by the rotation</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="applyTo" startLine="780" endLine="792">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="T" name="s" />
    </method>
    <javadoc>
      <text>* Apply the rotation to a vector stored in an array.</text>
      <param>in an array with three items which stores vector to rotate</param>
      <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
    </javadoc>
    <method type="void" name="applyTo" startLine="799" endLine="811">
      <declaration type="T" name="x" />
      <declaration type="T" name="y" />
      <declaration type="T" name="z" />
      <declaration type="T" name="s" />
    </method>
    <javadoc>
      <text>* Apply the rotation to a vector stored in an array.</text>
      <param>in an array with three items which stores vector to rotate</param>
      <param>out an array with three items to put result to</param>
    </javadoc>
    <method type="void" name="applyTo" startLine="817" endLine="829">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="T" name="s" />
    </method>
    <javadoc>
      <text>* Apply a rotation to a vector.</text>
      <param>r rotation to apply</param>
      <param>u vector to apply the rotation to</param>
      <param><T>
 *  the type of the field elements</param>
      <return>a new vector which is the image of u by the rotation</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="applyTo" startLine="837" endLine="849">
      <declaration type="T" name="x" />
      <declaration type="T" name="y" />
      <declaration type="T" name="z" />
      <declaration type="T" name="s" />
    </method>
    <javadoc>
      <text>* Apply the inverse of the rotation to a vector.</text>
      <param>u vector to apply the inverse of the rotation to</param>
      <return>a new vector which such that u is its image by the rotation</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="applyInverseTo" startLine="855" endLine="868">
      <declaration type="T" name="x" />
      <declaration type="T" name="y" />
      <declaration type="T" name="z" />
      <declaration type="T" name="s" />
      <declaration type="T" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the inverse of the rotation to a vector.</text>
      <param>u vector to apply the inverse of the rotation to</param>
      <return>a new vector which such that u is its image by the rotation</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="applyInverseTo" startLine="874" endLine="887">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="T" name="s" />
      <declaration type="T" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the inverse of the rotation to a vector stored in an array.</text>
      <param>in an array with three items which stores vector to rotate</param>
      <param>out an array with three items to put result to (it can be the same
 * array as in)</param>
    </javadoc>
    <method type="void" name="applyInverseTo" startLine="894" endLine="907">
      <declaration type="T" name="x" />
      <declaration type="T" name="y" />
      <declaration type="T" name="z" />
      <declaration type="T" name="s" />
      <declaration type="T" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the inverse of the rotation to a vector stored in an array.</text>
      <param>in an array with three items which stores vector to rotate</param>
      <param>out an array with three items to put result to</param>
    </javadoc>
    <method type="void" name="applyInverseTo" startLine="913" endLine="926">
      <declaration type="double" name="x" />
      <declaration type="double" name="y" />
      <declaration type="double" name="z" />
      <declaration type="T" name="s" />
      <declaration type="T" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the inverse of a rotation to a vector.</text>
      <param>r rotation to apply</param>
      <param>u vector to apply the inverse of the rotation to</param>
      <param><T>
 *  the type of the field elements</param>
      <return>a new vector which such that u is its image by the rotation</return>
    </javadoc>
    <method type="FieldVector3D<T>" name="applyInverseTo" startLine="934" endLine="947">
      <declaration type="T" name="x" />
      <declaration type="T" name="y" />
      <declaration type="T" name="z" />
      <declaration type="T" name="s" />
      <declaration type="double" name="m0" />
    </method>
    <javadoc>
      <text>* Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).</text>
      <param>r rotation to apply the rotation to</param>
      <return>a new rotation which is the composition of r by the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="applyTo" startLine="958" endLine="964" />
    <javadoc>
      <text>* Apply the instance to another rotation.
 * Applying the instance to a rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
 * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(r).</text>
      <param>r rotation to apply the rotation to</param>
      <return>a new rotation which is the composition of r by the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="applyTo" startLine="975" endLine="981" />
    <javadoc>
      <text>* Apply a rotation to another rotation.
 * Applying a rotation to another rotation is computing the composition
 * in an order compliant with the following rule : let u be any
 * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image
 * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),
 * where comp = applyTo(rOuter, rInner).</text>
      <param>r1 rotation to apply</param>
      <param>rInner rotation to apply the rotation to</param>
      <param><T>
 *  the type of the field elements</param>
      <return>a new rotation which is the composition of r by the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="applyTo" startLine="994" endLine="1000" />
    <javadoc>
      <text>* Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).</text>
      <param>r rotation to apply the rotation to</param>
      <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="applyInverseTo" startLine="1013" endLine="1019" />
    <javadoc>
      <text>* Apply the inverse of the instance to another rotation.
 * Applying the inverse of the instance to a rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
 * let w be the inverse image of v by the instance
 * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(r).</text>
      <param>r rotation to apply the rotation to</param>
      <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="applyInverseTo" startLine="1032" endLine="1038" />
    <javadoc>
      <text>* Apply the inverse of a rotation to another rotation.
 * Applying the inverse of a rotation to another rotation is computing
 * the composition in an order compliant with the following rule :
 * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),
 * let w be the inverse image of v by rOuter
 * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where
 * comp = applyInverseTo(rOuter, rInner).</text>
      <param>rOuter rotation to apply the rotation to</param>
      <param>rInner rotation to apply the rotation to</param>
      <param><T>
 *  the type of the field elements</param>
      <return>a new rotation which is the composition of r by the inverse
 * of the instance</return>
    </javadoc>
    <method type="FieldRotation<T>" name="applyInverseTo" startLine="1053" endLine="1059" />
    <javadoc>
      <text>* Perfect orthogonality on a 3X3 matrix.</text>
      <param>m initial matrix (not exactly orthogonal)</param>
      <param>threshold convergence threshold for the iterative
 * orthogonality correction (convergence is reached when the
 * difference between two steps of the Frobenius norm of the
 * correction is below this threshold)</param>
      <return>an orthogonal matrix close to m</return>
      <exception>NotARotationMatrixException if the matrix cannot be
 * orthogonalized with the given threshold after 10 iterations</exception>
    </javadoc>
    <method type="T[][]" name="orthogonalizeMatrix" startLine="1072" endLine="1153">
      <declaration type="T" name="x00" />
      <declaration type="T" name="x01" />
      <declaration type="T" name="x02" />
      <declaration type="T" name="x10" />
      <declaration type="T" name="x11" />
      <declaration type="T" name="x12" />
      <declaration type="T" name="x20" />
      <declaration type="T" name="x21" />
      <declaration type="T" name="x22" />
      <declaration type="double" name="fn" />
      <declaration type="double" name="fn1" />
      <declaration type="T[][]" name="o" />
      <declaration type="int" name="i" />
      <scope startLine="1090" endLine="1147">
        <declaration type="T" name="mx00" />
        <declaration type="T" name="mx10" />
        <declaration type="T" name="mx20" />
        <declaration type="T" name="mx01" />
        <declaration type="T" name="mx11" />
        <declaration type="T" name="mx21" />
        <declaration type="T" name="mx02" />
        <declaration type="T" name="mx12" />
        <declaration type="T" name="mx22" />
        <declaration type="double" name="corr00" />
        <declaration type="double" name="corr01" />
        <declaration type="double" name="corr02" />
        <declaration type="double" name="corr10" />
        <declaration type="double" name="corr11" />
        <declaration type="double" name="corr12" />
        <declaration type="double" name="corr20" />
        <declaration type="double" name="corr21" />
        <declaration type="double" name="corr22" />
        <scope startLine="1131" endLine="1133" />
        <comment>Mt.Xn</comment>
        <comment>Xn+1</comment>
        <comment>correction on each elements</comment>
        <comment>Frobenius norm of the correction</comment>
        <comment>convergence test</comment>
        <comment>prepare next iteration</comment>
      </scope>
      <comment>iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)</comment>
      <comment>the algorithm did not converge after 10 iterations</comment>
    </method>
    <javadoc>
      <text>* Compute the <i>distance</i> between two rotations.
 * <p>The <i>distance</i> is intended here as a way to check if two
 * rotations are almost similar (i.e. they transform vectors the same way)
 * or very different. It is mathematically defined as the angle of
 * the rotation r that prepended to one of the rotations gives the other
 * one:</p>
 * <pre>
 * r<sub>1</sub>(r) = r<sub>2</sub>
 * </pre>
 * <p>This distance is an angle between 0 and &pi;. Its value is the smallest
 * possible upper bound of the angle in radians between r<sub>1</sub>(v)
 * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is
 * reached for some v. The distance is equal to 0 if and only if the two
 * rotations are identical.</p>
 * <p>Comparing two rotations should always be done using this value rather
 * than for example comparing the components of the quaternions. It is much
 * more stable, and has a geometric meaning. Also comparing quaternions
 * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
 * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
 * their components are different (they are exact opposites).</p></text>
      <param>r1 first rotation</param>
      <param>r2 second rotation</param>
      <param><T>
 *  the type of the field elements</param>
      <return><i>distance</i> between r1 and r2</return>
    </javadoc>
    <method type="T" name="distance" startLine="1180" endLine="1182" />
  </class>
</source>
