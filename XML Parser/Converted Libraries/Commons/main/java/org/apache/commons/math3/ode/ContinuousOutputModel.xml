<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode">
  <import name="java.io.Serializable" />
  <import name="java.util.ArrayList" />
  <import name="java.util.List" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.ode.sampling.StepHandler" />
  <import name="org.apache.commons.math3.ode.sampling.StepInterpolator" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="ContinuousOutputModel" startLine="32">
    <implements name="StepHandler" />
    <implements name="Serializable" />
    <javadoc>
      <text>* This class stores all information provided by an ODE integrator
 * during the integration process and build a continuous model of the
 * solution from this.
 * <p>This class act as a step handler from the integrator point of
 * view. It is called iteratively during the integration process and
 * stores a copy of all steps information in a sorted collection for
 * later use. Once the integration process is over, the user can use
 * the {@link #setInterpolatedTime setInterpolatedTime} and {@link #getInterpolatedState getInterpolatedState} to retrieve this
 * information at any time. It is important to wait for the
 * integration to be over before attempting to call {@link #setInterpolatedTime setInterpolatedTime} because some internal
 * variables are set only once the last step has been handled.</p>
 * <p>This is useful for example if the main loop of the user
 * application should remain independent from the integration process
 * or if one needs to mimic the behaviour of an analytical model
 * despite a numerical model is used (i.e. one needs the ability to
 * get the model value at any time or to navigate through the
 * data).</p>
 * <p>If problem modeling is done with several separate
 * integration phases for contiguous intervals, the same
 * ContinuousOutputModel can be used as step handler for all
 * integration phases as long as they are performed in order and in
 * the same direction. As an example, one can extrapolate the
 * trajectory of a satellite with one model (i.e. one set of
 * differential equations) up to the beginning of a maneuver, use
 * another more complex model including thrusters modeling and
 * accurate attitude control during the maneuver, and revert to the
 * first model after the end of the maneuver. If the same continuous
 * output model handles the steps of all integration phases, the user
 * do not need to bother when the maneuver begins or ends, he has all
 * the data available in a transparent manner.</p>
 * <p>An important feature of this class is that it implements the
 * <code>Serializable</code> interface. This means that the result of
 * an integration can be serialized and reused later (if stored into a
 * persistent medium like a filesystem or a database) or elsewhere (if
 * sent to another application). Only the result of the integration is
 * stored, there is no reference to the integrated problem by
 * itself.</p>
 * <p>One should be aware that the amount of data stored in a
 * ContinuousOutputModel instance can be important if the state vector
 * is large, if the integration interval is long or if the steps are
 * small (which can result from small tolerance settings in {@link org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator adaptive
 * step size integrators}).</p></text>
      <see>StepHandler</see>
      <see>StepInterpolator</see>
      <version>$Id: ContinuousOutputModel.java 1463684 2013-04-02 19:04:13Z luc $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Serializable version identifier</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Initial integration time.</text>
    </javadoc>
    <declaration type="double" name="initialTime" />
    <javadoc>
      <text>* Final integration time.</text>
    </javadoc>
    <declaration type="double" name="finalTime" />
    <javadoc>
      <text>* Integration direction indicator.</text>
    </javadoc>
    <declaration type="boolean" name="forward" />
    <javadoc>
      <text>* Current interpolator index.</text>
    </javadoc>
    <declaration type="int" name="index" />
    <javadoc>
      <text>* Steps table.</text>
    </javadoc>
    <declaration type="List<StepInterpolator>" name="steps" />
    <javadoc>
      <text>* Simple constructor.
 * Build an empty continuous output model.</text>
    </javadoc>
    <method type="constructor" name="ContinuousOutputModel" startLine="114" endLine="120" />
    <javadoc>
      <text>* Append another model at the end of the instance.</text>
      <param>model model to add at the end of the instance</param>
      <exception>MathIllegalArgumentException if the model to append is not
 * compatible with the instance (dimension of the state vector,
 * propagation direction, hole between the dates)</exception>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded
 * during step finalization</exception>
    </javadoc>
    <method type="void" name="append" startLine="131" endLine="170">
      <scope startLine="133" endLine="135" />
      <scope startLine="137" endLine="140" />
      <scope startLine="140" endLine="161">
        <scope startLine="142" endLine="145" />
        <scope startLine="147" endLine="149" />
        <declaration type="StepInterpolator" name="lastInterpolator" />
        <declaration type="double" name="current" />
        <declaration type="double" name="previous" />
        <declaration type="double" name="step" />
        <declaration type="double" name="gap" />
        <scope startLine="156" endLine="159" />
      </scope>
      <scope startLine="163" endLine="165" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="init" startLine="173" endLine="179" />
    <javadoc>
      <text>* Handle the last accepted step.
 * A copy of the information provided by the last step is stored in
 * the instance for later use.</text>
      <param>interpolator interpolator for the last accepted step.</param>
      <param>isLast true if the step is the last one</param>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded
 * during step finalization</exception>
    </javadoc>
    <method type="void" name="handleStep" startLine="190" endLine="204">
      <scope startLine="192" endLine="195" />
      <scope startLine="199" endLine="202" />
    </method>
    <javadoc>
      <text>* Get the initial integration time.</text>
      <return>initial integration time</return>
    </javadoc>
    <method type="double" name="getInitialTime" startLine="210" endLine="212" />
    <javadoc>
      <text>* Get the final integration time.</text>
      <return>final integration time</return>
    </javadoc>
    <method type="double" name="getFinalTime" startLine="218" endLine="220" />
    <javadoc>
      <text>* Get the time of the interpolated point.
 * If {@link #setInterpolatedTime} has not been called, it returns
 * the final integration time.</text>
      <return>interpolation point time</return>
    </javadoc>
    <method type="double" name="getInterpolatedTime" startLine="228" endLine="230" />
    <javadoc>
      <text>* Set the time of the interpolated point.
 * <p>This method should <strong>not</strong> be called before the
 * integration is over because some internal variables are set only
 * once the last step has been handled.</p>
 * <p>Setting the time outside of the integration interval is now
 * allowed (it was not allowed up to version 5.9 of Mantissa), but
 * should be used with care since the accuracy of the interpolator
 * will probably be very poor far from this interval. This allowance
 * has been added to simplify implementation of search algorithms
 * near the interval endpoints.</p></text>
      <param>time time of the interpolated point</param>
    </javadoc>
    <method type="void" name="setInterpolatedTime" startLine="244" endLine="330">
      <declaration type="int" name="iMin" />
      <declaration type="StepInterpolator" name="sMin" />
      <declaration type="double" name="tMin" />
      <declaration type="int" name="iMax" />
      <declaration type="StepInterpolator" name="sMax" />
      <declaration type="double" name="tMax" />
      <scope startLine="257" endLine="261" />
      <scope startLine="262" endLine="266" />
      <scope startLine="269" endLine="320">
        <declaration type="StepInterpolator" name="si" />
        <declaration type="int" name="location" />
        <scope startLine="274" endLine="277" />
        <scope startLine="277" endLine="280" />
        <scope startLine="280" endLine="284" />
        <declaration type="int" name="iMed" />
        <declaration type="StepInterpolator" name="sMed" />
        <declaration type="double" name="tMed" />
        <scope startLine="291" endLine="294" />
        <scope startLine="294" endLine="309">
          <declaration type="double" name="d12" />
          <declaration type="double" name="d23" />
          <declaration type="double" name="d13" />
          <declaration type="double" name="dt1" />
          <declaration type="double" name="dt2" />
          <declaration type="double" name="dt3" />
          <declaration type="double" name="iLagrange" />
        </scope>
        <declaration type="int" name="low" />
        <declaration type="int" name="high" />
        <scope startLine="314" endLine="316" />
        <scope startLine="316" endLine="318" />
        <comment>use the last estimated index as the splitting index</comment>
        <comment>we have found the target step, no need to continue searching</comment>
        <comment>compute a new estimate of the index in the reduced table slice</comment>
        <comment>too close to the bounds, we estimate using a simple dichotomy</comment>
        <comment>estimate the index using a reverse quadratic polynom</comment>
        <comment>(reverse means we have i = P(t), thus allowing to simply</comment>
        <comment>compute index = P(time) rather than solving a quadratic equation)</comment>
        <comment>force the next size reduction to be at least one tenth</comment>
      </scope>
      <scope startLine="324" endLine="326" />
      <comment>initialize the search with the complete steps table</comment>
      <comment>handle points outside of the integration interval</comment>
      <comment>or in the first and last step</comment>
      <comment>reduction of the table slice size</comment>
      <comment>now the table slice is very small, we perform an iterative search</comment>
    </method>
    <javadoc>
      <text>* Get the state vector of the interpolated point.</text>
      <return>state vector at time {@link #getInterpolatedTime}</return>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
      <see>#getInterpolatedSecondaryState(int)</see>
    </javadoc>
    <method type="double[]" name="getInterpolatedState" startLine="338" endLine="340" />
    <javadoc>
      <text>* Get the interpolated secondary state corresponding to the secondary equations.</text>
      <param>secondaryStateIndex index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}</param>
      <return>interpolated secondary state at the current interpolation date</return>
      <see>#getInterpolatedState()</see>
      <since>3.2</since>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
    </javadoc>
    <method type="double[]" name="getInterpolatedSecondaryState" startLine="353" endLine="355" />
    <javadoc>
      <text>* Compare a step interval and a double.</text>
      <param>time point to locate</param>
      <param>interval step interval</param>
      <return>-1 if the double is before the interval, 0 if it is in
 * the interval, and +1 if it is after the interval, according to
 * the interval direction</return>
    </javadoc>
    <method type="int" name="locatePoint" startLine="364" endLine="381">
      <scope startLine="365" endLine="373">
        <scope startLine="366" endLine="368" />
        <scope startLine="368" endLine="370" />
        <scope startLine="370" endLine="372" />
      </scope>
      <scope startLine="374" endLine="376" />
      <scope startLine="376" endLine="378" />
      <scope startLine="378" endLine="380" />
    </method>
  </class>
</source>
