<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.geometry.euclidean.threed">
  <import name="java.awt.geom.AffineTransform" />
  <import name="java.util.Collection" />
  <import name="org.apache.commons.math3.geometry.Vector" />
  <import name="org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D" />
  <import name="org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D" />
  <import name="org.apache.commons.math3.geometry.euclidean.twod.SubLine" />
  <import name="org.apache.commons.math3.geometry.euclidean.twod.Vector2D" />
  <import name="org.apache.commons.math3.geometry.partitioning.AbstractRegion" />
  <import name="org.apache.commons.math3.geometry.partitioning.BSPTree" />
  <import name="org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor" />
  <import name="org.apache.commons.math3.geometry.partitioning.BoundaryAttribute" />
  <import name="org.apache.commons.math3.geometry.partitioning.Hyperplane" />
  <import name="org.apache.commons.math3.geometry.partitioning.Region" />
  <import name="org.apache.commons.math3.geometry.partitioning.RegionFactory" />
  <import name="org.apache.commons.math3.geometry.partitioning.SubHyperplane" />
  <import name="org.apache.commons.math3.geometry.partitioning.Transform" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="PolyhedronsSet" extends="AbstractRegion<Euclidean3D,Euclidean2D>" startLine="38">
    <javadoc>
      <text>* This class represents a 3D region: a set of polyhedrons.</text>
      <version>$Id: PolyhedronsSet.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Build a polyhedrons set representing the whole real line.</text>
    </javadoc>
    <method type="constructor" name="PolyhedronsSet" startLine="46" endLine="48" />
    <javadoc>
      <text>* Build a polyhedrons set from a BSP tree.
 * <p>The leaf nodes of the BSP tree <em>must</em> have a{@code Boolean} attribute representing the inside status of
 * the corresponding cell (true for inside cells, false for outside
 * cells). In order to avoid building too many small objects, it is
 * recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}</p></text>
      <param>tree inside/outside BSP tree representing the region</param>
    </javadoc>
    <method type="constructor" name="PolyhedronsSet" startLine="59" endLine="61" />
    <javadoc>
      <text>* Build a polyhedrons set from a Boundary REPresentation (B-rep).
 * <p>The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
 * interior part of the region on its minus side and the exterior on
 * its plus side.</p>
 * <p>The boundary elements can be in any order, and can form
 * several non-connected sets (like for example polyhedrons with holes
 * or a set of disjoint polyhedrons considered as a whole). In
 * fact, the elements do not even need to be connected together
 * (their topological connections are not used here). However, if the
 * boundary does not really separate an inside open from an outside
 * open (open having here its topological meaning), then subsequent
 * calls to the {@link Region#checkPoint(Vector) checkPoint} method will
 * not be meaningful anymore.</p>
 * <p>If the boundary is empty, the region will represent the whole
 * space.</p></text>
      <param>boundary collection of boundary elements, as a
 * collection of {@link SubHyperplane SubHyperplane} objects</param>
    </javadoc>
    <method type="constructor" name="PolyhedronsSet" startLine="82" endLine="84" />
    <javadoc>
      <text>* Build a parallellepipedic box.</text>
      <param>xMin low bound along the x direction</param>
      <param>xMax high bound along the x direction</param>
      <param>yMin low bound along the y direction</param>
      <param>yMax high bound along the y direction</param>
      <param>zMin low bound along the z direction</param>
      <param>zMax high bound along the z direction</param>
    </javadoc>
    <method type="constructor" name="PolyhedronsSet" startLine="96" endLine="98" />
    <javadoc>
      <text>* Build a parallellepipedic box boundary.</text>
      <param>xMin low bound along the x direction</param>
      <param>xMax high bound along the x direction</param>
      <param>yMin low bound along the y direction</param>
      <param>yMax high bound along the y direction</param>
      <param>zMin low bound along the z direction</param>
      <param>zMax high bound along the z direction</param>
      <return>boundary tree</return>
    </javadoc>
    <method type="BSPTree<Euclidean3D>" name="buildBoundary" startLine="111" endLine="122">
      <declaration type="Plane" name="pxMin" />
      <declaration type="Plane" name="pxMax" />
      <declaration type="Plane" name="pyMin" />
      <declaration type="Plane" name="pyMax" />
      <declaration type="Plane" name="pzMin" />
      <declaration type="Plane" name="pzMax" />
      <declaration type="Region<Euclidean3D>" name="boundary" />
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="PolyhedronsSet" name="buildNew" startLine="126" endLine="128" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="computeGeometricalProperties" startLine="132" endLine="148">
      <scope startLine="137" endLine="142">
        <comment>the polyhedrons set as a finite outside</comment>
        <comment>surrounded by an infinite inside</comment>
      </scope>
      <scope startLine="142" endLine="146">
        <comment>the polyhedrons set is finite, apply the remaining scaling factors</comment>
      </scope>
      <comment>compute the contribution of all boundary facets</comment>
    </method>
    <class name="FacetsContributionVisitor" startLine="150">
      <implements name="BSPTreeVisitor<Euclidean3D>" />
      <javadoc>
        <text>* Visitor computing geometrical properties.</text>
      </javadoc>
      <javadoc>
        <text>* Simple constructor.</text>
      </javadoc>
      <method type="constructor" name="FacetsContributionVisitor" startLine="154" endLine="157" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="Order" name="visitOrder" startLine="160" endLine="162" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visitInternalNode" startLine="165" endLine="175">
        <declaration type="BoundaryAttribute<Euclidean3D>" name="attribute" />
        <scope startLine="169" endLine="171" />
        <scope startLine="172" endLine="174" />
      </method>
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visitLeafNode" startLine="178" endLine="179" />
      <javadoc>
        <text>* Add he contribution of a boundary facet.</text>
        <param>facet boundary facet</param>
        <param>reversed if true, the facet has the inside on its plus side</param>
      </javadoc>
      <method type="void" name="addContribution" startLine="185" endLine="207">
        <declaration type="Region<Euclidean2D>" name="polygon" />
        <declaration type="double" name="area" />
        <scope startLine="190" endLine="193" />
        <scope startLine="193" endLine="205">
          <declaration type="Plane" name="plane" />
          <declaration type="Vector3D" name="facetB" />
          <declaration type="double" name="scaled" />
          <scope startLine="198" endLine="200" />
        </scope>
      </method>
      <javadoc>
        <text>* Get the first sub-hyperplane crossed by a semi-infinite line.</text>
        <param>point start point of the part of the line considered</param>
        <param>line line to consider (contains point)</param>
        <return>the first sub-hyperplaned crossed by the line after the
 * given point, or null if the line does not intersect any
 * sub-hyperplaned</return>
      </javadoc>
      <method type="SubHyperplane<Euclidean3D>" name="firstIntersection" startLine="218" endLine="220" />
      <javadoc>
        <text>* Get the first sub-hyperplane crossed by a semi-infinite line.</text>
        <param>node current node</param>
        <param>point start point of the part of the line considered</param>
        <param>line line to consider (contains point)</param>
        <return>the first sub-hyperplaned crossed by the line after the
 * given point, or null if the line does not intersect any
 * sub-hyperplaned</return>
      </javadoc>
      <method type="SubHyperplane<Euclidean3D>" name="recurseFirstIntersection" startLine="232" endLine="283">
        <declaration type="SubHyperplane<Euclidean3D>" name="cut" />
        <scope startLine="235" endLine="237" />
        <declaration type="BSPTree<Euclidean3D>" name="minus" />
        <declaration type="BSPTree<Euclidean3D>" name="plus" />
        <declaration type="Plane" name="plane" />
        <declaration type="double" name="offset" />
        <declaration type="boolean" name="in" />
        <declaration type="BSPTree<Euclidean3D>" name="near" />
        <declaration type="BSPTree<Euclidean3D>" name="far" />
        <scope startLine="247" endLine="250" />
        <scope startLine="250" endLine="253" />
        <scope startLine="255" endLine="261">
          <declaration type="SubHyperplane<Euclidean3D>" name="facet" />
          <scope startLine="258" endLine="260" />
          <comment>search in the cut hyperplane</comment>
        </scope>
        <declaration type="SubHyperplane<Euclidean3D>" name="crossed" />
        <scope startLine="265" endLine="267" />
        <scope startLine="269" endLine="278">
          <declaration type="Vector3D" name="hit3D" />
          <scope startLine="272" endLine="277">
            <declaration type="SubHyperplane<Euclidean3D>" name="facet" />
            <scope startLine="274" endLine="276" />
          </scope>
          <comment>search in the cut hyperplane</comment>
        </scope>
        <comment>establish search order</comment>
        <comment>search in the near branch</comment>
        <comment>search in the far branch</comment>
      </method>
      <javadoc>
        <text>* Check if a point belongs to the boundary part of a node.</text>
        <param>point point to check</param>
        <param>node node containing the boundary facet to check</param>
        <return>the boundary facet this points belongs to (or null if it
 * does not belong to any boundary facet)</return>
      </javadoc>
      <method type="SubHyperplane<Euclidean3D>" name="boundaryFacet" startLine="292" endLine="306">
        <declaration type="Vector2D" name="point2D" />
        <declaration type="BoundaryAttribute<Euclidean3D>" name="attribute" />
        <scope startLine="298" endLine="300" />
        <scope startLine="302" endLine="304" />
      </method>
      <javadoc>
        <text>* Rotate the region around the specified point.
 * <p>The instance is not modified, a new instance is created.</p></text>
        <param>center rotation center</param>
        <param>rotation vectorial rotation operator</param>
        <return>a new instance representing the rotated region</return>
      </javadoc>
      <method type="PolyhedronsSet" name="rotate" startLine="314" endLine="316" />
      <class name="RotationTransform" startLine="318">
        <implements name="Transform<Euclidean3D,Euclidean2D>" />
        <javadoc>
          <text>* 3D rotation as a Transform.</text>
        </javadoc>
        <javadoc>
          <text>* Center point of the rotation.</text>
        </javadoc>
        <declaration type="Vector3D" name="center" />
        <javadoc>
          <text>* Vectorial rotation.</text>
        </javadoc>
        <declaration type="Rotation" name="rotation" />
        <javadoc>
          <text>* Cached original hyperplane.</text>
        </javadoc>
        <declaration type="Plane" name="cachedOriginal" />
        <javadoc>
          <text>* Cached 2D transform valid inside the cached original hyperplane.</text>
        </javadoc>
        <declaration type="Transform<Euclidean2D,Euclidean1D>" name="cachedTransform" />
        <javadoc>
          <text>* Build a rotation transform.</text>
          <param>center center point of the rotation</param>
          <param>rotation vectorial rotation</param>
        </javadoc>
        <method type="constructor" name="RotationTransform" startLine="337" endLine="340" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="Vector3D" name="apply" startLine="343" endLine="346">
          <declaration type="Vector3D" name="delta" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="Plane" name="apply" startLine="349" endLine="351" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="SubHyperplane<Euclidean2D>" name="apply" startLine="356" endLine="378">
          <scope startLine="357" endLine="376">
            <declaration type="Plane" name="oPlane" />
            <declaration type="Plane" name="tPlane" />
            <declaration type="Vector3D" name="p00" />
            <declaration type="Vector3D" name="p10" />
            <declaration type="Vector3D" name="p01" />
            <declaration type="Vector2D" name="tP00" />
            <declaration type="Vector2D" name="tP10" />
            <declaration type="Vector2D" name="tP01" />
            <declaration type="AffineTransform" name="at" />
            <comment>we have changed hyperplane, reset the in-hyperplane transform</comment>
          </scope>
        </method>
        <javadoc>
          <text>* Translate the region by the specified amount.
 * <p>The instance is not modified, a new instance is created.</p></text>
          <param>translation translation to apply</param>
          <return>a new instance representing the translated region</return>
        </javadoc>
        <method type="PolyhedronsSet" name="translate" startLine="387" endLine="389" />
        <class name="TranslationTransform" startLine="391">
          <implements name="Transform<Euclidean3D,Euclidean2D>" />
          <javadoc>
            <text>* 3D translation as a transform.</text>
          </javadoc>
          <javadoc>
            <text>* Translation vector.</text>
          </javadoc>
          <declaration type="Vector3D" name="translation" />
          <javadoc>
            <text>* Cached original hyperplane.</text>
          </javadoc>
          <declaration type="Plane" name="cachedOriginal" />
          <javadoc>
            <text>* Cached 2D transform valid inside the cached original hyperplane.</text>
          </javadoc>
          <declaration type="Transform<Euclidean2D,Euclidean1D>" name="cachedTransform" />
          <javadoc>
            <text>* Build a translation transform.</text>
            <param>translation translation vector</param>
          </javadoc>
          <method type="constructor" name="TranslationTransform" startLine="406" endLine="408" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="Vector3D" name="apply" startLine="411" endLine="413" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="Plane" name="apply" startLine="416" endLine="418" />
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="SubHyperplane<Euclidean2D>" name="apply" startLine="423" endLine="441">
            <scope startLine="424" endLine="437">
              <declaration type="Plane" name="oPlane" />
              <declaration type="Plane" name="tPlane" />
              <declaration type="Vector2D" name="shift" />
              <declaration type="AffineTransform" name="at" />
              <comment>we have changed hyperplane, reset the in-hyperplane transform</comment>
            </scope>
          </method>
        </class>
      </class>
    </class>
  </class>
</source>
