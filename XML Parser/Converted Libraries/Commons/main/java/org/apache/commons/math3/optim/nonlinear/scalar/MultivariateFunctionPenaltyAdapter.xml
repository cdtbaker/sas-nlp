<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.scalar">
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="MultivariateFunctionPenaltyAdapter" startLine="25">
    <implements name="MultivariateFunction" />
    <javadoc>
      <text>* <p>Adapter extending bounded {@link MultivariateFunction} to an unbouded
 * domain using a penalty function.</p>
 * <p>
 * This adapter can be used to wrap functions subject to simple bounds on
 * parameters so they can be used by optimizers that do <em>not</em> directly
 * support simple bounds.
 * </p>
 * <p>
 * The principle is that the user function that will be wrapped will see its
 * parameters bounded as required, i.e when its {@code value} method is called
 * with argument array {@code point}, the elements array will fulfill requirement{@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components
 * may be unbounded or bounded only on one side if the corresponding bound is
 * set to an infinite value. The optimizer will not manage the user function by
 * itself, but it will handle this adapter and it is this adapter that will take
 * care the bounds are fulfilled. The adapter {@link #value(double[])} method will
 * be called by the optimizer with unbound parameters, and the adapter will check
 * if the parameters is within range or not. If it is in range, then the underlying
 * user function will be called, and if it is not the value of a penalty function
 * will be returned instead.
 * </p>
 * <p>
 * This adapter is only a poor-man's solution to simple bounds optimization
 * constraints that can be used with simple optimizers like{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerSimplexOptimizer}.
 * A better solution is to use an optimizer that directly supports simple bounds like{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerCMAESOptimizer} or{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.BOBYQAOptimizerBOBYQAOptimizer}.
 * One caveat of this poor-man's solution is that if start point or start simplex
 * is completely outside of the allowed range, only the penalty function is used,
 * and the optimizer may converge without ever entering the range.
 * </p></text>
      <see>MultivariateFunctionMappingAdapter</see>
      <version>$Id: MultivariateFunctionPenaltyAdapter.java 1435539 2013-01-19 13:27:24Z tn $</version>
      <since>3.0</since>
    </javadoc>
    <javadoc>
      <text>* Underlying bounded function.</text>
    </javadoc>
    <declaration type="MultivariateFunction" name="bounded" />
    <javadoc>
      <text>* Lower bounds.</text>
    </javadoc>
    <declaration type="double[]" name="lower" />
    <javadoc>
      <text>* Upper bounds.</text>
    </javadoc>
    <declaration type="double[]" name="upper" />
    <javadoc>
      <text>* Penalty offset.</text>
    </javadoc>
    <declaration type="double" name="offset" />
    <javadoc>
      <text>* Penalty scales.</text>
    </javadoc>
    <declaration type="double[]" name="scale" />
    <javadoc>
      <text>* Simple constructor.
 * <p>
 * When the optimizer provided points are out of range, the value of the
 * penalty function will be used instead of the value of the underlying
 * function. In order for this penalty to be effective in rejecting this
 * point during the optimization process, the penalty function value should
 * be defined with care. This value is computed as:
 * <pre>
 * penalty(point) = offset + &sum;<sub>i</sub>[scale[i] * &radic;|point[i]-boundary[i]|]
 * </pre>
 * where indices i correspond to all the components that violates their boundaries.
 * </p>
 * <p>
 * So when attempting a function minimization, offset should be larger than
 * the maximum expected value of the underlying function and scale components
 * should all be positive. When attempting a function maximization, offset
 * should be lesser than the minimum expected value of the underlying function
 * and scale components should all be negative.
 * minimization, and lesser than the minimum expected value of the underlying
 * function when attempting maximization.
 * </p>
 * <p>
 * These choices for the penalty function have two properties. First, all out
 * of range points will return a function value that is worse than the value
 * returned by any in range point. Second, the penalty is worse for large
 * boundaries violation than for small violations, so the optimizer has an hint
 * about the direction in which it should search for acceptable points.
 * </p></text>
      <param>bounded bounded function</param>
      <param>lower lower bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for
 * unbounded values)</param>
      <param>upper upper bounds for each element of the input parameters array
 * (some elements may be set to {@code Double.POSITIVE_INFINITY} for
 * unbounded values)</param>
      <param>offset base offset of the penalty function</param>
      <param>scale scale of the penalty function</param>
      <exception>DimensionMismatchException if lower bounds, upper bounds and
 * scales are not consistent, either according to dimension or to bounadary
 * values</exception>
    </javadoc>
    <method type="constructor" name="MultivariateFunctionPenaltyAdapter" startLine="125" endLine="149">
      <scope startLine="131" endLine="133" />
      <scope startLine="134" endLine="136" />
      <scope startLine="137" endLine="142">
        <scope startLine="139" endLine="141" />
        <comment>note the following test is written in such a way it also fails for NaN</comment>
      </scope>
      <comment>safety checks</comment>
    </method>
    <javadoc>
      <text>* Computes the underlying function value from an unbounded point.
 * <p>
 * This method simply returns the value of the underlying function
 * if the unbounded point already fulfills the bounds, and compute
 * a replacement value using the offset and scale if bounds are
 * violated, without calling the function at all.
 * </p></text>
      <param>point unbounded point</param>
      <return>either underlying function value or penalty function value</return>
    </javadoc>
    <method type="double" name="value" startLine="162" endLine="186">
      <scope startLine="164" endLine="181">
        <scope startLine="165" endLine="180">
          <declaration type="double" name="sum" />
          <scope startLine="168" endLine="178">
            <declaration type="double" name="overshoot" />
            <scope startLine="170" endLine="172" />
            <scope startLine="172" endLine="174" />
            <scope startLine="174" endLine="176" />
          </scope>
        </scope>
        <comment>bound violation starting at this component</comment>
      </scope>
      <comment>all boundaries are fulfilled, we are in the expected</comment>
      <comment>domain of the underlying function</comment>
    </method>
  </class>
</source>
