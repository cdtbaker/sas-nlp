<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.stat.descriptive">
  <import name="java.io.Serializable" />
  <import name="java.lang.reflect.InvocationTargetException" />
  <import name="java.util.Arrays" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.GeometricMean" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.Kurtosis" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.Mean" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.Skewness" />
  <import name="org.apache.commons.math3.stat.descriptive.moment.Variance" />
  <import name="org.apache.commons.math3.stat.descriptive.rank.Max" />
  <import name="org.apache.commons.math3.stat.descriptive.rank.Min" />
  <import name="org.apache.commons.math3.stat.descriptive.rank.Percentile" />
  <import name="org.apache.commons.math3.stat.descriptive.summary.Sum" />
  <import name="org.apache.commons.math3.stat.descriptive.summary.SumOfSquares" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <import name="org.apache.commons.math3.util.ResizableDoubleArray" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="DescriptiveStatistics" startLine="42">
    <implements name="StatisticalSummary" />
    <implements name="Serializable" />
    <javadoc>
      <text>* Maintains a dataset of values of a single variable and computes descriptive
 * statistics based on stored data. The {@link #getWindowSize() windowSize}property sets a limit on the number of values that can be stored in the
 * dataset.  The default value, INFINITE_WINDOW, puts no limit on the size of
 * the dataset.  This value should be used with caution, as the backing store
 * will grow without bound in this case.  For very large datasets,{@link SummaryStatistics}, which does not store the dataset, should be used
 * instead of this class. If <code>windowSize</code> is not INFINITE_WINDOW and
 * more values are added than can be stored in the dataset, new values are
 * added in a "rolling" manner, with new values replacing the "oldest" values
 * in the dataset.
 * <p>Note: this class is not threadsafe.  Use{@link SynchronizedDescriptiveStatistics} if concurrent access from multiple
 * threads is required.</p></text>
      <version>$Id: DescriptiveStatistics.java 1422354 2012-12-15 20:59:01Z psteitz $</version>
    </javadoc>
    <javadoc>
      <text>* Represents an infinite window size.  When the {@link #getWindowSize()}returns this value, there is no limit to the number of data values
 * that can be stored in the dataset.</text>
    </javadoc>
    <declaration type="int" name="INFINITE_WINDOW" />
    <javadoc>
      <text>* Serialization UID</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Name of the setQuantile method.</text>
    </javadoc>
    <declaration type="String" name="SET_QUANTILE_METHOD_NAME" />
    <javadoc>
      <text>* hold the window size</text>
    </javadoc>
    <declaration type="int" name="windowSize" />
    <javadoc>
      <text>* Stored data values</text>
    </javadoc>
    <declaration type="ResizableDoubleArray" name="eDA" />
    <javadoc>
      <text>* Mean statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="meanImpl" />
    <javadoc>
      <text>* Geometric mean statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="geometricMeanImpl" />
    <javadoc>
      <text>* Kurtosis statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="kurtosisImpl" />
    <javadoc>
      <text>* Maximum statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="maxImpl" />
    <javadoc>
      <text>* Minimum statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="minImpl" />
    <javadoc>
      <text>* Percentile statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="percentileImpl" />
    <javadoc>
      <text>* Skewness statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="skewnessImpl" />
    <javadoc>
      <text>* Variance statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="varianceImpl" />
    <javadoc>
      <text>* Sum of squares statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="sumsqImpl" />
    <javadoc>
      <text>* Sum statistic implementation - can be reset by setter.</text>
    </javadoc>
    <declaration type="UnivariateStatistic" name="sumImpl" />
    <javadoc>
      <text>* Construct a DescriptiveStatistics instance with an infinite window</text>
    </javadoc>
    <method type="constructor" name="DescriptiveStatistics" startLine="117" endLine="118" />
    <javadoc>
      <text>* Construct a DescriptiveStatistics instance with the specified window</text>
      <param>window the window size.</param>
      <throws>MathIllegalArgumentException if window size is less than 1 but
 * not equal to {@link #INFINITE_WINDOW}</throws>
    </javadoc>
    <method type="constructor" name="DescriptiveStatistics" startLine="127" endLine="129" />
    <javadoc>
      <text>* Construct a DescriptiveStatistics instance with an infinite window
 * and the initial data values in double[] initialDoubleArray.
 * If initialDoubleArray is null, then this constructor corresponds to
 * DescriptiveStatistics()</text>
      <param>initialDoubleArray the initial double[].</param>
    </javadoc>
    <method type="constructor" name="DescriptiveStatistics" startLine="139" endLine="143">
      <scope startLine="140" endLine="142" />
    </method>
    <javadoc>
      <text>* Copy constructor.  Construct a new DescriptiveStatistics instance that
 * is a copy of original.</text>
      <param>original DescriptiveStatistics instance to copy</param>
      <throws>NullArgumentException if original is null</throws>
    </javadoc>
    <method type="constructor" name="DescriptiveStatistics" startLine="152" endLine="154" />
    <javadoc>
      <text>* Adds the value to the dataset. If the dataset is at the maximum size
 * (i.e., the number of stored elements equals the currently configured
 * windowSize), the first (oldest) element in the dataset is discarded
 * to make room for the new value.</text>
      <param>v the value to be added</param>
    </javadoc>
    <method type="void" name="addValue" startLine="164" endLine="174">
      <scope startLine="165" endLine="171">
        <scope startLine="166" endLine="168" />
        <scope startLine="168" endLine="170" />
      </scope>
      <scope startLine="171" endLine="173" />
    </method>
    <javadoc>
      <text>* Removes the most recent value from the dataset.</text>
      <throws>MathIllegalStateException if there are no elements stored</throws>
    </javadoc>
    <method type="void" name="removeMostRecentValue" startLine="181" endLine="187">
      <scope startLine="182" endLine="184" />
      <scope startLine="184" endLine="186" />
    </method>
    <javadoc>
      <text>* Replaces the most recently stored value with the given value.
 * There must be at least one element stored to call this method.</text>
      <param>v the value to replace the most recent stored value</param>
      <return>replaced value</return>
      <throws>MathIllegalStateException if there are no elements stored</throws>
    </javadoc>
    <method type="double" name="replaceMostRecentValue" startLine="197" endLine="199" />
    <javadoc>
      <text>* Returns the <a href="http://www.xycoon.com/arithmetic_mean.htm">
 * arithmetic mean </a> of the available values</text>
      <return>The mean or Double.NaN if no values have been added.</return>
    </javadoc>
    <method type="double" name="getMean" startLine="206" endLine="208" />
    <javadoc>
      <text>* Returns the <a href="http://www.xycoon.com/geometric_mean.htm">
 * geometric mean </a> of the available values</text>
      <return>The geometricMean, Double.NaN if no values have been added,
 * or if the product of the available values is less than or equal to 0.</return>
    </javadoc>
    <method type="double" name="getGeometricMean" startLine="216" endLine="218" />
    <javadoc>
      <text>* Returns the (sample) variance of the available values.
 * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in
 * the denominator).  Use {@link #getPopulationVariance()} for the non-bias-corrected
 * population variance.</p></text>
      <return>The variance, Double.NaN if no values have been added
 * or 0.0 for a single value set.</return>
    </javadoc>
    <method type="double" name="getVariance" startLine="230" endLine="232" />
    <javadoc>
      <text>* Returns the <a href="http://en.wikibooks.org/wiki/Statistics/Summary/Variance">
 * population variance</a> of the available values.</text>
      <return>The population variance, Double.NaN if no values have been added,
 * or 0.0 for a single value set.</return>
    </javadoc>
    <method type="double" name="getPopulationVariance" startLine="241" endLine="243" />
    <javadoc>
      <text>* Returns the standard deviation of the available values.</text>
      <return>The standard deviation, Double.NaN if no values have been added
 * or 0.0 for a single value set.</return>
    </javadoc>
    <method type="double" name="getStandardDeviation" startLine="250" endLine="260">
      <declaration type="double" name="stdDev" />
      <scope startLine="252" endLine="258">
        <scope startLine="253" endLine="255" />
        <scope startLine="255" endLine="257" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the skewness of the available values. Skewness is a
 * measure of the asymmetry of a given distribution.</text>
      <return>The skewness, Double.NaN if no values have been added
 * or 0.0 for a value set &lt;=2.</return>
    </javadoc>
    <method type="double" name="getSkewness" startLine="268" endLine="270" />
    <javadoc>
      <text>* Returns the Kurtosis of the available values. Kurtosis is a
 * measure of the "peakedness" of a distribution</text>
      <return>The kurtosis, Double.NaN if no values have been added, or 0.0
 * for a value set &lt;=3.</return>
    </javadoc>
    <method type="double" name="getKurtosis" startLine="278" endLine="280" />
    <javadoc>
      <text>* Returns the maximum of the available values</text>
      <return>The max or Double.NaN if no values have been added.</return>
    </javadoc>
    <method type="double" name="getMax" startLine="286" endLine="288" />
    <javadoc>
      <text>* Returns the minimum of the available values</text>
      <return>The min or Double.NaN if no values have been added.</return>
    </javadoc>
    <method type="double" name="getMin" startLine="294" endLine="296" />
    <javadoc>
      <text>* Returns the number of available values</text>
      <return>The number of available values</return>
    </javadoc>
    <method type="long" name="getN" startLine="302" endLine="304" />
    <javadoc>
      <text>* Returns the sum of the values that have been added to Univariate.</text>
      <return>The sum or Double.NaN if no values have been added</return>
    </javadoc>
    <method type="double" name="getSum" startLine="310" endLine="312" />
    <javadoc>
      <text>* Returns the sum of the squares of the available values.</text>
      <return>The sum of the squares or Double.NaN if no
 * values have been added.</return>
    </javadoc>
    <method type="double" name="getSumsq" startLine="319" endLine="321" />
    <javadoc>
      <text>* Resets all statistics and storage</text>
    </javadoc>
    <method type="void" name="clear" startLine="326" endLine="328" />
    <javadoc>
      <text>* Returns the maximum number of values that can be stored in the
 * dataset, or INFINITE_WINDOW (-1) if there is no limit.</text>
      <return>The current window size or -1 if its Infinite.</return>
    </javadoc>
    <method type="int" name="getWindowSize" startLine="337" endLine="339" />
    <javadoc>
      <text>* WindowSize controls the number of values that contribute to the
 * reported statistics.  For example, if windowSize is set to 3 and the
 * values {1,2,3,4,5} have been added <strong> in that order</strong> then
 * the <i>available values</i> are {3,4,5} and all reported statistics will
 * be based on these values. If {@code windowSize} is decreased as a result
 * of this call and there are more than the new value of elements in the
 * current dataset, values from the front of the array are discarded to
 * reduce the dataset to {@code windowSize} elements.</text>
      <param>windowSize sets the size of the window.</param>
      <throws>MathIllegalArgumentException if window size is less than 1 but
 * not equal to {@link #INFINITE_WINDOW}</throws>
    </javadoc>
    <method type="void" name="setWindowSize" startLine="355" endLine="369">
      <scope startLine="356" endLine="359" />
      <scope startLine="366" endLine="368" />
      <comment>We need to check to see if we need to discard elements</comment>
      <comment>from the front of the array.  If the windowSize is less than</comment>
      <comment>the current number of elements.</comment>
    </method>
    <javadoc>
      <text>* Returns the current set of values in an array of double primitives.
 * The order of addition is preserved.  The returned array is a fresh
 * copy of the underlying data -- i.e., it is not a reference to the
 * stored data.</text>
      <return>returns the current set of numbers in the order in which they
 * were added to this set</return>
    </javadoc>
    <method type="double[]" name="getValues" startLine="380" endLine="382" />
    <javadoc>
      <text>* Returns the current set of values in an array of double primitives,
 * sorted in ascending order.  The returned array is a fresh
 * copy of the underlying data -- i.e., it is not a reference to the
 * stored data.</text>
      <return>returns the current set of
 * numbers sorted in ascending order</return>
    </javadoc>
    <method type="double[]" name="getSortedValues" startLine="392" endLine="396">
      <declaration type="double[]" name="sort" />
    </method>
    <javadoc>
      <text>* Returns the element at the specified index</text>
      <param>index The Index of the element</param>
      <return>return the element at the specified index</return>
    </javadoc>
    <method type="double" name="getElement" startLine="403" endLine="405" />
    <javadoc>
      <text>* Returns an estimate for the pth percentile of the stored values.
 * <p>
 * The implementation provided here follows the first estimation procedure presented
 * <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm">here.</a>
 * </p><p>
 * <strong>Preconditions</strong>:<ul>
 * <li><code>0 &lt; p &le; 100</code> (otherwise an
 * <code>MathIllegalArgumentException</code> is thrown)</li>
 * <li>at least one value must be stored (returns <code>Double.NaN
 * </code> otherwise)</li>
 * </ul></p></text>
      <param>p the requested percentile (scaled from 0 - 100)</param>
      <return>An estimate for the pth percentile of the stored data</return>
      <throws>MathIllegalStateException if percentile implementation has been
 * overridden and the supplied implementation does not support setQuantile</throws>
      <throws>MathIllegalArgumentException if p is not a valid quantile</throws>
    </javadoc>
    <method type="double" name="getPercentile" startLine="426" endLine="447">
      <scope startLine="427" endLine="429" />
      <scope startLine="429" endLine="445">
        <scope startLine="430" endLine="434" />
        <scope startLine="434" endLine="438" />
        <scope startLine="438" endLine="442" />
        <scope startLine="442" endLine="444" />
        <comment>Setter guard should prevent</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Generates a text report displaying univariate statistics from values
 * that have been added.  Each statistic is displayed on a separate
 * line.</text>
      <return>String with line feeds displaying statistics</return>
    </javadoc>
    <method type="String" name="toString" startLine="457" endLine="476">
      <declaration type="StringBuilder" name="outBuffer" />
      <declaration type="String" name="endl" />
      <scope startLine="467" endLine="470">
        <comment>No catch for MIAE because actual parameter is valid below</comment>
      </scope>
      <scope startLine="470" endLine="472" />
    </method>
    <javadoc>
      <text>* Apply the given statistic to the data associated with this set of statistics.</text>
      <param>stat the statistic to apply</param>
      <return>the computed value of the statistic.</return>
    </javadoc>
    <method type="double" name="apply" startLine="483" endLine="486">
      <comment>No try-catch or advertised exception here because arguments are guaranteed valid</comment>
    </method>
    <javadoc>
      <text>* Returns the currently configured mean implementation.</text>
      <return>the UnivariateStatistic implementing the mean</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getMeanImpl" startLine="496" endLine="498" />
    <javadoc>
      <text>* <p>Sets the implementation for the mean.</p></text>
      <param>meanImpl the UnivariateStatistic instance to use
 * for computing the mean</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setMeanImpl" startLine="507" endLine="509" />
    <javadoc>
      <text>* Returns the currently configured geometric mean implementation.</text>
      <return>the UnivariateStatistic implementing the geometric mean</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getGeometricMeanImpl" startLine="517" endLine="519" />
    <javadoc>
      <text>* <p>Sets the implementation for the gemoetric mean.</p></text>
      <param>geometricMeanImpl the UnivariateStatistic instance to use
 * for computing the geometric mean</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setGeometricMeanImpl" startLine="529" endLine="531" />
    <javadoc>
      <text>* Returns the currently configured kurtosis implementation.</text>
      <return>the UnivariateStatistic implementing the kurtosis</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getKurtosisImpl" startLine="539" endLine="541" />
    <javadoc>
      <text>* <p>Sets the implementation for the kurtosis.</p></text>
      <param>kurtosisImpl the UnivariateStatistic instance to use
 * for computing the kurtosis</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setKurtosisImpl" startLine="550" endLine="552" />
    <javadoc>
      <text>* Returns the currently configured maximum implementation.</text>
      <return>the UnivariateStatistic implementing the maximum</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getMaxImpl" startLine="560" endLine="562" />
    <javadoc>
      <text>* <p>Sets the implementation for the maximum.</p></text>
      <param>maxImpl the UnivariateStatistic instance to use
 * for computing the maximum</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setMaxImpl" startLine="571" endLine="573" />
    <javadoc>
      <text>* Returns the currently configured minimum implementation.</text>
      <return>the UnivariateStatistic implementing the minimum</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getMinImpl" startLine="581" endLine="583" />
    <javadoc>
      <text>* <p>Sets the implementation for the minimum.</p></text>
      <param>minImpl the UnivariateStatistic instance to use
 * for computing the minimum</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setMinImpl" startLine="592" endLine="594" />
    <javadoc>
      <text>* Returns the currently configured percentile implementation.</text>
      <return>the UnivariateStatistic implementing the percentile</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getPercentileImpl" startLine="602" endLine="604" />
    <javadoc>
      <text>* Sets the implementation to be used by {@link #getPercentile(double)}.
 * The supplied <code>UnivariateStatistic</code> must provide a
 * <code>setQuantile(double)</code> method; otherwise
 * <code>IllegalArgumentException</code> is thrown.</text>
      <param>percentileImpl the percentileImpl to set</param>
      <throws>MathIllegalArgumentException if the supplied implementation does not
 * provide a <code>setQuantile</code> method</throws>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setPercentileImpl" startLine="618" endLine="635">
      <scope startLine="619" endLine="623" />
      <scope startLine="623" endLine="627" />
      <scope startLine="627" endLine="631" />
      <scope startLine="631" endLine="633" />
    </method>
    <javadoc>
      <text>* Returns the currently configured skewness implementation.</text>
      <return>the UnivariateStatistic implementing the skewness</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getSkewnessImpl" startLine="643" endLine="645" />
    <javadoc>
      <text>* <p>Sets the implementation for the skewness.</p></text>
      <param>skewnessImpl the UnivariateStatistic instance to use
 * for computing the skewness</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setSkewnessImpl" startLine="655" endLine="657" />
    <javadoc>
      <text>* Returns the currently configured variance implementation.</text>
      <return>the UnivariateStatistic implementing the variance</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getVarianceImpl" startLine="665" endLine="667" />
    <javadoc>
      <text>* <p>Sets the implementation for the variance.</p></text>
      <param>varianceImpl the UnivariateStatistic instance to use
 * for computing the variance</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setVarianceImpl" startLine="677" endLine="679" />
    <javadoc>
      <text>* Returns the currently configured sum of squares implementation.</text>
      <return>the UnivariateStatistic implementing the sum of squares</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getSumsqImpl" startLine="687" endLine="689" />
    <javadoc>
      <text>* <p>Sets the implementation for the sum of squares.</p></text>
      <param>sumsqImpl the UnivariateStatistic instance to use
 * for computing the sum of squares</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setSumsqImpl" startLine="698" endLine="700" />
    <javadoc>
      <text>* Returns the currently configured sum implementation.</text>
      <return>the UnivariateStatistic implementing the sum</return>
      <since>1.2</since>
    </javadoc>
    <method type="UnivariateStatistic" name="getSumImpl" startLine="708" endLine="710" />
    <javadoc>
      <text>* <p>Sets the implementation for the sum.</p></text>
      <param>sumImpl the UnivariateStatistic instance to use
 * for computing the sum</param>
      <since>1.2</since>
    </javadoc>
    <method type="void" name="setSumImpl" startLine="719" endLine="721" />
    <javadoc>
      <text>* Returns a copy of this DescriptiveStatistics instance with the same internal state.</text>
      <return>a copy of this</return>
    </javadoc>
    <method type="DescriptiveStatistics" name="copy" startLine="728" endLine="733">
      <declaration type="DescriptiveStatistics" name="result" />
      <comment>No try-catch or advertised exception because parms are guaranteed valid</comment>
    </method>
    <javadoc>
      <text>* Copies source to dest.
 * <p>Neither source nor dest can be null.</p></text>
      <param>source DescriptiveStatistics to copy</param>
      <param>dest DescriptiveStatistics to copy to</param>
      <throws>NullArgumentException if either source or dest is null</throws>
    </javadoc>
    <method type="void" name="copy" startLine="744" endLine="762">
      <comment>Copy data and window size</comment>
      <comment>Copy implementations</comment>
    </method>
    <comment>Implementation getters and setter</comment>
  </class>
</source>
