<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.genetics">
  <import name="java.util.ArrayList" />
  <import name="java.util.HashSet" />
  <import name="java.util.List" />
  <import name="java.util.Set" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathIllegalArgumentException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <class name="CycleCrossover" startLine="28">
    <implements name="CrossoverPolicy" />
    <javadoc>
      <text>* Cycle Crossover [CX] builds offspring from <b>ordered</b> chromosomes by identifying cycles
 * between two parent chromosomes. To form the children, the cycles are copied from the
 * respective parents.
 * <p>
 * To form a cycle the following procedure is applied:
 * <ol>
 * <li>start with the first gene of parent 1</li>
 * <li>look at the gene at the same position of parent 2</li>
 * <li>go to the position with the same gene in parent 1</li>
 * <li>add this gene index to the cycle</li>
 * <li>repeat the steps 2-5 until we arrive at the starting gene of this cycle</li>
 * </ol>
 * The indices that form a cycle are then used to form the children in alternating order, i.e.
 * in cycle 1, the genes of parent 1 are copied to child 1, while in cycle 2 the genes of parent 1
 * are copied to child 2, and so forth ...
 * </p>
 * Example (zero-start cycle):
 * <pre>
 * p1 = (8 4 7 3 6 2 5 1 9 0)    X   c1 = (8 1 2 3 4 5 6 7 9 0)
 * p2 = (0 1 2 3 4 5 6 7 8 9)    X   c2 = (0 4 7 3 6 2 5 1 8 9)
 * cycle 1: 8 0 9
 * cycle 2: 4 1 7 2 5 6
 * cycle 3: 3
 * </pre>
 * This policy works only on {@link AbstractListChromosome}, and therefore it
 * is parameterized by T. Moreover, the chromosomes must have same lengths.</text>
      <see><a href="http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx">
 * Cycle Crossover Operator</a></see>
      <param><T>
 *  generic type of the {@link AbstractListChromosome}s for crossover</param>
      <since>3.1</since>
      <version>$Id: CycleCrossover.java 1385297 2012-09-16 16:05:57Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* If the start index shall be chosen randomly.</text>
    </javadoc>
    <declaration type="boolean" name="randomStart" />
    <javadoc>
      <text>* Creates a new {@link CycleCrossover} policy.</text>
    </javadoc>
    <method type="constructor" name="CycleCrossover" startLine="74" endLine="76" />
    <javadoc>
      <text>* Creates a new {@link CycleCrossover} policy using the given {@code randomStart} behavior.</text>
      <param>randomStart whether the start index shall be chosen randomly or be set to 0</param>
    </javadoc>
    <method type="constructor" name="CycleCrossover" startLine="83" endLine="85" />
    <javadoc>
      <text>* Returns whether the starting index is chosen randomly or set to zero.</text>
      <return>{@code true} if the starting index is chosen randomly, {@code false} otherwise</return>
    </javadoc>
    <method type="boolean" name="isRandomStart" startLine="92" endLine="94" />
    <javadoc>
      <text>* {@inheritDoc}</text>
      <throws>MathIllegalArgumentException if the chromosomes are not an instance of {@link AbstractListChromosome}</throws>
      <throws>DimensionMismatchException if the length of the two chromosomes is different</throws>
    </javadoc>
    <method type="ChromosomePair" name="crossover" startLine="104" endLine="110">
      <scope startLine="106" endLine="108" />
    </method>
    <javadoc>
      <text>* Helper for {@link #crossover(Chromosome,Chromosome)}. Performs the actual crossover.</text>
      <param>first the first chromosome</param>
      <param>second the second chromosome</param>
      <return>the pair of new chromosomes that resulted from the crossover</return>
      <throws>DimensionMismatchException if the length of the two chromosomes is different</throws>
    </javadoc>
    <method type="ChromosomePair" name="mate" startLine="121" endLine="182">
      <declaration type="int" name="length" />
      <scope startLine="124" endLine="126" />
      <declaration type="List<T>" name="parent1Rep" />
      <declaration type="List<T>" name="parent2Rep" />
      <declaration type="List<T>" name="child1Rep" />
      <declaration type="List<T>" name="child2Rep" />
      <declaration type="Set<Integer>" name="visitedIndices" />
      <declaration type="List<Integer>" name="indices" />
      <declaration type="int" name="idx" />
      <declaration type="int" name="cycle" />
      <scope startLine="144" endLine="178">
        <declaration type="T" name="item" />
        <scope startLine="150" endLine="157" />
        <scope startLine="160" endLine="166">
          <scope startLine="161" endLine="165">
            <declaration type="T" name="tmp" />
          </scope>
        </scope>
        <scope startLine="171" endLine="176">
          <scope startLine="173" endLine="175" />
        </scope>
        <comment>add that index to the cycle indices</comment>
        <comment>get the item in the second parent at that index</comment>
        <comment>get the index of that item in the first parent</comment>
        <comment>for even cycles: swap the child elements on the indices found in this cycle</comment>
        <comment>find next starting index: last one + 1 until we find an unvisited index</comment>
      </scope>
      <comment>array representations of the parents</comment>
      <comment>and of the children: do a crossover copy to simplify the later processing</comment>
      <comment>the set of all visited indices so far</comment>
      <comment>the indices of the current cycle</comment>
      <comment>determine the starting index</comment>
    </method>
  </class>
</source>
