<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.ode.nonstiff">
  <import name="org.apache.commons.math3.analysis.solvers.UnivariateSolver" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MaxCountExceededException" />
  <import name="org.apache.commons.math3.exception.NoBracketingException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.ode.ExpandableStatefulODE" />
  <import name="org.apache.commons.math3.ode.events.EventHandler" />
  <import name="org.apache.commons.math3.ode.sampling.AbstractStepInterpolator" />
  <import name="org.apache.commons.math3.ode.sampling.StepHandler" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <class name="GraggBulirschStoerIntegrator" extends="AdaptiveStepsizeIntegrator" startLine="31">
    <javadoc>
      <text>* This class implements a Gragg-Bulirsch-Stoer integrator for
 * Ordinary Differential Equations.
 * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient
 * ones currently available for smooth problems. It uses Richardson
 * extrapolation to estimate what would be the solution if the step
 * size could be decreased down to zero.</p>
 * <p>
 * This method changes both the step size and the order during
 * integration, in order to minimize computation cost. It is
 * particularly well suited when a very high precision is needed. The
 * limit where this method becomes more efficient than high-order
 * embedded Runge-Kutta methods like {@link DormandPrince853IntegratorDormand-Prince 8(5,3)} depends on the problem. Results given in the
 * Hairer, Norsett and Wanner book show for example that this limit
 * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz
 * equations (the authors note this problem is <i>extremely sensitive
 * to the errors in the first integration steps</i>), and around 1e-11
 * for a two dimensional celestial mechanics problems with seven
 * bodies (pleiades problem, involving quasi-collisions for which
 * <i>automatic step size control is essential</i>).
 * </p>
 * <p>
 * This implementation is basically a reimplementation in Java of the
 * <a
 * href="http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f">odex</a>
 * fortran code by E. Hairer and G. Wanner. The redistribution policy
 * for this code is available <a
 * href="http://www.unige.ch/~hairer/prog/licence.txt">here</a>, for
 * convenience, it is reproduced below.</p>
 * </p>
 * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0">
 * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>
 * <tr><td>Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * <ul>
 * <li>Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.</li>
 * </ul></td></tr>
 * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>
 * </table></text>
      <version>$Id: GraggBulirschStoerIntegrator.java 1416643 2012-12-03 19:37:14Z tn $</version>
      <since>1.2</since>
    </javadoc>
    <javadoc>
      <text>* Integrator method name.</text>
    </javadoc>
    <declaration type="String" name="METHOD_NAME" />
    <javadoc>
      <text>* maximal order.</text>
    </javadoc>
    <declaration type="int" name="maxOrder" />
    <javadoc>
      <text>* step size sequence.</text>
    </javadoc>
    <declaration type="int[]" name="sequence" />
    <javadoc>
      <text>* overall cost of applying step reduction up to iteration k+1, in number of calls.</text>
    </javadoc>
    <declaration type="int[]" name="costPerStep" />
    <javadoc>
      <text>* cost per unit step.</text>
    </javadoc>
    <declaration type="double[]" name="costPerTimeUnit" />
    <javadoc>
      <text>* optimal steps for each order.</text>
    </javadoc>
    <declaration type="double[]" name="optimalStep" />
    <javadoc>
      <text>* extrapolation coefficients.</text>
    </javadoc>
    <declaration type="double[][]" name="coeff" />
    <javadoc>
      <text>* stability check enabling parameter.</text>
    </javadoc>
    <declaration type="boolean" name="performTest" />
    <javadoc>
      <text>* maximal number of checks for each iteration.</text>
    </javadoc>
    <declaration type="int" name="maxChecks" />
    <javadoc>
      <text>* maximal number of iterations for which checks are performed.</text>
    </javadoc>
    <declaration type="int" name="maxIter" />
    <javadoc>
      <text>* stepsize reduction factor in case of stability check failure.</text>
    </javadoc>
    <declaration type="double" name="stabilityReduction" />
    <javadoc>
      <text>* first stepsize control factor.</text>
    </javadoc>
    <declaration type="double" name="stepControl1" />
    <javadoc>
      <text>* second stepsize control factor.</text>
    </javadoc>
    <declaration type="double" name="stepControl2" />
    <javadoc>
      <text>* third stepsize control factor.</text>
    </javadoc>
    <declaration type="double" name="stepControl3" />
    <javadoc>
      <text>* fourth stepsize control factor.</text>
    </javadoc>
    <declaration type="double" name="stepControl4" />
    <javadoc>
      <text>* first order control factor.</text>
    </javadoc>
    <declaration type="double" name="orderControl1" />
    <javadoc>
      <text>* second order control factor.</text>
    </javadoc>
    <declaration type="double" name="orderControl2" />
    <javadoc>
      <text>* use interpolation error in stepsize control.</text>
    </javadoc>
    <declaration type="boolean" name="useInterpolationError" />
    <javadoc>
      <text>* interpolation order control parameter.</text>
    </javadoc>
    <declaration type="int" name="mudif" />
    <javadoc>
      <text>* Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.</text>
      <param>minStep minimal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>maxStep maximal step (sign is irrelevant, regardless of
 * integration direction, forward or backward), the last step can
 * be smaller than this</param>
      <param>scalAbsoluteTolerance allowed absolute error</param>
      <param>scalRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="GraggBulirschStoerIntegrator" startLine="171" endLine="178" />
    <javadoc>
      <text>* Simple constructor.
 * Build a Gragg-Bulirsch-Stoer integrator with the given step
 * bounds. All tuning parameters are set to their default
 * values. The default step handler does nothing.</text>
      <param>minStep minimal step (must be positive even for backward
 * integration), the last step can be smaller than this</param>
      <param>maxStep maximal step (must be positive even for backward
 * integration)</param>
      <param>vecAbsoluteTolerance allowed absolute error</param>
      <param>vecRelativeTolerance allowed relative error</param>
    </javadoc>
    <method type="constructor" name="GraggBulirschStoerIntegrator" startLine="193" endLine="200" />
    <javadoc>
      <text>* Set the stability check controls.
 * <p>The stability check is performed on the first few iterations of
 * the extrapolation scheme. If this test fails, the step is rejected
 * and the stepsize is reduced.</p>
 * <p>By default, the test is performed, at most during two
 * iterations at each step, and at most once for each of these
 * iterations. The default stepsize reduction factor is 0.5.</p></text>
      <param>performStabilityCheck if true, stability check will be performed,
 * if false, the check will be skipped</param>
      <param>maxNumIter maximal number of iterations for which checks are
 * performed (the number of iterations is reset to default if negative
 * or null)</param>
      <param>maxNumChecks maximal number of checks for each iteration
 * (the number of checks is reset to default if negative or null)</param>
      <param>stepsizeReductionFactor stepsize reduction factor in case of
 * failure (the factor is reset to default if lower than 0.0001 or
 * greater than 0.9999)</param>
    </javadoc>
    <method type="void" name="setStabilityCheck" startLine="222" endLine="234">
      <scope startLine="228" endLine="230" />
      <scope startLine="230" endLine="232" />
    </method>
    <javadoc>
      <text>* Set the step size control factors.
 * <p>The new step size hNew is computed from the old one h by:
 * <pre>
 * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))
 * </pre>
 * where err is the scaled error and k the iteration number of the
 * extrapolation scheme (counting from 0). The default values are
 * 0.65 for stepControl1 and 0.94 for stepControl2.</p>
 * <p>The step size is subject to the restriction:
 * <pre>
 * stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))
 * </pre>
 * The default values are 0.02 for stepControl3 and 4.0 for
 * stepControl4.</p></text>
      <param>control1 first stepsize control factor (the factor is
 * reset to default if lower than 0.0001 or greater than 0.9999)</param>
      <param>control2 second stepsize control factor (the factor
 * is reset to default if lower than 0.0001 or greater than 0.9999)</param>
      <param>control3 third stepsize control factor (the factor is
 * reset to default if lower than 0.0001 or greater than 0.9999)</param>
      <param>control4 fourth stepsize control factor (the factor
 * is reset to default if lower than 1.0001 or greater than 999.9)</param>
    </javadoc>
    <method type="void" name="setControlFactors" startLine="261" endLine="287">
      <scope startLine="263" endLine="265" />
      <scope startLine="265" endLine="267" />
      <scope startLine="269" endLine="271" />
      <scope startLine="271" endLine="273" />
      <scope startLine="275" endLine="277" />
      <scope startLine="277" endLine="279" />
      <scope startLine="281" endLine="283" />
      <scope startLine="283" endLine="285" />
    </method>
    <javadoc>
      <text>* Set the order control parameters.
 * <p>The Gragg-Bulirsch-Stoer method changes both the step size and
 * the order during integration, in order to minimize computation
 * cost. Each extrapolation step increases the order by 2, so the
 * maximal order that will be used is always even, it is twice the
 * maximal number of columns in the extrapolation table.</p>
 * <pre>
 * order is decreased if w(k-1) <= w(k)   * orderControl1
 * order is increased if w(k)   <= w(k-1) * orderControl2
 * </pre>
 * <p>where w is the table of work per unit step for each order
 * (number of function calls divided by the step length), and k is
 * the current order.</p>
 * <p>The default maximal order after construction is 18 (i.e. the
 * maximal number of columns is 9). The default values are 0.8 for
 * orderControl1 and 0.9 for orderControl2.</p></text>
      <param>maximalOrder maximal order in the extrapolation table (the
 * maximal order is reset to default if order <= 6 or odd)</param>
      <param>control1 first order control factor (the factor is
 * reset to default if lower than 0.0001 or greater than 0.9999)</param>
      <param>control2 second order control factor (the factor
 * is reset to default if lower than 0.0001 or greater than 0.9999)</param>
    </javadoc>
    <method type="void" name="setOrderControl" startLine="313" endLine="334">
      <scope startLine="315" endLine="317" />
      <scope startLine="319" endLine="321" />
      <scope startLine="321" endLine="323" />
      <scope startLine="325" endLine="327" />
      <scope startLine="327" endLine="329" />
      <comment>reinitialize the arrays</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="addStepHandler" startLine="338" endLine="345">
      <comment>reinitialize the arrays</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="addEventHandler" startLine="353" endLine="360">
      <comment>reinitialize the arrays</comment>
    </method>
    <javadoc>
      <text>* Initialize the integrator internal arrays.</text>
    </javadoc>
    <method type="void" name="initializeArrays" startLine="363" endLine="397">
      <declaration type="int" name="size" />
      <scope startLine="367" endLine="374">
        <comment>all arrays should be reallocated with the right size</comment>
      </scope>
      <scope startLine="377" endLine="379" />
      <scope startLine="384" endLine="386" />
      <scope startLine="389" endLine="395">
        <scope startLine="391" endLine="394">
          <declaration type="double" name="ratio" />
        </scope>
      </scope>
      <comment>step size sequence: 2, 6, 10, 14, ...</comment>
      <comment>initialize the order selection cost array</comment>
      <comment>(number of function calls for each column of the extrapolation table)</comment>
      <comment>initialize the extrapolation tables</comment>
    </method>
    <javadoc>
      <text>* Set the interpolation order control parameter.
 * The interpolation order for dense output is 2k - mudif + 1. The
 * default value for mudif is 4 and the interpolation error is used
 * in stepsize control by default.</text>
      <param>useInterpolationErrorForControl if true, interpolation error is used
 * for stepsize control</param>
      <param>mudifControlParameter interpolation order control parameter (the parameter
 * is reset to default if <= 0 or >= 7)</param>
    </javadoc>
    <method type="void" name="setInterpolationControl" startLine="410" endLine="420">
      <scope startLine="414" endLine="416" />
      <scope startLine="416" endLine="418" />
    </method>
    <javadoc>
      <text>* Update scaling array.</text>
      <param>y1 first state vector to use for scaling</param>
      <param>y2 second state vector to use for scaling</param>
      <param>scale scaling array to update (can be shorter than state)</param>
    </javadoc>
    <method type="void" name="rescale" startLine="427" endLine="439">
      <scope startLine="428" endLine="433">
        <scope startLine="429" endLine="432">
          <declaration type="double" name="yi" />
        </scope>
      </scope>
      <scope startLine="433" endLine="438">
        <scope startLine="434" endLine="437">
          <declaration type="double" name="yi" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Perform integration over one step using substeps of a modified
 * midpoint method.</text>
      <param>t0 initial time</param>
      <param>y0 initial value of the state vector at t0</param>
      <param>step global step</param>
      <param>k iteration number (from 0 to sequence.length - 1)</param>
      <param>scale scaling array (can be shorter than state)</param>
      <param>f placeholder where to put the state vector derivatives at each substep
 * (element 0 already contains initial derivative)</param>
      <param>yMiddle placeholder where to put the state vector at the middle of the step</param>
      <param>yEnd placeholder where to put the state vector at the end</param>
      <param>yTmp placeholder for one state vector</param>
      <return>true if computation was done properly,
 * false if stability check failed before end of computation</return>
      <exception>MaxCountExceededException if the number of functions evaluations is exceeded</exception>
      <exception>DimensionMismatchException if arrays dimensions do not match equations settings</exception>
    </javadoc>
    <method type="boolean" name="tryStep" startLine="462" endLine="519">
      <declaration type="int" name="n" />
      <declaration type="double" name="subStep" />
      <declaration type="double" name="subStep2" />
      <declaration type="double" name="t" />
      <scope startLine="470" endLine="473" />
      <scope startLine="477" endLine="510">
        <scope startLine="479" endLine="482" />
        <scope startLine="485" endLine="489">
          <declaration type="double" name="middle" />
        </scope>
        <scope startLine="494" endLine="508">
          <declaration type="double" name="initialNorm" />
          <scope startLine="496" endLine="499">
            <declaration type="double" name="ratio" />
          </scope>
          <declaration type="double" name="deltaNorm" />
          <scope startLine="501" endLine="504">
            <declaration type="double" name="ratio" />
          </scope>
          <scope startLine="505" endLine="507" />
        </scope>
        <comment>save the point at the middle of the step</comment>
        <comment>stability check</comment>
      </scope>
      <scope startLine="513" endLine="515" />
      <comment>first substep</comment>
      <comment>other substeps</comment>
      <comment>correction of the last substep (at t0 + step)</comment>
    </method>
    <javadoc>
      <text>* Extrapolate a vector.</text>
      <param>offset offset to use in the coefficients table</param>
      <param>k index of the last updated point</param>
      <param>diag working diagonal of the Aitken-Neville's
 * triangle, without the last element</param>
      <param>last last element</param>
    </javadoc>
    <method type="void" name="extrapolate" startLine="529" endLine="545">
      <scope startLine="532" endLine="538">
        <scope startLine="533" endLine="537" />
        <comment>Aitken-Neville's recursive formula</comment>
      </scope>
      <scope startLine="541" endLine="544">
        <comment>Aitken-Neville's recursive formula</comment>
      </scope>
      <comment>update the diagonal</comment>
      <comment>update the last element</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="integrate" startLine="551" endLine="948">
      <declaration type="boolean" name="forward" />
      <declaration type="double[]" name="y0" />
      <declaration type="double[]" name="y" />
      <declaration type="double[]" name="yDot0" />
      <declaration type="double[]" name="y1" />
      <declaration type="double[]" name="yTmp" />
      <declaration type="double[]" name="yTmpDot" />
      <declaration type="double[][][]" name="diagonal" />
      <declaration type="double[][][]" name="y1Diag" />
      <scope startLine="567" endLine="570" />
      <declaration type="double[][][][]" name="fk" />
      <scope startLine="573" endLine="584">
        <scope startLine="580" endLine="582" />
        <comment>all substeps start at the same point, so share the first array</comment>
      </scope>
      <scope startLine="586" endLine="588" />
      <declaration type="double[]" name="yDot1" />
      <declaration type="double[][]" name="yMidDots" />
      <declaration type="double[]" name="scale" />
      <declaration type="double" name="tol" />
      <declaration type="double" name="log10R" />
      <declaration type="int" name="targetIter" />
      <declaration type="AbstractStepInterpolator" name="interpolator" />
      <declaration type="double" name="hNew" />
      <declaration type="double" name="maxError" />
      <declaration type="boolean" name="previousRejected" />
      <declaration type="boolean" name="firstTime" />
      <declaration type="boolean" name="newStep" />
      <declaration type="boolean" name="firstStepAlreadyComputed" />
      <scope startLine="624" endLine="940">
        <declaration type="double" name="error" />
        <declaration type="boolean" name="reject" />
        <scope startLine="629" endLine="645">
          <scope startLine="634" endLine="636" />
          <scope startLine="638" endLine="641" />
        </scope>
        <scope startLine="651" endLine="653" />
        <declaration type="double" name="nextT" />
        <declaration type="int" name="k" />
        <scope startLine="659" endLine="790">
          <scope startLine="667" endLine="674" />
          <scope startLine="674" endLine="789">
            <scope startLine="677" endLine="788">
              <scope startLine="686" endLine="689">
                <declaration type="double" name="e" />
              </scope>
              <scope startLine="692" endLine="697" />
              <scope startLine="697" endLine="787">
                <declaration type="double" name="exp" />
                <declaration type="double" name="fac" />
                <declaration type="double" name="pow" />
                <scope startLine="713" endLine="739">
                  <scope startLine="716" endLine="719" />
                  <scope startLine="719" endLine="738">
                    <declaration type="double" name="ratio" />
                    <scope startLine="725" endLine="737">
                      <scope startLine="733" endLine="735" />
                    </scope>
                  </scope>
                </scope>
                <scope startLine="743" endLine="746" />
                <scope startLine="746" endLine="763">
                  <declaration type="double" name="ratio" />
                  <scope startLine="751" endLine="762">
                    <scope startLine="758" endLine="760" />
                  </scope>
                </scope>
                <scope startLine="767" endLine="775">
                  <scope startLine="771" endLine="773" />
                </scope>
                <scope startLine="780" endLine="782" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope startLine="792" endLine="795" />
        <declaration type="double" name="hInt" />
        <scope startLine="799" endLine="860">
          <scope startLine="802" endLine="804" />
          <declaration type="int" name="mu" />
          <scope startLine="808" endLine="838">
            <declaration type="int" name="l2" />
            <declaration type="double" name="factor" />
            <declaration type="int" name="middleIndex" />
            <scope startLine="814" endLine="816" />
            <scope startLine="817" endLine="824">
              <scope startLine="820" endLine="822" />
            </scope>
            <scope startLine="825" endLine="827" />
            <scope startLine="830" endLine="836">
              <scope startLine="831" endLine="835">
                <scope startLine="832" endLine="834" />
              </scope>
            </scope>
          </scope>
          <scope startLine="840" endLine="858">
            <declaration type="GraggBulirschStoerStepInterpolator" name="gbsInterpolator" />
            <scope startLine="847" endLine="856">
              <declaration type="double" name="interpError" />
              <scope startLine="852" endLine="855" />
            </scope>
          </scope>
        </scope>
        <scope startLine="862" endLine="924">
          <declaration type="int" name="optimalIter" />
          <scope startLine="875" endLine="880">
            <scope startLine="877" endLine="879" />
          </scope>
          <scope startLine="880" endLine="887">
            <scope startLine="882" endLine="884" />
            <scope startLine="884" endLine="886" />
          </scope>
          <scope startLine="887" endLine="896">
            <scope startLine="890" endLine="892" />
            <scope startLine="893" endLine="895" />
          </scope>
          <scope startLine="898" endLine="903" />
          <scope startLine="903" endLine="920">
            <scope startLine="905" endLine="907" />
            <scope startLine="907" endLine="916">
              <scope startLine="909" endLine="912" />
              <scope startLine="912" endLine="915" />
            </scope>
          </scope>
        </scope>
        <scope startLine="927" endLine="929" />
        <scope startLine="933" endLine="936" />
        <scope startLine="936" endLine="938" />
        <comment>first evaluation, at the beginning of the step</comment>
        <comment>step adjustment near bounds</comment>
        <comment>iterate over several substep sizes</comment>
        <comment>modified midpoint integration with the current substep</comment>
        <comment>the stability check failed, we reduce the global step</comment>
        <comment>the substep was computed successfully</comment>
        <comment>extrapolate the state at the end of the step</comment>
        <comment>using last iteration data</comment>
        <comment>estimate the error at the end of the step.</comment>
        <comment>error is too big, we reduce the global step</comment>
        <comment>compute optimal stepsize for this order</comment>
        <comment>check convergence</comment>
        <comment>check if we can stop iterations now</comment>
        <comment>convergence have been reached just before targetIter</comment>
        <comment>estimate if there is a chance convergence will</comment>
        <comment>be reached on next iteration, using the</comment>
        <comment>asymptotic evolution of error</comment>
        <comment>we don't expect to converge on next iteration</comment>
        <comment>we reject the step immediately and reduce order</comment>
        <comment>convergence has been reached exactly at targetIter</comment>
        <comment>estimate if there is a chance convergence will</comment>
        <comment>be reached on next iteration, using the</comment>
        <comment>asymptotic evolution of error</comment>
        <comment>we don't expect to converge on next iteration</comment>
        <comment>we reject the step immediately</comment>
        <comment>derivatives at end of step</comment>
        <comment>dense output handling</comment>
        <comment>extrapolate state at middle point of the step</comment>
        <comment>derivative at middle point of the step</comment>
        <comment>compute centered differences to evaluate next derivatives</comment>
        <comment>estimate the dense output coefficients</comment>
        <comment>use the interpolation error to limit stepsize</comment>
        <comment>Discrete events handling</comment>
        <comment>prepare next step</comment>
        <comment>after a rejected step neither order nor stepsize</comment>
        <comment>should increase</comment>
        <comment>stepsize control</comment>
      </scope>
      <comment>create some internal working arrays</comment>
      <comment>initial scaling</comment>
      <comment>initial order selection</comment>
      <comment>set up an interpolator sharing the integrator arrays</comment>
      <comment>dispatch results</comment>
    </method>
  </class>
</source>
