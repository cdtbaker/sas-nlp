<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.filter">
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.NullArgumentException" />
  <import name="org.apache.commons.math3.linear.Array2DRowRealMatrix" />
  <import name="org.apache.commons.math3.linear.ArrayRealVector" />
  <import name="org.apache.commons.math3.linear.CholeskyDecomposition" />
  <import name="org.apache.commons.math3.linear.DecompositionSolver" />
  <import name="org.apache.commons.math3.linear.MatrixDimensionMismatchException" />
  <import name="org.apache.commons.math3.linear.MatrixUtils" />
  <import name="org.apache.commons.math3.linear.NonSquareMatrixException" />
  <import name="org.apache.commons.math3.linear.RealMatrix" />
  <import name="org.apache.commons.math3.linear.RealVector" />
  <import name="org.apache.commons.math3.linear.SingularMatrixException" />
  <import name="org.apache.commons.math3.util.MathUtils" />
  <class name="KalmanFilter" startLine="33">
    <javadoc>
      <text>* Implementation of a Kalman filter to estimate the state <i>x<sub>k</sub></i>
 * of a discrete-time controlled process that is governed by the linear
 * stochastic difference equation:
 * <pre>
 * <i>x<sub>k</sub></i> = <b>A</b><i>x<sub>k-1</sub></i> + <b>B</b><i>u<sub>k-1</sub></i> + <i>w<sub>k-1</sub></i>
 * </pre>
 * with a measurement <i>x<sub>k</sub></i> that is
 * <pre>
 * <i>z<sub>k</sub></i> = <b>H</b><i>x<sub>k</sub></i> + <i>v<sub>k</sub></i>.
 * </pre>
 * <p>
 * The random variables <i>w<sub>k</sub></i> and <i>v<sub>k</sub></i> represent
 * the process and measurement noise and are assumed to be independent of each
 * other and distributed with normal probability (white noise).
 * <p>
 * The Kalman filter cycle involves the following steps:
 * <ol>
 * <li>predict: project the current state estimate ahead in time</li>
 * <li>correct: adjust the projected estimate by an actual measurement</li>
 * </ol>
 * <p>
 * The Kalman filter is initialized with a {@link ProcessModel} and a{@link MeasurementModel}, which contain the corresponding transformation and
 * noise covariance matrices. The parameter names used in the respective models
 * correspond to the following names commonly used in the mathematical
 * literature:
 * <ul>
 * <li>A - state transition matrix</li>
 * <li>B - control input matrix</li>
 * <li>H - measurement matrix</li>
 * <li>Q - process noise covariance matrix</li>
 * <li>R - measurement noise covariance matrix</li>
 * <li>P - error covariance matrix</li>
 * </ul></text>
      <see><a href="http://www.cs.unc.edu/~welch/kalman/">Kalman filter
 *      resources</a></see>
      <see><a href="http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf">An
 *      introduction to the Kalman filter by Greg Welch and Gary Bishop</a></see>
      <see><a href="http://academic.csuohio.edu/simond/courses/eec644/kalman.pdf">
 *      Kalman filter example by Dan Simon</a></see>
      <see>ProcessModel</see>
      <see>MeasurementModel</see>
      <since>3.0</since>
      <version>$Id: KalmanFilter.java 1416643 2012-12-03 19:37:14Z tn $</version>
    </javadoc>
    <javadoc>
      <text>* The process model used by this filter instance.</text>
    </javadoc>
    <declaration type="ProcessModel" name="processModel" />
    <javadoc>
      <text>* The measurement model used by this filter instance.</text>
    </javadoc>
    <declaration type="MeasurementModel" name="measurementModel" />
    <javadoc>
      <text>* The transition matrix, equivalent to A.</text>
    </javadoc>
    <declaration type="RealMatrix" name="transitionMatrix" />
    <javadoc>
      <text>* The transposed transition matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="transitionMatrixT" />
    <javadoc>
      <text>* The control matrix, equivalent to B.</text>
    </javadoc>
    <declaration type="RealMatrix" name="controlMatrix" />
    <javadoc>
      <text>* The measurement matrix, equivalent to H.</text>
    </javadoc>
    <declaration type="RealMatrix" name="measurementMatrix" />
    <javadoc>
      <text>* The transposed measurement matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="measurementMatrixT" />
    <javadoc>
      <text>* The internal state estimation vector, equivalent to x hat.</text>
    </javadoc>
    <declaration type="RealVector" name="stateEstimation" />
    <javadoc>
      <text>* The error covariance matrix, equivalent to P.</text>
    </javadoc>
    <declaration type="RealMatrix" name="errorCovariance" />
    <javadoc>
      <text>* Creates a new Kalman filter with the given process and measurement models.</text>
      <param>processthe model defining the underlying process dynamics</param>
      <param>measurementthe model defining the given measurement characteristics</param>
      <throws>NullArgumentExceptionif any of the given inputs is null (except for the control matrix)</throws>
      <throws>NonSquareMatrixExceptionif the transition matrix is non square</throws>
      <throws>DimensionMismatchExceptionif the column dimension of the transition matrix does not match the dimension of the
 * initial state estimation vector</throws>
      <throws>MatrixDimensionMismatchExceptionif the matrix dimensions do not fit together</throws>
    </javadoc>
    <method type="constructor" name="KalmanFilter" startLine="123" endLine="213">
      <scope startLine="136" endLine="138" />
      <scope startLine="138" endLine="140" />
      <declaration type="RealMatrix" name="processNoise" />
      <declaration type="RealMatrix" name="measNoise" />
      <scope startLine="156" endLine="158" />
      <scope startLine="158" endLine="160" />
      <scope startLine="162" endLine="165" />
      <scope startLine="169" endLine="171" />
      <scope startLine="171" endLine="173" />
      <scope startLine="178" endLine="182" />
      <scope startLine="189" endLine="193" />
      <scope startLine="199" endLine="204" />
      <scope startLine="208" endLine="212" />
      <comment>create an empty matrix if no control matrix was given</comment>
      <comment>check that the process and measurement noise matrices are not null</comment>
      <comment>they will be directly accessed from the model as they may change</comment>
      <comment>over time</comment>
      <comment>set the initial state estimate to a zero vector if it is not</comment>
      <comment>available from the process model</comment>
      <comment>initialize the error covariance to the process noise if it is not</comment>
      <comment>available from the process model</comment>
      <comment>sanity checks, the control matrix B may be null</comment>
      <comment>A must be a square matrix</comment>
      <comment>row dimension of B must be equal to A</comment>
      <comment>Q must be equal to A</comment>
      <comment>column dimension of H must be equal to row dimension of A</comment>
      <comment>row dimension of R must be equal to row dimension of H</comment>
    </method>
    <javadoc>
      <text>* Returns the dimension of the state estimation vector.</text>
      <return>the state dimension</return>
    </javadoc>
    <method type="int" name="getStateDimension" startLine="220" endLine="222" />
    <javadoc>
      <text>* Returns the dimension of the measurement vector.</text>
      <return>the measurement vector dimension</return>
    </javadoc>
    <method type="int" name="getMeasurementDimension" startLine="229" endLine="231" />
    <javadoc>
      <text>* Returns the current state estimation vector.</text>
      <return>the state estimation vector</return>
    </javadoc>
    <method type="double[]" name="getStateEstimation" startLine="238" endLine="240" />
    <javadoc>
      <text>* Returns a copy of the current state estimation vector.</text>
      <return>the state estimation vector</return>
    </javadoc>
    <method type="RealVector" name="getStateEstimationVector" startLine="247" endLine="249" />
    <javadoc>
      <text>* Returns the current error covariance matrix.</text>
      <return>the error covariance matrix</return>
    </javadoc>
    <method type="double[][]" name="getErrorCovariance" startLine="256" endLine="258" />
    <javadoc>
      <text>* Returns a copy of the current error covariance matrix.</text>
      <return>the error covariance matrix</return>
    </javadoc>
    <method type="RealMatrix" name="getErrorCovarianceMatrix" startLine="265" endLine="267" />
    <javadoc>
      <text>* Predict the internal state estimation one time step ahead.</text>
    </javadoc>
    <method type="void" name="predict" startLine="272" endLine="274" />
    <javadoc>
      <text>* Predict the internal state estimation one time step ahead.</text>
      <param>uthe control vector</param>
      <throws>DimensionMismatchExceptionif the dimension of the control vector does not fit</throws>
    </javadoc>
    <method type="void" name="predict" startLine="284" endLine="286" />
    <javadoc>
      <text>* Predict the internal state estimation one time step ahead.</text>
      <param>uthe control vector</param>
      <throws>DimensionMismatchExceptionif the dimension of the control vector does not match</throws>
    </javadoc>
    <method type="void" name="predict" startLine="296" endLine="318">
      <scope startLine="299" endLine="302" />
      <scope startLine="309" endLine="311" />
      <comment>sanity checks</comment>
      <comment>project the state estimation ahead (a priori state)</comment>
      <comment>xHat(k)- = A * xHat(k-1) + B * u(k-1)</comment>
      <comment>add control input if it is available</comment>
      <comment>project the error covariance ahead</comment>
      <comment>P(k)- = A * P(k-1) * A' + Q</comment>
    </method>
    <javadoc>
      <text>* Correct the current state estimate with an actual measurement.</text>
      <param>zthe measurement vector</param>
      <throws>NullArgumentExceptionif the measurement vector is {@code null}</throws>
      <throws>DimensionMismatchExceptionif the dimension of the measurement vector does not fit</throws>
      <throws>SingularMatrixExceptionif the covariance matrix could not be inverted</throws>
    </javadoc>
    <method type="void" name="correct" startLine="333" endLine="335" />
    <javadoc>
      <text>* Correct the current state estimate with an actual measurement.</text>
      <param>zthe measurement vector</param>
      <throws>NullArgumentExceptionif the measurement vector is {@code null}</throws>
      <throws>DimensionMismatchExceptionif the dimension of the measurement vector does not fit</throws>
      <throws>SingularMatrixExceptionif the covariance matrix could not be inverted</throws>
    </javadoc>
    <method type="void" name="correct" startLine="350" endLine="386">
      <scope startLine="354" endLine="357" />
      <declaration type="RealMatrix" name="s" />
      <declaration type="DecompositionSolver" name="solver" />
      <declaration type="RealMatrix" name="invertedS" />
      <declaration type="RealVector" name="innovation" />
      <declaration type="RealMatrix" name="kalmanGain" />
      <declaration type="RealMatrix" name="identity" />
      <comment>sanity checks</comment>
      <comment>S = H * P(k) - * H' + R</comment>
      <comment>invert S</comment>
      <comment>as the error covariance matrix is a symmetric positive</comment>
      <comment>semi-definite matrix, we can use the cholesky decomposition</comment>
      <comment>Inn = z(k) - H * xHat(k)-</comment>
      <comment>calculate gain matrix</comment>
      <comment>K(k) = P(k)- * H' * (H * P(k)- * H' + R)^-1</comment>
      <comment>K(k) = P(k)- * H' * S^-1</comment>
      <comment>update estimate with measurement z(k)</comment>
      <comment>xHat(k) = xHat(k)- + K * Inn</comment>
      <comment>update covariance of prediction error</comment>
      <comment>P(k) = (I - K * H) * P(k)-</comment>
    </method>
  </class>
</source>
