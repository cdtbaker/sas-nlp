<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.linear">
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.util.LocalizedFormats" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.apache.commons.math3.util.Precision" />
  <class name="SingularValueDecomposition" startLine="24">
    <javadoc>
      <text>* Calculates the compact Singular Value Decomposition of a matrix.
 * <p>
 * The Singular Value Decomposition of matrix A is a set of three matrices: U,
 * &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>. Let A be
 * a m &times; n matrix, then U is a m &times; p orthogonal matrix, &Sigma; is a
 * p &times; p diagonal matrix with positive or null elements, V is a p &times;
 * n orthogonal matrix (hence V<sup>T</sup> is also orthogonal) where
 * p=min(m,n).
 * </p>
 * <p>This class is similar to the class with similar name from the
 * <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a> library, with the
 * following changes:</p>
 * <ul>
 * <li>the {@code norm2} method which has been renamed as {@link #getNorm()getNorm},</li>
 * <li>the {@code cond} method which has been renamed as {@link #getConditionNumber() getConditionNumber},</li>
 * <li>the {@code rank} method which has been renamed as {@link #getRank()getRank},</li>
 * <li>a {@link #getUT() getUT} method has been added,</li>
 * <li>a {@link #getVT() getVT} method has been added,</li>
 * <li>a {@link #getSolver() getSolver} method has been added,</li>
 * <li>a {@link #getCovariance(double) getCovariance} method has been added.</li>
 * </ul></text>
      <see><a href="http://mathworld.wolfram.com/SingularValueDecomposition.html">MathWorld</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Singular_value_decomposition">Wikipedia</a></see>
      <version>$Id: SingularValueDecomposition.java 1456931 2013-03-15 12:34:35Z luc $</version>
      <since>2.0 (changed to concrete class in 3.0)</since>
    </javadoc>
    <javadoc>
      <text>* Relative threshold for small singular values.</text>
    </javadoc>
    <declaration type="double" name="EPS" />
    <javadoc>
      <text>* Absolute threshold for small singular values.</text>
    </javadoc>
    <declaration type="double" name="TINY" />
    <javadoc>
      <text>* Computed singular values.</text>
    </javadoc>
    <declaration type="double[]" name="singularValues" />
    <javadoc>
      <text>* max(row dimension, column dimension).</text>
    </javadoc>
    <declaration type="int" name="m" />
    <javadoc>
      <text>* min(row dimension, column dimension).</text>
    </javadoc>
    <declaration type="int" name="n" />
    <javadoc>
      <text>* Indicator for transposed matrix.</text>
    </javadoc>
    <declaration type="boolean" name="transposed" />
    <javadoc>
      <text>* Cached value of U matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedU" />
    <javadoc>
      <text>* Cached value of transposed U matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedUt" />
    <javadoc>
      <text>* Cached value of S (diagonal) matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedS" />
    <javadoc>
      <text>* Cached value of V matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedV" />
    <javadoc>
      <text>* Cached value of transposed V matrix.</text>
    </javadoc>
    <declaration type="RealMatrix" name="cachedVt" />
    <javadoc>
      <text>* Tolerance value for small singular values, calculated once we have
 * populated "singularValues".</text>
    </javadoc>
    <declaration type="double" name="tol" />
    <javadoc>
      <text>* Calculates the compact Singular Value Decomposition of the given matrix.</text>
      <param>matrix Matrix to decompose.</param>
    </javadoc>
    <method type="constructor" name="SingularValueDecomposition" startLine="88" endLine="488">
      <declaration type="double[][]" name="A" />
      <scope startLine="92" endLine="97" />
      <scope startLine="97" endLine="102" />
      <declaration type="double[][]" name="U" />
      <declaration type="double[][]" name="V" />
      <declaration type="double[]" name="e" />
      <declaration type="double[]" name="work" />
      <declaration type="int" name="nct" />
      <declaration type="int" name="nrt" />
      <scope startLine="113" endLine="200">
        <scope startLine="114" endLine="132">
          <scope startLine="119" endLine="121" />
          <scope startLine="122" endLine="130">
            <scope startLine="123" endLine="125" />
            <scope startLine="126" endLine="128" />
          </scope>
        </scope>
        <scope startLine="133" endLine="149">
          <scope startLine="135" endLine="145">
            <declaration type="double" name="t" />
            <scope startLine="138" endLine="140" />
            <scope startLine="142" endLine="144" />
          </scope>
        </scope>
        <scope startLine="150" endLine="156">
          <scope startLine="153" endLine="155" />
        </scope>
        <scope startLine="157" endLine="199">
          <scope startLine="162" endLine="164" />
          <scope startLine="165" endLine="173">
            <scope startLine="166" endLine="168" />
            <scope startLine="169" endLine="171" />
          </scope>
          <scope startLine="176" endLine="192">
            <scope startLine="178" endLine="180" />
            <scope startLine="181" endLine="185">
              <scope startLine="182" endLine="184" />
            </scope>
            <scope startLine="186" endLine="191">
              <declaration type="double" name="t" />
              <scope startLine="188" endLine="190" />
            </scope>
          </scope>
          <scope startLine="196" endLine="198" />
        </scope>
        <comment>Compute the transformation for the k-th column and</comment>
        <comment>place the k-th diagonal in s[k].</comment>
        <comment>Compute 2-norm of k-th column without under/overflow.</comment>
        <comment>Apply the transformation.</comment>
        <comment>Place the k-th row of A into e for the</comment>
        <comment>subsequent calculation of the row transformation.</comment>
        <comment>Place the transformation in U for subsequent back</comment>
        <comment>multiplication.</comment>
        <comment>Compute the k-th row transformation and place the</comment>
        <comment>k-th super-diagonal in e[k].</comment>
        <comment>Compute 2-norm without under/overflow.</comment>
        <comment>Apply the transformation.</comment>
        <comment>Place the transformation in V for subsequent</comment>
        <comment>back multiplication.</comment>
      </scope>
      <declaration type="int" name="p" />
      <scope startLine="203" endLine="205" />
      <scope startLine="206" endLine="208" />
      <scope startLine="209" endLine="211" />
      <scope startLine="215" endLine="220">
        <scope startLine="216" endLine="218" />
      </scope>
      <scope startLine="221" endLine="246">
        <scope startLine="222" endLine="240">
          <scope startLine="223" endLine="232">
            <declaration type="double" name="t" />
            <scope startLine="225" endLine="227" />
            <scope startLine="229" endLine="231" />
          </scope>
          <scope startLine="233" endLine="235" />
          <scope startLine="237" endLine="239" />
        </scope>
        <scope startLine="240" endLine="245">
          <scope startLine="241" endLine="243" />
        </scope>
      </scope>
      <scope startLine="249" endLine="267">
        <scope startLine="251" endLine="262">
          <scope startLine="252" endLine="261">
            <declaration type="double" name="t" />
            <scope startLine="254" endLine="256" />
            <scope startLine="258" endLine="260" />
          </scope>
        </scope>
        <scope startLine="263" endLine="265" />
      </scope>
      <declaration type="int" name="pp" />
      <declaration type="int" name="iter" />
      <scope startLine="272" endLine="475">
        <declaration type="int" name="k" />
        <declaration type="int" name="kase" />
        <scope startLine="284" endLine="300">
          <declaration type="double" name="threshold" />
          <scope startLine="295" endLine="298" />
        </scope>
        <scope startLine="302" endLine="304" />
        <scope startLine="304" endLine="325">
          <declaration type="int" name="ks" />
          <scope startLine="306" endLine="316">
            <scope startLine="307" endLine="309" />
            <declaration type="double" name="t" />
            <scope startLine="312" endLine="315" />
          </scope>
          <scope startLine="317" endLine="319" />
          <scope startLine="319" endLine="321" />
          <scope startLine="321" endLine="324" />
        </scope>
        <scope startLine="330" endLine="349">
          <declaration type="double" name="f" />
          <scope startLine="333" endLine="348">
            <declaration type="double" name="t" />
            <declaration type="double" name="cs" />
            <declaration type="double" name="sn" />
            <scope startLine="338" endLine="341" />
            <scope startLine="343" endLine="347" />
          </scope>
        </scope>
        <scope startLine="352" endLine="369">
          <declaration type="double" name="f" />
          <scope startLine="355" endLine="368">
            <declaration type="double" name="t" />
            <declaration type="double" name="cs" />
            <declaration type="double" name="sn" />
            <scope startLine="363" endLine="367" />
          </scope>
        </scope>
        <scope startLine="372" endLine="434">
          <declaration type="double" name="maxPm1Pm2" />
          <declaration type="double" name="scale" />
          <declaration type="double" name="sp" />
          <declaration type="double" name="spm1" />
          <declaration type="double" name="epm1" />
          <declaration type="double" name="sk" />
          <declaration type="double" name="ek" />
          <declaration type="double" name="b" />
          <declaration type="double" name="c" />
          <declaration type="double" name="shift" />
          <scope startLine="389" endLine="395">
            <scope startLine="391" endLine="393" />
          </scope>
          <declaration type="double" name="f" />
          <declaration type="double" name="g" />
          <scope startLine="399" endLine="431">
            <declaration type="double" name="t" />
            <declaration type="double" name="cs" />
            <declaration type="double" name="sn" />
            <scope startLine="403" endLine="405" />
            <scope startLine="411" endLine="415" />
            <scope startLine="424" endLine="430">
              <scope startLine="425" endLine="429" />
            </scope>
          </scope>
        </scope>
        <scope startLine="437" endLine="472">
          <scope startLine="439" endLine="445">
            <scope startLine="442" endLine="444" />
          </scope>
          <scope startLine="447" endLine="469">
            <scope startLine="448" endLine="450" />
            <declaration type="double" name="t" />
            <scope startLine="454" endLine="460">
              <scope startLine="455" endLine="459" />
            </scope>
            <scope startLine="461" endLine="467">
              <scope startLine="462" endLine="466" />
            </scope>
          </scope>
        </scope>
        <comment>Here is where a test for too many iterations would go.</comment>
        <comment>This section of the program inspects for</comment>
        <comment>negligible elements in the s and e arrays.  On</comment>
        <comment>completion the variables kase and k are set as follows.</comment>
        <comment>kase = 1     if s(p) and e[k-1] are negligible and k<p</comment>
        <comment>kase = 2     if s(k) is negligible and k<p</comment>
        <comment>kase = 3     if e[k-1] is negligible, k<p, and</comment>
        <comment>s(k), ..., s(p) are not negligible (qr step).</comment>
        <comment>kase = 4     if e(p-1) is negligible (convergence).</comment>
        <comment>the following condition is written this way in order</comment>
        <comment>to break out of the loop when NaN occurs, writing it</comment>
        <comment>as "if (FastMath.abs(e[k]) <= threshold)" would loop</comment>
        <comment>indefinitely in case of NaNs because comparison on NaNs</comment>
        <comment>always return false, regardless of what is checked</comment>
        <comment>see issue MATH-947</comment>
        <comment>Perform the task indicated by kase.</comment>
        <comment>Deflate negligible s(p).</comment>
        <comment>Split at negligible s(k).</comment>
        <comment>Perform one qr step.</comment>
        <comment>Calculate the shift.</comment>
        <comment>Chase zeros.</comment>
        <comment>Convergence.</comment>
        <comment>Make the singular values positive.</comment>
        <comment>Order the singular values.</comment>
      </scope>
      <scope startLine="481" endLine="484" />
      <scope startLine="484" endLine="487" />
      <comment>"m" is always the largest dimension.</comment>
      <comment>Reduce A to bidiagonal form, storing the diagonal elements</comment>
      <comment>in s and the super-diagonal elements in e.</comment>
      <comment>Set up the final bidiagonal matrix or order p.</comment>
      <comment>Generate U.</comment>
      <comment>Generate V.</comment>
      <comment>Main iteration loop for the singular values.</comment>
      <comment>Set the small value tolerance used to calculate rank and pseudo-inverse</comment>
    </method>
    <javadoc>
      <text>* Returns the matrix U of the decomposition.
 * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p></text>
      <return>the U matrix</return>
      <see>#getUT()</see>
    </javadoc>
    <method type="RealMatrix" name="getU" startLine="496" endLine="500">
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Returns the transpose of the matrix U of the decomposition.
 * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p></text>
      <return>the U matrix (or null if decomposed matrix is singular)</return>
      <see>#getU()</see>
    </javadoc>
    <method type="RealMatrix" name="getUT" startLine="508" endLine="514">
      <scope startLine="509" endLine="511" />
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Returns the diagonal matrix &Sigma; of the decomposition.
 * <p>&Sigma; is a diagonal matrix. The singular values are provided in
 * non-increasing order, for compatibility with Jama.</p></text>
      <return>the &Sigma; matrix</return>
    </javadoc>
    <method type="RealMatrix" name="getS" startLine="522" endLine="528">
      <scope startLine="523" endLine="526">
        <comment>cache the matrix for subsequent calls</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the diagonal elements of the matrix &Sigma; of the decomposition.
 * <p>The singular values are provided in non-increasing order, for
 * compatibility with Jama.</p></text>
      <return>the diagonal elements of the &Sigma; matrix</return>
    </javadoc>
    <method type="double[]" name="getSingularValues" startLine="536" endLine="538" />
    <javadoc>
      <text>* Returns the matrix V of the decomposition.
 * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p></text>
      <return>the V matrix (or null if decomposed matrix is singular)</return>
      <see>#getVT()</see>
    </javadoc>
    <method type="RealMatrix" name="getV" startLine="546" endLine="549">
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Returns the transpose of the matrix V of the decomposition.
 * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p></text>
      <return>the V matrix (or null if decomposed matrix is singular)</return>
      <see>#getV()</see>
    </javadoc>
    <method type="RealMatrix" name="getVT" startLine="557" endLine="563">
      <scope startLine="558" endLine="560" />
      <comment>return the cached matrix</comment>
    </method>
    <javadoc>
      <text>* Returns the n &times; n covariance matrix.
 * <p>The covariance matrix is V &times; J &times; V<sup>T</sup>
 * where J is the diagonal matrix of the inverse of the squares of
 * the singular values.</p></text>
      <param>minSingularValue value below which singular values are ignored
 * (a 0 or negative value implies all singular value will be used)</param>
      <return>covariance matrix</return>
      <exception>IllegalArgumentException if minSingularValue is larger than
 * the largest singular value, meaning all singular values are ignored</exception>
    </javadoc>
    <method type="RealMatrix" name="getCovariance" startLine="576" endLine="602">
      <declaration type="int" name="p" />
      <declaration type="int" name="dimension" />
      <scope startLine="581" endLine="583" />
      <scope startLine="585" endLine="588" />
      <declaration type="double[][]" name="data" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="visit" startLine="595" endLine="597" />
      <declaration type="RealMatrix" name="jv" />
      <comment>get the number of singular values to consider</comment>
    </method>
    <javadoc>
      <text>* Returns the L<sub>2</sub> norm of the matrix.
 * <p>The L<sub>2</sub> norm is max(|A &times; u|<sub>2</sub> /
 * |u|<sub>2</sub>), where |.|<sub>2</sub> denotes the vectorial 2-norm
 * (i.e. the traditional euclidian norm).</p></text>
      <return>norm</return>
    </javadoc>
    <method type="double" name="getNorm" startLine="611" endLine="613" />
    <javadoc>
      <text>* Return the condition number of the matrix.</text>
      <return>condition number of the matrix</return>
    </javadoc>
    <method type="double" name="getConditionNumber" startLine="619" endLine="621" />
    <javadoc>
      <text>* Computes the inverse of the condition number.
 * In cases of rank deficiency, the {@link #getConditionNumber() condition
 * number} will become undefined.</text>
      <return>the inverse of the condition number.</return>
    </javadoc>
    <method type="double" name="getInverseConditionNumber" startLine="630" endLine="632" />
    <javadoc>
      <text>* Return the effective numerical matrix rank.
 * <p>The effective numerical rank is the number of non-negligible
 * singular values. The threshold used to identify non-negligible
 * terms is max(m,n) &times; ulp(s<sub>1</sub>) where ulp(s<sub>1</sub>)
 * is the least significant bit of the largest singular value.</p></text>
      <return>effective numerical matrix rank</return>
    </javadoc>
    <method type="int" name="getRank" startLine="642" endLine="650">
      <declaration type="int" name="r" />
      <scope startLine="644" endLine="648">
        <scope startLine="645" endLine="647" />
      </scope>
    </method>
    <javadoc>
      <text>* Get a solver for finding the A &times; X = B solution in least square sense.</text>
      <return>a solver</return>
    </javadoc>
    <method type="DecompositionSolver" name="getSolver" startLine="656" endLine="658" />
    <class name="Solver" startLine="660">
      <implements name="DecompositionSolver" />
      <javadoc>
        <text>* Specialized solver.</text>
      </javadoc>
      <javadoc>
        <text>* Pseudo-inverse of the initial matrix.</text>
      </javadoc>
      <declaration type="RealMatrix" name="pseudoInverse" />
      <javadoc>
        <text>* Singularity indicator.</text>
      </javadoc>
      <declaration type="boolean" name="nonSingular" />
      <javadoc>
        <text>* Build a solver from decomposed matrix.</text>
        <param>singularValues Singular values.</param>
        <param>uT U<sup>T</sup> matrix of the decomposition.</param>
        <param>v V matrix of the decomposition.</param>
        <param>nonSingular Singularity indicator.</param>
        <param>tol tolerance for singular values</param>
      </javadoc>
      <method type="constructor" name="Solver" startLine="677" endLine="693">
        <declaration type="double[][]" name="suT" />
        <scope startLine="679" endLine="690">
          <declaration type="double" name="a" />
          <scope startLine="681" endLine="683" />
          <scope startLine="683" endLine="685" />
          <declaration type="double[]" name="suTi" />
          <scope startLine="687" endLine="689" />
        </scope>
      </method>
      <javadoc>
        <text>* Solve the linear equation A &times; X = B in least square sense.
 * <p>
 * The m&times;n matrix A may not be square, the solution X is such that
 * ||A &times; X - B|| is minimal.
 * </p></text>
        <param>b Right-hand side of the equation A &times; X = B</param>
        <return>a vector X that minimizes the two norm of A &times; X - B</return>
        <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the matrices dimensions do not match.</throws>
      </javadoc>
      <method type="RealVector" name="solve" startLine="706" endLine="708" />
      <javadoc>
        <text>* Solve the linear equation A &times; X = B in least square sense.
 * <p>
 * The m&times;n matrix A may not be square, the solution X is such that
 * ||A &times; X - B|| is minimal.
 * </p></text>
        <param>b Right-hand side of the equation A &times; X = B</param>
        <return>a matrix X that minimizes the two norm of A &times; X - B</return>
        <throws>org.apache.commons.math3.exception.DimensionMismatchExceptionif the matrices dimensions do not match.</throws>
      </javadoc>
      <method type="RealMatrix" name="solve" startLine="722" endLine="724" />
      <javadoc>
        <text>* Check if the decomposed matrix is non-singular.</text>
        <return>{@code true} if the decomposed matrix is non-singular.</return>
      </javadoc>
      <method type="boolean" name="isNonSingular" startLine="731" endLine="733" />
      <javadoc>
        <text>* Get the pseudo-inverse of the decomposed matrix.</text>
        <return>the inverse matrix.</return>
      </javadoc>
      <method type="RealMatrix" name="getInverse" startLine="740" endLine="742" />
    </class>
  </class>
</source>
