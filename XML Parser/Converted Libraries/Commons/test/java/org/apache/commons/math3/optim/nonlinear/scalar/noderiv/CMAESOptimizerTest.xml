<?xml version="1.0" encoding="UTF-8"?>
<source package="org.apache.commons.math3.optim.nonlinear.scalar.noderiv">
  <import name="java.util.Arrays" />
  <import name="java.util.Random" />
  <import name="org.apache.commons.math3.Retry" />
  <import name="org.apache.commons.math3.RetryRunner" />
  <import name="org.apache.commons.math3.analysis.MultivariateFunction" />
  <import name="org.apache.commons.math3.exception.NumberIsTooLargeException" />
  <import name="org.apache.commons.math3.exception.NumberIsTooSmallException" />
  <import name="org.apache.commons.math3.exception.DimensionMismatchException" />
  <import name="org.apache.commons.math3.exception.MathUnsupportedOperationException" />
  <import name="org.apache.commons.math3.exception.MathIllegalStateException" />
  <import name="org.apache.commons.math3.exception.NotPositiveException" />
  <import name="org.apache.commons.math3.exception.OutOfRangeException" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.GoalType" />
  <import name="org.apache.commons.math3.optim.PointValuePair" />
  <import name="org.apache.commons.math3.optim.InitialGuess" />
  <import name="org.apache.commons.math3.optim.SimpleBounds" />
  <import name="org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction" />
  <import name="org.apache.commons.math3.optim.MaxEval" />
  <import name="org.apache.commons.math3.random.MersenneTwister" />
  <import name="org.apache.commons.math3.util.FastMath" />
  <import name="org.junit.Assert" />
  <import name="org.junit.Test" />
  <import name="org.junit.Ignore" />
  <import name="org.junit.runner.RunWith" />
  <class name="CMAESOptimizerTest" startLine="44">
    <javadoc>
      <text>* Test for {@link CMAESOptimizer}.</text>
    </javadoc>
    <declaration type="int" name="DIM" />
    <declaration type="int" name="LAMBDA" />
    <method type="void" name="testInitOutofbounds1" startLine="54" endLine="63">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testInitOutofbounds2" startLine="65" endLine="74">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testBoundariesDimensionMismatch" startLine="77" endLine="86">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testInputSigmaNegative" startLine="89" endLine="98">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testInputSigmaOutOfRange" startLine="101" endLine="110">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testInputSigmaDimensionMismatch" startLine="113" endLine="122">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testRosen" startLine="126" endLine="138">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testMaximize" startLine="142" endLine="159">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testEllipse" startLine="162" endLine="174">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testElliRotated" startLine="177" endLine="189">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testCigar" startLine="192" endLine="204">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testCigarWithBoundaries" startLine="207" endLine="219">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testTwoAxes" startLine="222" endLine="234">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testCigTab" startLine="237" endLine="249">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testSphere" startLine="252" endLine="264">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testTablet" startLine="267" endLine="279">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testDiffPow" startLine="282" endLine="294">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testSsDiffPow" startLine="297" endLine="309">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testAckley" startLine="312" endLine="324">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testRastrigin" startLine="327" endLine="339">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testConstrainedRosen" startLine="342" endLine="354">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testDiagonalRosen" startLine="357" endLine="366">
      <declaration type="double[]" name="startPoint" />
      <declaration type="double[]" name="insigma" />
      <declaration type="double[][]" name="boundaries" />
      <declaration type="PointValuePair" name="expected" />
    </method>
    <method type="void" name="testMath864" startLine="369" endLine="394">
      <declaration type="CMAESOptimizer" name="optimizer" />
      <declaration type="MultivariateFunction[]" name="fitnessFunction" />
      <method type="double" name="value" startLine="374" endLine="378">
        <declaration type="double" name="target" />
        <declaration type="double" name="error" />
      </method>
      <declaration type="double[]" name="start" />
      <declaration type="double[]" name="lower" />
      <declaration type="double[]" name="upper" />
      <declaration type="double[]" name="sigma" />
      <declaration type="double[]" name="result" />
    </method>
    <javadoc>
      <text>* Cf. MATH-867</text>
    </javadoc>
    <method type="void" name="testFitAccuracyDependsOnBoundary" startLine="400" endLine="457">
      <declaration type="CMAESOptimizer" name="optimizer" />
      <declaration type="MultivariateFunction[]" name="fitnessFunction" />
      <method type="double" name="value" startLine="405" endLine="409">
        <declaration type="double" name="target" />
        <declaration type="double" name="error" />
      </method>
      <declaration type="double[]" name="start" />
      <declaration type="PointValuePair[]" name="result" />
      <declaration type="double" name="resNoBound" />
      <declaration type="double[]" name="lower" />
      <declaration type="double[]" name="upper" />
      <declaration type="double[]" name="sigma" />
      <declaration type="double" name="resNearLo" />
      <declaration type="double" name="resNearHi" />
      <comment>No bounds.</comment>
      <comment>Optimum is near the lower bound.</comment>
      <comment>Optimum is near the upper bound.</comment>
      <comment>System.out.println("resNoBound=" + resNoBound +</comment>
      <comment>" resNearLo=" + resNearLo +</comment>
      <comment>" resNearHi=" + resNearHi);</comment>
      <comment>The two values currently differ by a substantial amount, indicating that</comment>
      <comment>the bounds definition can prevent reaching the optimum.</comment>
    </method>
    <javadoc>
      <param>func Function to optimize.</param>
      <param>startPoint Starting point.</param>
      <param>inSigma Individual input sigma.</param>
      <param>boundaries Upper / lower point limit.</param>
      <param>goal Minimization or maximization.</param>
      <param>lambda Population size used for offspring.</param>
      <param>isActive Covariance update mechanism.</param>
      <param>diagonalOnly Simplified covariance update.</param>
      <param>stopValue Termination criteria for optimization.</param>
      <param>fTol Tolerance relative error on the objective function.</param>
      <param>pointTol Tolerance for checking that the optimum is correct.</param>
      <param>maxEvaluations Maximum number of evaluations.</param>
      <param>expected Expected point / value.</param>
    </javadoc>
    <method type="void" name="doTest" startLine="486" endLine="515">
      <declaration type="int" name="dim" />
      <declaration type="CMAESOptimizer" name="optim" />
      <declaration type="PointValuePair" name="result" />
      <scope startLine="510" endLine="512" />
      <comment>test diagonalOnly = 0 - slow but normally fewer feval#</comment>
      <comment>System.out.println("sol=" + Arrays.toString(result.getPoint()));</comment>
    </method>
    <method type="double[]" name="point" startLine="517" endLine="521">
      <declaration type="double[]" name="ds" />
    </method>
    <method type="double[][]" name="boundaries" startLine="524" endLine="531">
      <declaration type="double[][]" name="boundaries" />
    </method>
    <class name="Sphere" startLine="533">
      <implements name="MultivariateFunction" />
      <method type="double" name="value" startLine="535" endLine="540">
        <declaration type="double" name="f" />
      </method>
      <class name="Cigar" startLine="543">
        <implements name="MultivariateFunction" />
        <declaration type="double" name="factor" />
        <method type="constructor" name="Cigar" startLine="546" endLine="548" />
        <method type="constructor" name="Cigar" startLine="550" endLine="552" />
        <method type="double" name="value" startLine="554" endLine="559">
          <declaration type="double" name="f" />
        </method>
        <class name="Tablet" startLine="562">
          <implements name="MultivariateFunction" />
          <declaration type="double" name="factor" />
          <method type="constructor" name="Tablet" startLine="565" endLine="567" />
          <method type="constructor" name="Tablet" startLine="569" endLine="571" />
          <method type="double" name="value" startLine="573" endLine="578">
            <declaration type="double" name="f" />
          </method>
          <class name="CigTab" startLine="581">
            <implements name="MultivariateFunction" />
            <declaration type="double" name="factor" />
            <method type="constructor" name="CigTab" startLine="584" endLine="586" />
            <method type="constructor" name="CigTab" startLine="588" endLine="590" />
            <method type="double" name="value" startLine="592" endLine="598">
              <declaration type="int" name="end" />
              <declaration type="double" name="f" />
            </method>
            <class name="TwoAxes" startLine="601">
              <implements name="MultivariateFunction" />
              <declaration type="double" name="factor" />
              <method type="constructor" name="TwoAxes" startLine="605" endLine="607" />
              <method type="constructor" name="TwoAxes" startLine="609" endLine="611" />
              <method type="double" name="value" startLine="613" endLine="618">
                <declaration type="double" name="f" />
              </method>
              <class name="ElliRotated" startLine="621">
                <implements name="MultivariateFunction" />
                <declaration type="Basis" name="B" />
                <declaration type="double" name="factor" />
                <method type="constructor" name="ElliRotated" startLine="625" endLine="627" />
                <method type="constructor" name="ElliRotated" startLine="629" endLine="631" />
                <method type="double" name="value" startLine="633" endLine="639">
                  <declaration type="double" name="f" />
                </method>
                <class name="Elli" startLine="642">
                  <implements name="MultivariateFunction" />
                  <declaration type="double" name="factor" />
                  <method type="constructor" name="Elli" startLine="646" endLine="648" />
                  <method type="constructor" name="Elli" startLine="650" endLine="652" />
                  <method type="double" name="value" startLine="654" endLine="659">
                    <declaration type="double" name="f" />
                  </method>
                  <class name="MinusElli" startLine="662">
                    <implements name="MultivariateFunction" />
                    <method type="double" name="value" startLine="664" endLine="666" />
                    <class name="DiffPow" startLine="669">
                      <implements name="MultivariateFunction" />
                      <method type="double" name="value" startLine="671" endLine="677">
                        <declaration type="double" name="f" />
                      </method>
                      <class name="SsDiffPow" startLine="680">
                        <implements name="MultivariateFunction" />
                        <method type="double" name="value" startLine="682" endLine="685">
                          <declaration type="double" name="f" />
                        </method>
                        <class name="Rosen" startLine="688">
                          <implements name="MultivariateFunction" />
                          <method type="double" name="value" startLine="690" endLine="696">
                            <declaration type="double" name="f" />
                          </method>
                          <class name="Ackley" startLine="699">
                            <implements name="MultivariateFunction" />
                            <declaration type="double" name="axisratio" />
                            <method type="constructor" name="Ackley" startLine="702" endLine="704" />
                            <method type="constructor" name="Ackley" startLine="706" endLine="708" />
                            <method type="double" name="value" startLine="710" endLine="722">
                              <declaration type="double" name="f" />
                              <declaration type="double" name="res2" />
                              <declaration type="double" name="fac" />
                              <scope startLine="714" endLine="718" />
                            </method>
                            <class name="Rastrigin" startLine="725">
                              <implements name="MultivariateFunction" />
                              <declaration type="double" name="axisratio" />
                              <declaration type="double" name="amplitude" />
                              <method type="constructor" name="Rastrigin" startLine="730" endLine="732" />
                              <method type="constructor" name="Rastrigin" startLine="734" endLine="737" />
                              <method type="double" name="value" startLine="739" endLine="750">
                                <declaration type="double" name="f" />
                                <declaration type="double" name="fac" />
                                <scope startLine="742" endLine="748" />
                              </method>
                              <class name="Basis" startLine="753">
                                <declaration type="double[][]" name="basis" />
                                <declaration type="Random" name="rand" />
                                <method type="double[]" name="Rotate" startLine="757" endLine="766">
                                  <declaration type="double[]" name="y" />
                                  <scope startLine="760" endLine="764" />
                                </method>
                                <method type="void" name="GenBasis" startLine="768" endLine="794">
                                  <declaration type="double" name="sp" />
                                  <declaration type="int" name="i" />
                                  <scope startLine="777" endLine="793">
                                    <scope startLine="782" endLine="787" />
                                    <comment>sample components gaussian</comment>
                                    <comment>substract projection of previous vectors</comment>
                                    <comment>sp += basis[i][k]  basis[j][k];  scalar product</comment>
                                    <comment>basis[i][k] -= sp  basis[j][k];  substract</comment>
                                    <comment>normalize</comment>
                                    <comment>sp += basis[i][k]  basis[i][k];  squared norm</comment>
                                  </scope>
                                  <comment>generate orthogonal basis</comment>
                                </method>
                              </class>
                            </class>
                          </class>
                        </class>
                      </class>
                    </class>
                  </class>
                </class>
              </class>
            </class>
          </class>
        </class>
      </class>
    </class>
    <comment>use not always the same basis</comment>
  </class>
</source>
