<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.block.decomposition.qr">
        <import package="org.ejml.alg.block.BlockMatrixOps"/>
        <import package="org.ejml.alg.block.BlockMultiplication"/>
        <import package="org.ejml.data.BlockMatrix64F"/>
        <import package="org.ejml.data.D1Submatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <class name="BlockMatrix64HouseholderQR" line="28">
            <comment line="29">
                the input matrix which is overwritten with the decomposition.                
            </comment>
            <comment line="29">
                Reflectors are stored in the lower triangular portion. The R matrix is stored                
            </comment>
            <comment line="29">
                in the upper triangle portion                
            </comment>
            <comment line="29">
                where the computed W matrix is stored                
            </comment>
            <comment line="29">
                Matrix used to store an intermediate calculation                
            </comment>
            <comment line="29">
                size of the inner matrix block.                
            </comment>
            <comment line="29">
                The submatrices which are being manipulated in each iteration                
            </comment>
            <comment line="29">
                stores the computed gammas                
            </comment>
            <comment line="29">
                save the W matrix the first time it is computed in the decomposition                
            </comment>
            <implements interface="QRDecomposition&lt;BlockMatrix64F&gt;"/>
            <javadoc line="28">
                &lt;p&gt;
                 * QR decomposition for {@link BlockMatrix64F} using householder reflectors.  The decomposition is
                 * performed by computing a QR decomposition for each block column as is normally done, see {@link org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholder}.
                 * The reflectors are then combined and applied to the remainder of the matrix.  This process is repeated
                 * until all the block columns have been processed
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * The input matrix is modified and used to store the decomposition.  Reflectors are stored in the lower triangle
                 * columns.  The first element of the reflector is implicitly assumed to be one.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Each iteration can be sketched as follows:
                 * &lt;pre&gt;
                 * QR_Decomposition( A(:,i-r to i) )
                 * W=computeW( A(:,i-r to i) )
                 * A(:,i:n) = (I + W*Y&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A(:,i:n)
                 * &lt;/pre&gt;
                 * Where r is the block size, i is the submatrix being considered, A is the input matrix,
                 * Y is a matrix containing the reflectors just computed,
                 * and W is computed using {@link BlockHouseHolder#computeW_Column}.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Based upon &quot;Block Householder QR Factorization&quot; pg 255 in &quot;Matrix Computations&quot;
                 * 3rd Ed. 1996 by Gene H. Golub and Charles F. Van Loan.
                 * &lt;/p&gt;                
                <@author>
                    r Peter Abeles                    
                </@author>
            </javadoc>
            <declaration name="dataA" type="BlockMatrix64F" line="66"/>
            <declaration name="dataW" type="BlockMatrix64F" line="69"/>
            <declaration name="dataWTA" type="BlockMatrix64F" line="71"/>
            <declaration name="blockLength" type="int" line="74"/>
            <declaration name="A" type="D1Submatrix64F" line="77"/>
            <declaration name="Y" type="D1Submatrix64F" line="78"/>
            <declaration name="W" type="D1Submatrix64F" line="79"/>
            <declaration name="WTA" type="D1Submatrix64F" line="80"/>
            <declaration name="temp" type="double" line="81"/>
            <declaration name="gammas" type="double" line="83"/>
            <declaration name="saveW" type="boolean" line="86"/>
            <javadoc line="88">
                This is the input matrix after it has been overwritten with the decomposition.                
                <@return>
                    n Internal matrix used to store decomposition.                    
                </@return>
            </javadoc>
            <method name="getQR" type="BlockMatrix64F" line="93"/>
            <javadoc line="97">
                &lt;p&gt;
                 * Sets if it should internally save the W matrix before performing the decomposition.  Must
                 * be set before decomposition the matrix.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Saving W can result in about a 5% savings when solving systems around a height of 5k.  The
                 * price is that it needs to save a matrix the size of the input matrix.
                 * &lt;/p&gt;                
                <@param>
                    m saveW If the W matrix should be saved or not.                    
                </@param>
            </javadoc>
            <method name="setSaveW" type="void" line="110"/>
            <javadoc line="114">
                @inheritDoc                
            </javadoc>
            <method name="getQ" type="BlockMatrix64F" line="118"/>
            <javadoc line="126">
                Sanity checks the input or declares a new matrix.  Return matrix is an identity matrix.                
            </javadoc>
            <method name="initializeQ" type="BlockMatrix64F" line="131">
                <declaration name="minLength" type="int" line="132"/>
                <scope line="133">
                    <scope line="134"/>
                    <scope line="137">
                        <scope line="138"/>
                        <scope line="140"/>
                    </scope>
                </scope>
                <scope line="144">
                    <scope line="145"/>
                    <scope line="148">
                        <scope line="149"/>
                        <scope line="151"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="159">
                &lt;p&gt;
                 * Multiplies the provided matrix by Q using householder reflectors.  This is more
                 * efficient that computing Q then applying it to the matrix.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * B = Q * B
                 * &lt;/p&gt;                
                <@param>
                    m B Matrix which Q is applied to.  Modified.                    
                </@param>
            </javadoc>
            <method name="applyQ" type="void" line="171"/>
            <javadoc line="175">
                Specialized version of applyQ() that allows the zeros in an identity matrix
                 * to be taken advantage of depending on if isIdentity is true or not.                
                <@param>
                    m B                    
                </@param>
                <@param>
                    m isIdentity If B is an identity matrix.                    
                </@param>
            </javadoc>
            <method name="applyQ" type="void" line="182">
                <comment line="183">
                    (Q1^T * (Q2^T * (Q3^t * A)))                    
                </comment>
                <declaration name="minDimen" type="int" line="183"/>
                <declaration name="subB" type="D1Submatrix64F" line="185"/>
                <declaration name="start" type="int" line="191"/>
                <scope line="198"/>
            </method>
            <javadoc line="222">
                &lt;p&gt;
                 * Multiplies the provided matrix by Q&lt;sup&gt;T&lt;/sup&gt; using householder reflectors.  This is more
                 * efficient that computing Q then applying it to the matrix.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Q = Q*(I - &amp;gamma; W*Y^T)&lt;br&gt;
                 * QR = A =&gt; R = Q^T*A  = (Q3^T * (Q2^T * (Q1^t * A)))
                 * &lt;/p&gt;                
                <@param>
                    m B Matrix which Q is applied to.  Modified.                    
                </@param>
            </javadoc>
            <method name="applyQTran" type="void" line="235">
                <comment line="236">
                    (Q3^T * (Q2^T * (Q1^t * A)))                    
                </comment>
                <declaration name="minDimen" type="int" line="236"/>
                <declaration name="subB" type="D1Submatrix64F" line="238"/>
                <scope line="245"/>
            </method>
            <javadoc line="274">
                @inheritDoc                
            </javadoc>
            <method name="getR" type="BlockMatrix64F" line="278">
                <declaration name="min" type="int" line="279"/>
                <scope line="281">
                    <scope line="282"/>
                    <scope line="284"/>
                </scope>
                <scope line="287">
                    <scope line="288">
                        <scope line="289"/>
                    </scope>
                    <scope line="292"/>
                </scope>
            </method>
            <javadoc line="303">
                @inheritDoc                
            </javadoc>
            <method name="decompose" type="boolean" line="307">
                <comment line="308">
                    process the matrix one column block at a time and overwrite the input matrix                    
                </comment>
                <declaration name="m" type="int" line="310"/>
                <scope line="313">
                    <scope line="320"/>
                </scope>
            </method>
            <javadoc line="331">
                Adjust submatrices and helper data structures for the input matrix.  Must be called
                 * before the decomposition can be computed.                
                <@param>
                    m orig                    
                </@param>
            </javadoc>
            <method name="setup" type="void" line="337">
                <declaration name="l" type="int" line="345"/>
                <scope line="355"/>
            </method>
            <javadoc line="360">
                &lt;p&gt;
                 * A = (I + W Y&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A&lt;BR&gt;
                 * A = A + Y (W&lt;sup&gt;T&lt;/sup&gt;A)&lt;BR&gt;
                 * &lt;br&gt;
                 * where A is a submatrix of the input matrix.
                 * &lt;/p&gt;                
            </javadoc>
            <method name="updateA" type="void" line="369">
                <scope line="383"/>
                <scope line="388"/>
            </method>
            <javadoc line="393">
                Sets the submatrix of W up give Y is already configured and if it is being cached or not.                
            </javadoc>
            <method name="setW" type="void" line="396">
                <scope line="397"/>
                <scope line="402"/>
            </method>
            <javadoc line="408">
                The input matrix is always modified.                
                <@return>
                    n Returns true since the input matrix is modified.                    
                </@return>
            </javadoc>
            <method name="inputModified" type="boolean" line="414"/>
        </class>
    </source>