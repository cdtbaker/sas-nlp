<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.bidiagonal">
        <import package="org.ejml.UtilEjml"/>
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.DecompositionFactory"/>
        <import package="org.ejml.factory.QRPDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="BidiagonalDecompositionTall" line="28">
            <comment line="29">
                TODO optimize this code                
            </comment>
            <comment line="29">
                PDecomposition&lt;DenseMatrix64F&gt; decompQRP = DecompositionFactory.qrp(500, 100); // todo this should be passed in                
            </comment>
            <comment line="29">
                number of rows                
            </comment>
            <comment line="29">
                number of column                
            </comment>
            <comment line="29">
                min(m,n)                
            </comment>
            <implements interface="BidiagonalDecomposition&lt;DenseMatrix64F&gt;"/>
            <javadoc line="28">
                &lt;p&gt;{@link BidiagonalDecomposition} specifically designed for tall matrices.
                 * First step is to perform QR decomposition on the input matrix.  Then R is decomposed using
                 * a bidiagonal decomposition.  By performing the bidiagonal decomposition on the smaller matrix
                 * computations can be saved if m/n &gt; 5/3 and if U is NOT needed.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * A = [Q&lt;sub&gt;1&lt;/sub&gt; Q&lt;sub&gt;2&lt;/sub&gt;][U1 0; 0 I] [B1;0] V&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
                 * U=[Q&lt;sub&gt;1&lt;/sub&gt;*U1 Q&lt;sub&gt;2&lt;/sub&gt;]&lt;br&gt;
                 * B=[B1;0]&lt;br&gt;
                 * A = U*B*V&lt;sup&gt;T&lt;/sup&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * A QRP decomposition is used internally.  That decomposition relies an a fixed threshold for selecting singular
                 * values and is known to be less stable than SVD.  There is the potential for a degregation of stability
                 * by using BidiagonalDecompositionTall instead of BidiagonalDecomposition. A few simple tests have shown
                 * that loss in stability to be insignificant.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * See page 404 in &quot;Fundamentals of Matrix Computations&quot;, 2nd by David S. Watkins.
                 * &lt;/p&gt;                
                <@author>
                    r Peter Abeles                    
                </@author>
            </javadoc>
            <declaration name="decompQRP" type="QRPDecomposition&lt;DenseMatrix64F&gt;" line="61"/>
            <declaration name="decompBi" type="BidiagonalDecomposition&lt;DenseMatrix64F&gt;" line="62"/>
            <declaration name="B" type="DenseMatrix64F" line="64"/>
            <declaration name="m" type="int" line="67"/>
            <declaration name="n" type="int" line="69"/>
            <declaration name="min" type="int" line="71"/>
            <method name="getDiagonal" type="void" line="74">
                <scope line="76"/>
            </method>
            <method name="getB" type="DenseMatrix64F" line="83">
                <scope line="87"/>
            </method>
            <method name="getU" type="DenseMatrix64F" line="98">
                <scope line="101">
                    <declaration name="Q1" type="DenseMatrix64F" line="103"/>
                    <declaration name="U1" type="DenseMatrix64F" line="104"/>
                </scope>
                <scope line="106">
                    <declaration name="Q" type="DenseMatrix64F" line="108"/>
                    <declaration name="U1" type="DenseMatrix64F" line="109"/>
                    <declaration name="Q1" type="DenseMatrix64F" line="110"/>
                    <declaration name="tmp" type="DenseMatrix64F" line="111"/>
                </scope>
            </method>
            <method name="getV" type="DenseMatrix64F" line="123"/>
            <method name="decompose" type="boolean" line="128">
                <comment line="129">
                    apply the column pivots.                    
                </comment>
                <comment line="129">
                    TODO this is horribly inefficient                    
                </comment>
                <scope line="131"/>
                <declaration name="result" type="DenseMatrix64F" line="144"/>
                <declaration name="P" type="DenseMatrix64F" line="145"/>
            </method>
            <method name="inputModified" type="boolean" line="153"/>
        </class>
    </source>