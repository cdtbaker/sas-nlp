<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.QRPDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="QRColPivDecompositionHouseholderColumn" extends="QRDecompositionHouseholderColumn" line="25">
            <comment line="26">
                the ordering of each column, the current column i is the original column pivots[i]                
            </comment>
            <comment line="26">
                F-norm  squared for each column                
            </comment>
            <comment line="26">
                threshold used to determine when a column is considered to be singular                
            </comment>
            <comment line="26">
                Threshold is relative to the maxAbs                
            </comment>
            <comment line="26">
                the matrix&apos;s rank                
            </comment>
            <implements interface="QRPDecomposition&lt;DenseMatrix64F&gt;"/>
            <javadoc line="25">
                &lt;p&gt;
                 * Performs QR decomposition with column pivoting.  To prevent overflow/underflow the whole matrix
                 * is normalized by the max value, but columns are not normalized individually any more. To enable
                 * code reuse it extends {@link QRDecompositionHouseholderColumn} and functions from that class
                 * are used whenever possible.  Columns are transposed into single arrays, which allow for
                 * fast pivots.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Decomposition: A*P = Q*R
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Based off the description in &quot;Fundamentals of Matrix Computations&quot;, 2nd by David S. Watkins.
                 * &lt;/p&gt;                
                <@author>
                    r Peter Abeles                    
                </@author>
            </javadoc>
            <declaration name="pivots" type="int" line="49"/>
            <declaration name="normsCol" type="double" line="51"/>
            <declaration name="singularThreshold" type="double" line="55"/>
            <declaration name="rank" type="int" line="58"/>
            <javadoc line="60">
                Configure parameters.                
                <@param>
                    m singularThreshold The singular threshold.                    
                </@param>
            </javadoc>
            <method name="QRColPivDecompositionHouseholderColumn" type="constructor" line="65"/>
            <method name="QRColPivDecompositionHouseholderColumn" type="constructor" line="69"/>
            <method name="setSingularThreshold" type="void" line="73"/>
            <method name="setExpectedMaxSize" type="void" line="78">
                <scope line="81"/>
            </method>
            <javadoc line="87">
                Computes the Q matrix from the information stored in the QR matrix.  This
                 * operation requires about 4(m&lt;sup&gt;2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.                
                <@param>
                    m Q The orthogonal Q matrix.                    
                </@param>
            </javadoc>
            <method name="getQ" type="DenseMatrix64F" line="94">
                <scope line="95">
                    <scope line="96"/>
                    <scope line="98">
                        <scope line="99"/>
                        <scope line="101"/>
                    </scope>
                </scope>
                <scope line="105">
                    <scope line="106"/>
                    <scope line="108">
                        <scope line="109"/>
                        <scope line="111"/>
                    </scope>
                </scope>
                <scope line="117">
                    <declaration name="u" type="double" line="118"/>
                    <declaration name="vv" type="double" line="120"/>
                </scope>
            </method>
            <javadoc line="129">
                &lt;p&gt;
                 * To decompose the matrix &apos;A&apos; it must have full rank.  &apos;A&apos; is a &apos;m&apos; by &apos;n&apos; matrix.
                 * It requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * The matrix provided here can be of different
                 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
                 * to it.
                 * &lt;/p&gt;                
            </javadoc>
            <method name="decompose" type="boolean" line="142">
                <comment line="143">
                    initialize pivot variables                    
                </comment>
                <comment line="143">
                    go through each column and perform the decomposition                    
                </comment>
                <scope line="151"/>
            </method>
            <javadoc line="165">
                Sets the initial pivot ordering and compute the F-norm squared for each column                
            </javadoc>
            <method name="setupPivotInfo" type="void" line="168">
                <scope line="169">
                    <declaration name="c" type="double" line="171"/>
                    <declaration name="norm" type="double" line="172"/>
                    <scope line="173">
                        <declaration name="element" type="double" line="174"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="182">
                Performs an efficient update of each columns&apos; norm                
            </javadoc>
            <method name="updateNorms" type="void" line="185">
                <comment line="186">
                    if a negative sum has been found then clearly too much precision has been last                    
                </comment>
                <comment line="186">
                    and it should recompute the column norms from scratch                    
                </comment>
                <declaration name="foundNegative" type="boolean" line="186"/>
                <scope line="187">
                    <declaration name="e" type="double" line="188"/>
                    <scope line="191"/>
                </scope>
                <scope line="199">
                    <scope line="200">
                        <declaration name="u" type="double" line="201"/>
                        <declaration name="actual" type="double" line="202"/>
                        <scope line="203">
                            <declaration name="v" type="double" line="204"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="212">
                Finds the column with the largest normal and makes that the first column                
                <@param>
                    m j Current column being inspected                    
                </@param>
            </javadoc>
            <method name="swapColumns" type="void" line="217">
                <comment line="218">
                    find the column with the largest norm                    
                </comment>
                <comment line="218">
                    swap the columns                    
                </comment>
                <declaration name="largestIndex" type="int" line="220"/>
                <declaration name="largestNorm" type="double" line="221"/>
                <scope line="222">
                    <declaration name="n" type="double" line="223"/>
                    <scope line="224"/>
                </scope>
                <declaration name="tempC" type="double[]" line="230"/>
                <declaration name="tempN" type="double" line="233"/>
                <declaration name="tempP" type="int" line="236"/>
            </method>
            <javadoc line="241">
                &lt;p&gt;
                 * Computes the householder vector &quot;u&quot; for the first column of submatrix j. The already computed
                 * norm is used and checks to see if the matrix is singular at this point.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * This function finds the values of &apos;u&apos; and &apos;&amp;gamma;&apos;.
                 * &lt;/p&gt;                
                <@param>
                    m j Which submatrix to work off of.                    
                </@param>
                <@return>
                    n false if it is degenerate                    
                </@return>
            </javadoc>
            <method name="householderPivot" type="boolean" line="257">
                <comment line="258">
                    find the largest value in this column                    
                </comment>
                <comment line="258">
                    this is used to normalize the column and mitigate overflow/underflow                    
                </comment>
                <declaration name="u" type="double" line="258"/>
                <declaration name="max" type="double" line="262"/>
                <scope line="264"/>
                <scope line="266">
                    <declaration name="u_0" type="double" line="271"/>
                    <scope line="279"/>
                </scope>
            </method>
            <method name="getRank" type="int" line="290"/>
            <method name="getPivots" type="int[]" line="295"/>
            <method name="getPivotMatrix" type="DenseMatrix64F" line="300">
                <scope line="307"/>
                <scope line="311"/>
            </method>
        </class>
    </source>