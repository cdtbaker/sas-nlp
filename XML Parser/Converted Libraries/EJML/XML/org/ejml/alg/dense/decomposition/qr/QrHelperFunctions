<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <class name="QrHelperFunctions" line="24">
            <javadoc line="24">
                &lt;p&gt;
                 * Contains different functions that are useful for computing the QR decomposition of a matrix.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Two different families of functions are provided for help in computing reflectors.  Internally
                 * both of these functions switch between normalization by division or multiplication.  Multiplication
                 * is most often significantly faster than division (2 or 3 times) but produces less accurate results
                 * on very small numbers.  It checks to see if round off error is significant and decides which
                 * one it should do.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Tests were done using the stability benchmark in jmatbench and there doesn&apos;t seem to be
                 * any advantage to always dividing by the max instead of checking and deciding.  The most
                 * noticeable difference between the two methods is with very small numbers.
                 * &lt;/p&gt;                
                <@author>
                    r Peter Abeles                    
                </@author>
            </javadoc>
            <method name="findMax" type="double" line="47">
                <declaration name="max" type="double" line="48"/>
                <declaration name="index" type="int" line="50"/>
                <declaration name="stopIndex" type="int" line="51"/>
                <scope line="52">
                    <declaration name="val" type="double" line="53"/>
                </scope>
            </method>
            <method name="divideElements" type="void" line="63">
                <comment line="64">
                    double div_u = 1.0/u_0;                    
                </comment>
                <comment line="64">
                                        
                </comment>
                <comment line="64">
                    if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="64">
                    } else {                    
                </comment>
                <comment line="64">
                    for( int i = j; i &lt; numRows; i++ ) {                    
                </comment>
                <comment line="64">
                    u[i] *= div_u;                    
                </comment>
                <comment line="64">
                    }                    
                </comment>
                <comment line="64">
                    }                    
                </comment>
                <scope line="67"/>
            </method>
            <method name="divideElements" type="void" line="77">
                <comment line="78">
                    double div_u = 1.0/u_0;                    
                </comment>
                <comment line="78">
                                        
                </comment>
                <comment line="78">
                    if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="78">
                    } else {                    
                </comment>
                <comment line="78">
                    for( int i = j; i &lt; numRows; i++ ) {                    
                </comment>
                <comment line="78">
                    u[i+startU] *= div_u;                    
                </comment>
                <comment line="78">
                    }                    
                </comment>
                <comment line="78">
                    }                    
                </comment>
                <scope line="81"/>
            </method>
            <method name="divideElements_Brow" type="void" line="93">
                <comment line="94">
                    double div_u = 1.0/u_0;                    
                </comment>
                <comment line="94">
                                        
                </comment>
                <comment line="94">
                    if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="94">
                    } else {                    
                </comment>
                <comment line="94">
                    for( int i = j; i &lt; numRows; i++ ) {                    
                </comment>
                <comment line="94">
                    u[i] = b[i+startB] *= div_u;                    
                </comment>
                <comment line="94">
                    }                    
                </comment>
                <comment line="94">
                    }                    
                </comment>
                <scope line="97"/>
            </method>
            <method name="divideElements_Bcol" type="void" line="110">
                <comment line="111">
                    double div_u = 1.0/u_0;                    
                </comment>
                <comment line="111">
                                        
                </comment>
                <comment line="111">
                    if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="111">
                    } else {                    
                </comment>
                <comment line="111">
                    int indexB = j*numCols+startB;                    
                </comment>
                <comment line="111">
                    for( int i = j; i &lt; numRows; i++ , indexB += numCols ) {                    
                </comment>
                <comment line="111">
                    b[indexB] = u[i] *= div_u;                    
                </comment>
                <comment line="111">
                    }                    
                </comment>
                <comment line="111">
                    }                    
                </comment>
                <declaration name="indexB" type="int" line="114"/>
                <scope line="115"/>
            </method>
            <method name="computeTauAndDivide" type="double" line="126">
                <comment line="127">
                    compute the norm2 of the matrix, with each element                    
                </comment>
                <comment line="127">
                    normalized by the max value to avoid overflow problems                    
                </comment>
                <comment line="127">
                    double div_max = 1.0/max;                    
                </comment>
                <comment line="127">
                    if( Double.isInfinite(div_max)) {                    
                </comment>
                <comment line="127">
                    more accurate                    
                </comment>
                <comment line="127">
                    } else {                    
                </comment>
                <comment line="127">
                    // faster                    
                </comment>
                <comment line="127">
                    for( int i = j; i &lt; numRows; i++ ) {                    
                </comment>
                <comment line="127">
                    double d = u[startU+i] *= div_max;                    
                </comment>
                <comment line="127">
                    tau += d*d;                    
                </comment>
                <comment line="127">
                    }                    
                </comment>
                <comment line="127">
                    }                    
                </comment>
                <declaration name="tau" type="double" line="129"/>
                <scope line="133">
                    <declaration name="d" type="double" line="134"/>
                </scope>
            </method>
            <javadoc line="152">
                Normalizes elements in &apos;u&apos; by dividing by max and computes the norm2 of the normalized
                 * array u.  Adjust the sign of the returned value depending on the size of the first
                 * element in &apos;u&apos;. Normalization is done to avoid overflow.
                 * &lt;pre&gt;
                 * for i=j:numRows
                 * u[i] = u[i] / max
                 * tau = tau + u[i]*u[i]
                 * end
                 * tau = sqrt(tau)
                 * if( u[j] &lt; 0 )
                 * tau = -tau;
                 * &lt;/pre&gt;                
                <@param>
                    m j Element in 'u' that it starts at.                    
                </@param>
                <@param>
                    m numRows Element in 'u' that it stops at.                    
                </@param>
                <@param>
                    m u Array                    
                </@param>
                <@param>
                    m max Max value in 'u' that is used to normalize it.                    
                </@param>
                <@return>
                    n norm2 of 'u'                    
                </@return>
            </javadoc>
            <method name="computeTauAndDivide" type="double" line="174">
                <comment line="175">
                    double div_max = 1.0/max;                    
                </comment>
                <comment line="175">
                    if( Double.isInfinite(div_max)) {                    
                </comment>
                <comment line="175">
                    } else {                    
                </comment>
                <comment line="175">
                    for( int i = j; i &lt; numRows; i++ ) {                    
                </comment>
                <comment line="175">
                    double d = u[i] *= div_max;                    
                </comment>
                <comment line="175">
                    tau += d*d;                    
                </comment>
                <comment line="175">
                    }                    
                </comment>
                <comment line="175">
                    }                    
                </comment>
                <declaration name="tau" type="double" line="175"/>
                <scope line="178">
                    <declaration name="d" type="double" line="179"/>
                </scope>
            </method>
            <javadoc line="196">
                &lt;p&gt;
                 * Performs a rank-1 update operation on the submatrix specified by w with the multiply on the right.&lt;br&gt;
                 * &lt;br&gt;
                 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)*A&lt;br&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * The order that matrix multiplies are performed has been carefully selected
                 * to minimize the number of operations.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Before this can become a truly generic operation the submatrix specification needs
                 * to be made more generic.
                 * &lt;/p&gt;                
            </javadoc>
            <method name="rank1UpdateMultR" type="void" line="216">
                <comment line="217">
                    for( int i = colA0; i &lt; A.numCols; i++ ) {                    
                </comment>
                <comment line="217">
                    double val = 0;                    
                </comment>
                <comment line="217">
                                        
                </comment>
                <comment line="217">
                    for( int k = w0; k &lt; w1; k++ ) {                    
                </comment>
                <comment line="217">
                    val += u[k]*A.data[k*A.numCols +i];                    
                </comment>
                <comment line="217">
                    }                    
                </comment>
                <comment line="217">
                    _temp[i] = gamma*val;                    
                </comment>
                <comment line="217">
                    }                    
                </comment>
                <comment line="217">
                    reordered to reduce cpu cache issues                    
                </comment>
                <comment line="217">
                    end of reorder                    
                </comment>
                <scope line="227"/>
                <scope line="231">
                    <declaration name="indexA" type="int" line="232"/>
                    <declaration name="valU" type="double" line="233"/>
                    <scope line="234"/>
                </scope>
                <scope line="238"/>
                <scope line="244">
                    <declaration name="valU" type="double" line="245"/>
                    <declaration name="indexA" type="int" line="247"/>
                    <scope line="248"/>
                </scope>
            </method>
            <method name="rank1UpdateMultR" type="void" line="260">
                <comment line="261">
                    for( int i = colA0; i &lt; A.numCols; i++ ) {                    
                </comment>
                <comment line="261">
                    double val = 0;                    
                </comment>
                <comment line="261">
                                        
                </comment>
                <comment line="261">
                    for( int k = w0; k &lt; w1; k++ ) {                    
                </comment>
                <comment line="261">
                    val += u[k+offsetU]*A.data[k*A.numCols +i];                    
                </comment>
                <comment line="261">
                    }                    
                </comment>
                <comment line="261">
                    _temp[i] = gamma*val;                    
                </comment>
                <comment line="261">
                    }                    
                </comment>
                <comment line="261">
                    reordered to reduce cpu cache issues                    
                </comment>
                <comment line="261">
                    end of reorder                    
                </comment>
                <scope line="271"/>
                <scope line="275">
                    <declaration name="indexA" type="int" line="276"/>
                    <declaration name="valU" type="double" line="277"/>
                    <scope line="278"/>
                </scope>
                <scope line="282"/>
                <scope line="288">
                    <declaration name="valU" type="double" line="289"/>
                    <declaration name="indexA" type="int" line="291"/>
                    <scope line="292"/>
                </scope>
            </method>
            <javadoc line="298">
                &lt;p&gt;
                 * Performs a rank-1 update operation on the submatrix specified by w with the multiply on the left.&lt;br&gt;
                 * &lt;br&gt;
                 * A = A(I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)&lt;br&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * The order that matrix multiplies are performed has been carefully selected
                 * to minimize the number of operations.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Before this can become a truly generic operation the submatrix specification needs
                 * to be made more generic.
                 * &lt;/p&gt;                
            </javadoc>
            <method name="rank1UpdateMultL" type="void" line="318">
                <scope line="319">
                    <declaration name="startIndex" type="int" line="320"/>
                    <declaration name="sum" type="double" line="321"/>
                    <declaration name="rowIndex" type="int" line="322"/>
                    <scope line="323"/>
                    <scope line="329"/>
                </scope>
            </method>
        </class>
    </source>