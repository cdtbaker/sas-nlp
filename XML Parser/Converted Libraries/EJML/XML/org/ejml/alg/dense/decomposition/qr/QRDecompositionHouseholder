<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="QRDecompositionHouseholder" line="26">
            <comment line="27">
                used internally to store temporary data                
            </comment>
            <comment line="27">
                dimension of the decomposed matrices                
            </comment>
            <comment line="27">
                otected int numCols; // this is &apos;n&apos;                
            </comment>
            <comment line="27">
                otected int numRows; // this is &apos;m&apos;                
            </comment>
            <comment line="27">
                the computed gamma for Q_k matrix                
            </comment>
            <comment line="27">
                local variables                
            </comment>
            <comment line="27">
                did it encounter an error?                
            </comment>
            <implements interface="QRDecomposition&lt;DenseMatrix64F&gt;"/>
            <javadoc line="26">
                &lt;p&gt;
                 * This variation of QR decomposition uses reflections to compute the Q matrix.
                 * Each reflection uses a householder operations, hence its name.  To provide a meaningful solution
                 * the original matrix must have full rank.  This is intended for processing of small to medium matrices.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Both Q and R are stored in the same m by n matrix.  Q is not stored directly, instead the u from
                 * Q&lt;sub&gt;k&lt;/sub&gt;=(I-&amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;) is stored.  Decomposition requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * See the QR reflections algorithm described in:&lt;br&gt;
                 * David S. Watkins, &quot;Fundamentals of Matrix Computations&quot; 2nd Edition, 2002
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * For the most part this is a straight forward implementation.  To improve performance on large matrices a column is writen to an array and the order
                 * of some of the loops has been changed.  This will degrade performance noticeably on small matrices.  Since
                 * it is unlikely that the QR decomposition would be a bottle neck when small matrices are involved only
                 * one implementation is provided.
                 * &lt;/p&gt;                
                <@author>
                    r Peter Abeles                    
                </@author>
            </javadoc>
            <declaration name="QR" type="DenseMatrix64F" line="53"/>
            <javadoc line="53">
                Where the Q and R matrices are stored.  R is stored in the
                 * upper triangular portion and Q on the lower bit.  Lower columns
                 * are where u is stored.  Q_k = (I - gamma_k*u_k*u_k^T).                
            </javadoc>
            <declaration name="u" type="double" line="61"/>
            <declaration name="numCols" type="int" line="64"/>
            <declaration name="numRows" type="int" line="65"/>
            <declaration name="minLength" type="int" line="66"/>
            <declaration name="dataQR" type="double" line="68"/>
            <declaration name="gammas" type="double" line="71"/>
            <declaration name="gamma" type="double" line="73"/>
            <declaration name="tau" type="double" line="74"/>
            <declaration name="error" type="boolean" line="77"/>
            <method name="setExpectedMaxSize" type="void" line="79">
                <declaration name="maxLength" type="int" line="85"/>
                <scope line="87"/>
                <scope line="92"/>
                <scope line="98"/>
                <scope line="103"/>
            </method>
            <javadoc line="108">
                Returns a single matrix which contains the combined values of Q and R.  This
                 * is possible since Q is symmetric and R is upper triangular.                
                <@return>
                    n The combined Q R matrix.                    
                </@return>
            </javadoc>
            <method name="getQR" type="DenseMatrix64F" line="114"/>
            <javadoc line="118">
                Computes the Q matrix from the imformation stored in the QR matrix.  This
                 * operation requires about 4(m&lt;sup&gt;2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.                
                <@param>
                    m Q The orthogonal Q matrix.                    
                </@param>
            </javadoc>
            <method name="getQ" type="DenseMatrix64F" line="125">
                <scope line="126">
                    <scope line="127"/>
                    <scope line="129">
                        <scope line="130"/>
                        <scope line="132"/>
                    </scope>
                </scope>
                <scope line="136">
                    <scope line="137"/>
                    <scope line="139">
                        <scope line="140"/>
                        <scope line="142"/>
                    </scope>
                </scope>
                <scope line="148">
                    <scope line="150"/>
                </scope>
            </method>
            <javadoc line="159">
                Returns an upper triangular matrix which is the R in the QR decomposition.                
                <@param>
                    m R An upper triangular matrix.                    
                </@param>
                <@param>
                    m compact                    
                </@param>
            </javadoc>
            <method name="getR" type="DenseMatrix64F" line="166">
                <scope line="167">
                    <scope line="168"/>
                </scope>
                <scope line="172">
                    <scope line="173"/>
                    <scope line="176"/>
                    <scope line="181">
                        <declaration name="min" type="int" line="182"/>
                        <scope line="183"/>
                    </scope>
                </scope>
                <scope line="189">
                    <scope line="190">
                        <declaration name="val" type="double" line="191"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="199">
                &lt;p&gt;
                 * In order to decompose the matrix &apos;A&apos; it must have full rank.  &apos;A&apos; is a &apos;m&apos; by &apos;n&apos; matrix.
                 * It requires about 2n*m&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * The matrix provided here can be of different
                 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
                 * to it.
                 * &lt;/p&gt;                
            </javadoc>
            <method name="decompose" type="boolean" line="212">
                <scope line="215"/>
            </method>
            <method name="inputModified" type="boolean" line="224"/>
            <javadoc line="228">
                &lt;p&gt;
                 * Computes the householder vector &quot;u&quot; for the first column of submatrix j.  Note this is
                 * a specialized householder for this problem.  There is some protection against
                 * overflow and underflow.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * This function finds the values of &apos;u&apos; and &apos;&amp;gamma;&apos;.
                 * &lt;/p&gt;                
                <@param>
                    m j Which submatrix to work off of.                    
                </@param>
            </javadoc>
            <method name="householder" type="void" line="244">
                <comment line="245">
                    find the element with the largest absolute value in the column and make a copy                    
                </comment>
                <declaration name="index" type="int" line="246"/>
                <declaration name="max" type="double" line="247"/>
                <scope line="248">
                    <declaration name="d" type="double" line="250"/>
                    <scope line="254"/>
                </scope>
                <scope line="260"/>
                <scope line="263">
                    <scope line="267">
                        <declaration name="d" type="double" line="269"/>
                    </scope>
                    <declaration name="u_0" type="double" line="277"/>
                    <scope line="279"/>
                </scope>
            </method>
            <javadoc line="289">
                &lt;p&gt;
                 * Takes the results from the householder computation and updates the &apos;A&apos; matrix.&lt;br&gt;
                 * &lt;br&gt;
                 * A = (I - &amp;gamma;*u*u&lt;sup&gt;T&lt;/sup&gt;)A
                 * &lt;/p&gt;                
                <@param>
                    m w The submatrix.                    
                </@param>
            </javadoc>
            <method name="updateA" type="void" line="299">
                <comment line="300">
                    much of the code below is equivalent to the rank1Update function                    
                </comment>
                <comment line="300">
                    however, since &amp;tau; has already been computed there is no need to                    
                </comment>
                <comment line="300">
                    recompute it, saving a few multiplication operations                    
                </comment>
                <comment line="300">
                    for( int i = w+1; i &lt; numCols; i++ ) {                    
                </comment>
                <comment line="300">
                    double val = 0;                    
                </comment>
                <comment line="300">
                                        
                </comment>
                <comment line="300">
                    for( int k = w; k &lt; numRows; k++ ) {                    
                </comment>
                <comment line="300">
                    val += u[k]*dataQR[k*numCols +i];                    
                </comment>
                <comment line="300">
                    }                    
                </comment>
                <comment line="300">
                    v[i] = gamma*val;                    
                </comment>
                <comment line="300">
                    }                    
                </comment>
                <comment line="300">
                    This is functionally the same as the above code but the order has been changed                    
                </comment>
                <comment line="300">
                    to avoid jumping the cpu cache                    
                </comment>
                <comment line="300">
                    end of reordered code                    
                </comment>
                <comment line="300">
                    save the Q matrix in the lower portion of QR                    
                </comment>
                <scope line="314"/>
                <scope line="318">
                    <declaration name="indexQR" type="int" line="319"/>
                    <scope line="320"/>
                </scope>
                <scope line="326"/>
                <scope line="332">
                    <declaration name="valU" type="double" line="333"/>
                    <declaration name="indexQR" type="int" line="335"/>
                    <scope line="336"/>
                </scope>
                <scope line="342"/>
                <scope line="347"/>
            </method>
            <javadoc line="352">
                This function performs sanity check on the input for decompose and sets up the QR matrix.                
                <@param>
                    m A                    
                </@param>
            </javadoc>
            <method name="commonSetup" type="void" line="357"/>
            <method name="getGammas" type="double[]" line="363"/>
        </class>
    </source>