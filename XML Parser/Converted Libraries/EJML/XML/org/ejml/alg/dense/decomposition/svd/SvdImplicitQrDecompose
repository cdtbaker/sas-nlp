<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.svd">
        <import package="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecomposition"/>
        <import package="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecompositionRow"/>
        <import package="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecompositionTall"/>
        <import package="org.ejml.alg.dense.decomposition.svd.implicitqr.SvdImplicitQrAlgorithm"/>
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.SingularValueDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="SvdImplicitQrDecompose" line="30">
            <comment line="31">
                dimensions of transposed matrix                
            </comment>
            <comment line="31">
                if true then it can use the special Bidiagonal decomposition                
            </comment>
            <comment line="31">
                If U is not being computed and the input matrix is &apos;tall&apos; then a special bidiagonal decomposition                
            </comment>
            <comment line="31">
                can be used which is faster.                
            </comment>
            <comment line="31">
                compute a compact SVD                
            </comment>
            <comment line="31">
                What is actually computed                
            </comment>
            <comment line="31">
                What the user requested to be computed                
            </comment>
            <comment line="31">
                If the transpose is computed instead then what is actually computed is swapped                
            </comment>
            <comment line="31">
                Should it compute the transpose instead                
            </comment>
            <comment line="31">
                Either a copy of the input matrix or a copy of it transposed                
            </comment>
            <implements interface="SingularValueDecomposition&lt;DenseMatrix64F&gt;"/>
            <javadoc line="30">
                &lt;p&gt;
                 * Computes the Singular value decomposition of a matrix using the implicit QR algorithm
                 * for singular value decomposition.  It works by first by transforming the matrix
                 * to a bidiagonal A=U*B*V&lt;sup&gt;T&lt;/sup&gt; form, then it implicitly computing the eigenvalues of the B&lt;sup&gt;T&lt;/sup&gt;B matrix,
                 * which are the same as the singular values in the original A matrix.
                 * &lt;/p&gt;
                 * &lt;p&gt;
                 * Based off of the description provided in:&lt;br&gt;
                 * &lt;br&gt;
                 * David S. Watkins, &quot;Fundamentals of Matrix Computations,&quot; Second Edition. Page 404-411
                 * &lt;/p&gt;                
                <@author>
                    r Peter Abeles                    
                </@author>
            </javadoc>
            <declaration name="numRows" type="int" line="48"/>
            <declaration name="numCols" type="int" line="49"/>
            <declaration name="numRowsT" type="int" line="52"/>
            <declaration name="numColsT" type="int" line="53"/>
            <declaration name="canUseTallBidiagonal" type="boolean" line="56"/>
            <declaration name="bidiag" type="BidiagonalDecomposition&lt;DenseMatrix64F&gt;" line="60"/>
            <declaration name="qralg" type="SvdImplicitQrAlgorithm" line="61"/>
            <declaration name="diag" type="double" line="63"/>
            <declaration name="off" type="double" line="64"/>
            <declaration name="Ut" type="DenseMatrix64F" line="66"/>
            <declaration name="Vt" type="DenseMatrix64F" line="67"/>
            <declaration name="singularValues" type="double" line="69"/>
            <declaration name="numSingular" type="int" line="70"/>
            <declaration name="compact" type="boolean" line="73"/>
            <declaration name="computeU" type="boolean" line="75"/>
            <declaration name="computeV" type="boolean" line="76"/>
            <declaration name="prefComputeU" type="boolean" line="80"/>
            <declaration name="prefComputeV" type="boolean" line="81"/>
            <declaration name="transposed" type="boolean" line="84"/>
            <declaration name="A_mod" type="DenseMatrix64F" line="87"/>
            <javadoc line="89">
                Configures the class                
                <@param>
                    m compact Compute a compact SVD                    
                </@param>
                <@param>
                    m computeU If true it will compute the U matrix                    
                </@param>
                <@param>
                    m computeV If true it will compute the V matrix                    
                </@param>
                <@param>
                    m canUseTallBidiagonal If true then it can choose to use a tall Bidiagonal decomposition to improve runtime performance.                    
                </@param>
            </javadoc>
            <method name="SvdImplicitQrDecompose" type="constructor" line="99"/>
            <method name="getSingularValues" type="double[]" line="107"/>
            <method name="numberOfSingularValues" type="int" line="112"/>
            <method name="isCompact" type="boolean" line="117"/>
            <method name="getU" type="DenseMatrix64F" line="122">
                <scope line="125"/>
                <scope line="132"/>
            </method>
            <method name="getV" type="DenseMatrix64F" line="145">
                <scope line="148"/>
                <scope line="155"/>
            </method>
            <method name="getW" type="DenseMatrix64F" line="167">
                <declaration name="m" type="int" line="168"/>
                <declaration name="n" type="int" line="169"/>
                <scope line="173"/>
                <scope line="178"/>
            </method>
            <method name="decompose" type="boolean" line="186">
                <comment line="187">
                    make sure all the singular values or positive                    
                </comment>
                <comment line="187">
                    if transposed undo the transposition                    
                </comment>
            </method>
            <method name="inputModified" type="boolean" line="205"/>
            <method name="bidiagonalization" type="boolean" line="209">
                <comment line="210">
                    change the matrix to bidiagonal form                    
                </comment>
                <scope line="211"/>
                <scope line="214"/>
            </method>
            <javadoc line="221">
                If the transpose was computed instead do some additional computations                
            </javadoc>
            <method name="undoTranspose" type="void" line="224">
                <scope line="225">
                    <declaration name="temp" type="DenseMatrix64F" line="226"/>
                </scope>
            </method>
            <javadoc line="232">
                Compute singular values and U and V at the same time                
            </javadoc>
            <method name="computeUWV" type="boolean" line="235">
                <comment line="236">
                    long pointA = System.currentTimeMillis();                    
                </comment>
                <comment line="236">
                    compute U and V matrices                    
                </comment>
                <comment line="236">
                    long pointB = System.currentTimeMillis();                    
                </comment>
                <comment line="236">
                    long pointC = System.currentTimeMillis();                    
                </comment>
                <comment line="236">
                    System.out.println(&quot;  compute UV &quot;+(pointB-pointA)+&quot;  QR = &quot;+(pointC-pointB));                    
                </comment>
                <declaration name="ret" type="boolean" line="258"/>
            </method>
            <method name="setup" type="void" line="266">
                <comment line="267">
                    flag what should be computed and what should not be computed                    
                </comment>
                <comment line="267">
                    if it is a tall matrix and U is not needed then there is faster decomposition algorithm                    
                </comment>
                <scope line="270"/>
                <scope line="275"/>
                <scope line="285"/>
                <scope line="291">
                    <scope line="292"/>
                </scope>
                <scope line="295"/>
            </method>
            <javadoc line="300">
                With the QR algorithm it is possible for the found singular values to be negative.  This
                 * makes them all positive by multiplying it by a diagonal matrix that has                
            </javadoc>
            <method name="makeSingularPositive" type="void" line="304">
                <scope line="308">
                    <declaration name="val" type="double" line="309"/>
                    <scope line="311">
                        <scope line="314">
                            <declaration name="start" type="int" line="317"/>
                            <declaration name="stop" type="int" line="318"/>
                            <scope line="320"/>
                        </scope>
                    </scope>
                    <scope line="324"/>
                </scope>
            </method>
            <method name="numRows" type="int" line="331"/>
            <method name="numCols" type="int" line="336"/>
        </class>
    </source>