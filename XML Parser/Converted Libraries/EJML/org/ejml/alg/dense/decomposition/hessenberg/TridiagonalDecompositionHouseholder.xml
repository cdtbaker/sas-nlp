<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.hessenberg">
  <import name="org.ejml.alg.dense.decomposition.qr.QrHelperFunctions" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="TridiagonalDecompositionHouseholder" startLine="25">
    <implements name="TridiagonalSimilarDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Performs a {@link TridiagonalSimilarDecomposition similar tridiagonal decomposition} on a square symmetric input matrix.
 * Householder vectors perform the similar operation and the symmetry is taken advantage
 * of for good performance.
 * </p>
 * <p>
 * Finds the decomposition of a matrix in the form of:<br>
 * <br>
 * A = O*T*O<sup>T</sup><br>
 * <br>
 * where A is a symmetric m by m matrix, O is an orthogonal matrix, and T is a tridiagonal matrix.
 * </p>
 * <p>
 * This implementation is based off of the algorithm described in:<br>
 * <br>
 * David S. Watkins, "Fundamentals of Matrix Computations," Second Edition.  Page 349-355
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* Only the upper right triangle is used.  The Tridiagonal portion stores
 * the tridiagonal matrix.  The rows store householder vectors.</text>
    </javadoc>
    <declaration type="DenseMatrix64F" name="QT" />
    <declaration type="int" name="N" />
    <declaration type="double" name="w" />
    <declaration type="double" name="gammas" />
    <declaration type="double" name="b" />
    <method type="constructor" name="TridiagonalDecompositionHouseholder" startLine="65" endLine="70" />
    <javadoc>
      <text>* Returns the internal matrix where the decomposed results are stored.</text>
      <return />
    </javadoc>
    <method type="DenseMatrix64F" name="getQT" startLine="76" endLine="78" />
    <method type="void" name="getDiagonal" startLine="81" endLine="89">
      <scope startLine="82" endLine="88">
        <scope startLine="85" endLine="87" />
      </scope>
    </method>
    <javadoc>
      <text>* Extracts the tridiagonal matrix found in the decomposition.</text>
      <param>T If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
      <return>The extracted T matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getT" startLine="98" endLine="122">
      <scope startLine="99" endLine="101" />
      <scope startLine="109" endLine="114">
        <declaration type="double" name="a" />
      </scope>
      <scope startLine="116" endLine="119" />
    </method>
    <javadoc>
      <text>* An orthogonal matrix that has the following property: T = Q<sup>T</sup>AQ</text>
      <param>Q If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
      <return>The extracted Q matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getQ" startLine="131" endLine="160">
      <scope startLine="132" endLine="134" />
      <scope startLine="141" endLine="149">
        <scope startLine="142" endLine="148">
          <scope startLine="144" endLine="146" />
        </scope>
      </scope>
      <scope startLine="149" endLine="157">
        <scope startLine="150" endLine="156">
          <scope startLine="152" endLine="154" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Decomposes the provided symmetric matrix.</text>
      <param>A Symmetric matrix that is going to be decomposed.  Not modified.</param>
    </javadoc>
    <method type="boolean" name="decompose" startLine="168" endLine="176">
      <scope startLine="171" endLine="173" />
    </method>
    <javadoc>
      <text>* Computes and performs the similar a transform for submatrix k.</text>
    </javadoc>
    <method type="void" name="similarTransform" startLine="181" endLine="218">
      <declaration type="double[]" name="t" />
      <declaration type="double" name="max" />
      <declaration type="int" name="rowU" />
      <scope startLine="190" endLine="194">
        <declaration type="double" name="val" />
      </scope>
      <scope startLine="196" endLine="215">
        <declaration type="double" name="tau" />
        <declaration type="double" name="nu" />
        <declaration type="double" name="gamma" />
        <comment>-------- set up the reflector Q_k</comment>
        <comment>write the reflector into the lower left column of the matrix</comment>
        <comment>---------- Specialized householder that takes advantage of the symmetry</comment>
        <comment>since the first element in the householder vector is known to be 1</comment>
        <comment>store the full upper hessenberg</comment>
      </scope>
      <scope startLine="215" endLine="217" />
      <comment>find the largest value in this column</comment>
      <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    </method>
    <javadoc>
      <text>* Performs the householder operations on left and right and side of the matrix.  Q<sup>T</sup>AQ</text>
      <param>row Specifies the submatrix.</param>
      <param>gamma The gamma for the householder operation</param>
    </javadoc>
    <method type="void" name="householderSymmetric" startLine="227" endLine="270">
      <declaration type="int" name="startU" />
      <scope startLine="231" endLine="243">
        <declaration type="double" name="total" />
        <scope startLine="236" endLine="238" />
        <scope startLine="239" endLine="241" />
        <comment>the lower triangle is not written to so it needs to traverse upwards</comment>
        <comment>to get the information.  Reduces the number of matrix writes need</comment>
        <comment>improving large matrix performance</comment>
      </scope>
      <declaration type="double" name="alpha" />
      <scope startLine="247" endLine="249" />
      <scope startLine="253" endLine="255" />
      <scope startLine="257" endLine="268">
        <declaration type="double" name="ww" />
        <declaration type="double" name="uu" />
        <declaration type="int" name="rowA" />
        <scope startLine="263" endLine="267" />
        <comment>only write to the upper portion of the matrix</comment>
        <comment>this reduces the number of cache misses</comment>
      </scope>
      <comment>compute v = -gamma*A*u</comment>
      <comment>alpha = -0.5*gamma*u^T*v</comment>
      <comment>w = v + alpha*u</comment>
      <comment>A = A + w*u^T + u*w^T</comment>
    </method>
    <javadoc>
      <text>* If needed declares and sets up internal data structures.</text>
      <param>A Matrix being decomposed.</param>
    </javadoc>
    <method type="void" name="init" startLine="278" endLine="293">
      <scope startLine="282" endLine="290">
        <scope startLine="285" endLine="289" />
      </scope>
    </method>
    <method type="boolean" name="inputModified" startLine="296" endLine="298" />
    <comment>The size of the matrix</comment>
    <comment>temporary storage</comment>
    <comment>gammas for the householder operations</comment>
    <comment>temporary storage</comment>
  </class>
</source>
