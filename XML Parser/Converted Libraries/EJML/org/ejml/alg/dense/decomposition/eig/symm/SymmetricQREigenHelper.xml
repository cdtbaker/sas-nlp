<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.eig.symm">
  <import name="org.ejml.UtilEjml" />
  <import name="org.ejml.alg.dense.decomposition.eig.EigenvalueSmall" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="java.util.Random" />
  <class name="SymmetricQREigenHelper" startLine="28">
    <javadoc>
      <text>* A helper class for the symmetric matrix implicit QR algorithm for eigenvalue decomposition.
 * Performs most of the basic operations needed to extract eigenvalues and eigenvectors.</text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="Random" name="rand" />
    <declaration type="int" name="steps" />
    <declaration type="int" name="numExceptional" />
    <declaration type="int" name="lastExceptional" />
    <declaration type="EigenvalueSmall" name="eigenSmall" />
    <declaration type="DenseMatrix64F" name="Q" />
    <declaration type="int" name="N" />
    <declaration type="double" name="diag" />
    <declaration type="double" name="off" />
    <declaration type="int" name="x1" />
    <declaration type="int" name="x2" />
    <declaration type="int" name="splits" />
    <declaration type="int" name="numSplits" />
    <declaration type="double" name="bulge" />
    <declaration type="double" name="c" />
    <method type="constructor" name="SymmetricQREigenHelper" startLine="74" endLine="76" />
    <method type="void" name="printMatrix" startLine="78" endLine="89">
      <scope startLine="80" endLine="82" />
      <scope startLine="85" endLine="87" />
    </method>
    <method type="void" name="setQ" startLine="91" endLine="93" />
    <method type="void" name="incrementSteps" startLine="95" endLine="97" />
    <javadoc>
      <text>* Sets up and declares internal data structures.</text>
      <param>diag Diagonal elements from tridiagonal matrix. Modified.</param>
      <param>off Off diagonal elements from tridiagonal matrix. Modified.</param>
      <param>numCols number of columns (and rows) in the matrix.</param>
    </javadoc>
    <method type="void" name="init" startLine="108" endLine="113" />
    <javadoc>
      <text>* Exchanges the internal array of the diagonal elements for the provided one.</text>
    </javadoc>
    <method type="double[]" name="swapDiag" startLine="118" endLine="123">
      <declaration type="double[]" name="ret" />
    </method>
    <javadoc>
      <text>* Exchanges the internal array of the off diagonal elements for the provided one.</text>
    </javadoc>
    <method type="double[]" name="swapOff" startLine="128" endLine="133">
      <declaration type="double[]" name="ret" />
    </method>
    <javadoc>
      <text>* Sets the size of the matrix being decomposed, declares new memory if needed,
 * and sets all helper functions to their initial value.</text>
    </javadoc>
    <method type="void" name="reset" startLine="139" endLine="157">
      <scope startLine="145" endLine="147" />
    </method>
    <method type="double[]" name="copyDiag" startLine="159" endLine="167">
      <scope startLine="160" endLine="162" />
    </method>
    <method type="double[]" name="copyOff" startLine="169" endLine="177">
      <scope startLine="170" endLine="172" />
    </method>
    <method type="double[]" name="copyEigenvalues" startLine="179" endLine="187">
      <scope startLine="180" endLine="182" />
    </method>
    <javadoc>
      <text>* Sets which submatrix is being processed.</text>
      <param>x1 Lower bound, inclusive.</param>
      <param>x2 Upper bound, inclusive.</param>
    </javadoc>
    <method type="void" name="setSubmatrix" startLine="194" endLine="197" />
    <javadoc>
      <text>* Checks to see if the specified off diagonal element is zero using a relative metric.</text>
    </javadoc>
    <method type="boolean" name="isZero" startLine="202" endLine="206">
      <declaration type="double" name="bottom" />
    </method>
    <method type="void" name="performImplicitSingleStep" startLine="209" endLine="222">
      <scope startLine="210" endLine="212" />
      <scope startLine="212" endLine="221">
        <scope startLine="215" endLine="218" />
      </scope>
    </method>
    <method type="void" name="updateQ" startLine="225" endLine="242">
      <declaration type="int" name="rowA" />
      <declaration type="int" name="rowB" />
      <declaration type="int" name="endA" />
      <scope startLine="236" endLine="241">
        <declaration type="double" name="a" />
        <declaration type="double" name="b" />
      </scope>
      <comment>for( int i = 0; i < N; i++ ) {</comment>
      <comment>double a = Q.data[rowA+i];</comment>
      <comment>double b = Q.data[rowB+i];</comment>
      <comment>Q.data[rowA+i] = c*a + s*b;</comment>
      <comment>Q.data[rowB+i] = -s*a + c*b;</comment>
      <comment>}</comment>
    </method>
    <javadoc>
      <text>* Performs a similar transform on A-pI</text>
    </javadoc>
    <method type="void" name="createBulge" startLine="247" endLine="273">
      <declaration type="double" name="a11" />
      <declaration type="double" name="a22" />
      <declaration type="double" name="a12" />
      <declaration type="double" name="a23" />
      <scope startLine="253" endLine="260" />
      <scope startLine="260" endLine="262" />
      <comment>multiply the rotator on the top left.</comment>
    </method>
    <method type="void" name="createBulge2by2" startLine="275" endLine="298">
      <declaration type="double" name="a11" />
      <declaration type="double" name="a22" />
      <declaration type="double" name="a12" />
      <scope startLine="280" endLine="287" />
      <scope startLine="287" endLine="289" />
      <comment>multiply the rotator on the top left.</comment>
    </method>
    <javadoc>
      <text>* Computes the rotation and stores it in (c,s)</text>
    </javadoc>
    <method type="void" name="computeRotation" startLine="303" endLine="331">
      <scope startLine="308" endLine="319">
        <declaration type="double" name="k" />
        <declaration type="double" name="bottom" />
        <declaration type="double" name="bottom_sq" />
      </scope>
      <scope startLine="319" endLine="330">
        <declaration type="double" name="t" />
        <declaration type="double" name="bottom" />
        <declaration type="double" name="bottom_sq" />
      </scope>
      <comment>double alpha = Math.sqrt(run*run + rise*rise);</comment>
      <comment>c = run/alpha;</comment>
      <comment>s = rise/alpha;</comment>
    </method>
    <method type="void" name="removeBulge" startLine="333" endLine="352">
      <declaration type="double" name="a22" />
      <declaration type="double" name="a33" />
      <declaration type="double" name="a12" />
      <declaration type="double" name="a23" />
      <declaration type="double" name="a34" />
      <comment>multiply the rotator on the top left.</comment>
    </method>
    <javadoc>
      <text>* Rotator to remove the bulge</text>
    </javadoc>
    <method type="void" name="removeBulgeEnd" startLine="357" endLine="373">
      <declaration type="double" name="a22" />
      <declaration type="double" name="a12" />
      <declaration type="double" name="a23" />
      <declaration type="double" name="a33" />
      <comment>multiply the rotator on the top left.</comment>
    </method>
    <javadoc>
      <text>* Computes the eigenvalue of the 2 by 2 matrix.</text>
    </javadoc>
    <method type="void" name="eigenvalue2by2" startLine="378" endLine="409">
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="c" />
      <declaration type="double" name="absA" />
      <declaration type="double" name="absB" />
      <declaration type="double" name="absC" />
      <declaration type="double" name="scale" />
      <scope startLine="393" endLine="398" />
      <comment>normalize to reduce overflow</comment>
      <comment>see if it is a pathological case.  the diagonal must already be zero</comment>
      <comment>and the eigenvalues are all zero.  so just return</comment>
    </method>
    <javadoc>
      <text>* Perform a shift in a random direction that is of the same magnitude as the elements in the matrix.</text>
    </javadoc>
    <method type="void" name="exceptionalShift" startLine="414" endLine="426">
      <declaration type="double" name="mag" />
      <declaration type="double" name="theta" />
      <comment>rotating by a random angle handles at least one case using a random lambda</comment>
      <comment>does not handle well:</comment>
      <comment>- two identical eigenvalues are next to each other and a very small diagonal element</comment>
    </method>
    <javadoc>
      <text>* Tells it to process the submatrix at the next split.  Should be called after the
 * current submatrix has been processed.</text>
    </javadoc>
    <method type="boolean" name="nextSplit" startLine="432" endLine="442" />
    <method type="double" name="computeShift" startLine="444" endLine="449" />
    <method type="double" name="computeWilkinsonShift" startLine="451" endLine="484">
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="c" />
      <declaration type="double" name="absA" />
      <declaration type="double" name="absB" />
      <declaration type="double" name="absC" />
      <declaration type="double" name="scale" />
      <scope startLine="464" endLine="466" />
      <declaration type="double" name="diff0" />
      <declaration type="double" name="diff1" />
      <comment>normalize to reduce overflow</comment>
      <comment>TODO see 385</comment>
      <comment>return the eigenvalue closest to c</comment>
    </method>
    <method type="int" name="getMatrixSize" startLine="486" endLine="488" />
    <method type="void" name="resetSteps" startLine="490" endLine="493" />
    <comment>used in exceptional shifts</comment>
    <comment>how many steps has it taken</comment>
    <comment>how many exception shifts has it performed</comment>
    <comment>the step number of the last exception shift</comment>
    <comment>used to compute eigenvalues directly</comment>
    <comment>orthogonal matrix used in similar transform.  optional</comment>
    <comment>size of the matrix being processed</comment>
    <comment>diagonal elements in the matrix</comment>
    <comment>the off diagonal elements</comment>
    <comment>which submatrix is being processed</comment>
    <comment>where splits are performed</comment>
    <comment>current value of the bulge</comment>
    <comment>local helper functions</comment>
  </class>
</source>
