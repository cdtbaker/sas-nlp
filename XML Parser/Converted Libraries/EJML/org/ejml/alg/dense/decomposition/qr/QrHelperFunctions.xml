<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.qr">
  <import name="org.ejml.data.DenseMatrix64F" />
  <class name="QrHelperFunctions" startLine="24">
    <javadoc>
      <text>* <p>
 * Contains different functions that are useful for computing the QR decomposition of a matrix.
 * </p>
 * <p>
 * Two different families of functions are provided for help in computing reflectors.  Internally
 * both of these functions switch between normalization by division or multiplication.  Multiplication
 * is most often significantly faster than division (2 or 3 times) but produces less accurate results
 * on very small numbers.  It checks to see if round off error is significant and decides which
 * one it should do.
 * </p>
 * <p>
 * Tests were done using the stability benchmark in jmatbench and there doesn't seem to be
 * any advantage to always dividing by the max instead of checking and deciding.  The most
 * noticeable difference between the two methods is with very small numbers.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <method type="double" name="findMax" startLine="47" endLine="60">
      <declaration type="double" name="max" />
      <declaration type="int" name="index" />
      <declaration type="int" name="stopIndex" />
      <scope startLine="52" endLine="57">
        <declaration type="double" name="val" />
      </scope>
    </method>
    <method type="void" name="divideElements" startLine="63" endLine="75">
      <scope startLine="67" endLine="69" />
      <comment>double div_u = 1.0/u_0;</comment>
      <comment />
      <comment>if( Double.isInfinite(div_u)) {</comment>
      <comment>} else {</comment>
      <comment>for( int i = j; i < numRows; i++ ) {</comment>
      <comment>u[i] *= div_u;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <method type="void" name="divideElements" startLine="77" endLine="89">
      <scope startLine="81" endLine="83" />
      <comment>double div_u = 1.0/u_0;</comment>
      <comment />
      <comment>if( Double.isInfinite(div_u)) {</comment>
      <comment>} else {</comment>
      <comment>for( int i = j; i < numRows; i++ ) {</comment>
      <comment>u[i+startU] *= div_u;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <method type="void" name="divideElements_Brow" startLine="93" endLine="105">
      <scope startLine="97" endLine="99" />
      <comment>double div_u = 1.0/u_0;</comment>
      <comment />
      <comment>if( Double.isInfinite(div_u)) {</comment>
      <comment>} else {</comment>
      <comment>for( int i = j; i < numRows; i++ ) {</comment>
      <comment>u[i] = b[i+startB] *= div_u;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <method type="void" name="divideElements_Bcol" startLine="110" endLine="124">
      <declaration type="int" name="indexB" />
      <scope startLine="115" endLine="117" />
      <comment>double div_u = 1.0/u_0;</comment>
      <comment />
      <comment>if( Double.isInfinite(div_u)) {</comment>
      <comment>} else {</comment>
      <comment>int indexB = j*numCols+startB;</comment>
      <comment>for( int i = j; i < numRows; i++ , indexB += numCols ) {</comment>
      <comment>b[indexB] = u[i] *= div_u;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <method type="double" name="computeTauAndDivide" startLine="126" endLine="150">
      <declaration type="double" name="tau" />
      <scope startLine="133" endLine="136">
        <declaration type="double" name="d" />
      </scope>
      <comment>compute the norm2 of the matrix, with each element</comment>
      <comment>normalized by the max value to avoid overflow problems</comment>
      <comment>double div_max = 1.0/max;</comment>
      <comment>if( Double.isInfinite(div_max)) {</comment>
      <comment>more accurate</comment>
      <comment>} else {</comment>
      <comment>faster</comment>
      <comment>for( int i = j; i < numRows; i++ ) {</comment>
      <comment>double d = u[startU+i] *= div_max;</comment>
      <comment>tau += d*d;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <javadoc>
      <text>* Normalizes elements in 'u' by dividing by max and computes the norm2 of the normalized
 * array u.  Adjust the sign of the returned value depending on the size of the first
 * element in 'u'. Normalization is done to avoid overflow.
 * <pre>
 * for i=j:numRows
 * u[i] = u[i] / max
 * tau = tau + u[i]*u[i]
 * end
 * tau = sqrt(tau)
 * if( u[j] < 0 )
 * tau = -tau;
 * </pre></text>
      <param>j Element in 'u' that it starts at.</param>
      <param>numRows Element in 'u' that it stops at.</param>
      <param>u Array</param>
      <param>max Max value in 'u' that is used to normalize it.</param>
      <return>norm2 of 'u'</return>
    </javadoc>
    <method type="double" name="computeTauAndDivide" startLine="174" endLine="194">
      <declaration type="double" name="tau" />
      <scope startLine="178" endLine="181">
        <declaration type="double" name="d" />
      </scope>
      <comment>double div_max = 1.0/max;</comment>
      <comment>if( Double.isInfinite(div_max)) {</comment>
      <comment>} else {</comment>
      <comment>for( int i = j; i < numRows; i++ ) {</comment>
      <comment>double d = u[i] *= div_max;</comment>
      <comment>tau += d*d;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Performs a rank-1 update operation on the submatrix specified by w with the multiply on the right.<br>
 * <br>
 * A = (I - &gamma;*u*u<sup>T</sup>)*A<br>
 * </p>
 * <p>
 * The order that matrix multiplies are performed has been carefully selected
 * to minimize the number of operations.
 * </p>
 * <p>
 * Before this can become a truly generic operation the submatrix specification needs
 * to be made more generic.
 * </p></text>
    </javadoc>
    <method type="void" name="rank1UpdateMultR" startLine="216" endLine="252">
      <scope startLine="227" endLine="229" />
      <scope startLine="231" endLine="237">
        <declaration type="int" name="indexA" />
        <declaration type="double" name="valU" />
        <scope startLine="234" endLine="236" />
      </scope>
      <scope startLine="238" endLine="240" />
      <scope startLine="244" endLine="251">
        <declaration type="double" name="valU" />
        <declaration type="int" name="indexA" />
        <scope startLine="248" endLine="250" />
      </scope>
      <comment>for( int i = colA0; i < A.numCols; i++ ) {</comment>
      <comment>double val = 0;</comment>
      <comment />
      <comment>for( int k = w0; k < w1; k++ ) {</comment>
      <comment>val += u[k]*A.data[k*A.numCols +i];</comment>
      <comment>}</comment>
      <comment>_temp[i] = gamma*val;</comment>
      <comment>}</comment>
      <comment>reordered to reduce cpu cache issues</comment>
      <comment>end of reorder</comment>
    </method>
    <method type="void" name="rank1UpdateMultR" startLine="260" endLine="296">
      <scope startLine="271" endLine="273" />
      <scope startLine="275" endLine="281">
        <declaration type="int" name="indexA" />
        <declaration type="double" name="valU" />
        <scope startLine="278" endLine="280" />
      </scope>
      <scope startLine="282" endLine="284" />
      <scope startLine="288" endLine="295">
        <declaration type="double" name="valU" />
        <declaration type="int" name="indexA" />
        <scope startLine="292" endLine="294" />
      </scope>
      <comment>for( int i = colA0; i < A.numCols; i++ ) {</comment>
      <comment>double val = 0;</comment>
      <comment />
      <comment>for( int k = w0; k < w1; k++ ) {</comment>
      <comment>val += u[k+offsetU]*A.data[k*A.numCols +i];</comment>
      <comment>}</comment>
      <comment>_temp[i] = gamma*val;</comment>
      <comment>}</comment>
      <comment>reordered to reduce cpu cache issues</comment>
      <comment>end of reorder</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Performs a rank-1 update operation on the submatrix specified by w with the multiply on the left.<br>
 * <br>
 * A = A(I - &gamma;*u*u<sup>T</sup>)<br>
 * </p>
 * <p>
 * The order that matrix multiplies are performed has been carefully selected
 * to minimize the number of operations.
 * </p>
 * <p>
 * Before this can become a truly generic operation the submatrix specification needs
 * to be made more generic.
 * </p></text>
    </javadoc>
    <method type="void" name="rank1UpdateMultL" startLine="318" endLine="333">
      <scope startLine="319" endLine="332">
        <declaration type="int" name="startIndex" />
        <declaration type="double" name="sum" />
        <declaration type="int" name="rowIndex" />
        <scope startLine="323" endLine="325" />
        <scope startLine="329" endLine="331" />
      </scope>
    </method>
  </class>
</source>
