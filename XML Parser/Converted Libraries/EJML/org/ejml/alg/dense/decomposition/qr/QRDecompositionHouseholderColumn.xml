<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.qr">
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.QRDecomposition" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="QRDecompositionHouseholderColumn" startLine="26">
    <implements name="QRDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Householder QR decomposition is rich in operations along the columns of the matrix.  This can be
 * taken advantage of by solving for the Q matrix in a column major format to reduce the number
 * of CPU cache misses and the number of copies that are performed.
 * </p></text>
      <see>org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholder</see>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* Where the Q and R matrices are stored.  R is stored in the
 * upper triangular portion and Q on the lower bit.  Lower columns
 * are where u is stored.  Q_k = (I - gamma_k*u_k*u_k^T).</text>
    </javadoc>
    <declaration type="double" name="dataQR" />
    <declaration type="double" name="v" />
    <declaration type="int" name="numCols" />
    <declaration type="int" name="numRows" />
    <declaration type="int" name="minLength" />
    <declaration type="double" name="gammas" />
    <declaration type="double" name="gamma" />
    <declaration type="double" name="tau" />
    <declaration type="boolean" name="error" />
    <method type="void" name="setExpectedMaxSize" startLine="63" endLine="81">
      <declaration type="int" name="maxLength" />
      <scope startLine="69" endLine="73" />
      <scope startLine="75" endLine="77" />
      <scope startLine="78" endLine="80" />
    </method>
    <javadoc>
      <text>* Returns the combined QR matrix in a 2D array format that is column major.</text>
      <return>The QR matrix in a 2D matrix column major format. [ column ][ row ]</return>
    </javadoc>
    <method type="double[][]" name="getQR" startLine="88" endLine="90" />
    <javadoc>
      <text>* Computes the Q matrix from the imformation stored in the QR matrix.  This
 * operation requires about 4(m<sup>2</sup>n-mn<sup>2</sup>+n<sup>3</sup>/3) flops.</text>
      <param>Q The orthogonal Q matrix.</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getQ" startLine="99" endLine="132">
      <scope startLine="100" endLine="110">
        <scope startLine="101" endLine="103" />
        <scope startLine="103" endLine="109">
          <scope startLine="104" endLine="106" />
          <scope startLine="106" endLine="108" />
        </scope>
      </scope>
      <scope startLine="110" endLine="120">
        <scope startLine="111" endLine="113" />
        <scope startLine="113" endLine="119">
          <scope startLine="114" endLine="116" />
          <scope startLine="116" endLine="118" />
        </scope>
      </scope>
      <scope startLine="122" endLine="129">
        <declaration type="double[]" name="u" />
        <declaration type="double" name="vv" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns an upper triangular matrix which is the R in the QR decomposition.</text>
      <param>R An upper triangular matrix.</param>
      <param>compact</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getR" startLine="141" endLine="175">
      <scope startLine="142" endLine="147">
        <scope startLine="143" endLine="145" />
      </scope>
      <scope startLine="147" endLine="163">
        <scope startLine="148" endLine="152" />
        <scope startLine="152" endLine="155" />
        <scope startLine="157" endLine="162">
          <declaration type="int" name="min" />
          <scope startLine="159" endLine="161" />
        </scope>
      </scope>
      <scope startLine="165" endLine="172">
        <declaration type="double[]" name="colR" />
        <declaration type="int" name="l" />
        <scope startLine="168" endLine="171">
          <declaration type="double" name="val" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * To decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m<sup>2</sup>-2m<sup>2</sup>/3 flops.
 * </p>
 * <p>
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * </p></text>
    </javadoc>
    <method type="boolean" name="decompose" startLine="190" endLine="203">
      <scope startLine="197" endLine="200" />
    </method>
    <method type="boolean" name="inputModified" startLine="206" endLine="208" />
    <javadoc>
      <text>* Converts the standard row-major matrix into a column-major vector
 * that is advantageous for this problem.</text>
      <param>A original matrix that is to be decomposed.</param>
    </javadoc>
    <method type="void" name="convertToColumnMajor" startLine="216" endLine="223">
      <scope startLine="217" endLine="222">
        <declaration type="double[]" name="colQ" />
        <scope startLine="219" endLine="221" />
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the householder vector "u" for the first column of submatrix j.  Note this is
 * a specialized householder for this problem.  There is some protection against
 * overfloaw and underflow.
 * </p>
 * <p>
 * Q = I - &gamma;uu<sup>T</sup>
 * </p>
 * <p>
 * This function finds the values of 'u' and '&gamma;'.
 * </p></text>
      <param>j Which submatrix to work off of.</param>
    </javadoc>
    <method type="void" name="householder" startLine="241" endLine="266">
      <declaration type="double[]" name="u" />
      <declaration type="double" name="max" />
      <scope startLine="248" endLine="251" />
      <scope startLine="251" endLine="263">
        <declaration type="double" name="u_0" />
        <comment>computes tau and normalizes u by max</comment>
        <comment>divide u by u_0</comment>
      </scope>
      <comment>find the largest value in this column</comment>
      <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Takes the results from the householder computation and updates the 'A' matrix.<br>
 * <br>
 * A = (I - &gamma;*u*u<sup>T</sup>)A
 * </p></text>
      <param>w The submatrix.</param>
    </javadoc>
    <method type="void" name="updateA" startLine="278" endLine="296">
      <declaration type="double[]" name="u" />
      <scope startLine="281" endLine="295">
        <declaration type="double[]" name="colQ" />
        <declaration type="double" name="val" />
        <scope startLine="286" endLine="288" />
        <scope startLine="292" endLine="294" />
      </scope>
    </method>
    <method type="double[]" name="getGammas" startLine="298" endLine="300" />
    <comment>[ column][ row ]</comment>
    <comment>used internally to store temporary data</comment>
    <comment>dimension of the decomposed matrices</comment>
    <comment>this is 'n'</comment>
    <comment>this is 'm'</comment>
    <comment>the computed gamma for Q_k matrix</comment>
    <comment>local variables</comment>
    <comment>did it encounter an error?</comment>
  </class>
</source>
