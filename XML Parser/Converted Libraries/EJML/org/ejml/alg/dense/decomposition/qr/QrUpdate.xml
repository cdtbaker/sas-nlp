<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.qr">
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="QrUpdate" startLine="25">
    <javadoc>
      <text>* <p>
 * The effects of adding and removing rows from the A matrix in a QR decomposition can
 * be computed much faster than simply recomputing the whole decomposition.  There are many real
 * world situations where this is useful.  For example, when computing a rolling solution to
 * the most recent N measurements.
 * </p>
 * <p>
 * Definitions: A &isin; &real; <sup>m &times; n</sup>, m &ge; n, rank(A) = n and that A = QR, where
 * Q &isin; &real; <sup>m &times; m</sup> is orthogonal, and R &isin; &real; <sup>m &times; n</sup> is
 * upper triangular.
 * </p>
 * <p>
 * ** IMPORTANT USAGE NOTE ** If auto grow is set to true then the internal data structures will grow automatically
 * to accommodate the matrices passed in.  When adding elements to the decomposition the matrices must have enough
 * data elements to grow before hand.
 * </p>
 * <p>
 * For more information see David S. Watkins, "Fundamentals of Matrix Computations" 2nd edition, pages 249-259.
 * It is also possible to add and remove columns efficiently, but this is less common and is not supported at
 * this time.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="DenseMatrix64F" name="Q" />
    <declaration type="DenseMatrix64F" name="U_tran" />
    <declaration type="DenseMatrix64F" name="Qm" />
    <declaration type="double" name="r_row" />
    <declaration type="int" name="maxCols" />
    <declaration type="int" name="maxRows" />
    <declaration type="int" name="m" />
    <declaration type="int" name="m_m" />
    <declaration type="boolean" name="autoGrow" />
    <javadoc>
      <text>* Creates an update which can decompose matrices up to the specified size.  Autogrow
 * is set to false.</text>
      <param>maxRows</param>
      <param>maxCols</param>
    </javadoc>
    <method type="constructor" name="QrUpdate" startLine="83" endLine="86" />
    <javadoc>
      <text>* Creates an update which can decompose matrices up to the specified size.  Autogrow
 * is configurable.</text>
      <param>maxRows</param>
      <param>maxCols</param>
      <param>autoGrow</param>
    </javadoc>
    <method type="constructor" name="QrUpdate" startLine="96" endLine="99" />
    <javadoc>
      <text>* Does not predeclare data and it will autogrow.</text>
    </javadoc>
    <method type="constructor" name="QrUpdate" startLine="104" endLine="106" />
    <javadoc>
      <text>* Declares the internal data structures so that it can process matrices up to the specified size.</text>
      <param>maxRows</param>
      <param>maxCols</param>
    </javadoc>
    <method type="void" name="declareInternalData" startLine="114" endLine="122" />
    <javadoc>
      <text>* <p>
 * Adjusts the values of the Q and R matrices to take in account the effects of inserting
 * a row to the 'A' matrix at the specified location.  This operation requires about 6mn + O(n) flops.
 * </p>
 * <p>
 * If Q and/or R does not have enough data elements to grow then an exception is thrown.
 * </p>
 * <p>
 * The adjustment done is by computing a series of planar Givens rotations that make the adjusted R
 * matrix upper triangular again.  This is then used to modify the Q matrix.
 * </p></text>
      <param>Q The Q matrix which is to be modified, must be big enough to grow.  Must be n by n..  Is modified.</param>
      <param>R The R matrix which is to be modified, must be big enough to grow.  Must be m by n.  Is modified.</param>
      <param>row The row being inserted.  Not modified.</param>
      <param>rowIndex Which row index it is to be inserted at.</param>
      <param>resizeR Should the number of rows in R be changed?  The additional rows are all zero.</param>
    </javadoc>
    <method type="void" name="addRow" startLine="145" endLine="169">
      <comment>memory management and check precoditions</comment>
      <comment>apply givens rotation to the first two rows of the augmented R matrix</comment>
      <comment>compute new Q matrix</comment>
      <comment>discard the reference since it is no longer needed</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Adjusts the values of the Q and R matrices to take in account the effects of removing
 * a row from the 'A' matrix at the specified location.  This operation requires about 6mn + O(n) flops.
 * </p>
 * <p>
 * The adjustment is done by computing a series of planar Givens rotations that make the removed row in Q
 * equal to [1 0 ... 0].
 * </p></text>
      <param>Q The Q matrix.  Is modified.</param>
      <param>R The R matrix.  Is modified.</param>
      <param>rowIndex Which index of the row that is being removed.</param>
      <param>resizeR should the shape of R be adjusted?</param>
    </javadoc>
    <method type="void" name="deleteRow" startLine="187" endLine="206">
      <scope startLine="189" endLine="191" />
      <comment>discard the reference since it is no longer needed</comment>
    </method>
    <javadoc>
      <text>* Provides the results of a QR decomposition.  These will be modified by adding or removing
 * rows from the original 'A' matrix.</text>
      <param>Q The Q matrix which is to be modified.  Is modified later and reference saved.</param>
      <param>R The R matrix which is to be modified.  Is modified later and reference saved.</param>
    </javadoc>
    <method type="void" name="setQR" startLine="215" endLine="234">
      <scope startLine="216" endLine="218" />
      <scope startLine="226" endLine="233">
        <scope startLine="227" endLine="229" />
        <scope startLine="229" endLine="232" />
      </scope>
    </method>
    <javadoc>
      <text>* Updates the Q matrix to take in account the inserted matrix.</text>
      <param>rowIndex where the matrix has been inserted.</param>
    </javadoc>
    <method type="void" name="updateInsertQ" startLine="241" endLine="268">
      <scope startLine="245" endLine="253">
        <scope startLine="246" endLine="252">
          <declaration type="double" name="sum" />
          <scope startLine="248" endLine="250" />
        </scope>
      </scope>
      <scope startLine="255" endLine="257" />
      <scope startLine="259" endLine="267">
        <scope startLine="260" endLine="266">
          <declaration type="double" name="sum" />
          <scope startLine="262" endLine="264" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Updates the Q matrix to take inaccount the row that was removed by only multiplying e
 * lements that need to be.  There is still some room for improvement here...</text>
      <param>rowIndex</param>
    </javadoc>
    <method type="void" name="updateRemoveQ" startLine="275" endLine="298">
      <scope startLine="279" endLine="287">
        <scope startLine="280" endLine="286">
          <declaration type="double" name="sum" />
          <scope startLine="282" endLine="284" />
        </scope>
      </scope>
      <scope startLine="289" endLine="297">
        <scope startLine="290" endLine="296">
          <declaration type="double" name="sum" />
          <scope startLine="292" endLine="294" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Updates the R matrix to take in account the removed row.</text>
    </javadoc>
    <method type="void" name="updateRemoveR" startLine="303" endLine="313">
      <scope startLine="304" endLine="312">
        <scope startLine="305" endLine="311">
          <declaration type="double" name="sum" />
          <scope startLine="307" endLine="309" />
        </scope>
      </scope>
    </method>
    <method type="void" name="applyFirstGivens" startLine="315" endLine="346">
      <declaration type="double" name="c" />
      <declaration type="double" name="xi" />
      <declaration type="double" name="xj" />
      <declaration type="double" name="r" />
      <scope startLine="321" endLine="326" />
      <scope startLine="326" endLine="329" />
      <scope startLine="332" endLine="338">
        <declaration type="double" name="vali" />
        <declaration type="double" name="valj" />
      </scope>
      <comment>set U to its initial values</comment>
    </method>
    <method type="void" name="applyLaterGivens" startLine="349" endLine="386">
      <scope startLine="350" endLine="385">
        <declaration type="double" name="c" />
        <declaration type="double" name="xi" />
        <declaration type="double" name="xj" />
        <declaration type="double" name="r" />
        <scope startLine="357" endLine="362" />
        <scope startLine="362" endLine="365" />
        <scope startLine="369" endLine="375">
          <declaration type="double" name="vali" />
          <declaration type="double" name="valj" />
        </scope>
        <scope startLine="378" endLine="384">
          <declaration type="double" name="q1" />
          <declaration type="double" name="q2" />
        </scope>
        <comment>first compute the rotation</comment>
        <comment>update R matrix</comment>
        <comment>compute U^T = U^T_(x+1) * U^T_x</comment>
      </scope>
    </method>
    <method type="void" name="computeRemoveGivens" startLine="389" endLine="421">
      <declaration type="double" name="xj" />
      <scope startLine="394" endLine="420">
        <declaration type="double" name="c" />
        <declaration type="double" name="xi" />
        <declaration type="double" name="r" />
        <scope startLine="400" endLine="404" />
        <scope startLine="404" endLine="407" />
        <scope startLine="413" endLine="419">
          <declaration type="double" name="q1" />
          <declaration type="double" name="q2" />
        </scope>
        <comment>first compute the rotation</comment>
        <comment>in the next iteration xj is r</comment>
        <comment>compute U^T = U^T_(x+1) * U^T_x</comment>
      </scope>
    </method>
    <method type="DenseMatrix64F" name="getU_tran" startLine="423" endLine="425" />
    <comment>the decomposition that is being adjusted</comment>
    <comment>product of planar multiplications</comment>
    <comment>using transpose of U reduces cache misses</comment>
    <comment>used to temporarially store data</comment>
    <comment>it can process matrices up to this size</comment>
    <comment>number of rows and columns in the original A matrix that was decomposed</comment>
    <comment>number of rows in the adjusted matrices</comment>
    <comment>should it declare new internal data when what currently exists is too small or throw</comment>
    <comment>and exception.</comment>
  </class>
</source>
