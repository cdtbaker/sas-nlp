<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.bidiagonal">
  <import name="org.ejml.alg.dense.decomposition.qr.QrHelperFunctions" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="BidiagonalDecompositionRow" startLine="25">
    <implements name="BidiagonalDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Performs a {@link org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecomposition} using
 * householder reflectors.  This is efficient on wide or square matrices.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="DenseMatrix64F" name="UBV" />
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
    <declaration type="int" name="min" />
    <declaration type="double" name="gammasU" />
    <declaration type="double" name="gammasV" />
    <declaration type="double" name="b" />
    <declaration type="double" name="u" />
    <javadoc>
      <text>* Creates a decompose that defines the specified amount of memory.</text>
      <param>numElements number of elements in the matrix.</param>
    </javadoc>
    <method type="constructor" name="BidiagonalDecompositionRow" startLine="58" endLine="65" />
    <method type="constructor" name="BidiagonalDecompositionRow" startLine="67" endLine="69" />
    <javadoc>
      <text>* Computes the decomposition of the provided matrix.  If no errors are detected then true is returned,
 * false otherwise.</text>
      <param>A  The matrix that is being decomposed.  Not modified.</param>
      <return>If it detects any errors or not.</return>
    </javadoc>
    <method type="boolean" name="decompose" startLine="80" endLine="83" />
    <javadoc>
      <text>* Sets up internal data structures and creates a copy of the input matrix.</text>
      <param>A The input matrix.  Not modified.</param>
    </javadoc>
    <method type="void" name="init" startLine="90" endLine="109">
      <declaration type="int" name="max" />
      <scope startLine="99" endLine="102" />
      <scope startLine="103" endLine="105" />
      <scope startLine="106" endLine="108" />
    </method>
    <javadoc>
      <text>* The raw UBV matrix that is stored internally.</text>
      <return>UBV matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getUBV" startLine="116" endLine="118" />
    <method type="void" name="getDiagonal" startLine="121" endLine="127">
      <scope startLine="123" endLine="126" />
    </method>
    <javadoc>
      <text>* Returns the bidiagonal matrix.</text>
      <param>B If not null the results are stored here, if null a new matrix is created.</param>
      <return>The bidiagonal matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getB" startLine="136" endLine="150">
      <scope startLine="142" endLine="145" />
      <comment>System.arraycopy(UBV.data, 0, B.data, 0, UBV.getNumElements());</comment>
    </method>
    <method type="DenseMatrix64F" name="handleB" startLine="153" endLine="172">
      <declaration type="int" name="w" />
      <scope startLine="156" endLine="163">
        <scope startLine="157" endLine="159" />
        <scope startLine="159" endLine="162" />
      </scope>
      <scope startLine="163" endLine="170">
        <scope startLine="164" endLine="166" />
        <scope startLine="166" endLine="169" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the orthogonal U matrix.</text>
      <param>U If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
      <return>The extracted Q matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getU" startLine="181" endLine="199">
      <scope startLine="187" endLine="196">
        <scope startLine="189" endLine="191" />
      </scope>
    </method>
    <method type="DenseMatrix64F" name="handleU" startLine="203" endLine="225">
      <scope startLine="204" endLine="217">
        <scope startLine="205" endLine="211">
          <scope startLine="208" endLine="210" />
        </scope>
        <scope startLine="211" endLine="216" />
      </scope>
      <scope startLine="217" endLine="222" />
    </method>
    <javadoc>
      <text>* Returns the orthogonal V matrix.</text>
      <param>V If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
      <return>The extracted Q matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getV" startLine="234" endLine="253">
      <scope startLine="241" endLine="250">
        <scope startLine="243" endLine="245" />
      </scope>
      <comment>UBV.print();</comment>
      <comment>todo the very first multiplication can be avoided by setting to the rank1update output</comment>
    </method>
    <method type="DenseMatrix64F" name="handleV" startLine="256" endLine="279">
      <declaration type="int" name="w" />
      <scope startLine="259" endLine="271">
        <scope startLine="260" endLine="265">
          <scope startLine="261" endLine="263" />
        </scope>
        <scope startLine="265" endLine="270">
          <scope startLine="266" endLine="268" />
        </scope>
      </scope>
      <scope startLine="271" endLine="276">
        <scope startLine="272" endLine="274" />
      </scope>
    </method>
    <javadoc>
      <text>* Internal function for computing the decomposition.</text>
    </javadoc>
    <method type="boolean" name="_decompose" startLine="284" endLine="296">
      <scope startLine="285" endLine="293">
        <comment>UBV.print();</comment>
        <comment>System.out.println("--- after U");</comment>
        <comment>UBV.print();</comment>
        <comment>System.out.println("--- after V");</comment>
        <comment>UBV.print();</comment>
      </scope>
    </method>
    <method type="void" name="computeU" startLine="298" endLine="334">
      <declaration type="double[]" name="b" />
      <declaration type="double" name="max" />
      <scope startLine="305" endLine="312">
        <declaration type="double" name="val" />
        <comment>copy the householder vector to vector outside of the matrix to reduce caching issues</comment>
        <comment>big improvement on larger matrices and a relatively small performance hit on small matrices.</comment>
      </scope>
      <scope startLine="314" endLine="331">
        <declaration type="double" name="tau" />
        <declaration type="double" name="nu" />
        <declaration type="double" name="gamma" />
        <comment>-------- set up the reflector Q_k</comment>
        <comment>write the reflector into the lower left column of the matrix</comment>
        <comment>while dividing u by nu</comment>
        <comment>---------- multiply on the left by Q_k</comment>
      </scope>
      <scope startLine="331" endLine="333" />
      <comment>find the largest value in this column</comment>
      <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    </method>
    <method type="void" name="computeV" startLine="336" endLine="368">
      <declaration type="double[]" name="b" />
      <declaration type="int" name="row" />
      <declaration type="double" name="max" />
      <scope startLine="345" endLine="365">
        <declaration type="double" name="tau" />
        <declaration type="double" name="nu" />
        <declaration type="double" name="gamma" />
        <comment>-------- set up the reflector Q_k</comment>
        <comment>write the reflector into the lower left column of the matrix</comment>
        <comment>writing to u could be avoided by working directly with b.</comment>
        <comment>requires writing a custom rank1Update function</comment>
        <comment>---------- multiply on the left by Q_k</comment>
      </scope>
      <scope startLine="365" endLine="367" />
      <comment>find the largest value in this column</comment>
      <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    </method>
    <javadoc>
      <text>* Returns gammas from the householder operations for the U matrix.</text>
      <return>gammas for householder operations</return>
    </javadoc>
    <method type="double[]" name="getGammasU" startLine="375" endLine="377" />
    <javadoc>
      <text>* Returns gammas from the householder operations for the V matrix.</text>
      <return>gammas for householder operations</return>
    </javadoc>
    <method type="double[]" name="getGammasV" startLine="384" endLine="386" />
    <method type="boolean" name="inputModified" startLine="389" endLine="391" />
    <comment>A combined matrix that stores te upper Hessenberg matrix and the orthogonal matrix.</comment>
    <comment>number of rows</comment>
    <comment>number of columns</comment>
    <comment>the smaller of m or n</comment>
    <comment>the first element in the orthogonal vectors</comment>
    <comment>temporary storage</comment>
  </class>
</source>
