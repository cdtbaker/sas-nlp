<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.qr">
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.QRPDecomposition" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="QRColPivDecompositionHouseholderColumn" extends="QRDecompositionHouseholderColumn" startLine="25">
    <implements name="QRPDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Performs QR decomposition with column pivoting.  To prevent overflow/underflow the whole matrix
 * is normalized by the max value, but columns are not normalized individually any more. To enable
 * code reuse it extends {@link QRDecompositionHouseholderColumn} and functions from that class
 * are used whenever possible.  Columns are transposed into single arrays, which allow for
 * fast pivots.
 * </p>
 * <p>
 * Decomposition: A*P = Q*R
 * </p>
 * <p>
 * Based off the description in "Fundamentals of Matrix Computations", 2nd by David S. Watkins.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="int" name="pivots" />
    <declaration type="double" name="normsCol" />
    <declaration type="double" name="singularThreshold" />
    <declaration type="int" name="rank" />
    <javadoc>
      <text>* Configure parameters.</text>
      <param>singularThreshold The singular threshold.</param>
    </javadoc>
    <method type="constructor" name="QRColPivDecompositionHouseholderColumn" startLine="65" endLine="67" />
    <method type="constructor" name="QRColPivDecompositionHouseholderColumn" startLine="69" endLine="70" />
    <method type="void" name="setSingularThreshold" startLine="73" endLine="75" />
    <method type="void" name="setExpectedMaxSize" startLine="78" endLine="85">
      <scope startLine="81" endLine="84" />
    </method>
    <javadoc>
      <text>* Computes the Q matrix from the information stored in the QR matrix.  This
 * operation requires about 4(m<sup>2</sup>n-mn<sup>2</sup>+n<sup>3</sup>/3) flops.</text>
      <param>Q The orthogonal Q matrix.</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getQ" startLine="94" endLine="127">
      <scope startLine="95" endLine="105">
        <scope startLine="96" endLine="98" />
        <scope startLine="98" endLine="104">
          <scope startLine="99" endLine="101" />
          <scope startLine="101" endLine="103" />
        </scope>
      </scope>
      <scope startLine="105" endLine="115">
        <scope startLine="106" endLine="108" />
        <scope startLine="108" endLine="114">
          <scope startLine="109" endLine="111" />
          <scope startLine="111" endLine="113" />
        </scope>
      </scope>
      <scope startLine="117" endLine="124">
        <declaration type="double[]" name="u" />
        <declaration type="double" name="vv" />
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * To decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m<sup>2</sup>-2m<sup>2</sup>/3 flops.
 * </p>
 * <p>
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * </p></text>
    </javadoc>
    <method type="boolean" name="decompose" startLine="142" endLine="163">
      <scope startLine="151" endLine="160">
        <comment>if its degenerate stop processing</comment>
      </scope>
      <comment>initialize pivot variables</comment>
      <comment>go through each column and perform the decomposition</comment>
    </method>
    <javadoc>
      <text>* Sets the initial pivot ordering and compute the F-norm squared for each column</text>
    </javadoc>
    <method type="void" name="setupPivotInfo" startLine="168" endLine="179">
      <scope startLine="169" endLine="178">
        <declaration type="double[]" name="c" />
        <declaration type="double" name="norm" />
        <scope startLine="173" endLine="176">
          <declaration type="double" name="element" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Performs an efficient update of each columns' norm</text>
    </javadoc>
    <method type="void" name="updateNorms" startLine="185" endLine="210">
      <declaration type="boolean" name="foundNegative" />
      <scope startLine="187" endLine="195">
        <declaration type="double" name="e" />
        <scope startLine="191" endLine="194" />
      </scope>
      <scope startLine="199" endLine="209">
        <scope startLine="200" endLine="208">
          <declaration type="double[]" name="u" />
          <declaration type="double" name="actual" />
          <scope startLine="203" endLine="206">
            <declaration type="double" name="v" />
          </scope>
        </scope>
      </scope>
      <comment>if a negative sum has been found then clearly too much precision has been last</comment>
      <comment>and it should recompute the column norms from scratch</comment>
    </method>
    <javadoc>
      <text>* Finds the column with the largest normal and makes that the first column</text>
      <param>j Current column being inspected</param>
    </javadoc>
    <method type="void" name="swapColumns" startLine="217" endLine="239">
      <declaration type="int" name="largestIndex" />
      <declaration type="double" name="largestNorm" />
      <scope startLine="222" endLine="228">
        <declaration type="double" name="n" />
        <scope startLine="224" endLine="227" />
      </scope>
      <declaration type="double[]" name="tempC" />
      <declaration type="double" name="tempN" />
      <declaration type="int" name="tempP" />
      <comment>find the column with the largest norm</comment>
      <comment>swap the columns</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the householder vector "u" for the first column of submatrix j. The already computed
 * norm is used and checks to see if the matrix is singular at this point.
 * </p>
 * <p>
 * Q = I - &gamma;uu<sup>T</sup>
 * </p>
 * <p>
 * This function finds the values of 'u' and '&gamma;'.
 * </p></text>
      <param>j Which submatrix to work off of.</param>
      <return>false if it is degenerate</return>
    </javadoc>
    <method type="boolean" name="householderPivot" startLine="257" endLine="287">
      <declaration type="double[]" name="u" />
      <declaration type="double" name="max" />
      <scope startLine="264" endLine="266" />
      <scope startLine="266" endLine="282">
        <declaration type="double" name="u_0" />
        <scope startLine="279" endLine="281" />
        <comment>computes tau and normalizes u by max</comment>
        <comment>divide u by u_0</comment>
      </scope>
      <comment>find the largest value in this column</comment>
      <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
    </method>
    <method type="int" name="getRank" startLine="290" endLine="292" />
    <method type="int[]" name="getPivots" startLine="295" endLine="297" />
    <method type="DenseMatrix64F" name="getPivotMatrix" startLine="300" endLine="316">
      <scope startLine="307" endLine="309" />
      <scope startLine="311" endLine="313" />
    </method>
    <comment>the ordering of each column, the current column i is the original column pivots[i]</comment>
    <comment>F-norm  squared for each column</comment>
    <comment>threshold used to determine when a column is considered to be singular</comment>
    <comment>Threshold is relative to the maxAbs</comment>
    <comment>the matrix's rank</comment>
  </class>
</source>
