<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.qr">
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.QRDecomposition" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="QRDecompositionHouseholderTran" startLine="26">
    <implements name="QRDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Householder QR decomposition is rich in operations along the columns of the matrix.  This can be
 * taken advantage of by solving for the Q matrix in a column major format to reduce the number
 * of CPU cache misses and the number of copies that are performed.
 * </p></text>
      <see>QRDecompositionHouseholder</see>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* Where the Q and R matrices are stored.  For speed reasons
 * this is transposed</text>
    </javadoc>
    <declaration type="DenseMatrix64F" name="QR" />
    <declaration type="double" name="v" />
    <declaration type="int" name="numCols" />
    <declaration type="int" name="numRows" />
    <declaration type="int" name="minLength" />
    <declaration type="double" name="gammas" />
    <declaration type="double" name="gamma" />
    <declaration type="double" name="tau" />
    <declaration type="boolean" name="error" />
    <method type="void" name="setExpectedMaxSize" startLine="64" endLine="84">
      <declaration type="int" name="maxLength" />
      <scope startLine="70" endLine="74" />
      <scope startLine="74" endLine="76" />
      <scope startLine="78" endLine="80" />
      <scope startLine="81" endLine="83" />
    </method>
    <javadoc>
      <text>* Inner matrix that stores the decomposition</text>
    </javadoc>
    <method type="DenseMatrix64F" name="getQR" startLine="89" endLine="91" />
    <javadoc>
      <text>* Computes the Q matrix from the information stored in the QR matrix.  This
 * operation requires about 4(m<sup2</sup>n-mn<sup>2</sup>+n<sup>3</sup>/3) flops.</text>
      <param>Q The orthogonal Q matrix.</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getQ" startLine="100" endLine="134">
      <scope startLine="101" endLine="111">
        <scope startLine="102" endLine="104" />
        <scope startLine="104" endLine="110">
          <scope startLine="105" endLine="107" />
          <scope startLine="107" endLine="109" />
        </scope>
      </scope>
      <scope startLine="111" endLine="121">
        <scope startLine="112" endLine="114" />
        <scope startLine="114" endLine="120">
          <scope startLine="115" endLine="117" />
          <scope startLine="117" endLine="119" />
        </scope>
      </scope>
      <scope startLine="125" endLine="131">
        <declaration type="int" name="diagIndex" />
        <declaration type="double" name="before" />
      </scope>
      <comment>Unlike applyQ() this takes advantage of zeros in the identity matrix</comment>
      <comment>by not multiplying across all rows.</comment>
    </method>
    <javadoc>
      <text>* A = Q*A</text>
      <param>A Matrix that is being multiplied by Q.  Is modified.</param>
    </javadoc>
    <method type="void" name="applyQ" startLine="141" endLine="152">
      <scope startLine="145" endLine="151">
        <declaration type="int" name="diagIndex" />
        <declaration type="double" name="before" />
      </scope>
    </method>
    <javadoc>
      <text>* A = Q<sup>T</sup>*A</text>
      <param>A Matrix that is being multiplied by Q<sup>T</sup>.  Is modified.</param>
    </javadoc>
    <method type="void" name="applyTranQ" startLine="159" endLine="167">
      <scope startLine="160" endLine="166">
        <declaration type="int" name="diagIndex" />
        <declaration type="double" name="before" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns an upper triangular matrix which is the R in the QR decomposition.</text>
      <param>R An upper triangular matrix.</param>
      <param>compact</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getR" startLine="176" endLine="207">
      <scope startLine="177" endLine="182">
        <scope startLine="178" endLine="180" />
      </scope>
      <scope startLine="182" endLine="197">
        <scope startLine="183" endLine="186" />
        <scope startLine="186" endLine="189" />
        <scope startLine="191" endLine="196">
          <declaration type="int" name="min" />
          <scope startLine="193" endLine="195" />
        </scope>
      </scope>
      <scope startLine="199" endLine="203">
        <scope startLine="200" endLine="202" />
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * To decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m<sup>2</sup>-2m<sup>2</sup>/3 flops.
 * </p>
 * <p>
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * </p></text>
    </javadoc>
    <method type="boolean" name="decompose" startLine="222" endLine="235">
      <scope startLine="229" endLine="232" />
    </method>
    <method type="boolean" name="inputModified" startLine="238" endLine="240" />
    <javadoc>
      <text>* <p>
 * Computes the householder vector "u" for the first column of submatrix j.  Note this is
 * a specialized householder for this problem.  There is some protection against
 * overflow and underflow.
 * </p>
 * <p>
 * Q = I - &gamma;uu<sup>T</sup>
 * </p>
 * <p>
 * This function finds the values of 'u' and '&gamma;'.
 * </p></text>
      <param>j Which submatrix to work off of.</param>
    </javadoc>
    <method type="void" name="householder" startLine="258" endLine="283">
      <declaration type="int" name="startQR" />
      <declaration type="int" name="endQR" />
      <declaration type="double" name="max" />
      <scope startLine="265" endLine="268" />
      <scope startLine="268" endLine="280">
        <declaration type="double" name="u_0" />
        <comment>computes tau and normalizes u by max</comment>
        <comment>divide u by u_0</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Takes the results from the householder computation and updates the 'A' matrix.<br>
 * <br>
 * A = (I - &gamma;*u*u<sup>T</sup>)A
 * </p></text>
      <param>w The submatrix.</param>
    </javadoc>
    <method type="void" name="updateA" startLine="295" endLine="340">
      <declaration type="double[]" name="data" />
      <declaration type="int" name="rowW" />
      <declaration type="int" name="rowJ" />
      <declaration type="int" name="rowJEnd" />
      <declaration type="int" name="indexWEnd" />
      <scope startLine="321" endLine="339">
        <declaration type="double" name="val" />
        <declaration type="int" name="indexW" />
        <declaration type="int" name="indexJ" />
        <scope startLine="328" endLine="330" />
        <scope startLine="336" endLine="338" />
        <comment>assume the first element in u is 1</comment>
      </scope>
      <comment>int rowW = w*numRows;</comment>
      <comment>int rowJ = rowW + numRows;</comment>
      <comment />
      <comment>for( int j = w+1; j < numCols; j++ , rowJ += numRows) {</comment>
      <comment>double val = QR.data[rowJ + w];</comment>
      <comment />
      <comment>val = gamma*u^T * A</comment>
      <comment>for( int k = w+1; k < numRows; k++ ) {</comment>
      <comment>val += QR.data[rowW + k]*QR.data[rowJ + k];</comment>
      <comment>}</comment>
      <comment>val *= gamma;</comment>
      <comment />
      <comment>A - val*u</comment>
      <comment>QR.data[rowJ + w] -= val;</comment>
      <comment>for( int i = w+1; i < numRows; i++ ) {</comment>
      <comment>QR.data[rowJ + i] -= QR.data[rowW + i]*val;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <method type="double[]" name="getGammas" startLine="342" endLine="344" />
    <comment>TODO remove QR Col and replace with this one?</comment>
    <comment>-- On small matrices col seems to be about 10% faster</comment>
    <comment>used internally to store temporary data</comment>
    <comment>dimension of the decomposed matrices</comment>
    <comment>this is 'n'</comment>
    <comment>this is 'm'</comment>
    <comment>the computed gamma for Q_k matrix</comment>
    <comment>local variables</comment>
    <comment>did it encounter an error?</comment>
  </class>
</source>
