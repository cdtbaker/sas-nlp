<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.chol">
  <import name="org.ejml.data.DenseMatrix64F" />
  <class name="CholeskyDecompositionBlock" extends="CholeskyDecompositionCommon" startLine="24">
    <javadoc>
      <text>* This is an implementation of Cholesky that processes internal submatrices as blocks.  This is
 * done to reduce the number of cache issues.</text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="int" name="blockWidth" />
    <declaration type="DenseMatrix64F" name="B" />
    <declaration type="CholeskyBlockHelper" name="chol" />
    <javadoc>
      <text>* Creates a CholeksyDecomposition capable of decomposing a matrix that is
 * n by n, where n is the width.</text>
      <param>blockWidth The width of a block.</param>
    </javadoc>
    <method type="constructor" name="CholeskyDecompositionBlock" startLine="43" endLine="48" />
    <javadoc>
      <text>* Declares additional internal data structures.</text>
    </javadoc>
    <method type="void" name="setExpectedMaxSize" startLine="54" endLine="65">
      <comment>if the matrix that is being decomposed is smaller than the block we really don't</comment>
      <comment>see the B matrix.</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Performs Choleksy decomposition on the provided matrix.
 * </p>
 * <p>
 * If the matrix is not positive definite then this function will return
 * false since it can't complete its computations.  Not all errors will be
 * found.
 * </p></text>
      <return>True if it was able to finish the decomposition.</return>
    </javadoc>
    <method type="boolean" name="decomposeLower" startLine="80" endLine="128">
      <declaration type="int" name="numBlocks" />
      <declaration type="int" name="remainder" />
      <scope startLine="90" endLine="92" />
      <scope startLine="96" endLine="117">
        <scope startLine="99" endLine="113">
          <declaration type="int" name="indexSrc" />
          <declaration type="int" name="indexDst" />
          <declaration type="int" name="indexL" />
        </scope>
        <scope startLine="113" endLine="116">
          <declaration type="int" name="width" />
        </scope>
        <comment>apply cholesky to the current block</comment>
        <comment>B = L^(-1) * B</comment>
        <comment>c = c - a^T*a</comment>
      </scope>
      <scope startLine="121" endLine="125">
        <scope startLine="122" endLine="124" />
      </scope>
      <comment>zero the top right corner.</comment>
    </method>
    <method type="boolean" name="decomposeUpper" startLine="131" endLine="133" />
    <javadoc>
      <text>* This is a variation on the {@link org.ejml.alg.dense.decomposition.TriangularSolver#solveL} function.
 * It grabs the input from the top right row rectangle of the source matrix then writes the results
 * to the lower bottom column rectangle.  The rectangle matrices just matrices are submatrices
 * of the matrix that is being decomposed.  The results are also written to B.</text>
      <param>L A lower triangular matrix.</param>
      <param>b_src matrix with the vectors that are to be solved for</param>
      <param>indexSrc First index of the submatrix where the inputs are coming from.</param>
      <param>indexDst First index of the submatrix where the results are going to.</param>
      <param>B</param>
    </javadoc>
    <method type="void" name="solveL_special" startLine="151" endLine="191">
      <declaration type="double[]" name="dataSrc" />
      <declaration type="double[]" name="b" />
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="widthL" />
      <scope startLine="171" endLine="190">
        <declaration type="int" name="indexb" />
        <declaration type="int" name="rowL" />
        <scope startLine="176" endLine="189">
          <declaration type="double" name="sum" />
          <declaration type="int" name="indexL" />
          <declaration type="int" name="endL" />
          <declaration type="int" name="indexB" />
          <scope startLine="183" endLine="185" />
          <declaration type="double" name="val" />
        </scope>
        <comment>for( int i = 0; i < widthL; i++</comment>
        <comment>for( int k=0; k<i; k++ ) {</comment>
      </scope>
      <comment>for( int j = 0; j < n; j++ ) {</comment>
      <comment>for( int i = 0; i < widthL; i++ ) {</comment>
      <comment>double sum = dataSrc[indexSrc+i*b_src.numCols+j];</comment>
      <comment>for( int k=0; k<i; k++ ) {</comment>
      <comment>sum -= L[i*widthL+k]* b[k*n+j];</comment>
      <comment>}</comment>
      <comment>double val = sum / L[i*widthL+i];</comment>
      <comment>dataSrc[indexDst+j*b_src.numCols+i] = val;</comment>
      <comment>b[i*n+j] = val;</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Performs this operation:<br>
 * <br>
 * c = c - a<sup>T</sup>a <br>
 * where c is a submatrix.
 * </p>
 * Only the upper triangle is updated.</text>
      <param>a A matrix.</param>
      <param>c A matrix.</param>
      <param>startIndexC start of the submatrix in c.</param>
    </javadoc>
    <method type="void" name="symmRankTranA_sub" startLine="209" endLine="241">
      <declaration type="double[]" name="dataA" />
      <declaration type="double[]" name="dataC" />
      <declaration type="int" name="strideC" />
      <scope startLine="225" endLine="239">
        <declaration type="int" name="indexA" />
        <declaration type="int" name="endR" />
        <scope startLine="229" endLine="237">
          <declaration type="int" name="indexC" />
          <declaration type="double" name="valA" />
          <declaration type="int" name="indexR" />
          <scope startLine="234" endLine="236" />
        </scope>
      </scope>
      <comment>TODO update so that it doesn't modify/read parts that it shouldn't</comment>
      <comment>for( int i = 0; i < a.numCols; i++ ) {</comment>
      <comment>for( int k = 0; k < a.numRows; k++ ) {</comment>
      <comment>double valA = dataA[k*a.numCols+i];</comment>
      <comment />
      <comment>for( int j = i; j < a.numCols; j++ ) {</comment>
      <comment>dataC[startIndexC+i*c.numCols+j] -= valA * dataA[k*a.numCols+j];</comment>
      <comment>}</comment>
      <comment>}</comment>
      <comment>}</comment>
    </method>
    <comment>how wide the blocks should be</comment>
    <comment>row rectangular matrix</comment>
  </class>
</source>
