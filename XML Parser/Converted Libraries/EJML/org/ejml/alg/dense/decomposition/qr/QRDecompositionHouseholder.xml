<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.qr">
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.QRDecomposition" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="QRDecompositionHouseholder" startLine="26">
    <implements name="QRDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * This variation of QR decomposition uses reflections to compute the Q matrix.
 * Each reflection uses a householder operations, hence its name.  To provide a meaningful solution
 * the original matrix must have full rank.  This is intended for processing of small to medium matrices.
 * </p>
 * <p>
 * Both Q and R are stored in the same m by n matrix.  Q is not stored directly, instead the u from
 * Q<sub>k</sub>=(I-&gamma;*u*u<sup>T</sup>) is stored.  Decomposition requires about 2n*m<sup>2</sup>-2m<sup>2</sup>/3 flops.
 * </p>
 * <p>
 * See the QR reflections algorithm described in:<br>
 * David S. Watkins, "Fundamentals of Matrix Computations" 2nd Edition, 2002
 * </p>
 * <p>
 * For the most part this is a straight forward implementation.  To improve performance on large matrices a column is writen to an array and the order
 * of some of the loops has been changed.  This will degrade performance noticeably on small matrices.  Since
 * it is unlikely that the QR decomposition would be a bottle neck when small matrices are involved only
 * one implementation is provided.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* Where the Q and R matrices are stored.  R is stored in the
 * upper triangular portion and Q on the lower bit.  Lower columns
 * are where u is stored.  Q_k = (I - gamma_k*u_k*u_k^T).</text>
    </javadoc>
    <declaration type="DenseMatrix64F" name="QR" />
    <declaration type="double" name="u" />
    <declaration type="int" name="numCols" />
    <declaration type="int" name="numRows" />
    <declaration type="int" name="minLength" />
    <declaration type="double" name="dataQR" />
    <declaration type="double" name="gammas" />
    <declaration type="double" name="gamma" />
    <declaration type="double" name="tau" />
    <declaration type="boolean" name="error" />
    <method type="void" name="setExpectedMaxSize" startLine="79" endLine="106">
      <declaration type="int" name="maxLength" />
      <scope startLine="87" endLine="92" />
      <scope startLine="92" endLine="94" />
      <scope startLine="98" endLine="101" />
      <scope startLine="103" endLine="105" />
    </method>
    <javadoc>
      <text>* Returns a single matrix which contains the combined values of Q and R.  This
 * is possible since Q is symmetric and R is upper triangular.</text>
      <return>The combined Q R matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getQR" startLine="114" endLine="116" />
    <javadoc>
      <text>* Computes the Q matrix from the imformation stored in the QR matrix.  This
 * operation requires about 4(m<sup>2</sup>n-mn<sup>2</sup>+n<sup>3</sup>/3) flops.</text>
      <param>Q The orthogonal Q matrix.</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getQ" startLine="125" endLine="157">
      <scope startLine="126" endLine="136">
        <scope startLine="127" endLine="129" />
        <scope startLine="129" endLine="135">
          <scope startLine="130" endLine="132" />
          <scope startLine="132" endLine="134" />
        </scope>
      </scope>
      <scope startLine="136" endLine="146">
        <scope startLine="137" endLine="139" />
        <scope startLine="139" endLine="145">
          <scope startLine="140" endLine="142" />
          <scope startLine="142" endLine="144" />
        </scope>
      </scope>
      <scope startLine="148" endLine="154">
        <scope startLine="150" endLine="152" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns an upper triangular matrix which is the R in the QR decomposition.</text>
      <param>R An upper triangular matrix.</param>
      <param>compact</param>
    </javadoc>
    <method type="DenseMatrix64F" name="getR" startLine="166" endLine="197">
      <scope startLine="167" endLine="172">
        <scope startLine="168" endLine="170" />
      </scope>
      <scope startLine="172" endLine="187">
        <scope startLine="173" endLine="176" />
        <scope startLine="176" endLine="179" />
        <scope startLine="181" endLine="186">
          <declaration type="int" name="min" />
          <scope startLine="183" endLine="185" />
        </scope>
      </scope>
      <scope startLine="189" endLine="194">
        <scope startLine="190" endLine="193">
          <declaration type="double" name="val" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * In order to decompose the matrix 'A' it must have full rank.  'A' is a 'm' by 'n' matrix.
 * It requires about 2n*m<sup>2</sup>-2m<sup>2</sup>/3 flops.
 * </p>
 * <p>
 * The matrix provided here can be of different
 * dimension than the one specified in the constructor.  It just has to be smaller than or equal
 * to it.
 * </p></text>
    </javadoc>
    <method type="boolean" name="decompose" startLine="212" endLine="221">
      <scope startLine="215" endLine="218" />
    </method>
    <method type="boolean" name="inputModified" startLine="224" endLine="226" />
    <javadoc>
      <text>* <p>
 * Computes the householder vector "u" for the first column of submatrix j.  Note this is
 * a specialized householder for this problem.  There is some protection against
 * overflow and underflow.
 * </p>
 * <p>
 * Q = I - &gamma;uu<sup>T</sup>
 * </p>
 * <p>
 * This function finds the values of 'u' and '&gamma;'.
 * </p></text>
      <param>j Which submatrix to work off of.</param>
    </javadoc>
    <method type="void" name="householder" startLine="244" endLine="287">
      <declaration type="int" name="index" />
      <declaration type="double" name="max" />
      <scope startLine="248" endLine="258">
        <declaration type="double" name="d" />
        <scope startLine="254" endLine="256" />
        <comment>absolute value of d</comment>
      </scope>
      <scope startLine="260" endLine="263" />
      <scope startLine="263" endLine="284">
        <scope startLine="267" endLine="271">
          <declaration type="double" name="d" />
        </scope>
        <declaration type="double" name="u_0" />
        <scope startLine="279" endLine="281" />
        <comment>compute the norm2 of the matrix, with each element</comment>
        <comment>normalized by the max value to avoid overflow problems</comment>
      </scope>
      <comment>find the element with the largest absolute value in the column and make a copy</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Takes the results from the householder computation and updates the 'A' matrix.<br>
 * <br>
 * A = (I - &gamma;*u*u<sup>T</sup>)A
 * </p></text>
      <param>w The submatrix.</param>
    </javadoc>
    <method type="void" name="updateA" startLine="299" endLine="350">
      <scope startLine="314" endLine="316" />
      <scope startLine="318" endLine="324">
        <declaration type="int" name="indexQR" />
        <scope startLine="320" endLine="323" />
        <comment>v[i] += u[k]*dataQR[k*numCols +i];</comment>
      </scope>
      <scope startLine="326" endLine="328" />
      <scope startLine="332" endLine="340">
        <declaration type="double" name="valU" />
        <declaration type="int" name="indexQR" />
        <scope startLine="336" endLine="339" />
        <comment>dataQR[i*numCols+j] -= valU*v[j];</comment>
      </scope>
      <scope startLine="342" endLine="344" />
      <scope startLine="347" endLine="349" />
      <comment>much of the code below is equivalent to the rank1Update function</comment>
      <comment>however, since &tau; has already been computed there is no need to</comment>
      <comment>recompute it, saving a few multiplication operations</comment>
      <comment>for( int i = w+1; i < numCols; i++ ) {</comment>
      <comment>double val = 0;</comment>
      <comment />
      <comment>for( int k = w; k < numRows; k++ ) {</comment>
      <comment>val += u[k]*dataQR[k*numCols +i];</comment>
      <comment>}</comment>
      <comment>v[i] = gamma*val;</comment>
      <comment>}</comment>
      <comment>This is functionally the same as the above code but the order has been changed</comment>
      <comment>to avoid jumping the cpu cache</comment>
      <comment>end of reordered code</comment>
      <comment>save the Q matrix in the lower portion of QR</comment>
    </method>
    <javadoc>
      <text>* This function performs sanity check on the input for decompose and sets up the QR matrix.</text>
      <param>A</param>
    </javadoc>
    <method type="void" name="commonSetup" startLine="357" endLine="361" />
    <method type="double[]" name="getGammas" startLine="363" endLine="365" />
    <comment>used internally to store temporary data</comment>
    <comment>dimension of the decomposed matrices</comment>
    <comment>this is 'n'</comment>
    <comment>this is 'm'</comment>
    <comment>the computed gamma for Q_k matrix</comment>
    <comment>local variables</comment>
    <comment>did it encounter an error?</comment>
  </class>
</source>
