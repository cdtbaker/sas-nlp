<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.svd">
  <import name="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecomposition" />
  <import name="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecompositionRow" />
  <import name="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecompositionTall" />
  <import name="org.ejml.alg.dense.decomposition.svd.implicitqr.SvdImplicitQrAlgorithm" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.SingularValueDecomposition" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="SvdImplicitQrDecompose" startLine="30">
    <implements name="SingularValueDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Computes the Singular value decomposition of a matrix using the implicit QR algorithm
 * for singular value decomposition.  It works by first by transforming the matrix
 * to a bidiagonal A=U*B*V<sup>T</sup> form, then it implicitly computing the eigenvalues of the B<sup>T</sup>B matrix,
 * which are the same as the singular values in the original A matrix.
 * </p>
 * <p>
 * Based off of the description provided in:<br>
 * <br>
 * David S. Watkins, "Fundamentals of Matrix Computations," Second Edition. Page 404-411
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="int" name="numRows" />
    <declaration type="int" name="numCols" />
    <declaration type="int" name="numRowsT" />
    <declaration type="int" name="numColsT" />
    <declaration type="boolean" name="canUseTallBidiagonal" />
    <declaration type="BidiagonalDecomposition<DenseMatrix64F>" name="bidiag" />
    <declaration type="SvdImplicitQrAlgorithm" name="qralg" />
    <declaration type="double" name="diag" />
    <declaration type="double" name="off" />
    <declaration type="DenseMatrix64F" name="Ut" />
    <declaration type="DenseMatrix64F" name="Vt" />
    <declaration type="double" name="singularValues" />
    <declaration type="int" name="numSingular" />
    <declaration type="boolean" name="compact" />
    <declaration type="boolean" name="computeU" />
    <declaration type="boolean" name="computeV" />
    <declaration type="boolean" name="prefComputeU" />
    <declaration type="boolean" name="prefComputeV" />
    <declaration type="boolean" name="transposed" />
    <declaration type="DenseMatrix64F" name="A_mod" />
    <javadoc>
      <text>* Configures the class</text>
      <param>compact Compute a compact SVD</param>
      <param>computeU If true it will compute the U matrix</param>
      <param>computeV If true it will compute the V matrix</param>
      <param>canUseTallBidiagonal If true then it can choose to use a tall Bidiagonal decomposition to improve runtime performance.</param>
    </javadoc>
    <method type="constructor" name="SvdImplicitQrDecompose" startLine="99" endLine="104" />
    <method type="double[]" name="getSingularValues" startLine="107" endLine="109" />
    <method type="int" name="numberOfSingularValues" startLine="112" endLine="114" />
    <method type="boolean" name="isCompact" startLine="117" endLine="119" />
    <method type="DenseMatrix64F" name="getU" startLine="122" endLine="142">
      <scope startLine="125" endLine="132" />
      <scope startLine="132" endLine="139" />
    </method>
    <method type="DenseMatrix64F" name="getV" startLine="145" endLine="164">
      <scope startLine="148" endLine="155" />
      <scope startLine="155" endLine="161" />
    </method>
    <method type="DenseMatrix64F" name="getW" startLine="167" endLine="183">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="173" endLine="176" />
      <scope startLine="178" endLine="180" />
    </method>
    <method type="boolean" name="decompose" startLine="186" endLine="202">
      <comment>make sure all the singular values or positive</comment>
      <comment>if transposed undo the transposition</comment>
    </method>
    <method type="boolean" name="inputModified" startLine="205" endLine="207" />
    <method type="boolean" name="bidiagonalization" startLine="209" endLine="219">
      <scope startLine="211" endLine="214" />
      <scope startLine="214" endLine="217" />
      <comment>change the matrix to bidiagonal form</comment>
    </method>
    <javadoc>
      <text>* If the transpose was computed instead do some additional computations</text>
    </javadoc>
    <method type="void" name="undoTranspose" startLine="224" endLine="230">
      <scope startLine="225" endLine="229">
        <declaration type="DenseMatrix64F" name="temp" />
      </scope>
    </method>
    <javadoc>
      <text>* Compute singular values and U and V at the same time</text>
    </javadoc>
    <method type="boolean" name="computeUWV" startLine="235" endLine="264">
      <declaration type="boolean" name="ret" />
      <comment>long pointA = System.currentTimeMillis();</comment>
      <comment>compute U and V matrices</comment>
      <comment>long pointB = System.currentTimeMillis();</comment>
      <comment>long pointC = System.currentTimeMillis();</comment>
      <comment>System.out.println("  compute UV "+(pointB-pointA)+"  QR = "+(pointC-pointB));</comment>
    </method>
    <method type="void" name="setup" startLine="266" endLine="298">
      <scope startLine="270" endLine="275" />
      <scope startLine="275" endLine="280" />
      <scope startLine="285" endLine="288" />
      <scope startLine="291" endLine="295">
        <scope startLine="292" endLine="294" />
      </scope>
      <scope startLine="295" endLine="297" />
      <comment>flag what should be computed and what should not be computed</comment>
      <comment>if it is a tall matrix and U is not needed then there is faster decomposition algorithm</comment>
    </method>
    <javadoc>
      <text>* With the QR algorithm it is possible for the found singular values to be negative.  This
 * makes them all positive by multiplying it by a diagonal matrix that has</text>
    </javadoc>
    <method type="void" name="makeSingularPositive" startLine="304" endLine="328">
      <scope startLine="308" endLine="327">
        <declaration type="double" name="val" />
        <scope startLine="311" endLine="324">
          <scope startLine="314" endLine="323">
            <declaration type="int" name="start" />
            <declaration type="int" name="stop" />
            <scope startLine="320" endLine="322" />
          </scope>
        </scope>
        <scope startLine="324" endLine="326" />
        <comment>compute the results of multiplying it by an element of -1 at this location in</comment>
        <comment>a diagonal matrix.</comment>
      </scope>
    </method>
    <method type="int" name="numRows" startLine="331" endLine="333" />
    <method type="int" name="numCols" startLine="336" endLine="338" />
    <comment>dimensions of transposed matrix</comment>
    <comment>if true then it can use the special Bidiagonal decomposition</comment>
    <comment>If U is not being computed and the input matrix is 'tall' then a special bidiagonal decomposition</comment>
    <comment>can be used which is faster.</comment>
    <comment>compute a compact SVD</comment>
    <comment>What is actually computed</comment>
    <comment>What the user requested to be computed</comment>
    <comment>If the transpose is computed instead then what is actually computed is swapped</comment>
    <comment>Should it compute the transpose instead</comment>
    <comment>Either a copy of the input matrix or a copy of it transposed</comment>
  </class>
</source>
