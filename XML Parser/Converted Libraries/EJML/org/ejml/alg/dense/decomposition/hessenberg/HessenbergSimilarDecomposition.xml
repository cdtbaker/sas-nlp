<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.hessenberg">
  <import name="org.ejml.alg.dense.decomposition.qr.QrHelperFunctions" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.DecompositionInterface" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="HessenbergSimilarDecomposition" startLine="26">
    <implements name="DecompositionInterface<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Finds the decomposition of a matrix in the form of:<br>
 * <br>
 * A = OHO<sup>T</sup><br>
 * <br>
 * where A is an m by m matrix, O is an orthogonal matrix, and H is an upper Hessenberg matrix.
 * </p>
 * <p>
 * A matrix is upper Hessenberg if a<sup>ij</sup> = 0 for all i > j+1. For example, the following matrix
 * is upper Hessenberg.<br>
 * <br>
 * WRITE IT OUT USING A TABLE
 * </p>
 * <p>
 * This decomposition is primarily used as a step for computing the eigenvalue decomposition of a matrix.
 * The basic algorithm comes from David S. Watkins, "Fundamentals of MatrixComputations" Second Edition.
 * </p></text>
    </javadoc>
    <declaration type="DenseMatrix64F" name="QH" />
    <declaration type="int" name="N" />
    <declaration type="double" name="gammas" />
    <declaration type="double" name="b" />
    <declaration type="double" name="u" />
    <javadoc>
      <text>* Creates a decomposition that won't need to allocate new memory if it is passed matrices up to
 * the specified size.</text>
      <param>initialSize Expected size of the matrices it will decompose.</param>
    </javadoc>
    <method type="constructor" name="HessenbergSimilarDecomposition" startLine="67" endLine="71" />
    <method type="constructor" name="HessenbergSimilarDecomposition" startLine="73" endLine="75" />
    <javadoc>
      <text>* Computes the decomposition of the provided matrix.  If no errors are detected then true is returned,
 * false otherwise.</text>
      <param>A  The matrix that is being decomposed.  Not modified.</param>
      <return>If it detects any errors or not.</return>
    </javadoc>
    <method type="boolean" name="decompose" startLine="85" endLine="99">
      <scope startLine="93" endLine="97" />
    </method>
    <method type="boolean" name="inputModified" startLine="102" endLine="104" />
    <javadoc>
      <text>* The raw QH matrix that is stored internally.</text>
      <return>QH matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getQH" startLine="111" endLine="113" />
    <javadoc>
      <text>* An upper Hessenberg matrix from the decompostion.</text>
      <param>H If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
      <return>The extracted H matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getH" startLine="121" endLine="139">
      <scope startLine="122" endLine="124" />
      <scope startLine="132" endLine="136">
        <scope startLine="133" endLine="135" />
      </scope>
      <comment>copy the first row</comment>
    </method>
    <javadoc>
      <text>* An orthogonal matrix that has the following property: H = Q<sup>T</sup>AQ</text>
      <param>Q If not null then the results will be stored here.  Otherwise a new matrix will be created.</param>
      <return>The extracted Q matrix.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="getQ" startLine="147" endLine="167">
      <scope startLine="148" endLine="153">
        <scope startLine="150" endLine="152" />
      </scope>
      <scope startLine="158" endLine="164">
        <scope startLine="160" endLine="162" />
      </scope>
    </method>
    <javadoc>
      <text>* Internal function for computing the decomposition.</text>
    </javadoc>
    <method type="boolean" name="_decompose" startLine="172" endLine="233">
      <declaration type="double[]" name="h" />
      <scope startLine="175" endLine="230">
        <declaration type="double" name="max" />
        <scope startLine="180" endLine="187">
          <declaration type="double" name="val" />
        </scope>
        <scope startLine="189" endLine="226">
          <declaration type="double" name="tau" />
          <scope startLine="195" endLine="198">
            <declaration type="double" name="val" />
          </scope>
          <declaration type="double" name="nu" />
          <scope startLine="209" endLine="211" />
          <declaration type="double" name="gamma" />
        </scope>
        <scope startLine="226" endLine="228" />
        <comment>find the largest value in this column</comment>
        <comment>this is used to normalize the column and mitigate overflow/underflow</comment>
        <comment>copy the householder vector to vector outside of the matrix to reduce caching issues</comment>
        <comment>big improvement on larger matrices and a relatively small performance hit on small matrices.</comment>
        <comment>-------- set up the reflector Q_k</comment>
        <comment>normalize to reduce overflow/underflow</comment>
        <comment>and compute tau for the reflector</comment>
        <comment>write the reflector into the lower left column of the matrix</comment>
        <comment>---------- multiply on the left by Q_k</comment>
        <comment>---------- multiply on the right by Q_k</comment>
        <comment>since the first element in the householder vector is known to be 1</comment>
        <comment>store the full upper hessenberg</comment>
      </scope>
    </method>
    <method type="double[]" name="getGammas" startLine="235" endLine="237" />
    <comment>TODO create a column based one similar to what was done for QR decomposition?</comment>
    <comment>A combined matrix that stores te upper Hessenberg matrix and the orthogonal matrix.</comment>
    <comment>number of rows and columns of the matrix being decompose</comment>
    <comment>the first element in the orthogonal vectors</comment>
    <comment>temporary storage</comment>
  </class>
</source>
