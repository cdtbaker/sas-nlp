<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.bidiagonal">
  <import name="org.ejml.UtilEjml" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.DecompositionFactory" />
  <import name="org.ejml.factory.QRPDecomposition" />
  <import name="org.ejml.ops.CommonOps" />
  <class name="BidiagonalDecompositionTall" startLine="28">
    <implements name="BidiagonalDecomposition<DenseMatrix64F>" />
    <javadoc>
      <text>* <p>{@link BidiagonalDecomposition} specifically designed for tall matrices.
 * First step is to perform QR decomposition on the input matrix.  Then R is decomposed using
 * a bidiagonal decomposition.  By performing the bidiagonal decomposition on the smaller matrix
 * computations can be saved if m/n > 5/3 and if U is NOT needed.
 * </p>
 * <p>
 * A = [Q<sub>1</sub> Q<sub>2</sub>][U1 0; 0 I] [B1;0] V<sup>T</sup><br>
 * U=[Q<sub>1</sub>*U1 Q<sub>2</sub>]<br>
 * B=[B1;0]<br>
 * A = U*B*V<sup>T</sup>
 * </p>
 * <p>
 * A QRP decomposition is used internally.  That decomposition relies an a fixed threshold for selecting singular
 * values and is known to be less stable than SVD.  There is the potential for a degregation of stability
 * by using BidiagonalDecompositionTall instead of BidiagonalDecomposition. A few simple tests have shown
 * that loss in stability to be insignificant.
 * </p>
 * <p>
 * See page 404 in "Fundamentals of Matrix Computations", 2nd by David S. Watkins.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="QRPDecomposition<DenseMatrix64F>" name="decompQRP" />
    <declaration type="BidiagonalDecomposition<DenseMatrix64F>" name="decompBi" />
    <declaration type="DenseMatrix64F" name="B" />
    <declaration type="int" name="m" />
    <declaration type="int" name="n" />
    <declaration type="int" name="min" />
    <method type="void" name="getDiagonal" startLine="74" endLine="80">
      <scope startLine="76" endLine="79" />
    </method>
    <method type="DenseMatrix64F" name="getB" startLine="83" endLine="95">
      <scope startLine="87" endLine="90" />
    </method>
    <method type="DenseMatrix64F" name="getU" startLine="98" endLine="120">
      <scope startLine="101" endLine="106">
        <declaration type="DenseMatrix64F" name="Q1" />
        <declaration type="DenseMatrix64F" name="U1" />
        <comment>U = Q*U1</comment>
      </scope>
      <scope startLine="106" endLine="114">
        <declaration type="DenseMatrix64F" name="Q" />
        <declaration type="DenseMatrix64F" name="U1" />
        <declaration type="DenseMatrix64F" name="Q1" />
        <declaration type="DenseMatrix64F" name="tmp" />
        <comment>U = [Q1*U1 Q2]</comment>
      </scope>
    </method>
    <method type="DenseMatrix64F" name="getV" startLine="123" endLine="125" />
    <method type="boolean" name="decompose" startLine="128" endLine="150">
      <scope startLine="131" endLine="133" />
      <declaration type="DenseMatrix64F" name="result" />
      <declaration type="DenseMatrix64F" name="P" />
      <comment>apply the column pivots.</comment>
      <comment>TODO this is horribly inefficient</comment>
    </method>
    <method type="boolean" name="inputModified" startLine="153" endLine="155" />
    <comment>TODO optimize this code</comment>
    <comment>todo this should be passed in</comment>
    <comment>number of rows</comment>
    <comment>number of column</comment>
    <comment>min(m,n)</comment>
  </class>
</source>
