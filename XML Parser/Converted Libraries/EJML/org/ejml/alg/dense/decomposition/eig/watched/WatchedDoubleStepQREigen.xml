<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.eig.watched">
  <import name="org.ejml.UtilEjml" />
  <import name="org.ejml.alg.dense.decomposition.eig.EigenvalueSmall" />
  <import name="org.ejml.alg.dense.decomposition.qr.QrHelperFunctions" />
  <import name="org.ejml.data.Complex64F" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.ops.MatrixFeatures" />
  <import name="java.util.Random" />
  <class name="WatchedDoubleStepQREigen" startLine="30">
    <javadoc>
      <text>* <p>
 * The double step implicit Eigenvalue decomposition algorithm is fairly complicated and needs to be designed so that
 * it can handle several special cases.  To aid in development and debugging this class was created.  It allows
 * individual components to be tested and to print out their results.  This shows how each step is performed.
 * </p>
 * <p>
 * Do not use this class to compute the eigenvalues since it is much slower than a non-debug implementation.
 * </p></text>
    </javadoc>
    <declaration type="Random" name="rand" />
    <declaration type="int" name="N" />
    <declaration type="DenseMatrix64F" name="A" />
    <declaration type="DenseMatrix64F" name="u" />
    <declaration type="double" name="gamma" />
    <declaration type="DenseMatrix64F" name="_temp" />
    <declaration type="int" name="numStepsFind" />
    <declaration type="int" name="steps" />
    <declaration type="Complex64F" name="eigenvalues" />
    <declaration type="int" name="numEigen" />
    <declaration type="EigenvalueSmall" name="valueSmall" />
    <declaration type="double" name="temp" />
    <declaration type="boolean" name="printHumps" />
    <declaration type="boolean" name="checkHessenberg" />
    <declaration type="boolean" name="checkOrthogonal" />
    <declaration type="boolean" name="checkUncountable" />
    <declaration type="boolean" name="useStandardEq" />
    <declaration type="boolean" name="useCareful2x2" />
    <declaration type="boolean" name="normalize" />
    <declaration type="int" name="lastExceptional" />
    <declaration type="int" name="numExceptional" />
    <declaration type="int" name="exceptionalThreshold" />
    <declaration type="int" name="maxIterations" />
    <declaration type="boolean" name="createR" />
    <declaration type="DenseMatrix64F" name="Q" />
    <method type="void" name="incrementSteps" startLine="86" endLine="88" />
    <method type="void" name="setQ" startLine="90" endLine="92" />
    <method type="void" name="addEigenvalue" startLine="94" endLine="100" />
    <method type="void" name="addEigenvalue" startLine="102" endLine="108" />
    <method type="void" name="setChecks" startLine="110" endLine="114" />
    <method type="boolean" name="isZero" startLine="117" endLine="126">
      <declaration type="double" name="target" />
      <declaration type="double" name="above" />
      <declaration type="double" name="right" />
      <comment>this provides a relative threshold for when dealing with very large/small numbers</comment>
      <comment>according to Matrix Computations page 352 this is what is done in Eispack</comment>
    </method>
    <method type="void" name="setup" startLine="128" endLine="161">
      <scope startLine="132" endLine="140" />
      <scope startLine="140" endLine="143" />
      <scope startLine="146" endLine="150">
        <scope startLine="147" endLine="149" />
      </scope>
      <scope startLine="153" endLine="155" />
      <comment>zero all the off numbers that should be zero for a hessenberg matrix</comment>
    </method>
    <javadoc>
      <text>* Perform a shift in a random direction that is of the same magnitude as the elements in the matrix.</text>
    </javadoc>
    <method type="void" name="exceptionalShift" startLine="166" endLine="187">
      <declaration type="double" name="val" />
      <declaration type="double" name="p" />
      <comment>perform a random shift that is of the same magnitude as the matrix</comment>
      <comment>the closer the value is the better it handles identical eigenvalues cases</comment>
    </method>
    <javadoc>
      <text>* Performs an implicit double step using the values contained in the lower right hand side
 * of the submatrix for the estimated eigenvector values.</text>
      <param>x1</param>
      <param>x2</param>
    </javadoc>
    <method type="void" name="implicitDoubleStep" startLine="195" endLine="240">
      <declaration type="double" name="z11" />
      <declaration type="double" name="z12" />
      <declaration type="double" name="z21" />
      <declaration type="double" name="z22" />
      <declaration type="double" name="a11" />
      <declaration type="double" name="a21" />
      <declaration type="double" name="a12" />
      <declaration type="double" name="a22" />
      <declaration type="double" name="a32" />
      <scope startLine="211" endLine="222">
        <declaration type="double" name="max" />
        <scope startLine="216" endLine="219" />
      </scope>
      <declaration type="double" name="b11" />
      <scope startLine="227" endLine="231" />
      <scope startLine="231" endLine="237">
        <comment>this is different from the version in the book and seems in my testing to be more resilient to</comment>
        <comment>over flow issues</comment>
      </scope>
      <comment>compute the wilkinson shift</comment>
      <comment>these equations are derived when the eigenvalues are extracted from the lower right</comment>
      <comment>2 by 2 matrix.  See page 388 of Fundamentals of Matrix Computations 2nd ed for details.</comment>
    </method>
    <javadoc>
      <text>* Performs an implicit double step given the set of two imaginary eigenvalues provided.
 * Since one eigenvalue is the complex conjugate of the other only one set of real and imaginary
 * numbers is needed.</text>
      <param>x1 upper index of submatrix.</param>
      <param>x2 lower index of submatrix.</param>
      <param>real Real component of each of the eigenvalues.</param>
      <param>img Imaginary component of one of the eigenvalues.</param>
    </javadoc>
    <method type="void" name="performImplicitDoubleStep" startLine="252" endLine="276">
      <declaration type="double" name="a11" />
      <declaration type="double" name="a21" />
      <declaration type="double" name="a12" />
      <declaration type="double" name="a22" />
      <declaration type="double" name="a32" />
      <declaration type="double" name="p_plus_t" />
      <declaration type="double" name="p_times_t" />
      <declaration type="double" name="b11" />
      <scope startLine="263" endLine="267" />
      <scope startLine="267" endLine="273">
        <comment>this is different from the version in the book and seems in my testing to be more resilient to</comment>
        <comment>over flow issues</comment>
      </scope>
    </method>
    <method type="void" name="performImplicitDoubleStep" startLine="279" endLine="332">
      <scope startLine="284" endLine="292">
        <scope startLine="286" endLine="291" />
      </scope>
      <scope startLine="294" endLine="298" />
      <scope startLine="301" endLine="312">
        <scope startLine="302" endLine="306" />
        <scope startLine="308" endLine="311" />
      </scope>
      <scope startLine="316" endLine="321" />
      <scope startLine="322" endLine="325" />
      <scope startLine="328" endLine="331" />
      <comment>get rid of the bump</comment>
      <comment>perform double steps</comment>
      <comment>the last one has to be a single step</comment>
      <comment>A.print("%12.3e");</comment>
    </method>
    <method type="void" name="performImplicitSingleStep" startLine="335" endLine="370">
      <scope startLine="340" endLine="344" />
      <scope startLine="346" endLine="350" />
      <scope startLine="353" endLine="364">
        <scope startLine="354" endLine="358" />
        <scope startLine="360" endLine="363" />
      </scope>
      <scope startLine="366" endLine="369" />
      <comment>get rid of the bump</comment>
      <comment>perform simple steps</comment>
    </method>
    <method type="boolean" name="createBulgeSingleStep" startLine="372" endLine="380">
      <declaration type="double" name="b11" />
      <declaration type="double" name="b21" />
      <declaration type="double" name="threshold" />
    </method>
    <method type="boolean" name="bulgeDoubleStepQn" startLine="382" endLine="390">
      <declaration type="double" name="a11" />
      <declaration type="double" name="a21" />
      <declaration type="double" name="a31" />
      <declaration type="double" name="threshold" />
    </method>
    <method type="boolean" name="bulgeDoubleStepQn" startLine="395" endLine="462">
      <declaration type="double" name="max" />
      <scope startLine="397" endLine="418">
        <declaration type="double" name="absA11" />
        <declaration type="double" name="absA21" />
        <declaration type="double" name="absA31" />
        <scope startLine="406" endLine="413">
          <scope startLine="407" endLine="411" />
        </scope>
        <comment>if( max <= Math.abs(A.get(i,i))*UtilEjml.EPS ) {</comment>
      </scope>
      <scope startLine="418" endLine="420" />
      <declaration type="double" name="tau" />
      <declaration type="double" name="div" />
      <scope startLine="440" endLine="444" />
      <scope startLine="446" endLine="449" />
      <scope startLine="457" endLine="459" />
      <comment>compute the reflector using the b's above</comment>
      <comment>compute A_1 = Q_1^T * A * Q_1</comment>
      <comment>apply Q*A  - just do the 3 rows</comment>
      <comment>apply A*Q - just the three things</comment>
      <comment>System.out.println("  after Q*A*Q ");</comment>
      <comment>A.print();</comment>
    </method>
    <method type="boolean" name="bulgeSingleStepQn" startLine="465" endLine="472">
      <declaration type="double" name="a11" />
      <declaration type="double" name="a21" />
      <declaration type="double" name="threshold" />
    </method>
    <method type="boolean" name="bulgeSingleStepQn" startLine="477" endLine="531">
      <declaration type="double" name="max" />
      <scope startLine="480" endLine="497">
        <scope startLine="485" endLine="493">
          <scope startLine="488" endLine="491" />
        </scope>
        <comment>if( max <= Math.abs(A.get(i,i))*UtilEjml.EPS ) {</comment>
        <comment>System.out.println("i = "+i);</comment>
        <comment>A.print();</comment>
      </scope>
      <scope startLine="497" endLine="499" />
      <declaration type="double" name="tau" />
      <declaration type="double" name="div" />
      <scope startLine="518" endLine="521" />
      <scope startLine="526" endLine="528" />
      <comment>compute the reflector using the b's above</comment>
      <comment>compute A_1 = Q_1^T * A * Q_1</comment>
      <comment>apply Q*A  - just do the 3 rows</comment>
      <comment>apply A*Q - just the three things</comment>
    </method>
    <method type="void" name="eigen2by2_scale" startLine="534" endLine="565">
      <declaration type="double" name="abs11" />
      <declaration type="double" name="abs22" />
      <declaration type="double" name="abs12" />
      <declaration type="double" name="abs21" />
      <declaration type="double" name="max" />
      <scope startLine="544" endLine="549" />
      <scope startLine="549" endLine="562">
        <scope startLine="552" endLine="554" />
        <scope startLine="554" endLine="556" />
      </scope>
      <comment>System.out.printf("eigen (%6.3f , %6.3f) (%6.3f , %6.3f)\n",p0_real,p0_img,p1_real,p1_img);</comment>
    </method>
    <method type="int" name="getNumberOfEigenvalues" startLine="567" endLine="569" />
    <method type="Complex64F[]" name="getEigenvalues" startLine="571" endLine="573" />
    <method type="void" name="addComputedEigen2x2" startLine="575" endLine="585">
      <scope startLine="579" endLine="581" />
    </method>
    <method type="boolean" name="isReal2x2" startLine="587" endLine="591" />
    <method type="void" name="addEigenAt" startLine="593" endLine="595" />
    <method type="void" name="printSteps" startLine="597" endLine="601">
      <scope startLine="598" endLine="600" />
    </method>
    <comment>TODO make rank1UpdateMultR efficient once again by setting 0 to x1 and creating a new one that updates all the rows</comment>
    <comment>TODO option of modifying original matrix</comment>
    <comment>how many steps did it take to find the eigenvalue</comment>
    <comment>computes eigenvalues for 2 by 2 submatrices</comment>
  </class>
</source>
