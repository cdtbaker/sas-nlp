<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.dense.decomposition.eig">
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.factory.LinearSolver" />
  <import name="org.ejml.factory.LinearSolverFactory" />
  <import name="org.ejml.ops.CommonOps" />
  <import name="org.ejml.ops.NormOps" />
  <import name="org.ejml.ops.SpecializedOps" />
  <class name="EigenPowerMethod" startLine="29">
    <javadoc>
      <text>* <p>
 * The power method is an iterative method that can be used to find dominant eigen vector in
 * a matrix.  Computing <b>A<sup>n</sup>q</b> for larger and larger values of n, where q is a vector.  Eventually the
 * dominant (if there is any) eigen vector will "win".
 * <p>
 * <p>
 * Shift implementations find the eigen value of the matrix B=A-pI instead.  This matrix has the
 * same eigen vectors, but can converge much faster if p is chosen wisely.
 * </p>
 * <p>
 * See section 5.3 in "Fundamentals of Matrix Computations" Second Edition, David S. Watkins.
 * </p>
 * <p>
 * WARNING:  These functions have well known conditions where they will not converge or converge
 * very slowly and are only used in special situations in practice.  I have also seen it converge
 * to none dominant eigen vectors.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="double" name="tol" />
    <declaration type="DenseMatrix64F" name="q0" />
    <declaration type="int" name="maxIterations" />
    <declaration type="DenseMatrix64F" name="B" />
    <declaration type="DenseMatrix64F" name="seed" />
    <javadoc>
      <param>size The size of the matrix which can be processed.</param>
    </javadoc>
    <method type="constructor" name="EigenPowerMethod" startLine="71" endLine="77" />
    <javadoc>
      <text>* Sets the value of the vector to use in the start of the iterations.</text>
      <param>seed The initial seed vector in the iteration.</param>
    </javadoc>
    <method type="void" name="setSeed" startLine="84" endLine="86" />
    <javadoc>
      <param>maxIterations</param>
      <param>tolerance</param>
    </javadoc>
    <method type="void" name="setOptions" startLine="93" endLine="96" />
    <javadoc>
      <text>* This method computes the eigen vector with the largest eigen value by using the
 * direct power method. This technique is the easiest to implement, but the slowest to converge.
 * Works only if all the eigenvalues are real.</text>
      <param>A The matrix. Not modified.</param>
      <return>If it converged or not.</return>
    </javadoc>
    <method type="boolean" name="computeDirect" startLine="106" endLine="123">
      <declaration type="boolean" name="converged" />
      <scope startLine="112" endLine="120">
        <declaration type="double" name="s" />
        <comment>q0.print();</comment>
      </scope>
    </method>
    <method type="void" name="initPower" startLine="126" endLine="137">
      <scope startLine="130" endLine="132" />
      <scope startLine="132" endLine="136">
        <scope startLine="133" endLine="135" />
      </scope>
    </method>
    <javadoc>
      <text>* Test for convergence by seeing if the element with the largest change
 * is smaller than the tolerance.  In some test cases it alternated between
 * the + and - values of the eigen vector.  When this happens it seems to have "converged"
 * to a non-dominant eigen vector.    At least in the case I looked at.  I haven't devoted
 * a lot of time into this issue...</text>
    </javadoc>
    <method type="boolean" name="checkConverged" startLine="146" endLine="167">
      <declaration type="double" name="worst" />
      <declaration type="double" name="worst2" />
      <scope startLine="149" endLine="154">
        <declaration type="double" name="val" />
      </scope>
      <declaration type="DenseMatrix64F" name="temp" />
      <comment>swap vectors</comment>
    </method>
    <javadoc>
      <text>* Computes the most dominant eigen vector of A using a shifted matrix.
 * The shifted matrix is defined as <b>B = A - &alpha;I</b> and can converge faster
 * if &alpha; is chosen wisely.  In general it is easier to choose a value for &alpha;
 * that will converge faster with the shift-invert strategy than this one.</text>
      <param>A The matrix.</param>
      <param>alpha Shifting factor.</param>
      <return>If it converged or not.</return>
    </javadoc>
    <method type="boolean" name="computeShiftDirect" startLine="179" endLine="183" />
    <javadoc>
      <text>* Computes the most dominant eigen vector of A using an inverted shifted matrix.
 * The inverted shifted matrix is defined as <b>B = (A - &alpha;I)<sup>-1</sup></b> and
 * can converge faster if &alpha; is chosen wisely.</text>
      <param>A An invertible square matrix matrix.</param>
      <param>alpha Shifting factor.</param>
      <return>If it converged or not.</return>
    </javadoc>
    <method type="boolean" name="computeShiftInvert" startLine="194" endLine="213">
      <declaration type="LinearSolver" name="solver" />
      <declaration type="boolean" name="converged" />
      <scope startLine="204" endLine="210">
        <declaration type="double" name="s" />
      </scope>
    </method>
    <method type="DenseMatrix64F" name="getEigenVector" startLine="215" endLine="217" />
    <comment>used to determine convergence</comment>
  </class>
</source>
