<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.block.decomposition.qr">
  <import name="org.ejml.alg.block.BlockMatrixOps" />
  <import name="org.ejml.alg.block.BlockMultiplication" />
  <import name="org.ejml.data.BlockMatrix64F" />
  <import name="org.ejml.data.D1Submatrix64F" />
  <import name="org.ejml.factory.QRDecomposition" />
  <class name="BlockMatrix64HouseholderQR" startLine="28">
    <implements name="QRDecomposition<BlockMatrix64F>" />
    <javadoc>
      <text>* <p>
 * QR decomposition for {@link BlockMatrix64F} using householder reflectors.  The decomposition is
 * performed by computing a QR decomposition for each block column as is normally done, see {@link org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholder}.
 * The reflectors are then combined and applied to the remainder of the matrix.  This process is repeated
 * until all the block columns have been processed
 * </p>
 * <p>
 * The input matrix is modified and used to store the decomposition.  Reflectors are stored in the lower triangle
 * columns.  The first element of the reflector is implicitly assumed to be one.
 * </p>
 * <p>
 * Each iteration can be sketched as follows:
 * <pre>
 * QR_Decomposition( A(:,i-r to i) )
 * W=computeW( A(:,i-r to i) )
 * A(:,i:n) = (I + W*Y<sup>T</sup>)<sup>T</sup>A(:,i:n)
 * </pre>
 * Where r is the block size, i is the submatrix being considered, A is the input matrix,
 * Y is a matrix containing the reflectors just computed,
 * and W is computed using {@link BlockHouseHolder#computeW_Column}.
 * </p>
 * <p>
 * Based upon "Block Householder QR Factorization" pg 255 in "Matrix Computations"
 * 3rd Ed. 1996 by Gene H. Golub and Charles F. Van Loan.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="BlockMatrix64F" name="dataA" />
    <declaration type="BlockMatrix64F" name="dataW" />
    <declaration type="BlockMatrix64F" name="dataWTA" />
    <declaration type="int" name="blockLength" />
    <declaration type="D1Submatrix64F" name="A" />
    <declaration type="D1Submatrix64F" name="Y" />
    <declaration type="D1Submatrix64F" name="W" />
    <declaration type="D1Submatrix64F" name="WTA" />
    <declaration type="double" name="temp" />
    <declaration type="double" name="gammas" />
    <declaration type="boolean" name="saveW" />
    <javadoc>
      <text>* This is the input matrix after it has been overwritten with the decomposition.</text>
      <return>Internal matrix used to store decomposition.</return>
    </javadoc>
    <method type="BlockMatrix64F" name="getQR" startLine="93" endLine="95" />
    <javadoc>
      <text>* <p>
 * Sets if it should internally save the W matrix before performing the decomposition.  Must
 * be set before decomposition the matrix.
 * </p>
 * <p>
 * Saving W can result in about a 5% savings when solving systems around a height of 5k.  The
 * price is that it needs to save a matrix the size of the input matrix.
 * </p></text>
      <param>saveW If the W matrix should be saved or not.</param>
    </javadoc>
    <method type="void" name="setSaveW" startLine="110" endLine="112" />
    <javadoc>
      <inheritDoc />
    </javadoc>
    <method type="BlockMatrix64F" name="getQ" startLine="118" endLine="124" />
    <javadoc>
      <text>* Sanity checks the input or declares a new matrix.  Return matrix is an identity matrix.</text>
    </javadoc>
    <method type="BlockMatrix64F" name="initializeQ" startLine="131" endLine="157">
      <declaration type="int" name="minLength" />
      <scope startLine="133" endLine="144">
        <scope startLine="134" endLine="137" />
        <scope startLine="137" endLine="143">
          <scope startLine="138" endLine="140" />
          <scope startLine="140" endLine="142" />
        </scope>
      </scope>
      <scope startLine="144" endLine="155">
        <scope startLine="145" endLine="148" />
        <scope startLine="148" endLine="154">
          <scope startLine="149" endLine="151" />
          <scope startLine="151" endLine="153" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Multiplies the provided matrix by Q using householder reflectors.  This is more
 * efficient that computing Q then applying it to the matrix.
 * </p>
 * <p>
 * B = Q * B
 * </p></text>
      <param>B Matrix which Q is applied to.  Modified.</param>
    </javadoc>
    <method type="void" name="applyQ" startLine="171" endLine="173" />
    <javadoc>
      <text>* Specialized version of applyQ() that allows the zeros in an identity matrix
 * to be taken advantage of depending on if isIdentity is true or not.</text>
      <param>B</param>
      <param>isIdentity If B is an identity matrix.</param>
    </javadoc>
    <method type="void" name="applyQ" startLine="182" endLine="220">
      <declaration type="int" name="minDimen" />
      <declaration type="D1Submatrix64F" name="subB" />
      <declaration type="int" name="start" />
      <scope startLine="198" endLine="219">
        <comment>Compute W matrix from reflectors stored in Y</comment>
        <comment>Apply the Qi to Q</comment>
      </scope>
      <comment>(Q1^T * (Q2^T * (Q3^t * A)))</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Multiplies the provided matrix by Q<sup>T</sup> using householder reflectors.  This is more
 * efficient that computing Q then applying it to the matrix.
 * </p>
 * <p>
 * Q = Q*(I - &gamma; W*Y^T)<br>
 * QR = A => R = Q^T*A  = (Q3^T * (Q2^T * (Q1^t * A)))
 * </p></text>
      <param>B Matrix which Q is applied to.  Modified.</param>
    </javadoc>
    <method type="void" name="applyQTran" startLine="235" endLine="272">
      <declaration type="int" name="minDimen" />
      <declaration type="D1Submatrix64F" name="subB" />
      <scope startLine="245" endLine="271">
        <comment>subB.row1 = B.numRows;</comment>
        <comment>subB.col0 = 0;</comment>
        <comment>subB.col1 = B.numCols;</comment>
        <comment>W.original.reshape(W.row1,W.col1,false);</comment>
        <comment>Compute W matrix from reflectors stored in Y</comment>
        <comment>Apply the Qi to Q</comment>
      </scope>
      <comment>(Q3^T * (Q2^T * (Q1^t * A)))</comment>
    </method>
    <javadoc>
      <inheritDoc />
    </javadoc>
    <method type="BlockMatrix64F" name="getR" startLine="278" endLine="301">
      <declaration type="int" name="min" />
      <scope startLine="281" endLine="287">
        <scope startLine="282" endLine="284" />
        <scope startLine="284" endLine="286" />
      </scope>
      <scope startLine="287" endLine="295">
        <scope startLine="288" endLine="292">
          <scope startLine="289" endLine="291" />
        </scope>
        <scope startLine="292" endLine="294" />
      </scope>
    </method>
    <javadoc>
      <inheritDoc />
    </javadoc>
    <method type="boolean" name="decompose" startLine="307" endLine="329">
      <declaration type="int" name="m" />
      <scope startLine="313" endLine="326">
        <scope startLine="320" endLine="322" />
        <comment>compute the QR decomposition of the left most block column</comment>
        <comment>this overwrites the original input matrix</comment>
        <comment>Update the remainder of the matrix using the reflectors just computed</comment>
      </scope>
      <comment>process the matrix one column block at a time and overwrite the input matrix</comment>
    </method>
    <javadoc>
      <text>* Adjust submatrices and helper data structures for the input matrix.  Must be called
 * before the decomposition can be computed.</text>
      <param>orig</param>
    </javadoc>
    <method type="void" name="setup" startLine="337" endLine="358">
      <declaration type="int" name="l" />
      <scope startLine="355" endLine="357" />
    </method>
    <javadoc>
      <text>* <p>
 * A = (I + W Y<sup>T</sup>)<sup>T</sup>A<BR>
 * A = A + Y (W<sup>T</sup>A)<BR>
 * <br>
 * where A is a submatrix of the input matrix.
 * </p></text>
    </javadoc>
    <method type="void" name="updateA" startLine="369" endLine="391">
      <scope startLine="383" endLine="388" />
      <scope startLine="388" endLine="390" />
    </method>
    <javadoc>
      <text>* Sets the submatrix of W up give Y is already configured and if it is being cached or not.</text>
    </javadoc>
    <method type="void" name="setW" startLine="396" endLine="406">
      <scope startLine="397" endLine="402" />
      <scope startLine="402" endLine="405" />
    </method>
    <javadoc>
      <text>* The input matrix is always modified.</text>
      <return>Returns true since the input matrix is modified.</return>
    </javadoc>
    <method type="boolean" name="inputModified" startLine="414" endLine="416" />
    <comment>the input matrix which is overwritten with the decomposition.</comment>
    <comment>Reflectors are stored in the lower triangular portion. The R matrix is stored</comment>
    <comment>in the upper triangle portion</comment>
    <comment>where the computed W matrix is stored</comment>
    <comment>Matrix used to store an intermediate calculation</comment>
    <comment>size of the inner matrix block.</comment>
    <comment>The submatrices which are being manipulated in each iteration</comment>
    <comment>stores the computed gammas</comment>
    <comment>save the W matrix the first time it is computed in the decomposition</comment>
  </class>
</source>
