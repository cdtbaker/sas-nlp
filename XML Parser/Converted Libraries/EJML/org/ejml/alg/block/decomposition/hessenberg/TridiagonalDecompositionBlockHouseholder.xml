<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.block.decomposition.hessenberg">
  <import name="org.ejml.alg.block.BlockMultiplication" />
  <import name="org.ejml.alg.block.decomposition.qr.BlockMatrix64HouseholderQR" />
  <import name="org.ejml.alg.dense.decomposition.hessenberg.TridiagonalSimilarDecomposition" />
  <import name="org.ejml.data.BlockMatrix64F" />
  <import name="org.ejml.data.D1Submatrix64F" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.ops.CommonOps" />
  <import name="static org.ejml.alg.block.BlockInnerMultiplication.blockMultPlusTransA" />
  <class name="TridiagonalDecompositionBlockHouseholder" startLine="32">
    <implements name="TridiagonalSimilarDecomposition<BlockMatrix64F>" />
    <javadoc>
      <text>* <p>
 * Tridiagonal similar decomposition for block matrices.  Orthogonal matrices are computed using
 * householder vectors.
 * </p>
 * <p>
 * Based off algorithm in section 2 of J. J. Dongarra, D. C. Sorensen, S. J. Hammarling,
 * "Block Reduction of Matrices to Condensed Forms for Eigenvalue Computations" Journal of
 * Computations and Applied Mathematics 27 (1989) 215-227<b>
 * <br>
 * Computations of Householder reflectors has been modified from what is presented in that paper to how 
 * it is performed in "Fundamentals of Matrix Computations" 2nd ed. by David S. Watkins.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <declaration type="BlockMatrix64F" name="A" />
    <declaration type="BlockMatrix64F" name="V" />
    <declaration type="BlockMatrix64F" name="tmp" />
    <declaration type="double" name="gammas" />
    <declaration type="DenseMatrix64F" name="zerosM" />
    <method type="BlockMatrix64F" name="getT" startLine="65" endLine="84">
      <scope startLine="66" endLine="68" />
      <scope startLine="68" endLine="73" />
      <scope startLine="76" endLine="81">
        <declaration type="double" name="d" />
      </scope>
    </method>
    <method type="BlockMatrix64F" name="getQ" startLine="87" endLine="162">
      <declaration type="int" name="height" />
      <declaration type="D1Submatrix64F" name="subQ" />
      <declaration type="D1Submatrix64F" name="subU" />
      <declaration type="D1Submatrix64F" name="subW" />
      <declaration type="D1Submatrix64F" name="tmp" />
      <declaration type="int" name="N" />
      <declaration type="int" name="start" />
      <scope startLine="109" endLine="159">
        <declaration type="int" name="blockSize" />
        <scope startLine="116" endLine="121" />
        <scope startLine="121" endLine="124" />
        <comment>zeros and ones are saved and overwritten in U so that standard matrix multiplication can be used</comment>
        <comment>compute W for Q(i) = ( I + W*Y^T)</comment>
        <comment>Apply the Qi to Q</comment>
        <comment>Qi = I + W*U^T</comment>
        <comment>Note that U and V are really row vectors.  but standard notation assumed they are column vectors.</comment>
        <comment>which is why the functions called don't match the math above</comment>
        <comment>(I + W*U^T)*Q</comment>
        <comment>F=U^T*Q(i)</comment>
        <comment>Q(i+1) = Q(i) + W*F</comment>
      </scope>
      <comment>(Q1^T * (Q2^T * (Q3^t * A)))</comment>
    </method>
    <method type="void" name="copyZeros" startLine="164" endLine="178">
      <declaration type="int" name="N" />
      <scope startLine="166" endLine="177">
        <scope startLine="168" endLine="171" />
        <scope startLine="173" endLine="176" />
        <comment>save the zeros</comment>
        <comment>save the one</comment>
      </scope>
    </method>
    <method type="void" name="replaceZeros" startLine="180" endLine="192">
      <declaration type="int" name="N" />
      <scope startLine="182" endLine="191">
        <scope startLine="184" endLine="186" />
        <scope startLine="188" endLine="190" />
        <comment>save the zeros</comment>
        <comment>save the one</comment>
      </scope>
    </method>
    <method type="void" name="getDiagonal" startLine="195" endLine="201">
      <scope startLine="197" endLine="200" />
    </method>
    <method type="boolean" name="decompose" startLine="204" endLine="248">
      <declaration type="D1Submatrix64F" name="subA" />
      <declaration type="D1Submatrix64F" name="subV" />
      <declaration type="D1Submatrix64F" name="subU" />
      <declaration type="int" name="N" />
      <scope startLine="216" endLine="245">
        <declaration type="int" name="height" />
        <scope startLine="234" endLine="244">
          <declaration type="double" name="before" />
        </scope>
        <comment>System.out.println("-------- triag i "+i);</comment>
        <comment>bidiagonalize the top row</comment>
        <comment>apply Householder reflectors to the lower portion using block multiplication</comment>
        <comment>take in account the 1 in the last row.  The others are skipped over.</comment>
        <comment>A = A + U*V^T + V*U^T</comment>
      </scope>
    </method>
    <javadoc>
      <text>* C = C + A^T*B</text>
      <param>blockLength</param>
      <param>A row block vector</param>
      <param>B row block vector</param>
      <param>C</param>
    </javadoc>
    <method type="void" name="multPlusTransA" startLine="261" endLine="279">
      <declaration type="int" name="heightA" />
      <scope startLine="264" endLine="278">
        <declaration type="int" name="heightC" />
        <declaration type="int" name="indexA" />
        <scope startLine="269" endLine="277">
          <declaration type="int" name="widthC" />
          <declaration type="int" name="indexC" />
          <declaration type="int" name="indexB" />
        </scope>
      </scope>
    </method>
    <method type="void" name="init" startLine="281" endLine="292">
      <declaration type="int" name="height" />
    </method>
    <method type="boolean" name="inputModified" startLine="295" endLine="297" />
    <comment>matrix which is being decomposed</comment>
    <comment>householder vectors are stored along the upper triangle rows</comment>
    <comment>temporary storage for block computations</comment>
    <comment>stores intermediate results in matrix multiplication</comment>
    <comment>temporary storage for zeros and ones in U</comment>
  </class>
</source>
