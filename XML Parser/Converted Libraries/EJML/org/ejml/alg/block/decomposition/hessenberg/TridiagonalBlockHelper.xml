<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.block.decomposition.hessenberg">
  <import name="org.ejml.alg.block.BlockVectorOps" />
  <import name="org.ejml.alg.block.decomposition.qr.BlockHouseHolder" />
  <import name="org.ejml.data.D1Submatrix64F" />
  <import name="org.ejml.ops.CommonOps" />
  <import name="static org.ejml.alg.block.decomposition.qr.BlockHouseHolder.computeHouseHolderRow" />
  <class name="TridiagonalBlockHelper" startLine="29">
    <javadoc>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* <p>
 * Performs a tridiagonal decomposition on the upper row only.
 * </p>
 * <p>
 * For each row 'a' in 'A':
 * Compute 'u' the householder reflector.
 * y(:) = A*u
 * v(i) = y - (1/2)*(y^T*u)*u
 * a(i+1) = a(i) - u*&gamma;*v^T - v*u^t
 * </p></text>
      <param>blockLength Size of a block</param>
      <param>A is the row block being decomposed.  Modified.</param>
      <param>gammas Householder gammas.</param>
      <param>V Where computed 'v' are stored in a row block.  Modified.</param>
    </javadoc>
    <method type="void" name="tridiagUpperRow" startLine="56" endLine="81">
      <declaration type="int" name="blockHeight" />
      <declaration type="int" name="width" />
      <declaration type="int" name="num" />
      <declaration type="int" name="applyIndex" />
      <scope startLine="65" endLine="80">
        <declaration type="double" name="gamma" />
        <scope startLine="77" endLine="79" />
        <comment>compute the new reflector and save it in a row in 'A'</comment>
        <comment>compute y</comment>
        <comment>compute v from y</comment>
        <comment>Apply the reflectors to the next row in 'A' only</comment>
      </scope>
      <comment>step through rows in the block</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Computes W from the householder reflectors stored in the columns of the row block
 * submatrix Y.
 * </p>
 * <p>
 * Y = v<sup>(1)</sup><br>
 * W = -&beta;<sub>1</sub>v<sup>(1)</sup><br>
 * for j=2:r<br>
 * &nbsp;&nbsp;z = -&beta;(I +WY<sup>T</sup>)v<sup>(j)</sup> <br>
 * &nbsp;&nbsp;W = [W z]<br>
 * &nbsp;&nbsp;Y = [Y v<sup>(j)</sup>]<br>
 * end<br>
 * <br>
 * where v<sup>(.)</sup> are the house holder vectors, and r is the block length.  Note that
 * Y already contains the householder vectors so it does not need to be modified.
 * </p>
 * <p>
 * Y and W are assumed to have the same number of rows and columns.
 * </p></text>
    </javadoc>
    <method type="void" name="computeW_row" startLine="108" endLine="132">
      <declaration type="int" name="heightY" />
      <declaration type="int" name="min" />
      <scope startLine="119" endLine="131">
        <declaration type="double" name="b" />
        <scope startLine="124" endLine="127">
          <declaration type="double" name="yv" />
        </scope>
        <comment>w=-beta*(I + W*Y^T)*u</comment>
        <comment>w = w -beta*W*(Y^T*u)</comment>
        <comment>w=w -beta*u + stuff above</comment>
      </scope>
      <comment>W = -beta*v(1)</comment>
      <comment>set up rest of the rows</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Given an already computed tridiagonal decomposition, compute the V row block vector.<br>
 * <br>
 * y(:) = A*u<br>
 * v(i) = y - (1/2)*&gamma;*(y^T*u)*u
 * </p></text>
    </javadoc>
    <method type="void" name="computeV_blockVector" startLine="147" endLine="163">
      <declaration type="int" name="blockHeight" />
      <declaration type="int" name="width" />
      <declaration type="int" name="num" />
      <scope startLine="154" endLine="162">
        <declaration type="double" name="gamma" />
        <comment>compute y</comment>
        <comment>compute v from y</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Applies the reflectors that have been computed previously to the specified row.
 * <br>
 * A = A + u*v^T + v*u^T only along the specified row in A.
 * </p></text>
      <param>blockLength</param>
      <param>A Contains the reflectors and the row being updated.</param>
      <param>V Contains previously computed 'v' vectors.</param>
      <param>row The row of 'A' that is to be updated.</param>
    </javadoc>
    <method type="void" name="applyReflectorsToRow" startLine="181" endLine="209">
      <declaration type="int" name="height" />
      <declaration type="double[]" name="dataA" />
      <declaration type="double[]" name="dataV" />
      <declaration type="int" name="indexU" />
      <scope startLine="190" endLine="208">
        <declaration type="int" name="width" />
        <declaration type="double" name="u_row" />
        <declaration type="double" name="v_row" />
        <declaration type="double" name="before" />
        <comment>take in account the leading one</comment>
        <comment>grab only the relevant row from A = A + u*v^T + v*u^T</comment>
      </scope>
      <comment>for each previously computed reflector</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the 'y' vector and stores the result in 'v'<br>
 * <br>
 * y = -&gamma;(A + U*V^T + V*U^T)u
 * </p></text>
      <param>blockLength</param>
      <param>A Contains the reflectors and the row being updated.</param>
      <param>V Contains previously computed 'v' vectors.</param>
      <param>row The row of 'A' that is to be updated.</param>
    </javadoc>
    <method type="void" name="computeY" startLine="228" endLine="255">
      <scope startLine="234" endLine="251">
        <declaration type="double" name="dot_v_u" />
        <declaration type="double" name="dot_u_u" />
        <comment>y = y + u_i*v_i^t*u + v_i*u_i^t*u</comment>
        <comment>v_i^t*u</comment>
        <comment>u_i^t*u</comment>
        <comment>y = y + u_i*(v_i^t*u)</comment>
        <comment>the ones in these 'u' are skipped over since the next submatrix of A</comment>
        <comment>is only updated</comment>
        <comment>y = y + v_i*(u_i^t*u)</comment>
        <comment>the 1 in U is taken account above</comment>
      </scope>
      <comment>Elements in 'y' before 'row' are known to be zero and the element at 'row'</comment>
      <comment>is not used. Thus only elements after row and after are computed.</comment>
      <comment>y = A*u</comment>
      <comment>y = -gamma*y</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Multiples the appropriate submatrix of A by the specified reflector and stores
 * the result ('y') in V.<br>
 * <br>
 * y = A*u<br>
 * </p></text>
      <param>blockLength</param>
      <param>A Contains the 'A' matrix and 'u' vector.</param>
      <param>V Where resulting 'y' row vectors are stored.</param>
      <param>row row in matrix 'A' that 'u' vector and the row in 'V' that 'y' is stored in.</param>
    </javadoc>
    <method type="void" name="multA_u" startLine="274" endLine="283">
      <declaration type="int" name="heightMatA" />
      <scope startLine="277" endLine="282">
        <declaration type="double" name="val" />
      </scope>
    </method>
    <method type="double" name="innerProdRowSymm" startLine="289" endLine="310">
      <declaration type="int" name="offset" />
      <scope startLine="294" endLine="302">
        <declaration type="double" name="total" />
        <comment>take in account the one in 'A'</comment>
      </scope>
      <scope startLine="302" endLine="309">
        <declaration type="double" name="total" />
        <comment>take in account the one in 'A'</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Final computation for a single row of 'v':<br>
 * <br>
 * v = y -(1/2)&gamma;(y^T*u)*u
 * </p></text>
      <param>blockLength</param>
      <param>A</param>
      <param>V</param>
      <param>row</param>
      <param>gamma</param>
    </javadoc>
    <method type="void" name="computeRowOfV" startLine="330" endLine="342">
      <declaration type="double" name="val" />
      <declaration type="double" name="before" />
      <comment>val=(y^T*u)</comment>
      <comment>take in account the one</comment>
      <comment>v = y - (1/2)gamma*val * u</comment>
    </method>
  </class>
</source>
