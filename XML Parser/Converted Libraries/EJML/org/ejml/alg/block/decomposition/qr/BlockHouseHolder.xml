<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.alg.block.decomposition.qr">
  <import name="org.ejml.alg.block.BlockInnerMultiplication" />
  <import name="org.ejml.alg.block.BlockVectorOps" />
  <import name="org.ejml.data.D1Submatrix64F" />
  <class name="BlockHouseHolder" startLine="25">
    <javadoc>
      <text>* <p>
 * Contains various helper functions for performing a block matrix QR decomposition.
 * </p>
 * <p>
 * Assumptions:
 * <ul>
 * <le> All submatrices are aligned along the inner blocks of the {@link org.ejml.data.BlockMatrix64F}.
 * <le> Some times vectors are assumed to have leading zeros and a one.
 * </ul></text>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* Performs a standard QR decomposition on the specified submatrix that is one block wide.</text>
      <param>blockLength</param>
      <param>Y</param>
      <param>gamma</param>
    </javadoc>
    <method type="boolean" name="decomposeQR_block_col" startLine="52" endLine="66">
      <declaration type="int" name="width" />
      <declaration type="int" name="height" />
      <declaration type="int" name="min" />
      <scope startLine="56" endLine="63">
        <comment>compute the householder vector</comment>
        <comment>apply to rest of the columns in the block</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the householder vector that is used to create reflector for the column.
 * The results are stored in the original matrix.
 * </p>
 * <p>
 * The householder vector 'u' is computed as follows:<br>
 * <br>
 * u(1) = 1 <br>
 * u(i) = x(i)/(&tau; + x(1))<br>
 * </p>
 * The first element is implicitly assumed to be one and not written.</text>
      <return>If there was any problems or not. true = no problem.</return>
    </javadoc>
    <method type="boolean" name="computeHouseHolderCol" startLine="86" endLine="106">
      <declaration type="double" name="max" />
      <scope startLine="89" endLine="91" />
      <scope startLine="91" endLine="104">
        <declaration type="double" name="tau" />
        <declaration type="double" name="u_0" />
        <comment>computes tau and normalizes u by max</comment>
        <comment>divide u by u_0</comment>
        <comment>after the reflector is applied the column would be all zeros but be -tau in the first element</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the householder vector from the specified row
 * </p>
 * <p>
 * The householder vector 'u' is computed as follows:<br>
 * <br>
 * u(1) = 1 <br>
 * u(i) = x(i)/(&tau; + x(1))<br>
 * </p>
 * The first element is implicitly assumed to be one and not written.</text>
      <return>If there was any problems or not. true = no problem.</return>
    </javadoc>
    <method type="boolean" name="computeHouseHolderRow" startLine="125" endLine="144">
      <declaration type="double" name="max" />
      <scope startLine="128" endLine="130" />
      <scope startLine="130" endLine="142">
        <declaration type="double" name="tau" />
        <declaration type="double" name="u_0" />
        <comment>computes tau and normalizes u by max</comment>
        <comment>divide u by u_0</comment>
        <comment>after the reflector is applied the column would be all zeros but be -tau in the first element</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Applies a householder reflector stored in column 'col' to the remainder of the columns
 * in the block after it.  Takes in account leading zeros and one.<br>
 * <br>
 * A = (I - &gamma;*u*u<sup>T</sup>)*A<br>
 * </p></text>
      <param>A submatrix that is at most one block wide and aligned along inner blocks</param>
      <param>col The column in A containing 'u'</param>
    </javadoc>
    <method type="void" name="rank1UpdateMultR_Col" startLine="160" endLine="199">
      <declaration type="int" name="width" />
      <declaration type="double[]" name="dataA" />
      <scope startLine="165" endLine="198">
        <declaration type="double" name="total" />
        <scope startLine="173" endLine="197">
          <declaration type="int" name="height" />
          <declaration type="int" name="indexU" />
          <declaration type="int" name="indexA" />
          <scope startLine="179" endLine="190">
            <scope startLine="187" endLine="189" />
          </scope>
          <scope startLine="190" endLine="196">
            <declaration type="int" name="endU" />
            <scope startLine="193" endLine="195" />
          </scope>
        </scope>
        <comment>total = U^T * A(:,j)</comment>
        <comment>A(:,j) - gamma*U*total</comment>
        <comment>for( int k = 0; k < height; k++</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Applies a householder reflector stored in column 'col' to the top block row (excluding
 * the first column) of A.  Takes in account leading zeros and one.<br>
 * <br>
 * A = (I - &gamma;*u*u<sup>T</sup>)*A<br>
 * </p></text>
      <param>A submatrix that is at most one block wide and aligned along inner blocks</param>
      <param>col The column in A containing 'u'</param>
    </javadoc>
    <method type="void" name="rank1UpdateMultR_TopRow" startLine="215" endLine="249">
      <declaration type="double[]" name="dataA" />
      <declaration type="int" name="widthCol" />
      <scope startLine="221" endLine="248">
        <declaration type="int" name="widthJ" />
        <scope startLine="224" endLine="247">
          <declaration type="double" name="total" />
          <declaration type="int" name="i" />
          <declaration type="int" name="height" />
          <declaration type="int" name="indexU" />
          <declaration type="int" name="indexA" />
          <scope startLine="244" endLine="246" />
        </scope>
        <comment>total = U^T * A(:,j) * gamma</comment>
        <comment>A(:,j) - gamma*U*total</comment>
        <comment>just update the top most block</comment>
        <comment>take in account zeros and one</comment>
      </scope>
      <comment>step through columns in top block, skipping over the first block</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Applies a householder reflector stored in row 'row' to the remainder of the row
 * in the block after it.  Takes in account leading zeros and one.<br>
 * <br>
 * A = A*(I - &gamma;*u*u<sup>T</sup>)<br>
 * </p></text>
      <param>A submatrix that is block aligned</param>
      <param>row The row in A containing 'u'</param>
      <param>colStart First index in 'u' that the reflector starts at</param>
    </javadoc>
    <method type="void" name="rank1UpdateMultL_Row" startLine="267" endLine="303">
      <declaration type="int" name="height" />
      <declaration type="double[]" name="dataA" />
      <declaration type="int" name="zeroOffset" />
      <scope startLine="274" endLine="302">
        <declaration type="double" name="total" />
        <scope startLine="281" endLine="301">
          <declaration type="int" name="width" />
          <declaration type="int" name="indexU" />
          <declaration type="int" name="indexA" />
          <scope startLine="287" endLine="296">
            <scope startLine="293" endLine="295" />
          </scope>
          <scope startLine="296" endLine="300">
            <scope startLine="297" endLine="299" />
          </scope>
        </scope>
        <comment>total = U^T * A(i,:)</comment>
        <comment>A(i,:) - gamma*U*total</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Applies a householder reflector stored in row 'row' to the left column block.
 * Takes in account leading zeros and one.<br>
 * <br>
 * A = A*(I - &gamma;*u*u<sup>T</sup>)<br>
 * </p></text>
      <param>A submatrix that is block aligned</param>
      <param>row The row in A containing 'u'</param>
      <param>zeroOffset How far off the diagonal is the first element in 'u'</param>
    </javadoc>
    <method type="void" name="rank1UpdateMultL_LeftCol" startLine="321" endLine="355">
      <declaration type="int" name="heightU" />
      <declaration type="int" name="width" />
      <declaration type="double[]" name="data" />
      <scope startLine="327" endLine="354">
        <declaration type="int" name="heightA" />
        <scope startLine="330" endLine="353">
          <declaration type="double" name="total" />
          <declaration type="int" name="indexU" />
          <declaration type="int" name="indexA" />
          <scope startLine="349" endLine="351" />
        </scope>
        <comment>total = U^T * A(i,:)</comment>
        <comment>A(i,:) - gamma*U*total</comment>
        <comment>plusScale_row(blockLength,);</comment>
        <comment>skip over zeros and assume first element in U is 1</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the inner product of column vector 'colA' against column vector 'colB' while taking account leading zeros and one.<br>
 * <br>
 * ret = a<sup>T*b
 * </p>
 * <p>
 * Column A is assumed to be a householder vector.  Element at 'colA' is one and previous ones are zero.
 * </p></text>
      <param>blockLength</param>
      <param>A block aligned submatrix.</param>
      <param>colA Column inside the block of first column vector.</param>
      <param>widthA how wide the column block that colA is inside of.</param>
      <param>colB Column inside the block of second column vector.</param>
      <param>widthB how wide the column block that colB is inside of.</param>
      <return>dot product of the two vectors.</return>
    </javadoc>
    <method type="double" name="innerProdCol" startLine="378" endLine="422">
      <declaration type="double" name="total" />
      <declaration type="double[]" name="data" />
      <declaration type="int" name="colBlockA" />
      <declaration type="int" name="colBlockB" />
      <scope startLine="389" endLine="420">
        <declaration type="int" name="height" />
        <declaration type="int" name="indexA" />
        <declaration type="int" name="indexB" />
        <scope startLine="396" endLine="412">
          <declaration type="int" name="endA" />
          <scope startLine="408" endLine="411" />
        </scope>
        <scope startLine="412" endLine="419">
          <declaration type="int" name="endA" />
          <scope startLine="416" endLine="418" />
        </scope>
        <comment>handle leading zeros</comment>
        <comment>handle leading one</comment>
        <comment>standard vector dot product</comment>
        <comment>for( int k = col+1; k < height; k++ , indexU += width, indexA += width ) {</comment>
        <comment>standard vector dot product</comment>
        <comment>for( int k = 0; k < height; k++ ) {</comment>
      </scope>
      <comment>first column in the blocks</comment>
      <comment>compute dot product down column vectors</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the inner product of row vector 'rowA' against row vector 'rowB' while taking account leading zeros and one.<br>
 * <br>
 * ret = a<sup>T</sup>*b
 * </p>
 * <p>
 * Row A is assumed to be a householder vector.  Element at 'colStartA' is one and previous elements are zero.
 * </p></text>
      <param>blockLength</param>
      <param>A block aligned submatrix.</param>
      <param>rowA Row index inside the sub-matrix of first row vector has zeros and ones..</param>
      <param>rowB Row index inside the sub-matrix of second row vector.</param>
      <return>dot product of the two vectors.</return>
    </javadoc>
    <method type="double" name="innerProdRow" startLine="445" endLine="456">
      <declaration type="int" name="offset" />
      <declaration type="double" name="total" />
      <comment>take in account the one in 'A'</comment>
    </method>
    <method type="void" name="add_row" startLine="462" endLine="471">
      <declaration type="int" name="offset" />
      <comment>handle leading one</comment>
    </method>
    <javadoc>
      <text>* Divides the elements at the specified column by 'val'.  Takes in account
 * leading zeros and one.</text>
    </javadoc>
    <method type="void" name="divideElementsCol" startLine="478" endLine="502">
      <declaration type="int" name="width" />
      <declaration type="double[]" name="dataY" />
      <scope startLine="483" endLine="501">
        <declaration type="int" name="height" />
        <declaration type="int" name="index" />
        <scope startLine="488" endLine="494">
          <scope startLine="491" endLine="493" />
        </scope>
        <scope startLine="494" endLine="500">
          <declaration type="int" name="endIndex" />
          <scope startLine="497" endLine="499" />
        </scope>
        <comment>for( int k = 0; k < height; k++</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Scales the elements in the specified row starting at element colStart by 'val'.<br>
 * W = val*Y
 * Takes in account zeros and leading one automatically.</text>
      <param>zeroOffset How far off the diagonal is the first element in the vector.</param>
    </javadoc>
    <method type="void" name="scale_row" startLine="518" endLine="531">
      <declaration type="int" name="offset" />
      <comment>handle the one</comment>
      <comment>scale rest of the vector</comment>
    </method>
    <javadoc>
      <text>* <p>
 * From the specified column of Y tau is computed and each element is divided by 'max'.
 * See code below:
 * </p>
 * <pre>
 * for i=col:Y.numRows
 * Y[i][col] = u[i][col] / max
 * tau = tau + u[i][col]*u[i][col]
 * end
 * tau = sqrt(tau)
 * if( Y[col][col] < 0 )
 * tau = -tau;
 * </pre></text>
    </javadoc>
    <method type="double" name="computeTauAndDivideCol" startLine="552" endLine="590">
      <declaration type="int" name="width" />
      <declaration type="double[]" name="dataY" />
      <declaration type="double" name="top" />
      <declaration type="double" name="norm2" />
      <scope startLine="560" endLine="582">
        <declaration type="int" name="height" />
        <declaration type="int" name="index" />
        <scope startLine="565" endLine="576">
          <scope startLine="572" endLine="575">
            <declaration type="double" name="val" />
          </scope>
        </scope>
        <scope startLine="576" endLine="581">
          <scope startLine="577" endLine="580">
            <declaration type="double" name="val" />
          </scope>
        </scope>
        <comment>save this value so that the sign can be determined later on</comment>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * From the specified row of Y tau is computed and each element is divided by 'max'.
 * See code below:
 * </p>
 * <pre>
 * for j=row:Y.numCols
 * Y[row][j] = u[row][j] / max
 * tau = tau + u[row][j]*u[row][j]
 * end
 * tau = sqrt(tau)
 * if( Y[row][row] < 0 )
 * tau = -tau;
 * </pre></text>
      <param>row Which row in the block will be processed</param>
      <param>colStart The first column that computation of tau will start at</param>
      <param>max used to normalize and prevent buffer over flow</param>
    </javadoc>
    <method type="double" name="computeTauAndDivideRow" startLine="615" endLine="656">
      <declaration type="int" name="height" />
      <declaration type="double[]" name="dataY" />
      <declaration type="double" name="top" />
      <declaration type="double" name="norm2" />
      <declaration type="int" name="startJ" />
      <scope startLine="626" endLine="648">
        <declaration type="int" name="width" />
        <declaration type="int" name="index" />
        <scope startLine="631" endLine="642">
          <scope startLine="638" endLine="641">
            <declaration type="double" name="val" />
          </scope>
        </scope>
        <scope startLine="642" endLine="647">
          <scope startLine="643" endLine="646">
            <declaration type="double" name="val" />
          </scope>
        </scope>
        <comment>save this value so that the sign can be determined later on</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Finds the element in the column with the largest absolute value. The offset
 * from zero is automatically taken in account based on the column.</text>
    </javadoc>
    <method type="double" name="findMaxCol" startLine="663" endLine="694">
      <declaration type="int" name="width" />
      <declaration type="double[]" name="dataY" />
      <declaration type="double" name="max" />
      <scope startLine="670" endLine="691">
        <declaration type="int" name="height" />
        <declaration type="int" name="index" />
        <scope startLine="675" endLine="683">
          <scope startLine="677" endLine="682">
            <declaration type="double" name="v" />
            <scope startLine="679" endLine="681" />
          </scope>
        </scope>
        <scope startLine="683" endLine="690">
          <scope startLine="684" endLine="689">
            <declaration type="double" name="v" />
            <scope startLine="686" endLine="688" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Finds the element in the column with the largest absolute value. The offset
 * from zero is automatically taken in account based on the column.</text>
    </javadoc>
    <method type="double" name="findMaxRow" startLine="702" endLine="734">
      <declaration type="int" name="height" />
      <declaration type="double[]" name="dataY" />
      <declaration type="double" name="max" />
      <scope startLine="709" endLine="731">
        <declaration type="int" name="width" />
        <declaration type="int" name="index" />
        <scope startLine="714" endLine="723">
          <scope startLine="717" endLine="722">
            <declaration type="double" name="v" />
            <scope startLine="719" endLine="721" />
          </scope>
        </scope>
        <scope startLine="723" endLine="730">
          <scope startLine="724" endLine="729">
            <declaration type="double" name="v" />
            <scope startLine="726" endLine="728" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Computes W from the householder reflectors stored in the columns of the column block
 * submatrix Y.
 * </p>
 * <p>
 * Y = v<sup>(1)</sup><br>
 * W = -&beta;<sub>1</sub>v<sup>(1)</sup><br>
 * for j=2:r<br>
 * &nbsp;&nbsp;z = -&beta;(I +WY<sup>T</sup>)v<sup>(j)</sup> <br>
 * &nbsp;&nbsp;W = [W z]<br>
 * &nbsp;&nbsp;Y = [Y v<sup>(j)</sup>]<br>
 * end<br>
 * <br>
 * where v<sup>(.)</sup> are the house holder vectors, and r is the block length.  Note that
 * Y already contains the householder vectors so it does not need to be modified.
 * </p>
 * <p>
 * Y and W are assumed to have the same number of rows and columns.
 * </p></text>
      <param>Y Input matrix containing householder vectors.  Not modified.</param>
      <param>W Resulting W matrix. Modified.</param>
      <param>temp Used internally.  Must have W.numCols elements.</param>
      <param>beta Beta's for householder vectors.</param>
      <param>betaIndex Index of first relevant beta.</param>
    </javadoc>
    <method type="void" name="computeW_Column" startLine="767" endLine="782">
      <declaration type="int" name="widthB" />
      <declaration type="int" name="min" />
      <scope startLine="777" endLine="781">
        <comment>compute the z vector and insert it into W</comment>
      </scope>
      <comment>set the first column in W</comment>
      <comment>set up rest of the columns</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Sets W to its initial value using the first column of 'y' and the value of 'b':
 * <br>
 * W = -&beta;v<br>
 * <br>
 * where v = Y(:,0).
 * </p></text>
      <param>blockLength size of the inner block</param>
      <param>W Submatrix being initialized.</param>
      <param>Y Contains householder vector</param>
      <param>widthB How wide the W block matrix is.</param>
      <param>b beta</param>
    </javadoc>
    <method type="void" name="initializeW" startLine="801" endLine="826">
      <declaration type="double[]" name="dataW" />
      <declaration type="double[]" name="dataY" />
      <scope startLine="806" endLine="825">
        <declaration type="int" name="heightW" />
        <declaration type="int" name="indexW" />
        <declaration type="int" name="indexY" />
        <scope startLine="813" endLine="820">
          <scope startLine="817" endLine="819" />
        </scope>
        <scope startLine="820" endLine="824">
          <scope startLine="821" endLine="823" />
        </scope>
        <comment>take in account the first element in V being 1</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Computes the vector z and inserts it into 'W':<br>
 * <br>
 * z = - &beta;<sub>j</sub>*(V<sup>j</sup> + W*h)<br>
 * <br>
 * where h is a vector of length 'col' and was computed using {@link #computeY_t_V}.
 * V is a column in the Y matrix. Z is a column in the W matrix.  Both Z and V are
 * column 'col'.</text>
    </javadoc>
    <method type="void" name="computeZ" startLine="839" endLine="893">
      <declaration type="int" name="width" />
      <declaration type="double[]" name="dataW" />
      <declaration type="double[]" name="dataY" />
      <declaration type="int" name="colsW" />
      <declaration type="double" name="beta_neg" />
      <scope startLine="849" endLine="892">
        <declaration type="int" name="heightW" />
        <declaration type="int" name="indexW" />
        <declaration type="int" name="indexZ" />
        <declaration type="int" name="indexV" />
        <scope startLine="856" endLine="875">
          <scope startLine="858" endLine="874">
            <declaration type="double" name="total" />
            <scope startLine="862" endLine="864" />
            <scope startLine="867" endLine="869" />
            <scope startLine="869" endLine="871" />
            <scope startLine="871" endLine="873" />
          </scope>
        </scope>
        <scope startLine="875" endLine="891">
          <declaration type="int" name="endZ" />
          <scope startLine="878" endLine="890">
            <declaration type="double" name="total" />
            <scope startLine="882" endLine="884" />
          </scope>
        </scope>
        <comment>handle the triangular portion with the leading zeros and the one</comment>
        <comment>compute the rows of W * h</comment>
        <comment>add the two vectors together and multiply by -beta</comment>
        <comment>zeros</comment>
        <comment>one</comment>
        <comment>normal data</comment>
        <comment>for( int k = 0; k < heightW; k++ ,</comment>
        <comment>compute the rows of W * h</comment>
        <comment>add the two vectors together and multiply by -beta</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Computes Y<sup>T</sup>v<sup>(j)</sup>.  Where Y are the columns before 'col' and v is the column
 * at 'col'.  The zeros and ones are taken in account.  The solution is a vector with 'col' elements.
 * width of Y must be along the block of original matrix A</text>
      <param>temp Temporary storage of least length 'col'</param>
    </javadoc>
    <method type="void" name="computeY_t_V" startLine="905" endLine="911">
      <declaration type="int" name="widthB" />
      <scope startLine="908" endLine="910" />
    </method>
    <javadoc>
      <text>* Special multiplication that takes in account the zeros and one in Y, which
 * is the matrix that stores the householder vectors.</text>
    </javadoc>
    <method type="void" name="multAdd_zeros" startLine="921" endLine="946">
      <declaration type="int" name="widthY" />
      <scope startLine="924" endLine="945">
        <declaration type="int" name="heightY" />
        <scope startLine="927" endLine="944">
          <declaration type="int" name="widthB" />
          <declaration type="int" name="indexC" />
          <scope startLine="932" endLine="943">
            <declaration type="int" name="indexY" />
            <declaration type="int" name="indexB" />
            <scope startLine="936" endLine="939" />
            <scope startLine="939" endLine="942" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Inner block mult add operation that takes in account the zeros and on in dataA,
 * which is the top part of the Y block vector that has the householder vectors.<br>
 * <br>
 * C = C + A * B
 * </p></text>
    </javadoc>
    <method type="void" name="multBlockAdd_zerosone" startLine="958" endLine="974">
      <scope startLine="961" endLine="973">
        <scope startLine="962" endLine="972">
          <declaration type="double" name="val" />
          <declaration type="int" name="end" />
          <scope startLine="967" endLine="969" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Performs a matrix multiplication on the block aligned submatrices.  A is
 * assumed to be block column vector that is lower triangular with diagonal elements set to 1.<br>
 * <br>
 * C = A^T * B
 * </p></text>
    </javadoc>
    <method type="void" name="multTransA_vecCol" startLine="987" endLine="1011">
      <declaration type="int" name="widthA" />
      <scope startLine="992" endLine="1010">
        <declaration type="int" name="widthB" />
        <declaration type="int" name="indexC" />
        <scope startLine="997" endLine="1009">
          <declaration type="int" name="heightA" />
          <declaration type="int" name="indexA" />
          <declaration type="int" name="indexB" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Performs a matrix multiplication on an single inner block where A is assumed to be lower triangular with diagonal
 * elements equal to 1.<br>
 * <br>
 * C = A^T * B</text>
    </javadoc>
    <method type="void" name="multTransABlockSet_lowerTriag" startLine="1021" endLine="1033">
      <scope startLine="1022" endLine="1032">
        <scope startLine="1023" endLine="1031">
          <declaration type="double" name="val" />
          <scope startLine="1026" endLine="1028" />
        </scope>
      </scope>
    </method>
  </class>
</source>
