<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.ops">
  <import name="org.ejml.UtilEjml" />
  <import name="org.ejml.alg.dense.decomposition.eig.EigenPowerMethod" />
  <import name="org.ejml.alg.dense.mult.VectorVectorMult" />
  <import name="org.ejml.data.Complex64F" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.data.Eigenpair" />
  <import name="org.ejml.factory.EigenDecomposition" />
  <import name="org.ejml.factory.LinearSolver" />
  <import name="org.ejml.factory.LinearSolverFactory" />
  <class name="EigenOps" startLine="32">
    <javadoc>
      <text>* Additional functions related to eigenvalues and eigenvectors of a matrix.</text>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* <p>
 * Given matrix A and an eigen vector of A, compute the corresponding eigen value.  This is
 * the Rayleigh quotient.<br>
 * <br>
 * x<sup>T</sup>Ax / x<sup>T</sup>x
 * </p></text>
      <param>A Matrix. Not modified.</param>
      <param>eigenVector An eigen vector of A. Not modified.</param>
      <return>The corresponding eigen value.</return>
    </javadoc>
    <method type="double" name="computeEigenValue" startLine="52" endLine="57">
      <declaration type="double" name="bottom" />
      <declaration type="double" name="top" />
    </method>
    <javadoc>
      <text>* <p>
 * Given an eigenvalue it computes an eigenvector using inverse iteration:
 * <br>
 * for i=1:MAX {<br>
 * (A - &mu;I)z<sup>(i)</sup> = q<sup>(i-1)</sup><br>
 * q<sup>(i)</sup> = z<sup>(i)</sup> / ||z<sup>(i)</sup>||<br>
 * &lambda;<sup>(i)</sup> =  q<sup>(i)</sup><sup>T</sup> A  q<sup>(i)</sup><br>
 * }<br>
 * </p>
 * <p>
 * NOTE: If there is another eigenvalue that is very similar to the provided one then there
 * is a chance of it converging towards that one instead.  The larger a matrix is the more
 * likely this is to happen.
 * </p></text>
      <param>A Matrix whose eigenvector is being computed.  Not modified.</param>
      <param>eigenvalue The eigenvalue in the eigen pair.</param>
      <return>The eigenvector or null if none could be found.</return>
    </javadoc>
    <method type="Eigenpair" name="computeEigenVector" startLine="79" endLine="168">
      <declaration type="DenseMatrix64F" name="M" />
      <declaration type="DenseMatrix64F" name="x" />
      <declaration type="DenseMatrix64F" name="b" />
      <declaration type="double" name="origEigenvalue" />
      <declaration type="double" name="threshold" />
      <declaration type="double" name="prevError" />
      <declaration type="boolean" name="hasWorked" />
      <declaration type="LinearSolver<DenseMatrix64F>" name="solver" />
      <declaration type="double" name="perp" />
      <scope startLine="106" endLine="165">
        <declaration type="boolean" name="failed" />
        <scope startLine="110" endLine="112" />
        <scope startLine="112" endLine="114" />
        <scope startLine="117" endLine="119" />
        <scope startLine="121" endLine="135">
          <scope startLine="122" endLine="130">
            <declaration type="double" name="val" />
          </scope>
          <scope startLine="130" endLine="134" />
        </scope>
        <scope startLine="135" endLine="164">
          <declaration type="double" name="error" />
          <scope startLine="145" endLine="153">
            <declaration type="double" name="val" />
          </scope>
          <scope startLine="153" endLine="161" />
        </scope>
        <comment>if the matrix is singular then the eigenvalue is within machine precision</comment>
        <comment>of the true value, meaning that x must also be.</comment>
        <comment>see if solve silently failed</comment>
        <comment>if it failed on the first trial try perturbing it some more</comment>
        <comment>maybe this should be turn into a parameter allowing the user</comment>
        <comment>to configure the wise of each step</comment>
        <comment>otherwise assume that it was so accurate that the matrix was singular</comment>
        <comment>and return that result</comment>
        <comment>compute the residual</comment>
        <comment>if the error increased it is probably converging towards a different</comment>
        <comment>eigenvalue</comment>
        <comment>CommonOps.set(b,1);</comment>
        <comment>see if it has converged</comment>
        <comment>update everything</comment>
      </scope>
      <comment>perturb the eigenvalue slightly so that its not an exact solution the first time</comment>
      <comment>eigenvalue -= eigenvalue*UtilEjml.EPS*10;</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Computes the dominant eigen vector for a matrix.  The dominant eigen vector is an
 * eigen vector associated with the largest eigen value.
 * </p>
 * <p>
 * WARNING: This function uses the power method.  There are known cases where it will not converge.
 * It also seems to converge to non-dominant eigen vectors some times.  Use at your own risk.
 * </p></text>
      <param>A A matrix.  Not modified.</param>
    </javadoc>
    <method type="Eigenpair" name="dominantEigenpair" startLine="185" endLine="194">
      <declaration type="EigenPowerMethod" name="power" />
      <comment>eh maybe 0.1 is a good value.  who knows.</comment>
      <comment>power.getEigenVector();</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Generates a bound for the largest eigen value of the provided matrix using Perron-Frobenius
 * theorem.   This function only applies to non-negative real matrices.
 * </p>
 * <p>
 * For "stochastic" matrices (Markov process) this should return one for the upper and lower bound.
 * </p></text>
      <param>A Square matrix with positive elements.  Not modified.</param>
      <param>bound Where the results are stored.  If null then a matrix will be declared. Modified.</param>
      <return>Lower and upper bound in the first and second elements respectively.</return>
    </javadoc>
    <method type="double[]" name="boundLargestEigenValue" startLine="210" endLine="244">
      <declaration type="double" name="min" />
      <declaration type="double" name="max" />
      <declaration type="int" name="n" />
      <scope startLine="219" endLine="235">
        <declaration type="double" name="total" />
        <scope startLine="221" endLine="226">
          <declaration type="double" name="v" />
        </scope>
        <scope startLine="228" endLine="230" />
        <scope startLine="232" endLine="234" />
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * A diagonal matrix where real diagonal element contains a real eigenvalue.  If an eigenvalue
 * is imaginary then zero is stored in its place.
 * </p></text>
      <param>eig An eigenvalue decomposition which has already decomposed a matrix.</param>
      <return>A diagonal matrix containing the eigenvalues.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="createMatrixD" startLine="256" endLine="270">
      <declaration type="int" name="N" />
      <declaration type="DenseMatrix64F" name="D" />
      <scope startLine="261" endLine="267">
        <declaration type="Complex64F" name="c" />
        <scope startLine="264" endLine="266" />
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Puts all the real eigenvectors into the columns of a matrix.  If an eigenvalue is imaginary
 * then the corresponding eigenvector will have zeros in its column.
 * </p></text>
      <param>eig An eigenvalue decomposition which has already decomposed a matrix.</param>
      <return>An m by m matrix containing eigenvectors in its columns.</return>
    </javadoc>
    <method type="DenseMatrix64F" name="createMatrixV" startLine="282" endLine="302">
      <declaration type="int" name="N" />
      <declaration type="DenseMatrix64F" name="V" />
      <scope startLine="287" endLine="299">
        <declaration type="Complex64F" name="c" />
        <scope startLine="290" endLine="298">
          <declaration type="DenseMatrix64F" name="v" />
          <scope startLine="293" endLine="297">
            <scope startLine="294" endLine="296" />
          </scope>
        </scope>
      </scope>
    </method>
    <comment>TODO maybe do the regular power method, estimate the eigenvalue, then shift invert?</comment>
  </class>
</source>
