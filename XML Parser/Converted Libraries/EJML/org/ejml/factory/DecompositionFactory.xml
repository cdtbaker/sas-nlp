<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.factory">
  <import name="org.ejml.EjmlParameters" />
  <import name="org.ejml.alg.dense.decomposition.chol.CholeskyDecompositionBlock" />
  <import name="org.ejml.alg.dense.decomposition.chol.CholeskyDecompositionBlock64" />
  <import name="org.ejml.alg.dense.decomposition.chol.CholeskyDecompositionInner" />
  <import name="org.ejml.alg.dense.decomposition.chol.CholeskyDecompositionLDL" />
  <import name="org.ejml.alg.dense.decomposition.eig.SwitchingEigenDecomposition" />
  <import name="org.ejml.alg.dense.decomposition.eig.SymmetricQRAlgorithmDecomposition" />
  <import name="org.ejml.alg.dense.decomposition.eig.WatchedDoubleStepQRDecomposition" />
  <import name="org.ejml.alg.dense.decomposition.hessenberg.TridiagonalDecompositionBlock" />
  <import name="org.ejml.alg.dense.decomposition.hessenberg.TridiagonalDecompositionHouseholder" />
  <import name="org.ejml.alg.dense.decomposition.hessenberg.TridiagonalSimilarDecomposition" />
  <import name="org.ejml.alg.dense.decomposition.lu.LUDecompositionAlt" />
  <import name="org.ejml.alg.dense.decomposition.qr.QRColPivDecompositionHouseholderColumn" />
  <import name="org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholderColumn" />
  <import name="org.ejml.alg.dense.decomposition.svd.SvdImplicitQrDecompose" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <import name="org.ejml.data.ReshapeMatrix64F" />
  <import name="org.ejml.ops.EigenOps" />
  <import name="org.ejml.ops.SpecializedOps" />
  <import name="org.ejml.simple.SimpleMatrix" />
  <class name="DecompositionFactory" startLine="43">
    <javadoc>
      <text>* <p>
 * Contains operations related to creating and evaluating the quality of common matrix decompositions.  Except
 * in specialized situations, matrix decompositions should be instantiated from this factory instead of being
 * directly constructed.  Low level implementations are more prone to changes and new algorithms will be
 * automatically placed here.
 * </p>
 * <p>
 * Several functions are also provided to evaluate the quality of a decomposition.  This is provided
 * as a way to sanity check a decomposition.  Often times a significant error in a decomposition will
 * result in a poor (larger) quality value. Typically a quality value of around 1e-15 means it is within
 * machine precision.
 * </p></text>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* <p>
 * Returns a {@link CholeskyDecomposition} that has been optimized for the specified matrix size.
 * </p></text>
      <param>matrixSize Number of rows and columns that the returned decomposition is optimized for.</param>
      <param>lower should a lower or upper triangular matrix be used. If not sure set to true.</param>
      <return>A new CholeskyDecomposition.</return>
    </javadoc>
    <method type="CholeskyDecomposition<DenseMatrix64F>" name="chol" startLine="73" endLine="81">
      <scope startLine="74" endLine="76" />
      <scope startLine="76" endLine="78" />
      <scope startLine="78" endLine="80" />
    </method>
    <javadoc>
      <text>* <p>
 * Returns a {@link CholeskyDecompositionLDL} that has been optimized for the specified matrix size.
 * </p></text>
      <param>matrixSize Number of rows and columns that the returned decomposition is optimized for.</param>
      <return>CholeskyDecompositionLDL</return>
    </javadoc>
    <method type="CholeskyDecompositionLDL" name="cholLDL" startLine="91" endLine="93" />
    <javadoc>
      <text>* <p>
 * Returns a {@link LUDecomposition} that has been optimized for the specified matrix size.
 * </p></text>
      <parm>matrixWidth The matrix size that the decomposition should be optimized for.</parm>
      <return>LUDecomposition</return>
    </javadoc>
    <method type="LUDecomposition<DenseMatrix64F>" name="lu" startLine="103" endLine="105" />
    <javadoc>
      <text>* <p>
 * Returns a {@link SingularValueDecomposition} that has been optimized for the specified matrix size.
 * For improved performance only the portion of the decomposition that the user requests will be computed.
 * </p></text>
      <param>numRows Number of rows the returned decomposition is optimized for.</param>
      <param>numCols Number of columns that the returned decomposition is optimized for.</param>
      <param>needU Should it compute the U matrix. If not sure set to true.</param>
      <param>needV Should it compute the V matrix. If not sure set to true.</param>
      <param>compact Should it compute the SVD in compact form.  If not sure set to false.</param>
      <return />
    </javadoc>
    <method type="SingularValueDecomposition<DenseMatrix64F>" name="svd" startLine="121" endLine="124">
      <comment>Don't allow the tall decomposition by default since it *might* be less stable</comment>
    </method>
    <javadoc>
      <text>* <p>
 * Returns a {@link QRDecomposition} that has been optimized for the specified matrix size.
 * </p></text>
      <param>numRows Number of rows the returned decomposition is optimized for.</param>
      <param>numCols Number of columns that the returned decomposition is optimized for.</param>
      <return>QRDecomposition</return>
    </javadoc>
    <method type="QRDecomposition<DenseMatrix64F>" name="qr" startLine="135" endLine="137" />
    <javadoc>
      <text>* <p>
 * Returns a {@link QRPDecomposition} that has been optimized for the specified matrix size.
 * </p></text>
      <param>numRows Number of rows the returned decomposition is optimized for.</param>
      <param>numCols Number of columns that the returned decomposition is optimized for.</param>
      <return>QRPDecomposition</return>
    </javadoc>
    <method type="QRPDecomposition<DenseMatrix64F>" name="qrp" startLine="148" endLine="150" />
    <javadoc>
      <text>* <p>
 * Returns an {@link EigenDecomposition} that has been optimized for the specified matrix size.
 * If the input matrix is symmetric within tolerance then the symmetric algorithm will be used, otherwise
 * a general purpose eigenvalue decomposition is used.
 * </p></text>
      <param>matrixSize Number of rows and columns that the returned decomposition is optimized for.</param>
      <param>needVectors Should eigenvectors be computed or not.  If not sure set to true.</param>
      <return>A new EigenDecomposition</return>
    </javadoc>
    <method type="EigenDecomposition<DenseMatrix64F>" name="eig" startLine="163" endLine="165" />
    <javadoc>
      <text>* <p>
 * Returns an {@link EigenDecomposition} which is specialized for symmetric matrices or the general problem.
 * </p></text>
      <param>matrixSize Number of rows and columns that the returned decomposition is optimized for.</param>
      <param>computeVectors Should it compute the eigenvectors or just eigenvalues.</param>
      <param>isSymmetric If true then the returned algorithm is specialized only for symmetric matrices, if false
 * then a general purpose algorithm is returned.</param>
      <return>EVD for any matrix.</return>
    </javadoc>
    <method type="EigenDecomposition<DenseMatrix64F>" name="eig" startLine="179" endLine="185">
      <scope startLine="180" endLine="183">
        <declaration type="TridiagonalSimilarDecomposition<DenseMatrix64F>" name="decomp" />
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Computes a metric which measures the the quality of a singular value decomposition.  If a
 * value is returned that is close to or smaller than 1e-15 then it is within machine precision.
 * </p>
 * <p>
 * SVD quality is defined as:<br>
 * <br>
 * Quality = || A - U W V<sup>T</sup>|| / || A || <br>
 * where A is the original matrix , U W V is the decomposition, and ||A|| is the norm-f of A.
 * </p></text>
      <param>orig The original matrix which was decomposed. Not modified.</param>
      <param>svd The decomposition after processing 'orig'. Not modified.</param>
      <return>The quality of the decomposition.</return>
    </javadoc>
    <method type="double" name="quality" startLine="205" endLine="207" />
    <method type="double" name="quality" startLine="210" endLine="218">
      <declaration type="SimpleMatrix" name="_U" />
      <declaration type="SimpleMatrix" name="_W" />
      <declaration type="SimpleMatrix" name="_Vt" />
      <declaration type="SimpleMatrix" name="foundA" />
    </method>
    <javadoc>
      <text>* <p>
 * Computes a metric which measures the the quality of an eigen value decomposition.  If a
 * value is returned that is close to or smaller than 1e-15 then it is within machine precision.
 * </p>
 * <p>
 * EVD quality is defined as:<br>
 * <br>
 * Quality = ||A*V - V*D|| / ||A*V||.
 * </p></text>
      <param>orig The original matrix. Not modified.</param>
      <param>eig EVD of the original matrix. Not modified.</param>
      <return>The quality of the decomposition.</return>
    </javadoc>
    <method type="double" name="quality" startLine="236" endLine="252">
      <declaration type="SimpleMatrix" name="A" />
      <declaration type="SimpleMatrix" name="V" />
      <declaration type="SimpleMatrix" name="D" />
      <declaration type="SimpleMatrix" name="L" />
      <declaration type="SimpleMatrix" name="R" />
      <declaration type="SimpleMatrix" name="diff" />
      <declaration type="double" name="top" />
      <declaration type="double" name="bottom" />
      <declaration type="double" name="error" />
    </method>
    <javadoc>
      <text>* Checks to see if the passed in tridiagonal decomposition is of the appropriate type
 * for the matrix of the provided size.  Returns the same instance or a new instance.</text>
      <param>matrixSize Number of rows and columns that the returned decomposition is optimized for.</param>
    </javadoc>
    <method type="TridiagonalSimilarDecomposition<DenseMatrix64F>" name="tridiagonal" startLine="260" endLine="266">
      <scope startLine="261" endLine="263" />
      <scope startLine="263" endLine="265" />
    </method>
    <javadoc>
      <text>* A simple convinience function that decomposes the matrix but automatically checks the input ti make
 * sure is not being modified.</text>
      <param>decomp Decomposition which is being wrapped</param>
      <param>M THe matrix being decomposed.</param>
      <param><T>
 *  Matrix type.</param>
      <return>If the decomposition was successful or not.</return>
    </javadoc>
    <method type="boolean" name="decomposeSafe" startLine="277" endLine="283">
      <scope startLine="278" endLine="280" />
      <scope startLine="280" endLine="282" />
    </method>
  </class>
</source>
