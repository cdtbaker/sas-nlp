<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ejml.factory">
  <import name="org.ejml.EjmlParameters" />
  <import name="org.ejml.alg.dense.decomposition.chol.CholeskyDecompositionCommon" />
  <import name="org.ejml.alg.dense.decomposition.chol.CholeskyDecompositionInner" />
  <import name="org.ejml.alg.dense.decomposition.lu.LUDecompositionAlt" />
  <import name="org.ejml.alg.dense.decomposition.qr.QRColPivDecompositionHouseholderColumn" />
  <import name="org.ejml.alg.dense.linsol.AdjustableLinearSolver" />
  <import name="org.ejml.alg.dense.linsol.chol.LinearSolverChol" />
  <import name="org.ejml.alg.dense.linsol.chol.LinearSolverCholBlock64" />
  <import name="org.ejml.alg.dense.linsol.lu.LinearSolverLu" />
  <import name="org.ejml.alg.dense.linsol.qr.*" />
  <import name="org.ejml.alg.dense.linsol.svd.SolvePseudoInverseSvd" />
  <import name="org.ejml.data.DenseMatrix64F" />
  <class name="LinearSolverFactory" startLine="35">
    <javadoc>
      <text>* A factory for generating solvers for systems of the form A*x=b, where A and B are known and x is unknown.</text>
      <author>Peter Abeles</author>
    </javadoc>
    <javadoc>
      <text>* Creates a general purpose solver.  Use this if you are not sure what you need.</text>
      <param>numRows The number of rows that the decomposition is optimized for.</param>
      <param>numCols The number of columns that the decomposition is optimized for.</param>
    </javadoc>
    <method type="LinearSolver<DenseMatrix64F>" name="general" startLine="48" endLine="53" />
    <javadoc>
      <text>* Creates a solver for linear systems.  The A matrix will have dimensions (m,m).</text>
      <return>A new linear solver.</return>
    </javadoc>
    <method type="LinearSolver<DenseMatrix64F>" name="linear" startLine="60" endLine="62" />
    <javadoc>
      <text>* Creates a good general purpose solver for over determined systems and returns the optimal least-squares
 * solution.  The A matrix will have dimensions (m,n) where m &ge; n.</text>
      <param>numRows The number of rows that the decomposition is optimized for.</param>
      <param>numCols The number of columns that the decomposition is optimized for.</param>
      <return>A new least-squares solver for over determined systems.</return>
    </javadoc>
    <method type="LinearSolver<DenseMatrix64F>" name="leastSquares" startLine="72" endLine="81">
      <scope startLine="73" endLine="75" />
      <scope startLine="75" endLine="80" />
    </method>
    <javadoc>
      <text>* Creates a solver for symmetric positive definite matrices.</text>
      <return>A new solver for symmetric positive definite matrices.</return>
    </javadoc>
    <method type="LinearSolver<DenseMatrix64F>" name="symmPosDef" startLine="88" endLine="100">
      <scope startLine="89" endLine="92">
        <declaration type="CholeskyDecompositionCommon" name="decomp" />
      </scope>
      <scope startLine="92" endLine="99">
        <scope startLine="95" endLine="98">
          <declaration type="CholeskyDecompositionCommon" name="decomp" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* <p>
 * Linear solver which uses QR pivot decomposition.  These solvers can handle singular systems
 * and should never fail.  For singular systems, the solution might not be as accurate as a
 * pseudo inverse that uses SVD.
 * </p>
 * <p>
 * For singular systems there are multiple correct solutions.  The optimal 2-norm solution is the
 * solution vector with the minimal 2-norm and is unique.  If the optimal solution is not computed
 * then the basic solution is returned.  See {@link org.ejml.alg.dense.linsol.qr.BaseLinearSolverQrp}for details.  There is only a runtime difference for small matrices, 2-norm solution is slower.
 * </p>
 * <p>
 * Two different solvers are available.  Compute Q will compute the Q matrix once then use it multiple times.
 * If the solution for a single vector is being found then this should be set to false.  If the pseudo inverse
 * is being found or the solution matrix has more than one columns AND solve is being called numerous multiples
 * times then this should be set to true.
 * </p></text>
      <param>computeNorm2 true to compute the minimum 2-norm solution for singular systems. Try true.</param>
      <param>computeQ Should it precompute Q or use house holder.  Try false;</param>
      <return>Pseudo inverse type solver using QR with column pivots.</return>
    </javadoc>
    <method type="LinearSolver<DenseMatrix64F>" name="leastSquaresQrPivot" startLine="127" endLine="135">
      <declaration type="QRColPivDecompositionHouseholderColumn" name="decomposition" />
    </method>
    <javadoc>
      <text>* <p>
 * Returns a solver which uses the pseudo inverse.  Useful when a matrix
 * needs to be inverted which is singular.  Two variants of pseudo inverse are provided.  SVD
 * will tend to be the most robust but the slowest and QR decomposition with column pivots will
 * be faster, but less robust.
 * </p>
 * <p>
 * See {@link #leastSquaresQrPivot} for additional options specific to QR decomposition based
 * pseudo inverse.  These options allow for better runtime performance in different situations.
 * </p></text>
      <param>useSVD If true SVD will be used, otherwise QR with column pivot will be used.</param>
      <return>Solver for singular matrices.</return>
    </javadoc>
    <method type="LinearSolver<DenseMatrix64F>" name="pseudoInverse" startLine="153" endLine="158" />
    <javadoc>
      <text>* Create a solver which can efficiently add and remove elements instead of recomputing
 * everything from scratch.</text>
    </javadoc>
    <method type="AdjustableLinearSolver" name="adjustable" startLine="164" endLine="166" />
  </class>
</source>
