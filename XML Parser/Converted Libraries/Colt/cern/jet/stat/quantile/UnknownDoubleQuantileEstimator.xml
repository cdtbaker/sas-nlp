<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.stat.quantile">
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.ObjectArrayList" />
  <import name="cern.jet.random.engine.RandomEngine" />
  <import name="cern.jet.random.sampling.WeightedRandomSampler" />
  <class name="UnknownDoubleQuantileEstimator" extends="DoubleQuantileEstimator" startLine="15">
    <javadoc>
      <text>* Approximate quantile finding algorithm for unknown <tt>N</tt> requiring only one pass and little main memory; computes quantiles over a sequence of <tt>double</tt> elements.
 * This algorithm requires at most two times the memory of a corresponding approx. quantile finder knowing <tt>N</tt>.
 * <p>Needs as input the following parameters:<p>
 * <dt>1. <tt>quantiles</tt> - the number of quantiles to be computed.
 * <dt>2. <tt>epsilon</tt> - the allowed approximation error on quantiles. The approximation guarantee of this algorithm is explicit.
 * <p>It is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. 
 * With sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a (user controlled) confidence parameter "delta".
 * <dt>3. <tt>delta</tt> - the probability allowed that the approximation error fails to be smaller than epsilon. Set <tt>delta</tt> to zero for explicit non probabilistic guarantees.
 * You usually don't instantiate quantile finders by using the constructor. Instead use the factory <tt>QuantileFinderFactor</tt> to do so. It will set up the right parametrization for you.
 * <p>After Gurmeet Singh Manku, Sridhar Rajagopalan and Bruce G. Lindsay,
 * Random Sampling Techniques for Space Efficient Online Computation of Order Statistics of Large Datasets.
 * Accepted for Proc. of the 1999 ACM SIGMOD Int. Conf. on Management of Data,
 * Paper (soon) available <A HREF="http://www-cad.eecs.berkeley.edu/~manku"> here</A>.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>QuantileFinderFactory</see>
      <see>KnownApproximateDoubleQuantileFinder</see>
    </javadoc>
    <declaration type="int" name="currentTreeHeight" />
    <declaration type="int" name="treeHeightStartingSampling" />
    <declaration type="WeightedRandomSampler" name="sampler" />
    <declaration type="double" name="precomputeEpsilon" />
    <javadoc>
      <text>* Constructs an approximate quantile finder with b buffers, each having k elements.</text>
      <param>b the number of buffers</param>
      <param>k the number of elements per buffer</param>
      <param>h the tree height at which sampling shall start.</param>
      <param>precomputeEpsilon the epsilon for which quantiles shall be precomputed; set this value <=0.0 if nothing shall be precomputed.</param>
      <param>generator a uniform random number generator.</param>
    </javadoc>
    <method type="constructor" name="UnknownDoubleQuantileEstimator" startLine="53" endLine="59" />
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <method type="DoubleBuffer[]" name="buffersToCollapse" startLine="63" endLine="75">
      <declaration type="DoubleBuffer[]" name="fullBuffers" />
      <declaration type="int" name="minLevel" />
      <scope startLine="70" endLine="72" />
      <comment>if there is only one buffer at the lowest level, then increase its level so that there are at least two at the lowest level.</comment>
    </method>
    <javadoc>
      <text>* Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, and its memory requirements will be close to zero.</text>
    </javadoc>
    <method type="void" name="clear" startLine="80" endLine="84" />
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="90" endLine="94">
      <declaration type="UnknownDoubleQuantileEstimator" name="copy" />
    </method>
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <method type="void" name="newBuffer" startLine="98" endLine="104" />
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <method type="void" name="postCollapse" startLine="108" endLine="115">
      <scope startLine="109" endLine="114">
        <scope startLine="111" endLine="113" />
        <comment>delta for unknown finder</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Computes the specified quantile elements over the values previously added.</text>
      <param>phis the quantiles for which elements are to be computed. Each phi must be in the interval (0.0,1.0]. <tt>phis</tt> must be sorted ascending.</param>
      <return>the approximate quantile elements.</return>
    </javadoc>
    <method type="DoubleArrayList" name="quantileElements" startLine="121" endLine="145">
      <declaration type="int" name="quantilesToPrecompute" />
      <declaration type="double" name="e" />
      <scope startLine="136" endLine="142">
        <declaration type="double" name="phi" />
        <declaration type="int" name="i" />
        <declaration type="double" name="augmentedPhi" />
        <comment>finds closest</comment>
      </scope>
      <comment>if (phis.size() > quantilesToPrecompute) {
 illegal use case!
 we compute results, but loose explicit approximation guarantees.
return super.quantileElements(phis);
}</comment>
      <comment>select that quantile from the precomputed set that corresponds to a position closest to phi.</comment>
    </method>
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <method type="boolean" name="sampleNextElement" startLine="149" endLine="151" />
    <javadoc>
      <text>* To do. This could faster be done without sorting (min and second min).</text>
    </javadoc>
    <method type="void" name="sortAscendingByLevel" startLine="155" endLine="165">
      <method type="int" name="compare" startLine="158" endLine="162">
        <declaration type="int" name="l1" />
        <declaration type="int" name="l2" />
      </method>
    </method>
    <javadoc>
      <text>* Returns a String representation of the receiver.</text>
    </javadoc>
    <method type="String" name="toString" startLine="169" endLine="173">
      <declaration type="StringBuffer" name="buf" />
    </method>
  </class>
</source>
