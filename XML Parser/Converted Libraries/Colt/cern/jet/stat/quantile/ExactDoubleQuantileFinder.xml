<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.stat.quantile">
  <import name="cern.colt.list.DoubleArrayList" />
  <class name="ExactDoubleQuantileFinder" extends="cern.colt.PersistentObject" startLine="12">
    <implements name="DoubleQuantileFinder" />
    <javadoc>
      <text>* Exact quantile finding algorithm for known and unknown <tt>N</tt> requiring large main memory; computes quantiles over a sequence of <tt>double</tt> elements.
 * The folkore algorithm: Keeps all elements in main memory, sorts the list, then picks the quantiles.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <declaration type="DoubleArrayList" name="buffer" />
    <declaration type="boolean" name="isSorted" />
    <javadoc>
      <text>* Constructs an empty exact quantile finder.</text>
    </javadoc>
    <method type="constructor" name="ExactDoubleQuantileFinder" startLine="26" endLine="29" />
    <javadoc>
      <text>* Adds a value to the receiver.</text>
      <param>value the value to add.</param>
    </javadoc>
    <method type="void" name="add" startLine="34" endLine="37" />
    <javadoc>
      <text>* Adds all values of the specified list to the receiver.</text>
      <param>values the list of which all values shall be added.</param>
    </javadoc>
    <method type="void" name="addAllOf" startLine="42" endLine="44" />
    <javadoc>
      <text>* Adds the part of the specified list between indexes <tt>from</tt> (inclusive) and <tt>to</tt> (inclusive) to the receiver.</text>
      <param>values the list of which elements shall be added.</param>
      <param>from the index of the first element to be added (inclusive).</param>
      <param>to the index of the last element to be added (inclusive).</param>
    </javadoc>
    <method type="void" name="addAllOfFromTo" startLine="52" endLine="55" />
    <javadoc>
      <text>* Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, and its memory requirements will be close to zero.</text>
    </javadoc>
    <method type="void" name="clear" startLine="60" endLine="64" />
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="70" endLine="74">
      <declaration type="ExactDoubleQuantileFinder" name="copy" />
    </method>
    <javadoc>
      <text>* Returns whether the specified element is contained in the receiver.</text>
    </javadoc>
    <method type="boolean" name="contains" startLine="78" endLine="81" />
    <javadoc>
      <text>* Applies a procedure to each element of the receiver, if any.
 * Iterates over the receiver in no particular order.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEach" startLine="88" endLine="94">
      <declaration type="double[]" name="theElements" />
      <declaration type="int" name="theSize" />
    </method>
    <javadoc>
      <text>* Returns the number of elements currently needed to store all contained elements.
 * This number usually differs from the results of method <tt>size()</tt>, according to the underlying datastructure.</text>
    </javadoc>
    <method type="long" name="memory" startLine="99" endLine="101" />
    <javadoc>
      <text>* Returns how many percent of the elements contained in the receiver are <tt>&lt;= element</tt>.
 * Does linear interpolation if the element is not contained but lies in between two contained elements.</text>
      <param>the element to search for.</param>
      <return>the percentage <tt>p</tt> of elements <tt>&lt;= element</tt> (<tt>0.0 &lt;= p &lt;=1.0)</tt>.</return>
    </javadoc>
    <method type="double" name="phi" startLine="109" endLine="112" />
    <javadoc>
      <text>* Computes the specified quantile elements over the values previously added.</text>
      <param>phis the quantiles for which elements are to be computed. Each phi must be in the interval [0.0,1.0]. <tt>phis</tt> must be sorted ascending.</param>
      <return>the exact quantile elements.</return>
    </javadoc>
    <method type="DoubleArrayList" name="quantileElements" startLine="118" endLine="130">
      <comment>int bufferSize = (int) this.size();
double[] quantileElements = new double[phis.size()];
for (int i=phis.size(); --i >=0;) {
int rank=(int)Utils.epsilonCeiling(phis.get(i)bufferSize) -1;
quantileElements[i]=buffer.get(rank);
}
return new DoubleArrayList(quantileElements);</comment>
    </method>
    <javadoc>
      <text>* Returns the number of elements currently contained in the receiver (identical to the number of values added so far).</text>
    </javadoc>
    <method type="long" name="size" startLine="134" endLine="136" />
    <javadoc>
      <text>* Sorts the receiver.</text>
    </javadoc>
    <method type="void" name="sort" startLine="140" endLine="148">
      <scope startLine="141" endLine="147">
        <comment>IMPORTANT: TO DO : replace mergeSort with quickSort!</comment>
        <comment>currently it is mergeSort because JDK 1.2 can't be imported into VisualAge.</comment>
        <comment>this.buffer.mergeSort();</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a String representation of the receiver.</text>
    </javadoc>
    <method type="String" name="toString" startLine="152" endLine="156">
      <declaration type="String" name="s" />
    </method>
    <javadoc>
      <text>* Returns the number of elements currently needed to store all contained elements.
 * This number usually differs from the results of method <tt>size()</tt>, according to the underlying datastructure.</text>
    </javadoc>
    <method type="long" name="totalMemory" startLine="161" endLine="163" />
    <comment>class ExactDoubleQuantileFinder extends Object implements DoubleQuantileFinder {</comment>
  </class>
</source>
