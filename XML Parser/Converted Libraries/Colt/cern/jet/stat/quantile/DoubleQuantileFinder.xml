<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.stat.quantile">
  <import name="cern.colt.list.DoubleArrayList" />
  <interface name="DoubleQuantileFinder" startLine="12">
    <implements name="java.io.Serializable" />
    <javadoc>
      <text>* The interface shared by all quantile finders, no matter if they are exact or approximate.
 * It is usually completely sufficient to operate on this interface only.
 * Also see {@link hep.aida.bin.QuantileBin1D}, demonstrating how this package can be used.</text>
    </javadoc>
    <method name="add" type="void" startLine="19" endLine="23" />
    <javadoc>
      <text>* Adds a value to the receiver.</text>
      <param>value the value to add.</param>
    </javadoc>
    <method name="addAllOf" type="void" startLine="24" endLine="28" />
    <javadoc>
      <text>* Adds all values of the specified list to the receiver.</text>
      <param>values the list of which all values shall be added.</param>
    </javadoc>
    <method name="addAllOfFromTo" type="void" startLine="29" endLine="36" />
    <javadoc>
      <text>* Adds the part of the specified list between indexes <tt>from</tt> (inclusive) and <tt>to</tt> (inclusive) to the receiver.</text>
      <param>values the list of which elements shall be added.</param>
      <param>from the index of the first element to be added (inclusive).</param>
      <param>to the index of the last element to be added (inclusive).</param>
    </javadoc>
    <method name="clear" type="void" startLine="37" endLine="41" />
    <javadoc>
      <text>* Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, and its memory requirements will be close to zero.</text>
    </javadoc>
    <method name="clone" type="Object" startLine="42" endLine="47" />
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method name="forEach" type="boolean" startLine="48" endLine="54" />
    <javadoc>
      <text>* Applies a procedure to each element of the receiver, if any.
 * Iterates over the receiver in no particular order.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method name="memory" type="long" startLine="55" endLine="59" />
    <javadoc>
      <text>* Returns the number of elements currently needed to store all contained elements.
 * This number usually differs from the results of method <tt>size()</tt>, according to the underlying datastructure.</text>
    </javadoc>
    <method name="phi" type="double" startLine="60" endLine="69" />
    <javadoc>
      <text>* Returns how many percent of the elements contained in the receiver are <tt>&lt;= element</tt>.
 * Does linear interpolation if the element is not contained but lies in between two contained elements.
 * Writing a wrapper is a good idea if you can think of better ways of doing interpolation.
 * Same if you want to keep min,max and other such measures.</text>
      <param>the element to search for.</param>
      <return>the percentage <tt>p</tt> of elements <tt>&lt;= element</tt> (<tt>0.0 &lt;= p &lt;=1.0)</tt>.</return>
    </javadoc>
    <method name="quantileElements" type="DoubleArrayList" startLine="70" endLine="75" />
    <javadoc>
      <text>* Computes the specified quantile elements over the values previously added.</text>
      <param>phis the quantiles for which elements are to be computed. Each phi must be in the interval [0.0,1.0]. <tt>phis</tt> must be sorted ascending.</param>
      <return>the quantile elements.</return>
    </javadoc>
    <method name="size" type="long" startLine="76" endLine="79" />
    <javadoc>
      <text>* Returns the number of elements currently contained in the receiver (identical to the number of values added so far).</text>
    </javadoc>
    <method name="totalMemory" type="long" startLine="80" endLine="84" />
    <javadoc>
      <text>* Returns the number of elements currently needed to store all contained elements.
 * This number usually differs from the results of method <tt>size()</tt>, according to the underlying datastructure.</text>
    </javadoc>
  </interface>
</source>
