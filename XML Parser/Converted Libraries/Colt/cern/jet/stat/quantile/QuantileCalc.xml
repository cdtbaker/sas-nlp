<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.stat.quantile">
  <class name="QuantileCalc" extends="Object" startLine="11">
    <javadoc>
      <text>* Computes b and k vor various parameters.</text>
    </javadoc>
    <javadoc>
      <text>* Efficiently computes the binomial coefficient, often also referred to as "n over k" or "n choose k".
 * The binomial coefficient is defined as n!/((n-k)!*k!).
 * Tries to avoid numeric overflows.</text>
      <return>the binomial coefficient.</return>
    </javadoc>
    <method type="double" name="binomial" startLine="21" endLine="34">
      <scope startLine="22" endLine="22" />
      <declaration type="double" name="binomial" />
      <declaration type="long" name="N" />
      <scope startLine="30" endLine="32" />
      <comment>since binomial(n,k)==binomial(n,n-k), we can enforce the faster variant,</comment>
      <comment>which is also the variant minimizing number overflows.</comment>
    </method>
    <javadoc>
      <text>* Returns the smallest <code>long &gt;= value</code>.
 * <dt>Examples: <code>1.0 -> 1, 1.2 -> 2, 1.9 -> 2</code>.
 * This method is safer than using (long) Math.ceil(value), because of possible rounding error.</text>
    </javadoc>
    <method type="long" name="ceiling" startLine="40" endLine="42" />
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * Assumes that quantiles are to be computed over N values.
 * The required sampling rate is computed and stored in the first element of the provided <tt>returnSamplingRate</tt> array, which, therefore must be at least of length 1.</text>
      <param>N the number of values over which quantiles shall be computed (e.g <tt>10^6</tt>).</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To avoid probabilistic answers, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <param>samplingRate a <tt>double[1]</tt> where the sampling rate is to be filled in.</param>
      <return><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>returnSamplingRate[0]</tt>=the required sampling rate.</return>
    </javadoc>
    <method type="long[]" name="known_N_compute_B_and_K" startLine="57" endLine="63">
      <scope startLine="58" endLine="60" />
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with a <b>guaranteed</b> approximation error no more than epsilon.
 * Assumes that quantiles are to be computed over N values.</text>
      <return><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer.</return>
      <param>N the anticipated number of values over which quantiles shall be determined.</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
    </javadoc>
    <method type="long[]" name="known_N_compute_B_and_K_quick" startLine="72" endLine="167">
      <scope startLine="73" endLine="79">
        <declaration type="long[]" name="result" />
        <comment>no way around exact quantile search</comment>
      </scope>
      <declaration type="int" name="maxBuffers" />
      <declaration type="int" name="maxHeight" />
      <declaration type="double" name="N_double" />
      <declaration type="double" name="c" />
      <declaration type="int[]" name="heightMaximums" />
      <scope startLine="89" endLine="121">
        <declaration type="int" name="h" />
        <scope startLine="97" endLine="97" />
        <scope startLine="104" endLine="104" />
        <declaration type="int" name="hMax" />
        <scope startLine="113" endLine="115" />
        <scope startLine="116" endLine="118" />
        <comment>skip heights until x<=0</comment>
        <comment>from now on x is monotonically growing...</comment>
        <comment>skip heights until x>0</comment>
        <comment>go back to last height</comment>
        <comment>was x>0 or did we loop without finding anything?</comment>
        <comment>safe some space</comment>
        <comment>end for</comment>
      </scope>
      <declaration type="long[]" name="kMinimums" />
      <scope startLine="127" endLine="138">
        <declaration type="int" name="h" />
        <declaration type="long" name="kMin" />
        <scope startLine="130" endLine="136">
          <declaration type="double" name="value" />
          <declaration type="long" name="tmpK" />
          <scope startLine="133" endLine="135" />
        </scope>
      </scope>
      <declaration type="long" name="multMin" />
      <declaration type="int" name="minB" />
      <scope startLine="143" endLine="151">
        <scope startLine="144" endLine="150">
          <declaration type="long" name="mult" />
          <scope startLine="146" endLine="149" />
        </scope>
      </scope>
      <declaration type="long" name="b" />
      <scope startLine="154" endLine="157">
        <comment>epsilon large enough?</comment>
      </scope>
      <scope startLine="158" endLine="161">
        <comment>epsilon is very small or zero.</comment>
        <comment>the only possible solution without violating the</comment>
        <comment>approximation guarantees is exact quantile search.</comment>
      </scope>
      <declaration type="long[]" name="result" />
      <comment>for each b, determine maximum height, i.e. the height for which x<=0 and x is a maximum</comment>
      <comment>with x = binomial(b+h-2, h-1) - binomial(b+h-3, h-3) + binomial(b+h-3, h-2) - N * epsilon * 2.0</comment>
      <comment>for each b, determine the smallest k satisfying the constraints, i.e.</comment>
      <comment>for each b, determine kMin, with kMin = N/binomial(b+hMax-2,hMax-1)</comment>
      <comment>from all b's, determine b that minimizes b*kMin</comment>
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * Assumes that quantiles are to be computed over N values.
 * The required sampling rate is computed and stored in the first element of the provided <tt>returnSamplingRate</tt> array, which, therefore must be at least of length 1.</text>
      <param>N the anticipated number of values over which quantiles shall be computed (e.g 10^6).</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To avoid probabilistic answers, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <param>samplingRate a <tt>double[1]</tt> where the sampling rate is to be filled in.</param>
      <return><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>returnSamplingRate[0]</tt>=the required sampling rate.</return>
    </javadoc>
    <method type="long[]" name="known_N_compute_B_and_K_slow" startLine="180" endLine="257">
      <scope startLine="182" endLine="189">
        <declaration type="long[]" name="result" />
        <comment>no way around exact quantile search</comment>
      </scope>
      <declaration type="int" name="maxBuffers" />
      <declaration type="int" name="maxHeight" />
      <declaration type="double" name="N_double" />
      <declaration type="long" name="ret_b" />
      <declaration type="long" name="ret_k" />
      <declaration type="double" name="sampling_rate" />
      <declaration type="long" name="memory" />
      <declaration type="double" name="logarithm" />
      <declaration type="double" name="c" />
      <scope startLine="213" endLine="250">
        <declaration type="double" name="binomial" />
        <declaration type="long" name="tmp" />
        <scope startLine="218" endLine="223" />
        <scope startLine="224" endLine="249">
          <declaration type="double" name="t" />
          <declaration type="double" name="u" />
          <declaration type="double" name="v" />
          <declaration type="double" name="w" />
          <declaration type="double" name="x" />
          <declaration type="long" name="k" />
          <scope startLine="243" endLine="248" />
        </scope>
        <comment>From our SIGMOD 98 paper, we have two equantions to satisfy:</comment>
        <comment>t  <= u * alpha/(1-alpha)^2</comment>
        <comment>kv >= w/(1-alpha)^2</comment>
        <comment />
        <comment>Denoting 1/(1-alpha)    by x,</comment>
        <comment>we see that the first inequality is equivalent to</comment>
        <comment>t/u <= x^2 - x</comment>
        <comment>which is satisfied by x >= 0.5 + 0.5 * sqrt (1 + 4t/u)</comment>
        <comment>Plugging in this value into second equation yields</comment>
        <comment>k >= wx^2/v</comment>
      </scope>
      <declaration type="long[]" name="result" />
      <comment>delta can be set to zero, i.e., all quantiles should be approximate with probability 1</comment>
      <comment>One possibility is to use one buffer of size N</comment>
      <comment />
      <comment>Otherwise, there are at least two buffers (b >= 2)</comment>
      <comment>and the height of the tree is at least three (h >= 3)</comment>
      <comment />
      <comment>We restrict the search for b and h to MAX_BINOM, a large enough value for</comment>
      <comment>practical values of    epsilon >= 0.001   and    delta >= 0.00001</comment>
      <comment />
    </method>
    <method type="void" name="main" startLine="258" endLine="260" />
    <javadoc>
      <text>* Computes b and k for different parameters.</text>
    </javadoc>
    <method type="void" name="test_B_and_K_Calculation" startLine="264" endLine="325">
      <declaration type="boolean" name="known_N" />
      <declaration type="int[]" name="quantiles" />
      <declaration type="long[]" name="sizes" />
      <declaration type="double[]" name="deltas" />
      <declaration type="double[]" name="epsilons" />
      <scope startLine="288" endLine="323">
        <declaration type="int" name="p" />
        <scope startLine="292" endLine="322">
          <declaration type="long" name="N" />
          <scope startLine="296" endLine="321">
            <declaration type="double" name="delta" />
            <scope startLine="300" endLine="320">
              <declaration type="double" name="epsilon" />
              <declaration type="double[]" name="returnSamplingRate" />
              <declaration type="long[]" name="result" />
              <scope startLine="305" endLine="307" />
              <scope startLine="308" endLine="310" />
              <declaration type="long" name="b" />
              <declaration type="long" name="k" />
            </scope>
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.</text>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact results, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To get exact results, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <return><tt>long[3]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>long[2]</tt>=the tree height where sampling shall start.</return>
    </javadoc>
    <method type="long[]" name="unknown_N_compute_B_and_K" startLine="335" endLine="448">
      <scope startLine="337" endLine="344">
        <declaration type="long[]" name="result" />
        <comment>no way around exact quantile search</comment>
      </scope>
      <declaration type="int" name="max_b" />
      <declaration type="int" name="max_h" />
      <declaration type="int" name="max_H" />
      <declaration type="int" name="max_Iterations" />
      <declaration type="long" name="best_b" />
      <declaration type="long" name="best_k" />
      <declaration type="long" name="best_h" />
      <declaration type="long" name="best_memory" />
      <declaration type="double" name="pow" />
      <declaration type="double" name="logDelta" />
      <scope startLine="360" endLine="431">
        <scope startLine="363" endLine="422">
          <scope startLine="364" endLine="421">
            <declaration type="double" name="Ld" />
            <declaration type="double" name="Ls" />
            <declaration type="double" name="c" />
            <declaration type="double" name="beta" />
            <declaration type="double" name="cc" />
            <declaration type="double" name="d" />
            <declaration type="double" name="f" />
            <declaration type="double" name="root" />
            <declaration type="double" name="alpha_one" />
            <declaration type="double" name="alpha_two" />
            <declaration type="boolean" name="alpha_one_OK" />
            <declaration type="boolean" name="alpha_two_OK" />
            <scope startLine="398" endLine="420">
              <declaration type="double" name="alpha" />
              <scope startLine="400" endLine="403" />
              <scope startLine="404" endLine="406" />
              <declaration type="long" name="k" />
              <scope startLine="410" endLine="419">
                <declaration type="long" name="memory" />
                <scope startLine="412" endLine="418" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope startLine="424" endLine="430" />
        <comment>until we find a solution</comment>
        <comment>identify that combination of b and h that minimizes b*k.</comment>
        <comment>exhaustive search.</comment>
        <comment>now we have k>=c*(1-alpha)^-2.</comment>
        <comment>let's compute c.</comment>
        <comment>double c = Math.log(2.0/(delta/quantiles)) / (2.0*epsilon*epsilon*Math.min(Ld, 8.0*Ls/3.0));</comment>
        <comment>now we have k>=d/alpha.</comment>
        <comment>let's compute d.</comment>
        <comment>double d = (Ld(h+max_H-1.0)  +  Ls((h+1)pow - 2.0(h+max_H)))      (Ld + Ls(pow-2.0));
d = (d + 2.0)  (2.0epsilon);</comment>
        <comment>now we have c*(1-alpha)^-2 == d/alpha.</comment>
        <comment>we solve this equation for alpha yielding two solutions</comment>
        <comment>alpha_1,2 = (c + 2*d  +-  Sqrt(c*c + 4*c*d))/(2*d)</comment>
        <comment>non real solution to equation</comment>
        <comment>any alpha must satisfy 0<alpha<1 to yield valid solutions</comment>
        <comment>take the alpha that minimizes d/alpha</comment>
        <comment>now we have k=Ceiling(Max(d/alpha, (h+1)/(2*epsilon)))</comment>
        <comment>valid solution?</comment>
        <comment>found a solution requiring less memory</comment>
        <comment>end for h</comment>
        <comment>end for b</comment>
        <comment>no solution found so far. very unlikely. Anyway, try again.</comment>
        <comment>end while</comment>
      </scope>
      <declaration type="long[]" name="result" />
      <scope startLine="434" endLine="440">
        <comment>no solution found.</comment>
        <comment>no way around exact quantile search.</comment>
      </scope>
      <scope startLine="441" endLine="445" />
      <comment>delta can be set to zero, i.e., all quantiles should be approximate with probability 1</comment>
      <comment>double logDelta =  Math.log(2.0/(quantiles*delta)) / (2.0*epsilon*epsilon);</comment>
    </method>
  </class>
</source>
