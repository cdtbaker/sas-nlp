<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.stat.quantile">
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.ObjectArrayList" />
  <class name="DoubleQuantileEstimator" extends="cern.colt.PersistentObject" startLine="13">
    <implements name="DoubleQuantileFinder" />
    <javadoc>
      <text>* The abstract base class for approximate quantile finders computing quantiles over a sequence of <tt>double</tt> elements.</text>
    </javadoc>
    <declaration type="DoubleBufferSet" name="bufferSet" />
    <declaration type="DoubleBuffer" name="currentBufferToFill" />
    <declaration type="int" name="totalElementsFilled" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="DoubleQuantileEstimator" startLine="24" endLine="24" />
    <javadoc>
      <text>* Adds a value to the receiver.</text>
      <param>value the value to add.</param>
    </javadoc>
    <method type="void" name="add" startLine="29" endLine="42">
      <scope startLine="35" endLine="38" />
      <comment>System.out.println("adding "+value);</comment>
    </method>
    <javadoc>
      <text>* Adds all values of the specified list to the receiver.</text>
      <param>values the list of which all values shall be added.</param>
    </javadoc>
    <method type="void" name="addAllOf" startLine="47" endLine="49" />
    <javadoc>
      <text>* Adds the part of the specified list between indexes <tt>from</tt> (inclusive) and <tt>to</tt> (inclusive) to the receiver.</text>
      <param>values the list of which elements shall be added.</param>
      <param>from the index of the first element to be added (inclusive).</param>
      <param>to the index of the last element to be added (inclusive).</param>
    </javadoc>
    <method type="void" name="addAllOfFromTo" startLine="57" endLine="97">
      <declaration type="double[]" name="valuesToAdd" />
      <declaration type="int" name="k" />
      <declaration type="int" name="bufferSize" />
      <declaration type="double[]" name="bufferValues" />
      <scope startLine="69" endLine="72" />
      <scope startLine="74" endLine="91">
        <scope startLine="75" endLine="90">
          <scope startLine="76" endLine="83" />
          <scope startLine="86" endLine="89" />
        </scope>
        <comment>full</comment>
        <comment>full</comment>
      </scope>
      <scope startLine="92" endLine="94" />
      <comment>the obvious version, but we can do quicker...
double[] theValues = values.elements();
int theSize=values.size();
for (int i=0; i<theSize; ) add(theValues[i++]);</comment>
    </method>
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <method type="DoubleBuffer[]" name="buffersToCollapse" startLine="101" endLine="104">
      <declaration type="int" name="minLevel" />
    </method>
    <javadoc>
      <text>* Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, and its memory requirements will be close to zero.</text>
    </javadoc>
    <method type="void" name="clear" startLine="109" endLine="113" />
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="119" endLine="129">
      <declaration type="DoubleQuantileEstimator" name="copy" />
      <scope startLine="121" endLine="127">
        <scope startLine="123" endLine="126">
          <declaration type="int" name="index" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <method type="void" name="collapse" startLine="133" endLine="141">
      <declaration type="DoubleBuffer[]" name="toCollapse" />
      <declaration type="DoubleBuffer" name="outputBuffer" />
      <declaration type="int" name="minLevel" />
    </method>
    <javadoc>
      <text>* Returns whether the specified element is contained in the receiver.</text>
    </javadoc>
    <method type="boolean" name="contains" startLine="145" endLine="147" />
    <javadoc>
      <text>* Applies a procedure to each element of the receiver, if any.
 * Iterates over the receiver in no particular order.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEach" startLine="154" endLine="156" />
    <javadoc>
      <text>* Returns the number of elements currently needed to store all contained elements.
 * This number usually differs from the results of method <tt>size()</tt>, according to the underlying datastructure.</text>
    </javadoc>
    <method type="long" name="memory" startLine="161" endLine="163" />
    <method name="newBuffer" type="void" startLine="164" endLine="167" />
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <javadoc>
      <text>* Returns how many percent of the elements contained in the receiver are <tt>&lt;= element</tt>.
 * Does linear interpolation if the element is not contained but lies in between two contained elements.</text>
      <param>the element to search for.</param>
      <return>the percentage <tt>p</tt> of elements <tt>&lt;= element</tt> (<tt>0.0 &lt;= p &lt;=1.0)</tt>.</return>
    </javadoc>
    <method type="double" name="phi" startLine="175" endLine="177" />
    <method name="postCollapse" type="void" startLine="178" endLine="181" />
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <javadoc>
      <text>* Default implementation does nothing.</text>
    </javadoc>
    <method type="DoubleArrayList" name="preProcessPhis" startLine="185" endLine="187" />
    <javadoc>
      <text>* Computes the specified quantile elements over the values previously added.</text>
      <param>phis the quantiles for which elements are to be computed. Each phi must be in the interval [0.0,1.0]. <tt>phis</tt> must be sorted ascending.</param>
      <return>the approximate quantile elements.</return>
    </javadoc>
    <method type="DoubleArrayList" name="quantileElements" startLine="193" endLine="222">
      <declaration type="long[]" name="triggerPositions" />
      <declaration type="long" name="totalSize" />
      <scope startLine="209" endLine="211" />
      <declaration type="DoubleBuffer[]" name="fullBuffers" />
      <declaration type="double[]" name="quantileElements" />
      <comment>check parameter
DoubleArrayList sortedPhiList = phis.copy();
sortedPhiList.sort();
if (! phis.equals(sortedPhiList)) {
throw new IllegalArgumentException("Phis must be sorted ascending.");
}</comment>
      <comment>System.out.println("starting to augment missing values, if necessary...");</comment>
      <comment>System.out.println("triggerPositions="+cern.colt.Arrays.toString(triggerPositions));</comment>
      <comment>System.out.println("starting to determine quantiles...");</comment>
      <comment>System.out.println(bufferSet);</comment>
      <comment>do the main work: determine values at given positions in sorted sequence</comment>
    </method>
    <method name="sampleNextElement" type="boolean" startLine="223" endLine="226" />
    <javadoc>
      <text>* Not yet commented.</text>
    </javadoc>
    <javadoc>
      <text>* Initializes the receiver</text>
    </javadoc>
    <method type="void" name="setUp" startLine="230" endLine="236">
      <scope startLine="231" endLine="233" />
    </method>
    <javadoc>
      <text>* Returns the number of elements currently contained in the receiver (identical to the number of values added so far).</text>
    </javadoc>
    <method type="long" name="size" startLine="240" endLine="242" />
    <javadoc>
      <text>* Returns a String representation of the receiver.</text>
    </javadoc>
    <method type="String" name="toString" startLine="246" endLine="252">
      <declaration type="String" name="s" />
      <declaration type="int" name="b" />
      <declaration type="int" name="k" />
    </method>
    <javadoc>
      <text>* Returns the number of elements currently needed to store all contained elements.
 * This number usually differs from the results of method <tt>size()</tt>, according to the underlying datastructure.</text>
    </javadoc>
    <method type="long" name="totalMemory" startLine="257" endLine="259" />
    <comment>abstract class ApproximateDoubleQuantileFinder extends Object implements DoubleQuantileFinder {</comment>
  </class>
</source>
