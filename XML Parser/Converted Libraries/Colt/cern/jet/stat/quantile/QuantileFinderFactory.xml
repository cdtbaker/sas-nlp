<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.stat.quantile">
  <import name="cern.jet.math.Arithmetic" />
  <import name="cern.jet.random.engine.RandomEngine" />
  <class name="QuantileFinderFactory" extends="Object" startLine="14">
    <javadoc>
      <text>* Factory constructing exact and approximate quantile finders for both known and unknown <tt>N</tt>.
 * Also see {@link hep.aida.bin.QuantileBin1D}, demonstrating how this package can be used.
 * The approx. algorithms compute approximate quantiles of large data sequences in a single pass.
 * The approximation guarantees are explicit, and apply for arbitrary value distributions and arrival distributions of the data sequence.
 * The main memory requirements are smaller than for any other known technique by an order of magnitude.
 * <p>The approx. algorithms are primarily intended to help applications scale.
 * When faced with a large data sequences, traditional methods either need very large memories or time consuming disk based sorting.
 * In constrast, the approx. algorithms can deal with > 10^10 values without disk based sorting.
 * <p>All classes can be seen from various angles, for example as
 * <dt>1. Algorithm to compute quantiles.
 * <dt>2. 1-dim-equi-depth histogram.
 * <dt>3. 1-dim-histogram arbitrarily rebinnable in real-time.
 * <dt>4. A space efficient MultiSet data structure using lossy compression.
 * <dt>5. A space efficient value preserving bin of a 2-dim or d-dim histogram.
 * <dt>(All subject to an accuracy specified by the user.)
 * <p>Use methods <tt>newXXX(...)</tt> to get new instances of one of the following quantile finders.
 * <p><b>1. Exact quantile finding algorithm for known and unknown <tt>N</tt> requiring large main memory.</b></p>
 * The folkore algorithm: Keeps all elements in main memory, sorts the list, then picks the quantiles.
 * <p><p><b>2. Approximate quantile finding algorithm for known <tt>N</tt> requiring only one pass and little main memory.</b></p>
 * <p>Needs as input the following parameters:<p>
 * <dt>1. <tt>N</tt> - the number of values of the data sequence over which quantiles are to be determined.
 * <dt>2. <tt>quantiles</tt> - the number of quantiles to be computed. If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.
 * <dt>3. <tt>epsilon</tt> - the allowed approximation error on quantiles. The approximation guarantee of this algorithm is explicit.
 * <p>It is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. 
 * With sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a (user controlled) confidence parameter "delta".
 * <dt>4. <tt>delta</tt> - the probability allowed that the approximation error fails to be smaller than epsilon. Set <tt>delta</tt> to zero for explicit non probabilistic guarantees.
 * <p>After Gurmeet Singh Manku, Sridhar Rajagopalan and Bruce G. Lindsay, 
 * Approximate Medians and other Quantiles in One Pass and with Limited Memory,
 * Proc. of the 1998 ACM SIGMOD Int. Conf. on Management of Data,
 * Paper available <A HREF="http://www-cad.eecs.berkeley.edu/~manku/papers/quantiles.ps.gz"> here</A>.
 * <p><p><b>3. Approximate quantile finding algorithm for unknown <tt>N</tt> requiring only one pass and little main memory.</b></p>
 * This algorithm requires at most two times the memory of a corresponding approx. quantile finder knowing <tt>N</tt>.
 * <p>Needs as input the following parameters:<p>
 * <dt>2. <tt>quantiles</tt> - the number of quantiles to be computed. If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 1000</tt>.
 * <dt>2. <tt>epsilon</tt> - the allowed approximation error on quantiles. The approximation guarantee of this algorithm is explicit.
 * <p>It is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. 
 * With sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a (user controlled) confidence parameter "delta".
 * <dt>3. <tt>delta</tt> - the probability allowed that the approximation error fails to be smaller than epsilon. Set <tt>delta</tt> to zero for explicit non probabilistic guarantees.
 * <p>After Gurmeet Singh Manku, Sridhar Rajagopalan and Bruce G. Lindsay,
 * Random Sampling Techniques for Space Efficient Online Computation of Order Statistics of Large Datasets.
 * Proc. of the 1999 ACM SIGMOD Int. Conf. on Management of Data,
 * Paper available <A HREF="http://www-cad.eecs.berkeley.edu/~manku/papers/unknown.ps.gz"> here</A>.
 * <p><b>Example usage:</b>
 * <pre>
 * _TODO_
 * </pre><p></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>KnownDoubleQuantileEstimator</see>
      <see>UnknownDoubleQuantileEstimator</see>
    </javadoc>
    <javadoc>
      <text>* Make this class non instantiable. Let still allow others to inherit.</text>
    </javadoc>
    <method type="constructor" name="QuantileFinderFactory" startLine="95" endLine="96" />
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * Assumes that quantiles are to be computed over N values.
 * The required sampling rate is computed and stored in the first element of the provided <tt>returnSamplingRate</tt> array, which, therefore must be at least of length 1.</text>
      <param>N the number of values over which quantiles shall be computed (e.g <tt>10^6</tt>).</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To avoid probabilistic answers, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <param>samplingRate output parameter, a <tt>double[1]</tt> where the sampling rate is to be filled in.</param>
      <return><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>returnSamplingRate[0]</tt>=the required sampling rate.</return>
    </javadoc>
    <method type="long[]" name="known_N_compute_B_and_K" startLine="111" endLine="132">
      <scope startLine="113" endLine="119">
        <declaration type="long[]" name="result" />
        <comment>no way around exact quantile search</comment>
      </scope>
      <scope startLine="120" endLine="126">
        <declaration type="long[]" name="result" />
        <comment>can make any error we wish</comment>
      </scope>
      <scope startLine="128" endLine="130" />
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with a <b>guaranteed</b> approximation error no more than epsilon.
 * Assumes that quantiles are to be computed over N values.</text>
      <return><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer.</return>
      <param>N the anticipated number of values over which quantiles shall be determined.</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
    </javadoc>
    <method type="long[]" name="known_N_compute_B_and_K_quick" startLine="141" endLine="228">
      <declaration type="int" name="maxBuffers" />
      <declaration type="int" name="maxHeight" />
      <declaration type="double" name="N_double" />
      <declaration type="double" name="c" />
      <declaration type="int[]" name="heightMaximums" />
      <scope startLine="150" endLine="182">
        <declaration type="int" name="h" />
        <scope startLine="158" endLine="158" />
        <scope startLine="165" endLine="165" />
        <declaration type="int" name="hMax" />
        <scope startLine="174" endLine="176" />
        <scope startLine="177" endLine="179" />
        <comment>skip heights until x<=0</comment>
        <comment>from now on x is monotonically growing...</comment>
        <comment>skip heights until x>0</comment>
        <comment>go back to last height</comment>
        <comment>was x>0 or did we loop without finding anything?</comment>
        <comment>safe some space</comment>
        <comment>end for</comment>
      </scope>
      <declaration type="long[]" name="kMinimums" />
      <scope startLine="188" endLine="199">
        <declaration type="int" name="h" />
        <declaration type="long" name="kMin" />
        <scope startLine="191" endLine="197">
          <declaration type="double" name="value" />
          <declaration type="long" name="tmpK" />
          <scope startLine="194" endLine="196" />
        </scope>
      </scope>
      <declaration type="long" name="multMin" />
      <declaration type="int" name="minB" />
      <scope startLine="204" endLine="212">
        <scope startLine="205" endLine="211">
          <declaration type="long" name="mult" />
          <scope startLine="207" endLine="210" />
        </scope>
      </scope>
      <declaration type="long" name="b" />
      <scope startLine="215" endLine="218">
        <comment>epsilon large enough?</comment>
      </scope>
      <scope startLine="219" endLine="222">
        <comment>epsilon is very small or zero.</comment>
        <comment>the only possible solution without violating the</comment>
        <comment>approximation guarantees is exact quantile search.</comment>
      </scope>
      <declaration type="long[]" name="result" />
      <comment>for each b, determine maximum height, i.e. the height for which x<=0 and x is a maximum</comment>
      <comment>with x = binomial(b+h-2, h-1) - binomial(b+h-3, h-3) + binomial(b+h-3, h-2) - N * epsilon * 2.0</comment>
      <comment>for each b, determine the smallest k satisfying the constraints, i.e.</comment>
      <comment>for each b, determine kMin, with kMin = N/binomial(b+hMax-2,hMax-1)</comment>
      <comment>from all b's, determine b that minimizes b*kMin</comment>
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * Assumes that quantiles are to be computed over N values.
 * The required sampling rate is computed and stored in the first element of the provided <tt>returnSamplingRate</tt> array, which, therefore must be at least of length 1.</text>
      <param>N the anticipated number of values over which quantiles shall be computed (e.g 10^6).</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To avoid probabilistic answers, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <param>samplingRate a <tt>double[1]</tt> where the sampling rate is to be filled in.</param>
      <return><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>returnSamplingRate[0]</tt>=the required sampling rate.</return>
    </javadoc>
    <method type="long[]" name="known_N_compute_B_and_K_slow" startLine="241" endLine="307">
      <declaration type="int" name="maxBuffers" />
      <declaration type="int" name="maxHeight" />
      <declaration type="double" name="N_double" />
      <declaration type="long" name="ret_b" />
      <declaration type="long" name="ret_k" />
      <declaration type="double" name="sampling_rate" />
      <declaration type="long" name="memory" />
      <declaration type="double" name="logarithm" />
      <declaration type="double" name="c" />
      <scope startLine="263" endLine="300">
        <declaration type="double" name="binomial" />
        <declaration type="long" name="tmp" />
        <scope startLine="268" endLine="273" />
        <scope startLine="274" endLine="299">
          <declaration type="double" name="t" />
          <declaration type="double" name="u" />
          <declaration type="double" name="v" />
          <declaration type="double" name="w" />
          <declaration type="double" name="x" />
          <declaration type="long" name="k" />
          <scope startLine="293" endLine="298" />
        </scope>
        <comment>From our SIGMOD 98 paper, we have two equantions to satisfy:</comment>
        <comment>t  <= u * alpha/(1-alpha)^2</comment>
        <comment>kv >= w/(1-alpha)^2</comment>
        <comment />
        <comment>Denoting 1/(1-alpha)    by x,</comment>
        <comment>we see that the first inequality is equivalent to</comment>
        <comment>t/u <= x^2 - x</comment>
        <comment>which is satisfied by x >= 0.5 + 0.5 * sqrt (1 + 4t/u)</comment>
        <comment>Plugging in this value into second equation yields</comment>
        <comment>k >= wx^2/v</comment>
      </scope>
      <declaration type="long[]" name="result" />
      <comment>One possibility is to use one buffer of size N</comment>
      <comment />
      <comment>Otherwise, there are at least two buffers (b >= 2)</comment>
      <comment>and the height of the tree is at least three (h >= 3)</comment>
      <comment />
      <comment>We restrict the search for b and h to MAX_BINOM, a large enough value for</comment>
      <comment>practical values of    epsilon >= 0.001   and    delta >= 0.00001</comment>
      <comment />
    </method>
    <javadoc>
      <text>* Returns a quantile finder that minimizes the amount of memory needed under the user provided constraints.
 * Many applications don't know in advance over how many elements quantiles are to be computed. 
 * However, some of them can give an upper limit, which will assist the factory in choosing quantile finders with minimal memory requirements.  
 * For example if you select values from a database and fill them into histograms, then you probably don't know how many values you will fill, but you probably do know that you will fill at most <tt>S</tt> elements, the size of your database.</text>
      <param>known_N specifies whether the number of elements over which quantiles are to be computed is known or not.</param>
      <param>N if <tt>known_N==true</tt>, the number of elements over which quantiles are to be computed.
 * if <tt>known_N==false</tt>, the upper limit on the number of elements over which quantiles are to be computed. 
 * If such an upper limit is a-priori unknown, then set <tt>N = Long.MAX_VALUE</tt>.</param>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). To avoid probabilistic answers, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <param>generator a uniform random number generator. Set this parameter to <tt>null</tt> to use a default generator.</param>
      <return>the quantile finder minimizing memory requirements under the given constraints.</return>
    </javadoc>
    <method type="DoubleQuantileFinder" name="newDoubleQuantileFinder" startLine="325" endLine="382">
      <declaration type="KnownDoubleQuantileEstimator" name="finder" />
      <scope startLine="338" endLine="345">
        <declaration type="double[]" name="samplingRate" />
        <declaration type="long[]" name="resultKnown" />
        <declaration type="long" name="b" />
        <declaration type="long" name="k" />
      </scope>
      <scope startLine="346" endLine="381">
        <declaration type="long[]" name="resultUnknown" />
        <declaration type="long" name="b1" />
        <declaration type="long" name="k1" />
        <declaration type="long" name="h1" />
        <declaration type="double" name="preComputeEpsilon" />
        <scope startLine="357" endLine="360" />
        <declaration type="double[]" name="samplingRate" />
        <declaration type="long[]" name="resultKnown" />
        <declaration type="long" name="b2" />
        <declaration type="long" name="k2" />
        <scope startLine="373" endLine="376" />
        <comment>if (N==Long.MAX_VALUE) {  no maximum N provided by user.</comment>
        <comment>if (true) fixes bug reported by LarryPeranich@fairisaac.com</comment>
        <comment>no maximum N provided by user.</comment>
        <comment>determine whether UnknownFinder or KnownFinder with maximum N requires less memory.</comment>
        <comment>IMPORTANT: for known finder, switch sampling off (delta == 0) !!!</comment>
        <comment>with knownN-sampling we can only guarantee the errors if the input sequence has EXACTLY N elements.</comment>
        <comment>with knownN-no sampling we can also guarantee the errors for sequences SMALLER than N elements.</comment>
        <comment>the KnownFinder is smaller</comment>
        <comment>the UnknownFinder is smaller</comment>
      </scope>
      <comment>boolean known_N = true;</comment>
      <comment>if (N==Long.MAX_VALUE) known_N = false;</comment>
      <comment>check parameters.</comment>
      <comment>if they are illegal, keep quite and return an exact finder.</comment>
    </method>
    <javadoc>
      <text>* Convenience method that computes phi's for equi-depth histograms.
 * This is simply a list of numbers with <tt>i / (double)quantiles</tt> for <tt>i={1,2,...,quantiles-1}</tt>.</text>
      <return>the equi-depth phi's</return>
    </javadoc>
    <method type="cern.colt.list.DoubleArrayList" name="newEquiDepthPhis" startLine="388" endLine="392">
      <declaration type="cern.colt.list.DoubleArrayList" name="phis" />
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.</text>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact results, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To get exact results, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <return><tt>long[4]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>long[2]</tt>=the tree height where sampling shall start, <tt>long[3]==1</tt> if precomputing is better, otherwise 0;</return>
    </javadoc>
    <method type="long[]" name="unknown_N_compute_B_and_K" startLine="402" endLine="427">
      <comment>move stuff from _raw(..) here and delete _raw(...)</comment>
      <comment>long[] result_1 = unknown_N_compute_B_and_K_raw(epsilon,delta,quantiles);
long b1 = result_1[0];
long k1 = result_1[1];


int quantilesToPrecompute = (int) Doubles.ceiling(1.0  epsilon);

if (quantiles>quantilesToPrecompute) {
 try if precomputing quantiles requires less memory.
long[] result_2 = unknown_N_compute_B_and_K_raw(epsilon2.0,delta,quantilesToPrecompute);

long b2 = result_2[0];
long k2 = result_2[1];
if (b2k2 < b1k1) {
result_2[3] = 1; precomputation is better
result_1 = result_2;
}
}
return result_1;</comment>
    </method>
    <javadoc>
      <text>* Computes the number of buffers and number of values per buffer such that
 * quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 * <b>You never need to call this method.</b> It is only for curious users wanting to gain some insight into the workings of the algorithms.</text>
      <param>epsilon the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;</param>
      <param>delta the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To get exact results, set <tt>delta=0.0</tt>.</param>
      <param>quantiles the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.</param>
      <return><tt>long[4]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>long[2]</tt>=the tree height where sampling shall start, <tt>long[3]==1</tt> if precomputing is better, otherwise 0;</return>
    </javadoc>
    <method type="long[]" name="unknown_N_compute_B_and_K_raw" startLine="438" endLine="570">
      <scope startLine="440" endLine="447">
        <declaration type="long[]" name="result" />
      </scope>
      <scope startLine="448" endLine="456">
        <declaration type="long[]" name="result" />
        <comment>can make any error we wish</comment>
      </scope>
      <scope startLine="457" endLine="465">
        <declaration type="long[]" name="result" />
        <comment>no way around exact quantile search</comment>
      </scope>
      <declaration type="int" name="max_b" />
      <declaration type="int" name="max_h" />
      <declaration type="int" name="max_H" />
      <declaration type="int" name="max_Iterations" />
      <declaration type="long" name="best_b" />
      <declaration type="long" name="best_k" />
      <declaration type="long" name="best_h" />
      <declaration type="long" name="best_memory" />
      <declaration type="double" name="pow" />
      <declaration type="double" name="logDelta" />
      <scope startLine="481" endLine="552">
        <scope startLine="484" endLine="543">
          <scope startLine="485" endLine="542">
            <declaration type="double" name="Ld" />
            <declaration type="double" name="Ls" />
            <declaration type="double" name="c" />
            <declaration type="double" name="beta" />
            <declaration type="double" name="cc" />
            <declaration type="double" name="d" />
            <declaration type="double" name="f" />
            <declaration type="double" name="root" />
            <declaration type="double" name="alpha_one" />
            <declaration type="double" name="alpha_two" />
            <declaration type="boolean" name="alpha_one_OK" />
            <declaration type="boolean" name="alpha_two_OK" />
            <scope startLine="519" endLine="541">
              <declaration type="double" name="alpha" />
              <scope startLine="521" endLine="524" />
              <scope startLine="525" endLine="527" />
              <declaration type="long" name="k" />
              <scope startLine="531" endLine="540">
                <declaration type="long" name="memory" />
                <scope startLine="533" endLine="539" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope startLine="545" endLine="551" />
        <comment>until we find a solution</comment>
        <comment>identify that combination of b and h that minimizes b*k.</comment>
        <comment>exhaustive search.</comment>
        <comment>now we have k>=c*(1-alpha)^-2.</comment>
        <comment>let's compute c.</comment>
        <comment>double c = Math.log(2.0/(delta/quantiles)) / (2.0*epsilon*epsilon*Math.min(Ld, 8.0*Ls/3.0));</comment>
        <comment>now we have k>=d/alpha.</comment>
        <comment>let's compute d.</comment>
        <comment>double d = (Ld(h+max_H-1.0)  +  Ls((h+1)pow - 2.0(h+max_H)))      (Ld + Ls(pow-2.0));
d = (d + 2.0)  (2.0epsilon);</comment>
        <comment>now we have c*(1-alpha)^-2 == d/alpha.</comment>
        <comment>we solve this equation for alpha yielding two solutions</comment>
        <comment>alpha_1,2 = (c + 2*d  +-  Sqrt(c*c + 4*c*d))/(2*d)</comment>
        <comment>non real solution to equation</comment>
        <comment>any alpha must satisfy 0<alpha<1 to yield valid solutions</comment>
        <comment>take the alpha that minimizes d/alpha</comment>
        <comment>now we have k=Ceiling(Max(d/alpha, (h+1)/(2*epsilon)))</comment>
        <comment>valid solution?</comment>
        <comment>found a solution requiring less memory</comment>
        <comment>end for h</comment>
        <comment>end for b</comment>
        <comment>no solution found so far. very unlikely. Anyway, try again.</comment>
        <comment>end while</comment>
      </scope>
      <declaration type="long[]" name="result" />
      <scope startLine="556" endLine="562">
        <comment>no solution found.</comment>
        <comment>no way around exact quantile search.</comment>
      </scope>
      <scope startLine="563" endLine="567" />
      <comment>delta can be set to zero, i.e., all quantiles should be approximate with probability 1</comment>
      <comment>double logDelta =  Math.log(2.0/(quantiles*delta)) / (2.0*epsilon*epsilon);</comment>
    </method>
  </class>
</source>
