<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.math">
  <class name="Arithmetic" extends="Constants" startLine="11">
    <javadoc>
      <text>* Arithmetic functions.</text>
    </javadoc>
    <declaration type="double[]" name="stirlingCorrection" />
    <declaration type="double[]" name="logFactorials" />
    <declaration type="long[]" name="longFactorials" />
    <declaration type="double[]" name="doubleFactorials" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="Arithmetic" startLine="232" endLine="232" />
    <javadoc>
      <text>* Efficiently returns the binomial coefficient, often also referred to as "n over k" or "n choose k".
 * The binomial coefficient is defined as <tt>(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</tt>.
 * <ul>
 * <li>k<0<tt>: <tt>0</tt>.
 * <li>k==0<tt>: <tt>1</tt>.
 * <li>k==1<tt>: <tt>n</tt>.
 * <li>else: <tt>(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</tt>.
 * </ul></text>
      <return>the binomial coefficient.</return>
    </javadoc>
    <method type="double" name="binomial" startLine="244" endLine="257">
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="binomial" />
      <scope startLine="253" endLine="255" />
      <comment>binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</comment>
    </method>
    <javadoc>
      <text>* Efficiently returns the binomial coefficient, often also referred to as "n over k" or "n choose k".
 * The binomial coefficient is defined as
 * <ul>
 * <li>k<0<tt>: <tt>0</tt>.
 * <li>k==0 || k==n<tt>: <tt>1</tt>.
 * <li>k==1 || k==n-1<tt>: <tt>n</tt>.
 * <li>else: <tt>(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</tt>.
 * </ul></text>
      <return>the binomial coefficient.</return>
    </javadoc>
    <method type="double" name="binomial" startLine="269" endLine="299">
      <scope startLine="276" endLine="289">
        <declaration type="int" name="max" />
        <scope startLine="278" endLine="287">
          <declaration type="double" name="n_fac" />
          <declaration type="double" name="k_fac" />
          <declaration type="double" name="n_minus_k_fac" />
          <declaration type="double" name="nk" />
          <scope startLine="283" endLine="286" />
        </scope>
        <comment>if (n! < inf && k! < inf)</comment>
        <comment>no numeric overflow?</comment>
        <comment>now this is completely safe and accurate</comment>
        <comment>quicker</comment>
      </scope>
      <declaration type="long" name="a" />
      <declaration type="long" name="b" />
      <declaration type="double" name="binomial" />
      <scope startLine="295" endLine="297" />
      <comment>try quick version and see whether we get numeric overflows.</comment>
      <comment>factorial(..) is O(1); requires no loop; only a table lookup.</comment>
      <comment>binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )</comment>
    </method>
    <javadoc>
      <text>* Returns the smallest <code>long &gt;= value</code>.
 * <dt>Examples: <code>1.0 -> 1, 1.2 -> 2, 1.9 -> 2</code>.
 * This method is safer than using (long) Math.ceil(value), because of possible rounding error.</text>
    </javadoc>
    <method type="long" name="ceil" startLine="305" endLine="307" />
    <javadoc>
      <text>* Evaluates the series of Chebyshev polynomials Ti at argument x/2.
 * The series is given by
 * <pre>
 * N-1
 * - '
 * y  =   >   coef[i] T (x/2)
 * -            i
 * i=0
 * </pre>
 * Coefficients are stored in reverse order, i.e. the zero
 * order term is last in the array.  Note N is the number of
 * coefficients, not the order.
 * <p>
 * If coefficients are for the interval a to b, x must
 * have been transformed to x -> 2(2x - b - a)/(b-a) before
 * entering the routine.  This maps x from (a, b) to (-1, 1),
 * over which the Chebyshev polynomials are defined.
 * <p>
 * If the coefficients are for the inverted interval, in
 * which (a, b) is mapped to (1/b, 1/a), the transformation
 * required is x -> 2(2ab/x - b - a)/(b-a).  If b is infinity,
 * this becomes x -> 4a/x - 1.
 * <p>
 * SPEED:
 * <p>
 * Taking advantage of the recurrence properties of the
 * Chebyshev polynomials, the routine requires one more
 * addition per loop than evaluating a nested polynomial of
 * the same degree.</text>
      <param>x argument to the polynomial.</param>
      <param>coef the coefficients of the polynomial.</param>
      <param>N the number of coefficients.</param>
    </javadoc>
    <method type="double" name="chbevl" startLine="343" endLine="360">
      <declaration type="double" name="b0" />
      <declaration type="int" name="p" />
      <declaration type="int" name="i" />
      <scope startLine="353" endLine="357" />
    </method>
    <javadoc>
      <text>* Returns the factorial of the argument.</text>
    </javadoc>
    <method type="long" name="fac1" startLine="364" endLine="374">
      <declaration type="long" name="i" />
      <declaration type="long" name="d" />
    </method>
    <javadoc>
      <text>* Returns the factorial of the argument.</text>
    </javadoc>
    <method type="double" name="fac2" startLine="378" endLine="387">
      <declaration type="long" name="i" />
      <declaration type="double" name="d" />
    </method>
    <javadoc>
      <text>* Instantly returns the factorial <tt>k!</tt>.</text>
      <param>k must hold <tt>k &gt;= 0</tt>.</param>
    </javadoc>
    <method type="double" name="factorial" startLine="392" endLine="401">
      <declaration type="int" name="length1" />
      <declaration type="int" name="length2" />
    </method>
    <javadoc>
      <text>* Returns the largest <code>long &lt;= value</code>.
 * <dt>Examples: <code>
 * 1.0 -> 1, 1.2 -> 1, 1.9 -> 1 <dt>
 * 2.0 -> 2, 2.2 -> 2, 2.9 -> 2 </code><dt>
 * This method is safer than using (long) Math.floor(value), because of possible rounding error.</text>
    </javadoc>
    <method type="long" name="floor" startLine="409" endLine="411" />
    <javadoc>
      <text>* Returns <tt>log<sub>base</sub>value</tt>.</text>
    </javadoc>
    <method type="double" name="log" startLine="415" endLine="417" />
    <javadoc>
      <text>* Returns <tt>log<sub>10</sub>value</tt>.</text>
    </javadoc>
    <method type="double" name="log10" startLine="421" endLine="424">
      <comment>1.0 / Math.log(10) == 0.43429448190325176</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>log<sub>2</sub>value</tt>.</text>
    </javadoc>
    <method type="double" name="log2" startLine="428" endLine="431">
      <comment>1.0 / Math.log(2) == 1.4426950408889634</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>log(k!)</tt>.
 * Tries to avoid overflows.
 * For <tt>k<30</tt> simply looks up a table in O(1).
 * For <tt>k>=30</tt> uses stirlings approximation.</text>
      <param>k must hold <tt>k &gt;= 0</tt>.</param>
    </javadoc>
    <method type="double" name="logFactorial" startLine="439" endLine="454">
      <scope startLine="440" endLine="451">
        <declaration type="double" name="r" />
        <declaration type="double" name="C0" />
        <declaration type="double" name="C1" />
        <declaration type="double" name="C3" />
        <declaration type="double" name="C5" />
        <declaration type="double" name="C7" />
      </scope>
    </method>
    <javadoc>
      <text>* Instantly returns the factorial <tt>k!</tt>.</text>
      <param>k must hold <tt>k &gt;= 0 && k &lt; 21</tt>.</param>
    </javadoc>
    <method type="long" name="longFactorial" startLine="459" endLine="464" />
    <javadoc>
      <text>* Returns the StirlingCorrection.                 
 * <p>                                                                      
 * Correction term of the Stirling approximation for <tt>log(k!)</tt>
 * (series in 1/k, or table values for small k)                         
 * with int parameter k.                                            
 * <p>                                                                                                                              
 * <tt>
 * log k! = (k + 1/2)log(k + 1) - (k + 1) + (1/2)log(2Pi) +
 * stirlingCorrection(k + 1)                                    
 * <p>                                                                      
 * log k! = (k + 1/2)log(k)     -  k      + (1/2)log(2Pi) +              
 * stirlingCorrection(k)
 * </tt></text>
    </javadoc>
    <method type="double" name="stirlingCorrection" startLine="480" endLine="494">
      <declaration type="double" name="C1" />
      <declaration type="double" name="C3" />
      <declaration type="double" name="C5" />
      <declaration type="double" name="C7" />
      <declaration type="double" name="r" />
      <scope startLine="488" endLine="492" />
      <comment>+1/12</comment>
      <comment>-1/360</comment>
      <comment>+1/1260</comment>
      <comment>-1/1680</comment>
    </method>
    <javadoc>
      <text>* Equivalent to <tt>Math.round(binomial(n,k))</tt>.</text>
    </javadoc>
    <method type="long" name="xlongBinomial" startLine="498" endLine="500" />
    <comment>for method stirlingCorrection(...)</comment>
    <comment>for method logFactorial(...)</comment>
    <comment>log(k!) for k = 0, ..., 29</comment>
    <comment>k! for k = 0, ..., 20</comment>
    <comment>k! for k = 21, ..., 170</comment>
  </class>
</source>
