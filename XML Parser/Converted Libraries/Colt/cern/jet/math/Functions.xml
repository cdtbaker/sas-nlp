<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.math">
  <import name="cern.colt.function.DoubleDoubleFunction" />
  <import name="cern.colt.function.DoubleDoubleProcedure" />
  <import name="cern.colt.function.DoubleFunction" />
  <import name="cern.colt.function.DoubleProcedure" />
  <class name="Functions" extends="Object" startLine="17">
    <javadoc>
      <text>* Function objects to be passed to generic methods. Contains the functions of {@link java.lang.Math} as function objects, as 
 * well as a few more basic functions.
 * <p>Function objects conveniently allow to express arbitrary functions in a generic 
 * manner. Essentially, a function object is an object that can perform a function 
 * on some arguments. It has a minimal interface: a method <tt>apply</tt> that 
 * takes the arguments, computes something and returns some result value. Function 
 * objects are comparable to function pointers in C used for call-backs.
 * <p>Unary functions are of type {@link cern.colt.function.DoubleFunction}, binary functions 
 * of type {@link cern.colt.function.DoubleDoubleFunction}. All can be retrieved via <tt>public 
 * static final</tt> variables named after the function. 
 * Unary predicates are of type {@link cern.colt.function.DoubleProcedure}, binary predicates 
 * of type {@link cern.colt.function.DoubleDoubleProcedure}. All can be retrieved via <tt>public 
 * static final</tt> variables named <tt>isXXX</tt>. 
 * <p> Binary functions and predicates also exist as unary functions with the second argument being 
 * fixed to a constant. These are generated and retrieved via factory methods (again 
 * with the same name as the function). Example: 
 * <ul>
 * <li><tt>Functions.pow</tt> gives the function <tt>a<sup>b</sup></tt>.
 * <li><tt>Functions.pow.apply(2,3)==8</tt>.
 * <li><tt>Functions.pow(3)</tt> gives the function <tt>a<sup>3</sup></tt>.
 * <li><tt>Functions.pow(3).apply(2)==8</tt>.
 * </ul>
 * More general, any binary function can be made an unary functions by fixing either 
 * the first or the second argument. See methods {@link #bindArg1(DoubleDoubleFunction,double)} 
 * and {@link #bindArg2(DoubleDoubleFunction,double)}. The order of arguments 
 * can be swapped so that the first argument becomes the second and vice-versa. See 
 * method {@link #swapArgs(DoubleDoubleFunction)}. Example: 
 * <ul>
 * <li><tt>Functions.pow</tt> gives the function <tt>a<sup>b</sup></tt>.
 * <li><tt>Functions.bindArg2(Functions.pow,3)</tt> gives the function <tt>x<sup>3</sup></tt>.
 * <li><tt>Functions.bindArg1(Functions.pow,3)</tt> gives the function <tt>3<sup>x</sup></tt>.
 * <li><tt>Functions.swapArgs(Functions.pow)</tt> gives the function <tt>b<sup>a</sup></tt>.
 * </ul>
 * <p>
 * Even more general, functions can be chained (composed, assembled). Assume we have two unary 
 * functions <tt>g</tt> and <tt>h</tt>. The unary function <tt>g(h(a))</tt> applying 
 * both in sequence can be generated via {@link #chain(DoubleFunction,DoubleFunction)}:
 * <ul>
 * <li><tt>Functions.chain(g,h);</tt>
 * </ul> 
 * Assume further we have a binary function <tt>f</tt>. The binary function <tt>g(f(a,b))</tt> 
 * can be generated via {@link #chain(DoubleFunction,DoubleDoubleFunction)}:
 * <ul>
 * <li><tt>Functions.chain(g,f);</tt>
 * </ul>
 * The binary function <tt>f(g(a),h(b))</tt> 
 * can be generated via {@link #chain(DoubleDoubleFunction,DoubleFunction,DoubleFunction)}:
 * <ul>
 * <li><tt>Functions.chain(f,g,h);</tt>
 * </ul>
 * Arbitrarily complex functions can be composed from these building blocks. For example
 * <tt>sin(a) + cos<sup>2</sup>(b)</tt> can be specified as follows:
 * <ul>
 * <li><tt>chain(plus,sin,chain(square,cos));</tt>
 * </ul> 
 * or, of course, as 
 * <pre>
 * new DoubleDoubleFunction() {
 * &nbsp;&nbsp;&nbsp;public final double apply(double a, double b) { return Math.sin(a) + Math.pow(Math.cos(b),2); }
 * }
 * </pre>
 * <p>
 * For aliasing see {@link #functions}.
 * Try this
 * <table>
 * <td class="PRE"> 
 * <pre>
 * // should yield 1.4399560356056456 in all cases
 * double a = 0.5; 
 * double b = 0.2;
 * double v = Math.sin(a) + Math.pow(Math.cos(b),2);
 * System.out.println(v);
 * Functions F = Functions.functions;
 * DoubleDoubleFunction f = F.chain(F.plus,F.sin,F.chain(F.square,F.cos));
 * System.out.println(f.apply(a,b));
 * DoubleDoubleFunction g = new DoubleDoubleFunction() {
 * &nbsp;&nbsp;&nbsp;public double apply(double a, double b) { return Math.sin(a) + Math.pow(Math.cos(b),2); }
 * };
 * System.out.println(g.apply(a,b));
 * </pre>
 * </td>
 * </table>
 * <p>
 * <H3>Performance</H3>
 * Surprise. Using modern non-adaptive JITs such as SunJDK 1.2.2 (java -classic) 
 * there seems to be no or only moderate performance penalty in using function 
 * objects in a loop over traditional code in a loop. For complex nested function 
 * objects (e.g. <tt>F.chain(F.abs,F.chain(F.plus,F.sin,F.chain(F.square,F.cos)))</tt>) 
 * the penalty is zero, for trivial functions (e.g. <tt>F.plus</tt>) the penalty 
 * is often acceptable.
 * <center>
 * <table border cellpadding="3" cellspacing="0" align="center">
 * <tr valign="middle" bgcolor="#33CC66" nowrap align="center"> 
 * <td nowrap colspan="7"> <font size="+2">Iteration Performance [million function 
 * evaluations per second]</font><br>
 * <font size="-1">Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic, 
 * </font></td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td nowrap bgcolor="#FF9966" rowspan="2">&nbsp;</td>
 * <td bgcolor="#FF9966" colspan="2"> 
 * <p> 30000000 iterations</p>
 * </td>
 * <td bgcolor="#FF9966" colspan="2"> 3000000 iterations (10 times less)</td>
 * <td bgcolor="#FF9966" colspan="2">&nbsp;</td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td bgcolor="#FF9966"> <tt>F.plus</tt></td>
 * <td bgcolor="#FF9966"><tt>a+b</tt></td>
 * <td bgcolor="#FF9966"> <tt>F.chain(F.abs,F.chain(F.plus,F.sin,F.chain(F.square,F.cos)))</tt></td>
 * <td bgcolor="#FF9966"> <tt>Math.abs(Math.sin(a) + Math.pow(Math.cos(b),2))</tt></td>
 * <td bgcolor="#FF9966">&nbsp;</td>
 * <td bgcolor="#FF9966">&nbsp;</td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td nowrap bgcolor="#FF9966">&nbsp;</td>
 * <td nowrap>10.8</td>
 * <td nowrap>29.6</td>
 * <td nowrap>0.43</td>
 * <td nowrap>0.35</td>
 * <td nowrap>&nbsp;</td>
 * <td nowrap>&nbsp;</td>
 * </tr>
 * </table></center></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* Little trick to allow for "aliasing", that is, renaming this class.
 * Writing code like
 * <p>
 * <tt>Functions.chain(Functions.plus,Functions.sin,Functions.chain(Functions.square,Functions.cos));</tt>
 * <p>
 * is a bit awkward, to say the least.
 * Using the aliasing you can instead write
 * <p>
 * <tt>Functions F = Functions.functions; <br>
 * F.chain(F.plus,F.sin,F.chain(F.square,F.cos));</tt></text>
    </javadoc>
    <declaration type="Functions" name="functions" />
    <javadoc>
      <text>* Function that returns <tt>Math.abs(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="173" endLine="173" />
    <declaration type="DoubleFunction" name="abs" />
    <javadoc>
      <text>* Function that returns <tt>Math.acos(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="180" endLine="180" />
    <declaration type="DoubleFunction" name="acos" />
    <javadoc>
      <text>* Function that returns <tt>Math.asin(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="196" endLine="196" />
    <declaration type="DoubleFunction" name="asin" />
    <javadoc>
      <text>* Function that returns <tt>Math.atan(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="212" endLine="212" />
    <declaration type="DoubleFunction" name="atan" />
    <javadoc>
      <text>* Function that returns <tt>Math.ceil(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="228" endLine="228" />
    <declaration type="DoubleFunction" name="ceil" />
    <javadoc>
      <text>* Function that returns <tt>Math.cos(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="235" endLine="235" />
    <declaration type="DoubleFunction" name="cos" />
    <javadoc>
      <text>* Function that returns <tt>Math.exp(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="278" endLine="278" />
    <declaration type="DoubleFunction" name="exp" />
    <javadoc>
      <text>* Function that returns <tt>Math.floor(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="285" endLine="285" />
    <declaration type="DoubleFunction" name="floor" />
    <javadoc>
      <text>* Function that returns its argument.</text>
    </javadoc>
    <method type="double" name="apply" startLine="301" endLine="301" />
    <declaration type="DoubleFunction" name="identity" />
    <javadoc>
      <text>* Function that returns <tt>1.0 / a</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="308" endLine="308" />
    <declaration type="DoubleFunction" name="inv" />
    <javadoc>
      <text>* Function that returns <tt>Math.log(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="315" endLine="315" />
    <declaration type="DoubleFunction" name="log" />
    <javadoc>
      <text>* Function that returns <tt>Math.log(a) / Math.log(2)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="332" endLine="332" />
    <declaration type="DoubleFunction" name="log2" />
    <javadoc>
      <text>* Function that returns <tt>-a</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="348" endLine="348" />
    <declaration type="DoubleFunction" name="neg" />
    <javadoc>
      <text>* Function that returns <tt>Math.rint(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="355" endLine="355" />
    <declaration type="DoubleFunction" name="rint" />
    <javadoc>
      <text>* Function that returns <tt>a < 0 ? -1 : a > 0 ? 1 : 0</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="362" endLine="362" />
    <declaration type="DoubleFunction" name="sign" />
    <javadoc>
      <text>* Function that returns <tt>Math.sin(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="369" endLine="369" />
    <declaration type="DoubleFunction" name="sin" />
    <javadoc>
      <text>* Function that returns <tt>Math.sqrt(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="385" endLine="385" />
    <declaration type="DoubleFunction" name="sqrt" />
    <javadoc>
      <text>* Function that returns <tt>a * a</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="392" endLine="392" />
    <declaration type="DoubleFunction" name="square" />
    <javadoc>
      <text>* Function that returns <tt>Math.tan(a)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="399" endLine="399" />
    <declaration type="DoubleFunction" name="tan" />
    <javadoc>
      <text>* Function that returns <tt>Math.atan2(a,b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="439" endLine="439" />
    <declaration type="DoubleDoubleFunction" name="atan2" />
    <javadoc>
      <text>* Function that returns <tt>a < b ? -1 : a > b ? 1 : 0</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="456" endLine="456" />
    <declaration type="DoubleDoubleFunction" name="compare" />
    <javadoc>
      <text>* Function that returns <tt>a / b</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="463" endLine="463" />
    <declaration type="DoubleDoubleFunction" name="div" />
    <javadoc>
      <text>* Function that returns <tt>a == b ? 1 : 0</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="470" endLine="470" />
    <declaration type="DoubleDoubleFunction" name="equals" />
    <javadoc>
      <text>* Function that returns <tt>a > b ? 1 : 0</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="477" endLine="477" />
    <declaration type="DoubleDoubleFunction" name="greater" />
    <javadoc>
      <text>* Function that returns <tt>Math.IEEEremainder(a,b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="484" endLine="484" />
    <declaration type="DoubleDoubleFunction" name="IEEEremainder" />
    <javadoc>
      <text>* Function that returns <tt>a == b</tt>.</text>
    </javadoc>
    <method type="boolean" name="apply" startLine="491" endLine="491" />
    <declaration type="DoubleDoubleProcedure" name="isEqual" />
    <javadoc>
      <text>* Function that returns <tt>a < b</tt>.</text>
    </javadoc>
    <method type="boolean" name="apply" startLine="498" endLine="498" />
    <declaration type="DoubleDoubleProcedure" name="isLess" />
    <javadoc>
      <text>* Function that returns <tt>a > b</tt>.</text>
    </javadoc>
    <method type="boolean" name="apply" startLine="505" endLine="505" />
    <declaration type="DoubleDoubleProcedure" name="isGreater" />
    <javadoc>
      <text>* Function that returns <tt>a < b ? 1 : 0</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="512" endLine="512" />
    <declaration type="DoubleDoubleFunction" name="less" />
    <javadoc>
      <text>* Function that returns <tt>Math.log(a) / Math.log(b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="519" endLine="519" />
    <declaration type="DoubleDoubleFunction" name="lg" />
    <javadoc>
      <text>* Function that returns <tt>Math.max(a,b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="526" endLine="526" />
    <declaration type="DoubleDoubleFunction" name="max" />
    <javadoc>
      <text>* Function that returns <tt>Math.min(a,b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="533" endLine="533" />
    <declaration type="DoubleDoubleFunction" name="min" />
    <javadoc>
      <text>* Function that returns <tt>a - b</tt>.</text>
    </javadoc>
    <declaration type="DoubleDoubleFunction" name="minus" />
    <javadoc>
      <text>* Function that returns <tt>a % b</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="550" endLine="550" />
    <declaration type="DoubleDoubleFunction" name="mod" />
    <javadoc>
      <text>* Function that returns <tt>a * b</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="557" endLine="557" />
    <declaration type="DoubleDoubleFunction" name="mult" />
    <javadoc>
      <text>* Function that returns <tt>a + b</tt>.</text>
    </javadoc>
    <declaration type="DoubleDoubleFunction" name="plus" />
    <javadoc>
      <text>* Function that returns <tt>Math.abs(a) + Math.abs(b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="574" endLine="574" />
    <declaration type="DoubleDoubleFunction" name="plusAbs" />
    <javadoc>
      <text>* Function that returns <tt>Math.pow(a,b)</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="581" endLine="581" />
    <declaration type="DoubleDoubleFunction" name="pow" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="Functions" startLine="586" endLine="586" />
    <javadoc>
      <text>* Constructs a function that returns <tt>(from<=a && a<=to) ? 1 : 0</tt>.
 * <tt>a</tt> is a variable, <tt>from</tt> and <tt>to</tt> are fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="between" startLine="591" endLine="595">
      <method type="double" name="apply" startLine="593" endLine="593" />
    </method>
    <javadoc>
      <text>* Constructs a unary function from a binary function with the first operand (argument) fixed to the given constant <tt>c</tt>.
 * The second operand is variable (free).</text>
      <param>function a binary function taking operands in the form <tt>function.apply(c,var)</tt>.</param>
      <return>the unary function <tt>function(c,var)</tt>.</return>
    </javadoc>
    <method type="DoubleFunction" name="bindArg1" startLine="603" endLine="607">
      <method type="double" name="apply" startLine="605" endLine="605" />
    </method>
    <javadoc>
      <text>* Constructs a unary function from a binary function with the second operand (argument) fixed to the given constant <tt>c</tt>.
 * The first operand is variable (free).</text>
      <param>function a binary function taking operands in the form <tt>function.apply(var,c)</tt>.</param>
      <return>the unary function <tt>function(var,c)</tt>.</return>
    </javadoc>
    <method type="DoubleFunction" name="bindArg2" startLine="615" endLine="619">
      <method type="double" name="apply" startLine="617" endLine="617" />
    </method>
    <javadoc>
      <text>* Constructs the function <tt>f( g(a), h(b) )</tt>.</text>
      <param>f a binary function.</param>
      <param>g a unary function.</param>
      <param>h a unary function.</param>
      <return>the binary function <tt>f( g(a), h(b) )</tt>.</return>
    </javadoc>
    <method type="DoubleDoubleFunction" name="chain" startLine="628" endLine="632">
      <method type="double" name="apply" startLine="630" endLine="630" />
    </method>
    <javadoc>
      <text>* Constructs the function <tt>g( h(a,b) )</tt>.</text>
      <param>g a unary function.</param>
      <param>h a binary function.</param>
      <return>the unary function <tt>g( h(a,b) )</tt>.</return>
    </javadoc>
    <method type="DoubleDoubleFunction" name="chain" startLine="640" endLine="644">
      <method type="double" name="apply" startLine="642" endLine="642" />
    </method>
    <javadoc>
      <text>* Constructs the function <tt>g( h(a) )</tt>.</text>
      <param>g a unary function.</param>
      <param>h a unary function.</param>
      <return>the unary function <tt>g( h(a) )</tt>.</return>
    </javadoc>
    <method type="DoubleFunction" name="chain" startLine="652" endLine="656">
      <method type="double" name="apply" startLine="654" endLine="654" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a < b ? -1 : a > b ? 1 : 0</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="compare" startLine="661" endLine="665">
      <method type="double" name="apply" startLine="663" endLine="663" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns the constant <tt>c</tt>.</text>
    </javadoc>
    <method type="DoubleFunction" name="constant" startLine="669" endLine="673">
      <method type="double" name="apply" startLine="671" endLine="671" />
    </method>
    <javadoc>
      <text>* Demonstrates usage of this class.</text>
    </javadoc>
    <method type="void" name="demo1" startLine="677" endLine="694">
      <declaration type="cern.jet.math.Functions" name="F" />
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="v" />
      <declaration type="DoubleDoubleFunction" name="f" />
      <declaration type="DoubleDoubleFunction" name="g" />
      <method type="double" name="apply" startLine="687" endLine="687" />
      <declaration type="DoubleFunction" name="m" />
      <declaration type="DoubleFunction" name="n" />
      <comment>DoubleDoubleFunction f = F.chain(plus,sin,F.chain(square,cos));</comment>
    </method>
    <javadoc>
      <text>* Benchmarks and demonstrates usage of trivial and complex functions.</text>
    </javadoc>
    <method type="void" name="demo2" startLine="698" endLine="766">
      <declaration type="cern.jet.math.Functions" name="F" />
      <declaration type="double" name="a" />
      <declaration type="double" name="b" />
      <declaration type="double" name="v" />
      <declaration type="DoubleDoubleFunction" name="f" />
      <declaration type="DoubleDoubleFunction" name="g" />
      <method type="double" name="apply" startLine="715" endLine="715" />
      <declaration type="cern.colt.Timer" name="emptyLoop" />
      <declaration type="double" name="sum" />
      <scope startLine="724" endLine="728" />
      <declaration type="cern.colt.Timer" name="timer" />
      <scope startLine="735" endLine="739">
        <comment>sum += a + b;</comment>
      </scope>
      <scope startLine="747" endLine="750" />
      <scope startLine="758" endLine="761" />
      <comment>double v = Math.sin(a) + Math.pow(Math.cos(b),2);</comment>
      <comment>double v = a + b;</comment>
      <comment>DoubleDoubleFunction f = F.chain(F.plus,F.identity,F.identity);</comment>
      <comment>DoubleDoubleFunction f = F.chain(F.plus,F.sin,F.chain(F.square,F.cos));</comment>
      <comment>DoubleDoubleFunction f = F.plus;</comment>
      <comment>public final double apply(double x, double y) { return x+y; }</comment>
      <comment>emptyLoop</comment>
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a / b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="div" startLine="771" endLine="773" />
    <javadoc>
      <text>* Constructs a function that returns <tt>a == b ? 1 : 0</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="equals" startLine="778" endLine="782">
      <method type="double" name="apply" startLine="780" endLine="780" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a > b ? 1 : 0</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="greater" startLine="787" endLine="791">
      <method type="double" name="apply" startLine="789" endLine="789" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>Math.IEEEremainder(a,b)</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="IEEEremainder" startLine="796" endLine="800">
      <method type="double" name="apply" startLine="798" endLine="798" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>from<=a && a<=to</tt>.
 * <tt>a</tt> is a variable, <tt>from</tt> and <tt>to</tt> are fixed.</text>
    </javadoc>
    <method type="DoubleProcedure" name="isBetween" startLine="805" endLine="809">
      <method type="boolean" name="apply" startLine="807" endLine="807" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a == b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleProcedure" name="isEqual" startLine="814" endLine="818">
      <method type="boolean" name="apply" startLine="816" endLine="816" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a > b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleProcedure" name="isGreater" startLine="823" endLine="827">
      <method type="boolean" name="apply" startLine="825" endLine="825" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a < b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleProcedure" name="isLess" startLine="832" endLine="836">
      <method type="boolean" name="apply" startLine="834" endLine="834" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a < b ? 1 : 0</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="less" startLine="841" endLine="845">
      <method type="double" name="apply" startLine="843" endLine="843" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt><tt>Math.log(a) / Math.log(b)</tt></tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="lg" startLine="850" endLine="855">
      <declaration type="double" name="logInv" />
      <method type="double" name="apply" startLine="853" endLine="853" />
      <comment>cached for speed</comment>
    </method>
    <javadoc>
      <text>* Tests various methods of this class.</text>
    </javadoc>
    <method type="void" name="main" startLine="859" endLine="863">
      <declaration type="int" name="size" />
      <comment>demo1();</comment>
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>Math.max(a,b)</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="max" startLine="868" endLine="872">
      <method type="double" name="apply" startLine="870" endLine="870" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>Math.min(a,b)</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="min" startLine="877" endLine="881">
      <method type="double" name="apply" startLine="879" endLine="879" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a - b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="minus" startLine="886" endLine="888" />
    <javadoc>
      <text>* Constructs a function that returns <tt>a - b*constant</tt>.
 * <tt>a</tt> and <tt>b</tt> are variables, <tt>constant</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleDoubleFunction" name="minusMult" startLine="893" endLine="895" />
    <javadoc>
      <text>* Constructs a function that returns <tt>a % b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="mod" startLine="900" endLine="904">
      <method type="double" name="apply" startLine="902" endLine="902" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a * b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="mult" startLine="909" endLine="916">
      <comment>return new DoubleFunction() {
public final double apply(double a) { return a  b; }
};</comment>
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a + b</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="plus" startLine="921" endLine="925">
      <method type="double" name="apply" startLine="923" endLine="923" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>a + b*constant</tt>.
 * <tt>a</tt> and <tt>b</tt> are variables, <tt>constant</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleDoubleFunction" name="plusMult" startLine="930" endLine="937">
      <comment>return new DoubleDoubleFunction() {
public final double apply(double a, double b) { return a + bconstant; }
};</comment>
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>Math.pow(a,b)</tt>.
 * <tt>a</tt> is a variable, <tt>b</tt> is fixed.</text>
    </javadoc>
    <method type="DoubleFunction" name="pow" startLine="942" endLine="946">
      <method type="double" name="apply" startLine="944" endLine="944" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns a new uniform random number in the open unit interval <code>(0.0,1.0)</code> (excluding 0.0 and 1.0).
 * Currently the engine is {@link cern.jet.random.engine.MersenneTwister}and is seeded with the current time.
 * <p>
 * Note that any random engine derived from {@link cern.jet.random.engine.RandomEngine} and any random distribution derived from {@link cern.jet.random.AbstractDistribution} are function objects, because they implement the proper interfaces.
 * Thus, if you are not happy with the default, just pass your favourite random generator to function evaluating methods.</text>
    </javadoc>
    <method type="DoubleFunction" name="random" startLine="955" endLine="957" />
    <javadoc>
      <text>* Constructs a function that returns the number rounded to the given precision; <tt>Math.rint(a/precision)*precision</tt>.
 * Examples:
 * <pre>
 * precision = 0.01 rounds 0.012 --> 0.01, 0.018 --> 0.02
 * precision = 10   rounds 123   --> 120 , 127   --> 130
 * </pre></text>
    </javadoc>
    <method type="DoubleFunction" name="round" startLine="966" endLine="970">
      <method type="double" name="apply" startLine="968" endLine="968" />
    </method>
    <javadoc>
      <text>* Constructs a function that returns <tt>function.apply(b,a)</tt>, i.e. applies the function with the first operand as second operand and the second operand as first operand.</text>
      <param>function a function taking operands in the form <tt>function.apply(a,b)</tt>.</param>
      <return>the binary function <tt>function(b,a)</tt>.</return>
    </javadoc>
    <method type="DoubleDoubleFunction" name="swapArgs" startLine="977" endLine="981">
      <method type="double" name="apply" startLine="979" endLine="979" />
    </method>
    <javadoc>
      <text>* <H3>Unary functions</H3></text>
    </javadoc>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.acosh(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction acosh = new DoubleFunction() {
public final double apply(double a) { return Sfun.acosh(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.asinh(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction asinh = new DoubleFunction() {
public final double apply(double a) { return Sfun.asinh(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.atanh(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction atanh = new DoubleFunction() {
public final double apply(double a) { return Sfun.atanh(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.cosh(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction cosh = new DoubleFunction() {
public final double apply(double a) { return Sfun.cosh(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.cot(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction cot = new DoubleFunction() {
public final double apply(double a) { return Sfun.cot(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.erf(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction erf = new DoubleFunction() {
public final double apply(double a) { return Sfun.erf(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.erfc(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction erfc = new DoubleFunction() {
public final double apply(double a) { return Sfun.erfc(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.gamma(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction gamma = new DoubleFunction() {
public final double apply(double a) { return Sfun.gamma(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.log10(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction log10 = new DoubleFunction() {
public final double apply(double a) { return Sfun.log10(a); }
};</comment>
    <comment>1.0 / Math.log(2) == 1.4426950408889634</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.logGamma(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction logGamma = new DoubleFunction() {
public final double apply(double a) { return Sfun.logGamma(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.sinh(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction sinh = new DoubleFunction() {
public final double apply(double a) { return Sfun.sinh(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.tanh(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction tanh = new DoubleFunction() {
public final double apply(double a) { return Sfun.tanh(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>Math.toDegrees(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction toDegrees = new DoubleFunction() {
public final double apply(double a) { return Math.toDegrees(a); }
};</comment>
    <javadoc>
      <text>* Function that returns <tt>Math.toRadians(a)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleFunction toRadians = new DoubleFunction() {
public final double apply(double a) { return Math.toRadians(a); }
};</comment>
    <javadoc>
      <text>* <H3>Binary functions</H3></text>
    </javadoc>
    <javadoc>
      <text>* Function that returns <tt>com.imsl.math.Sfun.logBeta(a,b)</tt>.</text>
    </javadoc>
    <comment>public static final DoubleDoubleFunction logBeta = new DoubleDoubleFunction() {
public final double apply(double a, double b) { return Sfun.logBeta(a,b); }
};</comment>
    <comment>new DoubleDoubleFunction() {
public final double apply(double a, double b) { return a - b; }
};</comment>
    <comment>new DoubleDoubleFunction() {
public final double apply(double a, double b) { return a + b; }
};</comment>
  </class>
</source>
