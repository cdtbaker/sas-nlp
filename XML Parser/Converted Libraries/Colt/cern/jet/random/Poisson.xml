<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.jet.random">
  <import name="cern.jet.math.Arithmetic" />
  <import name="cern.jet.random.engine.RandomEngine" />
  <import name="cern.jet.stat.Probability" />
  <class name="Poisson" extends="AbstractDiscreteDistribution" startLine="14">
    <javadoc>
      <text>* Poisson distribution (quick); See the <A HREF="http://www.cern.ch/RD11/rkb/AN16pp/node208.html#SECTION0002080000000000000000"> math definition</A>
 * and <A HREF="http://www.statsoft.com/textbook/glosp.html#Poisson Distribution"> animated definition</A>.
 * <p>
 * <tt>p(k) = (mean^k / k!) * exp(-mean)</tt> for <tt>k &gt;= 0</tt>.
 * <p>
 * Valid parameter ranges: <tt>mean &gt; 0</tt>.
 * Note: if <tt>mean &lt;= 0.0</tt> then always returns zero.
 * <p>
 * Instance methods operate on a user supplied uniform random number generator; they are unsynchronized.
 * <dt>
 * Static methods operate on a default uniform random number generator; they are synchronized.
 * <p>
 * <b>Implementation:</b> High performance implementation.
 * Patchwork Rejection/Inversion method.
 * <dt>This is a port of <tt>pprsc.c</tt> from the <A HREF="http://www.cis.tu-graz.ac.at/stat/stadl/random.html">C-RAND / WIN-RAND</A> library.
 * C-RAND's implementation, in turn, is based upon
 * <p>
 * H. Zechner (1994): Efficient sampling from continuous and discrete unimodal distributions,
 * Doctoral Dissertation, 156 pp., Technical University Graz, Austria.
 * <p>
 * Also see
 * <p>
 * Stadlober E., H. Zechner (1999), <A HREF="http://www.cis.tu-graz.ac.at/stat/stadl/random.html">The patchwork rejection method for sampling from unimodal distributions</A>,
 * to appear in ACM Transactions on Modelling and Simulation.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <declaration type="double" name="mean" />
    <declaration type="double" name="my_old" />
    <declaration type="double" name="p" />
    <declaration type="double[]" name="pp" />
    <declaration type="int" name="llll" />
    <declaration type="double" name="my_last" />
    <declaration type="double" name="ll" />
    <declaration type="int" name="k2" />
    <declaration type="double" name="dl" />
    <declaration type="double" name="f1" />
    <declaration type="int" name="m" />
    <declaration type="double" name="MEAN_MAX" />
    <declaration type="double" name="SWITCH_MEAN" />
    <declaration type="Poisson" name="shared" />
    <javadoc>
      <text>* Constructs a poisson distribution.
 * Example: mean=1.0.</text>
    </javadoc>
    <method type="constructor" name="Poisson" startLine="74" endLine="77" />
    <javadoc>
      <text>* Returns the cumulative distribution function.</text>
    </javadoc>
    <method type="double" name="cdf" startLine="81" endLine="83" />
    <javadoc>
      <text>* Returns a deep copy of the receiver; the copy will produce identical sequences.
 * After this call has returned, the copy and the receiver have equal but separate state.</text>
      <return>a copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="90" endLine="94">
      <declaration type="Poisson" name="copy" />
    </method>
    <method type="double" name="f" startLine="95" endLine="97" />
    <javadoc>
      <text>* Returns a random number from the distribution.</text>
    </javadoc>
    <method type="int" name="nextInt" startLine="101" endLine="103" />
    <javadoc>
      <text>* Returns a random number from the distribution; bypasses the internal state.</text>
    </javadoc>
    <method type="int" name="nextInt" startLine="107" endLine="295">
      <declaration type="RandomEngine" name="gen" />
      <declaration type="double" name="my" />
      <declaration type="double" name="t" />
      <declaration type="double" name="gx" />
      <declaration type="int" name="sign" />
      <declaration type="double" name="u" />
      <declaration type="int" name="k" />
      <scope startLine="137" endLine="167">
        <scope startLine="138" endLine="145" />
        <scope startLine="147" endLine="166">
          <scope startLine="151" endLine="155" />
          <scope startLine="156" endLine="164">
            <scope startLine="160" endLine="163" />
          </scope>
        </scope>
        <comment>CASE B: Inversion- start new table and calculate p0</comment>
        <comment>for (k=pp.length; --k >=0; ) pp[k] = 0;</comment>
        <comment>Step U. Uniform sample</comment>
        <comment>Step T. Table comparison</comment>
        <comment>Step C. Creation of new prob.</comment>
        <comment>end my < SWITCH_MEAN</comment>
      </scope>
      <scope startLine="168" endLine="291">
        <declaration type="int" name="Dk" />
        <declaration type="double" name="Ds" />
        <scope startLine="177" endLine="222" />
        <scope startLine="224" endLine="290">
          <scope startLine="227" endLine="248">
            <scope startLine="237" endLine="239" />
            <scope startLine="240" endLine="246">
              <scope startLine="242" endLine="244" />
            </scope>
          </scope>
          <scope startLine="249" endLine="269">
            <scope startLine="258" endLine="260" />
            <scope startLine="261" endLine="267">
              <scope startLine="263" endLine="265" />
            </scope>
          </scope>
          <scope startLine="270" endLine="284">
            <scope startLine="272" endLine="277" />
            <scope startLine="278" endLine="283" />
          </scope>
        </scope>
        <comment>CASE A: acceptance complement</comment>
        <comment>static double        my_last = -1.0;</comment>
        <comment>static long int      m,  k2, k4, k1, k5;</comment>
        <comment>static double        dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,</comment>
        <comment>f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;</comment>
        <comment>set-up</comment>
        <comment>approximate deviation of reflection points k2, k4 from my - 1/2</comment>
        <comment>mode m, reflection points k2 and k4, and points k1 and k5, which</comment>
        <comment>delimit the centre region of h(x)</comment>
        <comment>range width of the critical left and right centre region</comment>
        <comment>recurrence constants r(k) = p(k)/p(k-1) at k = k1, k2, k4+1, k5+1</comment>
        <comment>reciprocal values of the scale parameters of expon. tail envelopes</comment>
        <comment>expon. tail left</comment>
        <comment>expon. tail right</comment>
        <comment>Poisson constants, necessary for computing function values f(k)</comment>
        <comment>function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5</comment>
        <comment>area of the two centre and the two exponential tail regions</comment>
        <comment>area of the two immediate acceptance regions between k2, k4</comment>
        <comment>immed. left</comment>
        <comment>centre left</comment>
        <comment>immed. right</comment>
        <comment>centre right</comment>
        <comment>expon. tail left</comment>
        <comment>expon. tail right</comment>
        <comment>end set-up</comment>
        <comment>generate uniform number U -- U(0, p6)</comment>
        <comment>case distinction corresponding to U</comment>
        <comment>centre left</comment>
        <comment>immediate acceptance region R2 = [k2, m) *[0, f2),  X = k2, ... m -1</comment>
        <comment>immediate acceptance region R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1</comment>
        <comment>computation of candidate X < k2, and its counterpart Y > k2</comment>
        <comment>either squeeze-acceptance of X or acceptance-rejection of Y</comment>
        <comment>quick accept of</comment>
        <comment>X = k2 - Dk</comment>
        <comment>quick reject of Y</comment>
        <comment>quick accept of</comment>
        <comment>Y = k2 + Dk</comment>
        <comment>final accept of Y</comment>
        <comment>centre right</comment>
        <comment>immediate acceptance region R3 = [m, k4+1)*[0, f4), X = m, ... k4</comment>
        <comment>immediate acceptance region R4 = [k4+1, k5+1)*[0, f5)</comment>
        <comment>computation of candidate X > k4, and its counterpart Y < k4</comment>
        <comment>either squeeze-acceptance of X or acceptance-rejection of Y</comment>
        <comment>quick accept of</comment>
        <comment>X = k4 + Dk</comment>
        <comment>quick reject of Y</comment>
        <comment>quick accept of</comment>
        <comment>Y = k4 - Dk</comment>
        <comment>final accept of Y</comment>
        <comment>expon. tail left</comment>
        <comment>0 <= X <= k1 - 1</comment>
        <comment>W -- U(0, h(x))</comment>
        <comment>quick accept of X</comment>
        <comment>expon. tail right</comment>
        <comment>X >= k5 + 1</comment>
        <comment>W -- U(0, h(x))</comment>
        <comment>quick accept of X</comment>
        <comment>acceptance-rejection test of candidate X from the original area</comment>
        <comment>test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)</comment>
        <comment>log f(X) = (X - m)*log(my) - log X! + log m!</comment>
      </scope>
      <scope startLine="292" endLine="294">
        <comment>mean is too large</comment>
      </scope>
      <javadoc>
        <text>* *
 * Poisson Distribution - Patchwork Rejection/Inversion           
 * *
 * *
 * For parameter  my < 10  Tabulated Inversion is applied.        
 * For my >= 10  Patchwork Rejection is employed:                 
 * The area below the histogram function f(x) is rearranged in    
 * its body by certain point reflections. Within a large center   
 * interval variates are sampled efficiently by rejection from    
 * uniform hats. Rectangular immediate acceptance regions speed   
 * up the generation. The remaining tails are covered by          
 * exponential functions.                                         
 * *</text>
      </javadoc>
      <comment>static double p,q,p0,pp[36];</comment>
      <comment>static long ll,m;</comment>
    </method>
    <javadoc>
      <text>* Returns the probability distribution function.</text>
    </javadoc>
    <method type="double" name="pdf" startLine="299" endLine="304">
      <comment>Overflow sensitive:</comment>
      <comment>return (Math.pow(mean,k) / cephes.Arithmetic.factorial(k)) * Math.exp(-this.mean);</comment>
    </method>
    <javadoc>
      <text>* Sets the mean.</text>
    </javadoc>
    <method type="void" name="setMean" startLine="308" endLine="310" />
    <javadoc>
      <text>* Returns a random number from the distribution with the given mean.</text>
    </javadoc>
    <method type="int" name="staticNextInt" startLine="314" endLine="319">
      <scope startLine="315" endLine="318" />
    </method>
    <javadoc>
      <text>* Returns a String representation of the receiver.</text>
    </javadoc>
    <method type="String" name="toString" startLine="323" endLine="325" />
    <javadoc>
      <text>* Sets the uniform random number generated shared by all <b>static</b> methods.</text>
      <param>randomGenerator the new uniform random number generator to be shared.</param>
    </javadoc>
    <method type="void" name="xstaticSetRandomGenerator" startLine="330" endLine="334">
      <scope startLine="331" endLine="333" />
    </method>
    <comment>precomputed and cached values (for performance only)</comment>
    <comment>cache for < SWITCH_MEAN</comment>
    <comment>cache for >= SWITCH_MEAN</comment>
    <comment>cache for both;</comment>
    <comment>for all means larger than that, we don't try to compute a poisson deviation, but return the mean.</comment>
    <comment>switch from method A to method B</comment>
    <comment>The uniform random number generated shared by all <b>static</b> methods.</comment>
  </class>
</source>
