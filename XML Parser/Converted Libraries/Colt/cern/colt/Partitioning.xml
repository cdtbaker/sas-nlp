<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt">
  <import name="cern.colt.function.IntComparator" />
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <class name="Partitioning" extends="Object" startLine="14">
    <javadoc>
      <text>* Given some interval boundaries, partitions arrays such that all elements falling into an interval are placed next to each other.
 * <p>
 * The algorithms partition arrays into two or more intervals. 
 * They distinguish between <i>synchronously</i> partitioning either one, two or three arrays.
 * They further come in templated versions, either partitioning <tt>int[]</tt> arrays or <tt>double[]</tt> arrays.
 * <p>
 * You may want to start out reading about the simplest case: Partitioning one <tt>int[]</tt> array into two intervals.
 * To do so, read {@link #partition(int[],int,int,int)}.
 * Next, building upon that foundation comes a method partitioning <tt>int[]</tt> arrays into multiple intervals.
 * See {@link #partition(int[],int,int,int[],int,int,int[])} for related documentation.
 * <p>
 * All other methods are no different than the one's you now already understand, except that they operate on slightly different data types.
 * <p>
 * <b>Performance</b>
 * <p>
 * Partitioning into two intervals is <tt>O( N )</tt>.
 * Partitioning into k intervals is <tt>O( N * log(k))</tt>.
 * Constants factors are minimized.
 * No temporary memory is allocated; Partitioning is in-place.</text>
      <see>cern.colt.matrix.doublealgo.Partitioning</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 03-Jul-99</version>
    </javadoc>
    <declaration type="int" name="SMALL" />
    <declaration type="int" name="MEDIUM" />
    <declaration type="int" name="steps" />
    <declaration type="int" name="swappedElements" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="Partitioning" startLine="51" endLine="51" />
    <javadoc>
      <text>* Finds the given key "a" within some generic data using the binary search algorithm.</text>
      <param>a the index of the key to search for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <param>comp the comparator determining the order of the generic data.
 * Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
 * Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="69" endLine="78">
      <scope startLine="70" endLine="76">
        <declaration type="int" name="mid" />
        <declaration type="int" name="comparison" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #dualPartition(int[],int[],int,int,int[],int,int,int[])}except that it <i>synchronously</i> partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="void" name="dualPartition" startLine="83" endLine="151">
      <declaration type="double" name="splitter" />
      <scope startLine="87" endLine="91">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="97" endLine="99">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="100" endLine="120">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="103" endLine="113">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="106" endLine="111">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="129" endLine="134">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="135" endLine="140">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="143" endLine="145" />
      <scope startLine="148" endLine="150" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #dualPartition(int[],int[],int,int,int)} 
 * except that it <i>synchronously</i> partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="int" name="dualPartition" startLine="156" endLine="171">
      <declaration type="double" name="element" />
      <scope startLine="158" endLine="169">
        <scope startLine="160" endLine="168" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method <i>synchronously</i> partitions two arrays at the same time;
 * both arrays are partially sorted according to the elements of the primary array.
 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array is also moved from index A to B.
 * <p>
 * <b>Use cases:</b>
 * <p>
 * Image having a large list of 2-dimensional points. 
 * If memory consumption and performance matter, it is a good idea to physically lay them out as two 1-dimensional arrays
 * (using something like <tt>Point2D</tt> objects would be prohibitively expensive, both in terms of time and space).
 * Now imagine wanting to histogram the points.
 * We may want to partially sort the points by x-coordinate into intervals.
 * This method efficiently does the job.
 * <p>
 * <b>Performance:</b>
 * <p>
 * Same as for single-partition methods.</text>
    </javadoc>
    <method type="void" name="dualPartition" startLine="190" endLine="258">
      <declaration type="int" name="splitter" />
      <scope startLine="194" endLine="198">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="204" endLine="206">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="207" endLine="227">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="210" endLine="220">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="213" endLine="218">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="236" endLine="241">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="242" endLine="247">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="250" endLine="252" />
      <scope startLine="255" endLine="257" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int)} except that this method <i>synchronously</i> partitions two arrays at the same time;
 * both arrays are partially sorted according to the elements of the primary array.
 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array is also moved from index A to B.
 * <p>
 * <b>Performance:</b>
 * <p>
 * Same as for single-partition methods.</text>
    </javadoc>
    <method type="int" name="dualPartition" startLine="268" endLine="283">
      <declaration type="int" name="element" />
      <scope startLine="270" endLine="281">
        <scope startLine="272" endLine="280" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it <i>generically</i> partitions arbitrary shaped data (for example matrices or multiple arrays) rather than <tt>int[]</tt> arrays.
 * <p>
 * This method operates on arbitrary shaped data and arbitrary shaped splitters. 
 * In fact, it has no idea what kind of data by what kind of splitters it is partitioning. Comparisons and swapping 
 * are delegated to user provided objects which know their data and can do the 
 * job. 
 * <p>
 * Lets call the generic data <tt>g</tt> (it may be a matrix, one array, three linked lists 
 * or whatever). Lets call the generic splitters <tt>s</tt>.
 * This class takes a user comparison function operating on two indexes 
 * <tt>(a,b)</tt>, namely an {@link IntComparator}. 
 * The comparison function determines whether <tt>s[a]</tt> is equal, less or greater than <tt>g[b]</tt>. 
 * This method can then decide to swap the data <tt>g[b]</tt> 
 * with the data <tt>g[c]</tt> (yes, <tt>c</tt>, not <tt>a</tt>). 
 * It calls a user provided {@link cern.colt.Swapper} 
 * object that knows how to swap the data of these two indexes.
 * <p>
 * Again, note the details: Comparisons compare <tt>s[a]</tt> with <tt>g[b]</tt>.
 * Swaps swap <tt>g[b]</tt> with <tt>g[c]</tt>. 
 * Prior to calling this method, the generic splitters <tt>s</tt> must be sorted ascending and must not contain multiple equal values.
 * These preconditions are not checked; be sure that they are met.</text>
      <param>from the index of the first element within <tt>g</tt> to be considered.</param>
      <param>to the index of the last element within <tt>g</tt> to be considered.
 * The method considers the elements <tt>g[from] .. g[to]</tt>.</param>
      <param>splitFrom the index of the first splitter element to be considered.</param>
      <param>splitTo the index of the last splitter element to be considered.
 * The method considers the splitter elements <tt>s[splitFrom] .. s[splitTo]</tt>.</param>
      <param>splitIndexes a list into which this method fills the indexes of elements delimiting intervals.
 * Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
 * Therefore, must satisfy <tt>splitIndexes.length > splitTo</tt>.</param>
      <param>comp the comparator comparing a splitter with an element of the generic data.
 * Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
 * Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.</param>
      <param>comp2 the comparator to determine the order of the generic data.
 * Takes as first argument the index <tt>a</tt> within the generic data <tt>g</tt>.
 * Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.</param>
      <param>comp3 the comparator comparing a splitter with another splitter.
 * Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
 * Takes as second argument the index <tt>b</tt> within the generic splitters <tt>g</tt>.</param>
      <param>swapper an object that knows how to swap the elements at any two indexes (a,b).
 * Takes as first argument the index <tt>b</tt> within the generic data <tt>g</tt>.
 * Takes as second argument the index <tt>c</tt> within the generic data <tt>g</tt>.
 * <p>
 * Tip: Normally you will have <tt>splitIndexes.length == s.length</tt> as well as <tt>from==0, to==g.length-1</tt> and <tt>splitFrom==0, splitTo==s.length-1</tt>.</param>
      <see>Sort</see>
      <see>Sort#sort(int,int,IntComparator,Swapper)</see>
      <see>Sorting#binarySearchFromTo(int,int,IntComparator)</see>
    </javadoc>
    <method type="void" name="genericPartition" startLine="341" endLine="411">
      <declaration type="int" name="splitter" />
      <scope startLine="345" endLine="349">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="355" endLine="357">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="358" endLine="378">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="361" endLine="371">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="364" endLine="369">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="388" endLine="393">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="394" endLine="399">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="403" endLine="405" />
      <scope startLine="408" endLine="410" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int)} 
 * except that it <i>generically</i> partitions arbitrary shaped data (for example matrices or multiple arrays) rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="int" name="genericPartition" startLine="416" endLine="425">
      <scope startLine="417" endLine="423">
        <scope startLine="418" endLine="422" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed elements.</text>
    </javadoc>
    <method type="int" name="med3" startLine="429" endLine="433" />
    <javadoc>
      <text>* Returns the index of the median of the three indexed elements.</text>
    </javadoc>
    <method type="int" name="med3" startLine="437" endLine="441" />
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="445" endLine="452">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="456" endLine="463">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="void" name="partition" startLine="468" endLine="536">
      <declaration type="double" name="splitter" />
      <scope startLine="472" endLine="476">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="482" endLine="484">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="485" endLine="505">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="488" endLine="498">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="491" endLine="496">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="514" endLine="519">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="520" endLine="525">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="528" endLine="530" />
      <scope startLine="533" endLine="535" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int)}except that it partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="int" name="partition" startLine="541" endLine="552">
      <declaration type="double" name="element" />
      <scope startLine="543" endLine="550">
        <scope startLine="545" endLine="549" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
    </method>
    <javadoc>
      <text>* Partitions (partially sorts) the given list such that all elements falling into some intervals are placed next to each other.
 * Returns the indexes of elements delimiting intervals.
 * <p>
 * <b>Example:</b>
 * <p>
 * <tt>list = (7, 4, 5, 50, 6, 4, 3, 6), splitters = (5, 10, 30)</tt>
 * defines the three intervals <tt>[-infinity,5), [5,10), [10,30)</tt>.
 * Lets define to sort the entire list (<tt>from=0, to=7</tt>) using all splitters (<tt>splitFrom==0, splitTo=2</tt>).
 * <p>
 * The method modifies the list to be <tt>list = (4, 4, 3, 6, 7, 5, 6, 50)</tt>
 * and returns the <tt>splitIndexes = (2, 6, 6)</tt>.
 * In other words,
 * <ul>
 * <li>All values <tt>list[0..2]</tt> fall into <tt>[-infinity,5)</tt>.
 * <li>All values <tt>list[3..6]</tt> fall into <tt>[5,10)</tt>.
 * <li>All values <tt>list[7..6]</tt> fall into <tt>[10,30)</tt>, i.e. no elements, since <tt>7>6</tt>.
 * <li>All values <tt>list[7 .. 7=list.length-1]</tt> fall into <tt>[30,infinity]</tt>.
 * <li>In general, all values <tt>list[splitIndexes[j-1]+1 .. splitIndexes[j]]</tt> fall into interval <tt>j</tt>.
 * </ul>
 * As can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other.
 * Note that <i>within</i> an interval, elements are entirelly unsorted.
 * They are only sorted across interval boundaries.
 * In particular, this partitioning algorithm is not <i>stable</i>: the relative order of elements is not preserved
 * (Producing a stable algorithm would require no more than minor modifications to method partition(int[],int,int,int)).
 * <p>
 * More formally, this method guarantees that upon return <tt>for all j = splitFrom .. splitTo</tt> there holds:
 * <br><tt>for all i = splitIndexes[j-1]+1 .. splitIndexes[j]: splitters[j-1] <= list[i] < splitters[j]</tt>.
 * <p>
 * <b>Performance:</b>
 * <p>
 * Let <tt>N=to-from+1</tt> be the number of elements to be partitioned.
 * Let <tt>k=splitTo-splitFrom+1</tt> be the number of splitter elements.
 * Then we have the following time complexities
 * <ul>
 * <li>Worst case:  <tt>O( N * log(k) )</tt>.
 * <li>Average case: <tt>O( N * log(k) )</tt>.
 * <li>Best case: <tt>O( N )</tt>. 
 * In general, the more uniform (skewed) the data is spread across intervals, the more performance approaches the worst (best) case.
 * If no elements fall into the given intervals, running time is linear.
 * </ul>
 * No temporary memory is allocated; the sort is in-place.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * The algorithm can be seen as a Bentley/McIlroy quicksort where swapping and insertion sort are omitted.
 * It is designed to detect and take advantage of skew while maintaining good performance in the uniform case.</text>
      <param>list the list to be partially sorted.</param>
      <param>from the index of the first element within <tt>list</tt> to be considered.</param>
      <param>to the index of the last element within <tt>list</tt> to be considered.
 * The method considers the elements <tt>list[from] .. list[to]</tt>.</param>
      <param>splitters the values at which the list shall be split into intervals.
 * Must be sorted ascending and must not contain multiple identical values.
 * These preconditions are not checked; be sure that they are met.</param>
      <param>splitFrom the index of the first splitter element to be considered.</param>
      <param>splitTo the index of the last splitter element to be considered.
 * The method considers the splitter elements <tt>splitters[splitFrom] .. splitters[splitTo]</tt>.</param>
      <param>splitIndexes a list into which this method fills the indexes of elements delimiting intervals.
 * Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
 * Therefore, must satisfy <tt>splitIndexes.length > splitTo</tt>.
 * <p>
 * Tip: Normally you will have <tt>splitIndexes.length == splitters.length</tt> as well as <tt>from==0, to==list.length-1</tt> and <tt>splitFrom==0, splitTo==splitters.length-1</tt>.</param>
      <see>cern.colt.Arrays</see>
      <see>cern.colt.GenericSorting</see>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="void" name="partition" startLine="625" endLine="753">
      <declaration type="int" name="element" />
      <scope startLine="629" endLine="633">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="639" endLine="641">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="642" endLine="693">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="645" endLine="655">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="648" endLine="653">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>int key = list[m];</comment>
        <comment>if (splitTo-splitFrom+1 < 5) {  on short lists linear search is quicker
int i=splitFrom-1;
while (++i <= splitTo && list[i] < key);
if (i > splitTo || list[i] > key) i = -i-1;  not found
medianIndex = i;
}</comment>
        <comment>else {</comment>
        <comment>int low = splitFrom;
int high = splitTo;
int comparison;

int mid=0;
while (low <= high) {
mid = (low + high)  2;
comparison = splitters[mid]-key;
if (comparison < 0) low = mid + 1;
else if (comparison > 0) high = mid - 1;
else break; return mid;  key found
}
medianIndex = mid;
if (low > high) medianIndex = -(medianIndex + 1);   key not found.
}</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="728" endLine="733">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="734" endLine="739">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="742" endLine="745">
        <comment>System.out.println("1.recursive: from="+from+", to="+splitIndex+", splitFrom="+splitFrom+", splitTo="+(medianIndex-1));</comment>
      </scope>
      <scope startLine="748" endLine="751">
        <comment>System.out.println("2.recursive: from="+(splitIndex+1)+", to="+to+", splitFrom="+(medianIndex+1)+", splitTo="+splitTo);</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>System.out.println("medianIndex="+medianIndex);</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Could simply call:</comment>
      <comment>but for speed the code is manually inlined.</comment>
      <comment>steps += to-from+1;
int head = from;
for (int i=from-1; ++i<=to; ) {  swap all elements < splitter to front
element = list[i];
if (element < splitter) {
list[i] = list[head];
list[head++] = element;
swappedElements++;
}
}
int splitIndex = head-1;</comment>
      <comment>System.out.println("splitIndex="+splitIndex);</comment>
      <comment>if (splitFrom == splitTo) return;  done</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
      <comment>System.out.println("BACK TRACKING\n\n");</comment>
    </method>
    <javadoc>
      <text>* Partitions (partially sorts) the given list such that all elements falling into the given interval are placed next to each other.
 * Returns the index of the element delimiting the interval.
 * <p>
 * <b>Example:</b>
 * <p>
 * <tt>list = (7, 4, 5, 50, 6, 4, 3, 6), splitter = 5</tt>
 * defines the two intervals <tt>[-infinity,5), [5,+infinity]</tt>.
 * <p>
 * The method modifies the list to be <tt>list = (4, 4, 3, 50, 6, 7, 5, 6)</tt>
 * and returns the split index <tt>2</tt>.
 * In other words,
 * <ul>
 * <li>All values <tt>list[0..2]</tt> fall into <tt>[-infinity,5)</tt>.
 * <li>All values <tt>list[3=2+1 .. 7=list.length-1]</tt> fall into <tt>[5,+infinity]</tt>.
 * </ul>
 * As can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other.
 * Note that <i>within</i> an interval, elements are entirelly unsorted.
 * They are only sorted across interval boundaries.
 * In particular, this partitioning algorithm is not <i>stable</i>.
 * <p>
 * More formally, this method guarantees that upon return there holds:
 * <ul>
 * <li>for all <tt>i = from .. returnValue: list[i] < splitter</tt> and
 * <li>for all <tt>i = returnValue+1 .. list.length-1: !(list[i] < splitter)</tt>.
 * </ul>
 * <p>
 * <b>Performance:</b>
 * <p>
 * Let <tt>N=to-from+1</tt> be the number of elements to be partially sorted.
 * Then the time complexity is <tt>O( N )</tt>.
 * No temporary memory is allocated; the sort is in-place.
 * <p></text>
      <param>list the list to be partially sorted.</param>
      <param>from the index of the first element within <tt>list</tt> to be considered.</param>
      <param>to the index of the last element within <tt>list</tt> to be considered.
 * The method considers the elements <tt>list[from] .. list[to]</tt>.</param>
      <param>splitter the value at which the list shall be split.</param>
      <return>the index of the largest element falling into the interval <tt>[-infinity,splitter)</tt>, as seen after partitioning.</return>
    </javadoc>
    <method type="int" name="partition" startLine="798" endLine="938">
      <declaration type="int" name="element" />
      <scope startLine="832" endLine="840">
        <scope startLine="834" endLine="839" />
        <comment>swap x[i] with x[from]</comment>
        <comment>swappedElements++;</comment>
      </scope>
      <comment>System.out.println();
if (from<=to) {
System.out.println("SORT WORKING: from="+from+", to="+to+", splitter="+splitter);
}
else {
System.out.println("SORT WORKING: NOTHING TO DO.");
}</comment>
      <comment>returns index of last element < splitter</comment>
      <comment>for (int i=from-1; ++i<=to; ) {
if (list[i] < splitter) {
int element = list[i];
list[i] = list[from];
list[from++] = element;
}
}</comment>
      <comment>if (from<=to) System.out.println("Swapped "+(head-from)+" elements");</comment>
      <comment>JAL:
int first = from;
int last = to+1;
--first;
while (true) {
while (++first < last && list[first] < splitter);
while (first < --last && !(list[last] < splitter));
if (first >= last) return first-1;
int tmp = list[first];
list[first] = list[last];
list[last] = tmp;
}</comment>
      <comment>System.out.println("splitter="+splitter);
System.out.println("before="+new IntArrayList(list));
int head = from;
int trail = to;
int element;
while (head<=trail) {
head--;
while (++head < trail && list[head] < splitter);

trail++;
while (--trail > head && list[trail] >= splitter);

if (head != trail) {
element = list[head];
list[head] = list[trail];
list[trail] = element;
}
head++;
trail--;
System.out.println("after ="+new IntArrayList(list)+", head="+head);
}</comment>
      <comment>System.out.println("splitter="+splitter);
System.out.println("before="+new IntArrayList(list));
to++;
int head = from;
int element;
int oldHead;
while (--to >= from) {
element = list[to];
if (element < splitter) {
from--;
while (++from < to && list[from] < splitter);
if (head != to) {
list[to] = list[from];
list[from++] = element;
oldHead = list[head];
list[head] = element;
list[i] = oldHead;

head++;
}
head++;
}
System.out.println("after ="+new IntArrayList(list)+", head="+head);
}</comment>
      <comment>int i=from-1;
int head = from;
int trail = to;
while (++i <= trail) {
int element = list[i];
if (element < splitter) {
if (head == i) head++;
else {
 swap list[i] with list[from]
int oldHead = list[head];
int oldTrail = list[trail];
list[head++] = element;
list[i--] = oldTrail;
list[trail--] = oldHead;
}
}
System.out.println(new IntArrayList(list));

}</comment>
      <comment>return head-1;</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it partitions <tt>Object[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="void" name="partition" startLine="943" endLine="1011">
      <declaration type="Object" name="splitter" />
      <scope startLine="947" endLine="951">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="957" endLine="959">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="960" endLine="980">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="963" endLine="973">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="966" endLine="971">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="989" endLine="994">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="995" endLine="1000">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="1003" endLine="1005" />
      <scope startLine="1008" endLine="1010" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int)} 
 * except that it <i>synchronously</i> partitions the objects of the given list by the order of the given comparator.</text>
    </javadoc>
    <method type="int" name="partition" startLine="1016" endLine="1028">
      <declaration type="Object" name="element" />
      <scope startLine="1018" endLine="1026">
        <scope startLine="1020" endLine="1025" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
    </method>
    <javadoc>
      <text>* Equivalent to <tt>partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())</tt>.</text>
    </javadoc>
    <method type="void" name="partition" startLine="1032" endLine="1034" />
    <javadoc>
      <text>* Equivalent to <tt>partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())</tt>.</text>
    </javadoc>
    <method type="void" name="partition" startLine="1038" endLine="1040" />
    <javadoc>
      <text>* Same as {@link #triplePartition(int[],int[],int[],int,int,int[],int,int,int[])}except that it <i>synchronously</i> partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="void" name="triplePartition" startLine="1045" endLine="1113">
      <declaration type="double" name="splitter" />
      <scope startLine="1049" endLine="1053">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="1059" endLine="1061">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="1062" endLine="1082">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="1065" endLine="1075">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="1068" endLine="1073">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="1091" endLine="1096">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="1097" endLine="1102">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="1105" endLine="1107" />
      <scope startLine="1110" endLine="1112" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #triplePartition(int[],int[],int[],int,int,int)} 
 * except that it <i>synchronously</i> partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</text>
    </javadoc>
    <method type="int" name="triplePartition" startLine="1118" endLine="1138">
      <declaration type="double" name="element" />
      <scope startLine="1120" endLine="1135">
        <scope startLine="1122" endLine="1134" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method <i>synchronously</i> partitions three arrays at the same time;
 * all three arrays are partially sorted according to the elements of the primary array.
 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index A to B.
 * <p>
 * <b>Use cases:</b>
 * <p>
 * Image having a large list of 3-dimensional points. 
 * If memory consumption and performance matter, it is a good idea to physically lay them out as three 1-dimensional arrays
 * (using something like <tt>Point3D</tt> objects would be prohibitively expensive, both in terms of time and space).
 * Now imagine wanting to histogram the points.
 * We may want to partially sort the points by x-coordinate into intervals.
 * This method efficiently does the job.
 * <p>
 * <b>Performance:</b>
 * <p>
 * Same as for single-partition methods.</text>
    </javadoc>
    <method type="void" name="triplePartition" startLine="1157" endLine="1225">
      <declaration type="int" name="splitter" />
      <scope startLine="1161" endLine="1165">
        <comment>all bins are empty</comment>
      </scope>
      <declaration type="int" name="medianIndex" />
      <scope startLine="1171" endLine="1173">
        <comment>we don't really have a choice</comment>
      </scope>
      <scope startLine="1174" endLine="1194">
        <declaration type="int" name="m" />
        <declaration type="int" name="len" />
        <scope startLine="1177" endLine="1187">
          <declaration type="int" name="l" />
          <declaration type="int" name="n" />
          <scope startLine="1180" endLine="1185">
            <declaration type="int" name="s" />
          </scope>
        </scope>
        <comment>we do have a choice</comment>
        <comment>Small arrays, middle element</comment>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, pseudomedian of 3</comment>
        <comment>Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.</comment>
        <comment>not found</comment>
        <comment>not found, one past the end</comment>
      </scope>
      <declaration type="int" name="splitIndex" />
      <scope startLine="1203" endLine="1208">
        <declaration type="int" name="i" />
        <comment>no element falls into this bin</comment>
        <comment>all bins with splitters[i] <= splitter are empty</comment>
      </scope>
      <scope startLine="1209" endLine="1214">
        <declaration type="int" name="i" />
        <comment>all elements fall into this bin</comment>
        <comment>all bins with splitters[i] >= splitter are empty</comment>
      </scope>
      <scope startLine="1217" endLine="1219" />
      <scope startLine="1222" endLine="1224" />
      <comment>int, double --> template type dependent</comment>
      <comment>nothing to do</comment>
      <comment>Choose a partition (pivot) index, m</comment>
      <comment>Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.</comment>
      <comment>However, computing the median is expensive, so we use an approximation.</comment>
      <comment>Partition the list according to the splitter, i.e.</comment>
      <comment>Establish invariant: list[i] < splitter <= list[j] for i=from..medianIndex and j=medianIndex+1 .. to</comment>
      <comment>Optimization: Handle special cases to cut down recursions.</comment>
      <comment>recursively partition left half</comment>
      <comment>recursively partition right half</comment>
    </method>
    <javadoc>
      <text>* Same as {@link #partition(int[],int,int,int)} except that this method <i>synchronously</i> partitions three arrays at the same time;
 * all three arrays are partially sorted according to the elements of the primary array.
 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index A to B.
 * <p>
 * <b>Performance:</b>
 * <p>
 * Same as for single-partition methods.</text>
    </javadoc>
    <method type="int" name="triplePartition" startLine="1235" endLine="1255">
      <declaration type="int" name="element" />
      <scope startLine="1237" endLine="1252">
        <scope startLine="1239" endLine="1251" />
        <comment>swap x[i] with x[from]</comment>
      </scope>
      <comment>int, double --> template type dependent</comment>
    </method>
    <comment>benchmark only</comment>
  </class>
</source>
