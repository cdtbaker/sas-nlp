<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.bitvector">
  <import name="java.awt.Rectangle" />
  <class name="BitMatrix" extends="cern.colt.PersistentObject" startLine="12">
    <javadoc>
      <text>* Fixed sized (non resizable) n*m bit matrix.
 * A bit matrix has a number of columns and rows, which are assigned upon instance construction - The matrix's size is then <tt>columns()*rows()</tt>.
 * Bits are accessed via <tt>(column,row)</tt> coordinates.
 * <p>
 * Individual bits can be examined, set, or cleared.
 * Rectangular parts (boxes) can quickly be extracted, copied and replaced.
 * Quick iteration over boxes is provided by optimized internal iterators (<tt>forEach()</tt> methods).
 * One <code>BitMatrix</code> may be used to modify the contents of another 
 * <code>BitMatrix</code> through logical AND, OR, XOR and other similar operations.
 * <p>
 * Legal coordinates range from <tt>[0,0]</tt> to <tt>[columns()-1,rows()-1]</tt>.
 * Any attempt to access a bit at a coordinate <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt> will throw an <tt>IndexOutOfBoundsException</tt>.
 * Operations involving two bit matrices (like AND, OR, XOR, etc.) will throw an <tt>IllegalArgumentException</tt> if both bit matrices do not have the same number of columns and rows.
 * <p>
 * If you need extremely quick access to individual bits: Although getting and setting individual bits with methods <tt>get(...)</tt> and <tt>put(...)</tt> is quick, it is even quicker (<b>but not safe</b>) to use <tt>getQuick(...)</tt> and <tt>putQuick(...)</tt>.
 * <p>
 * <b>Note</b> that this implementation is not synchronized.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>BitVector</see>
      <see>QuickBitVector</see>
      <see>java.util.BitSet</see>
    </javadoc>
    <declaration type="int" name="columns" />
    <declaration type="int" name="rows" />
    <declaration type="long" name="bits" />
    <javadoc>
      <text>* Constructs a bit matrix with a given number of columns and rows. All bits are initially <tt>false</tt>.</text>
      <param>columns the number of columns the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>columns &lt; 0 || rows &lt; 0</tt>.</throws>
    </javadoc>
    <method type="constructor" name="BitMatrix" startLine="55" endLine="57" />
    <javadoc>
      <text>* Performs a logical <b>AND</b> of the receiver with another bit matrix.
 * The receiver is modified so that a bit in it has the
 * value <code>true</code> if and only if it already had the 
 * value <code>true</code> and the corresponding bit in the other bit matrix
 * argument has the value <code>true</code>.</text>
      <param>other   a bit matrix.</param>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>.</throws>
    </javadoc>
    <method type="void" name="and" startLine="68" endLine="71" />
    <javadoc>
      <text>* Clears all of the bits in receiver whose corresponding
 * bit is set in the other bit matrix.
 * In other words, determines the difference (A\B) between two bit matrices.</text>
      <param>other   a bit matrix with which to mask the receiver.</param>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>.</throws>
    </javadoc>
    <method type="void" name="andNot" startLine="80" endLine="83" />
    <javadoc>
      <text>* Returns the number of bits currently in the <tt>true</tt> state.
 * Optimized for speed. Particularly quick if the receiver is either sparse or dense.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="88" endLine="90" />
    <javadoc>
      <text>* Sanity check for operations requiring matrices with the same number of columns and rows.</text>
    </javadoc>
    <method type="void" name="checkDimensionCompatibility" startLine="94" endLine="96" />
    <javadoc>
      <text>* Clears all bits of the receiver.</text>
    </javadoc>
    <method type="void" name="clear" startLine="100" endLine="102" />
    <javadoc>
      <text>* Cloning this <code>BitMatrix</code> produces a new <code>BitMatrix</code> 
 * that is equal to it.
 * The clone of the bit matrix is another bit matrix that has exactly the 
 * same bits set to <code>true</code> as this bit matrix and the same 
 * number of columns and rows.</text>
      <return>a clone of this bit matrix.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="112" endLine="116">
      <declaration type="BitMatrix" name="clone" />
    </method>
    <javadoc>
      <text>* Returns the number of columns of the receiver.</text>
    </javadoc>
    <method type="int" name="columns" startLine="120" endLine="122" />
    <javadoc>
      <text>* Checks whether the receiver contains the given box.</text>
    </javadoc>
    <method type="void" name="containsBox" startLine="126" endLine="128" />
    <javadoc>
      <text>* Returns a shallow clone of the receiver; calls <code>clone()</code> and casts the result.</text>
      <return>a shallow clone of the receiver.</return>
    </javadoc>
    <method type="BitMatrix" name="copy" startLine="134" endLine="136" />
    <method type="long[]" name="elements" startLine="137" endLine="139" />
    <javadoc>
      <text>* You normally need not use this method. Use this method only if performance is critical. 
 * Sets the bit matrix's backing bits, columns and rows.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.</text>
      <throws>IllegalArgumentException if <tt>columns &lt; 0 || rows &lt; 0 || columns*rows &gt; bits.length*64</tt></throws>
    </javadoc>
    <method type="void" name="elements" startLine="147" endLine="152" />
    <javadoc>
      <text>* Compares this object against the specified object.
 * The result is <code>true</code> if and only if the argument is 
 * not <code>null</code> and is a <code>BitMatrix</code> object
 * that has the same number of columns and rows as the receiver and 
 * that has exactly the same bits set to <code>true</code> as the receiver.</text>
      <param>obj   the object to compare with.</param>
      <return><code>true</code> if the objects are the same;
 * <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="163" endLine="173">
      <declaration type="BitMatrix" name="other" />
    </method>
    <javadoc>
      <text>* Applies a procedure to each coordinate that holds a bit in the given state.
 * Iterates rowwise downwards from [columns()-1,rows()-1] to [0,0].
 * Useful, for example, if you want to copy bits into an image or somewhere else.
 * Optimized for speed. Particularly quick if one of the following conditions holds
 * <ul>
 * <li><tt>state==true</tt> and the receiver is sparse (<tt>cardinality()</tt> is small compared to <tt>size()</tt>).
 * <li><tt>state==false</tt> and the receiver is dense (<tt>cardinality()</tt> is large compared to <tt>size()</tt>).
 * </ul></text>
      <param>state element to search for.</param>
      <param>procedure a procedure object taking as first argument the current column and as second argument the current row. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachCoordinateInState" startLine="188" endLine="278">
      <declaration type="BitVector" name="vector" />
      <declaration type="long[]" name="theBits" />
      <declaration type="int" name="column" />
      <declaration type="int" name="row" />
      <declaration type="long" name="val" />
      <scope startLine="213" endLine="222">
        <declaration type="long" name="mask" />
        <scope startLine="215" endLine="217" />
        <scope startLine="218" endLine="221" />
      </scope>
      <declaration type="int" name="bitsPerUnit" />
      <declaration type="long" name="comparator" />
      <scope startLine="231" endLine="274">
        <scope startLine="233" endLine="259">
          <scope startLine="236" endLine="246">
            <scope startLine="237" endLine="245">
              <scope startLine="238" endLine="240" />
              <scope startLine="241" endLine="244" />
            </scope>
          </scope>
          <scope startLine="247" endLine="257">
            <scope startLine="248" endLine="256">
              <scope startLine="249" endLine="251" />
              <scope startLine="252" endLine="255" />
            </scope>
          </scope>
        </scope>
        <scope startLine="260" endLine="272">
          <scope startLine="262" endLine="271">
            <scope startLine="265" endLine="270">
              <scope startLine="266" endLine="269" />
            </scope>
          </scope>
        </scope>
        <comment>at least one element within current unit matches.</comment>
        <comment>iterate over all bits within current unit.</comment>
        <comment>unrolled comparison for speed.</comment>
        <comment>no element within current unit matches --> skip unit</comment>
        <comment>avoid implementation with *, /, %</comment>
      </scope>
      <comment>this is equivalent to the low level version below, apart from that it iterates in the reverse oder and is slower.
if (size()==0) return true;
BitVector vector = toBitVector();
return vector.forEachIndexFromToInState(0,size()-1,state,
new cern.colt.function.IntFunction() {
public boolean apply(int index) {
return function.apply(index%columns, indexcolumns);
}
}
);</comment>
      <comment>low level implementation for speed.</comment>
      <comment>for each coordinate of bits of partial unit</comment>
      <comment>for each coordinate of bits of full units</comment>
      <comment>all 64 bits set</comment>
    </method>
    <javadoc>
      <text>* Returns from the receiver the value of the bit at the specified coordinate.
 * The value is <tt>true</tt> if this bit is currently set; otherwise, returns <tt>false</tt>.</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <return>the value of the bit at the specified coordinate.</return>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt></throws>
    </javadoc>
    <method type="boolean" name="get" startLine="288" endLine="291" />
    <javadoc>
      <text>* Returns from the receiver the value of the bit at the specified coordinate; <b>WARNING:</b> Does not check preconditions.
 * The value is <tt>true</tt> if this bit is currently set; otherwise, returns <tt>false</tt>.
 * <p>Provided with invalid parameters this method may return invalid values without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>column&gt;=0 && column&lt;columns() && row&gt;=0 && row&lt;rows()</tt>.</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <return>the value of the bit at the specified coordinate.</return>
    </javadoc>
    <method type="boolean" name="getQuick" startLine="304" endLine="306" />
    <javadoc>
      <text>* Returns a hash code value for the receiver.</text>
    </javadoc>
    <method type="int" name="hashCode" startLine="310" endLine="312" />
    <javadoc>
      <text>* Performs a logical <b>NOT</b> on the bits of the receiver.</text>
    </javadoc>
    <method type="void" name="not" startLine="316" endLine="318" />
    <javadoc>
      <text>* Performs a logical <b>OR</b> of the receiver with another bit matrix.
 * The receiver is modified so that a bit in it has the
 * value <code>true</code> if and only if it either already had the 
 * value <code>true</code> or the corresponding bit in the other bit matrix
 * argument has the value <code>true</code>.</text>
      <param>other   a bit matrix.</param>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>.</throws>
    </javadoc>
    <method type="void" name="or" startLine="329" endLine="332" />
    <javadoc>
      <text>* Constructs and returns a new matrix with <tt>width</tt> columns and <tt>height</tt> rows which is a copy of the contents of the given box.
 * The box ranges from <tt>[column,row]</tt> to <tt>[column+width-1,row+height-1]</tt>, all inclusive.</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>width   the width of the box.</param>
      <param>height   the height of the box.</param>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column+width&gt;columns() || row&lt;0 || row+height&gt;rows()</tt></throws>
    </javadoc>
    <method type="BitMatrix" name="part" startLine="342" endLine="349">
      <declaration type="BitMatrix" name="subMatrix" />
    </method>
    <javadoc>
      <text>* Sets the bit at the specified coordinate to the state specified by <tt>value</tt>.</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>value the value of the bit to be copied into the specified coordinate.</param>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt></throws>
    </javadoc>
    <method type="void" name="put" startLine="358" endLine="361" />
    <javadoc>
      <text>* Sets the bit at the specified coordinate to the state specified by <tt>value</tt>; <b>WARNING:</b> Does not check preconditions.
 * <p>Provided with invalid parameters this method may return invalid values without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>column&gt;=0 && column&lt;columns() && row&gt;=0 && row&lt;rows()</tt>.</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>value the value of the bit to be copied into the specified coordinate.</param>
    </javadoc>
    <method type="void" name="putQuick" startLine="373" endLine="375" />
    <javadoc>
      <text>* Replaces a box of the receiver with the contents of another matrix's box.
 * The source box ranges from <tt>[sourceColumn,sourceRow]</tt> to <tt>[sourceColumn+width-1,sourceRow+height-1]</tt>, all inclusive.
 * The destination box ranges from <tt>[column,row]</tt> to <tt>[column+width-1,row+height-1]</tt>, all inclusive.
 * Does nothing if <tt>width &lt;= 0 || height &lt;= 0</tt>.
 * If <tt>source==this</tt> and the source and destination box intersect in an ambiguous way, then replaces as if using an intermediate auxiliary copy of the receiver.</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>width   the width of the box.</param>
      <param>height   the height of the box.</param>
      <param>source   the source matrix to copy from(may be identical to the receiver).</param>
      <param>sourceColumn   the index of the source column-coordinate.</param>
      <param>sourceRow   the index of the source row-coordinate.</param>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column+width&gt;columns() || row&lt;0 || row+height&gt;rows()</tt></throws>
      <throws>IndexOutOfBoundsException if <tt>sourceColumn&lt;0 || sourceColumn+width&gt;source.columns() || sourceRow&lt;0 || sourceRow+height&gt;source.rows()</tt></throws>
    </javadoc>
    <method type="void" name="replaceBoxWith" startLine="393" endLine="414">
      <scope startLine="398" endLine="404">
        <declaration type="Rectangle" name="destRect" />
        <declaration type="Rectangle" name="sourceRect" />
        <scope startLine="401" endLine="403" />
        <comment>dangerous intersection</comment>
      </scope>
      <declaration type="BitVector" name="sourceVector" />
      <declaration type="BitVector" name="destVector" />
      <declaration type="int" name="sourceColumns" />
      <scope startLine="409" endLine="413">
        <declaration type="int" name="offset" />
        <declaration type="int" name="sourceOffset" />
      </scope>
    </method>
    <javadoc>
      <text>* Sets the bits in the given box to the state specified by <tt>value</tt>.
 * The box ranges from <tt>[column,row]</tt> to <tt>[column+width-1,row+height-1]</tt>, all inclusive.
 * (Does nothing if <tt>width &lt;= 0 || height &lt;= 0</tt>).</text>
      <param>column   the index of the column-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>width   the width of the box.</param>
      <param>height   the height of the box.</param>
      <param>value the value of the bit to be copied into the bits of the specified box.</param>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column+width&gt;columns() || row&lt;0 || row+height&gt;rows()</tt></throws>
    </javadoc>
    <method type="void" name="replaceBoxWith" startLine="426" endLine="435">
      <declaration type="BitVector" name="destVector" />
      <scope startLine="431" endLine="434">
        <declaration type="int" name="offset" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the number of rows of the receiver.</text>
    </javadoc>
    <method type="int" name="rows" startLine="439" endLine="441" />
    <javadoc>
      <text>* Returns the size of the receiver which is <tt>columns()*rows()</tt>.</text>
    </javadoc>
    <method type="int" name="size" startLine="445" endLine="447" />
    <javadoc>
      <text>* Converts the receiver to a bitvector. 
 * In many cases this method only makes sense on one-dimensional matrices.
 * <b>WARNING:</b> The returned bitvector and the receiver share the <b>same</b> backing bits.
 * Modifying either of them will affect the other.
 * If this behaviour is not what you want, you should first use <tt>copy()</tt> to make sure both objects use separate internal storage.</text>
    </javadoc>
    <method type="BitVector" name="toBitVector" startLine="455" endLine="457" />
    <javadoc>
      <text>* Returns a (very crude) string representation of the receiver.</text>
    </javadoc>
    <method type="String" name="toString" startLine="461" endLine="463" />
    <javadoc>
      <text>* Performs a logical <b>XOR</b> of the receiver with another bit matrix.
 * The receiver is modified so that a bit in it has the
 * value <code>true</code> if and only if one of the following statements holds:
 * <ul>
 * <li>The bit initially has the value <code>true</code>, and the 
 * corresponding bit in the argument has the value <code>false</code>.
 * <li>The bit initially has the value <code>false</code>, and the 
 * corresponding bit in the argument has the value <code>true</code>. 
 * </ul></text>
      <param>other   a bit matrix.</param>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>.</throws>
    </javadoc>
    <method type="void" name="xor" startLine="478" endLine="481" />
    <comment>The bits of this matrix.
 bits are stored in row major, i.e.
 bitIndex==rowcolumns + column
 columnOf(bitIndex)==bitIndex%columns
 rowOf(bitIndex)==bitIndexcolumns</comment>
  </class>
</source>
