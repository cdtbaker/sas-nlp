<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.bitvector">
  <class name="QuickBitVector" extends="Object" startLine="11">
    <javadoc>
      <text>* Implements quick non polymorphic non bounds checking low level bitvector operations.
 * Includes some operations that interpret sub-bitstrings as long integers.
 * <p>
 * <b>WARNING: Methods of this class do not check preconditions.</b>
 * Provided with invalid parameters these method may return (or set) invalid values without throwing any exception.
 * <b>You should only use this class when performance is critical and you are absolutely sure that indexes are within bounds.</b>
 * <p>	 
 * A bitvector is modelled as a long array, i.e. <tt>long[] bits</tt> holds bits of a bitvector.
 * Each long value holds 64 bits.
 * The i-th bit is stored in bits[i/64] at
 * bit position i % 64 (where bit position 0 refers to the least
 * significant bit and 63 refers to the most significant bit).</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>BitVector</see>
      <see>BitMatrix</see>
      <see>java.util.BitSet</see>
    </javadoc>
    <declaration type="int" name="ADDRESS_BITS_PER_UNIT" />
    <declaration type="int" name="BITS_PER_UNIT" />
    <declaration type="int" name="BIT_INDEX_MASK" />
    <declaration type="long[]" name="pows" />
    <javadoc>
      <text>* Makes this class non instantiable, but still inheritable.</text>
    </javadoc>
    <method type="constructor" name="QuickBitVector" startLine="40" endLine="41" />
    <javadoc>
      <text>* Returns a bit mask with bits in the specified range set to 1, all the rest set to 0.
 * In other words, returns a bit mask having 0,1,2,3,...,64 bits set.
 * If <tt>to-from+1==0</tt> then returns zero (<tt>0L</tt>).
 * Precondition (not checked): <tt>to-from+1 &gt;= 0 && to-from+1 &lt;= 64</tt>.</text>
      <param>from index of start bit (inclusive)</param>
      <param>to index of end bit (inclusive).</param>
      <return>the bit mask having all bits between <tt>from</tt> and <tt>to</tt> set to 1.</return>
    </javadoc>
    <method type="long" name="bitMaskWithBitsSetFromTo" startLine="52" endLine="59">
      <comment>This turned out to be slower:</comment>
      <comment>0xffffffffffffffffL == ~0L == -1L == all 64 bits set.</comment>
      <comment>int width;</comment>
      <comment>return (width=to-from+1) == 0 ? 0L : (0xffffffffffffffffL >>> (BITS_PER_UNIT-width)) << from;</comment>
    </method>
    <javadoc>
      <text>* Changes the bit with index <tt>bitIndex</tt> in the bitvector <tt>bits</tt> to the "clear" (<tt>false</tt>) state.</text>
      <param>bits   the bitvector.</param>
      <param>bitIndex   the index of the bit to be cleared.</param>
    </javadoc>
    <method type="void" name="clear" startLine="66" endLine="68" />
    <javadoc>
      <text>* Returns from the bitvector the value of the bit with the specified index.
 * The value is <tt>true</tt> if the bit with the index <tt>bitIndex</tt> 
 * is currently set; otherwise, returns <tt>false</tt>.</text>
      <param>bits   the bitvector.</param>
      <param>bitIndex   the bit index.</param>
      <return>the value of the bit with the specified index.</return>
    </javadoc>
    <method type="boolean" name="get" startLine="78" endLine="80" />
    <javadoc>
      <text>* Returns a long value representing bits of a bitvector from index <tt>from</tt> to index <tt>to</tt>.
 * Bits are returned as a long value with the return value having bit 0 set to bit <code>from</code>, ..., bit <code>to-from</code> set to bit <code>to</code>.
 * All other bits of return value are set to 0.
 * If <tt>from &gt; to</tt> then returns zero (<tt>0L</tt>).
 * Precondition (not checked): <tt>to-from+1 &lt;= 64</tt>.</text>
      <param>bits the bitvector.</param>
      <param>from index of start bit (inclusive).</param>
      <param>to index of end bit (inclusive).</param>
      <return>the specified bits as long value.</return>
    </javadoc>
    <method type="long" name="getLongFromTo" startLine="92" endLine="124">
      <declaration type="int" name="fromIndex" />
      <declaration type="int" name="toIndex" />
      <declaration type="int" name="fromOffset" />
      <declaration type="int" name="toOffset" />
      <declaration type="long" name="mask" />
      <scope startLine="107" endLine="111">
        <comment>range does not cross unit boundaries; value to retrieve is contained in one single long value.</comment>
      </scope>
      <declaration type="long" name="x1" />
      <declaration type="long" name="x2" />
      <comment>equivalent to from/64</comment>
      <comment>equivalent to from%64</comment>
      <comment>this is equivalent to the above, but slower:</comment>
      <comment>final int fromIndex=from/BITS_PER_UNIT;</comment>
      <comment>final int toIndex=to/BITS_PER_UNIT;</comment>
      <comment>final int fromOffset=from%BITS_PER_UNIT;</comment>
      <comment>final int toOffset=to%BITS_PER_UNIT;</comment>
      <comment>range crosses unit boundaries; value to retrieve is spread over two long values.</comment>
      <comment>get part from first long value</comment>
      <comment>get part from second long value</comment>
      <comment>combine</comment>
    </method>
    <javadoc>
      <text>* Returns the index of the least significant bit in state "true".
 * Returns 32 if no bit is in state "true".
 * Examples: 
 * <pre>
 * 0x80000000 --> 31
 * 0x7fffffff --> 0
 * 0x00000001 --> 0
 * 0x00000000 --> 32
 * </pre></text>
    </javadoc>
    <method type="int" name="leastSignificantBit" startLine="136" endLine="140">
      <declaration type="int" name="i" />
    </method>
    <javadoc>
      <text>* Constructs a low level bitvector that holds <tt>size</tt> elements, with each element taking <tt>bitsPerElement</tt> bits.</text>
      <param>size   the number of elements to be stored in the bitvector (must be &gt;= 0).</param>
      <param>bitsPerElement   the number of bits one single element takes.</param>
      <return>a low level bitvector.</return>
    </javadoc>
    <method type="long[]" name="makeBitVector" startLine="148" endLine="153">
      <declaration type="int" name="nBits" />
      <declaration type="int" name="unitIndex" />
      <declaration type="long[]" name="bitVector" />
    </method>
    <javadoc>
      <text>* Returns the index of the most significant bit in state "true".
 * Returns -1 if no bit is in state "true".
 * Examples: 
 * <pre>
 * 0x80000000 --> 31
 * 0x7fffffff --> 30
 * 0x00000001 --> 0
 * 0x00000000 --> -1
 * </pre></text>
    </javadoc>
    <method type="int" name="mostSignificantBit" startLine="165" endLine="169">
      <declaration type="int" name="i" />
    </method>
    <javadoc>
      <text>* Returns the index within the unit that contains the given bitIndex.</text>
    </javadoc>
    <method type="int" name="offset" startLine="173" endLine="176">
      <comment>equivalent to bitIndex%64</comment>
    </method>
    <javadoc>
      <text>* Initializes a table with numbers having 1,2,3,...,64 bits set.
 * pows[i] has bits [0..i-1] set.
 * pows[64] == -1L == ~0L == has all 64 bits set --> correct.
 * to speedup calculations in subsequent methods.</text>
    </javadoc>
    <method type="long[]" name="precomputePows" startLine="183" endLine="213">
      <declaration type="long[]" name="pows" />
      <declaration type="long" name="value" />
      <scope startLine="186" endLine="189">
        <comment>System.out.println((i)+":"+pows[i]);</comment>
      </scope>
      <comment>System.out.println((0)+":"+pows[0]);</comment>
      <comment>OLD STUFF</comment>
      <comment>for (int i=BITS_PER_UNIT+1; --i >= 0; ) {
pows[i]=value;
value = value >>> 1;
System.out.println((i)+":"+pows[i]);
}</comment>
      <comment>long[] pows=new long[BITS_PER_UNIT];
for (int i=0; i<BITS_PER_UNIT-1; i++) {
pows[i]=Math.round(Math.pow(2.0,i+1))-1;
System.out.println((i)+":"+pows[i]);
}
pows[BITS_PER_UNIT-1] = ~0L;
System.out.println((BITS_PER_UNIT-1)+":"+pows[BITS_PER_UNIT-1]);
return pows;</comment>
    </method>
    <javadoc>
      <text>* Sets the bit with index <tt>bitIndex</tt> in the bitvector <tt>bits</tt> to the state specified by <tt>value</tt>.</text>
      <param>bits   the bitvector.</param>
      <param>bitIndex   the index of the bit to be changed.</param>
      <param>value   the value to be stored in the bit.</param>
    </javadoc>
    <method type="void" name="put" startLine="221" endLine="226" />
    <javadoc>
      <text>* Sets bits of a bitvector from index <code>from</code> to index <code>to</code> to the bits of <code>value</code>.
 * Bit <code>from</code> is set to bit 0 of <code>value</code>, ..., bit <code>to</code> is set to bit <code>to-from</code> of <code>value</code>.
 * All other bits stay unaffected.
 * If <tt>from &gt; to</tt> then does nothing.
 * Precondition (not checked): <tt>to-from+1 &lt;= 64</tt>.</text>
      <param>bits the bitvector.</param>
      <param>value the value to be copied into the bitvector.</param>
      <param>from index of start bit (inclusive).</param>
      <param>to index of end bit (inclusive).</param>
    </javadoc>
    <method type="void" name="putLongFromTo" startLine="239" endLine="279">
      <declaration type="int" name="fromIndex" />
      <declaration type="int" name="toIndex" />
      <declaration type="int" name="fromOffset" />
      <declaration type="int" name="toOffset" />
      <declaration type="long" name="mask" />
      <declaration type="long" name="cleanValue" />
      <declaration type="long" name="shiftedValue" />
      <scope startLine="261" endLine="267">
        <comment>range does not cross unit boundaries; should go into one single long value.</comment>
      </scope>
      <comment>equivalent to from/64</comment>
      <comment>equivalent to from%64</comment>
      <comment>this is equivalent to the above, but slower:
int fromIndex=fromBITS_PER_UNIT;
int toIndex=toBITS_PER_UNIT;
int fromOffset=from%BITS_PER_UNIT;
int toOffset=to%BITS_PER_UNIT;</comment>
      <comment>make sure all unused bits to the left are cleared.</comment>
      <comment>range crosses unit boundaries; value should go into two long values.</comment>
      <comment>copy into first long value.</comment>
      <comment>copy into second long value.</comment>
    </method>
    <javadoc>
      <text>* Changes the bit with index <tt>bitIndex</tt> in the bitvector <tt>bits</tt> to the "set" (<tt>true</tt>) state.</text>
      <param>bits   the bitvector.</param>
      <param>bitIndex   the index of the bit to be set.</param>
    </javadoc>
    <method type="void" name="set" startLine="286" endLine="288" />
    <javadoc>
      <text>* Returns the index of the unit that contains the given bitIndex.</text>
    </javadoc>
    <method type="int" name="unit" startLine="292" endLine="295">
      <comment>equivalent to bitIndex/64</comment>
    </method>
    <comment>64=2^6</comment>
    <comment>= 1 << ADDRESS_BITS_PER_UNIT</comment>
    <comment>= BITS_PER_UNIT - 1;</comment>
    <comment>precompute bitmasks for speed</comment>
  </class>
</source>
