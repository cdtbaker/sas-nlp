<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt">
  <import name="cern.colt.function.IntComparator" />
  <class name="GenericSorting" extends="Object" startLine="12">
    <javadoc>
      <text>* Generically sorts arbitrary shaped data (for example multiple arrays, 1,2 or 3-d matrices, and so on) using a 
 * quicksort or mergesort. This class addresses two problems, namely 
 * <ul>
 * <li><i>Sorting multiple arrays in sync</i> 
 * <li><i>Sorting by multiple sorting criteria</i> (primary, secondary, tertiary, 
 * ...) 
 * </ul>
 * <h4>Sorting multiple arrays in sync</h4>
 * <p>
 * Assume we have three arrays X, Y and Z. We want to sort all three arrays by 
 * X (or some arbitrary comparison function). For example, we have<br>
 * <tt>X=[3, 2, 1], Y=[3.0, 2.0, 1.0], Z=[6.0, 7.0, 8.0]</tt>. The output should 
 * be <tt><br>
 * X=[1, 2, 3], Y=[1.0, 2.0, 3.0], Z=[8.0, 7.0, 6.0]</tt>. </p>
 * <p>How can we achive this? Here are several alternatives. We could ... </p>
 * <ol>
 * <li> make a list of Point3D objects, sort the list as desired using a comparison 
 * function, then copy the results back into X, Y and Z. The classic object-oriented 
 * way. </li>
 * <li>make an index list [0,1,2,...,N-1], sort the index list using a comparison function, 
 * then reorder the elements of X,Y,Z as defined by the index list. Reordering 
 * cannot be done in-place, so we need to copy X to some temporary array, then 
 * copy in the right order back from the temporary into X. Same for Y and Z. 
 * </li>
 * <li> use a generic quicksort or mergesort which, whenever two elements in X are swapped, 
 * also swaps the corresponding elements in Y and Z. </li>
 * </ol>
 * Alternatives 1 and 2 involve quite a lot of copying and allocate significant amounts 
 * of temporary memory. Alternative 3 involves more swapping, more polymorphic message dispatches, no copying and does not need any temporary memory. 
 * <p> This class implements alternative 3. It operates on arbitrary shaped data. 
 * In fact, it has no idea what kind of data it is sorting. Comparisons and swapping 
 * are delegated to user provided objects which know their data and can do the 
 * job. 
 * <p> Lets call the generic data <tt>g</tt> (it may be one array, three linked lists 
 * or whatever). This class takes a user comparison function operating on two indexes 
 * <tt>(a,b)</tt>, namely an {@link IntComparator}. The comparison function determines 
 * whether <tt>g[a]</tt> is equal, less or greater than <tt>g[b]</tt>. The sort, 
 * depending on its implementation, can decide to swap the data at index <tt>a</tt> 
 * with the data at index <tt>b</tt>. It calls a user provided {@link cern.colt.Swapper} 
 * object that knows how to swap the data of these indexes. 
 * <p>The following snippet shows how to solve the problem. 
 * <table>
 * <td class="PRE"> 
 * <pre>
 * final int[] x;
 * final double[] y;
 * final double[] z;
 * x = new int[]    {3,   2,   1  };
 * y = new double[] {3.0, 2.0, 1.0};
 * z = new double[] {6.0, 7.0, 8.0};
 * // this one knows how to swap two indexes (a,b)
 * Swapper swapper = new Swapper() {
 * &nbsp;&nbsp;&nbsp;public void swap(int a, int b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t1;	double t2, t3;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1 = x[a]; x[a] = x[b];	x[b] = t1;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2 = y[a]; y[a] = y[b]; y[b] = t2;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t3 = z[a]; z[a] = z[b];	z[b] = t3;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * // simple comparison: compare by X and ignore Y,Z<br>
 * IntComparator comp = new IntComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(int a, int b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x[a]==x[b] ? 0 : (x[a]&lt;x[b] ? -1 : 1);
 * &nbsp;&nbsp;&nbsp;}
 * };
 * System.out.println("before:");
 * System.out.println("X="+Arrays.toString(x));
 * System.out.println("Y="+Arrays.toString(y));
 * System.out.println("Z="+Arrays.toString(z));
 * GenericSorting.quickSort(0, X.length, comp, swapper);
 * // GenericSorting.mergeSort(0, X.length, comp, swapper);
 * System.out.println("after:");
 * System.out.println("X="+Arrays.toString(x));
 * System.out.println("Y="+Arrays.toString(y));
 * System.out.println("Z="+Arrays.toString(z));
 * </pre>
 * </td>
 * </table>
 * <h4>Sorting by multiple sorting criterias (primary, secondary, tertiary, ...)</h4>
 * <p>Assume again we have three arrays X, Y and Z. Now we want to sort all three 
 * arrays, primarily by Y, secondarily by Z (if Y elements are equal). For example, 
 * we have<br>
 * <tt>X=[6, 7, 8, 9], Y=[3.0, 2.0, 1.0, 3.0], Z=[5.0, 4.0, 4.0, 1.0]</tt>. The 
 * output should be <tt><br>
 * X=[8, 7, 9, 6], Y=[1.0, 2.0, 3.0, 3.0], Z=[4.0, 4.0, 1.0, 5.0]</tt>. </p>
 * <p>Here is how to solve the problem. All code in the above example stays the same, 
 * except that we modify the comparison function as follows</p>
 * <table>
 * <td class="PRE"> 
 * <pre>
 * //compare by Y, if that doesn't help, reside to Z
 * IntComparator comp = new IntComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(int a, int b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (y[a]==y[b]) return z[a]==z[b] ? 0 : (z[a]&lt;z[b] ? -1 : 1);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return y[a]&lt;y[b] ? -1 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * </pre>
 * </td>
 * </table>
 * <h4>Notes</h4>
 * <p></p>
 * <p> Sorts involving floating point data and not involving comparators, like, for 
 * example provided in the JDK {@link java.util.Arrays} and in the Colt {@link cern.colt.Sorting} handle floating point numbers in special ways to guarantee 
 * that NaN's are swapped to the end and -0.0 comes before 0.0. Methods delegating 
 * to comparators cannot do this. They rely on the comparator. Thus, if such boundary 
 * cases are an issue for the application at hand, comparators explicitly need 
 * to implement -0.0 and NaN aware comparisons. Remember: <tt>-0.0 < 0.0 == false</tt>, 
 * <tt>(-0.0 == 0.0) == true</tt>, as well as <tt>5.0 &lt; Double.NaN == false</tt>, 
 * <tt>5.0 &gt; Double.NaN == false</tt>. Same for <tt>float</tt>.
 * <h4>Implementation </h4>
 * <p>The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in 
 * turn, based on Bentley's and McIlroy's fine work).
 * The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
 * Both quick and merge sort are "in-place", i.e. do not allocate temporary memory (helper arrays).
 * Mergesort is <i>stable</i> (by definition), while quicksort is not.
 * A stable sort is, for example, helpful, if matrices are sorted successively 
 * by multiple columns. It preserves the relative position of equal elements.</text>
      <see>java.util.Arrays</see>
      <see>cern.colt.Sorting</see>
      <see>cern.colt.matrix.doublealgo.Sorting</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 03-Jul-99</version>
    </javadoc>
    <declaration type="int" name="SMALL" />
    <declaration type="int" name="MEDIUM" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="GenericSorting" startLine="153" endLine="153" />
    <javadoc>
      <text>* Transforms two consecutive sorted ranges into a single sorted 
 * range.  The initial ranges are <code>[first, middle)</code>
 * and <code>[middle, last)</code>, and the resulting range is
 * <code>[first, last)</code>.  
 * Elements in the first input range will precede equal elements in the 
 * second.</text>
    </javadoc>
    <method type="void" name="inplace_merge" startLine="162" endLine="200">
      <scope startLine="165" endLine="170">
        <scope startLine="166" endLine="168" />
      </scope>
      <declaration type="int" name="firstCut" />
      <declaration type="int" name="secondCut" />
      <scope startLine="173" endLine="176" />
      <scope startLine="177" endLine="180" />
      <declaration type="int" name="first2" />
      <declaration type="int" name="middle2" />
      <declaration type="int" name="last2" />
      <scope startLine="187" endLine="194">
        <declaration type="int" name="first1" />
        <declaration type="int" name="last1" />
      </scope>
      <comment>rotate(firstCut, middle, secondCut, swapper);</comment>
      <comment>is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are "static private")</comment>
      <comment>speedup = 1.7</comment>
      <comment>begin inline</comment>
      <comment>end inline</comment>
    </method>
    <javadoc>
      <text>* Performs a binary search on an already-sorted range: finds the first
 * position where an element can be inserted without violating the ordering.
 * Sorting is by a user-supplied comparison function.</text>
      <param>array    Array containing the range.</param>
      <param>first    Beginning of the range.</param>
      <param>last     One past the end of the range.</param>
      <param>x        Element to be searched for.</param>
      <param>comp     Comparison function.</param>
      <return>The largest index i such that, for every j in the
 * range <code>[first, i)</code>, 
 * <code>comp.apply(array[j], x)</code> is
 * <code>true</code>.</return>
      <see>Sorting#upper_bound</see>
      <see>Sorting#equal_range</see>
      <see>Sorting#binary_search</see>
    </javadoc>
    <method type="int" name="lower_bound" startLine="218" endLine="233">
      <declaration type="int" name="len" />
      <scope startLine="221" endLine="231">
        <declaration type="int" name="half" />
        <declaration type="int" name="middle" />
        <scope startLine="224" endLine="227" />
        <scope startLine="228" endLine="230" />
      </scope>
      <comment>if (comp==null) throw new NullPointerException();</comment>
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="237" endLine="244">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(a, b)</tt> must not throw an
 * exception for any indexes <tt>a</tt> and
 * <tt>b</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>fromIndex the index of the first element (inclusive) to be sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the generic data.</param>
      <param>swapper an object that knows how to swap the elements at any two indexes (a,b).</param>
      <see>IntComparator</see>
      <see>Swapper</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="270" endLine="300">
      <declaration type="int" name="length" />
      <scope startLine="280" endLine="287">
        <scope startLine="281" endLine="285">
          <scope startLine="282" endLine="284" />
        </scope>
      </scope>
      <declaration type="int" name="mid" />
      <comment>We retain the same method signature as quickSort.
Given only a comparator and swapper we do not know how to copy and move elements fromto temporary arrays.
Hence, in contrast to the JDK mergesorts this is an "in-place" mergesort, i.e. does not allocate any temporary arrays.
A non-inplace mergesort would perhaps be faster in most cases, but would require non-intuitive delegate objects...</comment>
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves</comment>
      <comment>If list is already sorted, nothing left to do.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified range of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(a, b)</tt> must not throw an
 * exception for any indexes <tt>a</tt> and
 * <tt>b</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>fromIndex the index of the first element (inclusive) to be sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the generic data.</param>
      <param>swapper an object that knows how to swap the elements at any two indexes (a,b).</param>
      <see>IntComparator</see>
      <see>Swapper</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="324" endLine="326" />
    <javadoc>
      <text>* Sorts the specified sub-array into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="330" endLine="391">
      <scope startLine="332" endLine="338">
        <scope startLine="334" endLine="336" />
      </scope>
      <declaration type="int" name="m" />
      <scope startLine="342" endLine="352">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="345" endLine="350">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="int" name="a" />
      <scope startLine="357" endLine="379">
        <declaration type="int" name="comparison" />
        <scope startLine="359" endLine="366">
          <scope startLine="360" endLine="364" />
        </scope>
        <scope startLine="367" endLine="374">
          <scope startLine="368" endLine="372" />
        </scope>
        <comment>moving target; DELTA to JDK !!!</comment>
        <comment>moving target; DELTA to JDK !!!</comment>
        <comment>moving target; DELTA to JDK !!!</comment>
        <comment>moving target; DELTA to JDK !!!</comment>
        <comment>moving target; DELTA to JDK !!!</comment>
        <comment>moving target; DELTA to JDK !!!</comment>
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>long v = x[m];</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Reverses a sequence of elements.</text>
      <param>array      Array containing the sequence</param>
      <param>first      Beginning of the range</param>
      <param>last       One past the end of the range</param>
      <exception>ArrayIndexOutOfBoundsException If the range
 * is invalid.</exception>
    </javadoc>
    <method type="void" name="reverse" startLine="400" endLine="405">
      <scope startLine="402" endLine="404" />
      <comment>no more needed since manually inlined</comment>
    </method>
    <javadoc>
      <text>* Rotate a range in place: <code>array[middle]</code> is put in
 * <code>array[first]</code>, <code>array[middle+1]</code> is put in
 * <code>array[first+1]</code>, etc.  Generally, the element in position
 * <code>i</code> is put into position 
 * <code>(i + (last-middle)) % (last-first)</code>.</text>
      <param>array    Array containing the range</param>
      <param>first    Beginning of the range</param>
      <param>middle   Index of the element that will be put in
 * <code>array[first]</code></param>
      <param>last     One past the end of the range</param>
    </javadoc>
    <method type="void" name="rotate" startLine="418" endLine="425">
      <scope startLine="420" endLine="424" />
      <comment>no more needed since manually inlined</comment>
    </method>
    <javadoc>
      <text>* Performs a binary search on an already-sorted range: finds the last
 * position where an element can be inserted without violating the ordering.
 * Sorting is by a user-supplied comparison function.</text>
      <param>array    Array containing the range.</param>
      <param>first    Beginning of the range.</param>
      <param>last     One past the end of the range.</param>
      <param>x        Element to be searched for.</param>
      <param>comp     Comparison function.</param>
      <return>The largest index i such that, for every j in the
 * range <code>[first, i)</code>, 
 * <code>comp.apply(x, array[j])</code> is 
 * <code>false</code>.</return>
      <see>Sorting#lower_bound</see>
      <see>Sorting#equal_range</see>
      <see>Sorting#binary_search</see>
    </javadoc>
    <method type="int" name="upper_bound" startLine="443" endLine="458">
      <declaration type="int" name="len" />
      <scope startLine="446" endLine="456">
        <declaration type="int" name="half" />
        <declaration type="int" name="middle" />
        <scope startLine="449" endLine="451" />
        <scope startLine="452" endLine="455" />
      </scope>
      <comment>if (comp==null) throw new NullPointerException();</comment>
    </method>
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="462" endLine="464" />
  </class>
</source>
