<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix">
  <import name="cern.colt.list.IntArrayList" />
  <import name="cern.colt.list.ObjectArrayList" />
  <import name="cern.colt.matrix.impl.AbstractMatrix3D" />
  <class name="ObjectMatrix3D" extends="AbstractMatrix3D" startLine="14">
    <javadoc>
      <text>* Abstract base class for 3-d matrices holding <tt>Object</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * A matrix has a number of slices, rows and columns, which are assigned upon instance construction - The matrix's size is then <tt>slices()*rows()*columns()</tt>.
 * Elements are accessed via <tt>[slice,row,column]</tt> coordinates.
 * Legal coordinates range from <tt>[0,0,0]</tt> to <tt>[slices()-1,rows()-1,columns()-1]</tt>.
 * Any attempt to access an element at a coordinate <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt> will throw an <tt>IndexOutOfBoundsException</tt>.
 * <p>
 * <b>Note</b> that this implementation is not synchronized.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="ObjectMatrix3D" startLine="32" endLine="32" />
    <javadoc>
      <text>* Applies a function to each cell and aggregates the results.
 * Returns a value <tt>v</tt> such that <tt>v==a(size())</tt> where <tt>a(i) == aggr( a(i-1), f(get(slice,row,column)) )</tt> and terminators are <tt>a(1) == f(get(0,0,0)), a(0)==null</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
 * 2 x 2 x 2 matrix
 * 0 1
 * 2 3
 * 4 5
 * 6 7
 * // Sum( x[slice,row,col]*x[slice,row,col] ) 
 * matrix.aggregate(F.plus,F.square);
 * --> 140
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value.</param>
      <param>f a function transforming the current cell value.</param>
      <return>the aggregated measure.</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="Object" name="aggregate" startLine="58" endLine="71">
      <declaration type="Object" name="a" />
      <declaration type="int" name="d" />
      <scope startLine="62" endLine="69">
        <scope startLine="63" endLine="68">
          <scope startLine="64" endLine="66" />
        </scope>
      </scope>
      <comment>last cell already done</comment>
    </method>
    <javadoc>
      <text>* Applies a function to each corresponding cell of two matrices and aggregates the results.
 * Returns a value <tt>v</tt> such that <tt>v==a(size())</tt> where <tt>a(i) == aggr( a(i-1), f(get(slice,row,column),other.get(slice,row,column)) )</tt> and terminators are <tt>a(1) == f(get(0,0,0),other.get(0,0,0)), a(0)==null</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
 * x = 2 x 2 x 2 matrix
 * 0 1
 * 2 3
 * 4 5
 * 6 7
 * y = 2 x 2 x 2 matrix
 * 0 1
 * 2 3
 * 4 5
 * 6 7
 * // Sum( x[slice,row,col] * y[slice,row,col] ) 
 * x.aggregate(y, F.plus, F.mult);
 * --> 140
 * // Sum( (x[slice,row,col] + y[slice,row,col])^2 )
 * x.aggregate(y, F.plus, F.chain(F.square,F.plus));
 * --> 560
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values.</param>
      <param>f a function transforming the current cell values.</param>
      <return>the aggregated measure.</return>
      <throws>IllegalArgumentException if <tt>slices() != other.slices() || rows() != other.rows() || columns() != other.columns()</tt></throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="Object" name="aggregate" startLine="109" endLine="123">
      <declaration type="Object" name="a" />
      <declaration type="int" name="d" />
      <scope startLine="114" endLine="121">
        <scope startLine="115" endLine="120">
          <scope startLine="116" endLine="118" />
        </scope>
      </scope>
      <comment>last cell already done</comment>
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>values</tt>.
 * <tt>values</tt> is required to have the form <tt>values[slice][row][column]</tt>
 * and have exactly the same number of slices, rows and columns as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values the values to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows()</tt>.</throws>
      <throws>IllegalArgumentException if <tt>for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns()</tt>.</throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="assign" startLine="136" endLine="150">
      <scope startLine="138" endLine="148">
        <declaration type="Object[][]" name="currentSlice" />
        <scope startLine="141" endLine="147">
          <declaration type="Object[]" name="currentRow" />
          <scope startLine="144" endLine="146" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[slice,row,col] = function(x[slice,row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * matrix = 1 x 2 x 2 matrix
 * 0.5 1.5      
 * 2.5 3.5
 * // change each cell to its sine
 * matrix.assign(cern.jet.math.Functions.sin);
 * -->
 * 1 x 2 x 2 matrix
 * 0.479426  0.997495 
 * 0.598472 -0.350783
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>function a function object taking as argument the current cell's value.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="ObjectMatrix3D" name="assign" startLine="173" endLine="182">
      <scope startLine="174" endLine="180">
        <scope startLine="175" endLine="179">
          <scope startLine="176" endLine="178" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of slices, rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>other   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>slices() != other.slices() || rows() != other.rows() || columns() != other.columns()</tt></throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="assign" startLine="192" endLine="205">
      <scope startLine="197" endLine="203">
        <scope startLine="198" endLine="202">
          <scope startLine="199" endLine="201" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[row,col] = function(x[row,col],y[row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * // assign x[row,col] = x[row,col]<sup>y[row,col]</sup>
 * m1 = 1 x 2 x 2 matrix 
 * 0 1 
 * 2 3
 * m2 = 1 x 2 x 2 matrix 
 * 0 2 
 * 4 6
 * m1.assign(m2, cern.jet.math.Functions.pow);
 * -->
 * m1 == 1 x 2 x 2 matrix
 * 1   1 
 * 16 729
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>y the secondary matrix to operate on.</param>
      <param>function a function object taking as first argument the current cell's value of <tt>this</tt>,
 * and as second argument the current cell's value of <tt>y</tt>,</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>slices() != other.slices() || rows() != other.rows() || columns() != other.columns()</tt></throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="ObjectMatrix3D" name="assign" startLine="235" endLine="245">
      <scope startLine="237" endLine="243">
        <scope startLine="238" endLine="242">
          <scope startLine="239" endLine="241" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="assign" startLine="251" endLine="260">
      <scope startLine="252" endLine="258">
        <scope startLine="253" endLine="257">
          <scope startLine="254" endLine="256" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the number of cells having non-zero values; ignores tolerance.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="264" endLine="274">
      <declaration type="int" name="cardinality" />
      <scope startLine="266" endLine="272">
        <scope startLine="267" endLine="271">
          <scope startLine="268" endLine="270" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Constructs and returns a deep copy of the receiver.
 * <p>
 * <b>Note that the returned matrix is an independent deep copy.</b>
 * The returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="copy" startLine="283" endLine="285" />
    <javadoc>
      <text>* Compares the specified Object with the receiver for equality.
 * Equivalent to <tt>equals(otherObj,true)</tt>.</text>
      <param>otherObj the Object to be compared for equality with the receiver.</param>
      <return>true if the specified Object is equal to the receiver.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="293" endLine="295">
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Compares the specified Object with the receiver for equality.
 * Returns true if and only if the specified Object is also at least an ObjectMatrix3D, both matrices have the
 * same size, and all corresponding pairs of cells in the two matrices are the same.
 * In other words, two matrices are defined to be equal if they contain the
 * same cell values in the same order.
 * Tests elements for equality or identity as specified by <tt>testForEquality</tt>.
 * When testing for equality, two elements <tt>e1</tt> and
 * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
 * e1.equals(e2))</tt>.)</text>
      <param>otherObj the Object to be compared for equality with the receiver.</param>
      <param>testForEquality if true -> tests for equality, otherwise for identity.</param>
      <return>true if the specified Object is equal to the receiver.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="311" endLine="339">
      <scope startLine="312" endLine="312" />
      <declaration type="ObjectMatrix3D" name="other" />
      <scope startLine="319" endLine="327">
        <scope startLine="320" endLine="326">
          <scope startLine="321" endLine="325">
            <scope startLine="322" endLine="324" />
          </scope>
        </scope>
      </scope>
      <scope startLine="328" endLine="336">
        <scope startLine="329" endLine="335">
          <scope startLine="330" endLine="334">
            <scope startLine="331" endLine="333" />
          </scope>
        </scope>
      </scope>
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[slice,row,column]</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value of the specified cell.</return>
      <throws>IndexOutOfBoundsException if <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</throws>
    </javadoc>
    <method type="Object" name="get" startLine="349" endLine="352" />
    <javadoc>
      <text>* Returns the content of this matrix if it is a wrapper; or <tt>this</tt> otherwise.
 * Override this method in wrappers.</text>
    </javadoc>
    <method type="ObjectMatrix3D" name="getContent" startLine="357" endLine="359" />
    <javadoc>
      <text>* Fills the coordinates and values of cells having non-zero values into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists all have a new size, the number of non-zero values.
 * <p>
 * In general, fill order is <i>unspecified</i>.
 * This implementation fill like: <tt>for (slice = 0..slices-1) for (row = 0..rows-1) for (column = 0..colums-1) do ... </tt>.
 * However, subclasses are free to us any other order, even an order that may change over time as cell values are changed.
 * (Of course, result lists indexes are guaranteed to correspond to the same cell).
 * For an example, see {@link ObjectMatrix2D#getNonZeros(IntArrayList,IntArrayList,ObjectArrayList)}.</text>
      <param>sliceList the list to be filled with slice indexes, can have any size.</param>
      <param>rowList the list to be filled with row indexes, can have any size.</param>
      <param>columnList the list to be filled with column indexes, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="getNonZeros" startLine="376" endLine="397">
      <declaration type="int" name="s" />
      <declaration type="int" name="r" />
      <declaration type="int" name="c" />
      <scope startLine="384" endLine="396">
        <scope startLine="385" endLine="395">
          <scope startLine="386" endLine="394">
            <declaration type="Object" name="value" />
            <scope startLine="388" endLine="393" />
          </scope>
        </scope>
      </scope>
    </method>
    <method name="getQuick" type="Object" startLine="398" endLine="410" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[slice,row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCells" startLine="414" endLine="418" />
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="422" endLine="424" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the same number of slices, rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseObjectMatrix3D</tt> the new matrix must also be of type <tt>DenseObjectMatrix3D</tt>,
 * if the receiver is an instance of type <tt>SparseObjectMatrix3D</tt> the new matrix must also be of type <tt>SparseObjectMatrix3D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="like" startLine="433" endLine="435" />
    <method name="like" type="ObjectMatrix3D" startLine="436" endLine="447" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of slices, rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseObjectMatrix3D</tt> the new matrix must also be of type <tt>DenseObjectMatrix3D</tt>,
 * if the receiver is an instance of type <tt>SparseObjectMatrix3D</tt> the new matrix must also be of type <tt>SparseObjectMatrix3D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>slices the number of slices the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method name="like2D" type="ObjectMatrix2D" startLine="448" endLine="461" />
    <javadoc>
      <text>* Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseObjectMatrix3D</tt> the new matrix must also be of type <tt>DenseObjectMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseObjectMatrix3D</tt> the new matrix must also be of type <tt>SparseObjectMatrix2D</tt>, etc.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>rowZero the position of the first element.</param>
      <param>columnZero the position of the first element.</param>
      <param>rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.</param>
      <param>columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[slice,row,column]</tt> to the specified value.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
      <throws>IndexOutOfBoundsException if <tt>row&lt;0 || row&gt;=rows() || slice&lt;0 || slice&gt;=slices() || column&lt;0 || column&gt;=column()</tt>.</throws>
    </javadoc>
    <method type="void" name="set" startLine="471" endLine="474" />
    <method name="setQuick" type="void" startLine="475" endLine="487" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[slice,row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <javadoc>
      <text>* Constructs and returns a 2-dimensional array containing the cell values.
 * The returned array <tt>values</tt> has the form <tt>values[slice][row][column]</tt>
 * and has the same number of slices, rows and columns as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <return>an array filled with the values of the cells.</return>
    </javadoc>
    <method type="Object[][][]" name="toArray" startLine="497" endLine="509">
      <declaration type="Object[][][]" name="values" />
      <scope startLine="499" endLine="507">
        <declaration type="Object[][]" name="currentSlice" />
        <scope startLine="501" endLine="506">
          <declaration type="Object[]" name="currentRow" />
          <scope startLine="503" endLine="505" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns a string representation using default formatting.</text>
      <see>cern.colt.matrix.objectalgo.Formatter</see>
    </javadoc>
    <method type="String" name="toString" startLine="514" endLine="516" />
    <javadoc>
      <text>* Constructs and returns a new view equal to the receiver.
 * The view is a shallow clone. Calls <code>clone()</code> and casts the result.
 * <p>
 * <b>Note that the view is not a deep copy.</b>
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
 * <p>
 * Use {@link #copy()} if you want to construct an independent deep copy rather than a new view.</text>
      <return>a new view of the receiver.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="view" startLine="528" endLine="530" />
    <javadoc>
      <text>* Constructs and returns a new 2-dimensional <i>slice view</i> representing the slices and rows of the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p>
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>view().part(...)</tt>), then apply this method to the sub-range view.
 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods <tt>viewColumn</tt>, <tt>viewRow</tt>) on the intermediate 2-dimensional view.
 * To obtain 1-dimensional views on subranges, apply both steps.</text>
      <param>column the index of the column to fix.</param>
      <return>a new 2-dimensional slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.</throws>
      <see>#viewSlice(int)</see>
      <see>#viewRow(int)</see>
    </javadoc>
    <method type="ObjectMatrix2D" name="viewColumn" startLine="545" endLine="557">
      <declaration type="int" name="sliceRows" />
      <declaration type="int" name="sliceColumns" />
      <declaration type="int" name="sliceRowZero" />
      <declaration type="int" name="sliceColumnZero" />
      <declaration type="int" name="sliceRowStride" />
      <declaration type="int" name="sliceColumnStride" />
      <comment>int sliceOffset = index(0,0,column);</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the column axis.
 * What used to be column <tt>0</tt> is now column <tt>columns()-1</tt>, ..., what used to be column <tt>columns()-1</tt> is now column <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <return>a new flip view.</return>
      <see>#viewSliceFlip()</see>
      <see>#viewRowFlip()</see>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewColumnFlip" startLine="567" endLine="569" />
    <javadoc>
      <text>* Constructs and returns a new <i>dice view</i>; Swaps dimensions (axes); Example: 3 x 4 x 5 matrix --> 4 x 3 x 5 matrix.
 * The view has dimensions exchanged; what used to be one axis is now another, in all desired permutations.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>axis0 the axis that shall become axis 0 (legal values 0..2).</param>
      <param>axis1 the axis that shall become axis 1 (legal values 0..2).</param>
      <param>axis2 the axis that shall become axis 2 (legal values 0..2).</param>
      <return>a new dice view.</return>
      <throws>IllegalArgumentException if some of the parameters are equal or not in range 0..2.</throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewDice" startLine="581" endLine="583" />
    <javadoc>
      <text>* Constructs and returns a new <i>sub-range view</i> that is a <tt>depth x height x width</tt> sub matrix starting at <tt>[slice,row,column]</tt>;
 * Equivalent to <tt>view().part(slice,row,column,depth,height,width)</tt>; Provided for convenience only.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>slice   The index of the slice-coordinate.</param>
      <param>row   The index of the row-coordinate.</param>
      <param>column   The index of the column-coordinate.</param>
      <param>depth   The depth of the box.</param>
      <param>height   The height of the box.</param>
      <param>width   The width of the box.</param>
      <throws>IndexOutOfBoundsException if <tt>slice<0 || depth<0 || slice+depth>slices() || row<0 || height<0 || row+height>rows() || column<0 || width<0 || column+width>columns()</tt></throws>
      <return>the new view.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewPart" startLine="599" endLine="601" />
    <javadoc>
      <text>* Constructs and returns a new 2-dimensional <i>slice view</i> representing the slices and columns of the given row.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p>
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>view().part(...)</tt>), then apply this method to the sub-range view.
 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods <tt>viewColumn</tt>, <tt>viewRow</tt>) on the intermediate 2-dimensional view.
 * To obtain 1-dimensional views on subranges, apply both steps.</text>
      <param>row the index of the row to fix.</param>
      <return>a new 2-dimensional slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= row()</tt>.</throws>
      <see>#viewSlice(int)</see>
      <see>#viewColumn(int)</see>
    </javadoc>
    <method type="ObjectMatrix2D" name="viewRow" startLine="616" endLine="628">
      <declaration type="int" name="sliceRows" />
      <declaration type="int" name="sliceColumns" />
      <declaration type="int" name="sliceRowZero" />
      <declaration type="int" name="sliceColumnZero" />
      <declaration type="int" name="sliceRowStride" />
      <declaration type="int" name="sliceColumnStride" />
      <comment>int sliceOffset = index(0,row,0);</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the row axis.
 * What used to be row <tt>0</tt> is now row <tt>rows()-1</tt>, ..., what used to be row <tt>rows()-1</tt> is now row <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <return>a new flip view.</return>
      <see>#viewSliceFlip()</see>
      <see>#viewColumnFlip()</see>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewRowFlip" startLine="638" endLine="640" />
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding the indicated cells.
 * There holds <tt>view.slices() == sliceIndexes.length, view.rows() == rowIndexes.length, view.columns() == columnIndexes.length</tt> and 
 * <tt>view.get(k,i,j) == this.get(sliceIndexes[k],rowIndexes[i],columnIndexes[j])</tt>.
 * Indexes can occur multiple times and can be in arbitrary order.
 * For an example see {@link ObjectMatrix2D#viewSelection(int[],int[])}.
 * <p>
 * Note that modifying the index arguments after this call has returned has no effect on the view.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>sliceIndexes   The slices of the cells that shall be visible in the new view. To indicate that <i>all</i> slices shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <param>rowIndexes   The rows of the cells that shall be visible in the new view. To indicate that <i>all</i> rows shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <param>columnIndexes   The columns of the cells that shall be visible in the new view. To indicate that <i>all</i> columns shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <return>the new view.</return>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= sliceIndexes[i] < slices())</tt> for any <tt>i=0..sliceIndexes.length()-1</tt>.</throws>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= rowIndexes[i] < rows())</tt> for any <tt>i=0..rowIndexes.length()-1</tt>.</throws>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= columnIndexes[i] < columns())</tt> for any <tt>i=0..columnIndexes.length()-1</tt>.</throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewSelection" startLine="659" endLine="693">
      <scope startLine="661" endLine="664" />
      <scope startLine="665" endLine="668" />
      <scope startLine="669" endLine="672" />
      <declaration type="int[]" name="sliceOffsets" />
      <declaration type="int[]" name="rowOffsets" />
      <declaration type="int[]" name="columnOffsets" />
      <scope startLine="682" endLine="684" />
      <scope startLine="685" endLine="687" />
      <scope startLine="688" endLine="690" />
      <comment>check for "all"</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding all <b>slices</b> matching the given condition.
 * Applies the condition to each slice and takes only those where <tt>condition.apply(viewSlice(i))</tt> yields <tt>true</tt>.
 * To match rows or columns, use a dice view.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * // extract and view all slices which have an aggregate sum > 1000
 * matrix.viewSelection( 
 * &nbsp;&nbsp;&nbsp;new ObjectMatrix2DProcedure() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(ObjectMatrix2D m) { return m.zSum > 1000; }
 * &nbsp;&nbsp;&nbsp;}
 * );
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>condition The condition to be matched.</param>
      <return>the new view.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewSelection" startLine="715" endLine="723">
      <declaration type="IntArrayList" name="matches" />
      <scope startLine="717" endLine="719" />
      <comment>take all rows and columns</comment>
    </method>
    <method name="viewSelectionLike" type="ObjectMatrix3D" startLine="724" endLine="732" />
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>sliceOffsets the offsets of the visible elements.</param>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <javadoc>
      <text>* Constructs and returns a new 2-dimensional <i>slice view</i> representing the rows and columns of the given slice.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p>
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>view().part(...)</tt>), then apply this method to the sub-range view.
 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods <tt>viewColumn</tt>, <tt>viewRow</tt>) on the intermediate 2-dimensional view.
 * To obtain 1-dimensional views on subranges, apply both steps.</text>
      <param>slice the index of the slice to fix.</param>
      <return>a new 2-dimensional slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>slice < 0 || slice >= slices()</tt>.</throws>
      <see>#viewRow(int)</see>
      <see>#viewColumn(int)</see>
    </javadoc>
    <method type="ObjectMatrix2D" name="viewSlice" startLine="747" endLine="759">
      <declaration type="int" name="sliceRows" />
      <declaration type="int" name="sliceColumns" />
      <declaration type="int" name="sliceRowZero" />
      <declaration type="int" name="sliceColumnZero" />
      <declaration type="int" name="sliceRowStride" />
      <declaration type="int" name="sliceColumnStride" />
      <comment>int sliceOffset = index(slice,0,0);</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the slice axis.
 * What used to be slice <tt>0</tt> is now slice <tt>slices()-1</tt>, ..., what used to be slice <tt>slices()-1</tt> is now slice <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <return>a new flip view.</return>
      <see>#viewRowFlip()</see>
      <see>#viewColumnFlip()</see>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewSliceFlip" startLine="769" endLine="771" />
    <javadoc>
      <text>* Sorts the matrix slices into ascending order, according to the <i>natural ordering</i> of the matrix values in the given <tt>[row,column]</tt> position.
 * This sort is guaranteed to be <i>stable</i>.
 * For further information, see {@link cern.colt.matrix.objectalgo.Sorting#sort(ObjectMatrix3D,int,int)}.
 * For more advanced sorting functionality, see {@link cern.colt.matrix.objectalgo.Sorting}.</text>
      <return>a new sorted vector (matrix) view.</return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= rows() || column < 0 || column >= columns()</tt>.</throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewSorted" startLine="780" endLine="782" />
    <javadoc>
      <text>* Constructs and returns a new <i>stride view</i> which is a sub matrix consisting of every i-th cell.
 * More specifically, the view has <tt>this.slices()/sliceStride</tt> slices and <tt>this.rows()/rowStride</tt> rows and <tt>this.columns()/columnStride</tt> columns 
 * holding cells <tt>this.get(k*sliceStride,i*rowStride,j*columnStride)</tt> for all <tt>k = 0..slices()/sliceStride - 1, i = 0..rows()/rowStride - 1, j = 0..columns()/columnStride - 1</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>sliceStride the slice step factor.</param>
      <param>rowStride the row step factor.</param>
      <param>columnStride the column step factor.</param>
      <return>a new view.</return>
      <throws>IndexOutOfBoundsException if <tt>sliceStride<=0 || rowStride<=0 || columnStride<=0</tt>.</throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewStrides" startLine="795" endLine="797" />
    <javadoc>
      <text>* Applies a procedure to each cell's value.
 * Iterates downwards from <tt>[slices()-1,rows()-1,columns()-1]</tt> to <tt>[0,0,0]</tt>,
 * as demonstrated by this snippet:
 * <pre>
 * for (int slice=slices; --slice >=0;) {
 * for (int row=rows; --row >= 0;) {
 * for (int column=columns; --column >= 0;) {
 * if (!procedure.apply(get(slice,row,column))) return false;
 * }
 * }
 * }
 * return true;
 * </pre>
 * Note that an implementation may use more efficient techniques, but must not use any other order.</text>
      <param>procedure a procedure object taking as argument the current cell's value. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="xforEach" startLine="817" endLine="826">
      <scope startLine="818" endLine="824">
        <scope startLine="819" endLine="823">
          <scope startLine="820" endLine="822" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Applies a procedure to each cell's coordinate.
 * Iterates downwards from <tt>[slices()-1,rows()-1,columns()-1]</tt> to <tt>[0,0,0]</tt>,
 * as demonstrated by this snippet:
 * <pre>
 * for (int slice=slices; --slice >=0;) {
 * for (int row=rows; --row >= 0;) {
 * for (int column=columns; --column >= 0;) {
 * if (!procedure.apply(slice,row,column)) return false;
 * }
 * }
 * }
 * return true;
 * </pre>
 * Note that an implementation may use more efficient techniques, but must not use any other order.</text>
      <param>procedure a procedure object taking as first argument the current slice, as second argument the current row, and as third argument the current column. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="xforEachCoordinate" startLine="846" endLine="855">
      <scope startLine="847" endLine="853">
        <scope startLine="848" endLine="852">
          <scope startLine="849" endLine="851" />
        </scope>
      </scope>
    </method>
  </class>
</source>
