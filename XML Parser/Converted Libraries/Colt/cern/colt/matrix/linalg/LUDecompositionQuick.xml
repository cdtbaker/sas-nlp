<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.linalg">
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="LUDecompositionQuick" startLine="13">
    <implements name="java.io.Serializable" />
    <javadoc>
      <text>* A low level version of {@link LUDecomposition}, avoiding unnecessary memory allocation and copying.
 * The input to <tt>decompose</tt> methods is overriden with the result (LU).
 * The input to <tt>solve</tt> methods is overriden with the result (X).
 * In addition to <tt>LUDecomposition</tt>, this class also includes a faster variant of the decomposition, specialized for tridiagonal (and hence also diagonal) matrices,
 * as well as a solver tuned for vectors.
 * Its disadvantage is that it is a bit more difficult to use than <tt>LUDecomposition</tt>. 
 * Thus, you may want to disregard this class and come back later, if a need for speed arises.
 * <p>
 * An instance of this class remembers the result of its last decomposition.
 * Usage pattern is as follows: Create an instance of this class, call a decompose method, 
 * then retrieve the decompositions, determinant, and/or solve as many equation problems as needed.
 * Once another matrix needs to be LU-decomposed, you need not create a new instance of this class. 
 * Start again by calling a decompose method, then retrieve the decomposition and/or solve your equations, and so on.
 * In case a <tt>LU</tt> matrix is already available, call method <tt>setLU</tt> instead of <tt>decompose</tt> and proceed with solving et al.
 * <p>
 * If a matrix shall not be overriden, use <tt>matrix.copy()</tt> and hand the the copy to methods.
 * <p>
 * For an <tt>m x n</tt> matrix <tt>A</tt> with <tt>m >= n</tt>, the LU decomposition is an <tt>m x n</tt>
 * unit lower triangular matrix <tt>L</tt>, an <tt>n x n</tt> upper triangular matrix <tt>U</tt>,
 * and a permutation vector <tt>piv</tt> of length <tt>m</tt> so that <tt>A(piv,:) = L*U</tt>;
 * If <tt>m < n</tt>, then <tt>L</tt> is <tt>m x m</tt> and <tt>U</tt> is <tt>m x n</tt>.
 * <P>
 * The LU decomposition with pivoting always exists, even if the matrix is
 * singular, so the decompose methods will never fail.  The primary use of the
 * LU decomposition is in the solution of square systems of simultaneous
 * linear equations.
 * Attempting to solve such a system will throw an exception if <tt>isNonsingular()</tt> returns false.
 * <p></text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Array for internal storage of decomposition.</text>
      <serial>internal array storage.</serial>
    </javadoc>
    <declaration type="DoubleMatrix2D" name="LU" />
    <javadoc>
      <text>* pivot sign.</text>
      <serial>pivot sign.</serial>
    </javadoc>
    <declaration type="int" name="pivsign" />
    <javadoc>
      <text>* Internal storage of pivot vector.</text>
      <serial>pivot vector.</serial>
    </javadoc>
    <declaration type="int[]" name="piv" />
    <declaration type="boolean" name="isNonSingular" />
    <declaration type="Algebra" name="algebra" />
    <declaration type="double[]" name="workDouble" />
    <declaration type="int[]" name="work1" />
    <declaration type="int[]" name="work2" />
    <javadoc>
      <text>* Constructs and returns a new LU Decomposition object with default tolerance <tt>1.0E-9</tt> for singularity detection.</text>
    </javadoc>
    <method type="constructor" name="LUDecompositionQuick" startLine="71" endLine="73" />
    <javadoc>
      <text>* Constructs and returns a new LU Decomposition object which uses the given tolerance for singularity detection;</text>
    </javadoc>
    <method type="constructor" name="LUDecompositionQuick" startLine="77" endLine="79" />
    <javadoc>
      <text>* Decomposes matrix <tt>A</tt> into <tt>L</tt> and <tt>U</tt> (in-place).
 * Upon return <tt>A</tt> is overridden with the result <tt>LU</tt>, such that <tt>L*U = A</tt>.
 * Uses a "left-looking", dot-product, Crout/Doolittle algorithm.</text>
      <param>A   any matrix.</param>
    </javadoc>
    <method type="void" name="decompose" startLine="86" endLine="175">
      <declaration type="int" name="CUT_OFF" />
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="98" endLine="101">
        <comment>nothing to do</comment>
      </scope>
      <declaration type="DoubleMatrix1D[]" name="LUrows" />
      <declaration type="cern.colt.list.IntArrayList" name="nonZeroIndexes" />
      <declaration type="DoubleMatrix1D" name="LUcolj" />
      <declaration type="cern.jet.math.Mult" name="multFunction" />
      <scope startLine="112" endLine="173">
        <declaration type="int" name="maxCardinality" />
        <declaration type="int" name="cardinality" />
        <declaration type="boolean" name="sparse" />
        <scope startLine="123" endLine="146">
          <declaration type="int" name="kmax" />
          <declaration type="double" name="s" />
          <scope startLine="126" endLine="128" />
          <scope startLine="129" endLine="131" />
          <declaration type="double" name="before" />
          <declaration type="double" name="after" />
          <scope startLine="136" endLine="145">
            <scope startLine="137" endLine="141">
              <declaration type="int" name="pos" />
            </scope>
            <scope startLine="142" endLine="144" />
          </scope>
        </scope>
        <declaration type="int" name="p" />
        <scope startLine="150" endLine="159">
          <declaration type="double" name="max" />
          <scope startLine="152" endLine="158">
            <declaration type="double" name="v" />
            <scope startLine="154" endLine="157" />
          </scope>
        </scope>
        <scope startLine="160" endLine="164">
          <declaration type="int" name="k" />
        </scope>
        <declaration type="double" name="jj" />
        <scope startLine="168" endLine="171" />
        <comment>blocking (make copy of j-th column to localize references)</comment>
        <comment>sparsity detection</comment>
        <comment>== heuristic depending on speedup</comment>
        <comment>Apply previous transformations.</comment>
        <comment>LUcolj is a copy</comment>
        <comment>this is the original</comment>
        <comment>nasty bug fixed!</comment>
        <comment>Find pivot and exchange if necessary.</comment>
        <comment>Compute multipliers.</comment>
      </scope>
      <comment>setup</comment>
      <comment>setup pivot vector</comment>
      <comment>precompute and cache some views to avoid regenerating them time and again</comment>
      <comment>sparsity</comment>
      <comment>blocked column j</comment>
      <comment>Outer loop.</comment>
    </method>
    <javadoc>
      <text>* Decomposes the banded and square matrix <tt>A</tt> into <tt>L</tt> and <tt>U</tt> (in-place).
 * Upon return <tt>A</tt> is overridden with the result <tt>LU</tt>, such that <tt>L*U = A</tt>.
 * Currently supports diagonal and tridiagonal matrices, all other cases fall through to {@link #decompose(DoubleMatrix2D)}.</text>
      <param>semiBandwidth == 1 --> A is diagonal, == 2 --> A is tridiagonal.</param>
      <param>A   any matrix.</param>
    </javadoc>
    <method type="void" name="decompose" startLine="183" endLine="215">
      <scope startLine="184" endLine="187" />
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="198" endLine="201">
        <comment>nothing to do</comment>
      </scope>
      <scope startLine="204" endLine="213">
        <scope startLine="208" endLine="212">
          <declaration type="double" name="ei" />
        </scope>
        <comment>A is tridiagonal</comment>
        <comment>currently no pivoting !</comment>
      </scope>
      <comment>setup</comment>
      <comment>setup pivot vector</comment>
      <comment>if (semiBandwidth == 1) {  A is diagonal; nothing to do</comment>
    </method>
    <javadoc>
      <text>* Returns the determinant, <tt>det(A)</tt>.</text>
      <exception>IllegalArgumentException  if <tt>A.rows() != A.columns()</tt> (Matrix must be square).</exception>
    </javadoc>
    <method type="double" name="det" startLine="220" endLine="232">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="double" name="det" />
      <scope startLine="228" endLine="230" />
      <comment>avoid rounding errors</comment>
    </method>
    <javadoc>
      <text>* Returns pivot permutation vector as a one-dimensional double array</text>
      <return>(double) piv</return>
    </javadoc>
    <method type="double[]" name="getDoublePivot" startLine="237" endLine="244">
      <declaration type="int" name="m" />
      <declaration type="double[]" name="vals" />
      <scope startLine="240" endLine="242" />
    </method>
    <javadoc>
      <text>* Returns the lower triangular factor, <tt>L</tt>.</text>
      <return><tt>L</tt></return>
    </javadoc>
    <method type="DoubleMatrix2D" name="getL" startLine="249" endLine="251" />
    <javadoc>
      <text>* Returns a copy of the combined lower and upper triangular factor, <tt>LU</tt>.</text>
      <return><tt>LU</tt></return>
    </javadoc>
    <method type="DoubleMatrix2D" name="getLU" startLine="256" endLine="258" />
    <javadoc>
      <text>* Returns the pivot permutation vector (not a copy of it).</text>
      <return>piv</return>
    </javadoc>
    <method type="int[]" name="getPivot" startLine="263" endLine="265" />
    <javadoc>
      <text>* Returns the upper triangular factor, <tt>U</tt>.</text>
      <return><tt>U</tt></return>
    </javadoc>
    <method type="DoubleMatrix2D" name="getU" startLine="270" endLine="272" />
    <javadoc>
      <text>* Returns whether the matrix is nonsingular (has an inverse).</text>
      <return>true if <tt>U</tt>, and hence <tt>A</tt>, is nonsingular; false otherwise.</return>
    </javadoc>
    <method type="boolean" name="isNonsingular" startLine="277" endLine="279" />
    <javadoc>
      <text>* Returns whether the matrix is nonsingular.</text>
      <return>true if <tt>matrix</tt> is nonsingular; false otherwise.</return>
    </javadoc>
    <method type="boolean" name="isNonsingular" startLine="284" endLine="293">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="double" name="epsilon" />
      <scope startLine="288" endLine="291">
        <comment>if (matrix.getQuick(j,j) == 0) return false;</comment>
      </scope>
      <comment>consider numerical instability</comment>
    </method>
    <javadoc>
      <text>* Modifies the matrix to be a lower triangular matrix.
 * <p>
 * <b>Examples:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">3 x 5 matrix:<br>
 * 9, 9, 9, 9, 9<br>
 * 9, 9, 9, 9, 9<br>
 * 9, 9, 9, 9, 9 </td>
 * <td align="center">triang.Upper<br>
 * ==></td>
 * <td valign="top">3 x 5 matrix:<br>
 * 9, 9, 9, 9, 9<br>
 * 0, 9, 9, 9, 9<br>
 * 0, 0, 9, 9, 9</td>
 * </tr>
 * <tr nowrap> 
 * <td valign="top">5 x 3 matrix:<br>
 * 9, 9, 9<br>
 * 9, 9, 9<br>
 * 9, 9, 9<br>
 * 9, 9, 9<br>
 * 9, 9, 9 </td>
 * <td align="center">triang.Upper<br>
 * ==></td>
 * <td valign="top">5 x 3 matrix:<br>
 * 9, 9, 9<br>
 * 0, 9, 9<br>
 * 0, 0, 9<br>
 * 0, 0, 0<br>
 * 0, 0, 0</td>
 * </tr>
 * <tr nowrap> 
 * <td valign="top">3 x 5 matrix:<br>
 * 9, 9, 9, 9, 9<br>
 * 9, 9, 9, 9, 9<br>
 * 9, 9, 9, 9, 9 </td>
 * <td align="center">triang.Lower<br>
 * ==></td>
 * <td valign="top">3 x 5 matrix:<br>
 * 1, 0, 0, 0, 0<br>
 * 9, 1, 0, 0, 0<br>
 * 9, 9, 1, 0, 0</td>
 * </tr>
 * <tr nowrap> 
 * <td valign="top">5 x 3 matrix:<br>
 * 9, 9, 9<br>
 * 9, 9, 9<br>
 * 9, 9, 9<br>
 * 9, 9, 9<br>
 * 9, 9, 9 </td>
 * <td align="center">triang.Lower<br>
 * ==></td>
 * <td valign="top">5 x 3 matrix:<br>
 * 1, 0, 0<br>
 * 9, 1, 0<br>
 * 9, 9, 1<br>
 * 9, 9, 9<br>
 * 9, 9, 9</td>
 * </tr>
 * </table></text>
      <return><tt>A</tt> (for convenience only).</return>
      <see>#triangulateUpper(DoubleMatrix2D)</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="lowerTriangular" startLine="360" endLine="373">
      <declaration type="int" name="rows" />
      <declaration type="int" name="columns" />
      <declaration type="int" name="min" />
      <scope startLine="364" endLine="369">
        <scope startLine="365" endLine="368" />
      </scope>
    </method>
    <javadoc />
    <method type="int" name="m" startLine="377" endLine="379" />
    <javadoc />
    <method type="int" name="n" startLine="383" endLine="385" />
    <javadoc>
      <text>* Sets the combined lower and upper triangular factor, <tt>LU</tt>.
 * The parameter is not checked; make sure it is indeed a proper LU decomposition.</text>
    </javadoc>
    <method type="void" name="setLU" startLine="390" endLine="393" />
    <javadoc>
      <text>* Solves the system of equations <tt>A*X = B</tt> (in-place).
 * Upon return <tt>B</tt> is overridden with the result <tt>X</tt>, such that <tt>L*U*X = B(piv)</tt>.</text>
      <param>B   A vector with <tt>B.size() == A.rows()</tt>.</param>
      <exception>IllegalArgumentException if </tt>B.size() != A.rows()</tt>.</exception>
      <exception>IllegalArgumentException  if A is singular, that is, if <tt>!isNonsingular()</tt>.</exception>
      <exception>IllegalArgumentException  if <tt>A.rows() < A.columns()</tt>.</exception>
    </javadoc>
    <method type="void" name="solve" startLine="402" endLine="442">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="418" endLine="427">
        <declaration type="double" name="f" />
        <scope startLine="420" endLine="426">
          <scope startLine="421" endLine="425">
            <declaration type="double" name="v" />
          </scope>
        </scope>
        <comment>B[i] -= B[k]*LU[i][k];</comment>
      </scope>
      <scope startLine="430" endLine="441">
        <declaration type="double" name="f" />
        <scope startLine="434" endLine="440">
          <scope startLine="435" endLine="439">
            <declaration type="double" name="v" />
          </scope>
        </scope>
        <comment>B[k] /= LU[k,k]</comment>
        <comment>B[i] -= B[k]*LU[i][k];</comment>
      </scope>
      <comment>right hand side with pivoting</comment>
      <comment>Matrix Xmat = B.getMatrix(piv,0,nx-1);</comment>
      <comment>nothing to do</comment>
      <comment>Solve L*Y = B(piv,:)</comment>
      <comment>Solve U*B = Y;</comment>
    </method>
    <javadoc>
      <text>* Solves the system of equations <tt>A*X = B</tt> (in-place).
 * Upon return <tt>B</tt> is overridden with the result <tt>X</tt>, such that <tt>L*U*X = B(piv,:)</tt>.</text>
      <param>B   A matrix with as many rows as <tt>A</tt> and any number of columns.</param>
      <exception>IllegalArgumentException if </tt>B.rows() != A.rows()</tt>.</exception>
      <exception>IllegalArgumentException  if A is singular, that is, if <tt>!isNonsingular()</tt>.</exception>
      <exception>IllegalArgumentException  if <tt>A.rows() < A.columns()</tt>.</exception>
    </javadoc>
    <method type="void" name="solve" startLine="451" endLine="542">
      <declaration type="int" name="CUT_OFF" />
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="nx" />
      <declaration type="DoubleMatrix1D[]" name="Brows" />
      <declaration type="cern.jet.math.Mult" name="div" />
      <declaration type="cern.jet.math.PlusMult" name="minusMult" />
      <declaration type="cern.colt.list.IntArrayList" name="nonZeroIndexes" />
      <declaration type="DoubleMatrix1D" name="Browk" />
      <scope startLine="481" endLine="505">
        <declaration type="int" name="maxCardinality" />
        <declaration type="int" name="cardinality" />
        <declaration type="boolean" name="sparse" />
        <scope startLine="491" endLine="504">
          <scope startLine="496" endLine="503">
            <scope startLine="497" endLine="499" />
            <scope startLine="500" endLine="502" />
          </scope>
        </scope>
        <comment>blocking (make copy of k-th row to localize references)</comment>
        <comment>sparsity detection</comment>
        <comment>== heuristic depending on speedup</comment>
        <comment>for (int j = 0; j < nx; j++) B[i][j] -= B[k][j]*LU[i][k];</comment>
        <comment>for (int j = 0; j < nx; j++) B.set(i,j, B.get(i,j) - B.get(k,j)*LU.get(i,k));</comment>
      </scope>
      <scope startLine="508" endLine="541">
        <declaration type="int" name="maxCardinality" />
        <declaration type="int" name="cardinality" />
        <declaration type="boolean" name="sparse" />
        <scope startLine="527" endLine="540">
          <scope startLine="532" endLine="539">
            <scope startLine="533" endLine="535" />
            <scope startLine="536" endLine="538" />
          </scope>
        </scope>
        <comment>for (int j = 0; j < nx; j++) B[k][j] /= LU[k][k];</comment>
        <comment>for (int j = 0; j < nx; j++) B.set(k,j, B.get(k,j) / LU.get(k,k));</comment>
        <comment>blocking</comment>
        <comment>sparsity detection</comment>
        <comment>== heuristic depending on speedup</comment>
        <comment>Browk.getNonZeros(nonZeroIndexes,null);</comment>
        <comment>boolean sparse = nonZeroIndexes.size() < nx/10;</comment>
        <comment>for (int j = 0; j < nx; j++) B[i][j] -= B[k][j]*LU[i][k];</comment>
        <comment>for (int j = 0; j < nx; j++) B.set(i,j, B.get(i,j) - B.get(k,j)*LU.get(i,k));</comment>
      </scope>
      <comment>right hand side with pivoting</comment>
      <comment>Matrix Xmat = B.getMatrix(piv,0,nx-1);</comment>
      <comment>if (this.work2 == null || this.work2.length < m) this.work2 = new int[m];</comment>
      <comment>nothing to do</comment>
      <comment>precompute and cache some views to avoid regenerating them time and again</comment>
      <comment>transformations</comment>
      <comment>sparsity</comment>
      <comment>blocked row k</comment>
      <comment>Solve L*Y = B(piv,:)</comment>
      <comment>Solve U*B = Y;</comment>
    </method>
    <javadoc>
      <text>* Solves <tt>A*X = B</tt>.</text>
      <param>B   A matrix with as many rows as <tt>A</tt> and any number of columns.</param>
      <return><tt>X</tt> so that <tt>L*U*X = B(piv,:)</tt>.</return>
      <exception>IllegalArgumentException if </tt>B.rows() != A.rows()</tt>.</exception>
      <exception>IllegalArgumentException  if A is singular, that is, if <tt>!this.isNonsingular()</tt>.</exception>
      <exception>IllegalArgumentException  if <tt>A.rows() < A.columns()</tt>.</exception>
    </javadoc>
    <method type="void" name="solveOld" startLine="551" endLine="596">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="nx" />
      <scope startLine="566" endLine="576">
        <scope startLine="567" endLine="575">
          <declaration type="double" name="mult" />
          <scope startLine="569" endLine="574">
            <scope startLine="570" endLine="573" />
          </scope>
        </scope>
        <comment>B[i][j] -= B[k][j]*LU[i,k];</comment>
      </scope>
      <scope startLine="578" endLine="595">
        <declaration type="double" name="mult" />
        <scope startLine="580" endLine="585">
          <scope startLine="581" endLine="584" />
        </scope>
        <scope startLine="586" endLine="594">
          <scope startLine="588" endLine="593">
            <scope startLine="589" endLine="592" />
          </scope>
        </scope>
        <comment>B[k][j] /= LU[k][k];</comment>
        <comment>B[i][j] -= B[k][j]*LU[i][k];</comment>
      </scope>
      <comment>Copy right hand side with pivoting</comment>
      <comment>if (this.work2 == null || this.work2.length < m) this.work2 = new int[m];</comment>
      <comment>Solve L*Y = B(piv,:) --> Y (Y is modified B)</comment>
      <comment>Solve U*X = Y; --> X (X is modified B)</comment>
    </method>
    <javadoc>
      <text>* Returns a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * <pre>
 * rank          : 3
 * trace         : 0
 * </pre></text>
    </javadoc>
    <method type="String" name="toString" startLine="606" endLine="640">
      <declaration type="StringBuffer" name="buf" />
      <declaration type="String" name="unknown" />
      <scope startLine="615" endLine="615" />
      <scope startLine="616" endLine="616" />
      <scope startLine="619" endLine="619" />
      <scope startLine="620" endLine="620" />
      <scope startLine="623" endLine="623" />
      <scope startLine="624" endLine="624" />
      <scope startLine="627" endLine="627" />
      <scope startLine="628" endLine="628" />
      <scope startLine="631" endLine="631" />
      <scope startLine="632" endLine="632" />
      <declaration type="DoubleMatrix2D" name="identity" />
      <scope startLine="636" endLine="636" />
      <scope startLine="637" endLine="637" />
    </method>
    <javadoc>
      <text>* Modifies the matrix to be an upper triangular matrix.</text>
      <return><tt>A</tt> (for convenience only).</return>
      <see>#triangulateLower(DoubleMatrix2D)</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="upperTriangular" startLine="646" endLine="658">
      <declaration type="int" name="rows" />
      <declaration type="int" name="columns" />
      <declaration type="int" name="min" />
      <scope startLine="650" endLine="654">
        <scope startLine="651" endLine="653" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns pivot permutation vector as a one-dimensional double array</text>
      <return>(double) piv</return>
    </javadoc>
    <method type="double[]" name="xgetDoublePivot" startLine="663" endLine="670">
      <declaration type="int" name="m" />
      <declaration type="double[]" name="vals" />
      <scope startLine="666" endLine="668" />
    </method>
  </class>
</source>
