<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.linalg">
  <import name="cern.colt.matrix.DoubleFactory2D" />
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="Algebra" extends="cern.colt.PersistentObject" startLine="14">
    <javadoc>
      <text>* Linear algebraic matrix operations operating on {@link DoubleMatrix2D}; concentrates most functionality of this package.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* A default Algebra object; has {@link Property#DEFAULT} attached for tolerance. 
 * Allows ommiting to construct an Algebra object time and again.
 * Note that this Algebra object is immutable.
 * Any attempt to assign a new Property object to it (via method <tt>setProperty</tt>), or to alter the tolerance of its property object (via <tt>property().setTolerance(...)</tt>) will throw an exception.</text>
    </javadoc>
    <declaration type="Algebra" name="DEFAULT" />
    <javadoc>
      <text>* A default Algebra object; has {@link Property#ZERO} attached for tolerance. 
 * Allows ommiting to construct an Algebra object time and again.
 * Note that this Algebra object is immutable.
 * Any attempt to assign a new Property object to it (via method <tt>setProperty</tt>), or to alter the tolerance of its property object (via <tt>property().setTolerance(...)</tt>) will throw an exception.</text>
    </javadoc>
    <declaration type="Algebra" name="ZERO" />
    <javadoc>
      <text>* The property object attached to this instance.</text>
    </javadoc>
    <declaration type="Property" name="property" />
    <scope startLine="44" endLine="51">
      <comment>don't use new Algebra(Property.DEFAULT.tolerance()), because then property object would be mutable.</comment>
      <comment>immutable property object</comment>
      <comment>immutable property object</comment>
    </scope>
    <javadoc>
      <text>* Constructs a new instance with an equality tolerance given by <tt>Property.DEFAULT.tolerance()</tt>.</text>
    </javadoc>
    <method type="constructor" name="Algebra" startLine="55" endLine="57" />
    <javadoc>
      <text>* Constructs a new instance with the given equality tolerance.</text>
      <param>tolerance the tolerance to be used for equality operations.</param>
    </javadoc>
    <method type="constructor" name="Algebra" startLine="62" endLine="64" />
    <javadoc>
      <text>* Constructs and returns the cholesky-decomposition of the given matrix.</text>
    </javadoc>
    <method type="CholeskyDecomposition" name="chol" startLine="68" endLine="70" />
    <javadoc>
      <text>* Returns a copy of the receiver.
 * The attached property object is also copied. Hence, the property object of the copy is mutable.</text>
      <return>a copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="77" endLine="79" />
    <javadoc>
      <text>* Returns the condition of matrix <tt>A</tt>, which is the ratio of largest to smallest singular value.</text>
    </javadoc>
    <method type="double" name="cond" startLine="83" endLine="85" />
    <javadoc>
      <text>* Returns the determinant of matrix <tt>A</tt>.</text>
      <return>the determinant.</return>
    </javadoc>
    <method type="double" name="det" startLine="90" endLine="92" />
    <javadoc>
      <text>* Constructs and returns the Eigenvalue-decomposition of the given matrix.</text>
    </javadoc>
    <method type="EigenvalueDecomposition" name="eig" startLine="96" endLine="98" />
    <javadoc>
      <text>* Returns sqrt(a^2 + b^2) without under/overflow.</text>
    </javadoc>
    <method type="double" name="hypot" startLine="102" endLine="114">
      <declaration type="double" name="r" />
      <scope startLine="104" endLine="107" />
      <scope startLine="107" endLine="110" />
      <scope startLine="110" endLine="112" />
    </method>
    <javadoc>
      <text>* Returns sqrt(a^2 + b^2) without under/overflow.</text>
    </javadoc>
    <method type="cern.colt.function.DoubleDoubleFunction" name="hypotFunction" startLine="118" endLine="124">
      <method type="double" name="apply" startLine="120" endLine="122" />
    </method>
    <javadoc>
      <text>* Returns the inverse or pseudo-inverse of matrix <tt>A</tt>.</text>
      <return>a new independent matrix; inverse(matrix) if the matrix is square, pseudoinverse otherwise.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="inverse" startLine="129" endLine="137">
      <scope startLine="130" endLine="135">
        <declaration type="DoubleMatrix2D" name="inv" />
        <declaration type="boolean" name="isNonSingular" />
      </scope>
    </method>
    <javadoc>
      <text>* Constructs and returns the LU-decomposition of the given matrix.</text>
    </javadoc>
    <method type="LUDecomposition" name="lu" startLine="141" endLine="143" />
    <javadoc>
      <text>* Inner product of two vectors; <tt>Sum(x[i] * y[i])</tt>.
 * Also known as dot product.
 * <br>
 * Equivalent to <tt>x.zDotProduct(y)</tt>.</text>
      <param>x the first source vector.</param>
      <param>y the second source matrix.</param>
      <return>the inner product.</return>
      <throws>IllegalArgumentException if <tt>x.size() != y.size()</tt>.</throws>
    </javadoc>
    <method type="double" name="mult" startLine="156" endLine="158" />
    <javadoc>
      <text>* Linear algebraic matrix-vector multiplication; <tt>z = A * y</tt>.
 * <tt>z[i] = Sum(A[i,j] * y[j]), i=0..A.rows()-1, j=0..y.size()-1</tt>.</text>
      <param>A the source matrix.</param>
      <param>y the source vector.</param>
      <return><tt>z</tt>; a new vector with <tt>z.size()==A.rows()</tt>.</return>
      <throws>IllegalArgumentException if <tt>A.columns() != y.size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="mult" startLine="168" endLine="170" />
    <javadoc>
      <text>* Linear algebraic matrix-matrix multiplication; <tt>C = A x B</tt>.
 * <tt>C[i,j] = Sum(A[i,k] * B[k,j]), k=0..n-1</tt>.
 * <br>
 * Matrix shapes: <tt>A(m x n), B(n x p), C(m x p)</tt>.</text>
      <param>A the first source matrix.</param>
      <param>B the second source matrix.</param>
      <return><tt>C</tt>; a new matrix holding the results, with <tt>C.rows()=A.rows(), C.columns()==B.columns()</tt>.</return>
      <throws>IllegalArgumentException if <tt>B.rows() != A.columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="mult" startLine="183" endLine="185" />
    <javadoc>
      <text>* Outer product of two vectors; Sets <tt>A[i,j] = x[i] * y[j]</tt>.</text>
      <param>x the first source vector.</param>
      <param>y the second source vector.</param>
      <param>A the matrix to hold the results. Set this parameter to <tt>null</tt> to indicate that a new result matrix shall be constructed.</param>
      <return>A (for convenience only).</return>
      <throws>IllegalArgumentException	if <tt>A.rows() != x.size() || A.columns() != y.size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="multOuter" startLine="195" endLine="205">
      <declaration type="int" name="rows" />
      <declaration type="int" name="columns" />
    </method>
    <javadoc>
      <text>* Returns the one-norm of vector <tt>x</tt>, which is <tt>Sum(abs(x[i]))</tt>.</text>
    </javadoc>
    <method type="double" name="norm1" startLine="209" endLine="212" />
    <javadoc>
      <text>* Returns the one-norm of matrix <tt>A</tt>, which is the maximum absolute column sum.</text>
    </javadoc>
    <method type="double" name="norm1" startLine="216" endLine="222">
      <declaration type="double" name="max" />
      <scope startLine="218" endLine="220" />
    </method>
    <javadoc>
      <text>* Returns the two-norm (aka <i>euclidean norm</i>) of vector <tt>x</tt>; equivalent to <tt>mult(x,x)</tt>.</text>
    </javadoc>
    <method type="double" name="norm2" startLine="226" endLine="228" />
    <javadoc>
      <text>* Returns the two-norm of matrix <tt>A</tt>, which is the maximum singular value; obtained from SVD.</text>
    </javadoc>
    <method type="double" name="norm2" startLine="232" endLine="234" />
    <javadoc>
      <text>* Returns the Frobenius norm of matrix <tt>A</tt>, which is <tt>Sqrt(Sum(A[i,j]<sup>2</sup>))</tt>.</text>
    </javadoc>
    <method type="double" name="normF" startLine="238" endLine="241" />
    <javadoc>
      <text>* Returns the infinity norm of vector <tt>x</tt>, which is <tt>Max(abs(x[i]))</tt>.</text>
    </javadoc>
    <method type="double" name="normInfinity" startLine="245" endLine="256">
      <comment>fix for bug reported by T.J.Hunt@open.ac.uk</comment>
      <comment>if (x.size()==0) return 0;</comment>
      <comment>return x.aggregate(cern.jet.math.Functions.plus,cern.jet.math.Functions.abs);</comment>
      <comment>double max = 0;</comment>
      <comment>for (int i = x.size(); --i >= 0; ) {</comment>
      <comment>max = Math.max(max, x.getQuick(i));</comment>
      <comment>}</comment>
      <comment>return max;</comment>
    </method>
    <javadoc>
      <text>* Returns the infinity norm of matrix <tt>A</tt>, which is the maximum absolute row sum.</text>
    </javadoc>
    <method type="double" name="normInfinity" startLine="260" endLine="267">
      <declaration type="double" name="max" />
      <scope startLine="262" endLine="265">
        <comment>max = Math.max(max, normInfinity(A.viewRow(row)));</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Modifies the given vector <tt>A</tt> such that it is permuted as specified; Useful for pivoting.
 * Cell <tt>A[i]</tt> will go into cell <tt>A[indexes[i]]</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
 * [A,E,C,D,B]
 * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[2], A[3]<--A[3], A[4]<--A[1].
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
 * [A,E,B,C,D]
 * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[1], A[3]<--A[2], A[4]<--A[3].
 * </pre></text>
      <param>A   the vector to permute.</param>
      <param>indexes the permutation indexes, must satisfy <tt>indexes.length==A.size() && indexes[i] >= 0 && indexes[i] < A.size()</tt>;</param>
      <param>work the working storage, must satisfy <tt>work.length >= A.size()</tt>; set <tt>work==null</tt> if you don't care about performance.</param>
      <return>the modified <tt>A</tt> (for convenience only).</return>
      <throws>IndexOutOfBoundsException if <tt>indexes.length != A.size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="permute" startLine="291" endLine="311">
      <declaration type="int" name="size" />
      <scope startLine="303" endLine="305" />
      <scope startLine="306" endLine="308" />
      <comment>check validity</comment>
      <comment>int i=size;
int a;
while (--i >= 0 && (a=indexes[i])==i) if (a < 0 || a >= size) throw new IndexOutOfBoundsException("invalid permutation");
if (i<0) return;  nothing to permute</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new row and column permuted <i>selection view</i> of matrix <tt>A</tt>; equivalent to {@link DoubleMatrix2D#viewSelection(int[],int[])}.
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
 * Use idioms like <tt>result = permute(...).copy()</tt> to generate an independent sub matrix.</text>
      <return>the new permuted selection view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="permute" startLine="318" endLine="320" />
    <javadoc>
      <text>* Modifies the given matrix <tt>A</tt> such that it's columns are permuted as specified; Useful for pivoting.
 * Column <tt>A[i]</tt> will go into column <tt>A[indexes[i]]</tt>.
 * Equivalent to <tt>permuteRows(transpose(A), indexes, work)</tt>.</text>
      <param>A   the matrix to permute.</param>
      <param>indexes the permutation indexes, must satisfy <tt>indexes.length==A.columns() && indexes[i] >= 0 && indexes[i] < A.columns()</tt>;</param>
      <param>work the working storage, must satisfy <tt>work.length >= A.columns()</tt>; set <tt>work==null</tt> if you don't care about performance.</param>
      <return>the modified <tt>A</tt> (for convenience only).</return>
      <throws>IndexOutOfBoundsException if <tt>indexes.length != A.columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="permuteColumns" startLine="331" endLine="333" />
    <javadoc>
      <text>* Modifies the given matrix <tt>A</tt> such that it's rows are permuted as specified; Useful for pivoting.
 * Row <tt>A[i]</tt> will go into row <tt>A[indexes[i]]</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
 * [A,E,C,D,B]
 * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[2], A[3]<--A[3], A[4]<--A[1].
 * Reordering
 * [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
 * [A,E,B,C,D]
 * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[1], A[3]<--A[2], A[4]<--A[3].
 * </pre></text>
      <param>A   the matrix to permute.</param>
      <param>indexes the permutation indexes, must satisfy <tt>indexes.length==A.rows() && indexes[i] >= 0 && indexes[i] < A.rows()</tt>;</param>
      <param>work the working storage, must satisfy <tt>work.length >= A.rows()</tt>; set <tt>work==null</tt> if you don't care about performance.</param>
      <return>the modified <tt>A</tt> (for convenience only).</return>
      <throws>IndexOutOfBoundsException if <tt>indexes.length != A.rows()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="permuteRows" startLine="357" endLine="384">
      <declaration type="int" name="size" />
      <declaration type="int" name="columns" />
      <scope startLine="370" endLine="374">
        <declaration type="double[]" name="doubleWork" />
        <comment>quicker</comment>
      </scope>
      <declaration type="cern.colt.Swapper" name="swapper" />
      <method type="void" name="swap" startLine="377" endLine="379" />
      <comment>check validity</comment>
      <comment>int i=size;
int a;
while (--i >= 0 && (a=indexes[i])==i) if (a < 0 || a >= size) throw new IndexOutOfBoundsException("invalid permutation");
if (i<0) return;  nothing to permute</comment>
    </method>
    <javadoc>
      <text>* Linear algebraic matrix power; <tt>B = A<sup>k</sup> <==> B = A*A*...*A</tt>.
 * <ul>
 * <li><tt>p &gt;= 1: B = A*A*...*A</tt>.</li>
 * <li><tt>p == 0: B = identity matrix</tt>.</li>
 * <li><tt>p &lt;  0: B = pow(inverse(A),-p)</tt>.</li>
 * </ul>
 * Implementation: Based on logarithms of 2, memory usage minimized.</text>
      <param>A the source matrix; must be square; stays unaffected by this operation.</param>
      <param>p the exponent, can be any number.</param>
      <return><tt>B</tt>, a newly constructed result matrix; storage-independent of <tt>A</tt>.</return>
      <throws>IllegalArgumentException if <tt>!property().isSquare(A)</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="pow" startLine="399" endLine="454">
      <declaration type="Blas" name="blas" />
      <scope startLine="405" endLine="408" />
      <declaration type="DoubleMatrix2D" name="T" />
      <scope startLine="412" endLine="415">
        <comment>mult(A,A);  safes one auxiliary matrix allocation</comment>
      </scope>
      <declaration type="int" name="k" />
      <declaration type="int" name="i" />
      <scope startLine="432" endLine="437">
        <declaration type="DoubleMatrix2D" name="swap" />
        <comment>while (bit i of p == false)</comment>
        <comment>A = mult(A,A); would allocate a lot of temporary memory</comment>
        <comment>A.zMult(A,T);</comment>
        <comment>swap A with T</comment>
      </scope>
      <declaration type="DoubleMatrix2D" name="B" />
      <scope startLine="441" endLine="451">
        <declaration type="DoubleMatrix2D" name="swap" />
        <scope startLine="446" endLine="450" />
        <comment>A = mult(A,A); would allocate a lot of temporary memory</comment>
        <comment>A.zMult(A,T);</comment>
        <comment>swap A with T</comment>
        <comment>if (bit i of p == true)</comment>
        <comment>B = mult(B,A); would allocate a lot of temporary memory</comment>
        <comment>B.zMult(A,T);</comment>
        <comment>swap B with T</comment>
      </scope>
      <comment>matrix multiplication based on log2 method: A*A*....*A is slow, ((A * A)^2)^2 * ... is faster</comment>
      <comment>allocates two auxiliary matrices as work space</comment>
      <comment>for parallel matrix mult; if not initialized defaults to sequential blas</comment>
      <comment>temporary</comment>
      <comment>safes one auxiliary matrix allocation</comment>
      <comment>index of highest bit in state "true"</comment>
      <comment>this is the naive version:
DoubleMatrix2D B = A.copy();
for (int i=0; i<p-1; i++) {
B = mult(B,A);
}
return B;</comment>
      <comment>here comes the optimized version:</comment>
      <comment>cern.colt.Timer timer = new cern.colt.Timer().start();</comment>
      <comment>timer.stop().display();</comment>
    </method>
    <javadoc>
      <text>* Returns the property object attached to this Algebra, defining tolerance.</text>
      <return>the Property object.</return>
      <see>#setProperty(Property)</see>
    </javadoc>
    <method type="Property" name="property" startLine="460" endLine="462" />
    <javadoc>
      <text>* Constructs and returns the QR-decomposition of the given matrix.</text>
    </javadoc>
    <method type="QRDecomposition" name="qr" startLine="466" endLine="468" />
    <javadoc>
      <text>* Returns the effective numerical rank of matrix <tt>A</tt>, obtained from Singular Value Decomposition.</text>
    </javadoc>
    <method type="int" name="rank" startLine="472" endLine="474" />
    <javadoc>
      <text>* Attaches the given property object to this Algebra, defining tolerance.</text>
      <param>the Property object to be attached.</param>
      <throws>UnsupportedOperationException if <tt>this==DEFAULT && property!=this.property()</tt> - The DEFAULT Algebra object is immutable.</throws>
      <throws>UnsupportedOperationException if <tt>this==ZERO && property!=this.property()</tt> - The ZERO Algebra object is immutable.</throws>
      <see>#property</see>
    </javadoc>
    <method type="void" name="setProperty" startLine="482" endLine="486" />
    <javadoc>
      <text>* Solves A*X = B.</text>
      <return>X; a new independent matrix; solution if A is square, least squares solution otherwise.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="solve" startLine="491" endLine="493" />
    <javadoc>
      <text>* Solves X*A = B, which is also A'*X' = B'.</text>
      <return>X; a new independent matrix; solution if A is square, least squares solution otherwise.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="solveTranspose" startLine="498" endLine="500" />
    <javadoc>
      <text>* Copies the columns of the indicated rows into a new sub matrix.
 * <tt>sub[0..rowIndexes.length-1,0..columnTo-columnFrom] = A[rowIndexes(:),columnFrom..columnTo]</tt>;
 * The returned matrix is <i>not backed</i> by this matrix, so changes in the returned matrix are <i>not reflected</i> in this matrix, and vice-versa.</text>
      <param>A   the source matrix to copy from.</param>
      <param>rowIndexes the indexes of the rows to copy. May be unsorted.</param>
      <param>columnFrom the index of the first column to copy (inclusive).</param>
      <param>columnTo the index of the last column to copy (inclusive).</param>
      <return>a new sub matrix; with <tt>sub.rows()==rowIndexes.length; sub.columns()==columnTo-columnFrom+1</tt>.</return>
      <throws>IndexOutOfBoundsException if <tt>columnFrom<0 || columnTo-columnFrom+1<0 || columnTo+1>matrix.columns() || for any row=rowIndexes[i]: row < 0 || row >= matrix.rows()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="subMatrix" startLine="513" endLine="526">
      <declaration type="int" name="width" />
      <declaration type="int" name="rows" />
      <declaration type="DoubleMatrix2D" name="sub" />
      <scope startLine="519" endLine="524">
        <declaration type="int" name="row" />
      </scope>
    </method>
    <javadoc>
      <text>* Copies the rows of the indicated columns into a new sub matrix.
 * <tt>sub[0..rowTo-rowFrom,0..columnIndexes.length-1] = A[rowFrom..rowTo,columnIndexes(:)]</tt>;
 * The returned matrix is <i>not backed</i> by this matrix, so changes in the returned matrix are <i>not reflected</i> in this matrix, and vice-versa.</text>
      <param>A   the source matrix to copy from.</param>
      <param>rowFrom the index of the first row to copy (inclusive).</param>
      <param>rowTo the index of the last row to copy (inclusive).</param>
      <param>columnIndexes the indexes of the columns to copy. May be unsorted.</param>
      <return>a new sub matrix; with <tt>sub.rows()==rowTo-rowFrom+1; sub.columns()==columnIndexes.length</tt>.</return>
      <throws>IndexOutOfBoundsException if <tt>rowFrom<0 || rowTo-rowFrom+1<0 || rowTo+1>matrix.rows() || for any col=columnIndexes[i]: col < 0 || col >= matrix.columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="subMatrix" startLine="539" endLine="553">
      <declaration type="int" name="height" />
      <declaration type="int" name="columns" />
      <declaration type="DoubleMatrix2D" name="sub" />
      <scope startLine="546" endLine="551">
        <declaration type="int" name="column" />
      </scope>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>sub-range view</i> which is the sub matrix <tt>A[fromRow..toRow,fromColumn..toColumn]</tt>.
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
 * Use idioms like <tt>result = subMatrix(...).copy()</tt> to generate an independent sub matrix.</text>
      <param>A the source matrix.</param>
      <param>fromRow   The index of the first row (inclusive).</param>
      <param>toRow   The index of the last row (inclusive).</param>
      <param>fromColumn   The index of the first column (inclusive).</param>
      <param>toColumn   The index of the last column (inclusive).</param>
      <return>a new sub-range view.</return>
      <throws>IndexOutOfBoundsException if <tt>fromColumn<0 || toColumn-fromColumn+1<0 || toColumn>=A.columns() || fromRow<0 || toRow-fromRow+1<0 || toRow>=A.rows()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="subMatrix" startLine="567" endLine="569" />
    <javadoc>
      <text>* Constructs and returns the SingularValue-decomposition of the given matrix.</text>
    </javadoc>
    <method type="SingularValueDecomposition" name="svd" startLine="573" endLine="575" />
    <javadoc>
      <text>* Returns a String with (propertyName, propertyValue) pairs.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * <pre>
 * cond          : 14.073264490042144
 * det           : Illegal operation or error: Matrix must be square.
 * norm1         : 0.9620244354009628
 * norm2         : 3.0
 * normF         : 1.304841791648992
 * normInfinity  : 1.5406551198102534
 * rank          : 3
 * trace         : 0
 * </pre></text>
    </javadoc>
    <method type="String" name="toString" startLine="591" endLine="665">
      <declaration type="cern.colt.list.ObjectArrayList" name="names" />
      <declaration type="cern.colt.list.ObjectArrayList" name="values" />
      <declaration type="String" name="unknown" />
      <scope startLine="598" endLine="598" />
      <scope startLine="599" endLine="599" />
      <scope startLine="602" endLine="602" />
      <scope startLine="603" endLine="603" />
      <scope startLine="606" endLine="606" />
      <scope startLine="607" endLine="607" />
      <scope startLine="610" endLine="610" />
      <scope startLine="611" endLine="611" />
      <scope startLine="614" endLine="614" />
      <scope startLine="615" endLine="615" />
      <scope startLine="618" endLine="618" />
      <scope startLine="619" endLine="619" />
      <scope startLine="622" endLine="622" />
      <scope startLine="623" endLine="623" />
      <scope startLine="626" endLine="626" />
      <scope startLine="627" endLine="627" />
      <declaration type="cern.colt.function.IntComparator" name="comp" />
      <method type="int" name="compare" startLine="632" endLine="634" />
      <declaration type="cern.colt.Swapper" name="swapper" />
      <method type="void" name="swap" startLine="637" endLine="641">
        <declaration type="Object" name="tmp" />
      </method>
      <declaration type="int" name="maxLength" />
      <scope startLine="647" endLine="650">
        <declaration type="int" name="length" />
      </scope>
      <declaration type="StringBuffer" name="buf" />
      <scope startLine="654" endLine="662">
        <declaration type="String" name="name" />
      </scope>
      <comment>determine properties</comment>
      <comment>sort ascending by property name</comment>
      <comment>determine padding for nice formatting</comment>
      <comment>finally, format properties</comment>
    </method>
    <javadoc>
      <text>* Returns the results of <tt>toString(A)</tt> and additionally the results of all sorts of decompositions applied to the given matrix.
 * Useful for debugging or to quickly get the rough picture.
 * For example,
 * <pre>
 * A = 3 x 3 matrix
 * 249  66  68
 * 104 214 108
 * 144 146 293
 * cond         : 3.931600417472078
 * det          : 9638870.0
 * norm1        : 497.0
 * norm2        : 473.34508217011404
 * normF        : 516.873292016525
 * normInfinity : 583.0
 * rank         : 3
 * trace        : 756.0
 * density                      : 1.0
 * isDiagonal                   : false
 * isDiagonallyDominantByColumn : true
 * isDiagonallyDominantByRow    : true
 * isIdentity                   : false
 * isLowerBidiagonal            : false
 * isLowerTriangular            : false
 * isNonNegative                : true
 * isOrthogonal                 : false
 * isPositive                   : true
 * isSingular                   : false
 * isSkewSymmetric              : false
 * isSquare                     : true
 * isStrictlyLowerTriangular    : false
 * isStrictlyTriangular         : false
 * isStrictlyUpperTriangular    : false
 * isSymmetric                  : false
 * isTriangular                 : false
 * isTridiagonal                : false
 * isUnitTriangular             : false
 * isUpperBidiagonal            : false
 * isUpperTriangular            : false
 * isZero                       : false
 * lowerBandwidth               : 2
 * semiBandwidth                : 3
 * upperBandwidth               : 2
 * -----------------------------------------------------------------------------
 * LUDecompositionQuick(A) --> isNonSingular(A), det(A), pivot, L, U, inverse(A)
 * -----------------------------------------------------------------------------
 * isNonSingular = true
 * det = 9638870.0
 * pivot = [0, 1, 2]
 * L = 3 x 3 matrix
 * 1        0       0
 * 0.417671 1       0
 * 0.578313 0.57839 1
 * U = 3 x 3 matrix
 * 249  66         68       
 * 0 186.433735  79.598394
 * 0   0        207.635819
 * inverse(A) = 3 x 3 matrix
 * 0.004869 -0.000976 -0.00077 
 * -0.001548  0.006553 -0.002056
 * -0.001622 -0.002786  0.004816
 * -----------------------------------------------------------------
 * QRDecomposition(A) --> hasFullRank(A), H, Q, R, pseudo inverse(A)
 * -----------------------------------------------------------------
 * hasFullRank = true
 * H = 3 x 3 matrix
 * 1.814086 0        0
 * 0.34002  1.903675 0
 * 0.470797 0.428218 2
 * Q = 3 x 3 matrix
 * -0.814086  0.508871  0.279845
 * -0.34002  -0.808296  0.48067 
 * -0.470797 -0.296154 -0.831049
 * R = 3 x 3 matrix
 * -305.864349 -195.230337 -230.023539
 * 0        -182.628353  467.703164
 * 0           0        -309.13388 
 * pseudo inverse(A) = 3 x 3 matrix
 * 0.006601  0.001998 -0.005912
 * -0.005105  0.000444  0.008506
 * -0.000905 -0.001555  0.002688
 * --------------------------------------------------------------------------
 * CholeskyDecomposition(A) --> isSymmetricPositiveDefinite(A), L, inverse(A)
 * --------------------------------------------------------------------------
 * isSymmetricPositiveDefinite = false
 * L = 3 x 3 matrix
 * 15.779734  0         0       
 * 6.590732 13.059948  0       
 * 9.125629  6.573948 12.903724
 * inverse(A) = Illegal operation or error: Matrix is not symmetric positive definite.
 * ---------------------------------------------------------------------
 * EigenvalueDecomposition(A) --> D, V, realEigenvalues, imagEigenvalues
 * ---------------------------------------------------------------------
 * realEigenvalues = 1 x 3 matrix
 * 462.796507 172.382058 120.821435
 * imagEigenvalues = 1 x 3 matrix
 * 0 0 0
 * D = 3 x 3 matrix
 * 462.796507   0          0       
 * 0        172.382058   0       
 * 0          0        120.821435
 * V = 3 x 3 matrix
 * -0.398877 -0.778282  0.094294
 * -0.500327  0.217793 -0.806319
 * -0.768485  0.66553   0.604862
 * ---------------------------------------------------------------------
 * SingularValueDecomposition(A) --> cond(A), rank(A), norm2(A), U, S, V
 * ---------------------------------------------------------------------
 * cond = 3.931600417472078
 * rank = 3
 * norm2 = 473.34508217011404
 * U = 3 x 3 matrix
 * 0.46657  -0.877519  0.110777
 * 0.50486   0.161382 -0.847982
 * 0.726243  0.45157   0.51832 
 * S = 3 x 3 matrix
 * 473.345082   0          0       
 * 0        169.137441   0       
 * 0          0        120.395013
 * V = 3 x 3 matrix
 * 0.577296 -0.808174  0.116546
 * 0.517308  0.251562 -0.817991
 * 0.631761  0.532513  0.563301
 * </pre></text>
    </javadoc>
    <method type="String" name="toVerboseString" startLine="812" endLine="868">
      <declaration type="String" name="constructionException" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="LUDecomposition" name="lu" />
      <scope startLine="833" endLine="833" />
      <scope startLine="834" endLine="836" />
      <declaration type="QRDecomposition" name="qr" />
      <scope startLine="840" endLine="840" />
      <scope startLine="841" endLine="843" />
      <declaration type="CholeskyDecomposition" name="chol" />
      <scope startLine="847" endLine="847" />
      <scope startLine="848" endLine="850" />
      <declaration type="EigenvalueDecomposition" name="eig" />
      <scope startLine="854" endLine="854" />
      <scope startLine="855" endLine="857" />
      <declaration type="SingularValueDecomposition" name="svd" />
      <scope startLine="861" endLine="861" />
      <scope startLine="862" endLine="864" />
      <comment>StringBuffer buf = new StringBuffer();
String unknown = "Illegal operation or error: ";
String constructionException = "Illegal operation or error upon construction: ";

buf.append("------------------------------------------------------------------\n");
buf.append("LUDecomposition(A) --> isNonSingular, det, pivot, L, U, inverse(A)\n");
buf.append("------------------------------------------------------------------\n");</comment>
    </method>
    <javadoc>
      <text>* Returns the sum of the diagonal elements of matrix <tt>A</tt>; <tt>Sum(A[i,i])</tt>.</text>
    </javadoc>
    <method type="double" name="trace" startLine="872" endLine="878">
      <declaration type="double" name="sum" />
      <scope startLine="874" endLine="876" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new view which is the transposition of the given matrix <tt>A</tt>.
 * Equivalent to {@link DoubleMatrix2D#viewDice A.viewDice()}.
 * This is a zero-copy transposition, taking O(1), i.e. constant time.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
 * Use idioms like <tt>result = transpose(A).copy()</tt> to generate an independent matrix.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>transpose ==></td>
 * <td valign="top">3 x 2 matrix:<br>
 * 1, 4 <br>
 * 2, 5 <br>
 * 3, 6</td>
 * <td>transpose ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new transposed view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="transpose" startLine="905" endLine="907" />
    <javadoc>
      <text>* Modifies the matrix to be a lower trapezoidal matrix.</text>
      <return><tt>A</tt> (for convenience only).</return>
      <see>#triangulateLower(DoubleMatrix2D)</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="trapezoidalLower" startLine="913" endLine="922">
      <declaration type="int" name="rows" />
      <declaration type="int" name="columns" />
      <scope startLine="916" endLine="920">
        <scope startLine="917" endLine="919" />
      </scope>
    </method>
    <javadoc>
      <text>* Outer product of two vectors; Returns a matrix with <tt>A[i,j] = x[i] * y[j]</tt>.</text>
      <param>x the first source vector.</param>
      <param>y the second source vector.</param>
      <return>the outer product </tt>A</tt>.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="xmultOuter" startLine="930" endLine="934">
      <declaration type="DoubleMatrix2D" name="A" />
    </method>
    <javadoc>
      <text>* Linear algebraic matrix power; <tt>B = A<sup>k</sup> <==> B = A*A*...*A</tt>.</text>
      <param>A the source matrix; must be square.</param>
      <param>k the exponent, can be any number.</param>
      <return>a new result matrix.</return>
      <throws>IllegalArgumentException if <tt>!Testing.isSquare(A)</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="xpowSlow" startLine="943" endLine="951">
      <declaration type="DoubleMatrix2D" name="result" />
      <scope startLine="946" endLine="948" />
      <comment>cern.colt.Timer timer = new cern.colt.Timer().start();</comment>
      <comment>timer.stop().display();</comment>
    </method>
  </class>
</source>
