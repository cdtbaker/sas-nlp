<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix">
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <import name="cern.colt.matrix.impl.AbstractMatrix2D" />
  <import name="cern.colt.matrix.impl.DenseDoubleMatrix1D" />
  <import name="cern.colt.matrix.impl.DenseDoubleMatrix2D" />
  <class name="DoubleMatrix2D" extends="AbstractMatrix2D" startLine="16">
    <javadoc>
      <text>* Abstract base class for 2-d matrices holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * A matrix has a number of rows and columns, which are assigned upon instance construction - The matrix's size is then <tt>rows()*columns()</tt>.
 * Elements are accessed via <tt>[row,column]</tt> coordinates.
 * Legal coordinates range from <tt>[0,0]</tt> to <tt>[rows()-1,columns()-1]</tt>.
 * Any attempt to access an element at a coordinate <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt> will throw an <tt>IndexOutOfBoundsException</tt>.
 * <p>
 * <b>Note</b> that this implementation is not synchronized.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="DoubleMatrix2D" startLine="34" endLine="34" />
    <javadoc>
      <text>* Applies a function to each cell and aggregates the results.
 * Returns a value <tt>v</tt> such that <tt>v==a(size())</tt> where <tt>a(i) == aggr( a(i-1), f(get(row,column)) )</tt> and terminators are <tt>a(1) == f(get(0,0)), a(0)==Double.NaN</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
 * 2 x 2 matrix
 * 0 1
 * 2 3
 * // Sum( x[row,col]*x[row,col] ) 
 * matrix.aggregate(F.plus,F.square);
 * --> 14
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value.</param>
      <param>f a function transforming the current cell value.</param>
      <return>the aggregated measure.</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="double" name="aggregate" startLine="57" endLine="68">
      <declaration type="double" name="a" />
      <declaration type="int" name="d" />
      <scope startLine="61" endLine="66">
        <scope startLine="62" endLine="64" />
      </scope>
      <comment>last cell already done</comment>
    </method>
    <javadoc>
      <text>* Applies a function to each corresponding cell of two matrices and aggregates the results.
 * Returns a value <tt>v</tt> such that <tt>v==a(size())</tt> where <tt>a(i) == aggr( a(i-1), f(get(row,column),other.get(row,column)) )</tt> and terminators are <tt>a(1) == f(get(0,0),other.get(0,0)), a(0)==Double.NaN</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
 * x == 2 x 2 matrix
 * 0 1
 * 2 3
 * y == 2 x 2 matrix
 * 0 1
 * 2 3
 * // Sum( x[row,col] * y[row,col] ) 
 * x.aggregate(y, F.plus, F.mult);
 * --> 14
 * // Sum( (x[row,col] + y[row,col])^2 )
 * x.aggregate(y, F.plus, F.chain(F.square,F.plus));
 * --> 56
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values.</param>
      <param>f a function transforming the current cell values.</param>
      <return>the aggregated measure.</return>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt></throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="double" name="aggregate" startLine="100" endLine="112">
      <declaration type="double" name="a" />
      <declaration type="int" name="d" />
      <scope startLine="105" endLine="110">
        <scope startLine="106" endLine="108" />
      </scope>
      <comment>last cell already done</comment>
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>values</tt>.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of rows and columns as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values the values to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="124" endLine="134">
      <scope startLine="126" endLine="132">
        <declaration type="double[]" name="currentRow" />
        <scope startLine="129" endLine="131" />
      </scope>
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="140" endLine="151">
      <declaration type="int" name="r" />
      <declaration type="int" name="c" />
      <scope startLine="145" endLine="149">
        <scope startLine="146" endLine="148" />
      </scope>
      <comment>for (int row=rows; --row >= 0;) {</comment>
      <comment>for (int column=columns; --column >= 0;) {</comment>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[row,col] = function(x[row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * matrix = 2 x 2 matrix 
 * 0.5 1.5      
 * 2.5 3.5
 * // change each cell to its sine
 * matrix.assign(cern.jet.math.Functions.sin);
 * -->
 * 2 x 2 matrix
 * 0.479426  0.997495 
 * 0.598472 -0.350783
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>function a function object taking as argument the current cell's value.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="174" endLine="181">
      <scope startLine="175" endLine="179">
        <scope startLine="176" endLine="178" />
      </scope>
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>other   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="191" endLine="204">
      <scope startLine="198" endLine="202">
        <scope startLine="199" endLine="201" />
      </scope>
      <comment>for (int row=0; row<rows; row++) {</comment>
      <comment>for (int column=0; column<columns; column++) {</comment>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[row,col] = function(x[row,col],y[row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * // assign x[row,col] = x[row,col]<sup>y[row,col]</sup>
 * m1 = 2 x 2 matrix 
 * 0 1 
 * 2 3
 * m2 = 2 x 2 matrix 
 * 0 2 
 * 4 6
 * m1.assign(m2, cern.jet.math.Functions.pow);
 * -->
 * m1 == 2 x 2 matrix
 * 1   1 
 * 16 729
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>y the secondary matrix to operate on.</param>
      <param>function a function object taking as first argument the current cell's value of <tt>this</tt>,
 * and as second argument the current cell's value of <tt>y</tt>,</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt></throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="234" endLine="242">
      <scope startLine="236" endLine="240">
        <scope startLine="237" endLine="239" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the number of cells having non-zero values; ignores tolerance.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="246" endLine="254">
      <declaration type="int" name="cardinality" />
      <scope startLine="248" endLine="252">
        <scope startLine="249" endLine="251" />
      </scope>
    </method>
    <javadoc>
      <text>* Constructs and returns a deep copy of the receiver.
 * <p>
 * <b>Note that the returned matrix is an independent deep copy.</b>
 * The returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="copy" startLine="263" endLine="265" />
    <javadoc>
      <text>* Returns whether all cells are equal to the given value.</text>
      <param>value the value to test against.</param>
      <return><tt>true</tt> if all cells are equal to the given value, <tt>false</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="272" endLine="274" />
    <javadoc>
      <text>* Compares this object against the specified object.
 * The result is <code>true</code> if and only if the argument is 
 * not <code>null</code> and is at least a <code>DoubleMatrix2D</code> object
 * that has the same number of columns and rows as the receiver and 
 * has exactly the same values at the same coordinates.</text>
      <param>obj   the object to compare with.</param>
      <return><code>true</code> if the objects are the same;
 * <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="285" endLine="291" />
    <javadoc>
      <text>* Assigns the result of a function to each <i>non-zero</i> cell; <tt>x[row,col] = function(x[row,col])</tt>.
 * Use this method for fast special-purpose iteration.
 * If you want to modify another matrix instead of <tt>this</tt> (i.e. work in read-only mode), simply return the input value unchanged.
 * Parameters to function are as follows: <tt>first==row</tt>, <tt>second==column</tt>, <tt>third==nonZeroValue</tt>.</text>
      <param>function a function object taking as argument the current non-zero cell's row, column and value.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="forEachNonZero" startLine="302" endLine="313">
      <scope startLine="303" endLine="311">
        <scope startLine="304" endLine="310">
          <declaration type="double" name="value" />
          <scope startLine="306" endLine="309">
            <declaration type="double" name="r" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value of the specified cell.</return>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt></throws>
    </javadoc>
    <method type="double" name="get" startLine="322" endLine="325" />
    <javadoc>
      <text>* Returns the content of this matrix if it is a wrapper; or <tt>this</tt> otherwise.
 * Override this method in wrappers.</text>
    </javadoc>
    <method type="DoubleMatrix2D" name="getContent" startLine="330" endLine="332" />
    <javadoc>
      <text>* Fills the coordinates and values of cells having non-zero values into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists all have a new size, the number of non-zero values.
 * <p>
 * In general, fill order is <i>unspecified</i>.
 * This implementation fills like <tt>for (row = 0..rows-1) for (column = 0..columns-1) do ... </tt>.
 * However, subclasses are free to us any other order, even an order that may change over time as cell values are changed.
 * (Of course, result lists indexes are guaranteed to correspond to the same cell).
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * 2 x 3 matrix:
 * 0, 0, 8
 * 0, 7, 0
 * -->
 * rowList    = (0,1)
 * columnList = (2,1)
 * valueList  = (8,7)
 * </pre>
 * In other words, <tt>get(0,2)==8, get(1,1)==7</tt>.</text>
      <param>rowList the list to be filled with row indexes, can have any size.</param>
      <param>columnList the list to be filled with column indexes, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="getNonZeros" startLine="360" endLine="376">
      <declaration type="int" name="r" />
      <declaration type="int" name="c" />
      <scope startLine="366" endLine="375">
        <scope startLine="367" endLine="374">
          <declaration type="double" name="value" />
          <scope startLine="369" endLine="373" />
        </scope>
      </scope>
    </method>
    <method name="getQuick" type="double" startLine="377" endLine="388" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCells" startLine="392" endLine="396" />
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="400" endLine="402" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the same number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like" startLine="411" endLine="413" />
    <method name="like" type="DoubleMatrix2D" startLine="414" endLine="424" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method name="like1D" type="DoubleMatrix1D" startLine="425" endLine="433" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method name="like1D" type="DoubleMatrix1D" startLine="434" endLine="444" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <param>zero the index of the first element.</param>
      <param>stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
      <throws>IndexOutOfBoundsException if <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt></throws>
    </javadoc>
    <method type="void" name="set" startLine="453" endLine="456" />
    <method name="setQuick" type="void" startLine="457" endLine="468" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <javadoc>
      <text>* Constructs and returns a 2-dimensional array containing the cell values.
 * The returned array <tt>values</tt> has the form <tt>values[row][column]</tt>
 * and has the same number of rows and columns as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <return>an array filled with the values of the cells.</return>
    </javadoc>
    <method type="double[][]" name="toArray" startLine="478" endLine="487">
      <declaration type="double[][]" name="values" />
      <scope startLine="480" endLine="485">
        <declaration type="double[]" name="currentRow" />
        <scope startLine="482" endLine="484" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a string representation using default formatting.</text>
      <see>cern.colt.matrix.doublealgo.Formatter</see>
    </javadoc>
    <method type="String" name="toString" startLine="492" endLine="494" />
    <javadoc>
      <text>* Constructs and returns a new view equal to the receiver.
 * The view is a shallow clone. Calls <code>clone()</code> and casts the result.
 * <p>
 * <b>Note that the view is not a deep copy.</b>
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
 * <p>
 * Use {@link #copy()} to construct an independent deep copy rather than a new view.</text>
      <return>a new view of the receiver.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="view" startLine="506" endLine="508" />
    <javadoc>
      <text>* Constructs and returns a new <i>slice view</i> representing the rows of the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>viewPart(...)</tt>), then apply this method to the sub-range view.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>viewColumn(0) ==></td>
 * <td valign="top">Matrix1D of size 2:<br>
 * 1, 4</td>
 * </tr>
 * </table></text>
      <param>column the column to fix.</param>
      <return>a new slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.</throws>
      <see>#viewRow(int)</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewColumn" startLine="531" endLine="537">
      <declaration type="int" name="viewSize" />
      <declaration type="int" name="viewZero" />
      <declaration type="int" name="viewStride" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the column axis.
 * What used to be column <tt>0</tt> is now column <tt>columns()-1</tt>, ..., what used to be column <tt>columns()-1</tt> is now column <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>columnFlip ==></td>
 * <td valign="top">2 x 3 matrix:<br>
 * 3, 2, 1 <br>
 * 6, 5, 4</td>
 * <td>columnFlip ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new flip view.</return>
      <see>#viewRowFlip()</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewColumnFlip" startLine="563" endLine="565" />
    <javadoc>
      <text>* Constructs and returns a new <i>dice (transposition) view</i>; Swaps axes; example: 3 x 4 matrix --> 4 x 3 matrix.
 * The view has both dimensions exchanged; what used to be columns become rows, what used to be rows become columns.
 * In other words: <tt>view.get(row,column)==this.get(column,row)</tt>.
 * This is a zero-copy transposition, taking O(1), i.e. constant time.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
 * Use idioms like <tt>result = viewDice(A).copy()</tt> to generate an independent transposed matrix.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>transpose ==></td>
 * <td valign="top">3 x 2 matrix:<br>
 * 1, 4 <br>
 * 2, 5 <br>
 * 3, 6</td>
 * <td>transpose ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new dice view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewDice" startLine="594" endLine="596" />
    <javadoc>
      <text>* Constructs and returns a new <i>sub-range view</i> that is a <tt>height x width</tt> sub matrix starting at <tt>[row,column]</tt>.
 * Operations on the returned view can only be applied to the restricted range.
 * Any attempt to access coordinates not contained in the view will throw an <tt>IndexOutOfBoundsException</tt>.
 * <p>
 * <b>Note that the view is really just a range restriction:</b> 
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
 * <p>
 * The view contains the cells from <tt>[row,column]</tt> to <tt>[row+height-1,column+width-1]</tt>, all inclusive.
 * and has <tt>view.rows() == height; view.columns() == width;</tt>.
 * A view's legal coordinates are again zero based, as usual.
 * In other words, legal coordinates of the view range from <tt>[0,0]</tt> to <tt>[view.rows()-1==height-1,view.columns()-1==width-1]</tt>.
 * As usual, any attempt to access a cell at a coordinate <tt>column&lt;0 || column&gt;=view.columns() || row&lt;0 || row&gt;=view.rows()</tt> will throw an <tt>IndexOutOfBoundsException</tt>.</text>
      <param>row   The index of the row-coordinate.</param>
      <param>column   The index of the column-coordinate.</param>
      <param>height   The height of the box.</param>
      <param>width   The width of the box.</param>
      <throws>IndexOutOfBoundsException if <tt>column<0 || width<0 || column+width>columns() || row<0 || height<0 || row+height>rows()</tt></throws>
      <return>the new view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewPart" startLine="620" endLine="622" />
    <javadoc>
      <text>* Constructs and returns a new <i>slice view</i> representing the columns of the given row.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>viewPart(...)</tt>), then apply this method to the sub-range view.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>viewRow(0) ==></td>
 * <td valign="top">Matrix1D of size 3:<br>
 * 1, 2, 3</td>
 * </tr>
 * </table></text>
      <param>row the row to fix.</param>
      <return>a new slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= rows()</tt>.</throws>
      <see>#viewColumn(int)</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewRow" startLine="645" endLine="651">
      <declaration type="int" name="viewSize" />
      <declaration type="int" name="viewZero" />
      <declaration type="int" name="viewStride" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the row axis.
 * What used to be row <tt>0</tt> is now row <tt>rows()-1</tt>, ..., what used to be row <tt>rows()-1</tt> is now row <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>rowFlip ==></td>
 * <td valign="top">2 x 3 matrix:<br>
 * 4, 5, 6 <br>
 * 1, 2, 3</td>
 * <td>rowFlip ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new flip view.</return>
      <see>#viewColumnFlip()</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewRowFlip" startLine="677" endLine="679" />
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding the indicated cells.
 * There holds <tt>view.rows() == rowIndexes.length, view.columns() == columnIndexes.length</tt> and <tt>view.get(i,j) == this.get(rowIndexes[i],columnIndexes[j])</tt>.
 * Indexes can occur multiple times and can be in arbitrary order.
 * <p>
 * <b>Example:</b>
 * <pre>
 * this = 2 x 3 matrix:
 * 1, 2, 3
 * 4, 5, 6
 * rowIndexes     = (0,1)
 * columnIndexes  = (1,0,1,0)
 * -->
 * view = 2 x 4 matrix:
 * 2, 1, 2, 1
 * 5, 4, 5, 4
 * </pre>
 * Note that modifying the index arguments after this call has returned has no effect on the view.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
 * <p>
 * To indicate "all" rows or "all columns", simply set the respective parameter</text>
      <param>rowIndexes   The rows of the cells that shall be visible in the new view. To indicate that <i>all</i> rows shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <param>columnIndexes   The columns of the cells that shall be visible in the new view. To indicate that <i>all</i> columns shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <return>the new view.</return>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= rowIndexes[i] < rows())</tt> for any <tt>i=0..rowIndexes.length()-1</tt>.</throws>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= columnIndexes[i] < columns())</tt> for any <tt>i=0..columnIndexes.length()-1</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSelection" startLine="707" endLine="729">
      <scope startLine="709" endLine="712" />
      <scope startLine="713" endLine="716" />
      <declaration type="int[]" name="rowOffsets" />
      <declaration type="int[]" name="columnOffsets" />
      <scope startLine="722" endLine="724" />
      <scope startLine="725" endLine="727" />
      <comment>check for "all"</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding all <b>rows</b> matching the given condition.
 * Applies the condition to each row and takes only those row where <tt>condition.apply(viewRow(i))</tt> yields <tt>true</tt>.
 * To match columns, use a dice view.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * // extract and view all rows which have a value < threshold in the first column (representing "age")
 * final double threshold = 16;
 * matrix.viewSelection( 
 * &nbsp;&nbsp;&nbsp;new DoubleMatrix1DProcedure() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(DoubleMatrix1D m) { return m.get(0) < threshold; }
 * &nbsp;&nbsp;&nbsp;}
 * );
 * // extract and view all rows with RMS < threshold
 * // The RMS (Root-Mean-Square) is a measure of the average "size" of the elements of a data sequence.
 * matrix = 0 1 2 3
 * final double threshold = 0.5;
 * matrix.viewSelection( 
 * &nbsp;&nbsp;&nbsp;new DoubleMatrix1DProcedure() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(DoubleMatrix1D m) { return Math.sqrt(m.aggregate(F.plus,F.square) / m.size()) < threshold; }
 * &nbsp;&nbsp;&nbsp;}
 * );
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>condition The condition to be matched.</param>
      <return>the new view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSelection" startLine="762" endLine="770">
      <declaration type="IntArrayList" name="matches" />
      <scope startLine="764" endLine="766" />
      <comment>take all columns</comment>
    </method>
    <method name="viewSelectionLike" type="DoubleMatrix2D" startLine="771" endLine="778" />
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <javadoc>
      <text>* Sorts the matrix rows into ascending order, according to the <i>natural ordering</i> of the matrix values in the given column.
 * This sort is guaranteed to be <i>stable</i>.
 * For further information, see {@link cern.colt.matrix.doublealgo.Sorting#sort(DoubleMatrix2D,int)}.
 * For more advanced sorting functionality, see {@link cern.colt.matrix.doublealgo.Sorting}.</text>
      <return>a new sorted vector (matrix) view.</return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSorted" startLine="787" endLine="789" />
    <javadoc>
      <text>* Constructs and returns a new <i>stride view</i> which is a sub matrix consisting of every i-th cell.
 * More specifically, the view has <tt>this.rows()/rowStride</tt> rows and <tt>this.columns()/columnStride</tt> columns holding cells <tt>this.get(i*rowStride,j*columnStride)</tt> for all <tt>i = 0..rows()/rowStride - 1, j = 0..columns()/columnStride - 1</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>rowStride the row step factor.</param>
      <param>columnStride the column step factor.</param>
      <return>a new view.</return>
      <throws>IndexOutOfBoundsException if <tt>rowStride<=0 || columnStride<=0</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewStrides" startLine="800" endLine="802" />
    <javadoc>
      <text>* Applies a procedure to each cell's value.
 * Iterates downwards from <tt>[rows()-1,columns()-1]</tt> to <tt>[0,0]</tt>,
 * as demonstrated by this snippet:
 * <pre>
 * for (int row=rows; --row >=0;) {
 * for (int column=columns; --column >= 0;) {
 * if (!procedure.apply(getQuick(row,column))) return false;
 * }
 * }
 * return true;
 * </pre>
 * Note that an implementation may use more efficient techniques, but must not use any other order.</text>
      <param>procedure a procedure object taking as argument the current cell's value. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="xforEach" startLine="820" endLine="827">
      <scope startLine="821" endLine="825">
        <scope startLine="822" endLine="824" />
      </scope>
    </method>
    <javadoc>
      <text>* 8 neighbor stencil transformation. For efficient finite difference operations.
 * Applies a function to a moving <tt>3 x 3</tt> window.
 * Does nothing if <tt>rows() < 3 || columns() < 3</tt>.
 * <pre>
 * B[i,j] = function.apply(
 * &nbsp;&nbsp;&nbsp;A[i-1,j-1], A[i-1,j], A[i-1,j+1],
 * &nbsp;&nbsp;&nbsp;A[i,  j-1], A[i,  j], A[i,  j+1],
 * &nbsp;&nbsp;&nbsp;A[i+1,j-1], A[i+1,j], A[i+1,j+1]
 * &nbsp;&nbsp;&nbsp;)
 * x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - 
 * x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - 
 * x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x 
 * - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x 
 * - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x 
 * </pre>
 * Make sure that cells of <tt>this</tt> and <tt>B</tt> do not overlap.
 * In case of overlapping views, behaviour is unspecified.
 * </pre>
 * <p>
 * <b>Example:</b>
 * <pre>
 * final double alpha = 0.25;
 * final double beta = 0.75;
 * // 8 neighbors
 * cern.colt.function.Double9Function f = new cern.colt.function.Double9Function() {
 * &nbsp;&nbsp;&nbsp;public final double apply(
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return beta*a11 + alpha*(a00+a01+a02 + a10+a12 + a20+a21+a22);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 * };
 * A.zAssign8Neighbors(B,f);
 * // 4 neighbors
 * cern.colt.function.Double9Function g = new cern.colt.function.Double9Function() {
 * &nbsp;&nbsp;&nbsp;public final double apply(
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return beta*a11 + alpha*(a01+a10+a12+a21);
 * &nbsp;&nbsp;&nbsp;}
 * C.zAssign8Neighbors(B,g); // fast, even though it doesn't look like it
 * };
 * </pre></text>
      <param>B the matrix to hold the results.</param>
      <param>function the function to be applied to the 9 cells.</param>
      <throws>NullPointerException if <tt>function==null</tt>.</throws>
      <throws>IllegalArgumentException if <tt>rows() != B.rows() || columns() != B.columns()</tt>.</throws>
    </javadoc>
    <method type="void" name="zAssign8Neighbors" startLine="882" endLine="917">
      <declaration type="int" name="r" />
      <declaration type="int" name="c" />
      <declaration type="double" name="a00" />
      <declaration type="double" name="a10" />
      <declaration type="double" name="a20" />
      <scope startLine="891" endLine="916">
        <scope startLine="896" endLine="915" />
        <comment>in each step six cells can be remembered in registers - they don't need to be reread from slow memory</comment>
        <comment>in each step 3 instead of 9 cells need to be read from memory.</comment>
      </scope>
      <comment>nothing to do</comment>
    </method>
    <javadoc>
      <text>* Linear algebraic matrix-vector multiplication; <tt>z = A * y</tt>; 
 * Equivalent to <tt>return A.zMult(y,z,1,0);</tt></text>
    </javadoc>
    <method type="DoubleMatrix1D" name="zMult" startLine="922" endLine="924" />
    <javadoc>
      <text>* Linear algebraic matrix-vector multiplication; <tt>z = alpha * A * y + beta*z</tt>.
 * <tt>z[i] = alpha*Sum(A[i,j] * y[j]) + beta*z[i], i=0..A.rows()-1, j=0..y.size()-1</tt>.
 * Where <tt>A == this</tt>.
 * <br>
 * Note: Matrix shape conformance is checked <i>after</i> potential transpositions.</text>
      <param>y the source vector.</param>
      <param>z the vector where results are to be stored. Set this parameter to <tt>null</tt> to indicate that a new result vector shall be constructed.</param>
      <return>z (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>A.columns() != y.size() || A.rows() > z.size())</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="zMult" startLine="938" endLine="953">
      <scope startLine="945" endLine="951">
        <declaration type="double" name="s" />
        <scope startLine="947" endLine="949" />
      </scope>
      <comment>boolean ignore = (z==null);</comment>
    </method>
    <javadoc>
      <text>* Linear algebraic matrix-matrix multiplication; <tt>C = A x B</tt>;
 * Equivalent to <tt>A.zMult(B,C,1,0,false,false)</tt>.</text>
    </javadoc>
    <method type="DoubleMatrix2D" name="zMult" startLine="958" endLine="960" />
    <javadoc>
      <text>* Linear algebraic matrix-matrix multiplication; <tt>C = alpha * A x B + beta*C</tt>.
 * <tt>C[i,j] = alpha*Sum(A[i,k] * B[k,j]) + beta*C[i,j], k=0..n-1</tt>.
 * <br>
 * Matrix shapes: <tt>A(m x n), B(n x p), C(m x p)</tt>.
 * <br>
 * Note: Matrix shape conformance is checked <i>after</i> potential transpositions.</text>
      <param>B the second source matrix.</param>
      <param>C the matrix where results are to be stored. Set this parameter to <tt>null</tt> to indicate that a new result matrix shall be constructed.</param>
      <return>C (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>B.rows() != A.columns()</tt>.</throws>
      <throws>IllegalArgumentException if <tt>C.rows() != A.rows() || C.columns() != B.columns()</tt>.</throws>
      <throws>IllegalArgumentException if <tt>A == C || B == C</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="zMult" startLine="977" endLine="1003">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="p" />
      <scope startLine="993" endLine="1001">
        <scope startLine="994" endLine="1000">
          <declaration type="double" name="s" />
          <scope startLine="996" endLine="998" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the sum of all cells; <tt>Sum( x[i,j] )</tt>.</text>
      <return>the sum.</return>
    </javadoc>
    <method type="double" name="zSum" startLine="1008" endLine="1011" />
  </class>
</source>
