<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix">
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <import name="cern.colt.matrix.impl.AbstractMatrix1D" />
  <class name="DoubleMatrix1D" extends="AbstractMatrix1D" startLine="14">
    <javadoc>
      <text>* Abstract base class for 1-d matrices (aka <i>vectors</i>) holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * A matrix has a number of cells (its <i>size</i>), which are assigned upon instance construction.
 * Elements are accessed via zero based indexes.
 * Legal indexes are of the form <tt>[0..size()-1]</tt>.
 * Any attempt to access an element at a coordinate <tt>index&lt;0 || index&gt;=size()</tt> will throw an <tt>IndexOutOfBoundsException</tt>.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="DoubleMatrix1D" startLine="30" endLine="30" />
    <javadoc>
      <text>* Applies a function to each cell and aggregates the results.
 * Returns a value <tt>v</tt> such that <tt>v==a(size())</tt> where <tt>a(i) == aggr( a(i-1), f(get(i)) )</tt> and terminators are <tt>a(1) == f(get(0)), a(0)==Double.NaN</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
 * matrix = 0 1 2 3 
 * // Sum( x[i]*x[i] ) 
 * matrix.aggregate(F.plus,F.square);
 * --> 14
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value.</param>
      <param>f a function transforming the current cell value.</param>
      <return>the aggregated measure.</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="double" name="aggregate" startLine="51" endLine="58">
      <declaration type="double" name="a" />
      <scope startLine="54" endLine="56" />
    </method>
    <javadoc>
      <text>* Applies a function to each corresponding cell of two matrices and aggregates the results.
 * Returns a value <tt>v</tt> such that <tt>v==a(size())</tt> where <tt>a(i) == aggr( a(i-1), f(get(i),other.get(i)) )</tt> and terminators are <tt>a(1) == f(get(0),other.get(0)), a(0)==Double.NaN</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
 * x = 0 1 2 3 
 * y = 0 1 2 3 
 * // Sum( x[i]*y[i] )
 * x.aggregate(y, F.plus, F.mult);
 * --> 14
 * // Sum( (x[i]+y[i])^2 )
 * x.aggregate(y, F.plus, F.chain(F.square,F.plus));
 * --> 56
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values.</param>
      <param>f a function transforming the current cell values.</param>
      <return>the aggregated measure.</return>
      <throws>IllegalArgumentException if <tt>size() != other.size()</tt>.</throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="double" name="aggregate" startLine="85" endLine="93">
      <declaration type="double" name="a" />
      <scope startLine="89" endLine="91" />
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>values</tt>.
 * <tt>values</tt> is required to have the same number of cells as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values the values to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>values.length != size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="104" endLine="110">
      <scope startLine="106" endLine="108" />
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="116" endLine="121">
      <scope startLine="117" endLine="119" />
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[i] = function(x[i])</tt>.
 * (Iterates downwards from <tt>[size()-1]</tt> to <tt>[0]</tt>).
 * <p>
 * <b>Example:</b>
 * <pre>
 * // change each cell to its sine
 * matrix =   0.5      1.5      2.5       3.5 
 * matrix.assign(cern.jet.math.Functions.sin);
 * -->
 * matrix ==  0.479426 0.997495 0.598472 -0.350783
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>function a function object taking as argument the current cell's value.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="140" endLine="145">
      <scope startLine="141" endLine="143" />
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same size.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>other   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>size() != other.size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="155" endLine="164">
      <scope startLine="160" endLine="162" />
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[i] = function(x[i],y[i])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * // assign x[i] = x[i]<sup>y[i]</sup>
 * m1 = 0 1 2 3;
 * m2 = 0 2 4 6;
 * m1.assign(m2, cern.jet.math.Functions.pow);
 * -->
 * m1 == 1 1 16 729
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>y the secondary matrix to operate on.</param>
      <param>function a function object taking as first argument the current cell's value of <tt>this</tt>,
 * and as second argument the current cell's value of <tt>y</tt>,</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>size() != y.size()</tt>.</throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="186" endLine="192">
      <scope startLine="188" endLine="190" />
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[i] = function(x[i],y[i])</tt>.
 * (Iterates downwards from <tt>[size()-1]</tt> to <tt>[0]</tt>).
 * <p>
 * <b>Example:</b>
 * <pre>
 * // assign x[i] = x[i]<sup>y[i]</sup>
 * m1 = 0 1 2 3;
 * m2 = 0 2 4 6;
 * m1.assign(m2, cern.jet.math.Functions.pow);
 * -->
 * m1 == 1 1 16 729
 * // for non-standard functions there is no shortcut: 
 * m1.assign(m2,
 * &nbsp;&nbsp;&nbsp;new DoubleDoubleFunction() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public double apply(double x, double y) { return Math.pow(x,y); }
 * &nbsp;&nbsp;&nbsp;}
 * );
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>y the secondary matrix to operate on.</param>
      <param>function a function object taking as first argument the current cell's value of <tt>this</tt>,
 * and as second argument the current cell's value of <tt>y</tt>,</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>size() != y.size()</tt>.</throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="222" endLine="264">
      <declaration type="int[]" name="nonZeroElements" />
      <scope startLine="227" endLine="235">
        <declaration type="int" name="j" />
        <scope startLine="229" endLine="234">
          <declaration type="int" name="i" />
        </scope>
        <comment>x[i] = x[i] * y[i]</comment>
        <comment>x[i] = 0 for all zeros</comment>
        <comment>x[i] * y[i] for all nonZeros</comment>
      </scope>
      <scope startLine="236" endLine="259">
        <declaration type="double" name="multiplicator" />
        <scope startLine="238" endLine="240" />
        <scope startLine="241" endLine="246">
          <scope startLine="242" endLine="245">
            <declaration type="int" name="i" />
          </scope>
        </scope>
        <scope startLine="247" endLine="252">
          <scope startLine="248" endLine="251">
            <declaration type="int" name="i" />
          </scope>
        </scope>
        <scope startLine="253" endLine="258">
          <scope startLine="254" endLine="257">
            <declaration type="int" name="i" />
          </scope>
        </scope>
        <comment>x[i] = x[i] + 0*y[i]</comment>
        <comment>x[i] = x[i] + y[i]</comment>
        <comment>x[i] = x[i] - y[i]</comment>
        <comment>the general case x[i] = x[i] + mult*y[i]</comment>
      </scope>
      <scope startLine="260" endLine="262">
        <comment>the general case x[i] = f(x[i],y[i])</comment>
      </scope>
      <comment>specialized for speed</comment>
    </method>
    <javadoc>
      <text>* Returns the number of cells having non-zero values; ignores tolerance.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="268" endLine="274">
      <declaration type="int" name="cardinality" />
      <scope startLine="270" endLine="272" />
    </method>
    <javadoc>
      <text>* Returns the number of cells having non-zero values, but at most maxCardinality; ignores tolerance.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="278" endLine="285">
      <declaration type="int" name="cardinality" />
      <declaration type="int" name="i" />
      <scope startLine="281" endLine="283" />
    </method>
    <javadoc>
      <text>* Constructs and returns a deep copy of the receiver.
 * <p>
 * <b>Note that the returned matrix is an independent deep copy.</b>
 * The returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="copy" startLine="294" endLine="298">
      <declaration type="DoubleMatrix1D" name="copy" />
    </method>
    <javadoc>
      <text>* Returns whether all cells are equal to the given value.</text>
      <param>value the value to test against.</param>
      <return><tt>true</tt> if all cells are equal to the given value, <tt>false</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="305" endLine="307" />
    <javadoc>
      <text>* Compares this object against the specified object.
 * The result is <code>true</code> if and only if the argument is 
 * not <code>null</code> and is at least a <code>DoubleMatrix1D</code> object
 * that has the same sizes as the receiver and 
 * has exactly the same values at the same indexes.</text>
      <param>obj   the object to compare with.</param>
      <return><code>true</code> if the objects are the same;
 * <code>false</code> otherwise.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="318" endLine="324" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>index</tt>.</text>
      <param>index   the index of the cell.</param>
      <return>the value of the specified cell.</return>
      <throws>IndexOutOfBoundsException if <tt>index&lt;0 || index&gt;=size()</tt>.</throws>
    </javadoc>
    <method type="double" name="get" startLine="332" endLine="335" />
    <javadoc>
      <text>* Returns the content of this matrix if it is a wrapper; or <tt>this</tt> otherwise.
 * Override this method in wrappers.</text>
    </javadoc>
    <method type="DoubleMatrix1D" name="getContent" startLine="340" endLine="342" />
    <javadoc>
      <text>* Fills the coordinates and values of cells having non-zero values into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists all have a new size, the number of non-zero values.
 * <p>
 * In general, fill order is <i>unspecified</i>.
 * This implementation fills like: <tt>for (index = 0..size()-1)  do ... </tt>.
 * However, subclasses are free to us any other order, even an order that may change over time as cell values are changed.
 * (Of course, result lists indexes are guaranteed to correspond to the same cell).
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * 0, 0, 8, 0, 7
 * -->
 * indexList  = (2,4)
 * valueList  = (8,7)
 * </pre>
 * In other words, <tt>get(2)==8, get(4)==7</tt>.</text>
      <param>indexList the list to be filled with indexes, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="getNonZeros" startLine="366" endLine="379">
      <declaration type="boolean" name="fillIndexList" />
      <declaration type="boolean" name="fillValueList" />
      <declaration type="int" name="s" />
      <scope startLine="372" endLine="378">
        <declaration type="double" name="value" />
        <scope startLine="374" endLine="377" />
      </scope>
    </method>
    <javadoc>
      <text>* Fills the coordinates and values of cells having non-zero values into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists all have a new size, the number of non-zero values.
 * <p>
 * In general, fill order is <i>unspecified</i>.
 * This implementation fills like: <tt>for (index = 0..size()-1)  do ... </tt>.
 * However, subclasses are free to us any other order, even an order that may change over time as cell values are changed.
 * (Of course, result lists indexes are guaranteed to correspond to the same cell).
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * 0, 0, 8, 0, 7
 * -->
 * indexList  = (2,4)
 * valueList  = (8,7)
 * </pre>
 * In other words, <tt>get(2)==8, get(4)==7</tt>.</text>
      <param>indexList the list to be filled with indexes, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="getNonZeros" startLine="403" endLine="421">
      <declaration type="boolean" name="fillIndexList" />
      <declaration type="boolean" name="fillValueList" />
      <declaration type="int" name="card" />
      <declaration type="int" name="s" />
      <scope startLine="414" endLine="420">
        <declaration type="double" name="value" />
        <scope startLine="416" endLine="419" />
      </scope>
    </method>
    <method name="getQuick" type="double" startLine="422" endLine="432" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>index</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>index&lt;0 || index&gt;=size()</tt>.</text>
      <param>index   the index of the cell.</param>
      <return>the value of the specified cell.</return>
    </javadoc>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCells" startLine="436" endLine="440" />
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="444" endLine="446" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the same size.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix1D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix1D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix1D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like" startLine="455" endLine="457" />
    <method name="like" type="DoubleMatrix1D" startLine="458" endLine="467" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified size.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix1D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix1D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix1D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>size the number of cell the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method name="like2D" type="DoubleMatrix2D" startLine="468" endLine="477" />
    <javadoc>
      <text>* Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix1D</tt> the new matrix must be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix1D</tt> the new matrix must be of type <tt>SparseDoubleMatrix2D</tt>, etc.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>index</tt> to the specified value.</text>
      <param>index   the index of the cell.</param>
      <param>value the value to be filled into the specified cell.</param>
      <throws>IndexOutOfBoundsException if <tt>index&lt;0 || index&gt;=size()</tt>.</throws>
    </javadoc>
    <method type="void" name="set" startLine="485" endLine="488" />
    <method name="setQuick" type="void" startLine="489" endLine="499" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>index</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>index&lt;0 || index&gt;=size()</tt>.</text>
      <param>index   the index of the cell.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <javadoc>
      <text>* Swaps each element <tt>this[i]</tt> with <tt>other[i]</tt>.</text>
      <throws>IllegalArgumentException if <tt>size() != other.size()</tt>.</throws>
    </javadoc>
    <method type="void" name="swap" startLine="504" endLine="512">
      <scope startLine="506" endLine="510">
        <declaration type="double" name="tmp" />
      </scope>
    </method>
    <javadoc>
      <text>* Constructs and returns a 1-dimensional array containing the cell values.
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.
 * The returned array <tt>values</tt> has the form 
 * <br>
 * <tt>for (int i=0; i < size(); i++) values[i] = get(i);</tt></text>
      <return>an array filled with the values of the cells.</return>
    </javadoc>
    <method type="double[]" name="toArray" startLine="522" endLine="526">
      <declaration type="double[]" name="values" />
    </method>
    <javadoc>
      <text>* Fills the cell values into the specified 1-dimensional array.
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.
 * After this call returns the array <tt>values</tt> has the form 
 * <br>
 * <tt>for (int i=0; i < size(); i++) values[i] = get(i);</tt></text>
      <throws>IllegalArgumentException if <tt>values.length < size()</tt>.</throws>
    </javadoc>
    <method type="void" name="toArray" startLine="536" endLine="541">
      <scope startLine="538" endLine="540" />
    </method>
    <javadoc>
      <text>* Returns a string representation using default formatting.</text>
      <see>cern.colt.matrix.doublealgo.Formatter</see>
    </javadoc>
    <method type="String" name="toString" startLine="546" endLine="548" />
    <javadoc>
      <text>* Constructs and returns a new view equal to the receiver.
 * The view is a shallow clone. Calls <code>clone()</code> and casts the result.
 * <p>
 * <b>Note that the view is not a deep copy.</b>
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
 * <p>
 * Use {@link #copy()} to construct an independent deep copy rather than a new view.</text>
      <return>a new view of the receiver.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="view" startLine="560" endLine="562" />
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i>.
 * What used to be index <tt>0</tt> is now index <tt>size()-1</tt>, ..., what used to be index <tt>size()-1</tt> is now index <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <return>a new flip view.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewFlip" startLine="570" endLine="572" />
    <javadoc>
      <text>* Constructs and returns a new <i>sub-range view</i> that is a <tt>width</tt> sub matrix starting at <tt>index</tt>.
 * Operations on the returned view can only be applied to the restricted range.
 * Any attempt to access coordinates not contained in the view will throw an <tt>IndexOutOfBoundsException</tt>.
 * <p>
 * <b>Note that the view is really just a range restriction:</b> 
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
 * <p>
 * The view contains the cells from <tt>index..index+width-1</tt>.
 * and has <tt>view.size() == width</tt>.
 * A view's legal coordinates are again zero based, as usual.
 * In other words, legal coordinates of the view are <tt>0 .. view.size()-1==width-1</tt>.
 * As usual, any attempt to access a cell at other coordinates will throw an <tt>IndexOutOfBoundsException</tt>.</text>
      <param>index   The index of the first cell.</param>
      <param>width   The width of the range.</param>
      <throws>IndexOutOfBoundsException if <tt>index<0 || width<0 || index+width>size()</tt>.</throws>
      <return>the new view.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewPart" startLine="594" endLine="596" />
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding the indicated cells.
 * There holds <tt>view.size() == indexes.length</tt> and <tt>view.get(i) == this.get(indexes[i])</tt>.
 * Indexes can occur multiple times and can be in arbitrary order.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * this     = (0,0,8,0,7)
 * indexes  = (0,2,4,2)
 * -->
 * view     = (0,8,7,8)
 * </pre>
 * Note that modifying <tt>indexes</tt> after this call has returned has no effect on the view.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>indexes   The indexes of the cells that shall be visible in the new view. To indicate that <i>all</i> cells shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <return>the new view.</return>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= indexes[i] < size())</tt> for any <tt>i=0..indexes.length()-1</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewSelection" startLine="617" endLine="630">
      <scope startLine="619" endLine="622" />
      <declaration type="int[]" name="offsets" />
      <scope startLine="626" endLine="628" />
      <comment>check for "all"</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding the cells matching the given condition.
 * Applies the condition to each cell and takes only those cells where <tt>condition.apply(get(i))</tt> yields <tt>true</tt>.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * // extract and view all cells with even value
 * matrix = 0 1 2 3 
 * matrix.viewSelection( 
 * &nbsp;&nbsp;&nbsp;new DoubleProcedure() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(double a) { return a % 2 == 0; }
 * &nbsp;&nbsp;&nbsp;}
 * );
 * -->
 * matrix ==  0 2
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>condition The condition to be matched.</param>
      <return>the new view.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewSelection" startLine="654" endLine="661">
      <declaration type="IntArrayList" name="matches" />
      <scope startLine="656" endLine="658" />
    </method>
    <method name="viewSelectionLike" type="DoubleMatrix1D" startLine="662" endLine="668" />
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>offsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <javadoc>
      <text>* Sorts the vector into ascending order, according to the <i>natural ordering</i>.
 * This sort is guaranteed to be <i>stable</i>.
 * For further information, see {@link cern.colt.matrix.doublealgo.Sorting#sort(DoubleMatrix1D)}.
 * For more advanced sorting functionality, see {@link cern.colt.matrix.doublealgo.Sorting}.</text>
      <return>a new sorted vector (matrix) view.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewSorted" startLine="676" endLine="678" />
    <javadoc>
      <text>* Constructs and returns a new <i>stride view</i> which is a sub matrix consisting of every i-th cell.
 * More specifically, the view has size <tt>this.size()/stride</tt> holding cells <tt>this.get(i*stride)</tt> for all <tt>i = 0..size()/stride - 1</tt>.</text>
      <param>stride  the step factor.</param>
      <throws>IndexOutOfBoundsException if <tt>stride <= 0</tt>.</throws>
      <return>the new view.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewStrides" startLine="688" endLine="690" />
    <javadoc>
      <text>* Applies a procedure to each cell's value.
 * Iterates downwards from <tt>[size()-1]</tt> to <tt>[0]</tt>,
 * as demonstrated by this snippet:
 * <pre>
 * for (int i=size(); --i >=0;) {
 * if (!procedure.apply(getQuick(i))) return false;
 * }
 * return true;
 * </pre>
 * Note that an implementation may use more efficient techniques, but must not use any other order.</text>
      <param>procedure a procedure object taking as argument the current cell's value. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="xforEach" startLine="706" endLine="711">
      <scope startLine="707" endLine="709" />
    </method>
    <javadoc>
      <text>* Returns the dot product of two vectors x and y, which is <tt>Sum(x[i]*y[i])</tt>.
 * Where <tt>x == this</tt>.
 * Operates on cells at indexes <tt>0 .. Math.min(size(),y.size())</tt>.</text>
      <param>y the second vector.</param>
      <return>the sum of products.</return>
    </javadoc>
    <method type="double" name="zDotProduct" startLine="719" endLine="721" />
    <javadoc>
      <text>* Returns the dot product of two vectors x and y, which is <tt>Sum(x[i]*y[i])</tt>.
 * Where <tt>x == this</tt>.
 * Operates on cells at indexes <tt>from .. Min(size(),y.size(),from+length)-1</tt>.</text>
      <param>y the second vector.</param>
      <param>from the first index to be considered.</param>
      <param>length the number of cells to be considered.</param>
      <return>the sum of products; zero if <tt>from<0 || length<0</tt>.</return>
    </javadoc>
    <method type="double" name="zDotProduct" startLine="731" endLine="745">
      <declaration type="int" name="tail" />
      <declaration type="double" name="sum" />
      <declaration type="int" name="i" />
      <scope startLine="741" endLine="743" />
    </method>
    <javadoc>
      <text>* Returns the dot product of two vectors x and y, which is <tt>Sum(x[i]*y[i])</tt>.
 * Where <tt>x == this</tt>.</text>
      <param>y the second vector.</param>
      <param>nonZeroIndexes the indexes of cells in <tt>y</tt>having a non-zero value.</param>
      <return>the sum of products.</return>
    </javadoc>
    <method type="double" name="zDotProduct" startLine="753" endLine="780">
      <declaration type="int" name="tail" />
      <declaration type="int[]" name="nonZeroIndexElements" />
      <declaration type="int" name="index" />
      <declaration type="int" name="s" />
      <declaration type="int" name="i" />
      <declaration type="double" name="sum" />
      <scope startLine="774" endLine="777" />
      <comment>determine minimum length</comment>
      <comment>setup</comment>
      <comment>skip to start</comment>
      <comment>now the sparse dot product</comment>
    </method>
    <javadoc>
      <text>* Returns the dot product of two vectors x and y, which is <tt>Sum(x[i]*y[i])</tt>.
 * Where <tt>x == this</tt>.</text>
      <param>y the second vector.</param>
      <param>nonZeroIndexes the indexes of cells in <tt>y</tt>having a non-zero value.</param>
      <return>the sum of products.</return>
    </javadoc>
    <method type="double" name="zDotProduct" startLine="788" endLine="799">
      <comment>double sum = 0;
int[] nonZeroIndexElements = nonZeroIndexes.elements();
for (int index=nonZeroIndexes.size(); --index >= 0; ) {
int i = nonZeroIndexElements[index];
sum += getQuick(i)  y.getQuick(i);
}
return sum;</comment>
    </method>
    <javadoc>
      <text>* Returns the sum of all cells; <tt>Sum( x[i] )</tt>.</text>
      <return>the sum.</return>
    </javadoc>
    <method type="double" name="zSum" startLine="804" endLine="807" />
  </class>
</source>
