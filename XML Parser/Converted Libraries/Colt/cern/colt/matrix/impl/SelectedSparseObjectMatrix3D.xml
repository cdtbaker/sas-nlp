<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.map.AbstractIntObjectMap" />
  <import name="cern.colt.matrix.ObjectMatrix2D" />
  <import name="cern.colt.matrix.ObjectMatrix3D" />
  <class name="SelectedSparseObjectMatrix3D" extends="ObjectMatrix3D" startLine="14">
    <javadoc>
      <text>* Selection view on sparse 3-d matrices holding <tt>Object</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * Objects of this class are typically constructed via <tt>viewIndexes</tt> methods on some source matrix.
 * The interface introduced in abstract super classes defines everything a user can do.
 * From a user point of view there is nothing special about this class; it presents the same functionality with the same signatures and semantics as its abstract superclass(es) while introducing no additional functionality.
 * Thus, this class need not be visible to users.
 * By the way, the same principle applies to concrete DenseXXX and SparseXXX classes: they presents the same functionality with the same signatures and semantics as abstract superclass(es) while introducing no additional functionality.
 * Thus, they need not be visible to users, either. 
 * Factory methods could hide all these concrete types.
 * <p>
 * This class uses no delegation. 
 * Its instances point directly to the data. 
 * Cell addressing overhead is is 1 additional int addition and 3 additional array index accesses per get/set.
 * <p>
 * Note that this implementation is not synchronized.
 * <p>
 * <b>Memory requirements:</b>
 * <p>
 * <tt>memory [bytes] = 4*(sliceIndexes.length+rowIndexes.length+columnIndexes.length)</tt>.
 * Thus, an index view with 100 x 100 x 100 indexes additionally uses 8 KB.
 * <p>
 * <b>Time complexity:</b>
 * <p>
 * Depends on the parent view holding cells.
 * <p></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* The elements of this matrix.</text>
    </javadoc>
    <declaration type="AbstractIntObjectMap" name="elements" />
    <javadoc>
      <text>* The offsets of the visible cells of this matrix.</text>
    </javadoc>
    <declaration type="int[]" name="sliceOffsets" />
    <declaration type="int[]" name="rowOffsets" />
    <declaration type="int[]" name="columnOffsets" />
    <javadoc>
      <text>* The offset.</text>
    </javadoc>
    <declaration type="int" name="offset" />
    <javadoc>
      <text>* Constructs a matrix view with the given parameters.</text>
      <param>elements the cells.</param>
      <param>sliceOffsets   The slice offsets of the cells that shall be visible.</param>
      <param>rowOffsets   The row offsets of the cells that shall be visible.</param>
      <param>columnOffsets   The column offsets of the cells that shall be visible.</param>
    </javadoc>
    <method type="constructor" name="SelectedSparseObjectMatrix3D" startLine="71" endLine="87">
      <declaration type="int" name="slices" />
      <declaration type="int" name="rows" />
      <declaration type="int" name="columns" />
      <comment>be sure parameters are valid, we do not check...</comment>
    </method>
    <javadoc>
      <text>* Returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. 
 * Default implementation. Override, if necessary.</text>
      <param>rank   the absolute rank of the element.</param>
      <return>the position.</return>
    </javadoc>
    <method type="int" name="_columnOffset" startLine="95" endLine="97" />
    <javadoc>
      <text>* Returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. 
 * Default implementation. Override, if necessary.</text>
      <param>rank   the absolute rank of the element.</param>
      <return>the position.</return>
    </javadoc>
    <method type="int" name="_rowOffset" startLine="105" endLine="107" />
    <javadoc>
      <text>* Returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. 
 * Default implementation. Override, if necessary.</text>
      <param>rank   the absolute rank of the element.</param>
      <return>the position.</return>
    </javadoc>
    <method type="int" name="_sliceOffset" startLine="115" endLine="117" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[slice,row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="Object" name="getQuick" startLine="130" endLine="135">
      <comment>if (debug) if (slice<0 || slice>=slices || row<0 || row>=rows || column<0 || column>=columns) throw new IndexOutOfBoundsException("slice:"+slice+", row:"+row+", column:"+column);</comment>
      <comment>return elements.get(index(slice,row,column));</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share common cells.
 * More formally, returns <tt>true</tt> if <tt>other != null</tt> and at least one of the following conditions is met
 * <ul>
 * <li>the receiver is a view of the other matrix
 * <li>the other matrix is a view of the receiver
 * <li><tt>this == other</tt>
 * </ul></text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="145" endLine="155">
      <scope startLine="146" endLine="149">
        <declaration type="SelectedSparseObjectMatrix3D" name="otherMatrix" />
      </scope>
      <scope startLine="150" endLine="153">
        <declaration type="SparseObjectMatrix3D" name="otherMatrix" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the third-coordinate.</param>
    </javadoc>
    <method type="int" name="index" startLine="163" endLine="167">
      <comment>return this.offset + super.index(slice,row,column);</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of slices, rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseObjectMatrix3D</tt> the new matrix must also be of type <tt>DenseObjectMatrix3D</tt>,
 * if the receiver is an instance of type <tt>SparseObjectMatrix3D</tt> the new matrix must also be of type <tt>SparseObjectMatrix3D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>slices the number of slices the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="like" startLine="179" endLine="181" />
    <javadoc>
      <text>* Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseObjectMatrix3D</tt> the new matrix must also be of type <tt>DenseObjectMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseObjectMatrix3D</tt> the new matrix must also be of type <tt>SparseObjectMatrix2D</tt>, etc.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>rowZero the position of the first element.</param>
      <param>columnZero the position of the first element.</param>
      <param>rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.</param>
      <param>columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="ObjectMatrix2D" name="like2D" startLine="195" endLine="197">
      <comment>this method is never called since viewRow() and viewColumn are overridden properly.</comment>
    </method>
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[slice,row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="210" endLine="219">
      <declaration type="int" name="index" />
      <comment>if (debug) if (slice<0 || slice>=slices || row<0 || row>=rows || column<0 || column>=columns) throw new IndexOutOfBoundsException("slice:"+slice+", row:"+row+", column:"+column);</comment>
      <comment>int index =	index(slice,row,column);</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Sets up a matrix with a given number of slices and rows.</text>
      <param>slices the number of slices the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>(Object)rows*slices > Integer.MAX_VALUE</tt>.</throws>
    </javadoc>
    <method type="void" name="setUp" startLine="227" endLine="233" />
    <javadoc>
      <text>* Self modifying version of viewDice().</text>
      <throws>IllegalArgumentException if some of the parameters are equal or not in range 0..2.</throws>
    </javadoc>
    <method type="AbstractMatrix3D" name="vDice" startLine="238" endLine="252">
      <declaration type="int[][][]" name="offsets" />
      <comment>swap offsets</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new 2-dimensional <i>slice view</i> representing the slices and rows of the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p>
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>view().part(...)</tt>), then apply this method to the sub-range view.
 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods <tt>viewColumn</tt>, <tt>viewRow</tt>) on the intermediate 2-dimensional view.
 * To obtain 1-dimensional views on subranges, apply both steps.</text>
      <param>column the index of the column to fix.</param>
      <return>a new 2-dimensional slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.</throws>
      <see>#viewSlice(int)</see>
      <see>#viewRow(int)</see>
    </javadoc>
    <method type="ObjectMatrix2D" name="viewColumn" startLine="267" endLine="284">
      <declaration type="int" name="viewRows" />
      <declaration type="int" name="viewColumns" />
      <declaration type="int" name="viewRowZero" />
      <declaration type="int" name="viewColumnZero" />
      <declaration type="int" name="viewOffset" />
      <declaration type="int" name="viewRowStride" />
      <declaration type="int" name="viewColumnStride" />
      <declaration type="int[]" name="viewRowOffsets" />
      <declaration type="int[]" name="viewColumnOffsets" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new 2-dimensional <i>slice view</i> representing the slices and columns of the given row.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p>
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>view().part(...)</tt>), then apply this method to the sub-range view.
 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods <tt>viewColumn</tt>, <tt>viewRow</tt>) on the intermediate 2-dimensional view.
 * To obtain 1-dimensional views on subranges, apply both steps.</text>
      <param>row the index of the row to fix.</param>
      <return>a new 2-dimensional slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= row()</tt>.</throws>
      <see>#viewSlice(int)</see>
      <see>#viewColumn(int)</see>
    </javadoc>
    <method type="ObjectMatrix2D" name="viewRow" startLine="299" endLine="316">
      <declaration type="int" name="viewRows" />
      <declaration type="int" name="viewColumns" />
      <declaration type="int" name="viewRowZero" />
      <declaration type="int" name="viewColumnZero" />
      <declaration type="int" name="viewOffset" />
      <declaration type="int" name="viewRowStride" />
      <declaration type="int" name="viewColumnStride" />
      <declaration type="int[]" name="viewRowOffsets" />
      <declaration type="int[]" name="viewColumnOffsets" />
    </method>
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>sliceOffsets the offsets of the visible elements.</param>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <method type="ObjectMatrix3D" name="viewSelectionLike" startLine="325" endLine="327" />
    <javadoc>
      <text>* Constructs and returns a new 2-dimensional <i>slice view</i> representing the rows and columns of the given slice.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p>
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>view().part(...)</tt>), then apply this method to the sub-range view.
 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods <tt>viewColumn</tt>, <tt>viewRow</tt>) on the intermediate 2-dimensional view.
 * To obtain 1-dimensional views on subranges, apply both steps.</text>
      <param>slice the index of the slice to fix.</param>
      <return>a new 2-dimensional slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>slice < 0 || slice >= slices()</tt>.</throws>
      <see>#viewRow(int)</see>
      <see>#viewColumn(int)</see>
    </javadoc>
    <method type="ObjectMatrix2D" name="viewSlice" startLine="342" endLine="359">
      <declaration type="int" name="viewRows" />
      <declaration type="int" name="viewColumns" />
      <declaration type="int" name="viewRowZero" />
      <declaration type="int" name="viewColumnZero" />
      <declaration type="int" name="viewOffset" />
      <declaration type="int" name="viewRowStride" />
      <declaration type="int" name="viewColumnStride" />
      <declaration type="int[]" name="viewRowOffsets" />
      <declaration type="int[]" name="viewColumnOffsets" />
    </method>
  </class>
</source>
