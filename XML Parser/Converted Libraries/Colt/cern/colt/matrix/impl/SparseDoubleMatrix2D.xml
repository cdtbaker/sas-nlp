<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.map.AbstractIntDoubleMap" />
  <import name="cern.colt.map.OpenIntDoubleHashMap" />
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="SparseDoubleMatrix2D" extends="DoubleMatrix2D" startLine="15">
    <javadoc>
      <text>* Sparse hashed 2-d matrix holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * Note that this implementation is not synchronized.
 * Uses a {@link cern.colt.map.OpenIntDoubleHashMap}, which is a compact and performant hashing technique.
 * <p>
 * <b>Memory requirements:</b>
 * <p>
 * Cells that
 * <ul>
 * <li>are never set to non-zero values do not use any memory.
 * <li>switch from zero to non-zero state do use memory.
 * <li>switch back from non-zero to zero state also do use memory. However, their memory is automatically reclaimed from time to time. It can also manually be reclaimed by calling {@link #trimToSize()}.
 * </ul>
 * <p>
 * worst case: <tt>memory [bytes] = (1/minLoadFactor) * nonZeros * 13</tt>.
 * <br>best  case: <tt>memory [bytes] = (1/maxLoadFactor) * nonZeros * 13</tt>.
 * <br>Where <tt>nonZeros = cardinality()</tt> is the number of non-zero cells.
 * Thus, a 1000 x 1000 matrix with minLoadFactor=0.25 and maxLoadFactor=0.5 and 1000000 non-zero cells consumes between 25 MB and 50 MB.
 * The same 1000 x 1000 matrix with 1000 non-zero cells consumes between 25 and 50 KB.
 * <p>
 * <b>Time complexity:</b>
 * <p>
 * This class offers <i>expected</i> time complexity <tt>O(1)</tt> (i.e. constant time) for the basic operations
 * <tt>get</tt>, <tt>getQuick</tt>, <tt>set</tt>, <tt>setQuick</tt> and <tt>size</tt>
 * assuming the hash function disperses the elements properly among the buckets.
 * Otherwise, pathological cases, although highly improbable, can occur, degrading performance to <tt>O(N)</tt> in the worst case.
 * As such this sparse class is expected to have no worse time complexity than its dense counterpart {@link DenseDoubleMatrix2D}.
 * However, constant factors are considerably larger.
 * <p>
 * Cells are internally addressed in row-major.
 * Performance sensitive applications can exploit this fact.
 * Setting values in a loop row-by-row is quicker than column-by-column, because fewer hash collisions occur.
 * Thus
 * <pre>
 * for (int row=0; row < rows; row++) {
 * for (int column=0; column < columns; column++) {
 * matrix.setQuick(row,column,someValue);
 * }
 * }
 * </pre>
 * is quicker than
 * <pre>
 * for (int column=0; column < columns; column++) {
 * for (int row=0; row < rows; row++) {
 * matrix.setQuick(row,column,someValue);
 * }
 * }
 * </pre></text>
      <see>cern.colt.map</see>
      <see>cern.colt.map.OpenIntDoubleHashMap</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <declaration type="AbstractIntDoubleMap" name="elements" />
    <declaration type="int" name="dummy" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of columns in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.</throws>
    </javadoc>
    <method type="constructor" name="SparseDoubleMatrix2D" startLine="89" endLine="92" />
    <javadoc>
      <text>* Constructs a matrix with a given number of rows and columns and default memory usage.
 * All entries are initially <tt>0</tt>.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.</throws>
    </javadoc>
    <method type="constructor" name="SparseDoubleMatrix2D" startLine="100" endLine="102" />
    <javadoc>
      <text>* Constructs a matrix with a given number of rows and columns using memory as specified.
 * All entries are initially <tt>0</tt>.
 * For details related to memory usage see {@link cern.colt.map.OpenIntDoubleHashMap}.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>initialCapacity   the initial capacity of the hash map.
 * If not known, set <tt>initialCapacity=0</tt> or small.</param>
      <param>minLoadFactor        the minimum load factor of the hash map.</param>
      <param>maxLoadFactor        the maximum load factor of the hash map.</param>
      <throws>IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.</throws>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.</throws>
    </javadoc>
    <method type="constructor" name="SparseDoubleMatrix2D" startLine="117" endLine="120" />
    <javadoc>
      <text>* Constructs a view with the given parameters.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>elements the cells.</param>
      <param>rowZero the position of the first element.</param>
      <param>columnZero the position of the first element.</param>
      <param>rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.</param>
      <param>columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.</param>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt> or flip's are illegal.</throws>
    </javadoc>
    <method type="constructor" name="SparseDoubleMatrix2D" startLine="132" endLine="136" />
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="142" endLine="147">
      <comment>overriden for performance only</comment>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[row,col] = function(x[row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * matrix = 2 x 2 matrix
 * 0.5 1.5      
 * 2.5 3.5
 * // change each cell to its sine
 * matrix.assign(cern.jet.math.Functions.sin);
 * -->
 * 2 x 2 matrix
 * 0.479426  0.997495 
 * 0.598472 -0.350783
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>function a function object taking as argument the current cell's value.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="170" endLine="178">
      <scope startLine="171" endLine="173">
        <comment>x[i] = mult*x[i]</comment>
      </scope>
      <scope startLine="174" endLine="176" />
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>source   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="188" endLine="202">
      <scope startLine="190" endLine="192" />
      <declaration type="SparseDoubleMatrix2D" name="other" />
      <scope startLine="197" endLine="200">
        <comment>quickest</comment>
      </scope>
      <comment>overriden for performance only</comment>
      <comment>nothing to do</comment>
    </method>
    <method type="DoubleMatrix2D" name="assign" startLine="203" endLine="251">
      <scope startLine="208" endLine="220">
        <declaration type="double" name="alpha" />
        <method type="double" name="apply" startLine="213" endLine="216" />
        <comment>x[i] = x[i] + alpha*y[i]</comment>
        <comment>nothing to do</comment>
      </scope>
      <scope startLine="222" endLine="234">
        <method type="boolean" name="apply" startLine="225" endLine="231">
          <declaration type="int" name="i" />
          <declaration type="int" name="j" />
          <declaration type="double" name="r" />
        </method>
        <comment>x[i] = x[i] * y[i]</comment>
      </scope>
      <scope startLine="236" endLine="248">
        <method type="boolean" name="apply" startLine="239" endLine="245">
          <declaration type="int" name="i" />
          <declaration type="int" name="j" />
          <declaration type="double" name="r" />
        </method>
        <comment>x[i] = x[i] / y[i]</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the number of cells having non-zero values.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="255" endLine="258" />
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.
 * <p>
 * This method never need be called; it is for performance tuning only.
 * Calling this method before tt>set()</tt>ing a large number of non-zero values boosts performance,
 * because the receiver will grow only once instead of potentially many times and hash collisions get less probable.</text>
      <param>minNonZeros   the desired minimum number of non-zero cells.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="269" endLine="271" />
    <method type="DoubleMatrix2D" name="forEachNonZero" startLine="272" endLine="290">
      <scope startLine="273" endLine="285">
        <method type="boolean" name="apply" startLine="276" endLine="282">
          <declaration type="int" name="i" />
          <declaration type="int" name="j" />
          <declaration type="double" name="r" />
        </method>
      </scope>
      <scope startLine="286" endLine="288" />
    </method>
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="302" endLine="307">
      <comment>if (debug) if (column<0 || column>=columns || row<0 || row>=rows) throw new IndexOutOfBoundsException("row:"+row+", column:"+column);</comment>
      <comment>return this.elements.get(index(row,column));</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share common cells.
 * More formally, returns <tt>true</tt> if at least one of the following conditions is met
 * <ul>
 * <li>the receiver is a view of the other matrix
 * <li>the other matrix is a view of the receiver
 * <li><tt>this == other</tt>
 * </ul></text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="317" endLine="327">
      <scope startLine="318" endLine="321">
        <declaration type="SelectedSparseDoubleMatrix2D" name="otherMatrix" />
      </scope>
      <scope startLine="322" endLine="325">
        <declaration type="SparseDoubleMatrix2D" name="otherMatrix" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
    </javadoc>
    <method type="int" name="index" startLine="334" endLine="338">
      <comment>return super.index(row,column);</comment>
      <comment>manually inlined for speed:</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like" startLine="349" endLine="351" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="360" endLine="362" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <param>offset the index of the first element.</param>
      <param>stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="373" endLine="375" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="387" endLine="398">
      <declaration type="int" name="index" />
      <comment>if (debug) if (column<0 || column>=columns || row<0 || row>=rows) throw new IndexOutOfBoundsException("row:"+row+", column:"+column);</comment>
      <comment>int index =	index(row,column);</comment>
      <comment>manually inlined:</comment>
      <comment>if (value == 0 || Math.abs(value) < TOLERANCE)</comment>
    </method>
    <javadoc>
      <text>* Releases any superfluous memory created by explicitly putting zero values into cells formerly having non-zero values; 
 * An application can use this operation to minimize the
 * storage of the receiver.
 * <p>
 * <b>Background:</b>
 * <p>
 * Cells that <ul>
 * <li>are never set to non-zero values do not use any memory.
 * <li>switch from zero to non-zero state do use memory.
 * <li>switch back from non-zero to zero state also do use memory. However, their memory can be reclaimed by calling <tt>trimToSize()</tt>.
 * </ul>
 * A sequence like <tt>set(r,c,5); set(r,c,0);</tt>
 * sets a cell to non-zero state and later back to zero state.
 * Such as sequence generates obsolete memory that is automatically reclaimed from time to time or can manually be reclaimed by calling <tt>trimToSize()</tt>.
 * Putting zeros into cells already containing zeros does not generate obsolete memory since no memory was allocated to them in the first place.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="416" endLine="418" />
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSelectionLike" startLine="426" endLine="428" />
    <method type="DoubleMatrix1D" name="zMult" startLine="429" endLine="490">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="432" endLine="435" />
      <declaration type="boolean" name="ignore" />
      <scope startLine="440" endLine="442" />
      <declaration type="DenseDoubleMatrix1D" name="zz" />
      <declaration type="double[]" name="zElements" />
      <declaration type="int" name="zStride" />
      <declaration type="int" name="zi" />
      <declaration type="DenseDoubleMatrix1D" name="yy" />
      <declaration type="double[]" name="yElements" />
      <declaration type="int" name="yStride" />
      <declaration type="int" name="yi" />
      <method type="boolean" name="apply" startLine="463" endLine="470">
        <declaration type="int" name="i" />
        <declaration type="int" name="j" />
        <scope startLine="466" endLine="466">
          <declaration type="int" name="tmp" />
        </scope>
      </method>
      <comment>System.out.println("["+i+","+j+"]-->"+value);</comment>
      <comment>forEachNonZero(
new cern.colt.function.IntIntDoubleFunction() {
public double apply(int i, int j, double value) {
if (transposeA) { int tmp=i; i=j; j=tmp; }
zElements[zi + zStridei] += value  yElements[yi + yStridej];
z.setQuick(row,z.getQuick(row) + value  y.getQuick(column));
System.out.println("["+i+","+j+"]-->"+value);
return value;
}
}
);</comment>
    </method>
    <method type="DoubleMatrix2D" name="zMult" startLine="491" endLine="539">
      <scope startLine="492" endLine="494" />
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="498" endLine="501" />
      <declaration type="int" name="p" />
      <declaration type="boolean" name="ignore" />
      <declaration type="DoubleMatrix1D[]" name="Brows" />
      <declaration type="DoubleMatrix1D[]" name="Crows" />
      <declaration type="cern.jet.math.PlusMult" name="fun" />
      <method type="boolean" name="apply" startLine="525" endLine="534">
        <declaration type="int" name="i" />
        <declaration type="int" name="j" />
      </method>
      <comment>cache views</comment>
    </method>
    <comment>The elements of the matrix.</comment>
  </class>
</source>
