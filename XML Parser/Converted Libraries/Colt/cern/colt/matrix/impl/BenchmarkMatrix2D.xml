<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="BenchmarkMatrix2D" startLine="12">
    <javadoc>
      <text>* Benchmarks the performance of matrices. Here are the results of some encouraging 
 * measurements. Note that all benchmarks only measure the time spent in accessing 
 * a matrix element; they exclude the loop itself. 
 * <p> 
 * <center>
 * <table border cellpadding="3" cellspacing="0" align="center">
 * <tr valign="middle" bgcolor="#33CC66" nowrap align="center"> 
 * <td nowrap colspan="7"> <font size="+2">Iteration Performance [million method 
 * calls per second]</font><br>
 * <font size="-1">Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic,<br>
 * 60 times repeating the same iteration </font></td>
 * </tr>
 * <tr valign="middle" bgcolor="#33CC66" nowrap align="center"> 
 * <td nowrap> 
 * <div align="left"> Element type</div>
 * </td>
 * <td nowrap colspan="6"> Matrix2D type </td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td nowrap bgcolor="#FF9966" rowspan="2"> 
 * <div align="left"> .</div>
 * </td>
 * <td bgcolor="#FF9966" colspan="2"> 
 * <p><tt>DenseDoubleMatrix2D</tt><br>
 * 1000 x 1000 </p>
 * </td>
 * <td bgcolor="#FF9966" colspan="2">&nbsp;</td>
 * <td bgcolor="#FF9966" colspan="2"> 
 * <p><tt>SparseDoubleMatrix2D</tt><br>
 * 100 x 1000,<br>
 * <font size="-1"> minLoadFactor=0.2, maxLoadFactor=0.5, initialCapacity 
 * = 0</font></p>
 * </td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td bgcolor="#FF9966"> getQuick</td>
 * <td bgcolor="#FF9966"> setQuick</td>
 * <td bgcolor="#FF9966">&nbsp;</td>
 * <td bgcolor="#FF9966">&nbsp;</td>
 * <td bgcolor="#FF9966"> getQuick</td>
 * <td bgcolor="#FF9966">setQuick</td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td nowrap bgcolor="#FF9966">double</td>
 * <td nowrap>5</td>
 * <td nowrap>5</td>
 * <td nowrap>&nbsp;</td>
 * <td nowrap>&nbsp;</td>
 * <td nowrap>1</td>
 * <td nowrap>0.27</td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td nowrap bgcolor="#FF9966"> int</td>
 * <td nowrap>5 </td>
 * <td nowrap>5.5 </td>
 * <td nowrap>&nbsp;</td>
 * <td nowrap>&nbsp;</td>
 * <td nowrap>1 </td>
 * <td nowrap>0.3</td>
 * </tr>
 * </table>
 * </center>
 * <p align="left"> As can be seen, sparse matrices are certainly not quite as quick 
 * as dense ones, but not really slow either. Considering their minimal footprint 
 * they can be a real alternative. 
 * <p> Comparing the OO abstractions to zero-abstraction primitive Java arrays may 
 * or may not be useful. Still, the table below provides some interesting information. 
 * For example, access to <tt>Type_T_Matrix2D</tt> is quicker than naive usage 
 * of <tt>Type_T_[]</tt>. Primitive arrays should only be considered if the optimized 
 * form can be applied. Note again that all benchmarks only measure the time spent 
 * in accessing a matrix element; they exclude the loop itself. 
 * <p> 
 * <center>
 * <table border cellpadding="3" cellspacing="0" align="center" width="617">
 * <tr valign="middle" bgcolor="#33CC66" nowrap align="center"> 
 * <td height="30" nowrap colspan="7"> <font size="+2">Iteration Performance 
 * [million element accesses per second]</font><br>
 * <font size="-1">Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic,<br>
 * 200 times repeating the same iteration </font></td>
 * </tr>
 * <tr valign="middle" bgcolor="#33CC66" nowrap align="center"> 
 * <td width="78" height="30" nowrap> 
 * <div align="left"> Element type</div>
 * </td>
 * <td height="30" nowrap colspan="6"> 
 * <div align="center">Matrix2D type = Java array <tt>double[][]</tt></div>
 * </td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td width="78" height="60" nowrap bgcolor="#FF9966" rowspan="2"> 
 * <div align="left"> .</div>
 * </td>
 * <td height="132" bgcolor="#FF9966" colspan="2"> 
 * <p>Unoptimized Form<br>
 * 1000 x 1000<br>
 * <div align="left"> <font size="-1"> 
 * <pre>
 * for (int row=0; row < rows; row++) { 
 * for (int col=0; col < columns; ) { 
 * value = m[row][col++];
 * ...
 * }
 * }
 * </pre>
 * </font> </div>
 * </td>
 * <td height="132" bgcolor="#FF9966" colspan="4"> Optimized Form<br>
 * 1000 x 1000 
 * <div align="left"> <font size="-1"> 
 * <pre>
 * for (int row=0; row < rows; row++) { 
 * int[] r = matrix[row]; 
 * for (int col=0; col < columns; ) { 
 * value = r[col++];
 * ...
 * }
 * }
 * </pre>
 * </font> </div>
 * </td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td width="152" height="30" bgcolor="#FF9966"> getting</td>
 * <td width="144" height="30" bgcolor="#FF9966"> setting</td>
 * <td width="150" height="30" bgcolor="#FF9966"> getting</td>
 * <td width="138" height="30" bgcolor="#FF9966" colspan="3"> setting</td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td width="78" height="30" nowrap bgcolor="#FF9966">double</td>
 * <td width="152" height="30" nowrap>1.6</td>
 * <td width="144" height="30" nowrap>1.8</td>
 * <td width="150" height="30" nowrap>18</td>
 * <td width="138" height="30" nowrap colspan="3">11</td>
 * </tr>
 * <tr valign="middle" bgcolor="#66CCFF" nowrap align="center"> 
 * <td width="78" height="30" nowrap bgcolor="#FF9966"> int</td>
 * <td width="152" height="30" nowrap>1.5 </td>
 * <td width="144" height="30" nowrap>1.8</td>
 * <td width="150" height="30" nowrap>28</td>
 * <td width="138" height="30" nowrap colspan="3">26</td>
 * </tr>
 * </table>
 * </center>
 * <left></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="BenchmarkMatrix2D" startLine="165" endLine="167" />
    <javadoc>
      <text>* Runs a bench on matrices holding double elements.</text>
    </javadoc>
    <method type="void" name="doubleBenchmark" startLine="171" endLine="322">
      <declaration type="cern.colt.Timer" name="timer1" />
      <declaration type="cern.colt.Timer" name="timer2" />
      <declaration type="cern.colt.Timer" name="timer3" />
      <declaration type="cern.colt.Timer" name="timer4" />
      <declaration type="cern.colt.Timer" name="emptyLoop" />
      <declaration type="cern.colt.Timer" name="emptyLoop2" />
      <declaration type="int" name="dummy" />
      <scope startLine="185" endLine="191">
        <scope startLine="186" endLine="190">
          <scope startLine="187" endLine="189" />
        </scope>
      </scope>
      <declaration type="double" name="dummy2" />
      <scope startLine="198" endLine="204">
        <scope startLine="199" endLine="203">
          <scope startLine="200" endLine="202" />
        </scope>
      </scope>
      <declaration type="long" name="before" />
      <declaration type="long" name="size" />
      <declaration type="DoubleMatrix2D" name="matrix" />
      <scope startLine="220" endLine="232">
        <declaration type="int" name="value" />
        <scope startLine="226" endLine="230">
          <scope startLine="227" endLine="229" />
        </scope>
      </scope>
      <scope startLine="238" endLine="238" />
      <scope startLine="238" endLine="238" />
      <declaration type="long" name="after" />
      <scope startLine="242" endLine="245" />
      <declaration type="double" name="element" />
      <scope startLine="258" endLine="264">
        <scope startLine="259" endLine="263">
          <scope startLine="260" endLine="262" />
        </scope>
      </scope>
      <declaration type="DoubleMatrix2D" name="view" />
      <scope startLine="276" endLine="282">
        <scope startLine="277" endLine="281">
          <scope startLine="278" endLine="280" />
        </scope>
      </scope>
      <scope startLine="293" endLine="307">
        <scope startLine="295" endLine="299">
          <scope startLine="296" endLine="298" />
        </scope>
        <scope startLine="301" endLine="305">
          <scope startLine="302" endLine="304" />
        </scope>
        <comment>initializing</comment>
      </scope>
      <scope startLine="312" endLine="312" />
      <scope startLine="312" endLine="312" />
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
      <comment>this involves primarly read-loops</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(rows,columns);</comment>
      <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
      <comment>invite gc</comment>
      <comment>if (kind.equals("sparse")) {
int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--> "+ ((double)hashCollisions  (rowscolumns)) +" hashCollisionselement on average.");
}</comment>
      <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
      <comment>if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseDoubleMatrix2D)matrix).elements.hashCollisions);</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseDoubleMatrix2D)view).elements.hashCollisions);</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
      <comment>invite gc</comment>
      <comment>if (kind.equals("sparse")) System.out.println("hashCollisions"+((SparseDoubleMatrix2D)matrix).elements.hashCollisions);</comment>
    </method>
    <javadoc>
      <text>* Runs a bench on matrices holding double elements.</text>
    </javadoc>
    <method type="void" name="doubleBenchmarkMult" startLine="326" endLine="386">
      <declaration type="cern.colt.Timer" name="timer1" />
      <declaration type="cern.colt.Timer" name="timer2" />
      <declaration type="long" name="size" />
      <declaration type="DoubleMatrix2D" name="matrix" />
      <scope startLine="345" endLine="349" />
      <scope startLine="353" endLine="355" />
      <scope startLine="367" endLine="371" />
      <scope startLine="375" endLine="377" />
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
      <comment>this involves primarly read-loops</comment>
      <comment>else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(rows,columns);</comment>
      <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
      <comment>if (kind.equals("sparse")) {
int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--> "+ ((double)hashCollisions  (rowscolumns)) +" hashCollisionselement on average.");
}</comment>
      <comment>if (kind.equals("sparse")) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;</comment>
      <comment>if (kind.equals("sparse")) {
int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--> "+ ((double)hashCollisions  (rowscolumns)) +" hashCollisionselement on average.");
}</comment>
    </method>
    <javadoc>
      <text>* Runs a bench on matrices holding double elements.</text>
    </javadoc>
    <method type="void" name="doubleBenchmarkPrimitive" startLine="390" endLine="509">
      <declaration type="cern.colt.Timer" name="timer1" />
      <declaration type="cern.colt.Timer" name="timer2" />
      <declaration type="cern.colt.Timer" name="timer3" />
      <declaration type="cern.colt.Timer" name="emptyLoop" />
      <declaration type="cern.colt.Timer" name="emptyLoop2" />
      <declaration type="int" name="dummy" />
      <scope startLine="401" endLine="407">
        <scope startLine="402" endLine="406">
          <scope startLine="403" endLine="405" />
        </scope>
      </scope>
      <declaration type="double" name="dummy2" />
      <scope startLine="414" endLine="420">
        <scope startLine="415" endLine="419">
          <scope startLine="416" endLine="418" />
        </scope>
      </scope>
      <declaration type="long" name="before" />
      <declaration type="long" name="size" />
      <declaration type="double[][]" name="matrix" />
      <scope startLine="430" endLine="439">
        <declaration type="int" name="value" />
        <scope startLine="433" endLine="437">
          <scope startLine="434" endLine="436" />
        </scope>
      </scope>
      <scope startLine="445" endLine="445" />
      <scope startLine="445" endLine="445" />
      <declaration type="long" name="after" />
      <scope startLine="448" endLine="452">
        <declaration type="DenseDoubleMatrix2D" name="m" />
      </scope>
      <declaration type="double" name="element" />
      <scope startLine="457" endLine="463">
        <scope startLine="458" endLine="462">
          <scope startLine="459" endLine="461" />
        </scope>
      </scope>
      <scope startLine="467" endLine="471">
        <declaration type="DenseDoubleMatrix2D" name="m" />
      </scope>
      <scope startLine="476" endLine="492">
        <scope startLine="486" endLine="490">
          <scope startLine="487" endLine="489" />
        </scope>
        <comment>initializing
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
matrix.setQuick(row,column,1);
}
}</comment>
      </scope>
      <scope startLine="497" endLine="497" />
      <scope startLine="497" endLine="497" />
      <scope startLine="502" endLine="506">
        <declaration type="DenseDoubleMatrix2D" name="m" />
      </scope>
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
      <comment>this involves primarly read-loops</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>invite gc</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>invite gc</comment>
    </method>
    <javadoc>
      <text>* Runs a bench on matrices holding double elements.</text>
    </javadoc>
    <method type="void" name="doubleBenchmarkPrimitiveOptimized" startLine="513" endLine="630">
      <declaration type="cern.colt.Timer" name="timer1" />
      <declaration type="cern.colt.Timer" name="timer2" />
      <declaration type="cern.colt.Timer" name="timer3" />
      <declaration type="cern.colt.Timer" name="emptyLoop" />
      <declaration type="cern.colt.Timer" name="emptyLoop2" />
      <declaration type="int" name="dummy" />
      <scope startLine="524" endLine="530">
        <scope startLine="525" endLine="529">
          <scope startLine="526" endLine="528" />
        </scope>
      </scope>
      <declaration type="double" name="dummy2" />
      <scope startLine="537" endLine="543">
        <scope startLine="538" endLine="542">
          <scope startLine="539" endLine="541" />
        </scope>
      </scope>
      <declaration type="long" name="before" />
      <declaration type="long" name="size" />
      <declaration type="double[][]" name="matrix" />
      <scope startLine="553" endLine="564">
        <declaration type="int" name="value" />
        <scope startLine="556" endLine="562">
          <declaration type="double[]" name="r" />
          <scope startLine="558" endLine="561" />
        </scope>
        <comment>matrix[row][column] = value++;</comment>
      </scope>
      <scope startLine="570" endLine="570" />
      <scope startLine="570" endLine="570" />
      <declaration type="long" name="after" />
      <scope startLine="573" endLine="577">
        <declaration type="DenseDoubleMatrix2D" name="m" />
      </scope>
      <declaration type="double" name="element" />
      <scope startLine="582" endLine="590">
        <scope startLine="583" endLine="589">
          <declaration type="double[]" name="r" />
          <scope startLine="585" endLine="588" />
        </scope>
        <comment>element += matrix[row][column];</comment>
      </scope>
      <scope startLine="594" endLine="598">
        <declaration type="DenseDoubleMatrix2D" name="m" />
      </scope>
      <scope startLine="603" endLine="613">
        <scope startLine="605" endLine="611">
          <declaration type="double[]" name="r" />
          <scope startLine="607" endLine="610" />
        </scope>
        <comment>matrix[row][column] = 0;</comment>
      </scope>
      <scope startLine="618" endLine="618" />
      <scope startLine="618" endLine="618" />
      <scope startLine="623" endLine="627">
        <declaration type="DenseDoubleMatrix2D" name="m" />
      </scope>
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.</comment>
      <comment>this involves primarly read-loops</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>invite gc</comment>
      <comment>!!! so that the jitter can't optimize away the whole loop</comment>
      <comment>invite gc</comment>
    </method>
    <javadoc>
      <text>* Runs a bench on matrices holding int elements.</text>
    </javadoc>
    <method type="void" name="intBenchmark" startLine="634" endLine="765">
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.
 this involves primarly read-loops

cern.colt.Timer timer1 = new cern.colt.Timer();
cern.colt.Timer timer2 = new cern.colt.Timer();
cern.colt.Timer timer3 = new cern.colt.Timer();
cern.colt.Timer emptyLoop = new cern.colt.Timer();
cern.colt.Timer emptyLoop2 = new cern.colt.Timer();

emptyLoop.start();
int dummy = 0;
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
dummy++;
}
}
}
emptyLoop.stop();
System.out.println(dummy);  !!! so that the jitter can't optimize away the whole loop

emptyLoop2.start();
dummy = 3;
int dummy2 = 0;
for (int i=0; i<runs; i++) {
for (int value = 0, column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
dummy2 += dummy;
}
}
}
emptyLoop2.stop();
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop

long before = Runtime.getRuntime().freeMemory();
long size = (((long)rows)columns)runs;

AbstractIntMatrix2D  matrix = null;
if (kind.equals("sparse")) matrix = new SparseIntMatrix2D(rows,columns,initialCapacity,minLoadFactor,maxLoadFactor);
else if (kind.equals("dense")) matrix = new DenseIntMatrix2D(rows,columns);
else if (kind.equals("denseArray")) matrix = new DoubleArrayMatrix2D(rows,columns);
else throw new RuntimeException("unknown kind");

System.out.println("\nNow filling...");
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
for (int i=0; i<runs; i++) {
matrix.assign(0);
matrix.ensureCapacity(initialCapacity);
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).ensureCapacity(initialCapacity);
timer1.start();
int value = 0;
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
matrix.setQuick(row,column,value++);
}
}
timer1.stop();
}
timer1.display();
timer1.minus(emptyLoop).display();
System.out.println(size  timer1.minus(emptyLoop).seconds() +" elements  sec");

Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
long after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)  1024);
System.out.println("bytes needed per non-zero="+(before-after)  (double)matrix.cardinality());
if (print) {
System.out.println(matrix);
if (kind.equals("sparse")) System.out.println("map="+((SparseIntMatrix2D)matrix).elements);
}
if (kind.equals("sparse")) {
int hashCollisions = ((SparseIntMatrix2D)matrix).elements.hashCollisions;
System.out.println("hashCollisions="+hashCollisions);
System.out.println("--> "+ ((double)hashCollisions  (rowscolumns)) +" probeselement on average.");
}

System.out.println("\nNow reading...");
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
timer2.start();
int element=0;
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
element += matrix.getQuick(row,column);
}
}
}
timer2.stop().display();
timer2.minus(emptyLoop2).display();
System.out.println(size  timer2.minus(emptyLoop2).seconds() +" elements  sec");
if (print) System.out.println(matrix);
if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseIntMatrix2D)matrix).elements.hashCollisions);
System.out.println(element);  !!! so that the jitter can't optimize away the whole loop

System.out.println("\nNow removing...");
before = Runtime.getRuntime().freeMemory();
if (kind.equals("sparse")) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
for (int i=0; i<runs; i++) {
 initializing
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
matrix.setQuick(row,column,1);
}
}
timer3.start();
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
matrix.setQuick(row,column,0);
}
}
timer3.stop();
}
timer3.display();
timer3.minus(emptyLoop).display();
System.out.println(size  timer3.minus(emptyLoop).seconds() +" elements  sec");
Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)1024);
System.out.println("KB free="+(after1024));

if (print) System.out.println(matrix);
if (kind.equals("sparse")) System.out.println("hashCollisions="+((SparseIntMatrix2D)matrix).elements.hashCollisions);


System.out.println("bye bye.");</comment>
    </method>
    <javadoc>
      <text>* Runs a bench on matrices holding int elements.</text>
    </javadoc>
    <method type="void" name="intBenchmarkPrimitive" startLine="769" endLine="883">
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.
 this involves primarly read-loops
cern.colt.Timer timer1 = new cern.colt.Timer();
cern.colt.Timer timer2 = new cern.colt.Timer();
cern.colt.Timer timer3 = new cern.colt.Timer();
cern.colt.Timer emptyLoop = new cern.colt.Timer();
cern.colt.Timer emptyLoop2 = new cern.colt.Timer();

emptyLoop.start();
int dummy = 0;
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
dummy++;
}
}
}
emptyLoop.stop();
System.out.println(dummy);  !!! so that the jitter can't optimize away the whole loop

emptyLoop2.start();
dummy = 3;
int dummy2 = 0;
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
dummy2 += dummy;
}
}
}
emptyLoop2.stop();
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop

long before = Runtime.getRuntime().freeMemory();
long size = (((long)rows)columns)runs;

int[][] matrix = new int[rows][columns];

System.out.println("\nNow filling...");
for (int i=0; i<runs; i++) {
timer1.start();
int value = 0;
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
matrix[row][column] = value++;
}
}
timer1.stop();
}
timer1.display();
timer1.minus(emptyLoop).display();
System.out.println(size  timer1.minus(emptyLoop).seconds() +" elements  sec");

Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
long after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)  1024);
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("\nNow reading...");
timer2.start();
int element=0;
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
element += matrix[row][column];
}
}
}
timer2.stop().display();
timer2.minus(emptyLoop2).display();
System.out.println(size  timer2.minus(emptyLoop2).seconds() +" elements  sec");
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}
System.out.println(element);  !!! so that the jitter can't optimize away the whole loop

System.out.println("\nNow removing...");
before = Runtime.getRuntime().freeMemory();
for (int i=0; i<runs; i++) {
timer3.start();
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
matrix[row][column] = 0;
}
}
timer3.stop();
}
timer3.display();
timer3.minus(emptyLoop).display();
System.out.println(size  timer3.minus(emptyLoop).seconds() +" elements  sec");
Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)1024);
System.out.println("KB free="+(after1024));

if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("bye bye.");</comment>
    </method>
    <javadoc>
      <text>* Runs a bench on matrices holding int elements.</text>
    </javadoc>
    <method type="void" name="intBenchmarkPrimitiveOptimized" startLine="887" endLine="1008">
      <comment>certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers.
 this involves primarly read-loops
cern.colt.Timer timer1 = new cern.colt.Timer();
cern.colt.Timer timer2 = new cern.colt.Timer();
cern.colt.Timer timer3 = new cern.colt.Timer();
cern.colt.Timer emptyLoop = new cern.colt.Timer();
cern.colt.Timer emptyLoop2 = new cern.colt.Timer();

emptyLoop.start();
int dummy = 0;
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
dummy++;
}
}
}
emptyLoop.stop();
System.out.println(dummy);  !!! so that the jitter can't optimize away the whole loop

int[][] matrix = new int[rows][columns];
emptyLoop2.start();
dummy = 3;
int dummy2 = 7;
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop
for (int i=0; i<runs; i++) {
for (int column=0; column < columns; column++) {
for (int row=0; row < rows; row++) {
dummy2 += dummy; matrix[row][column];
}
}
}
emptyLoop2.stop();
System.out.println(dummy2);  !!! so that the jitter can't optimize away the whole loop

long before = Runtime.getRuntime().freeMemory();
long size = (((long)rows)columns)runs;


System.out.println("\nNow filling...");
for (int i=0; i<runs; i++) {
timer1.start();
int value = 0;
for (int row=0; row < rows; row++) {
int[] r = matrix[row];
for (int column=0; column < columns; column++) {
r[column] = value++;
matrix[row][column] = value++;
}
}
timer1.stop();
}
timer1.display();
timer1.minus(emptyLoop).display();
System.out.println(size  timer1.minus(emptyLoop).seconds() +" elements  sec");

Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
long after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)  1024);
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("\nNow reading...");
timer2.start();
int element=0;
for (int i=0; i<runs; i++) {
for (int row=0; row < rows; row++) {
int[] r = matrix[row];
for (int column=0; column < columns; column++) {
element += r[column];
element += matrix[row][column];
}
}
}
timer2.stop().display();
timer2.minus(emptyLoop2).display();
System.out.println(size  timer2.minus(emptyLoop2).seconds() +" elements  sec");
if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}
System.out.println(element);  !!! so that the jitter can't optimize away the whole loop

System.out.println("\nNow removing...");
before = Runtime.getRuntime().freeMemory();
for (int i=0; i<runs; i++) {
timer3.start();
for (int row=0; row < rows; row++) {
int[] r = matrix[row];
for (int column=0; column < columns; column++) {
r[column] = 0;
matrix[row][column] = 0;
}
}
timer3.stop();
}
timer3.display();
timer3.minus(emptyLoop).display();
System.out.println(size  timer3.minus(emptyLoop).seconds() +" elements  sec");
Runtime.getRuntime().gc();  invite gc
try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
after = Runtime.getRuntime().freeMemory();
System.out.println("KB needed="+(before-after)1024);
System.out.println("KB free="+(after1024));

if (print) {
DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
m.assign(matrix);
System.out.println(m);
}

System.out.println("bye bye.");</comment>
    </method>
    <javadoc>
      <text>* Benchmarks various methods of this class.</text>
    </javadoc>
    <method type="void" name="main" startLine="1012" endLine="1038">
      <declaration type="int" name="runs" />
      <declaration type="int" name="rows" />
      <declaration type="int" name="columns" />
      <declaration type="String" name="kind" />
      <declaration type="int" name="initialCapacity" />
      <declaration type="double" name="minLoadFactor" />
      <declaration type="double" name="maxLoadFactor" />
      <declaration type="boolean" name="print" />
      <declaration type="String" name="type" />
      <declaration type="String" name="command" />
      <scope startLine="1026" endLine="1030" />
      <scope startLine="1031" endLine="1036" />
      <comment>int size = Integer.parseInt(args[3]);</comment>
      <comment>boolean isSparse = args[4].equals("sparse");</comment>
    </method>
  </class>
</source>
