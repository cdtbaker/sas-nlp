<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="TridiagonalDoubleMatrix2D" extends="WrapperDoubleMatrix2D" startLine="13">
    <javadoc>
      <text>* Tridiagonal 2-d matrix holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * TODO.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>0.9, 04/14/2000</version>
    </javadoc>
    <declaration type="double[]" name="values" />
    <declaration type="int[]" name="dims" />
    <declaration type="int" name="NONZERO" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of columns in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.</throws>
    </javadoc>
    <method type="constructor" name="TridiagonalDoubleMatrix2D" startLine="57" endLine="60" />
    <javadoc>
      <text>* Constructs a matrix with a given number of rows and columns.
 * All entries are initially <tt>0</tt>.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.</throws>
    </javadoc>
    <method type="constructor" name="TridiagonalDoubleMatrix2D" startLine="68" endLine="89">
      <declaration type="int" name="d" />
      <declaration type="int" name="u" />
      <declaration type="int" name="l" />
      <declaration type="int[]" name="dimensions" />
      <comment>{lower, diagonal, upper}</comment>
      <comment>{lowerStart, diagonalStart, upperStart, values.length, lowerNonZeros, diagonalNonZeros, upperNonZeros}</comment>
      <comment>diagonal = new double[d];</comment>
      <comment>lower = new double[l];</comment>
      <comment>upper = new double[u];</comment>
      <comment>diagonalNonZeros = 0;</comment>
      <comment>lowerNonZeros = 0;</comment>
      <comment>upperNonZeros = 0;</comment>
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="95" endLine="111">
      <scope startLine="97" endLine="108">
        <comment>for (int i=diagonal.length; --i >= 0; ) diagonal[i]=0;</comment>
        <comment>for (int i=upper.length; --i >= 0; ) upper[i]=0;</comment>
        <comment>for (int i=lower.length; --i >= 0; ) lower[i]=0;</comment>
        <comment>diagonalNonZeros = 0;</comment>
        <comment>lowerNonZeros = 0;</comment>
        <comment>upperNonZeros = 0;</comment>
      </scope>
      <comment>overriden for performance only</comment>
    </method>
    <method type="DoubleMatrix2D" name="assign" startLine="112" endLine="138">
      <scope startLine="113" endLine="133">
        <declaration type="double" name="alpha" />
        <method type="double" name="apply" startLine="128" endLine="130" />
        <comment>x[i] = mult*x[i]</comment>
        <comment>the funny definition of isNaN(). This should better not happen.</comment>
        <comment>double[] vals = values.elements();
for (int j=values.size(); --j >= 0; ) {
vals[j] = alpha;
}</comment>
      </scope>
      <scope startLine="134" endLine="136" />
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>source   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="148" endLine="176">
      <scope startLine="153" endLine="160">
        <declaration type="TridiagonalDoubleMatrix2D" name="other" />
        <comment>quickest</comment>
      </scope>
      <scope startLine="162" endLine="173">
        <method type="double" name="apply" startLine="166" endLine="169" />
      </scope>
      <comment>overriden for performance only</comment>
      <comment>nothing to do</comment>
    </method>
    <method type="DoubleMatrix2D" name="assign" startLine="177" endLine="219">
      <scope startLine="180" endLine="192">
        <declaration type="double" name="alpha" />
        <method type="double" name="apply" startLine="185" endLine="188" />
        <comment>x[i] = x[i] + alpha*y[i]</comment>
        <comment>nothing to do</comment>
      </scope>
      <scope startLine="194" endLine="204">
        <method type="double" name="apply" startLine="197" endLine="200" />
        <comment>x[i] = x[i] * y[i]</comment>
      </scope>
      <scope startLine="206" endLine="216">
        <method type="double" name="apply" startLine="209" endLine="212" />
        <comment>x[i] = x[i] / y[i]</comment>
      </scope>
    </method>
    <method type="DoubleMatrix2D" name="forEachNonZero" startLine="220" endLine="243">
      <scope startLine="221" endLine="241">
        <declaration type="int" name="i" />
        <scope startLine="224" endLine="224" />
        <scope startLine="226" endLine="226" />
        <declaration type="int" name="low" />
        <declaration type="int" name="high" />
        <scope startLine="231" endLine="240">
          <declaration type="double" name="value" />
          <scope startLine="233" endLine="239">
            <declaration type="double" name="r" />
            <scope startLine="235" endLine="238" />
          </scope>
        </scope>
        <comment>lower</comment>
        <comment>case 1: {   }  diagonal</comment>
        <comment>upper</comment>
        <comment>one non zero more</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the content of this matrix if it is a wrapper; or <tt>this</tt> otherwise.
 * Override this method in wrappers.</text>
    </javadoc>
    <method type="DoubleMatrix2D" name="getContent" startLine="248" endLine="250" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="262" endLine="298">
      <declaration type="int" name="i" />
      <declaration type="int" name="j" />
      <declaration type="int" name="k" />
      <declaration type="int" name="q" />
      <scope startLine="270" endLine="272" />
      <comment>lower diagonal</comment>
      <comment>int k = -1;</comment>
      <comment>int q = 0;</comment>
      <comment>if (i==j) { k=0; q=i; }</comment>
      <comment>if (i==j+1) { k=1; q=j; }</comment>
      <comment>if (i==j-1) { k=2; q=i; }</comment>
      <comment>if (k<0) return 0;</comment>
      <comment>return values[dims[k]+q];</comment>
      <comment>if (i==j) return diagonal[i];</comment>
      <comment>if (i==j+1) return lower[j];</comment>
      <comment>if (i==j-1) return upper[i];</comment>
      <comment>return 0;</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like" startLine="309" endLine="311" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="320" endLine="322" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="334" endLine="418">
      <declaration type="int" name="i" />
      <declaration type="int" name="j" />
      <declaration type="boolean" name="isZero" />
      <declaration type="int" name="k" />
      <declaration type="int" name="q" />
      <scope startLine="344" endLine="354">
        <declaration type="int" name="index" />
        <scope startLine="346" endLine="348" />
        <scope startLine="349" endLine="351" />
        <comment>one nonZero less</comment>
        <comment>one nonZero more</comment>
      </scope>
      <comment>lower diagonal</comment>
      <comment>int k = -1;</comment>
      <comment>int q = 0;</comment>
      <comment>if (i==j) { k=0; q=i; }  diagonal</comment>
      <comment>if (i==j+1) { k=1; q=j; }  lower diagonal</comment>
      <comment>if (i==j-1) { k=2; q=i; }  upper diagonal</comment>
      <comment>if (k>0) {</comment>
      <comment>int index = dims[k]+q;</comment>
      <comment>if (values[index]!=0) {</comment>
      <comment>if (isZero) dims[k+NONZERO]--;  one nonZero less</comment>
      <comment>}</comment>
      <comment>else {</comment>
      <comment>if (!isZero) dims[k+NONZERO]++;  one nonZero more</comment>
      <comment>}</comment>
      <comment>values[index] = value;</comment>
      <comment>return;</comment>
      <comment>}</comment>
      <comment>if (!isZero) throw new IllegalArgumentException("Can't store non-zero value to non-tridiagonal coordinate: row="+row+", column="+column+", value="+value);</comment>
      <comment>if (i==j) {</comment>
      <comment>if (diagonal[i]!=0) {</comment>
      <comment>if (isZero) diagonalNonZeros--;</comment>
      <comment>}</comment>
      <comment>else {</comment>
      <comment>if (!isZero) diagonalNonZeros++;</comment>
      <comment>}</comment>
      <comment>diagonal[i] = value;</comment>
      <comment>return;</comment>
      <comment>}</comment>
      <comment>if (i==j+1) {</comment>
      <comment>if (lower[j]!=0) {</comment>
      <comment>if (isZero) lowerNonZeros--;</comment>
      <comment>}</comment>
      <comment>else {</comment>
      <comment>if (!isZero) lowerNonZeros++;</comment>
      <comment>}</comment>
      <comment>lower[j] = value;</comment>
      <comment>return;</comment>
      <comment>}</comment>
      <comment>if (i==j-1) {</comment>
      <comment>if (upper[i]!=0) {</comment>
      <comment>if (isZero) upperNonZeros--;</comment>
      <comment>}</comment>
      <comment>else {</comment>
      <comment>if (!isZero) upperNonZeros++;</comment>
      <comment>}</comment>
      <comment>upper[i] = value;</comment>
      <comment>return;</comment>
      <comment>}</comment>
      <comment>if (!isZero) throw new IllegalArgumentException("Can't store non-zero value to non-tridiagonal coordinate: row="+row+", column="+column+", value="+value);</comment>
    </method>
    <method type="DoubleMatrix1D" name="zMult" startLine="419" endLine="465">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="422" endLine="425" />
      <declaration type="boolean" name="ignore" />
      <scope startLine="430" endLine="432" />
      <declaration type="DenseDoubleMatrix1D" name="zz" />
      <declaration type="double[]" name="zElements" />
      <declaration type="int" name="zStride" />
      <declaration type="int" name="zi" />
      <declaration type="DenseDoubleMatrix1D" name="yy" />
      <declaration type="double[]" name="yElements" />
      <declaration type="int" name="yStride" />
      <declaration type="int" name="yi" />
      <method type="double" name="apply" startLine="453" endLine="459">
        <scope startLine="454" endLine="454">
          <declaration type="int" name="tmp" />
        </scope>
      </method>
      <comment>z.setQuick(row,z.getQuick(row) + value * y.getQuick(column));</comment>
      <comment>System.out.println("["+i+","+j+"]-->"+value);</comment>
    </method>
    <method type="DoubleMatrix2D" name="zMult" startLine="466" endLine="509">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="470" endLine="473" />
      <declaration type="int" name="p" />
      <declaration type="boolean" name="ignore" />
      <declaration type="DoubleMatrix1D[]" name="Brows" />
      <declaration type="DoubleMatrix1D[]" name="Crows" />
      <declaration type="cern.jet.math.PlusMult" name="fun" />
      <method type="double" name="apply" startLine="497" endLine="504" />
      <comment>cache views</comment>
    </method>
    <comment>The non zero elements of the matrix: {lower, diagonal, upper}.</comment>
    <comment>The startIndexes and number of non zeros: {lowerStart, diagonalStart, upperStart, values.length, lowerNonZeros, diagonalNonZeros, upperNonZeros}.
 lowerStart = 0
 diagonalStart = lowerStart + lower.length
 upperStart = diagonalStart + diagonal.length</comment>
    <comment>protected double diagonal[];</comment>
    <comment>protected double lower[];</comment>
    <comment>protected double upper[];</comment>
    <comment>protected int diagonalNonZeros;</comment>
    <comment>protected int lowerNonZeros;</comment>
    <comment>protected int upperNonZeros;</comment>
    <comment>protected int N;</comment>
  </class>
</source>
