<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="RCDoubleMatrix2D" extends="WrapperDoubleMatrix2D" startLine="15">
    <javadoc>
      <text>* Sparse row-compressed 2-d matrix holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * Internally uses the standard sparse row-compressed format, with two important differences that broaden the applicability of this storage format:
 * <ul>
 * <li>We use a {@link cern.colt.list.IntArrayList} and {@link cern.colt.list.DoubleArrayList} to hold the column indexes and nonzero values, respectively. 
 * This improves set(...) performance, because the standard way of using non-resizable primitive arrays causes excessive memory allocation, garbage collection and array copying.
 * The small downside of this is that set(...,0) does not free memory (The capacity of an arraylist does not shrink upon element removal).
 * <li>Column indexes are kept sorted within a row. This both improves get and set performance on rows with many non-zeros, because we can use a binary search. 
 * (Experiments show that this hurts < 10% on rows with < 4 nonZeros.)
 * </ul>
 * <br>
 * Note that this implementation is not synchronized.
 * <p>
 * <b>Memory requirements:</b>
 * <p>
 * Cells that
 * <ul>
 * <li>are never set to non-zero values do not use any memory.
 * <li>switch from zero to non-zero state do use memory.
 * <li>switch back from non-zero to zero state also do use memory. Their memory is <i>not</i> automatically reclaimed (because of the lists vs. arrays). Reclamation can be triggered via {@link #trimToSize()}.
 * </ul>
 * <p>
 * <tt>memory [bytes] = 4*rows + 12 * nonZeros</tt>.
 * <br>Where <tt>nonZeros = cardinality()</tt> is the number of non-zero cells.
 * Thus, a 1000 x 1000 matrix with 1000000 non-zero cells consumes 11.5 MB.
 * The same 1000 x 1000 matrix with 1000 non-zero cells consumes 15 KB.
 * <p>
 * <b>Time complexity:</b>
 * <p>
 * Getting a cell value takes time<tt> O(log nzr)</tt> where <tt>nzr</tt> 
 * is the number of non-zeros of the touched row. This is usually quick, because 
 * typically there are only few nonzeros per row. So, in practice, get has <i>expected</i> 
 * constant time. Setting a cell value takes <i> </i>worst-case time <tt>O(nz)</tt> 
 * where <tt>nzr</tt> is the total number of non-zeros in the matrix. This can 
 * be extremely slow, but if you traverse coordinates properly (i.e. upwards), each write is done much quicker:
 * <table>
 * <td class="PRE"> 
 * <pre>
 * // rather quick
 * matrix.assign(0);
 * for (int row=0; row < rows; row++) {
 * &nbsp;&nbsp;&nbsp;for (int column=0; column < columns; column++) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (someCondition) matrix.setQuick(row,column,someValue);
 * &nbsp;&nbsp;&nbsp;}
 * }
 * // poor
 * matrix.assign(0);
 * for (int row=rows; --row >= 0; ) {
 * &nbsp;&nbsp;&nbsp;for (int column=columns; --column >= 0; ) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (someCondition) matrix.setQuick(row,column,someValue);
 * &nbsp;&nbsp;&nbsp;}
 * }
 * </pre>
 * </td>
 * </table>
 * If for whatever reasons you can't iterate properly, consider to create an empty dense matrix, store your non-zeros in it, then call <tt>sparse.assign(dense)</tt>. Under the circumstances, this is still rather quick.
 * <p>
 * Fast iteration over non-zeros can be done via {@link #forEachNonZero}, which supplies your function with row, column and value of each nonzero.
 * Although the internally implemented version is a bit more sophisticated,
 * here is how a quite efficient user-level matrix-vector multiplication could look like:
 * <table>
 * <td class="PRE"> 
 * <pre>
 * // Linear algebraic y = A * x
 * A.forEachNonZero(
 * &nbsp;&nbsp;&nbsp;new cern.colt.function.IntIntDoubleFunction() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public double apply(int row, int column, double value) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.setQuick(row,y.getQuick(row) + value * x.getQuick(column));
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 * &nbsp;&nbsp;&nbsp;}
 * );
 * </pre>
 * </td>
 * </table>
 * <p>
 * Here is how a a quite efficient user-level combined scaling operation could look like:
 * <table>
 * <td class="PRE"> 
 * <pre>
 * // Elementwise A = A + alpha*B
 * B.forEachNonZero(
 * &nbsp;&nbsp;&nbsp;new cern.colt.function.IntIntDoubleFunction() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public double apply(int row, int column, double value) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.setQuick(row,column,A.getQuick(row,column) + alpha*value);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 * &nbsp;&nbsp;&nbsp;}
 * );
 * </pre>
 * </td>
 * </table>
 * Method {@link #assign(DoubleMatrix2D,cern.colt.function.DoubleDoubleFunction)} does just that if you supply {@link cern.jet.math.Functions#plusMult} as argument.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>0.9, 04/14/2000</version>
    </javadoc>
    <declaration type="IntArrayList" name="indexes" />
    <declaration type="DoubleArrayList" name="values" />
    <declaration type="int[]" name="starts" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of columns in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.</throws>
    </javadoc>
    <method type="constructor" name="RCDoubleMatrix2D" startLine="136" endLine="139" />
    <javadoc>
      <text>* Constructs a matrix with a given number of rows and columns.
 * All entries are initially <tt>0</tt>.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.</throws>
    </javadoc>
    <method type="constructor" name="RCDoubleMatrix2D" startLine="147" endLine="158">
      <scope startLine="149" endLine="151" />
      <scope startLine="152" endLine="154">
        <comment>we can hold rows*columns>Integer.MAX_VALUE cells !</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="164" endLine="173">
      <scope startLine="166" endLine="170" />
      <comment>overriden for performance only</comment>
    </method>
    <method type="DoubleMatrix2D" name="assign" startLine="174" endLine="200">
      <scope startLine="175" endLine="195">
        <declaration type="double" name="alpha" />
        <declaration type="double[]" name="vals" />
        <scope startLine="182" endLine="184" />
        <comment>x[i] = mult*x[i]</comment>
        <comment>the funny definition of isNaN(). This should better not happen.</comment>
        <comment>forEachNonZero(
new cern.colt.function.IntIntDoubleFunction() {
public double apply(int i, int j, double value) {
return function.apply(value);
}
}
);</comment>
      </scope>
      <scope startLine="196" endLine="198" />
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>source   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="210" endLine="257">
      <scope startLine="214" endLine="244">
        <method type="double" name="apply" startLine="220" endLine="223" />
        <comment>return super.assign(source);</comment>
        <comment>indexes.clear();
values.clear();
int nonZeros=0;
for (int row=0; row<rows; row++) {
starts[row]=nonZeros;
for (int column=0; column<columns; column++) {
double v = source.getQuick(row,column);
if (v!=0) {
values.add(v);
indexes.add(column);
nonZeros++;
}
}
}
starts[rows]=nonZeros;</comment>
      </scope>
      <declaration type="RCDoubleMatrix2D" name="other" />
      <declaration type="int" name="s" />
      <comment>nothing to do</comment>
      <comment>overriden for performance only</comment>
      <comment>even quicker</comment>
    </method>
    <method type="DoubleMatrix2D" name="assign" startLine="258" endLine="306">
      <scope startLine="261" endLine="273">
        <declaration type="double" name="alpha" />
        <method type="double" name="apply" startLine="266" endLine="269" />
        <comment>x[i] = x[i] + alpha*y[i]</comment>
        <comment>nothing to do</comment>
      </scope>
      <scope startLine="275" endLine="288">
        <declaration type="int[]" name="idx" />
        <declaration type="double[]" name="vals" />
        <scope startLine="279" endLine="286">
          <declaration type="int" name="low" />
          <scope startLine="281" endLine="285">
            <declaration type="int" name="j" />
          </scope>
        </scope>
        <comment>x[i] = x[i] * y[i]</comment>
      </scope>
      <scope startLine="290" endLine="303">
        <declaration type="int[]" name="idx" />
        <declaration type="double[]" name="vals" />
        <scope startLine="294" endLine="301">
          <declaration type="int" name="low" />
          <scope startLine="296" endLine="300">
            <declaration type="int" name="j" />
          </scope>
        </scope>
        <comment>x[i] = x[i] / y[i]</comment>
      </scope>
    </method>
    <method type="DoubleMatrix2D" name="forEachNonZero" startLine="307" endLine="321">
      <declaration type="int[]" name="idx" />
      <declaration type="double[]" name="vals" />
      <scope startLine="311" endLine="319">
        <declaration type="int" name="low" />
        <scope startLine="313" endLine="318">
          <declaration type="int" name="j" />
          <declaration type="double" name="value" />
          <declaration type="double" name="r" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the content of this matrix if it is a wrapper; or <tt>this</tt> otherwise.
 * Override this method in wrappers.</text>
    </javadoc>
    <method type="DoubleMatrix2D" name="getContent" startLine="326" endLine="328" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="340" endLine="345">
      <declaration type="int" name="k" />
      <declaration type="double" name="v" />
    </method>
    <method type="void" name="insert" startLine="346" endLine="350" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like" startLine="361" endLine="363" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="372" endLine="374" />
    <method type="void" name="remove" startLine="375" endLine="379" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="391" endLine="405">
      <declaration type="int" name="k" />
      <scope startLine="393" endLine="399">
        <comment>found</comment>
      </scope>
      <scope startLine="401" endLine="404" />
    </method>
    <method type="void" name="trimToSize" startLine="406" endLine="409" />
    <method type="DoubleMatrix1D" name="zMult" startLine="410" endLine="482">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="413" endLine="416" />
      <declaration type="boolean" name="ignore" />
      <scope startLine="421" endLine="423" />
      <declaration type="DenseDoubleMatrix1D" name="zz" />
      <declaration type="double[]" name="zElements" />
      <declaration type="int" name="zStride" />
      <declaration type="int" name="zi" />
      <declaration type="DenseDoubleMatrix1D" name="yy" />
      <declaration type="double[]" name="yElements" />
      <declaration type="int" name="yStride" />
      <declaration type="int" name="yi" />
      <declaration type="int[]" name="idx" />
      <declaration type="double[]" name="vals" />
      <declaration type="int" name="s" />
      <scope startLine="457" endLine="468">
        <scope startLine="458" endLine="467">
          <declaration type="int" name="high" />
          <declaration type="double" name="sum" />
          <scope startLine="461" endLine="464">
            <declaration type="int" name="j" />
          </scope>
        </scope>
      </scope>
      <scope startLine="469" endLine="479">
        <scope startLine="471" endLine="478">
          <declaration type="int" name="high" />
          <declaration type="double" name="yElem" />
          <scope startLine="474" endLine="477">
            <declaration type="int" name="j" />
          </scope>
        </scope>
      </scope>
      <comment>forEachNonZero(
new cern.colt.function.IntIntDoubleFunction() {
public double apply(int i, int j, double value) {
zElements[zi + zStridei] += value  yElements[yi + yStridej];
z.setQuick(row,z.getQuick(row) + value  y.getQuick(column));
System.out.println("["+i+","+j+"]-->"+value);
return value;
}
}
);</comment>
    </method>
    <method type="DoubleMatrix2D" name="zMult" startLine="483" endLine="527">
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <scope startLine="487" endLine="490" />
      <declaration type="int" name="p" />
      <declaration type="boolean" name="ignore" />
      <declaration type="DoubleMatrix1D[]" name="Brows" />
      <declaration type="DoubleMatrix1D[]" name="Crows" />
      <declaration type="cern.jet.math.PlusMult" name="fun" />
      <declaration type="int[]" name="idx" />
      <declaration type="double[]" name="vals" />
      <scope startLine="514" endLine="524">
        <declaration type="int" name="low" />
        <scope startLine="516" endLine="523">
          <declaration type="int" name="j" />
        </scope>
      </scope>
      <comment>cache views</comment>
    </method>
    <comment>The elements of the matrix.</comment>
    <comment>protected int N;</comment>
  </class>
</source>
