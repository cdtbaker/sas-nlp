<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="DenseDoubleMatrix1D" extends="DoubleMatrix1D" startLine="13">
    <javadoc>
      <text>* Dense 1-d matrix (aka <i>vector</i>) holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * Internally holds one single contigous one-dimensional array. 
 * Note that this implementation is not synchronized.
 * <p>
 * <b>Memory requirements:</b>
 * <p>
 * <tt>memory [bytes] = 8*size()</tt>.
 * Thus, a 1000000 matrix uses 8 MB.
 * <p>
 * <b>Time complexity:</b>
 * <p>
 * <tt>O(1)</tt> (i.e. constant time) for the basic operations
 * <tt>get</tt>, <tt>getQuick</tt>, <tt>set</tt>, <tt>setQuick</tt> and <tt>size</tt>,
 * <p></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* The elements of this matrix.</text>
    </javadoc>
    <declaration type="double[]" name="elements" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix1D" startLine="46" endLine="49" />
    <javadoc>
      <text>* Constructs a matrix with a given number of cells.
 * All entries are initially <tt>0</tt>.</text>
      <param>size the number of cells the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>size<0</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix1D" startLine="56" endLine="59" />
    <javadoc>
      <text>* Constructs a matrix view with the given parameters.</text>
      <param>size the number of cells the matrix shall have.</param>
      <param>elements the cells.</param>
      <param>zero the index of the first element.</param>
      <param>stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.</param>
      <throws>IllegalArgumentException if <tt>size<0</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix1D" startLine="68" endLine="72" />
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>values</tt>.
 * <tt>values</tt> is required to have the same number of cells as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values the values to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>values.length != size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="83" endLine="92">
      <scope startLine="84" endLine="87" />
      <scope startLine="88" endLine="90" />
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="98" endLine="107">
      <declaration type="int" name="index" />
      <declaration type="int" name="s" />
      <declaration type="double[]" name="elems" />
      <scope startLine="102" endLine="105" />
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[i] = function(x[i])</tt>.
 * (Iterates downwards from <tt>[size()-1]</tt> to <tt>[0]</tt>).
 * <p>
 * <b>Example:</b>
 * <pre>
 * // change each cell to its sine
 * matrix =   0.5      1.5      2.5       3.5 
 * matrix.assign(cern.jet.math.Functions.sin);
 * -->
 * matrix ==  0.479426 0.997495 0.598472 -0.350783
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>function a function object taking as argument the current cell's value.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="126" endLine="148">
      <declaration type="int" name="s" />
      <declaration type="int" name="i" />
      <declaration type="double[]" name="elems" />
      <scope startLine="133" endLine="140">
        <declaration type="double" name="multiplicator" />
        <scope startLine="136" endLine="139" />
        <comment>x[i] = mult*x[i]</comment>
      </scope>
      <scope startLine="141" endLine="146">
        <scope startLine="142" endLine="145" />
        <comment>the general case x[i] = f(x[i])</comment>
      </scope>
      <comment>specialization for speed</comment>
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same size.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>source   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>size() != other.size()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="158" endLine="192">
      <scope startLine="160" endLine="162" />
      <declaration type="DenseDoubleMatrix1D" name="other" />
      <scope startLine="166" endLine="169">
        <comment>quickest</comment>
      </scope>
      <scope startLine="170" endLine="176">
        <declaration type="DoubleMatrix1D" name="c" />
        <scope startLine="172" endLine="174" />
        <comment>should not happen</comment>
      </scope>
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="otherElems" />
      <declaration type="int" name="s" />
      <declaration type="int" name="ys" />
      <declaration type="int" name="index" />
      <declaration type="int" name="otherIndex" />
      <scope startLine="186" endLine="190" />
      <comment>overriden for performance only</comment>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[i] = function(x[i],y[i])</tt>.
 * (Iterates downwards from <tt>[size()-1]</tt> to <tt>[0]</tt>).
 * <p>
 * <b>Example:</b>
 * <pre>
 * // assign x[i] = x[i]<sup>y[i]</sup>
 * m1 = 0 1 2 3;
 * m2 = 0 2 4 6;
 * m1.assign(m2, cern.jet.math.Functions.pow);
 * -->
 * m1 == 1 1 16 729
 * // for non-standard functions there is no shortcut: 
 * m1.assign(m2,
 * &nbsp;&nbsp;&nbsp;new DoubleDoubleFunction() {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public double apply(double x, double y) { return Math.pow(x,y); }
 * &nbsp;&nbsp;&nbsp;}
 * );
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>y the secondary matrix to operate on.</param>
      <param>function a function object taking as first argument the current cell's value of <tt>this</tt>,
 * and as second argument the current cell's value of <tt>y</tt>,</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>size() != y.size()</tt>.</throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="assign" startLine="222" endLine="288">
      <scope startLine="224" endLine="226" />
      <declaration type="DenseDoubleMatrix1D" name="other" />
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="otherElems" />
      <declaration type="int" name="s" />
      <declaration type="int" name="ys" />
      <declaration type="int" name="index" />
      <declaration type="int" name="otherIndex" />
      <scope startLine="239" endLine="245">
        <scope startLine="240" endLine="244" />
        <comment>x[i] = x[i] * y[i]</comment>
      </scope>
      <scope startLine="246" endLine="252">
        <scope startLine="247" endLine="251" />
        <comment>x[i] = x[i] / y[i]</comment>
      </scope>
      <scope startLine="253" endLine="279">
        <declaration type="double" name="multiplicator" />
        <scope startLine="255" endLine="257" />
        <scope startLine="258" endLine="264">
          <scope startLine="259" endLine="263" />
        </scope>
        <scope startLine="265" endLine="271">
          <scope startLine="266" endLine="270" />
        </scope>
        <scope startLine="272" endLine="278">
          <scope startLine="273" endLine="277" />
        </scope>
        <comment>x[i] = x[i] + 0*y[i]</comment>
        <comment>x[i] = x[i] + y[i]</comment>
        <comment>x[i] = x[i] - y[i]</comment>
        <comment>the general case x[i] = x[i] + mult*y[i]</comment>
      </scope>
      <scope startLine="280" endLine="286">
        <scope startLine="281" endLine="285" />
        <comment>the general case x[i] = f(x[i],y[i])</comment>
      </scope>
      <comment>overriden for performance only</comment>
      <comment>specialized for speed</comment>
    </method>
    <javadoc>
      <text>* Returns the number of cells having non-zero values, but at most maxCardinality; ignores tolerance.</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="292" endLine="303">
      <declaration type="int" name="cardinality" />
      <declaration type="int" name="index" />
      <declaration type="int" name="s" />
      <declaration type="double[]" name="elems" />
      <declaration type="int" name="i" />
      <scope startLine="298" endLine="301" />
    </method>
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>index</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>index&lt;0 || index&gt;=size()</tt>.</text>
      <param>index   the index of the cell.</param>
      <return>the value of the specified cell.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="314" endLine="319">
      <comment>if (debug) if (index<0 || index>=size) checkIndex(index);</comment>
      <comment>return elements[index(index)];</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share at least one identical cell.</text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="323" endLine="333">
      <scope startLine="324" endLine="327">
        <declaration type="SelectedDenseDoubleMatrix1D" name="otherMatrix" />
      </scope>
      <scope startLine="328" endLine="331">
        <declaration type="DenseDoubleMatrix1D" name="otherMatrix" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array.
 * You may want to override this method for performance.</text>
      <param>rank   the rank of the element.</param>
    </javadoc>
    <method type="int" name="index" startLine="340" endLine="344">
      <comment>overriden for manual inlining only</comment>
      <comment>return _offset(_rank(rank));</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified size.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix1D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix1D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix1D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>size the number of cell the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like" startLine="354" endLine="356" />
    <javadoc>
      <text>* Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix1D</tt> the new matrix must be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix1D</tt> the new matrix must be of type <tt>SparseDoubleMatrix2D</tt>, etc.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like2D" startLine="366" endLine="368" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>index</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>index&lt;0 || index&gt;=size()</tt>.</text>
      <param>index   the index of the cell.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="379" endLine="384">
      <comment>if (debug) if (index<0 || index>=size) checkIndex(index);</comment>
      <comment>elements[index(index)] = value;</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Swaps each element <tt>this[i]</tt> with <tt>other[i]</tt>.</text>
      <throws>IllegalArgumentException if <tt>size() != other.size()</tt>.</throws>
    </javadoc>
    <method type="void" name="swap" startLine="389" endLine="414">
      <scope startLine="391" endLine="393" />
      <declaration type="DenseDoubleMatrix1D" name="y" />
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="otherElems" />
      <declaration type="int" name="s" />
      <declaration type="int" name="ys" />
      <declaration type="int" name="index" />
      <declaration type="int" name="otherIndex" />
      <scope startLine="406" endLine="412">
        <declaration type="double" name="tmp" />
      </scope>
      <comment>overriden for performance only</comment>
    </method>
    <javadoc>
      <text>* Fills the cell values into the specified 1-dimensional array.
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.
 * After this call returns the array <tt>values</tt> has the form 
 * <br>
 * <tt>for (int i=0; i < size(); i++) values[i] = get(i);</tt></text>
      <throws>IllegalArgumentException if <tt>values.length < size()</tt>.</throws>
    </javadoc>
    <method type="void" name="toArray" startLine="424" endLine="428" />
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>offsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewSelectionLike" startLine="435" endLine="437" />
    <javadoc>
      <text>* Returns the dot product of two vectors x and y, which is <tt>Sum(x[i]*y[i])</tt>.
 * Where <tt>x == this</tt>.
 * Operates on cells at indexes <tt>from .. Min(size(),y.size(),from+length)-1</tt>.</text>
      <param>y the second vector.</param>
      <param>from the first index to be considered.</param>
      <param>length the number of cells to be considered.</param>
      <return>the sum of products; zero if <tt>from<0 || length<0</tt>.</return>
    </javadoc>
    <method type="double" name="zDotProduct" startLine="447" endLine="491">
      <scope startLine="448" endLine="450" />
      <declaration type="DenseDoubleMatrix1D" name="yy" />
      <declaration type="int" name="tail" />
      <declaration type="int" name="min" />
      <declaration type="int" name="i" />
      <declaration type="int" name="j" />
      <declaration type="int" name="s" />
      <declaration type="int" name="ys" />
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="yElems" />
      <declaration type="double" name="sum" />
      <scope startLine="481" endLine="486" />
      <scope startLine="487" endLine="489" />
      <comment>unoptimized
for (int k = min; --k >= 0;) {
sum += elems[i]  yElems[j];
i += s;
j += ys;
}</comment>
      <comment>optimized</comment>
      <comment>loop unrolling</comment>
    </method>
    <javadoc>
      <text>* Returns the sum of all cells; <tt>Sum( x[i] )</tt>.</text>
      <return>the sum.</return>
    </javadoc>
    <method type="double" name="zSum" startLine="496" endLine="507">
      <declaration type="double" name="sum" />
      <declaration type="int" name="s" />
      <declaration type="int" name="i" />
      <declaration type="double[]" name="elems" />
      <scope startLine="502" endLine="505" />
    </method>
  </class>
</source>
