<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <import name="cern.colt.matrix.DoubleMatrix3D" />
  <class name="DenseDoubleMatrix3D" extends="DoubleMatrix3D" startLine="13">
    <javadoc>
      <text>* Dense 3-d matrix holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * Internally holds one single contigous one-dimensional array, addressed in (in decreasing order of significance): slice major, row major, column major.
 * Note that this implementation is not synchronized.
 * <p>
 * <b>Memory requirements:</b>
 * <p>
 * <tt>memory [bytes] = 8*slices()*rows()*columns()</tt>.
 * Thus, a 100*100*100 matrix uses 8 MB.
 * <p>
 * <b>Time complexity:</b>
 * <p>
 * <tt>O(1)</tt> (i.e. constant time) for the basic operations
 * <tt>get</tt>, <tt>getQuick</tt>, <tt>set</tt>, <tt>setQuick</tt> and <tt>size</tt>,
 * <p>
 * Applications demanding utmost speed can exploit knowledge about the internal addressing.
 * Setting/getting values in a loop slice-by-slice, row-by-row, column-by-column is quicker than, for example, column-by-column, row-by-row, slice-by-slice.
 * Thus
 * <pre>
 * for (int slice=0; slice < slices; slice++) {
 * for (int row=0; row < rows; row++) {
 * for (int column=0; column < columns; column++) {
 * matrix.setQuick(slice,row,column,someValue);
 * }		    
 * }
 * }
 * </pre>
 * is quicker than
 * <pre>
 * for (int column=0; column < columns; column++) {
 * for (int row=0; row < rows; row++) {
 * for (int slice=0; slice < slices; slice++) {
 * matrix.setQuick(slice,row,column,someValue);
 * }
 * }
 * }
 * </pre></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <javadoc>
      <text>* The elements of this matrix.
 * elements are stored in slice major, then row major, then column major, in order of significance, i.e.
 * index==slice*sliceStride+ row*rowStride + column*columnStride
 * i.e. {slice0 row0..m}, {slice1 row0..m}, ..., {sliceN row0..m}
 * with each row storead as 
 * {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m}</text>
    </javadoc>
    <declaration type="double[]" name="elements" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[slice][row][column]</tt>
 * and have exactly the same number of rows in in every slice and exactly the same number of columns in in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= slice &lt; values.length: values[slice].length != values[slice-1].length</tt>.</throws>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values[0].length: values[slice][row].length != values[slice][row-1].length</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix3D" startLine="78" endLine="81" />
    <javadoc>
      <text>* Constructs a matrix with a given number of slices, rows and columns.
 * All entries are initially <tt>0</tt>.</text>
      <param>slices the number of slices the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>(double)slices*columns*rows > Integer.MAX_VALUE</tt>.</throws>
      <throws>IllegalArgumentException if <tt>slices<0 || rows<0 || columns<0</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix3D" startLine="91" endLine="94" />
    <javadoc>
      <text>* Constructs a view with the given parameters.</text>
      <param>slices the number of slices the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>elements the cells.</param>
      <param>sliceZero the position of the first element.</param>
      <param>rowZero the position of the first element.</param>
      <param>columnZero the position of the first element.</param>
      <param>sliceStride the number of elements between two slices, i.e. <tt>index(k+1,i,j)-index(k,i,j)</tt>.</param>
      <param>rowStride the number of elements between two rows, i.e. <tt>index(k,i+1,j)-index(k,i,j)</tt>.</param>
      <param>columnnStride the number of elements between two columns, i.e. <tt>index(k,i,j+1)-index(k,i,j)</tt>.</param>
      <throws>IllegalArgumentException if <tt>(double)slices*columns*rows > Integer.MAX_VALUE</tt>.</throws>
      <throws>IllegalArgumentException if <tt>slices<0 || rows<0 || columns<0</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix3D" startLine="110" endLine="114" />
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>values</tt>.
 * <tt>values</tt> is required to have the form <tt>values[slice][row][column]</tt>
 * and have exactly the same number of slices, rows and columns as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values the values to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows()</tt>.</throws>
      <throws>IllegalArgumentException if <tt>for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix3D" name="assign" startLine="127" endLine="146">
      <scope startLine="128" endLine="141">
        <declaration type="int" name="i" />
        <scope startLine="131" endLine="140">
          <declaration type="double[][]" name="currentSlice" />
          <scope startLine="134" endLine="139">
            <declaration type="double[]" name="currentRow" />
          </scope>
        </scope>
      </scope>
      <scope startLine="142" endLine="144" />
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of slices, rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>source   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>slices() != source.slices() || rows() != source.rows() || columns() != source.columns()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix3D" name="assign" startLine="156" endLine="177">
      <scope startLine="158" endLine="160" />
      <declaration type="DenseDoubleMatrix3D" name="other" />
      <scope startLine="164" endLine="170">
        <declaration type="DoubleMatrix3D" name="c" />
        <scope startLine="166" endLine="168" />
        <comment>should not happen</comment>
      </scope>
      <scope startLine="172" endLine="175">
        <comment>quickest</comment>
      </scope>
      <comment>overriden for performance only</comment>
    </method>
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[slice,row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="190" endLine="195">
      <comment>if (debug) if (slice<0 || slice>=slices || row<0 || row>=rows || column<0 || column>=columns) throw new IndexOutOfBoundsException("slice:"+slice+", row:"+row+", column:"+column);</comment>
      <comment>return elements[index(slice,row,column)];</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share common cells.
 * More formally, returns <tt>true</tt> if <tt>other != null</tt> and at least one of the following conditions is met
 * <ul>
 * <li>the receiver is a view of the other matrix
 * <li>the other matrix is a view of the receiver
 * <li><tt>this == other</tt>
 * </ul></text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="205" endLine="215">
      <scope startLine="206" endLine="209">
        <declaration type="SelectedDenseDoubleMatrix3D" name="otherMatrix" />
      </scope>
      <scope startLine="210" endLine="213">
        <declaration type="DenseDoubleMatrix3D" name="otherMatrix" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the third-coordinate.</param>
    </javadoc>
    <method type="int" name="index" startLine="223" endLine="227">
      <comment>return _sliceOffset(_sliceRank(slice)) + _rowOffset(_rowRank(row)) + _columnOffset(_columnRank(column));</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of slices, rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix3D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix3D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix3D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix3D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>slices the number of slices the matrix shall have.</param>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix3D" name="like" startLine="239" endLine="241" />
    <javadoc>
      <text>* Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix3D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix3D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>rowZero the position of the first element.</param>
      <param>columnZero the position of the first element.</param>
      <param>rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.</param>
      <param>columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like2D" startLine="255" endLine="257" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[slice,row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column()</tt>.</text>
      <param>slice   the index of the slice-coordinate.</param>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="270" endLine="275">
      <comment>if (debug) if (slice<0 || slice>=slices || row<0 || row>=rows || column<0 || column>=columns) throw new IndexOutOfBoundsException("slice:"+slice+", row:"+row+", column:"+column);</comment>
      <comment>elements[index(slice,row,column)] = value;</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>sliceOffsets the offsets of the visible elements.</param>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <method type="DoubleMatrix3D" name="viewSelectionLike" startLine="284" endLine="286" />
    <javadoc>
      <text>* 27 neighbor stencil transformation. For efficient finite difference operations.
 * Applies a function to a moving <tt>3 x 3 x 3</tt> window.
 * Does nothing if <tt>rows() < 3 || columns() < 3 || slices() < 3</tt>.
 * <pre>
 * B[k,i,j] = function.apply(
 * &nbsp;&nbsp;&nbsp;A[k-1,i-1,j-1], A[k-1,i-1,j], A[k-1,i-1,j+1],
 * &nbsp;&nbsp;&nbsp;A[k-1,i,  j-1], A[k-1,i,  j], A[k-1,i,  j+1],
 * &nbsp;&nbsp;&nbsp;A[k-1,i+1,j-1], A[k-1,i+1,j], A[k-1,i+1,j+1],
 * &nbsp;&nbsp;&nbsp;A[k  ,i-1,j-1], A[k  ,i-1,j], A[k  ,i-1,j+1],
 * &nbsp;&nbsp;&nbsp;A[k  ,i,  j-1], A[k  ,i,  j], A[k  ,i,  j+1],
 * &nbsp;&nbsp;&nbsp;A[k  ,i+1,j-1], A[k  ,i+1,j], A[k  ,i+1,j+1],
 * &nbsp;&nbsp;&nbsp;A[k+1,i-1,j-1], A[k+1,i-1,j], A[k+1,i-1,j+1],
 * &nbsp;&nbsp;&nbsp;A[k+1,i,  j-1], A[k+1,i,  j], A[k+1,i,  j+1],
 * &nbsp;&nbsp;&nbsp;A[k+1,i+1,j-1], A[k+1,i+1,j], A[k+1,i+1,j+1]
 * &nbsp;&nbsp;&nbsp;)
 * x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - 
 * x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - 
 * x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x 
 * - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x 
 * - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x 
 * </pre>
 * Make sure that cells of <tt>this</tt> and <tt>B</tt> do not overlap.
 * In case of overlapping views, behaviour is unspecified.
 * </pre>
 * <p>
 * <b>Example:</b>
 * <pre>
 * final double alpha = 0.25;
 * final double beta = 0.75;
 * cern.colt.function.Double27Function f = new cern.colt.function.Double27Function() {
 * &nbsp;&nbsp;&nbsp;public final double apply(
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a000, double a001, double a002,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a010, double a011, double a012,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a020, double a021, double a022,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a100, double a101, double a102,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a110, double a111, double a112,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a120, double a121, double a122,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a200, double a201, double a202,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a210, double a211, double a212,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a220, double a221, double a222) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return beta*a111 + alpha*(a000 + ... + a222);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 * };
 * A.zAssign27Neighbors(B,f);
 * </pre></text>
      <param>B the matrix to hold the results.</param>
      <param>function the function to be applied to the 27 cells.</param>
      <throws>NullPointerException if <tt>function==null</tt>.</throws>
      <throws>IllegalArgumentException if <tt>rows() != B.rows() || columns() != B.columns() || slices() != B.slices() </tt>.</throws>
    </javadoc>
    <method type="void" name="zAssign27Neighbors" startLine="345" endLine="455">
      <scope startLine="347" endLine="350" />
      <declaration type="int" name="r" />
      <declaration type="int" name="c" />
      <declaration type="DenseDoubleMatrix3D" name="BB" />
      <declaration type="int" name="A_ss" />
      <declaration type="int" name="A_rs" />
      <declaration type="int" name="B_rs" />
      <declaration type="int" name="A_cs" />
      <declaration type="int" name="B_cs" />
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="B_elems" />
      <scope startLine="367" endLine="454">
        <declaration type="int" name="A_index" />
        <declaration type="int" name="B_index" />
        <scope startLine="371" endLine="453">
          <declaration type="int" name="A002" />
          <declaration type="int" name="A012" />
          <declaration type="int" name="A022" />
          <declaration type="int" name="A102" />
          <declaration type="int" name="A112" />
          <declaration type="int" name="A122" />
          <declaration type="int" name="A202" />
          <declaration type="int" name="A212" />
          <declaration type="int" name="A222" />
          <declaration type="double" name="a000" />
          <declaration type="double" name="a010" />
          <declaration type="double" name="a020" />
          <declaration type="double" name="a100" />
          <declaration type="double" name="a110" />
          <declaration type="double" name="a120" />
          <declaration type="double" name="a200" />
          <declaration type="double" name="a210" />
          <declaration type="double" name="a220" />
          <declaration type="int" name="B11" />
          <scope startLine="409" endLine="450" />
        </scope>
        <comment>in each step 18 cells can be remembered in registers - they don't need to be reread from slow memory</comment>
        <comment>in each step 9 instead of 27 cells need to be read from memory.</comment>
        <comment>move remembered cells</comment>
      </scope>
      <comment>overridden for performance only</comment>
      <comment>nothing to do</comment>
    </method>
  </class>
</source>
