<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="DenseDoubleMatrix2D" extends="DoubleMatrix2D" startLine="13">
    <javadoc>
      <text>* Dense 2-d matrix holding <tt>double</tt> elements.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation:</b>
 * <p>
 * Internally holds one single contigous one-dimensional array, addressed in row major. 
 * Note that this implementation is not synchronized.
 * <p>
 * <b>Memory requirements:</b>
 * <p>
 * <tt>memory [bytes] = 8*rows()*columns()</tt>.
 * Thus, a 1000*1000 matrix uses 8 MB.
 * <p>
 * <b>Time complexity:</b>
 * <p>
 * <tt>O(1)</tt> (i.e. constant time) for the basic operations
 * <tt>get</tt>, <tt>getQuick</tt>, <tt>set</tt>, <tt>setQuick</tt> and <tt>size</tt>,
 * <p>
 * Cells are internally addressed in row-major.
 * Applications demanding utmost speed can exploit this fact.
 * Setting/getting values in a loop row-by-row is quicker than column-by-column.
 * Thus
 * <pre>
 * for (int row=0; row < rows; row++) {
 * for (int column=0; column < columns; column++) {
 * matrix.setQuick(row,column,someValue);
 * }
 * }
 * </pre>
 * is quicker than
 * <pre>
 * for (int column=0; column < columns; column++) {
 * for (int row=0; row < rows; row++) {
 * matrix.setQuick(row,column,someValue);
 * }
 * }
 * </pre></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* The elements of this matrix.
 * elements are stored in row major, i.e.
 * index==row*columns + column
 * columnOf(index)==index%columns
 * rowOf(index)==index/columns
 * i.e. {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m}</text>
    </javadoc>
    <declaration type="double[]" name="elements" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of columns in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix2D" startLine="75" endLine="78" />
    <javadoc>
      <text>* Constructs a matrix with a given number of rows and columns.
 * All entries are initially <tt>0</tt>.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix2D" startLine="86" endLine="89" />
    <javadoc>
      <text>* Constructs a view with the given parameters.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <param>elements the cells.</param>
      <param>rowZero the position of the first element.</param>
      <param>columnZero the position of the first element.</param>
      <param>rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.</param>
      <param>columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.</param>
      <throws>IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt> or flip's are illegal.</throws>
    </javadoc>
    <method type="constructor" name="DenseDoubleMatrix2D" startLine="101" endLine="105" />
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>values</tt>.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of rows and columns as the receiver.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values the values to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="117" endLine="132">
      <scope startLine="118" endLine="127">
        <declaration type="int" name="i" />
        <scope startLine="121" endLine="126">
          <declaration type="double[]" name="currentRow" />
        </scope>
      </scope>
      <scope startLine="128" endLine="130" />
    </method>
    <javadoc>
      <text>* Sets all cells to the state specified by <tt>value</tt>.</text>
      <param>value the value to be filled into the cells.</param>
      <return><tt>this</tt> (for convenience only).</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="138" endLine="151">
      <declaration type="double[]" name="elems" />
      <declaration type="int" name="index" />
      <declaration type="int" name="cs" />
      <declaration type="int" name="rs" />
      <scope startLine="143" endLine="149">
        <scope startLine="144" endLine="147" />
      </scope>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[row,col] = function(x[row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * matrix = 2 x 2 matrix
 * 0.5 1.5      
 * 2.5 3.5
 * // change each cell to its sine
 * matrix.assign(cern.jet.math.Functions.sin);
 * -->
 * 2 x 2 matrix
 * 0.479426  0.997495 
 * 0.598472 -0.350783
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>function a function object taking as argument the current cell's value.</param>
      <return><tt>this</tt> (for convenience only).</return>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="174" endLine="204">
      <declaration type="double[]" name="elems" />
      <declaration type="int" name="index" />
      <declaration type="int" name="cs" />
      <declaration type="int" name="rs" />
      <scope startLine="182" endLine="193">
        <declaration type="double" name="multiplicator" />
        <scope startLine="186" endLine="192">
          <scope startLine="187" endLine="190" />
        </scope>
        <comment>x[i] = mult*x[i]</comment>
        <comment>the general case</comment>
      </scope>
      <scope startLine="194" endLine="202">
        <scope startLine="195" endLine="201">
          <scope startLine="196" endLine="199" />
        </scope>
        <comment>the general case x[i] = f(x[i])</comment>
      </scope>
      <comment>specialization for speed</comment>
    </method>
    <javadoc>
      <text>* Replaces all cell values of the receiver with the values of another matrix.
 * Both matrices must have the same number of rows and columns.
 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces <i>as if</i> using an intermediate auxiliary deep copy of <tt>other</tt>.</text>
      <param>source   the source matrix to copy from (may be identical to the receiver).</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt></throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="214" endLine="256">
      <scope startLine="216" endLine="218" />
      <declaration type="DenseDoubleMatrix2D" name="other" />
      <scope startLine="223" endLine="226">
        <comment>quickest</comment>
      </scope>
      <scope startLine="228" endLine="234">
        <declaration type="DoubleMatrix2D" name="c" />
        <scope startLine="230" endLine="232" />
        <comment>should not happen</comment>
      </scope>
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="otherElems" />
      <declaration type="int" name="cs" />
      <declaration type="int" name="ocs" />
      <declaration type="int" name="rs" />
      <declaration type="int" name="ors" />
      <declaration type="int" name="otherIndex" />
      <declaration type="int" name="index" />
      <scope startLine="246" endLine="254">
        <scope startLine="247" endLine="251" />
      </scope>
      <comment>overriden for performance only</comment>
      <comment>nothing to do</comment>
    </method>
    <javadoc>
      <text>* Assigns the result of a function to each cell; <tt>x[row,col] = function(x[row,col],y[row,col])</tt>.
 * <p>
 * <b>Example:</b>
 * <pre>
 * // assign x[row,col] = x[row,col]<sup>y[row,col]</sup>
 * m1 = 2 x 2 matrix 
 * 0 1 
 * 2 3
 * m2 = 2 x 2 matrix 
 * 0 2 
 * 4 6
 * m1.assign(m2, cern.jet.math.Functions.pow);
 * -->
 * m1 == 2 x 2 matrix
 * 1   1 
 * 16 729
 * </pre>
 * For further examples, see the <a href="package-summary.html#FunctionObjects">package doc</a>.</text>
      <param>y the secondary matrix to operate on.</param>
      <param>function a function object taking as first argument the current cell's value of <tt>this</tt>,
 * and as second argument the current cell's value of <tt>y</tt>,</param>
      <return><tt>this</tt> (for convenience only).</return>
      <throws>IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt></throws>
      <see>cern.jet.math.Functions</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="assign" startLine="286" endLine="379">
      <scope startLine="288" endLine="290" />
      <declaration type="DenseDoubleMatrix2D" name="other" />
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="otherElems" />
      <declaration type="int" name="cs" />
      <declaration type="int" name="ocs" />
      <declaration type="int" name="rs" />
      <declaration type="int" name="ors" />
      <declaration type="int" name="otherIndex" />
      <declaration type="int" name="index" />
      <scope startLine="306" endLine="316">
        <scope startLine="307" endLine="315">
          <scope startLine="308" endLine="312" />
        </scope>
        <comment>x[i] = x[i] * y[i]</comment>
      </scope>
      <scope startLine="317" endLine="327">
        <scope startLine="318" endLine="326">
          <scope startLine="319" endLine="323" />
        </scope>
        <comment>x[i] = x[i] / y[i]</comment>
      </scope>
      <scope startLine="328" endLine="366">
        <declaration type="double" name="multiplicator" />
        <scope startLine="330" endLine="332" />
        <scope startLine="333" endLine="343">
          <scope startLine="334" endLine="342">
            <scope startLine="335" endLine="339" />
          </scope>
        </scope>
        <scope startLine="344" endLine="354">
          <scope startLine="345" endLine="353">
            <scope startLine="346" endLine="350" />
          </scope>
        </scope>
        <scope startLine="355" endLine="365">
          <scope startLine="356" endLine="364">
            <scope startLine="357" endLine="361" />
          </scope>
        </scope>
        <comment>x[i] = x[i] + 0*y[i]</comment>
        <comment>x[i] = x[i] + y[i]</comment>
        <comment>x[i] = x[i] - y[i]</comment>
        <comment>the general case</comment>
        <comment>x[i] = x[i] + mult*y[i]</comment>
      </scope>
      <scope startLine="367" endLine="377">
        <scope startLine="368" endLine="376">
          <scope startLine="369" endLine="373" />
        </scope>
        <comment>the general case x[i] = f(x[i],y[i])</comment>
      </scope>
      <comment>overriden for performance only</comment>
      <comment>specialized for speed</comment>
    </method>
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="391" endLine="396">
      <comment>if (debug) if (column<0 || column>=columns || row<0 || row>=rows) throw new IndexOutOfBoundsException("row:"+row+", column:"+column);</comment>
      <comment>return elements[index(row,column)];</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if both matrices share common cells.
 * More formally, returns <tt>true</tt> if <tt>other != null</tt> and at least one of the following conditions is met
 * <ul>
 * <li>the receiver is a view of the other matrix
 * <li>the other matrix is a view of the receiver
 * <li><tt>this == other</tt>
 * </ul></text>
    </javadoc>
    <method type="boolean" name="haveSharedCellsRaw" startLine="406" endLine="416">
      <scope startLine="407" endLine="410">
        <declaration type="SelectedDenseDoubleMatrix2D" name="otherMatrix" />
      </scope>
      <scope startLine="411" endLine="414">
        <declaration type="DenseDoubleMatrix2D" name="otherMatrix" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
    </javadoc>
    <method type="int" name="index" startLine="423" endLine="427">
      <comment>return super.index(row,column);</comment>
      <comment>manually inlined for speed:</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like" startLine="438" endLine="440" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="449" endLine="451" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <param>zero the index of the first element.</param>
      <param>stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="462" endLine="464" />
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="476" endLine="481">
      <comment>if (debug) if (column<0 || column>=columns || row<0 || row>=rows) throw new IndexOutOfBoundsException("row:"+row+", column:"+column);</comment>
      <comment>elements[index(row,column)] = value;</comment>
      <comment>manually inlined:</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSelectionLike" startLine="489" endLine="491" />
    <javadoc>
      <text>* 8 neighbor stencil transformation. For efficient finite difference operations.
 * Applies a function to a moving <tt>3 x 3</tt> window.
 * Does nothing if <tt>rows() < 3 || columns() < 3</tt>.
 * <pre>
 * B[i,j] = function.apply(
 * &nbsp;&nbsp;&nbsp;A[i-1,j-1], A[i-1,j], A[i-1,j+1],
 * &nbsp;&nbsp;&nbsp;A[i,  j-1], A[i,  j], A[i,  j+1],
 * &nbsp;&nbsp;&nbsp;A[i+1,j-1], A[i+1,j], A[i+1,j+1]
 * &nbsp;&nbsp;&nbsp;)
 * x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - 
 * x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - 
 * x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x 
 * - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x 
 * - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x 
 * </pre>
 * Make sure that cells of <tt>this</tt> and <tt>B</tt> do not overlap.
 * In case of overlapping views, behaviour is unspecified.
 * </pre>
 * <p>
 * <b>Example:</b>
 * <pre>
 * final double alpha = 0.25;
 * final double beta = 0.75;
 * // 8 neighbors
 * cern.colt.function.Double9Function f = new cern.colt.function.Double9Function() {
 * &nbsp;&nbsp;&nbsp;public final double apply(
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return beta*a11 + alpha*(a00+a01+a02 + a10+a12 + a20+a21+a22);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 * };
 * A.zAssign8Neighbors(B,f);
 * // 4 neighbors
 * cern.colt.function.Double9Function g = new cern.colt.function.Double9Function() {
 * &nbsp;&nbsp;&nbsp;public final double apply(
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12,
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return beta*a11 + alpha*(a01+a10+a12+a21);
 * &nbsp;&nbsp;&nbsp;}
 * C.zAssign8Neighbors(B,g); // fast, even though it doesn't look like it
 * };
 * </pre></text>
      <param>B the matrix to hold the results.</param>
      <param>function the function to be applied to the 9 cells.</param>
      <throws>NullPointerException if <tt>function==null</tt>.</throws>
      <throws>IllegalArgumentException if <tt>rows() != B.rows() || columns() != B.columns()</tt>.</throws>
    </javadoc>
    <method type="void" name="zAssign8Neighbors" startLine="546" endLine="610">
      <scope startLine="552" endLine="555" />
      <declaration type="int" name="r" />
      <declaration type="int" name="c" />
      <declaration type="DenseDoubleMatrix2D" name="BB" />
      <declaration type="int" name="A_rs" />
      <declaration type="int" name="B_rs" />
      <declaration type="int" name="A_cs" />
      <declaration type="int" name="B_cs" />
      <declaration type="double[]" name="elems" />
      <declaration type="double[]" name="B_elems" />
      <declaration type="int" name="A_index" />
      <declaration type="int" name="B_index" />
      <scope startLine="573" endLine="608">
        <declaration type="double" name="a00" />
        <declaration type="double" name="a10" />
        <declaration type="double" name="a20" />
        <declaration type="int" name="B11" />
        <declaration type="int" name="A02" />
        <declaration type="int" name="A12" />
        <declaration type="int" name="A22" />
        <scope startLine="589" endLine="605" />
        <comment>in each step six cells can be remembered in registers - they don't need to be reread from slow memory</comment>
        <comment>A02+=A_cs;</comment>
        <comment>A12+=A_cs;</comment>
        <comment>A22+=A_cs;</comment>
        <comment>in each step 3 instead of 9 cells need to be read from memory.</comment>
        <comment>move remembered cells</comment>
      </scope>
      <comment>1. using only 4-5 out of the 9 cells in "function" is *not* the limiting factor for performance.</comment>
      <comment>2. if the "function" would be hardwired into the innermost loop, a speedup of 1.5-2.0 would be seen</comment>
      <comment>but then the multi-purpose interface is gone...</comment>
      <comment>nothing to do</comment>
    </method>
    <method type="DoubleMatrix1D" name="zMult" startLine="611" endLine="665">
      <declaration type="DenseDoubleMatrix1D" name="yy" />
      <declaration type="DenseDoubleMatrix1D" name="zz" />
      <declaration type="double[]" name="AElems" />
      <declaration type="double[]" name="yElems" />
      <declaration type="double[]" name="zElems" />
      <declaration type="int" name="As" />
      <declaration type="int" name="ys" />
      <declaration type="int" name="zs" />
      <declaration type="int" name="indexA" />
      <declaration type="int" name="indexY" />
      <declaration type="int" name="indexZ" />
      <declaration type="int" name="cols" />
      <scope startLine="634" endLine="662">
        <declaration type="double" name="sum" />
        <declaration type="int" name="i" />
        <declaration type="int" name="j" />
        <scope startLine="649" endLine="651" />
        <scope startLine="652" endLine="657" />
        <comment>not loop unrolled
for (int i=indexA, j=indexY, column=columns; --column >= 0; ) {
sum += AElems[i]  yElems[j];
i += As;
j += ys;
}</comment>
        <comment>loop unrolled</comment>
      </scope>
    </method>
    <method type="DoubleMatrix2D" name="zMult" startLine="666" endLine="792">
      <scope startLine="669" endLine="692">
        <scope startLine="672" endLine="674" />
        <scope startLine="675" endLine="678" />
        <comment>exploit quick sparse mult</comment>
        <comment>A*B = (B' * A')'</comment>
        <comment>final RCDoubleMatrix2D transB = new RCDoubleMatrix2D(B.columns,B.rows);
B.forEachNonZero(
new cern.colt.function.IntIntDoubleFunction() {
public double apply(int i, int j, double value) {
transB.setQuick(j,i,value);
return value;
}
}
);

return transB.zMult(this.viewDice(),C.viewDice()).viewDice();</comment>
      </scope>
      <declaration type="int" name="m" />
      <declaration type="int" name="n" />
      <declaration type="int" name="p" />
      <declaration type="DenseDoubleMatrix2D" name="BB" />
      <declaration type="DenseDoubleMatrix2D" name="CC" />
      <declaration type="double[]" name="AElems" />
      <declaration type="double[]" name="BElems" />
      <declaration type="double[]" name="CElems" />
      <declaration type="int" name="cA" />
      <declaration type="int" name="cB" />
      <declaration type="int" name="cC" />
      <declaration type="int" name="rA" />
      <declaration type="int" name="rB" />
      <declaration type="int" name="rC" />
      <declaration type="int" name="BLOCK_SIZE" />
      <declaration type="int" name="m_optimal" />
      <declaration type="int" name="blocks" />
      <declaration type="int" name="rr" />
      <scope startLine="744" endLine="790">
        <declaration type="int" name="jB" />
        <declaration type="int" name="indexA" />
        <declaration type="int" name="jC" />
        <scope startLine="751" endLine="789">
          <declaration type="int" name="iA" />
          <declaration type="int" name="iC" />
          <scope startLine="754" endLine="786">
            <declaration type="int" name="kA" />
            <declaration type="int" name="kB" />
            <declaration type="double" name="s" />
            <scope startLine="773" endLine="775" />
            <scope startLine="776" endLine="781" />
          </scope>
        </scope>
        <comment>not unrolled:
for (int k = n; --k >= 0; ) {
s += getQuick(i,k)  B.getQuick(k,j);
s += AElems[kA]  BElems[kB];
kB += rB;
kA += cA;
}</comment>
        <comment>loop unrolled</comment>
      </scope>
      <comment>overriden for performance only</comment>
      <comment>A is blocked to hide memory latency
xxxxxxx B
xxxxxxx
xxxxxxx
A
xxx     xxxxxxx C
xxx     xxxxxxx
---     -------
xxx     xxxxxxx
xxx     xxxxxxx
---     -------
xxx     xxxxxxx</comment>
      <comment>* 8 == Level 2 cache in bytes</comment>
      <comment>if (n+p == 0) return C;</comment>
      <comment>int m_optimal = (BLOCK_SIZE - n*p) / (n+p);</comment>
    </method>
    <javadoc>
      <text>* Returns the sum of all cells; <tt>Sum( x[i,j] )</tt>.</text>
      <return>the sum.</return>
    </javadoc>
    <method type="double" name="zSum" startLine="797" endLine="812">
      <declaration type="double" name="sum" />
      <declaration type="double[]" name="elems" />
      <declaration type="int" name="index" />
      <declaration type="int" name="cs" />
      <declaration type="int" name="rs" />
      <scope startLine="804" endLine="810">
        <scope startLine="805" endLine="808" />
      </scope>
    </method>
  </class>
</source>
