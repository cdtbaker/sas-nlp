<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.impl">
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <class name="WrapperDoubleMatrix2D" extends="DoubleMatrix2D" startLine="13">
    <javadoc>
      <text>* 2-d matrix holding <tt>double</tt> elements; either a view wrapping another matrix or a matrix whose views are wrappers.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 04/14/2000</version>
    </javadoc>
    <declaration type="DoubleMatrix2D" name="content" />
    <javadoc>
      <text>* Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of columns in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.</text>
      <param>values The values to be filled into the new matrix.</param>
      <throws>IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.</throws>
    </javadoc>
    <method type="constructor" name="WrapperDoubleMatrix2D" startLine="34" endLine="37" />
    <javadoc>
      <text>* Returns the content of this matrix if it is a wrapper; or <tt>this</tt> otherwise.
 * Override this method in wrappers.</text>
    </javadoc>
    <method type="DoubleMatrix2D" name="getContent" startLine="42" endLine="44" />
    <javadoc>
      <text>* Returns the matrix cell value at coordinate <tt>[row,column]</tt>.
 * <p>Provided with invalid parameters this method may return invalid objects without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <return>the value at the specified coordinate.</return>
    </javadoc>
    <method type="double" name="getQuick" startLine="56" endLine="58" />
    <javadoc>
      <text>* Construct and returns a new empty matrix <i>of the same dynamic type</i> as the receiver, having the specified number of rows and columns.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must also be of type <tt>DenseDoubleMatrix2D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must also be of type <tt>SparseDoubleMatrix2D</tt>, etc.
 * In general, the new matrix should have internal parametrization as similar as possible.</text>
      <param>rows the number of rows the matrix shall have.</param>
      <param>columns the number of columns the matrix shall have.</param>
      <return>a new empty matrix of the same dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="like" startLine="69" endLine="71" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="80" endLine="82" />
    <javadoc>
      <text>* Construct and returns a new 1-d matrix <i>of the corresponding dynamic type</i>, sharing the same cells.
 * For example, if the receiver is an instance of type <tt>DenseDoubleMatrix2D</tt> the new matrix must be of type <tt>DenseDoubleMatrix1D</tt>,
 * if the receiver is an instance of type <tt>SparseDoubleMatrix2D</tt> the new matrix must be of type <tt>SparseDoubleMatrix1D</tt>, etc.</text>
      <param>size the number of cells the matrix shall have.</param>
      <param>offset the index of the first element.</param>
      <param>stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.</param>
      <return>a new matrix of the corresponding dynamic type.</return>
    </javadoc>
    <method type="DoubleMatrix1D" name="like1D" startLine="93" endLine="95">
      <comment>should never get called</comment>
    </method>
    <javadoc>
      <text>* Sets the matrix cell at coordinate <tt>[row,column]</tt> to the specified value.
 * <p>Provided with invalid parameters this method may access illegal indexes without throwing any exception.
 * <b>You should only use this method when you are absolutely sure that the coordinate is within bounds.</b>
 * Precondition (unchecked): <tt>0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows()</tt>.</text>
      <param>row   the index of the row-coordinate.</param>
      <param>column   the index of the column-coordinate.</param>
      <param>value the value to be filled into the specified cell.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="107" endLine="109" />
    <javadoc>
      <text>* Constructs and returns a new <i>slice view</i> representing the rows of the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>viewPart(...)</tt>), then apply this method to the sub-range view.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>viewColumn(0) ==></td>
 * <td valign="top">Matrix1D of size 2:<br>
 * 1, 4</td>
 * </tr>
 * </table></text>
      <param>column the column to fix.</param>
      <return>a new slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.</throws>
      <see>#viewRow(int)</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewColumn" startLine="132" endLine="134" />
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the column axis.
 * What used to be column <tt>0</tt> is now column <tt>columns()-1</tt>, ..., what used to be column <tt>columns()-1</tt> is now column <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>columnFlip ==></td>
 * <td valign="top">2 x 3 matrix:<br>
 * 3, 2, 1 <br>
 * 6, 5, 4</td>
 * <td>columnFlip ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new flip view.</return>
      <see>#viewRowFlip()</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewColumnFlip" startLine="160" endLine="171">
      <declaration type="DoubleMatrix2D" name="view" />
      <method type="double" name="getQuick" startLine="163" endLine="165" />
      <method type="void" name="setQuick" startLine="166" endLine="168" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>dice (transposition) view</i>; Swaps axes; example: 3 x 4 matrix --> 4 x 3 matrix.
 * The view has both dimensions exchanged; what used to be columns become rows, what used to be rows become columns.
 * In other words: <tt>view.get(row,column)==this.get(column,row)</tt>.
 * This is a zero-copy transposition, taking O(1), i.e. constant time.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
 * Use idioms like <tt>result = viewDice(A).copy()</tt> to generate an independent transposed matrix.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>transpose ==></td>
 * <td valign="top">3 x 2 matrix:<br>
 * 1, 4 <br>
 * 2, 5 <br>
 * 3, 6</td>
 * <td>transpose ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new dice view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewDice" startLine="200" endLine="212">
      <declaration type="DoubleMatrix2D" name="view" />
      <method type="double" name="getQuick" startLine="202" endLine="204" />
      <method type="void" name="setQuick" startLine="205" endLine="207" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>sub-range view</i> that is a <tt>height x width</tt> sub matrix starting at <tt>[row,column]</tt>.
 * Operations on the returned view can only be applied to the restricted range.
 * Any attempt to access coordinates not contained in the view will throw an <tt>IndexOutOfBoundsException</tt>.
 * <p>
 * <b>Note that the view is really just a range restriction:</b> 
 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
 * <p>
 * The view contains the cells from <tt>[row,column]</tt> to <tt>[row+height-1,column+width-1]</tt>, all inclusive.
 * and has <tt>view.rows() == height; view.columns() == width;</tt>.
 * A view's legal coordinates are again zero based, as usual.
 * In other words, legal coordinates of the view range from <tt>[0,0]</tt> to <tt>[view.rows()-1==height-1,view.columns()-1==width-1]</tt>.
 * As usual, any attempt to access a cell at a coordinate <tt>column&lt;0 || column&gt;=view.columns() || row&lt;0 || row&gt;=view.rows()</tt> will throw an <tt>IndexOutOfBoundsException</tt>.</text>
      <param>row   The index of the row-coordinate.</param>
      <param>column   The index of the column-coordinate.</param>
      <param>height   The height of the box.</param>
      <param>width   The width of the box.</param>
      <throws>IndexOutOfBoundsException if <tt>column<0 || width<0 || column+width>columns() || row<0 || height<0 || row+height>rows()</tt></throws>
      <return>the new view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewPart" startLine="236" endLine="250">
      <declaration type="DoubleMatrix2D" name="view" />
      <method type="double" name="getQuick" startLine="239" endLine="241" />
      <method type="void" name="setQuick" startLine="242" endLine="244" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>slice view</i> representing the columns of the given row.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To obtain a slice view on subranges, construct a sub-ranging view (<tt>viewPart(...)</tt>), then apply this method to the sub-range view.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>viewRow(0) ==></td>
 * <td valign="top">Matrix1D of size 3:<br>
 * 1, 2, 3</td>
 * </tr>
 * </table></text>
      <param>row the row to fix.</param>
      <return>a new slice view.</return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= rows()</tt>.</throws>
      <see>#viewColumn(int)</see>
    </javadoc>
    <method type="DoubleMatrix1D" name="viewRow" startLine="273" endLine="276" />
    <javadoc>
      <text>* Constructs and returns a new <i>flip view</i> along the row axis.
 * What used to be row <tt>0</tt> is now row <tt>rows()-1</tt>, ..., what used to be row <tt>rows()-1</tt> is now row <tt>0</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * <p> 
 * <b>Example:</b> 
 * <table border="0">
 * <tr nowrap> 
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * <td>rowFlip ==></td>
 * <td valign="top">2 x 3 matrix:<br>
 * 4, 5, 6 <br>
 * 1, 2, 3</td>
 * <td>rowFlip ==></td>
 * <td valign="top">2 x 3 matrix: <br>
 * 1, 2, 3<br>
 * 4, 5, 6 </td>
 * </tr>
 * </table></text>
      <return>a new flip view.</return>
      <see>#viewColumnFlip()</see>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewRowFlip" startLine="302" endLine="313">
      <declaration type="DoubleMatrix2D" name="view" />
      <method type="double" name="getQuick" startLine="305" endLine="307" />
      <method type="void" name="setQuick" startLine="308" endLine="310" />
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>selection view</i> that is a matrix holding the indicated cells.
 * There holds <tt>view.rows() == rowIndexes.length, view.columns() == columnIndexes.length</tt> and <tt>view.get(i,j) == this.get(rowIndexes[i],columnIndexes[j])</tt>.
 * Indexes can occur multiple times and can be in arbitrary order.
 * <p>
 * <b>Example:</b>
 * <pre>
 * this = 2 x 3 matrix:
 * 1, 2, 3
 * 4, 5, 6
 * rowIndexes     = (0,1)
 * columnIndexes  = (1,0,1,0)
 * -->
 * view = 2 x 4 matrix:
 * 2, 1, 2, 1
 * 5, 4, 5, 4
 * </pre>
 * Note that modifying the index arguments after this call has returned has no effect on the view.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
 * <p>
 * To indicate "all" rows or "all columns", simply set the respective parameter</text>
      <param>rowIndexes   The rows of the cells that shall be visible in the new view. To indicate that <i>all</i> rows shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <param>columnIndexes   The columns of the cells that shall be visible in the new view. To indicate that <i>all</i> columns shall be visible, simply set this parameter to <tt>null</tt>.</param>
      <return>the new view.</return>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= rowIndexes[i] < rows())</tt> for any <tt>i=0..rowIndexes.length()-1</tt>.</throws>
      <throws>IndexOutOfBoundsException if <tt>!(0 <= columnIndexes[i] < columns())</tt> for any <tt>i=0..columnIndexes.length()-1</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSelection" startLine="341" endLine="369">
      <scope startLine="343" endLine="346" />
      <scope startLine="347" endLine="350" />
      <declaration type="int[]" name="rix" />
      <declaration type="int[]" name="cix" />
      <declaration type="DoubleMatrix2D" name="view" />
      <method type="double" name="getQuick" startLine="358" endLine="360" />
      <method type="void" name="setQuick" startLine="361" endLine="363" />
      <comment>check for "all"</comment>
    </method>
    <javadoc>
      <text>* Construct and returns a new selection view.</text>
      <param>rowOffsets the offsets of the visible elements.</param>
      <param>columnOffsets the offsets of the visible elements.</param>
      <return>a new view.</return>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewSelectionLike" startLine="377" endLine="379">
      <comment>should never be called</comment>
    </method>
    <javadoc>
      <text>* Constructs and returns a new <i>stride view</i> which is a sub matrix consisting of every i-th cell.
 * More specifically, the view has <tt>this.rows()/rowStride</tt> rows and <tt>this.columns()/columnStride</tt> columns holding cells <tt>this.get(i*rowStride,j*columnStride)</tt> for all <tt>i = 0..rows()/rowStride - 1, j = 0..columns()/columnStride - 1</tt>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.</text>
      <param>rowStride the row step factor.</param>
      <param>columnStride the column step factor.</param>
      <return>a new view.</return>
      <throws>IndexOutOfBoundsException if <tt>rowStride<=0 || columnStride<=0</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="viewStrides" startLine="390" endLine="405">
      <declaration type="DoubleMatrix2D" name="view" />
      <method type="double" name="getQuick" startLine="393" endLine="395" />
      <method type="void" name="setQuick" startLine="396" endLine="398" />
    </method>
    <comment>The elements of the matrix.</comment>
  </class>
</source>
