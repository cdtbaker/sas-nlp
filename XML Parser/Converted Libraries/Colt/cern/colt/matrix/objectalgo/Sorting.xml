<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.objectalgo">
  <import name="cern.colt.function.IntComparator" />
  <import name="cern.colt.matrix.ObjectMatrix1D" />
  <import name="cern.colt.matrix.ObjectMatrix2D" />
  <import name="cern.colt.matrix.ObjectMatrix3D" />
  <class name="Sorting" extends="cern.colt.PersistentObject" startLine="15">
    <javadoc>
      <text>* Matrix quicksorts and mergesorts.
 * Use idioms like <tt>Sorting.quickSort.sort(...)</tt> and <tt>Sorting.mergeSort.sort(...)</tt>.
 * <p>
 * This is another case demonstrating one primary goal of this library: Delivering easy to use, yet very efficient APIs.
 * The sorts return convenient <i>sort views</i>.
 * This enables the usage of algorithms which scale well with the problem size:
 * For example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix.
 * This is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices.
 * The original matrix is left unaffected.
 * <p>
 * The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in turn, based on Bentley's and McIlroy's fine work).
 * The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
 * Mergesort is <i>stable</i> (by definition), while quicksort is not.
 * A stable sort is, for example, helpful, if matrices are sorted successively 
 * by multiple columns. It preserves the relative position of equal elements.</text>
      <see>cern.colt.GenericSorting</see>
      <see>cern.colt.Sorting</see>
      <see>java.util.Arrays</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.1, 25/May/2000</version>
    </javadoc>
    <javadoc>
      <text>* A prefabricated quicksort.</text>
    </javadoc>
    <declaration type="Sorting" name="quickSort" />
    <javadoc>
      <text>* A prefabricated mergesort.</text>
    </javadoc>
    <method type="void" name="runSort" startLine="49" endLine="51" />
    <method type="void" name="runSort" startLine="52" endLine="54" />
    <declaration type="Sorting" name="mergeSort" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="Sorting" startLine="59" endLine="59" />
    <method type="void" name="runSort" startLine="60" endLine="62" />
    <method type="void" name="runSort" startLine="63" endLine="65" />
    <javadoc>
      <text>* Sorts the vector into ascending order, according to the <i>natural ordering</i>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b> 
 * <table border="1" cellspacing="0">
 * <tr nowrap> 
 * <td valign="top"><tt> 7, 1, 3, 1<br>
 * </tt></td>
 * <td valign="top"> 
 * <p><tt> ==&gt; 1, 1, 3, 7<br>
 * The vector IS NOT SORTED.<br>
 * The new VIEW IS SORTED.</tt></p>
 * </td>
 * </tr>
 * </table></text>
      <param>vector the vector to be sorted.</param>
      <return>a new sorted vector (matrix) view. 
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="ObjectMatrix1D" name="sort" startLine="88" endLine="104">
      <declaration type="int[]" name="indexes" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="93" endLine="98">
        <declaration type="Comparable" name="av" />
        <declaration type="Comparable" name="bv" />
        <declaration type="int" name="r" />
      </method>
      <comment>row indexes to reorder instead of matrix itself</comment>
    </method>
    <javadoc>
      <text>* Sorts the vector into ascending order, according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * <pre>
 * // sort by sinus of cells
 * ObjectComparator comp = new ObjectComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(Object a, Object b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object as = Math.sin(a); Object bs = Math.sin(b);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as < bs ? -1 : as == bs ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * sorted = quickSort(vector,comp);
 * </pre></text>
      <param>vector the vector to be sorted.</param>
      <param>c the comparator to determine the order.</param>
      <return>a new matrix view sorted as specified.
 * <b>Note that the original vector (matrix) is left unaffected.</b></return>
    </javadoc>
    <method type="ObjectMatrix1D" name="sort" startLine="128" endLine="141">
      <declaration type="int[]" name="indexes" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="133" endLine="135" />
      <comment>row indexes to reorder instead of matrix itself</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix rows into ascending order, according to the <i>natural ordering</i> of the matrix values in the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b> 
 * <table border="1" cellspacing="0">
 * <tr nowrap> 
 * <td valign="top"><tt>4 x 2 matrix: <br>
 * 7, 6<br>
 * 5, 4<br>
 * 3, 2<br>
 * 1, 0 <br>
 * </tt></td>
 * <td align="left" valign="top"> 
 * <p><tt>column = 0;<br>
 * view = quickSort(matrix,column);<br>
 * System.out.println(view); </tt><tt><br>
 * ==> </tt></p>
 * </td>
 * <td valign="top"> 
 * <p><tt>4 x 2 matrix:<br>
 * 1, 0<br>
 * 3, 2<br>
 * 5, 4<br>
 * 7, 6</tt><br>
 * The matrix IS NOT SORTED.<br>
 * The new VIEW IS SORTED.</p>
 * </td>
 * </tr>
 * </table></text>
      <param>matrix the matrix to be sorted.</param>
      <param>column the index of the column inducing the order.</param>
      <return>a new matrix view having rows sorted by the given column.
 * <b>Note that the original matrix is left unaffected.</b></return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= matrix.columns()</tt>.</throws>
    </javadoc>
    <method type="ObjectMatrix2D" name="sort" startLine="180" endLine="201">
      <declaration type="int[]" name="rowIndexes" />
      <declaration type="ObjectMatrix1D" name="col" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="188" endLine="193">
        <declaration type="Comparable" name="av" />
        <declaration type="Comparable" name="bv" />
        <declaration type="int" name="r" />
      </method>
      <comment>row indexes to reorder instead of matrix itself</comment>
      <comment>view the matrix according to the reordered row indexes</comment>
      <comment>take all columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix rows according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * <pre>
 * // sort by sum of values in a row
 * ObjectMatrix1DComparator comp = new ObjectMatrix1DComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(ObjectMatrix1D a, ObjectMatrix1D b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object as = a.zSum(); Object bs = b.zSum();
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as < bs ? -1 : as == bs ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * sorted = quickSort(matrix,comp);
 * </pre></text>
      <param>matrix the matrix to be sorted.</param>
      <param>c the comparator to determine the order.</param>
      <return>a new matrix view having rows sorted as specified.
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="ObjectMatrix2D" name="sort" startLine="225" endLine="244">
      <declaration type="int[]" name="rowIndexes" />
      <declaration type="ObjectMatrix1D[]" name="views" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="233" endLine="236" />
      <comment>row indexes to reorder instead of matrix itself</comment>
      <comment>precompute views for speed</comment>
      <comment>return c.compare(matrix.viewRow(a), matrix.viewRow(b));</comment>
      <comment>view the matrix according to the reordered row indexes</comment>
      <comment>take all columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix slices into ascending order, according to the <i>natural ordering</i> of the matrix values in the given <tt>[row,column]</tt> position.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
 * <p>
 * The algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other.
 * Comparison is based on the cell <tt>[row,column]</tt> within a slice.
 * Let <tt>A</tt> and <tt>B</tt> be two 2-d slices. Then we have the following rules
 * <ul>
 * <li><tt>A &lt;  B  iff A.get(row,column) &lt;  B.get(row,column)</tt>
 * <li><tt>A == B iff A.get(row,column) == B.get(row,column)</tt>
 * <li><tt>A &gt;  B  iff A.get(row,column) &gt;  B.get(row,column)</tt>
 * </ul></text>
      <param>matrix the matrix to be sorted.</param>
      <param>row the index of the row inducing the order.</param>
      <param>column the index of the column inducing the order.</param>
      <return>a new matrix view having slices sorted by the values of the slice view <tt>matrix.viewRow(row).viewColumn(column)</tt>.
 * <b>Note that the original matrix is left unaffected.</b></return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= matrix.rows() || column < 0 || column >= matrix.columns()</tt>.</throws>
    </javadoc>
    <method type="ObjectMatrix3D" name="sort" startLine="266" endLine="288">
      <declaration type="int[]" name="sliceIndexes" />
      <declaration type="ObjectMatrix1D" name="sliceView" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="275" endLine="280">
        <declaration type="Comparable" name="av" />
        <declaration type="Comparable" name="bv" />
        <declaration type="int" name="r" />
      </method>
      <comment>indexes to reorder instead of matrix itself</comment>
      <comment>view the matrix according to the reordered slice indexes</comment>
      <comment>take all rows and columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix slices according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * <pre>
 * // sort by sum of values in a slice
 * ObjectMatrix2DComparator comp = new ObjectMatrix2DComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(ObjectMatrix2D a, ObjectMatrix2D b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object as = a.zSum(); Object bs = b.zSum();
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as < bs ? -1 : as == bs ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * sorted = quickSort(matrix,comp);
 * </pre></text>
      <param>matrix the matrix to be sorted.</param>
      <param>c the comparator to determine the order.</param>
      <return>a new matrix view having slices sorted as specified.
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="ObjectMatrix3D" name="sort" startLine="312" endLine="331">
      <declaration type="int[]" name="sliceIndexes" />
      <declaration type="ObjectMatrix2D[]" name="views" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="320" endLine="323" />
      <comment>indexes to reorder instead of matrix itself</comment>
      <comment>precompute views for speed</comment>
      <comment>return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));</comment>
      <comment>view the matrix according to the reordered slice indexes</comment>
      <comment>take all rows and columns in the original order</comment>
    </method>
    <comment>already has quicksort implemented</comment>
    <comment>override quicksort with mergesort</comment>
  </class>
</source>
