<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.doublealgo">
  <import name="hep.aida.bin.DynamicBin1D" />
  <import name="cern.colt.function.DoubleDoubleFunction" />
  <import name="cern.colt.matrix.DoubleFactory1D" />
  <import name="cern.colt.matrix.DoubleFactory2D" />
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <import name="cern.colt.matrix.DoubleMatrix3D" />
  <import name="cern.jet.random.engine.RandomEngine" />
  <class name="Statistic" extends="Object" startLine="19">
    <javadoc>
      <text>* Basic statistics operations on matrices.
 * Computation of covariance, correlation, distance matrix.
 * Random sampling views.
 * Conversion to histograms with and without OLAP cube operators.
 * Conversion to bins with retrieval of statistical bin measures.
 * Also see {@link cern.jet.stat} and {@link hep.aida.bin}, in particular {@link hep.aida.bin.DynamicBin1D}.
 * <p>
 * Examples:
 * <table border="1" cellspacing="0" dwcopytype="CopyTableRow">
 * <tr valign="top" align="center"> 
 * <td><tt>A</tt></td>
 * <td><tt>covariance(A)</tt></td>
 * <td><tt>correlation(covariance(A))</tt></td>
 * <td><tt>distance(A,EUCLID)</tt></td>
 * </tr>
 * <tr valign="top"> 
 * <td><tt> 4&nbsp;x&nbsp;3&nbsp;matrix<br>
 * 1&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3<br>
 * 2&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6<br>
 * 3&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;9<br>
 * 4&nbsp;-8&nbsp;-10 </tt> </td>
 * <td><tt> 3&nbsp;x&nbsp;3&nbsp;matrix<br>
 * &nbsp;1.25&nbsp;-3.5&nbsp;-4.5<br>
 * -3.5&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;<br>
 * -4.5&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;52.5 </tt></td>
 * <td><tt> 3&nbsp;x&nbsp;3&nbsp;matrix<br>
 * &nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.581318&nbsp;-0.555492<br>
 * -0.581318&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.999507<br>
 * -0.555492&nbsp;&nbsp;0.999507&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 * </tt></td>
 * <td><tt> 3&nbsp;x&nbsp;3&nbsp;matrix<br>
 * &nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.569805&nbsp;15.874508<br>
 * 12.569805&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.242641<br>
 * 15.874508&nbsp;&nbsp;4.242641&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 * </tt> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt></td>
 * </tr>
 * </table></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <declaration type="cern.jet.math.Functions" name="F" />
    <javadoc>
      <text>* Euclidean distance function; <tt>Sqrt(Sum( (x[i]-y[i])^2 ))</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="67" endLine="69" />
    <declaration type="VectorVectorFunction" name="EUCLID" />
    <javadoc>
      <text>* Bray-Curtis distance function; <tt>Sum( abs(x[i]-y[i]) )  /  Sum( x[i]+y[i] )</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="76" endLine="78" />
    <declaration type="VectorVectorFunction" name="BRAY_CURTIS" />
    <javadoc>
      <text>* Canberra distance function; <tt>Sum( abs(x[i]-y[i]) / abs(x[i]+y[i]) )</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="86" endLine="88" />
    <declaration type="DoubleDoubleFunction" name="fun" />
    <method type="double" name="apply" startLine="90" endLine="92" />
    <declaration type="VectorVectorFunction" name="CANBERRA" />
    <javadoc>
      <text>* Maximum distance function; <tt>Max( abs(x[i]-y[i]) )</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="99" endLine="101" />
    <declaration type="VectorVectorFunction" name="MAXIMUM" />
    <javadoc>
      <text>* Manhattan distance function; <tt>Sum( abs(x[i]-y[i]) )</tt>.</text>
    </javadoc>
    <method type="double" name="apply" startLine="108" endLine="110" />
    <declaration type="VectorVectorFunction" name="MANHATTAN" />
    <interface name="VectorVectorFunction" startLine="116">
      <javadoc>
        <text>* Interface that represents a function object: a function that takes 
 * two argument vectors and returns a single value.</text>
      </javadoc>
      <method name="apply" type="double" startLine="121" endLine="128" />
      <javadoc>
        <text>* Applies a function to two argument vectors.</text>
        <param>x   the first argument vector passed to the function.</param>
        <param>y   the second argument vector passed to the function.</param>
        <return>the result of the function.</return>
      </javadoc>
      <javadoc>
        <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
      </javadoc>
      <method type="constructor" name="Statistic" startLine="134" endLine="134" />
      <javadoc>
        <text>* Applies the given aggregation functions to each column and stores the results in a the result matrix.
 * If matrix has shape <tt>m x n</tt>, then result must have shape <tt>aggr.length x n</tt>.
 * Tip: To do aggregations on rows use dice views (transpositions), as in <tt>aggregate(matrix.viewDice(),aggr,result.viewDice())</tt>.</text>
        <param>matrix any matrix; a column holds the values of a given variable.</param>
        <param>aggr the aggregation functions to be applied to each column.</param>
        <param>result the matrix to hold the aggregation results.</param>
        <return><tt>result</tt> (for convenience only).</return>
        <see>Formatter</see>
        <see>hep.aida.bin.BinFunction1D</see>
        <see>hep.aida.bin.BinFunctions1D</see>
      </javadoc>
      <method type="DoubleMatrix2D" name="aggregate" startLine="148" endLine="161">
        <declaration type="DynamicBin1D" name="bin" />
        <declaration type="double[]" name="elements" />
        <declaration type="cern.colt.list.DoubleArrayList" name="values" />
        <scope startLine="152" endLine="159">
          <scope startLine="156" endLine="158" />
          <comment>copy column into values</comment>
        </scope>
      </method>
      <javadoc>
        <text>* Fills all cell values of the given vector into a bin from which statistics measures can be retrieved efficiently.
 * Cells values are copied.
 * <br>
 * Tip: Use <tt>System.out.println(bin(vector))</tt> to print most measures computed by the bin. Example:
 * <table>
 * <td class="PRE"> 
 * <pre>
 * Size: 20000
 * Sum: 299858.02350278624
 * SumOfSquares: 5399184.154095971
 * Min: 0.8639113139711261
 * Max: 59.75331890541892
 * Mean: 14.992901175139313
 * RMS: 16.43043540825375
 * Variance: 45.17438077634358
 * Standard deviation: 6.721188940681818
 * Standard error: 0.04752598277592142
 * Geometric mean: 13.516615397064466
 * Product: Infinity
 * Harmonic mean: 11.995174297952191
 * Sum of inversions: 1667.337172700724
 * Skew: 0.8922838940067878
 * Kurtosis: 1.1915828121825598
 * Sum of powers(3): 1.1345828465808412E8
 * Sum of powers(4): 2.7251055344494686E9
 * Sum of powers(5): 7.367125643433887E10
 * Sum of powers(6): 2.215370909100143E12
 * Moment(0,0): 1.0
 * Moment(1,0): 14.992901175139313
 * Moment(2,0): 269.95920770479853
 * Moment(3,0): 5672.914232904206
 * Moment(4,0): 136255.27672247344
 * Moment(5,0): 3683562.8217169433
 * Moment(6,0): 1.1076854545500715E8
 * Moment(0,mean()): 1.0
 * Moment(1,mean()): -2.0806734113421045E-14
 * Moment(2,mean()): 45.172122057305664
 * Moment(3,mean()): 270.92018671421
 * Moment(4,mean()): 8553.8664869067
 * Moment(5,mean()): 153357.41712233616
 * Moment(6,mean()): 4273757.570142922
 * 25%, 50% and 75% Quantiles: 10.030074811938091, 13.977982089912224,
 * 18.86124362967137
 * quantileInverse(mean): 0.559163335012079
 * Distinct elements & frequencies not printed (too many).
 * </pre>
 * </td>
 * </table></text>
        <param>vector the vector to analyze.</param>
        <return>a bin holding the statistics measures of the vector.</return>
      </javadoc>
      <method type="DynamicBin1D" name="bin" startLine="215" endLine="219">
        <declaration type="DynamicBin1D" name="bin" />
      </method>
      <javadoc>
        <text>* Modifies the given covariance matrix to be a correlation matrix (in-place).
 * The correlation matrix is a square, symmetric matrix consisting of nothing but correlation coefficients.
 * The rows and the columns represent the variables, the cells represent correlation coefficients. 
 * The diagonal cells (i.e. the correlation between a variable and itself) will equal 1, for the simple reason that the correlation coefficient of a variable with itself equals 1. 
 * The correlation of two column vectors x and y is given by <tt>corr(x,y) = cov(x,y) / (stdDev(x)*stdDev(y))</tt> (Pearson's correlation coefficient).
 * A correlation coefficient varies between -1 (for a perfect negative relationship) to +1 (for a perfect positive relationship). 
 * See the <A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition</A>
 * and <A HREF="http://www.stat.berkeley.edu/users/stark/SticiGui/Text/gloss.htm#correlation_coef"> another def</A>.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
        <param>covariance a covariance matrix, as, for example, returned by method {@link #covariance(DoubleMatrix2D)}.</param>
        <return>the modified covariance, now correlation matrix (for convenience only).</return>
      </javadoc>
      <method type="DoubleMatrix2D" name="correlation" startLine="234" endLine="249">
        <scope startLine="235" endLine="245">
          <scope startLine="236" endLine="244">
            <declaration type="double" name="stdDev1" />
            <declaration type="double" name="stdDev2" />
            <declaration type="double" name="cov" />
            <declaration type="double" name="corr" />
          </scope>
          <comment>symmetric</comment>
        </scope>
      </method>
      <javadoc>
        <text>* Constructs and returns the covariance matrix of the given matrix.
 * The covariance matrix is a square, symmetric matrix consisting of nothing but covariance coefficients. 
 * The rows and the columns represent the variables, the cells represent covariance coefficients. 
 * The diagonal cells (i.e. the covariance between a variable and itself) will equal the variances.
 * The covariance of two column vectors x and y is given by <tt>cov(x,y) = (1/n) * Sum((x[i]-mean(x)) * (y[i]-mean(y)))</tt>.
 * See the <A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition</A>.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
        <param>matrix any matrix; a column holds the values of a given variable.</param>
        <return>the covariance matrix (<tt>n x n, n=matrix.columns</tt>).</return>
      </javadoc>
      <method type="DoubleMatrix2D" name="covariance" startLine="262" endLine="283">
        <declaration type="int" name="rows" />
        <declaration type="int" name="columns" />
        <declaration type="DoubleMatrix2D" name="covariance" />
        <declaration type="double[]" name="sums" />
        <declaration type="DoubleMatrix1D[]" name="cols" />
        <scope startLine="269" endLine="272" />
        <scope startLine="274" endLine="281">
          <scope startLine="275" endLine="280">
            <declaration type="double" name="sumOfProducts" />
            <declaration type="double" name="cov" />
          </scope>
          <comment>symmetric</comment>
        </scope>
      </method>
      <javadoc>
        <text>* 2-d OLAP cube operator; Fills all cells of the given vectors into the given histogram.
 * If you use hep.aida.ref.Converter.toString(histo) on the result, the OLAP cube of x-"column" vs. y-"column" , summing the weights "column" will be printed.
 * For example, aggregate sales by product by region.
 * <p>
 * Computes the distinct values of x and y, yielding histogram axes that capture one distinct value per bin.
 * Then fills the histogram.
 * <p>
 * Example output:
 * <table>
 * <td class="PRE"> 
 * <pre>
 * Cube:
 * &nbsp;&nbsp;&nbsp;Entries=5000, ExtraEntries=0
 * &nbsp;&nbsp;&nbsp;MeanX=4.9838, RmsX=NaN
 * &nbsp;&nbsp;&nbsp;MeanY=2.5304, RmsY=NaN
 * &nbsp;&nbsp;&nbsp;xAxis: Min=0, Max=10, Bins=11
 * &nbsp;&nbsp;&nbsp;yAxis: Min=0, Max=5, Bins=6
 * Heights:
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| X
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0   1   2   3   4   5   6   7   8   9   10  | Sum 
 * ----------------------------------------------------------
 * Y 5   |  30  53  51  52  57  39  65  61  55  49  22 |  534
 * &nbsp;&nbsp;4   |  43 106 112  96  92  94 107  98  98 110  47 | 1003
 * &nbsp;&nbsp;3   |  39 134  87  93 102 103 110  90 114  98  51 | 1021
 * &nbsp;&nbsp;2   |  44  81 113  96 101  86 109  83 111  93  42 |  959
 * &nbsp;&nbsp;1   |  54  94 103  99 115  92  98  97 103  90  44 |  989
 * &nbsp;&nbsp;0   |  24  54  52  44  42  56  46  47  56  53  20 |  494
 * ----------------------------------------------------------
 * &nbsp;&nbsp;Sum | 234 522 518 480 509 470 535 476 537 493 226 |     
 * </pre>
 * </td>
 * </table></text>
        <return>the histogram containing the cube.</return>
        <throws>IllegalArgumentException if <tt>x.size() != y.size() || y.size() != weights.size()</tt>.</throws>
      </javadoc>
      <method type="hep.aida.IHistogram2D" name="cube" startLine="320" endLine="348">
        <declaration type="double" name="epsilon" />
        <declaration type="cern.colt.list.DoubleArrayList" name="distinct" />
        <declaration type="double[]" name="vals" />
        <declaration type="cern.colt.list.DoubleArrayList" name="sorted" />
        <declaration type="hep.aida.IAxis" name="xaxis" />
        <declaration type="hep.aida.IAxis" name="yaxis" />
        <declaration type="hep.aida.IHistogram2D" name="histo" />
        <comment>compute distinct values of x</comment>
        <comment>copy x into vals</comment>
        <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
        <comment>compute distinct values of y</comment>
        <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
      </method>
      <javadoc>
        <text>* 3-d OLAP cube operator; Fills all cells of the given vectors into the given histogram.
 * If you use hep.aida.ref.Converter.toString(histo) on the result, the OLAP cube of x-"column" vs. y-"column" vs. z-"column", summing the weights "column" will be printed.
 * For example, aggregate sales by product by region by time.
 * <p>
 * Computes the distinct values of x and y and z, yielding histogram axes that capture one distinct value per bin.
 * Then fills the histogram.</text>
        <return>the histogram containing the cube.</return>
        <throws>IllegalArgumentException if <tt>x.size() != y.size() || x.size() != z.size() || x.size() != weights.size()</tt>.</throws>
      </javadoc>
      <method type="hep.aida.IHistogram3D" name="cube" startLine="359" endLine="396">
        <declaration type="double" name="epsilon" />
        <declaration type="cern.colt.list.DoubleArrayList" name="distinct" />
        <declaration type="double[]" name="vals" />
        <declaration type="cern.colt.list.DoubleArrayList" name="sorted" />
        <declaration type="hep.aida.IAxis" name="xaxis" />
        <declaration type="hep.aida.IAxis" name="yaxis" />
        <declaration type="hep.aida.IAxis" name="zaxis" />
        <declaration type="hep.aida.IHistogram3D" name="histo" />
        <comment>compute distinct values of x</comment>
        <comment>copy x into vals</comment>
        <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
        <comment>compute distinct values of y</comment>
        <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
        <comment>compute distinct values of z</comment>
        <comment>since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin</comment>
      </method>
      <javadoc>
        <text>* Demonstrates usage of this class.</text>
      </javadoc>
      <method type="void" name="demo1" startLine="400" endLine="419">
        <declaration type="double[][]" name="values" />
        <declaration type="DoubleFactory2D" name="factory" />
        <declaration type="DoubleMatrix2D" name="A" />
        <comment>System.out.println(correlation(covariance(A)));</comment>
        <comment>System.out.println(distance(A,EUCLID));</comment>
        <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(A.toString()));</comment>
        <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(covariance(A).toString()));</comment>
        <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(correlation(covariance(A)).toString()));</comment>
        <comment>System.out.println(cern.colt.matrixpattern.Converting.toHTML(distance(A,EUCLID).toString()));</comment>
      </method>
      <javadoc>
        <text>* Demonstrates usage of this class.</text>
      </javadoc>
      <method type="void" name="demo2" startLine="423" endLine="442">
        <declaration type="DoubleFactory2D" name="factory" />
        <declaration type="DoubleMatrix2D" name="A" />
        <declaration type="cern.colt.Timer" name="timer" />
        <declaration type="DoubleMatrix2D" name="corr" />
        <scope startLine="437" endLine="440" />
        <comment>double value = 1;</comment>
        <comment>DoubleMatrix2D A = factory.make(rows,columns);</comment>
        <comment>A.assign(value);</comment>
      </method>
      <javadoc>
        <text>* Demonstrates usage of this class.</text>
      </javadoc>
      <method type="void" name="demo3" startLine="446" endLine="461">
        <declaration type="double[][]" name="values" />
        <declaration type="DoubleFactory2D" name="factory" />
        <declaration type="DoubleMatrix2D" name="A" />
      </method>
      <javadoc>
        <text>* Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
        <param>matrix any matrix; a column holds the values of a given variable (vector).</param>
        <param>distanceFunction (EUCLID, CANBERRA, ..., or any user defined distance function operating on two vectors).</param>
        <return>the distance matrix (<tt>n x n, n=matrix.columns</tt>).</return>
      </javadoc>
      <method type="DoubleMatrix2D" name="distance" startLine="473" endLine="492">
        <declaration type="int" name="columns" />
        <declaration type="DoubleMatrix2D" name="distance" />
        <declaration type="DoubleMatrix1D[]" name="cols" />
        <scope startLine="479" endLine="481" />
        <scope startLine="484" endLine="490">
          <scope startLine="485" endLine="489">
            <declaration type="double" name="d" />
          </scope>
          <comment>symmetric</comment>
        </scope>
        <comment>cache views</comment>
        <comment>work out all permutations</comment>
      </method>
      <javadoc>
        <text>* Fills all cells of the given vector into the given histogram.</text>
        <return><tt>histo</tt> (for convenience only).</return>
      </javadoc>
      <method type="hep.aida.IHistogram1D" name="histogram" startLine="497" endLine="502">
        <scope startLine="498" endLine="500" />
      </method>
      <javadoc>
        <text>* Fills all cells of the given vectors into the given histogram.</text>
        <return><tt>histo</tt> (for convenience only).</return>
        <throws>IllegalArgumentException if <tt>x.size() != y.size()</tt>.</throws>
      </javadoc>
      <method type="hep.aida.IHistogram2D" name="histogram" startLine="508" endLine="514">
        <scope startLine="510" endLine="512" />
      </method>
      <javadoc>
        <text>* Fills all cells of the given vectors into the given histogram.</text>
        <return><tt>histo</tt> (for convenience only).</return>
        <throws>IllegalArgumentException if <tt>x.size() != y.size() || y.size() != weights.size()</tt>.</throws>
      </javadoc>
      <method type="hep.aida.IHistogram2D" name="histogram" startLine="520" endLine="526">
        <scope startLine="522" endLine="524" />
      </method>
      <javadoc>
        <text>* Fills all cells of the given vectors into the given histogram.</text>
        <return><tt>histo</tt> (for convenience only).</return>
        <throws>IllegalArgumentException if <tt>x.size() != y.size() || x.size() != z.size() || x.size() != weights.size()</tt>.</throws>
      </javadoc>
      <method type="hep.aida.IHistogram3D" name="histogram" startLine="532" endLine="538">
        <scope startLine="534" endLine="536" />
      </method>
      <javadoc>
        <text>* Benchmarks covariance computation.</text>
      </javadoc>
      <method type="void" name="main" startLine="542" endLine="547">
        <declaration type="int" name="rows" />
        <declaration type="int" name="columns" />
        <declaration type="boolean" name="print" />
      </method>
      <javadoc>
        <text>* Constructs and returns a sampling view with a size of <tt>round(matrix.size() * fraction)</tt>.
 * Samples "without replacement" from the uniform distribution.</text>
        <param>matrix any matrix.</param>
        <param>rowFraction the percentage of rows to be included in the view.</param>
        <param>columnFraction the percentage of columns to be included in the view.</param>
        <param>randomGenerator a uniform random number generator; set this parameter to <tt>null</tt> to use a default generator seeded with the current time.</param>
        <return>the sampling view.</return>
        <throws>IllegalArgumentException if <tt>! (0 <= rowFraction <= 1 && 0 <= columnFraction <= 1)</tt>.</throws>
        <see>cern.jet.random.sampling.RandomSampler</see>
      </javadoc>
      <method type="DoubleMatrix1D" name="viewSample" startLine="559" endLine="581">
        <declaration type="double" name="epsilon" />
        <declaration type="int" name="ncols" />
        <declaration type="int" name="max" />
        <declaration type="long[]" name="selected" />
        <declaration type="int" name="n" />
        <declaration type="int" name="N" />
        <declaration type="int[]" name="selectedCols" />
        <comment>check preconditions and allow for a little tolerance</comment>
        <comment>random generator seeded with current time</comment>
        <comment>sampler works on long's, not int's</comment>
        <comment>sample</comment>
      </method>
      <javadoc>
        <text>* Constructs and returns a sampling view with <tt>round(matrix.rows() * rowFraction)</tt> rows and <tt>round(matrix.columns() * columnFraction)</tt> columns.
 * Samples "without replacement".
 * Rows and columns are randomly chosen from the uniform distribution.
 * Examples: 
 * <table border="1" cellspacing="0">
 * <tr valign="top" align="center"> 
 * <td> 
 * <div align="left"><tt>matrix</tt></div>
 * </td>
 * <td> 
 * <div align="left"><tt>rowFraction=0.2<br>
 * columnFraction=0.2</tt></div>
 * </td>
 * <td> 
 * <div align="left"><tt>rowFraction=0.2<br>
 * columnFraction=1.0 </tt></div>
 * </td>
 * <td> 
 * <div align="left"><tt>rowFraction=1.0<br>
 * columnFraction=0.2 </tt></div>
 * </td>
 * </tr>
 * <tr valign="top"> 
 * <td><tt> 10&nbsp;x&nbsp;10&nbsp;matrix<br>
 * &nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;&nbsp;10<br>
 * 11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;&nbsp;20<br>
 * 21&nbsp;22&nbsp;23&nbsp;24&nbsp;25&nbsp;26&nbsp;27&nbsp;28&nbsp;29&nbsp;&nbsp;30<br>
 * 31&nbsp;32&nbsp;33&nbsp;34&nbsp;35&nbsp;36&nbsp;37&nbsp;38&nbsp;39&nbsp;&nbsp;40<br>
 * 41&nbsp;42&nbsp;43&nbsp;44&nbsp;45&nbsp;46&nbsp;47&nbsp;48&nbsp;49&nbsp;&nbsp;50<br>
 * 51&nbsp;52&nbsp;53&nbsp;54&nbsp;55&nbsp;56&nbsp;57&nbsp;58&nbsp;59&nbsp;&nbsp;60<br>
 * 61&nbsp;62&nbsp;63&nbsp;64&nbsp;65&nbsp;66&nbsp;67&nbsp;68&nbsp;69&nbsp;&nbsp;70<br>
 * 71&nbsp;72&nbsp;73&nbsp;74&nbsp;75&nbsp;76&nbsp;77&nbsp;78&nbsp;79&nbsp;&nbsp;80<br>
 * 81&nbsp;82&nbsp;83&nbsp;84&nbsp;85&nbsp;86&nbsp;87&nbsp;88&nbsp;89&nbsp;&nbsp;90<br>
 * 91&nbsp;92&nbsp;93&nbsp;94&nbsp;95&nbsp;96&nbsp;97&nbsp;98&nbsp;99&nbsp;100 
 * </tt> </td>
 * <td><tt> 2&nbsp;x&nbsp;2&nbsp;matrix<br>
 * 43&nbsp;50<br>
 * 53&nbsp;60 </tt></td>
 * <td><tt> 2&nbsp;x&nbsp;10&nbsp;matrix<br>
 * 41&nbsp;42&nbsp;43&nbsp;44&nbsp;45&nbsp;46&nbsp;47&nbsp;48&nbsp;49&nbsp;&nbsp;50<br>
 * 91&nbsp;92&nbsp;93&nbsp;94&nbsp;95&nbsp;96&nbsp;97&nbsp;98&nbsp;99&nbsp;100 
 * </tt> </td>
 * <td><tt> 10&nbsp;x&nbsp;2&nbsp;matrix<br>
 * &nbsp;4&nbsp;&nbsp;8<br>
 * 14&nbsp;18<br>
 * 24&nbsp;28<br>
 * 34&nbsp;38<br>
 * 44&nbsp;48<br>
 * 54&nbsp;58<br>
 * 64&nbsp;68<br>
 * 74&nbsp;78<br>
 * 84&nbsp;88<br>
 * 94&nbsp;98 </tt> </td>
 * </tr>
 * </table></text>
        <param>matrix any matrix.</param>
        <param>rowFraction the percentage of rows to be included in the view.</param>
        <param>columnFraction the percentage of columns to be included in the view.</param>
        <param>randomGenerator a uniform random number generator; set this parameter to <tt>null</tt> to use a default generator seeded with the current time.</param>
        <return>the sampling view.</return>
        <throws>IllegalArgumentException if <tt>! (0 <= rowFraction <= 1 && 0 <= columnFraction <= 1)</tt>.</throws>
        <see>cern.jet.random.sampling.RandomSampler</see>
      </javadoc>
      <method type="DoubleMatrix2D" name="viewSample" startLine="646" endLine="680">
        <declaration type="double" name="epsilon" />
        <declaration type="int" name="nrows" />
        <declaration type="int" name="ncols" />
        <declaration type="int" name="max" />
        <declaration type="long[]" name="selected" />
        <declaration type="int" name="n" />
        <declaration type="int" name="N" />
        <declaration type="int[]" name="selectedRows" />
        <declaration type="int[]" name="selectedCols" />
        <comment>check preconditions and allow for a little tolerance</comment>
        <comment>random generator seeded with current time</comment>
        <comment>sampler works on long's, not int's</comment>
        <comment>sample rows</comment>
        <comment>sample columns</comment>
      </method>
      <javadoc>
        <text>* Constructs and returns a sampling view with <tt>round(matrix.slices() * sliceFraction)</tt> slices and <tt>round(matrix.rows() * rowFraction)</tt> rows and <tt>round(matrix.columns() * columnFraction)</tt> columns.
 * Samples "without replacement".
 * Slices, rows and columns are randomly chosen from the uniform distribution.</text>
        <param>matrix any matrix.</param>
        <param>sliceFraction the percentage of slices to be included in the view.</param>
        <param>rowFraction the percentage of rows to be included in the view.</param>
        <param>columnFraction the percentage of columns to be included in the view.</param>
        <param>randomGenerator a uniform random number generator; set this parameter to <tt>null</tt> to use a default generator seeded with the current time.</param>
        <return>the sampling view.</return>
        <throws>IllegalArgumentException if <tt>! (0 <= sliceFraction <= 1 && 0 <= rowFraction <= 1 && 0 <= columnFraction <= 1)</tt>.</throws>
        <see>cern.jet.random.sampling.RandomSampler</see>
      </javadoc>
      <method type="DoubleMatrix3D" name="viewSample" startLine="694" endLine="740">
        <declaration type="double" name="epsilon" />
        <declaration type="int" name="nslices" />
        <declaration type="int" name="nrows" />
        <declaration type="int" name="ncols" />
        <declaration type="int" name="max" />
        <declaration type="long[]" name="selected" />
        <declaration type="int" name="n" />
        <declaration type="int" name="N" />
        <declaration type="int[]" name="selectedSlices" />
        <declaration type="int[]" name="selectedRows" />
        <declaration type="int[]" name="selectedCols" />
        <comment>check preconditions and allow for a little tolerance</comment>
        <comment>random generator seeded with current time</comment>
        <comment>sampler works on long's, not int's</comment>
        <comment>sample slices</comment>
        <comment>sample rows</comment>
        <comment>sample columns</comment>
      </method>
      <javadoc>
        <text>* Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
        <param>matrix any matrix; a column holds the values of a given variable (vector).</param>
        <param>norm the kind of norm to be used (EUCLID, CANBERRA, ...).</param>
        <return>the distance matrix (<tt>n x n, n=matrix.columns</tt>).</return>
      </javadoc>
      <method type="DoubleMatrix2D" name="xdistanceOld" startLine="752" endLine="793">
        <comment>int rows = matrix.rows();
int columns = matrix.columns();
DoubleMatrix2D distance = new cern.colt.matrix.impl.DenseDoubleMatrix2D(columns,columns);

 cache views
DoubleMatrix1D[] cols = new DoubleMatrix1D[columns];
for (int i=columns; --i >= 0; ) {
cols[i] = matrix.viewColumn(i);
}

 setup distance function
cern.jet.math.Functions F = cern.jet.math.Functions.functions;
DoubleDoubleFunction function = null;
DoubleDoubleFunction function2 = null;
if (norm==EUCLID) function = F.chain(F.square,F.minus);
else if (norm==BRAY_CURTIS) function = F.chain(F.abs,F.minus);
else if (norm==CANBERRA) function = new DoubleDoubleFunction() {
public final double apply(double a, double b) {	return Math.abs(a-b)  Math.abs(a+b);}
};
else if (norm==MAXIMUM) function = F.chain(F.abs,F.minus);
else if (norm==MANHATTAN) function = F.chain(F.abs,F.minus);
else throw new IllegalArgumentException("Unknown norm");

 work out all permutations
for (int i=columns; --i >= 0; ) {
for (int j=i; --j >= 0; ) {
double d = 0;
if (norm==EUCLID) d = Math.sqrt(cols[i].aggregate(cols[j], F.plus, function));
else if (norm==BRAY_CURTIS) d = cols[i].aggregate(cols[j], F.plus, function)  cols[i].aggregate(cols[j], F.plus, F.plus);
else if (norm==CANBERRA) d = cols[i].aggregate(cols[j], F.plus, function);
else if (norm==MAXIMUM) d = cols[i].aggregate(cols[j], F.max, function);
else if (norm==MANHATTAN) d = cols[i].aggregate(cols[j], F.plus, function);
distance.setQuick(i,j,d);
distance.setQuick(j,i,d);  symmetric
}
}
return distance;</comment>
      </method>
      <javadoc>
        <text>* Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.</text>
        <param>matrix any matrix; a column holds the values of a given variable (vector).</param>
        <param>norm the kind of norm to be used (EUCLID, CANBERRA, ...).</param>
        <return>the distance matrix (<tt>n x n, n=matrix.columns</tt>).</return>
      </javadoc>
      <method type="DoubleMatrix2D" name="xdistanceOld2" startLine="805" endLine="845">
        <comment>setup distance function
final cern.jet.math.Functions F = cern.jet.math.Functions.functions;
VectorVectorFunction function;
if (norm==EUCLID) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return Math.sqrt(a.aggregate(b, F.plus, F.chain(F.square,F.minus)));
}
};
else if (norm==BRAY_CURTIS) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.plus, F.chain(F.abs,F.minus))  a.aggregate(b, F.plus, F.plus);
}
};
else if (norm==CANBERRA) function = new VectorVectorFunction() {
DoubleDoubleFunction fun = new DoubleDoubleFunction() {
public final double apply(double a, double b) {
return Math.abs(a-b)  Math.abs(a+b);
}
};
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.plus, fun);
}
};
else if (norm==MAXIMUM) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.max, F.chain(F.abs,F.minus));
}
};
else if (norm==MANHATTAN) function = new VectorVectorFunction() {
public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
return a.aggregate(b, F.plus, F.chain(F.abs,F.minus));
}
};
else throw new IllegalArgumentException("Unknown norm");

return distance(matrix,function);</comment>
      </method>
    </interface>
  </class>
</source>
