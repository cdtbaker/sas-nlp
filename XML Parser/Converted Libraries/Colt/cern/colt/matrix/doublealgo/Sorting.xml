<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.matrix.doublealgo">
  <import name="cern.colt.function.IntComparator" />
  <import name="cern.colt.matrix.DoubleFactory2D" />
  <import name="cern.colt.matrix.DoubleFactory3D" />
  <import name="cern.colt.matrix.DoubleMatrix1D" />
  <import name="cern.colt.matrix.DoubleMatrix2D" />
  <import name="cern.colt.matrix.DoubleMatrix3D" />
  <import name="cern.colt.matrix.impl.DenseDoubleMatrix1D" />
  <class name="Sorting" extends="cern.colt.PersistentObject" startLine="18">
    <javadoc>
      <text>* Matrix quicksorts and mergesorts.
 * Use idioms like <tt>Sorting.quickSort.sort(...)</tt> and <tt>Sorting.mergeSort.sort(...)</tt>.
 * <p>
 * This is another case demonstrating one primary goal of this library: Delivering easy to use, yet very efficient APIs.
 * The sorts return convenient <i>sort views</i>.
 * This enables the usage of algorithms which scale well with the problem size:
 * For example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix.
 * This is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices.
 * The original matrix is left unaffected.
 * <p>
 * The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in turn, based on Bentley's and McIlroy's fine work).
 * The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
 * Mergesort is <i>stable</i> (by definition), while quicksort is not.
 * A stable sort is, for example, helpful, if matrices are sorted successively 
 * by multiple columns. It preserves the relative position of equal elements.</text>
      <see>cern.colt.GenericSorting</see>
      <see>cern.colt.Sorting</see>
      <see>java.util.Arrays</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.1, 25/May/2000</version>
    </javadoc>
    <javadoc>
      <text>* A prefabricated quicksort.</text>
    </javadoc>
    <declaration type="Sorting" name="quickSort" />
    <javadoc>
      <text>* A prefabricated mergesort.</text>
    </javadoc>
    <method type="void" name="runSort" startLine="52" endLine="54" />
    <method type="void" name="runSort" startLine="55" endLine="57" />
    <declaration type="Sorting" name="mergeSort" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="Sorting" startLine="62" endLine="62" />
    <javadoc>
      <text>* Compare two values, one of which is assumed to be Double.NaN</text>
    </javadoc>
    <method type="int" name="compareNaN" startLine="66" endLine="72">
      <scope startLine="67" endLine="70">
        <comment>NaN equals NaN</comment>
        <comment>e.g. NaN > 5</comment>
      </scope>
      <comment>e.g. 5 < NaN</comment>
    </method>
    <method type="void" name="runSort" startLine="73" endLine="75" />
    <method type="void" name="runSort" startLine="76" endLine="78" />
    <javadoc>
      <text>* Sorts the vector into ascending order, according to the <i>natural ordering</i>.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b> 
 * <table border="1" cellspacing="0">
 * <tr nowrap> 
 * <td valign="top"><tt> 7, 1, 3, 1<br>
 * </tt></td>
 * <td valign="top"> 
 * <p><tt> ==&gt; 1, 1, 3, 7<br>
 * The vector IS NOT SORTED.<br>
 * The new VIEW IS SORTED.</tt></p>
 * </td>
 * </tr>
 * </table></text>
      <param>vector the vector to be sorted.</param>
      <return>a new sorted vector (matrix) view. 
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="DoubleMatrix1D" name="sort" startLine="101" endLine="117">
      <declaration type="int[]" name="indexes" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="106" endLine="111">
        <declaration type="double" name="av" />
        <declaration type="double" name="bv" />
      </method>
      <comment>row indexes to reorder instead of matrix itself</comment>
      <comment>swap NaNs to the end</comment>
    </method>
    <javadoc>
      <text>* Sorts the vector into ascending order, according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * <pre>
 * // sort by sinus of cells
 * DoubleComparator comp = new DoubleComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(double a, double b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double as = Math.sin(a); double bs = Math.sin(b);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as < bs ? -1 : as == bs ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * sorted = quickSort(vector,comp);
 * </pre></text>
      <param>vector the vector to be sorted.</param>
      <param>c the comparator to determine the order.</param>
      <return>a new matrix view sorted as specified.
 * <b>Note that the original vector (matrix) is left unaffected.</b></return>
    </javadoc>
    <method type="DoubleMatrix1D" name="sort" startLine="141" endLine="154">
      <declaration type="int[]" name="indexes" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="146" endLine="148" />
      <comment>row indexes to reorder instead of matrix itself</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix rows into ascending order, according to the <i>natural ordering</i> of the matrix values in the virtual column <tt>aggregates</tt>;
 * Particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts.
 * Essentially, this algorithm makes expensive comparisons cheap.
 * Normally each element of <tt>aggregates</tt> is a summary measure of a row.
 * Speedup over comparator based sorting = <tt>2*log(rows)</tt>, on average.
 * For this operation, quicksort is usually faster.
 * <p>
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * Each aggregate is the sum of a row
 * <table border="1" cellspacing="0">
 * <tr nowrap> 
 * <td valign="top"><tt>4 x 2 matrix: <br>
 * 1, 1<br>
 * 5, 4<br>
 * 3, 0<br>
 * 4, 4 <br>
 * </tt></td>
 * <td align="left" valign="top"> 
 * <tt>aggregates=<br>
 * 2<br>
 * 9<br>
 * 3<br>
 * 8<br>
 * ==></tt></td>
 * <td valign="top"> 
 * <p><tt>4 x 2 matrix:<br>
 * 1, 1<br>
 * 3, 0<br>
 * 4, 4<br>
 * 5, 4</tt><br>
 * The matrix IS NOT SORTED.<br>
 * The new VIEW IS SORTED.</p>
 * </td>
 * </tr>
 * </table>
 * <table>
 * <td class="PRE"> 
 * <pre>
 * // sort 10000 x 1000 matrix by sum of logarithms in a row (i.e. by geometric mean)
 * DoubleMatrix2D matrix = new DenseDoubleMatrix2D(10000,1000);
 * matrix.assign(new cern.jet.random.engine.MersenneTwister()); // initialized randomly
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions; // alias for convenience
 * // THE QUICK VERSION (takes some 3 secs)
 * // aggregates[i] = Sum(log(row));
 * double[] aggregates = new double[matrix.rows()];
 * for (int i = matrix.rows(); --i >= 0; ) aggregates[i] = matrix.viewRow(i).aggregate(F.plus, F.log);
 * DoubleMatrix2D sorted = quickSort(matrix,aggregates);
 * // THE SLOW VERSION (takes some 90 secs)
 * DoubleMatrix1DComparator comparator = new DoubleMatrix1DComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(DoubleMatrix1D x, DoubleMatrix1D y) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a = x.aggregate(F.plus,F.log);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double b = y.aggregate(F.plus,F.log);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a < b ? -1 : a==b ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * DoubleMatrix2D sorted = quickSort(matrix,comparator);
 * </pre>
 * </td>
 * </table></text>
      <param>matrix the matrix to be sorted.</param>
      <param>aggregates the values to sort on. (As a side effect, this array will also get sorted).</param>
      <return>a new matrix view having rows sorted.
 * <b>Note that the original matrix is left unaffected.</b></return>
      <throws>IndexOutOfBoundsException if <tt>aggregates.length != matrix.rows()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="sort" startLine="228" endLine="260">
      <declaration type="int" name="rows" />
      <declaration type="int[]" name="indexes" />
      <declaration type="cern.colt.function.IntComparator" name="comp" />
      <method type="int" name="compare" startLine="238" endLine="243">
        <declaration type="double" name="a" />
        <declaration type="double" name="b" />
      </method>
      <declaration type="cern.colt.Swapper" name="swapper" />
      <method type="void" name="swap" startLine="247" endLine="251">
        <declaration type="int" name="t1" />
        <declaration type="double" name="t2" />
      </method>
      <comment>set up index reordering</comment>
      <comment>compares two aggregates at a time</comment>
      <comment>swap NaNs to the end</comment>
      <comment>swaps aggregates and reorders indexes</comment>
      <comment>sort indexes and aggregates</comment>
      <comment>view the matrix according to the reordered row indexes</comment>
      <comment>take all columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix rows into ascending order, according to the <i>natural ordering</i> of the matrix values in the given column.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b> 
 * <table border="1" cellspacing="0">
 * <tr nowrap> 
 * <td valign="top"><tt>4 x 2 matrix: <br>
 * 7, 6<br>
 * 5, 4<br>
 * 3, 2<br>
 * 1, 0 <br>
 * </tt></td>
 * <td align="left" valign="top"> 
 * <p><tt>column = 0;<br>
 * view = quickSort(matrix,column);<br>
 * System.out.println(view); </tt><tt><br>
 * ==> </tt></p>
 * </td>
 * <td valign="top"> 
 * <p><tt>4 x 2 matrix:<br>
 * 1, 0<br>
 * 3, 2<br>
 * 5, 4<br>
 * 7, 6</tt><br>
 * The matrix IS NOT SORTED.<br>
 * The new VIEW IS SORTED.</p>
 * </td>
 * </tr>
 * </table></text>
      <param>matrix the matrix to be sorted.</param>
      <param>column the index of the column inducing the order.</param>
      <return>a new matrix view having rows sorted by the given column.
 * <b>Note that the original matrix is left unaffected.</b></return>
      <throws>IndexOutOfBoundsException if <tt>column < 0 || column >= matrix.columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix2D" name="sort" startLine="299" endLine="320">
      <declaration type="int[]" name="rowIndexes" />
      <declaration type="DoubleMatrix1D" name="col" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="307" endLine="312">
        <declaration type="double" name="av" />
        <declaration type="double" name="bv" />
      </method>
      <comment>row indexes to reorder instead of matrix itself</comment>
      <comment>swap NaNs to the end</comment>
      <comment>view the matrix according to the reordered row indexes</comment>
      <comment>take all columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix rows according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * <pre>
 * // sort by sum of values in a row
 * DoubleMatrix1DComparator comp = new DoubleMatrix1DComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(DoubleMatrix1D a, DoubleMatrix1D b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double as = a.zSum(); double bs = b.zSum();
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as < bs ? -1 : as == bs ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * sorted = quickSort(matrix,comp);
 * </pre></text>
      <param>matrix the matrix to be sorted.</param>
      <param>c the comparator to determine the order.</param>
      <return>a new matrix view having rows sorted as specified.
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="DoubleMatrix2D" name="sort" startLine="344" endLine="363">
      <declaration type="int[]" name="rowIndexes" />
      <declaration type="DoubleMatrix1D[]" name="views" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="352" endLine="355" />
      <comment>row indexes to reorder instead of matrix itself</comment>
      <comment>precompute views for speed</comment>
      <comment>return c.compare(matrix.viewRow(a), matrix.viewRow(b));</comment>
      <comment>view the matrix according to the reordered row indexes</comment>
      <comment>take all columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix rows into ascending order, according to the <i>natural ordering</i> of the values computed by applying the given aggregation function to each row;
 * Particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts.
 * Essentially, this algorithm makes expensive comparisons cheap.
 * Normally <tt>aggregates</tt> defines a summary measure of a row.
 * Speedup over comparator based sorting = <tt>2*log(rows)</tt>, on average.
 * <p>
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * Each aggregate is the sum of a row
 * <table border="1" cellspacing="0">
 * <tr nowrap> 
 * <td valign="top"><tt>4 x 2 matrix: <br>
 * 1, 1<br>
 * 5, 4<br>
 * 3, 0<br>
 * 4, 4 <br>
 * </tt></td>
 * <td align="left" valign="top"> 
 * <tt>aggregates=<br>
 * hep.aida.bin.BinFunctions1D.sum<br>
 * ==></tt></td>
 * <td valign="top"> 
 * <p><tt>4 x 2 matrix:<br>
 * 1, 1<br>
 * 3, 0<br>
 * 4, 4<br>
 * 5, 4</tt><br>
 * The matrix IS NOT SORTED.<br>
 * The new VIEW IS SORTED.</p>
 * </td>
 * </tr>
 * </table>
 * <table>
 * <td class="PRE"> 
 * <pre>
 * // sort 10000 x 1000 matrix by median or by sum of logarithms in a row (i.e. by geometric mean)
 * DoubleMatrix2D matrix = new DenseDoubleMatrix2D(10000,1000);
 * matrix.assign(new cern.jet.random.engine.MersenneTwister()); // initialized randomly
 * cern.jet.math.Functions F = cern.jet.math.Functions.functions; // alias for convenience
 * // THE QUICK VERSION (takes some 10 secs)
 * DoubleMatrix2D sorted = quickSort(matrix,hep.aida.bin.BinFunctions1D.median);
 * //DoubleMatrix2D sorted = quickSort(matrix,hep.aida.bin.BinFunctions1D.sumOfLogarithms);
 * // THE SLOW VERSION (takes some 300 secs)
 * DoubleMatrix1DComparator comparator = new DoubleMatrix1DComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(DoubleMatrix1D x, DoubleMatrix1D y) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a = cern.colt.matrix.doublealgo.Statistic.bin(x).median();
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double b = cern.colt.matrix.doublealgo.Statistic.bin(y).median();
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double a = x.aggregate(F.plus,F.log);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double b = y.aggregate(F.plus,F.log);
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a < b ? -1 : a==b ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * DoubleMatrix2D sorted = quickSort(matrix,comparator);
 * </pre>
 * </td>
 * </table></text>
      <param>matrix the matrix to be sorted.</param>
      <param>aggregate the function to sort on; aggregates values in a row.</param>
      <return>a new matrix view having rows sorted.
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="DoubleMatrix2D" name="sort" startLine="432" endLine="441">
      <declaration type="DoubleMatrix2D" name="tmp" />
      <declaration type="hep.aida.bin.BinFunction1D[]" name="func" />
      <declaration type="double[]" name="aggr" />
      <comment>precompute aggregates over rows, as defined by "aggregate"</comment>
      <comment>a bit clumsy, because Statistic.aggregate(...) is defined on columns, so we need to transpose views</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix slices into ascending order, according to the <i>natural ordering</i> of the matrix values in the given <tt>[row,column]</tt> position.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
 * <p>
 * The algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other.
 * Comparison is based on the cell <tt>[row,column]</tt> within a slice.
 * Let <tt>A</tt> and <tt>B</tt> be two 2-d slices. Then we have the following rules
 * <ul>
 * <li><tt>A &lt;  B  iff A.get(row,column) &lt;  B.get(row,column)</tt>
 * <li><tt>A == B iff A.get(row,column) == B.get(row,column)</tt>
 * <li><tt>A &gt;  B  iff A.get(row,column) &gt;  B.get(row,column)</tt>
 * </ul></text>
      <param>matrix the matrix to be sorted.</param>
      <param>row the index of the row inducing the order.</param>
      <param>column the index of the column inducing the order.</param>
      <return>a new matrix view having slices sorted by the values of the slice view <tt>matrix.viewRow(row).viewColumn(column)</tt>.
 * <b>Note that the original matrix is left unaffected.</b></return>
      <throws>IndexOutOfBoundsException if <tt>row < 0 || row >= matrix.rows() || column < 0 || column >= matrix.columns()</tt>.</throws>
    </javadoc>
    <method type="DoubleMatrix3D" name="sort" startLine="463" endLine="485">
      <declaration type="int[]" name="sliceIndexes" />
      <declaration type="DoubleMatrix1D" name="sliceView" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="472" endLine="477">
        <declaration type="double" name="av" />
        <declaration type="double" name="bv" />
      </method>
      <comment>indexes to reorder instead of matrix itself</comment>
      <comment>swap NaNs to the end</comment>
      <comment>view the matrix according to the reordered slice indexes</comment>
      <comment>take all rows and columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Sorts the matrix slices according to the order induced by the specified comparator.
 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
 * The algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
 * <p>
 * <b>Example:</b>
 * <pre>
 * // sort by sum of values in a slice
 * DoubleMatrix2DComparator comp = new DoubleMatrix2DComparator() {
 * &nbsp;&nbsp;&nbsp;public int compare(DoubleMatrix2D a, DoubleMatrix2D b) {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double as = a.zSum(); double bs = b.zSum();
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as < bs ? -1 : as == bs ? 0 : 1;
 * &nbsp;&nbsp;&nbsp;}
 * };
 * sorted = quickSort(matrix,comp);
 * </pre></text>
      <param>matrix the matrix to be sorted.</param>
      <param>c the comparator to determine the order.</param>
      <return>a new matrix view having slices sorted as specified.
 * <b>Note that the original matrix is left unaffected.</b></return>
    </javadoc>
    <method type="DoubleMatrix3D" name="sort" startLine="509" endLine="528">
      <declaration type="int[]" name="sliceIndexes" />
      <declaration type="DoubleMatrix2D[]" name="views" />
      <declaration type="IntComparator" name="comp" />
      <method type="int" name="compare" startLine="517" endLine="520" />
      <comment>indexes to reorder instead of matrix itself</comment>
      <comment>precompute views for speed</comment>
      <comment>return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));</comment>
      <comment>view the matrix according to the reordered slice indexes</comment>
      <comment>take all rows and columns in the original order</comment>
    </method>
    <javadoc>
      <text>* Demonstrates advanced sorting.
 * Sorts by sum of row.</text>
    </javadoc>
    <method type="void" name="zdemo1" startLine="533" endLine="544">
      <declaration type="Sorting" name="sort" />
      <declaration type="DoubleMatrix2D" name="matrix" />
      <declaration type="DoubleMatrix1DComparator" name="comp" />
      <method type="int" name="compare" startLine="537" endLine="540">
        <declaration type="double" name="as" />
        <declaration type="double" name="bs" />
      </method>
    </method>
    <javadoc>
      <text>* Demonstrates advanced sorting.
 * Sorts by sum of slice.</text>
    </javadoc>
    <method type="void" name="zdemo2" startLine="549" endLine="561">
      <declaration type="Sorting" name="sort" />
      <declaration type="DoubleMatrix3D" name="matrix" />
      <declaration type="DoubleMatrix2DComparator" name="comp" />
      <method type="int" name="compare" startLine="553" endLine="557">
        <declaration type="double" name="as" />
        <declaration type="double" name="bs" />
      </method>
    </method>
    <javadoc>
      <text>* Demonstrates advanced sorting.
 * Sorts by sinus of cell values.</text>
    </javadoc>
    <method type="void" name="zdemo3" startLine="566" endLine="591">
      <declaration type="Sorting" name="sort" />
      <declaration type="double[]" name="values" />
      <declaration type="DoubleMatrix1D" name="matrix" />
      <declaration type="cern.colt.function.DoubleComparator" name="comp" />
      <method type="int" name="compare" startLine="571" endLine="574">
        <declaration type="double" name="as" />
        <declaration type="double" name="bs" />
      </method>
      <declaration type="DoubleMatrix1D" name="sorted" />
      <comment>check whether it is really sorted</comment>
      <comment>sorted.assign(
new cern.colt.function.DoubleFunction() {
public double apply(double arg) { return Math.sin(arg); }
}
);</comment>
    </method>
    <javadoc>
      <text>* Demonstrates applying functions.</text>
    </javadoc>
    <method type="void" name="zdemo4" startLine="595" endLine="614">
      <declaration type="double[]" name="values1" />
      <declaration type="double[]" name="values2" />
      <declaration type="DoubleMatrix1D" name="matrix1" />
      <declaration type="DoubleMatrix1D" name="matrix2" />
      <comment>matrix1.assign(matrix2,
new cern.colt.function.DoubleDoubleFunction() {
public double apply(double x, double y) { return Math.pow(x,y); }
}
);</comment>
    </method>
    <javadoc>
      <text>* Demonstrates sorting with precomputation of aggregates (median and sum of logarithms).</text>
    </javadoc>
    <method type="void" name="zdemo5" startLine="618" endLine="686">
      <declaration type="Sorting" name="sort" />
      <declaration type="cern.colt.Timer" name="timer" />
      <declaration type="cern.jet.math.Functions" name="F" />
      <declaration type="DoubleMatrix2D" name="A" />
      <declaration type="DoubleMatrix2D" name="B" />
      <scope startLine="659" endLine="669">
        <declaration type="int" name="r" />
        <declaration type="hep.aida.bin.BinFunction1D[]" name="funs" />
        <declaration type="String[]" name="rowNames" />
        <declaration type="String[]" name="columnNames" />
      </scope>
      <declaration type="cern.colt.matrix.doublealgo.DoubleMatrix1DComparator" name="fun" />
      <method type="int" name="compare" startLine="675" endLine="681">
        <declaration type="double" name="a" />
        <declaration type="double" name="b" />
      </method>
      <comment>for reliable benchmarks, call this method twice: once with small dummy parameters to "warm up" the jitter, then with your real work-load</comment>
      <comment>initialize randomly</comment>
      <comment>also benchmark copying in its several implementation flavours</comment>
      <comment>System.out.println(A);</comment>
      <comment>THE QUICK VERSION (takes some 10 secs)</comment>
      <comment>A = sort.sort(A,hep.aida.bin.BinFunctions1D.sumLog);</comment>
      <comment>check results for correctness</comment>
      <comment>WARNING: be sure NOT TO PRINT huge matrices unless you have tons of main memory and time!!</comment>
      <comment>so we just show the first 5 rows</comment>
      <comment>double a = x.aggregate(F.plus,F.log);</comment>
      <comment>double b = y.aggregate(F.plus,F.log);</comment>
    </method>
    <javadoc>
      <text>* Demonstrates advanced sorting.
 * Sorts by sum of row.</text>
    </javadoc>
    <method type="void" name="zdemo6" startLine="691" endLine="724">
      <declaration type="Sorting" name="sort" />
      <declaration type="double[][]" name="values" />
      <declaration type="DoubleMatrix2D" name="A" />
      <declaration type="DoubleMatrix2D" name="B" />
      <comment>DoubleMatrix1DComparator comp = new DoubleMatrix1DComparator() {
public int compare(DoubleMatrix1D a, DoubleMatrix1D b) {
double as = a.zSum(); double bs = b.zSum();
return as < bs ? -1 : as == bs ? 0 : 1;
}
};</comment>
    </method>
    <javadoc>
      <text>* Demonstrates sorting with precomputation of aggregates, comparing mergesort with quicksort.</text>
    </javadoc>
    <method type="void" name="zdemo7" startLine="728" endLine="760">
      <declaration type="cern.jet.math.Functions" name="F" />
      <declaration type="DoubleMatrix2D" name="A" />
      <declaration type="DoubleMatrix2D" name="B" />
      <declaration type="double[]" name="v1" />
      <declaration type="double[]" name="v2" />
      <declaration type="cern.colt.Timer" name="timer" />
      <comment>for reliable benchmarks, call this method twice: once with small dummy parameters to "warm up" the jitter, then with your real work-load</comment>
      <comment>initialize randomly</comment>
    </method>
    <comment>already has quicksort implemented</comment>
    <comment>override quicksort with mergesort</comment>
  </class>
</source>
