<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.map">
  <import name="cern.colt.function.DoubleIntProcedure" />
  <import name="cern.colt.function.DoubleProcedure" />
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <class name="AbstractDoubleIntMap" extends="AbstractMap" startLine="15">
    <javadoc>
      <text>* Abstract base class for hash maps holding (key,value) associations of type <tt>(double-->int)</tt>.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation</b>:
 * <p>
 * Almost all methods are expressed in terms of {@link #forEachKey(DoubleProcedure)}. 
 * As such they are fully functional, but inefficient. Override them in subclasses if necessary.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.HashMap</see>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="AbstractDoubleIntMap" startLine="33" endLine="33" />
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified key.</text>
      <return><tt>true</tt> if the receiver contains the specified key.</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="39" endLine="47">
      <method type="boolean" name="apply" startLine="42" endLine="44" />
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified value.</text>
      <return><tt>true</tt> if the receiver contains the specified value.</return>
    </javadoc>
    <method type="boolean" name="containsValue" startLine="53" endLine="61">
      <method type="boolean" name="apply" startLine="56" endLine="58" />
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="AbstractDoubleIntMap" name="copy" startLine="67" endLine="69" />
    <javadoc>
      <text>* Compares the specified object with this map for equality.  Returns
 * <tt>true</tt> if the given object is also a map and the two maps
 * represent the same mappings.  More formally, two maps <tt>m1</tt> and
 * <tt>m2</tt> represent the same mappings iff
 * <pre>
 * m1.forEachPair(
 * new DoubleIntProcedure() {
 * public boolean apply(double key, int value) {
 * return m2.containsKey(key) && m2.get(key) == value;
 * }
 * }
 * )
 * &&
 * m2.forEachPair(
 * new DoubleIntProcedure() {
 * public boolean apply(double key, int value) {
 * return m1.containsKey(key) && m1.get(key) == value;
 * }
 * }
 * );
 * </pre>
 * This implementation first checks if the specified object is this map;
 * if so it returns <tt>true</tt>.  Then, it checks if the specified
 * object is a map whose size is identical to the size of this set; if
 * not, it it returns <tt>false</tt>.  If so, it applies the iteration as described above.</text>
      <param>obj object to be compared for equality with this map.</param>
      <return><tt>true</tt> if the specified object is equal to this map.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="101" endLine="124">
      <declaration type="AbstractDoubleIntMap" name="other" />
      <method type="boolean" name="apply" startLine="111" endLine="113" />
      <method type="boolean" name="apply" startLine="119" endLine="121" />
    </method>
    <method name="forEachKey" type="boolean" startLine="125" endLine="135" />
    <javadoc>
      <text>* Applies a procedure to each key of the receiver, if any.
 * Note: Iterates over the keys in no particular order.
 * Subclasses can define a particular order, for example, "sorted by key".
 * All methods which <i>can</i> be expressed in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this method, even if it is no particular order.
 * This is necessary so that, for example, methods <tt>keys</tt> and <tt>values</tt> will yield association pairs, not two uncorrelated lists.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Applies a procedure to each (key,value) pair of the receiver, if any.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachPair" startLine="143" endLine="151">
      <method type="boolean" name="apply" startLine="146" endLine="148" />
    </method>
    <method name="get" type="int" startLine="152" endLine="159" />
    <javadoc>
      <text>* Returns the value associated with the specified key.
 * It is often a good idea to first check with {@link #containsKey(double)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.</text>
      <param>key the key to be searched for.</param>
      <return>the value associated with the specified key; <tt>0</tt> if no such key is present.</return>
    </javadoc>
    <javadoc>
      <text>* Returns the first key the given value is associated with.
 * It is often a good idea to first check with {@link #containsValue(int)} whether there exists an association from a key to this value.
 * Search order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.</text>
      <param>value the value to search for.</param>
      <return>the first key for which holds <tt>get(key) == value</tt>; 
 * returns <tt>Double.NaN</tt> if no such key exists.</return>
    </javadoc>
    <method type="double" name="keyOf" startLine="169" endLine="182">
      <declaration type="double[]" name="foundKey" />
      <declaration type="boolean" name="notFound" />
      <method type="boolean" name="apply" startLine="173" endLine="177">
        <declaration type="boolean" name="found" />
      </method>
    </method>
    <javadoc>
      <text>* Returns a list filled with all keys contained in the receiver.
 * The returned list has a size that equals <tt>this.size()</tt>.
 * Note: Keys are filled into the list in no particular order.
 * However, the order is <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <return>the keys.</return>
    </javadoc>
    <method type="DoubleArrayList" name="keys" startLine="193" endLine="197">
      <declaration type="DoubleArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Fills all keys contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keys" startLine="208" endLine="218">
      <method type="boolean" name="apply" startLine="212" endLine="215" />
    </method>
    <javadoc>
      <text>* Fills all keys <i>sorted ascending by their associated value</i> into the specified list.
 * Fills into the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Primary sort criterium is "value", secondary sort criterium is "key". 
 * This means that if any two values are equal, the smaller key comes first.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (8,6,7)</tt></text>
      <param>keyList the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keysSortedByValue" startLine="232" endLine="234" />
    <javadoc>
      <text>* Fills all pairs satisfying a given condition into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * DoubleIntProcedure condition = new DoubleIntProcedure() { // match even values only
 * public boolean apply(double key, int value) { return value%2==0; }
 * }
 * keys = (8,7,6), values = (1,2,2) --> keyList = (6,8), valueList = (2,1)</tt>
 * </pre></text>
      <param>condition    the condition to be matched. Takes the current key as first and the current value as second argument.</param>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsMatching" startLine="254" endLine="269">
      <method type="boolean" name="apply" startLine="260" endLine="266">
        <scope startLine="261" endLine="264" />
      </method>
    </method>
    <javadoc>
      <text>* Fills all keys and values <i>sorted ascending by key</i> into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size that equals <tt>this.size()</tt>.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (6,7,8), valueList = (2,2,1)</tt></text>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsSortedByKey" startLine="282" endLine="318">
      <scope startLine="313" endLine="315" />
      <comment>keys(keyList);
values(valueList);

final double[] k = keyList.elements();
final int[] v = valueList.elements();
cern.colt.Swapper swapper = new cern.colt.Swapper() {
public void swap(int a, int b) {
int t1;	double t2;
t1 = v[a]; v[a] = v[b]; v[b] = t1;
t2 = k[a]; k[a] = k[b];	k[b] = t2;
}
};

cern.colt.function.IntComparator comp = new cern.colt.function.IntComparator() {
public int compare(int a, int b) {
return k[a]<k[b] ? -1 : k[a]==k[b] ? 0 : 1;
}
};
cern.colt.MultiSorting.sort(0,keyList.size(),comp,swapper);</comment>
      <comment>this variant may be quicker</comment>
      <comment>cern.colt.map.OpenDoubleIntHashMap.hashCollisions = 0;</comment>
      <comment>System.out.println("collisions="+cern.colt.map.OpenDoubleIntHashMap.hashCollisions);</comment>
      <comment>System.out.println("collisions="+cern.colt.map.OpenDoubleIntHashMap.hashCollisions);</comment>
    </method>
    <javadoc>
      <text>* Fills all keys and values <i>sorted ascending by value</i> into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size that equals <tt>this.size()</tt>.
 * Primary sort criterium is "value", secondary sort criterium is "key". 
 * This means that if any two values are equal, the smaller key comes first.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (8,6,7), valueList = (1,2,2)</tt></text>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsSortedByValue" startLine="333" endLine="356">
      <declaration type="double[]" name="k" />
      <declaration type="int[]" name="v" />
      <declaration type="cern.colt.Swapper" name="swapper" />
      <method type="void" name="swap" startLine="340" endLine="344">
        <declaration type="int" name="t1" />
        <declaration type="double" name="t2" />
      </method>
      <declaration type="cern.colt.function.IntComparator" name="comp" />
      <method type="int" name="compare" startLine="348" endLine="350" />
      <comment>cern.colt.map.OpenDoubleIntHashMap.hashCollisions = 0;</comment>
      <comment>System.out.println("collisions="+cern.colt.map.OpenDoubleIntHashMap.hashCollisions);</comment>
    </method>
    <method name="put" type="boolean" startLine="357" endLine="366" />
    <javadoc>
      <text>* Associates the given key with the given value.
 * Replaces any old <tt>(key,someOtherValue)</tt> association, if existing.</text>
      <param>key the key the value shall be associated with.</param>
      <param>value the value to be associated.</param>
      <return><tt>true</tt> if the receiver did not already contain such a key;
 * <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.</return>
    </javadoc>
    <method name="removeKey" type="boolean" startLine="367" endLine="373" />
    <javadoc>
      <text>* Removes the given key with its associated element from the receiver, if present.</text>
      <param>key the key to be removed from the receiver.</param>
      <return><tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each key-value pair, sorted ascending by key.</text>
    </javadoc>
    <method type="String" name="toString" startLine="378" endLine="394">
      <declaration type="DoubleArrayList" name="theKeys" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="int" name="maxIndex" />
      <scope startLine="385" endLine="391">
        <declaration type="double" name="key" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each key-value pair, sorted ascending by value.</text>
    </javadoc>
    <method type="String" name="toStringByValue" startLine="399" endLine="415">
      <declaration type="DoubleArrayList" name="theKeys" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="int" name="maxIndex" />
      <scope startLine="406" endLine="412">
        <declaration type="double" name="key" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a list filled with all values contained in the receiver.
 * The returned list has a size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <return>the values.</return>
    </javadoc>
    <method type="IntArrayList" name="values" startLine="425" endLine="429">
      <declaration type="IntArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Fills all values contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(DoubleProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="values" startLine="440" endLine="450">
      <method type="boolean" name="apply" startLine="444" endLine="447" />
    </method>
    <comment>public static int hashCollisions = 0;  for debug only</comment>
  </class>
</source>
