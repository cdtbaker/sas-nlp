<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.map">
  <import name="cern.colt.function.LongObjectProcedure" />
  <import name="cern.colt.function.LongProcedure" />
  <import name="cern.colt.list.LongArrayList" />
  <import name="cern.colt.list.ObjectArrayList" />
  <class name="AbstractLongObjectMap" extends="AbstractMap" startLine="15">
    <javadoc>
      <text>* Abstract base class for hash maps holding (key,value) associations of type <tt>(long-->Object)</tt>.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation</b>:
 * <p>
 * Almost all methods are expressed in terms of {@link #forEachKey(LongProcedure)}. 
 * As such they are fully functional, but inefficient. Override them in subclasses if necessary.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.HashMap</see>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="AbstractLongObjectMap" startLine="33" endLine="33" />
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified key.</text>
      <return><tt>true</tt> if the receiver contains the specified key.</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="39" endLine="47">
      <method type="boolean" name="apply" startLine="42" endLine="44" />
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified value.
 * Tests for identity.</text>
      <return><tt>true</tt> if the receiver contains the specified value.</return>
    </javadoc>
    <method type="boolean" name="containsValue" startLine="54" endLine="62">
      <method type="boolean" name="apply" startLine="57" endLine="59" />
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="AbstractLongObjectMap" name="copy" startLine="68" endLine="70" />
    <javadoc>
      <text>* Compares the specified object with this map for equality.  Returns
 * <tt>true</tt> if the given object is also a map and the two maps
 * represent the same mappings.  More formally, two maps <tt>m1</tt> and
 * <tt>m2</tt> represent the same mappings iff
 * <pre>
 * m1.forEachPair(
 * new LongObjectProcedure() {
 * public boolean apply(long key, Object value) {
 * return m2.containsKey(key) && m2.get(key) == value;
 * }
 * }
 * )
 * &&
 * m2.forEachPair(
 * new LongObjectProcedure() {
 * public boolean apply(long key, Object value) {
 * return m1.containsKey(key) && m1.get(key) == value;
 * }
 * }
 * );
 * </pre>
 * This implementation first checks if the specified object is this map;
 * if so it returns <tt>true</tt>.  Then, it checks if the specified
 * object is a map whose size is identical to the size of this set; if
 * not, it it returns <tt>false</tt>.  If so, it applies the iteration as described above.</text>
      <param>obj object to be compared for equality with this map.</param>
      <return><tt>true</tt> if the specified object is equal to this map.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="102" endLine="125">
      <declaration type="AbstractLongObjectMap" name="other" />
      <method type="boolean" name="apply" startLine="112" endLine="114" />
      <method type="boolean" name="apply" startLine="120" endLine="122" />
    </method>
    <method name="forEachKey" type="boolean" startLine="126" endLine="136" />
    <javadoc>
      <text>* Applies a procedure to each key of the receiver, if any.
 * Note: Iterates over the keys in no particular order.
 * Subclasses can define a particular order, for example, "sorted by key".
 * All methods which <i>can</i> be expressed in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this method, even if it is no particular order.
 * This is necessary so that, for example, methods <tt>keys</tt> and <tt>values</tt> will yield association pairs, not two uncorrelated lists.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Applies a procedure to each (key,value) pair of the receiver, if any.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachPair" startLine="144" endLine="152">
      <method type="boolean" name="apply" startLine="147" endLine="149" />
    </method>
    <method name="get" type="Object" startLine="153" endLine="160" />
    <javadoc>
      <text>* Returns the value associated with the specified key.
 * It is often a good idea to first check with {@link #containsKey(long)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.</text>
      <param>key the key to be searched for.</param>
      <return>the value associated with the specified key; <tt>null</tt> if no such key is present.</return>
    </javadoc>
    <javadoc>
      <text>* Returns the first key the given value is associated with.
 * It is often a good idea to first check with {@link #containsValue(Object)} whether there exists an association from a key to this value.
 * Search order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.</text>
      <param>value the value to search for.</param>
      <return>the first key for which holds <tt>get(key) == value</tt>; 
 * returns <tt>Long.MIN_VALUE</tt> if no such key exists.</return>
    </javadoc>
    <method type="long" name="keyOf" startLine="170" endLine="183">
      <declaration type="long[]" name="foundKey" />
      <declaration type="boolean" name="notFound" />
      <method type="boolean" name="apply" startLine="174" endLine="178">
        <declaration type="boolean" name="found" />
      </method>
    </method>
    <javadoc>
      <text>* Returns a list filled with all keys contained in the receiver.
 * The returned list has a size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <return>the keys.</return>
    </javadoc>
    <method type="LongArrayList" name="keys" startLine="193" endLine="197">
      <declaration type="LongArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Fills all keys contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keys" startLine="208" endLine="218">
      <method type="boolean" name="apply" startLine="212" endLine="215" />
    </method>
    <javadoc>
      <text>* Fills all keys <i>sorted ascending by their associated value</i> into the specified list.
 * Fills into the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Primary sort criterium is "value", secondary sort criterium is "key". 
 * This means that if any two values are equal, the smaller key comes first.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (8,6,7)</tt></text>
      <param>keyList the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keysSortedByValue" startLine="232" endLine="234" />
    <javadoc>
      <text>* Fills all pairs satisfying a given condition into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * LongObjectProcedure condition = new LongObjectProcedure() { // match even keys only
 * public boolean apply(long key, Object value) { return key%2==0; }
 * }
 * keys = (8,7,6), values = (1,2,2) --> keyList = (6,8), valueList = (2,1)</tt>
 * </pre></text>
      <param>condition    the condition to be matched. Takes the current key as first and the current value as second argument.</param>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsMatching" startLine="254" endLine="269">
      <method type="boolean" name="apply" startLine="260" endLine="266">
        <scope startLine="261" endLine="264" />
      </method>
    </method>
    <javadoc>
      <text>* Fills all keys and values <i>sorted ascending by key</i> into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size that equals <tt>this.size()</tt>.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (6,7,8), valueList = (2,2,1)</tt></text>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsSortedByKey" startLine="282" endLine="289">
      <scope startLine="286" endLine="288" />
    </method>
    <javadoc>
      <text>* Fills all keys and values <i>sorted ascending by value according to natural ordering</i> into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size that equals <tt>this.size()</tt>.
 * Primary sort criterium is "value", secondary sort criterium is "key". 
 * This means that if any two values are equal, the smaller key comes first.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (8,6,7), valueList = (1,2,2)</tt></text>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsSortedByValue" startLine="304" endLine="327">
      <declaration type="long[]" name="k" />
      <declaration type="Object[]" name="v" />
      <declaration type="cern.colt.Swapper" name="swapper" />
      <method type="void" name="swap" startLine="311" endLine="315">
        <declaration type="long" name="t2" />
        <declaration type="Object" name="t1" />
      </method>
      <declaration type="cern.colt.function.IntComparator" name="comp" />
      <method type="int" name="compare" startLine="319" endLine="323">
        <declaration type="int" name="ab" />
      </method>
      <comment>return v[a]<v[b] ? -1 : v[a]>v[b] ? 1 : (k[a]<k[b] ? -1 : (k[a]==k[b] ? 0 : 1));</comment>
    </method>
    <method name="put" type="boolean" startLine="328" endLine="337" />
    <javadoc>
      <text>* Associates the given key with the given value.
 * Replaces any old <tt>(key,someOtherValue)</tt> association, if existing.</text>
      <param>key the key the value shall be associated with.</param>
      <param>value the value to be associated.</param>
      <return><tt>true</tt> if the receiver did not already contain such a key;
 * <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.</return>
    </javadoc>
    <method name="removeKey" type="boolean" startLine="338" endLine="344" />
    <javadoc>
      <text>* Removes the given key with its associated element from the receiver, if present.</text>
      <param>key the key to be removed from the receiver.</param>
      <return><tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each key-value pair, sorted ascending by key.</text>
    </javadoc>
    <method type="String" name="toString" startLine="349" endLine="365">
      <declaration type="LongArrayList" name="theKeys" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="int" name="maxIndex" />
      <scope startLine="356" endLine="362">
        <declaration type="long" name="key" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each key-value pair, sorted ascending by value, according to natural ordering.</text>
    </javadoc>
    <method type="String" name="toStringByValue" startLine="370" endLine="386">
      <declaration type="LongArrayList" name="theKeys" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="int" name="maxIndex" />
      <scope startLine="377" endLine="383">
        <declaration type="long" name="key" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a list filled with all values contained in the receiver.
 * The returned list has a size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <return>the values.</return>
    </javadoc>
    <method type="ObjectArrayList" name="values" startLine="396" endLine="400">
      <declaration type="ObjectArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Fills all values contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(LongProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="values" startLine="411" endLine="421">
      <method type="boolean" name="apply" startLine="415" endLine="418" />
    </method>
    <comment>public static int hashCollisions = 0;  for debug only</comment>
  </class>
</source>
