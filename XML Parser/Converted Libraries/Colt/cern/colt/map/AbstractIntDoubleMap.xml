<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.map">
  <import name="cern.colt.function.IntDoubleProcedure" />
  <import name="cern.colt.function.IntProcedure" />
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <class name="AbstractIntDoubleMap" extends="AbstractMap" startLine="15">
    <javadoc>
      <text>* Abstract base class for hash maps holding (key,value) associations of type <tt>(int-->double)</tt>.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Implementation</b>:
 * <p>
 * Almost all methods are expressed in terms of {@link #forEachKey(IntProcedure)}. 
 * As such they are fully functional, but inefficient. Override them in subclasses if necessary.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.HashMap</see>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="AbstractIntDoubleMap" startLine="33" endLine="33" />
    <javadoc>
      <text>* Assigns the result of a function to each value; <tt>v[i] = function(v[i])</tt>.</text>
      <param>function a function object taking as argument the current association's value.</param>
    </javadoc>
    <method type="void" name="assign" startLine="39" endLine="48">
      <method type="boolean" name="apply" startLine="42" endLine="45" />
    </method>
    <javadoc>
      <text>* Clears the receiver, then adds all (key,value) pairs of <tt>other</tt>values to it.</text>
      <param>other the other map to be copied into the receiver.</param>
    </javadoc>
    <method type="void" name="assign" startLine="54" endLine="64">
      <method type="boolean" name="apply" startLine="58" endLine="61" />
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified key.</text>
      <return><tt>true</tt> if the receiver contains the specified key.</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="70" endLine="78">
      <method type="boolean" name="apply" startLine="73" endLine="75" />
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified value.</text>
      <return><tt>true</tt> if the receiver contains the specified value.</return>
    </javadoc>
    <method type="boolean" name="containsValue" startLine="84" endLine="92">
      <method type="boolean" name="apply" startLine="87" endLine="89" />
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="AbstractIntDoubleMap" name="copy" startLine="98" endLine="100" />
    <javadoc>
      <text>* Compares the specified object with this map for equality.  Returns
 * <tt>true</tt> if the given object is also a map and the two maps
 * represent the same mappings.  More formally, two maps <tt>m1</tt> and
 * <tt>m2</tt> represent the same mappings iff
 * <pre>
 * m1.forEachPair(
 * new IntDoubleProcedure() {
 * public boolean apply(int key, double value) {
 * return m2.containsKey(key) && m2.get(key) == value;
 * }
 * }
 * )
 * &&
 * m2.forEachPair(
 * new IntDoubleProcedure() {
 * public boolean apply(int key, double value) {
 * return m1.containsKey(key) && m1.get(key) == value;
 * }
 * }
 * );
 * </pre>
 * This implementation first checks if the specified object is this map;
 * if so it returns <tt>true</tt>.  Then, it checks if the specified
 * object is a map whose size is identical to the size of this set; if
 * not, it it returns <tt>false</tt>.  If so, it applies the iteration as described above.</text>
      <param>obj object to be compared for equality with this map.</param>
      <return><tt>true</tt> if the specified object is equal to this map.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="132" endLine="155">
      <declaration type="AbstractIntDoubleMap" name="other" />
      <method type="boolean" name="apply" startLine="142" endLine="144" />
      <method type="boolean" name="apply" startLine="150" endLine="152" />
    </method>
    <method name="forEachKey" type="boolean" startLine="156" endLine="166" />
    <javadoc>
      <text>* Applies a procedure to each key of the receiver, if any.
 * Note: Iterates over the keys in no particular order.
 * Subclasses can define a particular order, for example, "sorted by key".
 * All methods which <i>can</i> be expressed in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this method, even if it is no particular order.
 * This is necessary so that, for example, methods <tt>keys</tt> and <tt>values</tt> will yield association pairs, not two uncorrelated lists.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Applies a procedure to each (key,value) pair of the receiver, if any.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachPair" startLine="174" endLine="182">
      <method type="boolean" name="apply" startLine="177" endLine="179" />
    </method>
    <method name="get" type="double" startLine="183" endLine="190" />
    <javadoc>
      <text>* Returns the value associated with the specified key.
 * It is often a good idea to first check with {@link #containsKey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.</text>
      <param>key the key to be searched for.</param>
      <return>the value associated with the specified key; <tt>0</tt> if no such key is present.</return>
    </javadoc>
    <javadoc>
      <text>* Returns the first key the given value is associated with.
 * It is often a good idea to first check with {@link #containsValue(double)} whether there exists an association from a key to this value.
 * Search order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.</text>
      <param>value the value to search for.</param>
      <return>the first key for which holds <tt>get(key) == value</tt>; 
 * returns <tt>Integer.MIN_VALUE</tt> if no such key exists.</return>
    </javadoc>
    <method type="int" name="keyOf" startLine="200" endLine="213">
      <declaration type="int[]" name="foundKey" />
      <declaration type="boolean" name="notFound" />
      <method type="boolean" name="apply" startLine="204" endLine="208">
        <declaration type="boolean" name="found" />
      </method>
    </method>
    <javadoc>
      <text>* Returns a list filled with all keys contained in the receiver.
 * The returned list has a size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <return>the keys.</return>
    </javadoc>
    <method type="IntArrayList" name="keys" startLine="223" endLine="227">
      <declaration type="IntArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Fills all keys contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keys" startLine="238" endLine="248">
      <method type="boolean" name="apply" startLine="242" endLine="245" />
    </method>
    <javadoc>
      <text>* Fills all keys <i>sorted ascending by their associated value</i> into the specified list.
 * Fills into the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Primary sort criterium is "value", secondary sort criterium is "key". 
 * This means that if any two values are equal, the smaller key comes first.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (8,6,7)</tt></text>
      <param>keyList the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keysSortedByValue" startLine="262" endLine="264" />
    <javadoc>
      <text>* Fills all pairs satisfying a given condition into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * IntDoubleProcedure condition = new IntDoubleProcedure() { // match even keys only
 * public boolean apply(int key, double value) { return key%2==0; }
 * }
 * keys = (8,7,6), values = (1,2,2) --> keyList = (6,8), valueList = (2,1)</tt>
 * </pre></text>
      <param>condition    the condition to be matched. Takes the current key as first and the current value as second argument.</param>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsMatching" startLine="284" endLine="299">
      <method type="boolean" name="apply" startLine="290" endLine="296">
        <scope startLine="291" endLine="294" />
      </method>
    </method>
    <javadoc>
      <text>* Fills all keys and values <i>sorted ascending by key</i> into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size that equals <tt>this.size()</tt>.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (6,7,8), valueList = (2,2,1)</tt></text>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsSortedByKey" startLine="312" endLine="319">
      <scope startLine="316" endLine="318" />
    </method>
    <javadoc>
      <text>* Fills all keys and values <i>sorted ascending by value</i> into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size that equals <tt>this.size()</tt>.
 * Primary sort criterium is "value", secondary sort criterium is "key". 
 * This means that if any two values are equal, the smaller key comes first.
 * <p>
 * <b>Example:</b>
 * <br>
 * <tt>keys = (8,7,6), values = (1,2,2) --> keyList = (8,6,7), valueList = (1,2,2)</tt></text>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsSortedByValue" startLine="334" endLine="355">
      <declaration type="int[]" name="k" />
      <declaration type="double[]" name="v" />
      <declaration type="cern.colt.Swapper" name="swapper" />
      <method type="void" name="swap" startLine="341" endLine="345">
        <declaration type="int" name="t2" />
        <declaration type="double" name="t1" />
      </method>
      <declaration type="cern.colt.function.IntComparator" name="comp" />
      <method type="int" name="compare" startLine="349" endLine="351" />
    </method>
    <method name="put" type="boolean" startLine="356" endLine="365" />
    <javadoc>
      <text>* Associates the given key with the given value.
 * Replaces any old <tt>(key,someOtherValue)</tt> association, if existing.</text>
      <param>key the key the value shall be associated with.</param>
      <param>value the value to be associated.</param>
      <return><tt>true</tt> if the receiver did not already contain such a key;
 * <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.</return>
    </javadoc>
    <method name="removeKey" type="boolean" startLine="366" endLine="372" />
    <javadoc>
      <text>* Removes the given key with its associated element from the receiver, if present.</text>
      <param>key the key to be removed from the receiver.</param>
      <return><tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.</return>
    </javadoc>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each key-value pair, sorted ascending by key.</text>
    </javadoc>
    <method type="String" name="toString" startLine="377" endLine="395">
      <declaration type="IntArrayList" name="theKeys" />
      <declaration type="String" name="tmp" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="int" name="maxIndex" />
      <scope startLine="386" endLine="392">
        <declaration type="int" name="key" />
      </scope>
      <comment>StringBuffer buf = new StringBuffer();</comment>
    </method>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each key-value pair, sorted ascending by value.</text>
    </javadoc>
    <method type="String" name="toStringByValue" startLine="400" endLine="416">
      <declaration type="IntArrayList" name="theKeys" />
      <declaration type="StringBuffer" name="buf" />
      <declaration type="int" name="maxIndex" />
      <scope startLine="407" endLine="413">
        <declaration type="int" name="key" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a list filled with all values contained in the receiver.
 * The returned list has a size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <return>the values.</return>
    </javadoc>
    <method type="DoubleArrayList" name="values" startLine="426" endLine="430">
      <declaration type="DoubleArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Fills all values contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="values" startLine="441" endLine="451">
      <method type="boolean" name="apply" startLine="445" endLine="448" />
    </method>
    <comment>public static int hashCollisions = 0;  for debug only</comment>
  </class>
</source>
