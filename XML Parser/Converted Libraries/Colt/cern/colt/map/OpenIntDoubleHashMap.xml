<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.map">
  <import name="cern.colt.function.IntDoubleProcedure" />
  <import name="cern.colt.function.IntProcedure" />
  <import name="cern.colt.list.ByteArrayList" />
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <class name="OpenIntDoubleHashMap" extends="AbstractIntDoubleMap" startLine="16">
    <javadoc>
      <text>* Hash map holding (key,value) associations of type <tt>(int-->double)</tt>; Automatically grows and shrinks as needed; Implemented using open addressing with double hashing.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * Overrides many methods for performance reasons only.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.HashMap</see>
    </javadoc>
    <javadoc>
      <text>* The hash table keys.</text>
      <serial />
    </javadoc>
    <declaration type="int" name="table" />
    <javadoc>
      <text>* The hash table values.</text>
      <serial />
    </javadoc>
    <declaration type="double" name="values" />
    <javadoc>
      <text>* The state of each hash table entry (FREE, FULL, REMOVED).</text>
      <serial />
    </javadoc>
    <declaration type="byte" name="state" />
    <javadoc>
      <text>* The number of table entries in state==FREE.</text>
      <serial />
    </javadoc>
    <declaration type="int" name="freeEntries" />
    <declaration type="byte" name="FREE" />
    <declaration type="byte" name="FULL" />
    <declaration type="byte" name="REMOVED" />
    <javadoc>
      <text>* Constructs an empty map with default capacity and default load factors.</text>
    </javadoc>
    <method type="constructor" name="OpenIntDoubleHashMap" startLine="60" endLine="62" />
    <javadoc>
      <text>* Constructs an empty map with the specified initial capacity and default load factors.</text>
      <param>initialCapacity   the initial capacity of the map.</param>
      <throws>IllegalArgumentException if the initial capacity is less
 * than zero.</throws>
    </javadoc>
    <method type="constructor" name="OpenIntDoubleHashMap" startLine="70" endLine="72" />
    <javadoc>
      <text>* Constructs an empty map with
 * the specified initial capacity and the specified minimum and maximum load factor.</text>
      <param>initialCapacity   the initial capacity.</param>
      <param>minLoadFactor        the minimum load factor.</param>
      <param>maxLoadFactor        the maximum load factor.</param>
      <throws>IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.</throws>
    </javadoc>
    <method type="constructor" name="OpenIntDoubleHashMap" startLine="82" endLine="84" />
    <javadoc>
      <text>* Assigns the result of a function to each value; <tt>v[i] = function(v[i])</tt>.</text>
      <param>function a function object taking as argument the current association's value.</param>
    </javadoc>
    <method type="void" name="assign" startLine="90" endLine="108">
      <scope startLine="92" endLine="102">
        <declaration type="double" name="multiplicator" />
        <scope startLine="95" endLine="98" />
        <scope startLine="99" endLine="101" />
        <comment>x[i] = mult*x[i]</comment>
      </scope>
      <scope startLine="103" endLine="107">
        <scope startLine="104" endLine="106" />
        <comment>the general case x[i] = f(x[i])</comment>
      </scope>
      <comment>specialization for speed</comment>
    </method>
    <javadoc>
      <text>* Clears the receiver, then adds all (key,value) pairs of <tt>other</tt>values to it.</text>
      <param>other the other map to be copied into the receiver.</param>
    </javadoc>
    <method type="void" name="assign" startLine="114" endLine="130">
      <scope startLine="115" endLine="118" />
      <declaration type="OpenIntDoubleHashMap" name="source" />
      <declaration type="OpenIntDoubleHashMap" name="copy" />
    </method>
    <javadoc>
      <text>* Removes all (key,value) associations from the receiver.
 * Implicitly calls <tt>trimToSize()</tt>.</text>
    </javadoc>
    <method type="void" name="clear" startLine="135" endLine="152">
      <comment>new DoubleArrayList(values).fillFromToWith(0, state.length-1, 0);  delta</comment>
      <comment>if (debug) {
for (int i=table.length; --i >= 0; ) {
state[i] = FREE;
table[i]= Integer.MAX_VALUE;
values[i]= Double.NaN;
}
}</comment>
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="158" endLine="164">
      <declaration type="OpenIntDoubleHashMap" name="copy" />
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified key.</text>
      <return><tt>true</tt> if the receiver contains the specified key.</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="170" endLine="172" />
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified value.</text>
      <return><tt>true</tt> if the receiver contains the specified value.</return>
    </javadoc>
    <method type="boolean" name="containsValue" startLine="178" endLine="180" />
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.
 * <p>
 * This method never need be called; it is for performance tuning only.
 * Calling this method before <tt>put()</tt>ing a large number of associations boosts performance,
 * because the receiver will grow only once instead of potentially many times and hash collisions get less probable.</text>
      <param>minCapacity   the desired minimum capacity.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="191" endLine="196">
      <scope startLine="192" endLine="195">
        <declaration type="int" name="newCapacity" />
      </scope>
    </method>
    <javadoc>
      <text>* Applies a procedure to each key of the receiver, if any.
 * Note: Iterates over the keys in no particular order.
 * Subclasses can define a particular order, for example, "sorted by key".
 * All methods which <i>can</i> be expressed in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this method, even if it is no particular order.
 * This is necessary so that, for example, methods <tt>keys</tt> and <tt>values</tt> will yield association pairs, not two uncorrelated lists.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachKey" startLine="207" endLine="212">
      <scope startLine="208" endLine="210" />
    </method>
    <javadoc>
      <text>* Applies a procedure to each (key,value) pair of the receiver, if any.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachPair" startLine="220" endLine="225">
      <scope startLine="221" endLine="223" />
    </method>
    <javadoc>
      <text>* Returns the value associated with the specified key.
 * It is often a good idea to first check with {@link #containsKey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.</text>
      <param>key the key to be searched for.</param>
      <return>the value associated with the specified key; <tt>0</tt> if no such key is present.</return>
    </javadoc>
    <method type="double" name="get" startLine="233" endLine="237">
      <declaration type="int" name="i" />
      <comment>not contained</comment>
    </method>
    <javadoc>
      <param>key the key to be added to the receiver.</param>
      <return>the index where the key would need to be inserted, if it is not already contained.
 * Returns -index-1 if the key is already contained at slot index.
 * Therefore, if the returned index < 0, then it is already contained at slot -index-1.
 * If the returned index >= 0, then it is NOT already contained and should be inserted at slot index.</return>
    </javadoc>
    <method type="int" name="indexOfInsertion" startLine="245" endLine="286">
      <declaration type="int[]" name="tab" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="length" />
      <declaration type="int" name="hash" />
      <declaration type="int" name="i" />
      <declaration type="int" name="decrement" />
      <scope startLine="258" endLine="262">
        <comment>hashCollisions++;</comment>
      </scope>
      <scope startLine="264" endLine="275">
        <declaration type="int" name="j" />
        <scope startLine="269" endLine="273" />
        <comment>stop if we find a free slot, or if we find the key itself.</comment>
        <comment>do skip over removed slots (yes, open addressing is like that...)</comment>
        <comment>assertion: there is at least one FREE slot.</comment>
        <comment>hashCollisions++;</comment>
      </scope>
      <scope startLine="278" endLine="282">
        <comment>key already contained at slot i.</comment>
        <comment>return a negative number identifying the slot.</comment>
      </scope>
      <comment>double hashing, see http:www.eece.unm.edu/faculty/heileman/hash/node4.html</comment>
      <comment>int decrement = (hash / length) % length;</comment>
      <comment>stop if we find a removed or free slot, or if we find the key itself</comment>
      <comment>do NOT skip over removed slots (yes, open addressing is like that...)</comment>
      <comment>not already contained, should be inserted at slot i.</comment>
      <comment>return a number >= 0 identifying the slot.</comment>
    </method>
    <javadoc>
      <param>key the key to be searched in the receiver.</param>
      <return>the index where the key is contained in the receiver, else returns -1.</return>
    </javadoc>
    <method type="int" name="indexOfKey" startLine="291" endLine="313">
      <declaration type="int[]" name="tab" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="length" />
      <declaration type="int" name="hash" />
      <declaration type="int" name="i" />
      <declaration type="int" name="decrement" />
      <scope startLine="305" endLine="309">
        <comment>hashCollisions++;</comment>
      </scope>
      <comment>double hashing, see http:www.eece.unm.edu/faculty/heileman/hash/node4.html</comment>
      <comment>int decrement = (hash / length) % length;</comment>
      <comment>stop if we find a free slot, or if we find the key itself.</comment>
      <comment>do skip over removed slots (yes, open addressing is like that...)</comment>
      <comment>assertion: there is at least one FREE slot.</comment>
      <comment>not found</comment>
      <comment>found, return index where key is contained</comment>
    </method>
    <javadoc>
      <param>value the value to be searched in the receiver.</param>
      <return>the index where the value is contained in the receiver, returns -1 if the value was not found.</return>
    </javadoc>
    <method type="int" name="indexOfValue" startLine="318" endLine="327">
      <declaration type="double[]" name="val" />
      <declaration type="byte[]" name="stat" />
      <scope startLine="322" endLine="324" />
      <comment>not found</comment>
    </method>
    <javadoc>
      <text>* Returns the first key the given value is associated with.
 * It is often a good idea to first check with {@link #containsValue(double)} whether there exists an association from a key to this value.
 * Search order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.</text>
      <param>value the value to search for.</param>
      <return>the first key for which holds <tt>get(key) == value</tt>; 
 * returns <tt>Integer.MIN_VALUE</tt> if no such key exists.</return>
    </javadoc>
    <method type="int" name="keyOf" startLine="337" endLine="342">
      <declaration type="int" name="i" />
      <comment>returns the first key found; there may be more matching keys, however.</comment>
    </method>
    <javadoc>
      <text>* Fills all keys contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keys" startLine="353" endLine="364">
      <declaration type="int[]" name="elements" />
      <declaration type="int[]" name="tab" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="j" />
      <scope startLine="361" endLine="363" />
    </method>
    <javadoc>
      <text>* Fills all pairs satisfying a given condition into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * IntDoubleProcedure condition = new IntDoubleProcedure() { // match even keys only
 * public boolean apply(int key, double value) { return key%2==0; }
 * }
 * keys = (8,7,6), values = (1,2,2) --> keyList = (6,8), valueList = (2,1)</tt>
 * </pre></text>
      <param>condition    the condition to be matched. Takes the current key as first and the current value as second argument.</param>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsMatching" startLine="384" endLine="394">
      <scope startLine="388" endLine="393">
        <scope startLine="389" endLine="392" />
      </scope>
    </method>
    <javadoc>
      <text>* Associates the given key with the given value.
 * Replaces any old <tt>(key,someOtherValue)</tt> association, if existing.</text>
      <param>key the key the value shall be associated with.</param>
      <param>value the value to be associated.</param>
      <return><tt>true</tt> if the receiver did not already contain such a key;
 * <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.</return>
    </javadoc>
    <method type="boolean" name="put" startLine="404" endLine="436">
      <declaration type="int" name="i" />
      <scope startLine="406" endLine="412">
        <comment>already contained</comment>
        <comment>if (debug) if (this.state[i] != FULL) throw new InternalError();</comment>
        <comment>if (debug) if (this.table[i] != key) throw new InternalError();</comment>
      </scope>
      <scope startLine="414" endLine="422">
        <declaration type="int" name="newCapacity" />
        <comment>System.out.print("grow rehashing ");
System.out.println("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");</comment>
      </scope>
      <scope startLine="430" endLine="433">
        <declaration type="int" name="newCapacity" />
        <comment>delta</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Rehashes the contents of the receiver into a new table
 * with a smaller or larger capacity.
 * This method is called automatically when the
 * number of keys in the receiver exceeds the high water mark or falls below the low water mark.</text>
    </javadoc>
    <method type="void" name="rehash" startLine="443" endLine="478">
      <declaration type="int" name="oldCapacity" />
      <declaration type="int[]" name="oldTable" />
      <declaration type="double[]" name="oldValues" />
      <declaration type="byte[]" name="oldState" />
      <declaration type="int[]" name="newTable" />
      <declaration type="double[]" name="newValues" />
      <declaration type="byte[]" name="newState" />
      <scope startLine="466" endLine="475">
        <scope startLine="467" endLine="474">
          <declaration type="int" name="element" />
          <declaration type="int" name="index" />
        </scope>
      </scope>
      <comment>if (oldCapacity == newCapacity) return;</comment>
      <comment>if (debug) check();</comment>
      <comment>delta</comment>
      <comment>if (debug) check();</comment>
    </method>
    <javadoc>
      <text>* Removes the given key with its associated element from the receiver, if present.</text>
      <param>key the key to be removed from the receiver.</param>
      <return><tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="removeKey" startLine="485" endLine="510">
      <declaration type="int" name="i" />
      <scope startLine="498" endLine="507">
        <declaration type="int" name="newCapacity" />
        <comment>if (table.length != newCapacity) {
System.out.print("shrink rehashing ");
System.out.println("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
}</comment>
      </scope>
      <comment>key not contained</comment>
      <comment>if (debug) if (this.state[i] == FREE) throw new InternalError();</comment>
      <comment>if (debug) if (this.state[i] == REMOVED) throw new InternalError();</comment>
      <comment>this.values[i]=0;  delta</comment>
      <comment>if (debug) this.table[i]=Integer.MAX_VALUE;  delta</comment>
      <comment>if (debug) this.values[i]=Double.NaN;  delta</comment>
    </method>
    <javadoc>
      <text>* Initializes the receiver.</text>
      <param>initialCapacity   the initial capacity of the receiver.</param>
      <param>minLoadFactor        the minLoadFactor of the receiver.</param>
      <param>maxLoadFactor        the maxLoadFactor of the receiver.</param>
      <throws>IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.</throws>
    </javadoc>
    <method type="void" name="setUp" startLine="519" endLine="543">
      <declaration type="int" name="capacity" />
      <comment>open addressing needs at least one FREE slot at any time.</comment>
      <comment>memory will be exhausted long before this pathological case happens, anyway.</comment>
      <comment>delta</comment>
      <comment>lowWaterMark will be established upon first expansion.</comment>
      <comment>establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).</comment>
      <comment>After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.</comment>
      <comment>See ensureCapacity(...)</comment>
    </method>
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
 * storage of the receiver.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="549" endLine="556">
      <declaration type="int" name="newCapacity" />
      <scope startLine="553" endLine="555" />
      <comment>* 1.2 because open addressing's performance exponentially degrades beyond that point</comment>
      <comment>so that even rehashing the table can take very long</comment>
    </method>
    <javadoc>
      <text>* Fills all values contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="values" startLine="567" endLine="578">
      <declaration type="double[]" name="elements" />
      <declaration type="double[]" name="val" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="j" />
      <scope startLine="575" endLine="577" />
    </method>
    <comment>public static int hashCollisions = 0;</comment>
  </class>
</source>
