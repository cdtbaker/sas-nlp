<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.map">
  <import name="cern.colt.function.IntObjectProcedure" />
  <import name="cern.colt.function.IntProcedure" />
  <import name="cern.colt.list.ByteArrayList" />
  <import name="cern.colt.list.IntArrayList" />
  <import name="cern.colt.list.ObjectArrayList" />
  <class name="OpenIntObjectHashMap" extends="AbstractIntObjectMap" startLine="16">
    <javadoc>
      <text>* Hash map holding (key,value) associations of type <tt>(int-->Object)</tt>; Automatically grows and shrinks as needed; Implemented using open addressing with double hashing.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * Overrides many methods for performance reasons only.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.HashMap</see>
    </javadoc>
    <javadoc>
      <text>* The hash table keys.</text>
      <serial />
    </javadoc>
    <declaration type="int" name="table" />
    <javadoc>
      <text>* The hash table values.</text>
      <serial />
    </javadoc>
    <declaration type="Object" name="values" />
    <javadoc>
      <text>* The state of each hash table entry (FREE, FULL, REMOVED).</text>
      <serial />
    </javadoc>
    <declaration type="byte" name="state" />
    <javadoc>
      <text>* The number of table entries in state==FREE.</text>
      <serial />
    </javadoc>
    <declaration type="int" name="freeEntries" />
    <declaration type="byte" name="FREE" />
    <declaration type="byte" name="FULL" />
    <declaration type="byte" name="REMOVED" />
    <javadoc>
      <text>* Constructs an empty map with default capacity and default load factors.</text>
    </javadoc>
    <method type="constructor" name="OpenIntObjectHashMap" startLine="59" endLine="61" />
    <javadoc>
      <text>* Constructs an empty map with the specified initial capacity and default load factors.</text>
      <param>initialCapacity   the initial capacity of the map.</param>
      <throws>IllegalArgumentException if the initial capacity is less
 * than zero.</throws>
    </javadoc>
    <method type="constructor" name="OpenIntObjectHashMap" startLine="69" endLine="71" />
    <javadoc>
      <text>* Constructs an empty map with
 * the specified initial capacity and the specified minimum and maximum load factor.</text>
      <param>initialCapacity   the initial capacity.</param>
      <param>minLoadFactor        the minimum load factor.</param>
      <param>maxLoadFactor        the maximum load factor.</param>
      <throws>IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.</throws>
    </javadoc>
    <method type="constructor" name="OpenIntObjectHashMap" startLine="81" endLine="83" />
    <javadoc>
      <text>* Removes all (key,value) associations from the receiver.
 * Implicitly calls <tt>trimToSize()</tt>.</text>
    </javadoc>
    <method type="void" name="clear" startLine="88" endLine="95">
      <comment>delta</comment>
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="101" endLine="107">
      <declaration type="OpenIntObjectHashMap" name="copy" />
    </method>
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified key.</text>
      <return><tt>true</tt> if the receiver contains the specified key.</return>
    </javadoc>
    <method type="boolean" name="containsKey" startLine="113" endLine="115" />
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains the specified value.</text>
      <return><tt>true</tt> if the receiver contains the specified value.</return>
    </javadoc>
    <method type="boolean" name="containsValue" startLine="121" endLine="123" />
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.
 * <p>
 * This method never need be called; it is for performance tuning only.
 * Calling this method before <tt>put()</tt>ing a large number of associations boosts performance,
 * because the receiver will grow only once instead of potentially many times and hash collisions get less probable.</text>
      <param>minCapacity   the desired minimum capacity.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="134" endLine="139">
      <scope startLine="135" endLine="138">
        <declaration type="int" name="newCapacity" />
      </scope>
    </method>
    <javadoc>
      <text>* Applies a procedure to each key of the receiver, if any.
 * Note: Iterates over the keys in no particular order.
 * Subclasses can define a particular order, for example, "sorted by key".
 * All methods which <i>can</i> be expressed in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this method, even if it is no particular order.
 * This is necessary so that, for example, methods <tt>keys</tt> and <tt>values</tt> will yield association pairs, not two uncorrelated lists.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachKey" startLine="150" endLine="155">
      <scope startLine="151" endLine="153" />
    </method>
    <javadoc>
      <text>* Applies a procedure to each (key,value) pair of the receiver, if any.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEachPair" startLine="163" endLine="168">
      <scope startLine="164" endLine="166" />
    </method>
    <javadoc>
      <text>* Returns the value associated with the specified key.
 * It is often a good idea to first check with {@link #containsKey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.</text>
      <param>key the key to be searched for.</param>
      <return>the value associated with the specified key; <tt>null</tt> if no such key is present.</return>
    </javadoc>
    <method type="Object" name="get" startLine="176" endLine="180">
      <declaration type="int" name="i" />
      <comment>not contained</comment>
    </method>
    <javadoc>
      <param>key the key to be added to the receiver.</param>
      <return>the index where the key would need to be inserted, if it is not already contained.
 * Returns -index-1 if the key is already contained at slot index.
 * Therefore, if the returned index < 0, then it is already contained at slot -index-1.
 * If the returned index >= 0, then it is NOT already contained and should be inserted at slot index.</return>
    </javadoc>
    <method type="int" name="indexOfInsertion" startLine="188" endLine="229">
      <declaration type="int[]" name="tab" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="length" />
      <declaration type="int" name="hash" />
      <declaration type="int" name="i" />
      <declaration type="int" name="decrement" />
      <scope startLine="201" endLine="205">
        <comment>hashCollisions++;</comment>
      </scope>
      <scope startLine="207" endLine="218">
        <declaration type="int" name="j" />
        <scope startLine="212" endLine="216" />
        <comment>stop if we find a free slot, or if we find the key itself.</comment>
        <comment>do skip over removed slots (yes, open addressing is like that...)</comment>
        <comment>assertion: there is at least one FREE slot.</comment>
        <comment>hashCollisions++;</comment>
      </scope>
      <scope startLine="221" endLine="225">
        <comment>key already contained at slot i.</comment>
        <comment>return a negative number identifying the slot.</comment>
      </scope>
      <comment>double hashing, see http:www.eece.unm.edu/faculty/heileman/hash/node4.html</comment>
      <comment>int decrement = (hash / length) % length;</comment>
      <comment>stop if we find a removed or free slot, or if we find the key itself</comment>
      <comment>do NOT skip over removed slots (yes, open addressing is like that...)</comment>
      <comment>not already contained, should be inserted at slot i.</comment>
      <comment>return a number >= 0 identifying the slot.</comment>
    </method>
    <javadoc>
      <param>key the key to be searched in the receiver.</param>
      <return>the index where the key is contained in the receiver, returns -1 if the key was not found.</return>
    </javadoc>
    <method type="int" name="indexOfKey" startLine="234" endLine="255">
      <declaration type="int[]" name="tab" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="length" />
      <declaration type="int" name="hash" />
      <declaration type="int" name="i" />
      <declaration type="int" name="decrement" />
      <scope startLine="247" endLine="251">
        <comment>hashCollisions++;</comment>
      </scope>
      <comment>double hashing, see http:www.eece.unm.edu/faculty/heileman/hash/node4.html</comment>
      <comment>int decrement = (hash / length) % length;</comment>
      <comment>stop if we find a free slot, or if we find the key itself.</comment>
      <comment>do skip over removed slots (yes, open addressing is like that...)</comment>
      <comment>not found</comment>
      <comment>found, return index where key is contained</comment>
    </method>
    <javadoc>
      <param>value the value to be searched in the receiver.</param>
      <return>the index where the value is contained in the receiver, returns -1 if the value was not found.</return>
    </javadoc>
    <method type="int" name="indexOfValue" startLine="260" endLine="269">
      <declaration type="Object[]" name="val" />
      <declaration type="byte[]" name="stat" />
      <scope startLine="264" endLine="266" />
      <comment>not found</comment>
    </method>
    <javadoc>
      <text>* Returns the first key the given value is associated with.
 * It is often a good idea to first check with {@link #containsValue(Object)} whether there exists an association from a key to this value.
 * Search order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.</text>
      <param>value the value to search for.</param>
      <return>the first key for which holds <tt>get(key) == value</tt>; 
 * returns <tt>Integer.MIN_VALUE</tt> if no such key exists.</return>
    </javadoc>
    <method type="int" name="keyOf" startLine="279" endLine="284">
      <declaration type="int" name="i" />
      <comment>returns the first key found; there may be more matching keys, however.</comment>
    </method>
    <javadoc>
      <text>* Fills all keys contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the keys of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="keys" startLine="295" endLine="306">
      <declaration type="int[]" name="elements" />
      <declaration type="int[]" name="tab" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="j" />
      <scope startLine="303" endLine="305" />
    </method>
    <javadoc>
      <text>* Fills all pairs satisfying a given condition into the specified lists.
 * Fills into the lists, starting at index 0.
 * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * <b>Example:</b>
 * <br>
 * <pre>
 * IntObjectProcedure condition = new IntObjectProcedure() { // match even keys only
 * public boolean apply(int key, Object value) { return key%2==0; }
 * }
 * keys = (8,7,6), values = (1,2,2) --> keyList = (6,8), valueList = (2,1)</tt>
 * </pre></text>
      <param>condition    the condition to be matched. Takes the current key as first and the current value as second argument.</param>
      <param>keyList the list to be filled with keys, can have any size.</param>
      <param>valueList the list to be filled with values, can have any size.</param>
    </javadoc>
    <method type="void" name="pairsMatching" startLine="326" endLine="336">
      <scope startLine="330" endLine="335">
        <scope startLine="331" endLine="334" />
      </scope>
    </method>
    <javadoc>
      <text>* Associates the given key with the given value.
 * Replaces any old <tt>(key,someOtherValue)</tt> association, if existing.</text>
      <param>key the key the value shall be associated with.</param>
      <param>value the value to be associated.</param>
      <return><tt>true</tt> if the receiver did not already contain such a key;
 * <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.</return>
    </javadoc>
    <method type="boolean" name="put" startLine="346" endLine="372">
      <declaration type="int" name="i" />
      <scope startLine="348" endLine="352">
        <comment>already contained</comment>
      </scope>
      <scope startLine="354" endLine="358">
        <declaration type="int" name="newCapacity" />
      </scope>
      <scope startLine="366" endLine="369">
        <declaration type="int" name="newCapacity" />
        <comment>delta</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Rehashes the contents of the receiver into a new table
 * with a smaller or larger capacity.
 * This method is called automatically when the
 * number of keys in the receiver exceeds the high water mark or falls below the low water mark.</text>
    </javadoc>
    <method type="void" name="rehash" startLine="379" endLine="408">
      <declaration type="int" name="oldCapacity" />
      <declaration type="int[]" name="oldTable" />
      <declaration type="Object[]" name="oldValues" />
      <declaration type="byte[]" name="oldState" />
      <declaration type="int[]" name="newTable" />
      <declaration type="Object[]" name="newValues" />
      <declaration type="byte[]" name="newState" />
      <scope startLine="399" endLine="407">
        <scope startLine="400" endLine="406">
          <declaration type="int" name="element" />
          <declaration type="int" name="index" />
        </scope>
      </scope>
      <comment>if (oldCapacity == newCapacity) return;</comment>
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Removes the given key with its associated element from the receiver, if present.</text>
      <param>key the key to be removed from the receiver.</param>
      <return><tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="removeKey" startLine="415" endLine="429">
      <declaration type="int" name="i" />
      <scope startLine="423" endLine="426">
        <declaration type="int" name="newCapacity" />
      </scope>
      <comment>key not contained</comment>
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Initializes the receiver.</text>
      <param>initialCapacity   the initial capacity of the receiver.</param>
      <param>minLoadFactor        the minLoadFactor of the receiver.</param>
      <param>maxLoadFactor        the maxLoadFactor of the receiver.</param>
      <throws>IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.</throws>
    </javadoc>
    <method type="void" name="setUp" startLine="438" endLine="462">
      <declaration type="int" name="capacity" />
      <comment>open addressing needs at least one FREE slot at any time.</comment>
      <comment>memory will be exhausted long before this pathological case happens, anyway.</comment>
      <comment>delta</comment>
      <comment>lowWaterMark will be established upon first expansion.</comment>
      <comment>establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).</comment>
      <comment>After all the idea of an "initialCapacity" implies violating lowWaterMarks when an object is young.</comment>
      <comment>See ensureCapacity(...)</comment>
    </method>
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
 * storage of the receiver.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="468" endLine="475">
      <declaration type="int" name="newCapacity" />
      <scope startLine="472" endLine="474" />
      <comment>* 1.2 because open addressing's performance exponentially degrades beyond that point</comment>
      <comment>so that even rehashing the table can take very long</comment>
    </method>
    <javadoc>
      <text>* Fills all values contained in the receiver into the specified list.
 * Fills the list, starting at index 0.
 * After this call returns the specified list has a new size that equals <tt>this.size()</tt>.
 * Iteration order is guaranteed to be <i>identical</i> to the order used by method {@link #forEachKey(IntProcedure)}.
 * <p>
 * This method can be used to iterate over the values of the receiver.</text>
      <param>list the list to be filled, can have any size.</param>
    </javadoc>
    <method type="void" name="values" startLine="486" endLine="497">
      <declaration type="Object[]" name="elements" />
      <declaration type="Object[]" name="val" />
      <declaration type="byte[]" name="stat" />
      <declaration type="int" name="j" />
      <scope startLine="494" endLine="496" />
    </method>
  </class>
</source>
