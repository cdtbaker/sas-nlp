<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.map">
  <class name="AbstractMap" extends="cern.colt.PersistentObject" startLine="11">
    <javadoc>
      <text>* Abstract base class for hash maps holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc. as keys and/or values.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * Note that implementations are not synchronized.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.HashMap</see>
    </javadoc>
    <javadoc>
      <text>* The number of distinct associations in the map; its "size()".</text>
    </javadoc>
    <declaration type="int" name="distinct" />
    <javadoc>
      <text>* The table capacity c=table.length always satisfies the invariant
 * <tt>c * minLoadFactor <= s <= c * maxLoadFactor</tt>, where s=size() is the number of associations currently contained.
 * The term "c * minLoadFactor" is called the "lowWaterMark", "c * maxLoadFactor" is called the "highWaterMark".
 * In other words, the table capacity (and proportionally the memory used by this class) oscillates within these constraints.
 * The terms are precomputed and cached to avoid recalculating them each time put(..) or removeKey(...) is called.</text>
    </javadoc>
    <declaration type="int" name="lowWaterMark" />
    <declaration type="int" name="highWaterMark" />
    <javadoc>
      <text>* The minimum load factor for the hashtable.</text>
    </javadoc>
    <declaration type="double" name="minLoadFactor" />
    <javadoc>
      <text>* The maximum load factor for the hashtable.</text>
    </javadoc>
    <declaration type="double" name="maxLoadFactor" />
    <declaration type="int" name="defaultCapacity" />
    <declaration type="double" name="defaultMinLoadFactor" />
    <declaration type="double" name="defaultMaxLoadFactor" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="AbstractMap" startLine="55" endLine="55" />
    <javadoc>
      <text>* Chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant
 * <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt>
 * and has at least one FREE slot for the given size.</text>
    </javadoc>
    <method type="int" name="chooseGrowCapacity" startLine="61" endLine="63" />
    <javadoc>
      <text>* Returns new high water mark threshold based on current capacity and maxLoadFactor.</text>
      <return>int the new threshold.</return>
    </javadoc>
    <method type="int" name="chooseHighWaterMark" startLine="68" endLine="70">
      <comment>makes sure there is always at least one FREE slot</comment>
    </method>
    <javadoc>
      <text>* Returns new low water mark threshold based on current capacity and minLoadFactor.</text>
      <return>int the new threshold.</return>
    </javadoc>
    <method type="int" name="chooseLowWaterMark" startLine="75" endLine="77" />
    <javadoc>
      <text>* Chooses a new prime table capacity neither favoring shrinking nor growing,
 * that (approximately) satisfies the invariant
 * <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt>
 * and has at least one FREE slot for the given size.</text>
    </javadoc>
    <method type="int" name="chooseMeanCapacity" startLine="84" endLine="86" />
    <javadoc>
      <text>* Chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant
 * <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt>
 * and has at least one FREE slot for the given size.</text>
    </javadoc>
    <method type="int" name="chooseShrinkCapacity" startLine="92" endLine="94" />
    <method name="clear" type="void" startLine="95" endLine="98" />
    <javadoc>
      <text>* Removes all (key,value) associations from the receiver.</text>
    </javadoc>
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.
 * <p>
 * This method never need be called; it is for performance tuning only.
 * Calling this method before <tt>put()</tt>ing a large number of associations boosts performance,
 * because the receiver will grow only once instead of potentially many times.
 * <p>
 * <b>This default implementation does nothing.</b> Override this method if necessary.</text>
      <param>minCapacity   the desired minimum capacity.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="111" endLine="111" />
    <javadoc>
      <text>* Returns <tt>true</tt> if the receiver contains no (key,value) associations.</text>
      <return><tt>true</tt> if the receiver contains no (key,value) associations.</return>
    </javadoc>
    <method type="boolean" name="isEmpty" startLine="117" endLine="119" />
    <javadoc>
      <text>* Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).</text>
      <param>desiredCapacity the capacity desired by the user.</param>
      <return>the capacity which should be used for a hashtable.</return>
    </javadoc>
    <method type="int" name="nextPrime" startLine="125" endLine="127" />
    <javadoc>
      <text>* Initializes the receiver.
 * You will almost certainly need to override this method in subclasses to initialize the hash table.</text>
      <param>initialCapacity   the initial capacity of the receiver.</param>
      <param>minLoadFactor     the minLoadFactor of the receiver.</param>
      <param>maxLoadFactor     the maxLoadFactor of the receiver.</param>
      <throws>IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.</throws>
    </javadoc>
    <method type="void" name="setUp" startLine="137" endLine="146" />
    <javadoc>
      <text>* Returns the number of (key,value) associations currently contained.</text>
      <return>the number of (key,value) associations currently contained.</return>
    </javadoc>
    <method type="int" name="size" startLine="152" endLine="154" />
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
 * storage of the receiver.
 * <p>
 * This default implementation does nothing. Override this method if necessary.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="162" endLine="162" />
    <comment>public static boolean debug = false;  debug only</comment>
  </class>
</source>
