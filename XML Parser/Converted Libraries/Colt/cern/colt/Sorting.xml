<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt">
  <import name="java.util.Comparator" />
  <import name="cern.colt.function.ByteComparator" />
  <import name="cern.colt.function.CharComparator" />
  <import name="cern.colt.function.DoubleComparator" />
  <import name="cern.colt.function.FloatComparator" />
  <import name="cern.colt.function.IntComparator" />
  <import name="cern.colt.function.LongComparator" />
  <import name="cern.colt.function.ShortComparator" />
  <class name="Sorting" extends="Object" startLine="20">
    <javadoc>
      <text>* Quicksorts, mergesorts and binary searches; complements <tt>java.util.Arrays</tt>.
 * Contains, for example, the quicksort on Comparators and Comparables, which are still missing in <tt>java.util.Arrays</tt> of JDK 1.2.
 * Also provides mergesorts for types not supported in <tt>java.util.Arrays</tt>, as well as a couple of other methods for primitive arrays.
 * The quicksorts and mergesorts are the JDK 1.2 V1.26 algorithms, modified as necessary.</text>
      <see>cern.colt.GenericSorting</see>
      <see>cern.colt.matrix.doublealgo.Sorting</see>
      <see>java.util.Arrays</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 03-Jul-99</version>
    </javadoc>
    <declaration type="int" name="SMALL" />
    <declaration type="int" name="MEDIUM" />
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="Sorting" startLine="39" endLine="39" />
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="63" endLine="73">
      <declaration type="byte" name="midVal" />
      <scope startLine="65" endLine="71">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="97" endLine="107">
      <declaration type="char" name="midVal" />
      <scope startLine="99" endLine="105">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="131" endLine="141">
      <declaration type="double" name="midVal" />
      <scope startLine="133" endLine="139">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="165" endLine="175">
      <declaration type="float" name="midVal" />
      <scope startLine="167" endLine="173">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="199" endLine="218">
      <declaration type="int" name="midVal" />
      <scope startLine="201" endLine="207">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
      <comment>even for very short lists (0,1,2,3 elems) this is only 10% faster
while (from<=to && list[from++] < key) ;
if (from<=to) {
if (list[--from] == key) return from;
}
return -(from + 1);</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="242" endLine="252">
      <declaration type="long" name="midVal" />
      <scope startLine="244" endLine="250">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm. The list must be sorted into ascending order
 * according to the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * If the list is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which instance
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <param>comparator the comparator by which the list is sorted.</param>
      <throws>ClassCastException if the list contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
      <see>java.util.Comparator</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="286" endLine="298">
      <declaration type="Object" name="midVal" />
      <scope startLine="288" endLine="296">
        <declaration type="int" name="mid" />
        <declaration type="int" name="cmp" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="322" endLine="332">
      <declaration type="short" name="midVal" />
      <scope startLine="324" endLine="330">
        <declaration type="int" name="mid" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Generically searches the list for the specified value using
 * the binary search algorithm.  The list must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the list contains multiple elements
 * equal to the specified key, there is no guarantee which of the multiple elements
 * will be found.</text>
      <param>list the list to be searched.</param>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the list;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the list: the index of the first
 * element greater than the key, or <tt>list.length</tt>, if all
 * elements in the list are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="356" endLine="366">
      <declaration type="int" name="dummy" />
      <scope startLine="358" endLine="364">
        <declaration type="int" name="mid" />
        <declaration type="int" name="comparison" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <method type="int" name="lower_bound" startLine="368" endLine="380">
      <declaration type="int" name="len" />
      <scope startLine="370" endLine="378">
        <declaration type="int" name="half" />
        <declaration type="int" name="middle" />
        <scope startLine="373" endLine="376" />
      </scope>
    </method>
    <method type="int" name="upper_bound" startLine="382" endLine="395">
      <declaration type="int" name="len" />
      <scope startLine="384" endLine="393">
        <declaration type="int" name="half" />
        <declaration type="int" name="middle" />
        <scope startLine="389" endLine="392" />
      </scope>
    </method>
    <method type="void" name="inplace_merge" startLine="397" endLine="438">
      <scope startLine="400" endLine="407">
        <scope startLine="401" endLine="405">
          <declaration type="int" name="tmp" />
        </scope>
      </scope>
      <declaration type="int" name="firstCut" />
      <declaration type="int" name="secondCut" />
      <scope startLine="410" endLine="413" />
      <scope startLine="413" endLine="416" />
      <declaration type="int" name="first2" />
      <declaration type="int" name="middle2" />
      <declaration type="int" name="last2" />
      <scope startLine="423" endLine="431">
        <declaration type="int" name="first1" />
        <declaration type="int" name="last1" />
        <declaration type="int" name="tmp" />
        <scope startLine="426" endLine="426" />
        <scope startLine="428" endLine="428" />
        <scope startLine="430" endLine="430" />
      </scope>
      <comment>rotate(array, firstCut, middle, secondCut);</comment>
      <comment>is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are "static private")</comment>
      <comment>speedup = 1.7</comment>
      <comment>begin inline</comment>
      <comment>end inline</comment>
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="442" endLine="449">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="453" endLine="460">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="464" endLine="471">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="475" endLine="482">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="486" endLine="493">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="497" endLine="504">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="508" endLine="515">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="519" endLine="526">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Returns the index of the median of the three indexed chars.</text>
    </javadoc>
    <method type="int" name="med3" startLine="530" endLine="537">
      <declaration type="int" name="ab" />
      <declaration type="int" name="ac" />
      <declaration type="int" name="bc" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="559" endLine="563">
      <declaration type="byte[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="593" endLine="597">
      <declaration type="byte[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="618" endLine="622">
      <declaration type="char[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="652" endLine="656">
      <declaration type="char[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="677" endLine="679" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="709" endLine="713">
      <declaration type="double[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="734" endLine="736" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="766" endLine="770">
      <declaration type="float[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="791" endLine="795">
      <declaration type="int[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="825" endLine="829">
      <declaration type="int[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="850" endLine="854">
      <declaration type="long[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="884" endLine="888">
      <declaration type="long[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSort" startLine="909" endLine="913">
      <declaration type="short[]" name="aux" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSort" startLine="943" endLine="947">
      <declaration type="short[]" name="aux" />
    </method>
    <method type="void" name="mergeSort1" startLine="948" endLine="978">
      <declaration type="int" name="length" />
      <scope startLine="952" endLine="957" />
      <declaration type="int" name="mid" />
      <scope startLine="966" endLine="969" />
      <scope startLine="972" endLine="977" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="979" endLine="1009">
      <declaration type="int" name="length" />
      <scope startLine="983" endLine="988" />
      <declaration type="int" name="mid" />
      <scope startLine="997" endLine="1000" />
      <scope startLine="1003" endLine="1008" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1010" endLine="1040">
      <declaration type="int" name="length" />
      <scope startLine="1014" endLine="1019" />
      <declaration type="int" name="mid" />
      <scope startLine="1028" endLine="1031" />
      <scope startLine="1034" endLine="1039" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1041" endLine="1071">
      <declaration type="int" name="length" />
      <scope startLine="1045" endLine="1050" />
      <declaration type="int" name="mid" />
      <scope startLine="1059" endLine="1062" />
      <scope startLine="1065" endLine="1070" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1072" endLine="1102">
      <declaration type="int" name="length" />
      <scope startLine="1076" endLine="1081" />
      <declaration type="int" name="mid" />
      <scope startLine="1090" endLine="1093" />
      <scope startLine="1096" endLine="1101" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1103" endLine="1133">
      <declaration type="int" name="length" />
      <scope startLine="1107" endLine="1112" />
      <declaration type="int" name="mid" />
      <scope startLine="1121" endLine="1124" />
      <scope startLine="1127" endLine="1132" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1134" endLine="1164">
      <declaration type="int" name="length" />
      <scope startLine="1138" endLine="1143" />
      <declaration type="int" name="mid" />
      <scope startLine="1152" endLine="1155" />
      <scope startLine="1158" endLine="1163" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1165" endLine="1195">
      <declaration type="int" name="length" />
      <scope startLine="1169" endLine="1174" />
      <declaration type="int" name="mid" />
      <scope startLine="1183" endLine="1186" />
      <scope startLine="1189" endLine="1194" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1196" endLine="1226">
      <declaration type="int" name="length" />
      <scope startLine="1200" endLine="1205" />
      <declaration type="int" name="mid" />
      <scope startLine="1214" endLine="1217" />
      <scope startLine="1220" endLine="1225" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1227" endLine="1257">
      <declaration type="int" name="length" />
      <scope startLine="1231" endLine="1236" />
      <declaration type="int" name="mid" />
      <scope startLine="1245" endLine="1248" />
      <scope startLine="1251" endLine="1256" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1258" endLine="1288">
      <declaration type="int" name="length" />
      <scope startLine="1262" endLine="1267" />
      <declaration type="int" name="mid" />
      <scope startLine="1276" endLine="1279" />
      <scope startLine="1282" endLine="1287" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1289" endLine="1319">
      <declaration type="int" name="length" />
      <scope startLine="1293" endLine="1298" />
      <declaration type="int" name="mid" />
      <scope startLine="1307" endLine="1310" />
      <scope startLine="1313" endLine="1318" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1320" endLine="1350">
      <declaration type="int" name="length" />
      <scope startLine="1324" endLine="1329" />
      <declaration type="int" name="mid" />
      <scope startLine="1338" endLine="1341" />
      <scope startLine="1344" endLine="1349" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort1" startLine="1351" endLine="1381">
      <declaration type="int" name="length" />
      <scope startLine="1355" endLine="1360" />
      <declaration type="int" name="mid" />
      <scope startLine="1369" endLine="1372" />
      <scope startLine="1375" endLine="1380" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves of dest into src</comment>
      <comment>If list is already sorted, just copy from src to dest.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves (now in src) into dest</comment>
    </method>
    <method type="void" name="mergeSort2" startLine="1382" endLine="1424">
      <declaration type="long" name="NEG_ZERO_BITS" />
      <declaration type="int" name="numNegZeros" />
      <declaration type="int" name="i" />
      <scope startLine="1396" endLine="1407">
        <scope startLine="1397" endLine="1400" />
        <scope startLine="1400" endLine="1406">
          <scope startLine="1401" endLine="1404" />
        </scope>
      </scope>
      <declaration type="double[]" name="aux" />
      <scope startLine="1414" endLine="1423">
        <declaration type="int" name="j" />
        <scope startLine="1416" endLine="1418" />
        <comment>posn of ANY zero</comment>
        <comment>j is now one less than the index of the FIRST zero</comment>
      </scope>
      <comment>The sort is done in three phases to avoid the expense of using
 NaN and -0.0 aware comparisons during the main sort.</comment>
      <comment>Preprocessing phase:  Move any NaN's to end of array, count the
 number of -0.0's, and turn them into 0.0's.</comment>
      <comment>Main sort phase: mergesort everything but the NaN's</comment>
      <comment>Postprocessing phase: change 0.0's to -0.0's as required</comment>
    </method>
    <method type="void" name="mergeSort2" startLine="1425" endLine="1467">
      <declaration type="int" name="NEG_ZERO_BITS" />
      <declaration type="int" name="numNegZeros" />
      <declaration type="int" name="i" />
      <scope startLine="1439" endLine="1450">
        <scope startLine="1440" endLine="1443" />
        <scope startLine="1443" endLine="1449">
          <scope startLine="1444" endLine="1447" />
        </scope>
      </scope>
      <declaration type="float[]" name="aux" />
      <scope startLine="1457" endLine="1466">
        <declaration type="int" name="j" />
        <scope startLine="1459" endLine="1461" />
        <comment>posn of ANY zero</comment>
        <comment>j is now one less than the index of the FIRST zero</comment>
      </scope>
      <comment>The sort is done in three phases to avoid the expense of using
 NaN and -0.0 aware comparisons during the main sort.</comment>
      <comment>Preprocessing phase:  Move any NaN's to end of array, count the
 number of -0.0's, and turn them into 0.0's.</comment>
      <comment>Main sort phase: mergesort everything but the NaN's</comment>
      <comment>Postprocessing phase: change 0.0's to -0.0's as required</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements.
 * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="mergeSortInPlace" startLine="1488" endLine="1514">
      <declaration type="int" name="length" />
      <scope startLine="1493" endLine="1500">
        <scope startLine="1494" endLine="1498">
          <scope startLine="1495" endLine="1497">
            <declaration type="int" name="tmp" />
          </scope>
        </scope>
      </scope>
      <declaration type="int" name="mid" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Recursively sort halves</comment>
      <comment>If list is already sorted, nothing left to do.  This is an</comment>
      <comment>optimization that results in faster sorts for nearly ordered lists.</comment>
      <comment>Merge sorted halves</comment>
      <comment>jal.INT.Sorting.inplace_merge(a, fromIndex, mid, toIndex);</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1542" endLine="1545" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1573" endLine="1576" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1604" endLine="1607" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1635" endLine="1638" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1666" endLine="1669" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1697" endLine="1700" />
    <javadoc>
      <text>* Sorts the specified range of the receiver into
 * ascending order, according to the <i>natural ordering</i> of its
 * elements.  All elements in this range must implement the
 * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 * must not throw a <tt>ClassCastException</tt> for any elements
 * <tt>e1</tt> and <tt>e2</tt> in the array).<p>
 * The sorting algorithm is a tuned quicksort, adapted from Jon
 * L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function",
 * Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November
 * 1993).  This algorithm offers n*log(n) performance on many data sets
 * that cause other quicksorts to degrade to quadratic performance.</text>
      <param>a the array to be sorted.</param>
    </javadoc>
    <method type="void" name="quickSort" startLine="1718" endLine="1720" />
    <javadoc>
      <text>* Sorts the specified range of the receiver into
 * ascending order, according to the <i>natural ordering</i> of its
 * elements.  All elements in this range must implement the
 * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 * must not throw a <tt>ClassCastException</tt> for any elements
 * <tt>e1</tt> and <tt>e2</tt> in the array).<p></text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
    </javadoc>
    <method type="void" name="quickSort" startLine="1738" endLine="1741" />
    <javadoc>
      <text>* Sorts the specified range of the specified array according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the receiver.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1769" endLine="1772" />
    <javadoc>
      <text>* Sorts the specified array according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>a the array to be sorted.</param>
      <param>c the comparator to determine the order of the receiver.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1797" endLine="1799" />
    <javadoc>
      <text>* Sorts the specified range of the specified array of elements according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>a the array to be sorted.</param>
      <param>fromIndex the index of the first element (inclusive) to be
 * sorted.</param>
      <param>toIndex the index of the last element (exclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the array.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="quickSort" startLine="1829" endLine="1832" />
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="1836" endLine="1889">
      <scope startLine="1838" endLine="1843" />
      <declaration type="int" name="m" />
      <scope startLine="1847" endLine="1857">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="1850" endLine="1855">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="byte" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="1862" endLine="1877">
        <declaration type="int" name="comparison" />
        <scope startLine="1864" endLine="1868" />
        <scope startLine="1869" endLine="1873" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="1893" endLine="1946">
      <scope startLine="1895" endLine="1900" />
      <declaration type="int" name="m" />
      <scope startLine="1904" endLine="1914">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="1907" endLine="1912">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="char" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="1919" endLine="1934">
        <declaration type="int" name="comparison" />
        <scope startLine="1921" endLine="1925" />
        <scope startLine="1926" endLine="1930" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="1950" endLine="2003">
      <scope startLine="1952" endLine="1957" />
      <declaration type="int" name="m" />
      <scope startLine="1961" endLine="1971">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="1964" endLine="1969">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="double" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="1976" endLine="1991">
        <declaration type="int" name="comparison" />
        <scope startLine="1978" endLine="1982" />
        <scope startLine="1983" endLine="1987" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="2007" endLine="2060">
      <scope startLine="2009" endLine="2014" />
      <declaration type="int" name="m" />
      <scope startLine="2018" endLine="2028">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="2021" endLine="2026">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="float" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="2033" endLine="2048">
        <declaration type="int" name="comparison" />
        <scope startLine="2035" endLine="2039" />
        <scope startLine="2040" endLine="2044" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="2064" endLine="2117">
      <scope startLine="2066" endLine="2071" />
      <declaration type="int" name="m" />
      <scope startLine="2075" endLine="2085">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="2078" endLine="2083">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="int" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="2090" endLine="2105">
        <declaration type="int" name="comparison" />
        <scope startLine="2092" endLine="2096" />
        <scope startLine="2097" endLine="2101" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="2121" endLine="2174">
      <scope startLine="2123" endLine="2128" />
      <declaration type="int" name="m" />
      <scope startLine="2132" endLine="2142">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="2135" endLine="2140">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="long" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="2147" endLine="2162">
        <declaration type="int" name="comparison" />
        <scope startLine="2149" endLine="2153" />
        <scope startLine="2154" endLine="2158" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="2178" endLine="2231">
      <scope startLine="2180" endLine="2185" />
      <declaration type="int" name="m" />
      <scope startLine="2189" endLine="2199">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="2192" endLine="2197">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="Comparable" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="2204" endLine="2219">
        <declaration type="int" name="comparison" />
        <scope startLine="2206" endLine="2210" />
        <scope startLine="2211" endLine="2215" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="2235" endLine="2288">
      <scope startLine="2237" endLine="2242" />
      <declaration type="int" name="m" />
      <scope startLine="2246" endLine="2256">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="2249" endLine="2254">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="Object" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="2261" endLine="2276">
        <declaration type="int" name="comparison" />
        <scope startLine="2263" endLine="2267" />
        <scope startLine="2268" endLine="2272" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified sub-array of chars into ascending order.</text>
    </javadoc>
    <method type="void" name="quickSort1" startLine="2292" endLine="2345">
      <scope startLine="2294" endLine="2299" />
      <declaration type="int" name="m" />
      <scope startLine="2303" endLine="2313">
        <declaration type="int" name="l" />
        <declaration type="int" name="n" />
        <scope startLine="2306" endLine="2311">
          <declaration type="int" name="s" />
        </scope>
        <comment>Big arrays, pseudomedian of 9</comment>
        <comment>Mid-size, med of 3</comment>
      </scope>
      <declaration type="short" name="v" />
      <declaration type="int" name="a" />
      <scope startLine="2318" endLine="2333">
        <declaration type="int" name="comparison" />
        <scope startLine="2320" endLine="2324" />
        <scope startLine="2325" endLine="2329" />
      </scope>
      <declaration type="int" name="s" />
      <comment>Insertion sort on smallest arrays</comment>
      <comment>Choose a partition element, v</comment>
      <comment>Small arrays, middle element</comment>
      <comment>Establish Invariant: v* (<v)* (>v)* v*</comment>
      <comment>Swap partition elements back to middle</comment>
      <comment>Recursively sort non-partition-elements</comment>
    </method>
    <javadoc>
      <text>* Check that fromIndex and toIndex are in range, and throw an
 * appropriate exception if they aren't.</text>
    </javadoc>
    <method type="void" name="rangeCheck" startLine="2350" endLine="2358" />
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2362" endLine="2366">
      <declaration type="byte" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2370" endLine="2374">
      <declaration type="char" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2378" endLine="2382">
      <declaration type="double" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2386" endLine="2390">
      <declaration type="float" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2394" endLine="2398">
      <declaration type="int" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2402" endLine="2406">
      <declaration type="long" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2410" endLine="2414">
      <declaration type="Object" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a] with x[b].</text>
    </javadoc>
    <method type="void" name="swap" startLine="2418" endLine="2422">
      <declaration type="short" name="t" />
    </method>
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2426" endLine="2429" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2433" endLine="2436" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2440" endLine="2443" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2447" endLine="2450" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2454" endLine="2457" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2461" endLine="2464" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2468" endLine="2471" />
    <javadoc>
      <text>* Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].</text>
    </javadoc>
    <method type="void" name="vecswap" startLine="2475" endLine="2478" />
  </class>
</source>
