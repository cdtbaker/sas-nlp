<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.list">
  <import name="cern.colt.bitvector.BitVector" />
  <import name="cern.colt.bitvector.QuickBitVector" />
  <class name="MinMaxNumberList" extends="cern.colt.list.AbstractLongList" startLine="13">
    <javadoc>
      <text>* Resizable compressed list holding numbers; based on the fact that a value in a given interval need not take more than <tt>log(max-min+1)</tt> bits; implemented with a <tt>cern.colt.bitvector.BitVector</tt>.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * Numbers can be compressed when minimum and maximum of all values ever to be stored in the list are known.
 * For example, if min=16, max=27, only 4 bits are needed to store a value.
 * No compression is achieved for <tt>float</tt> and <tt>double</tt> values.
 * <p>
 * You can add, get and set elements quite similar to <tt>java.util.ArrayList</tt>.
 * <p>
 * <b>Applicability:</b> Applicable if the data is non floating point, highly skewed without "outliers" and minimum and maximum known in advance.
 * <p>
 * <b>Performance:</b> Basic operations like <tt>add()</tt>, <tt>get()</tt>, <tt>set()</tt>, <tt>size()</tt> and <tt>clear()</tt> are <tt>O(1)</tt>, i.e. run in constant time.
 * <dt>200Mhz Pentium Pro, JDK 1.2, NT:
 * <dt><tt>10^6</tt> calls to <tt>getQuick()</tt> --> <tt>0.5</tt> seconds.
 * (50 times slower than reading from a primitive array of the appropriate type.)
 * <dt><tt>10^6</tt> calls to <tt>setQuick()</tt> --> <tt>0.8</tt> seconds.
 * (15 times slower than writing to a primitive array of the appropriate type.)
 * <p>
 * This class can, for example, be useful when making large lists of numbers persistent.
 * Also useful when very large lists would otherwise consume too much main memory.
 * <p>
 * Upon instantiation a contract is signed that defines the interval values may fall into.
 * It is not legal to store values not contained in that interval.
 * WARNING: The contract is not checked. Be sure you do not store illegal values.
 * If you need to store <tt>float</tt> or <tt>double</tt> values, you must set the minimum and maximum to <tt>[Integer.MIN_VALUE,Integer.MAX_VALUE]</tt> or <tt>[Long.MIN_VALUE,Long.MAX_VALUE]</tt>, respectively.
 * <p>
 * Although access methods are only defined on <tt>long</tt> values you can also store
 * all other primitive data types: <tt>boolean</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, <tt>float</tt>, <tt>double</tt> and <tt>char</tt>.
 * You can do this by explicitly representing them as <tt>long</tt> values.
 * Use casts for discrete data types.
 * Use the methods of <tt>java.lang.Float</tt> and <tt>java.lang.Double</tt> for floating point data types:
 * Recall that with those methods you can convert any floating point value to a <tt>long</tt> value and back <b>without losing any precision</b>:
 * <p>
 * <b>Example usage:</b><pre>
 * MinMaxNumberList list = ... instantiation goes here
 * double d1 = 1.234;
 * list.add(Double.doubleToLongBits(d1));
 * double d2 = Double.longBitsToDouble(list.get(0));
 * if (d1!=d2) System.out.println("This is impossible!");
 * MinMaxNumberList list2 = ... instantiation goes here
 * float f1 = 1.234f;
 * list2.add((long) Float.floatToIntBits(f1));
 * float f2 = Float.intBitsToFloat((int)list2.get(0));
 * if (f1!=f2) System.out.println("This is impossible!");
 * </pre></text>
      <see>LongArrayList</see>
      <see>DistinctNumberList</see>
      <see>java.lang.Float</see>
      <see>java.lang.Double</see>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
    </javadoc>
    <declaration type="long" name="minValue" />
    <declaration type="int" name="bitsPerElement" />
    <declaration type="long[]" name="bits" />
    <declaration type="int" name="capacity" />
    <javadoc>
      <text>* Constructs an empty list with the specified initial capacity and the specified range of values allowed to be hold in this list.
 * Legal values are in the range [minimum,maximum], all inclusive.</text>
      <param>minimum   the minimum of values allowed to be hold in this list.</param>
      <param>maximum   the maximum of values allowed to be hold in this list.</param>
      <param>initialCapacity   the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory.</param>
    </javadoc>
    <method type="constructor" name="MinMaxNumberList" startLine="80" endLine="82" />
    <javadoc>
      <text>* Appends the specified element to the end of this list.</text>
      <param>element element to be appended to this list.</param>
    </javadoc>
    <method type="void" name="add" startLine="88" endLine="96">
      <scope startLine="90" endLine="92" />
      <declaration type="int" name="i" />
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Appends the elements <tt>elements[from]</tt> (inclusive), ..., <tt>elements[to]</tt> (inclusive) to the receiver.</text>
      <param>elements the elements to be appended to the receiver.</param>
      <param>from the index of the first element to be appended (inclusive)</param>
      <param>to the index of the last element to be appended (inclusive)</param>
    </javadoc>
    <method type="void" name="addAllOfFromTo" startLine="103" endLine="119">
      <declaration type="int" name="bitsPerElem" />
      <declaration type="int" name="bitsPerElemMinusOne" />
      <declaration type="long" name="min" />
      <declaration type="long[]" name="theBits" />
      <declaration type="int" name="firstBit" />
      <declaration type="int" name="i" />
      <scope startLine="114" endLine="117" />
      <comment>cache some vars for speed.</comment>
      <comment>now let's go.</comment>
      <comment>*bitsPerElem;</comment>
    </method>
    <javadoc>
      <text>* Returns the number of bits necessary to store a single element.</text>
    </javadoc>
    <method type="int" name="bitsPerElement" startLine="123" endLine="125" />
    <javadoc>
      <text>* Returns the number of bits necessary to store values in the range <tt>[minimum,maximum]</tt>.</text>
    </javadoc>
    <method type="int" name="bitsPerElement" startLine="129" endLine="142">
      <declaration type="int" name="bits" />
      <scope startLine="131" endLine="133" />
      <scope startLine="134" endLine="140">
        <comment>overflow or underflow in calculating "1+maximum-minimum"</comment>
        <comment>happens if signed long representation is too short for doing unsigned calculations</comment>
        <comment>e.g. if minimum==LONG.MIN_VALUE, maximum==LONG.MAX_VALUE</comment>
        <comment>--> in such cases store all bits of values without any compression.</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.</text>
      <param>minCapacity   the desired minimum capacity.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="149" endLine="159">
      <declaration type="int" name="oldCapacity" />
      <scope startLine="151" endLine="158">
        <declaration type="int" name="newCapacity" />
        <declaration type="BitVector" name="vector" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions. 
 * Provided with invalid parameters this method may return invalid elements without throwing any exception!
 * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
 * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.</text>
      <param>index index of element to return.</param>
    </javadoc>
    <method type="long" name="getQuick" startLine="168" endLine="171">
      <declaration type="int" name="i" />
    </method>
    <javadoc>
      <text>* Copies all elements between index <tt>from</tt> (inclusive) and <tt>to</tt> (inclusive) into <tt>part</tt>, starting at index <tt>partFrom</tt> within <tt>part</tt>.
 * Elements are only copied if a corresponding flag within <tt>qualificants</tt> is set.
 * More precisely:<pre>
 * for (; from<=to; from++, partFrom++, qualificantsFrom++) {
 * if (qualificants==null || qualificants.get(qualificantsFrom)) {
 * part[partFrom] = this.get(from);
 * }
 * }
 * </pre></text>
    </javadoc>
    <method type="void" name="partFromTo" startLine="183" endLine="207">
      <declaration type="int" name="width" />
      <scope startLine="185" endLine="187" />
      <scope startLine="188" endLine="190" />
      <declaration type="long" name="minVal" />
      <declaration type="int" name="bitsPerElem" />
      <declaration type="long[]" name="theBits" />
      <declaration type="int" name="q" />
      <declaration type="int" name="p" />
      <declaration type="int" name="j" />
      <scope startLine="201" endLine="206">
        <scope startLine="202" endLine="205" />
        <comment>part[p] = minVal + tmpBitVector.getLongFromTo(j, j+bitsPerElem-1);</comment>
      </scope>
      <comment>BitVector tmpBitVector = new BitVector(this.bits, this.size*bitsPerElem);</comment>
    </method>
    <javadoc>
      <text>* Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not check preconditions. 
 * Provided with invalid parameters this method may access invalid indexes without throwing any exception!
 * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
 * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.</text>
      <param>index index of element to replace.</param>
      <param>element element to be stored at the specified position.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="217" endLine="220">
      <declaration type="int" name="i" />
    </method>
    <javadoc>
      <text>* Sets the size of the receiver without modifying it otherwise.
 * This method should not release or allocate new memory but simply set some instance variable like <tt>size</tt>.</text>
    </javadoc>
    <method type="void" name="setSizeRaw" startLine="225" endLine="227" />
    <javadoc>
      <text>* Sets the receiver to an empty list with the specified initial capacity and the specified range of values allowed to be hold in this list.
 * Legal values are in the range [minimum,maximum], all inclusive.</text>
      <param>minimum   the minimum of values allowed to be hold in this list.</param>
      <param>maximum   the maximum of values allowed to be hold in this list.</param>
      <param>initialCapacity   the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory.</param>
    </javadoc>
    <method type="void" name="setUp" startLine="235" endLine="242">
      <comment>this.capacity=initialCapacity;</comment>
    </method>
    <javadoc>
      <text>* This method was created in VisualAge.</text>
      <param>minValue long</param>
      <param>maxValue long</param>
      <param>initialCapacity int</param>
    </javadoc>
    <method type="void" name="setUpBitsPerEntry" startLine="249" endLine="261">
      <scope startLine="251" endLine="257">
        <comment>overflow or underflow in calculating "1+maxValue-minValue"</comment>
        <comment>happens if signed long representation is too short for doing unsigned calculations</comment>
        <comment>e.g. if minValue==LONG.MIN_VALUE, maxValue=LONG.MAX_VALUE</comment>
        <comment>--> in such cases store all bits of values without any en/decoding</comment>
      </scope>
      <scope startLine="258" endLine="260" />
    </method>
    <javadoc>
      <text>* Returns the receiver seen as bitvector.
 * WARNING: The bitvector and the receiver share the backing bits. Modifying one of them will affect the other.</text>
    </javadoc>
    <method type="BitVector" name="toBitVector" startLine="266" endLine="268" />
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. An application can use this operation to minimize the 
 * storage of the receiver.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="274" endLine="282">
      <declaration type="int" name="oldCapacity" />
      <scope startLine="276" endLine="281">
        <declaration type="BitVector" name="vector" />
      </scope>
    </method>
    <javadoc>
      <text>* deprecated
 * Returns the minimum element legal to the stored in the receiver.
 * Remark: This does not mean that such a minimum element is currently contained in the receiver.</text>
      <deprecated />
    </javadoc>
    <method type="long" name="xminimum" startLine="289" endLine="291" />
  </class>
</source>
