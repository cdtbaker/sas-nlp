<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.list">
  <import name="cern.colt.function.ObjectProcedure" />
  <class name="ObjectArrayList" extends="AbstractList" startLine="12">
    <javadoc>
      <text>* Resizable list holding <code>Object</code> elements; implemented with arrays.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.</text>
    </javadoc>
    <javadoc>
      <text>* The array buffer into which the elements of the list are stored.
 * The capacity of the list is the length of this array buffer.</text>
      <serial />
    </javadoc>
    <declaration type="Object[]" name="elements" />
    <javadoc>
      <text>* The size of the list.</text>
      <serial />
    </javadoc>
    <declaration type="int" name="size" />
    <javadoc>
      <text>* Constructs an empty list.</text>
    </javadoc>
    <method type="constructor" name="ObjectArrayList" startLine="32" endLine="34" />
    <javadoc>
      <text>* Constructs a list containing the specified elements. 
 * The initial size and capacity of the list is the length of the array.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.</text>
      <param>elements the array to be backed by the the constructed list</param>
    </javadoc>
    <method type="constructor" name="ObjectArrayList" startLine="44" endLine="46" />
    <javadoc>
      <text>* Constructs an empty list with the specified initial capacity.</text>
      <param>initialCapacity   the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory.</param>
    </javadoc>
    <method type="constructor" name="ObjectArrayList" startLine="52" endLine="55" />
    <javadoc>
      <text>* Appends the specified element to the end of this list.</text>
      <param>element element to be appended to this list.</param>
    </javadoc>
    <method type="void" name="add" startLine="61" endLine="64" />
    <javadoc>
      <text>* Appends the part of the specified list between <code>from</code> (inclusive) and <code>to</code> (inclusive) to the receiver.</text>
      <param>other the list to be added to the receiver.</param>
      <param>from the index of the first element to be appended (inclusive).</param>
      <param>to the index of the last element to be appended (inclusive).</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())</tt>).</exception>
    </javadoc>
    <method type="void" name="addAllOfFromTo" startLine="73" endLine="75" />
    <javadoc>
      <text>* Inserts the specified element before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.</text>
      <param>index index before which the specified element is to be inserted (must be in [0,size]).</param>
      <param>element element to be inserted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).</exception>
    </javadoc>
    <method type="void" name="beforeInsert" startLine="85" endLine="93">
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Inserts the part of the specified list between <code>otherFrom</code> (inclusive) and <code>otherTo</code> (inclusive) before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.</text>
      <param>index index before which to insert first element from the specified list (must be in [0,size])..</param>
      <param>other list of which a part is to be inserted into the receiver.</param>
      <param>from the index of the first element to be inserted (inclusive).</param>
      <param>to the index of the last element to be inserted (inclusive).</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())</tt>).</exception>
      <exception>IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).</exception>
    </javadoc>
    <method type="void" name="beforeInsertAllOfFromTo" startLine="106" endLine="110">
      <declaration type="int" name="length" />
    </method>
    <javadoc>
      <text>* Inserts length dummies before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.</text>
      <param>index index before which to insert dummies (must be in [0,size])..</param>
      <param>length number of dummies to be inserted.</param>
    </javadoc>
    <method type="void" name="beforeInsertDummies" startLine="119" endLine="127">
      <scope startLine="122" endLine="126" />
    </method>
    <javadoc>
      <text>* Searches the receiver for the specified value using
 * the binary search algorithm. The receiver must be sorted into ascending order
 * according to the <i>natural ordering</i> of its elements (as by the sort method)
 * prior to making this call.  
 * If it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the receiver contains multiple elements
 * equal to the specified object, there is no guarantee which instance
 * will be found.</text>
      <param>key the value to be searched for.</param>
      <return>index of the search key, if it is contained in the receiver;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the receiver: the index of the first
 * element greater than the key, or <tt>receiver.size()</tt>, if all
 * elements in the receiver are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>Comparable</see>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearch" startLine="150" endLine="152" />
    <javadoc>
      <text>* Searches the receiver for the specified value using
 * the binary search algorithm. The receiver must be sorted into ascending order
 * according to the <i>natural ordering</i> of its elements (as by the sort method)
 * prior to making this call.  
 * If it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the receiver contains multiple elements
 * equal to the specified object, there is no guarantee which instance
 * will be found.</text>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the receiver;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the receiver: the index of the first
 * element greater than the key, or <tt>receiver.size()</tt>, if all
 * elements in the receiver are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>Comparable</see>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="178" endLine="192">
      <declaration type="int" name="low" />
      <declaration type="int" name="high" />
      <scope startLine="182" endLine="190">
        <declaration type="int" name="mid" />
        <declaration type="Object" name="midVal" />
        <declaration type="int" name="cmp" />
        <comment>key found</comment>
      </scope>
      <comment>key not found.</comment>
    </method>
    <javadoc>
      <text>* Searches the receiver for the specified value using
 * the binary search algorithm. The receiver must be sorted into ascending order
 * according to the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * If the receiver is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the receiver contains multiple elements
 * equal to the specified object, there is no guarantee which instance
 * will be found.</text>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <param>comparator the comparator by which the receiver is sorted.</param>
      <throws>ClassCastException if the receiver contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <return>index of the search key, if it is contained in the receiver;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the receiver: the index of the first
 * element greater than the key, or <tt>receiver.size()</tt>, if all
 * elements in the receiver are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>cern.colt.Sorting</see>
      <see>java.util.Arrays</see>
      <see>java.util.Comparator</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="226" endLine="228" />
    <javadoc>
      <text>* Returns a copy of the receiver such that the copy and the receiver <i>share</i> the same elements, but do not share the same array to index them;
 * So modifying an object in the copy modifies the object in the receiver and vice versa;
 * However, structurally modifying the copy (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice versa.</text>
      <return>a copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="236" endLine="240">
      <declaration type="ObjectArrayList" name="v" />
    </method>
    <javadoc>
      <text>* Returns true if the receiver contains the specified element.
 * Tests for equality or identity as specified by testForEquality.</text>
      <param>element element to search for.</param>
      <param>testForEquality if true -> test for equality, otherwise for identity.</param>
    </javadoc>
    <method type="boolean" name="contains" startLine="248" endLine="250" />
    <javadoc>
      <text>* Returns a copy of the receiver; call <code>clone()</code> and casts the result.
 * Returns a copy such that the copy and the receiver <i>share</i> the same elements, but do not share the same array to index them;
 * So modifying an object in the copy modifies the object in the receiver and vice versa;
 * However, structurally modifying the copy (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice versa.</text>
      <return>a copy of the receiver.</return>
    </javadoc>
    <method type="ObjectArrayList" name="copy" startLine="259" endLine="261" />
    <javadoc>
      <text>* Deletes the first element from the receiver that matches the specified element.
 * Does nothing, if no such matching element is contained.
 * Tests elements for equality or identity as specified by <tt>testForEquality</tt>.
 * When testing for equality, two elements <tt>e1</tt> and
 * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
 * e1.equals(e2))</tt>.)</text>
      <param>testForEquality if true -> tests for equality, otherwise for identity.</param>
      <param>element the element to be deleted.</param>
    </javadoc>
    <method type="void" name="delete" startLine="274" endLine="277">
      <declaration type="int" name="index" />
    </method>
    <javadoc>
      <text>* Returns the elements currently stored, including invalid elements between size and capacity, if any.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.</text>
      <return>the elements currently stored.</return>
    </javadoc>
    <method type="Object[]" name="elements" startLine="286" endLine="288" />
    <javadoc>
      <text>* Sets the receiver's elements to be the specified array (not a copy of it).
 * The size and capacity of the list is the length of the array.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.</text>
      <param>elements the new elements to be stored.</param>
      <return>the receiver itself.</return>
    </javadoc>
    <method type="ObjectArrayList" name="elements" startLine="299" endLine="303" />
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.</text>
      <param>minCapacity   the desired minimum capacity.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="310" endLine="312" />
    <javadoc>
      <text>* Compares the specified Object with the receiver for equality.
 * Returns true if and only if the specified Object is also an ObjectArrayList, both lists have the
 * same size, and all corresponding pairs of elements in the two lists are equal.
 * In other words, two lists are defined to be equal if they contain the
 * same elements in the same order.
 * Two elements <tt>e1</tt> and
 * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
 * e1.equals(e2))</tt>.)</text>
      <param>otherObj the Object to be compared for equality with the receiver.</param>
      <return>true if the specified Object is equal to the receiver.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="326" endLine="328">
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Compares the specified Object with the receiver for equality.
 * Returns true if and only if the specified Object is also an ObjectArrayList, both lists have the
 * same size, and all corresponding pairs of elements in the two lists are the same.
 * In other words, two lists are defined to be equal if they contain the
 * same elements in the same order.
 * Tests elements for equality or identity as specified by <tt>testForEquality</tt>.
 * When testing for equality, two elements <tt>e1</tt> and
 * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :
 * e1.equals(e2))</tt>.)</text>
      <param>otherObj the Object to be compared for equality with the receiver.</param>
      <param>testForEquality if true -> tests for equality, otherwise for identity.</param>
      <return>true if the specified Object is equal to the receiver.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="344" endLine="367">
      <scope startLine="345" endLine="345" />
      <declaration type="ObjectArrayList" name="other" />
      <declaration type="Object[]" name="otherElements" />
      <declaration type="Object[]" name="theElements" />
      <scope startLine="354" endLine="358">
        <scope startLine="355" endLine="357" />
      </scope>
      <scope startLine="359" endLine="363">
        <scope startLine="360" endLine="362" />
      </scope>
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Sets the specified range of elements in the specified array to the specified value.</text>
      <param>from the index of the first element (inclusive) to be filled with the specified value.</param>
      <param>to the index of the last element (inclusive) to be filled with the specified value.</param>
      <param>val the value to be stored in the specified elements of the receiver.</param>
    </javadoc>
    <method type="void" name="fillFromToWith" startLine="375" endLine="378" />
    <javadoc>
      <text>* Applies a procedure to each element of the receiver, if any.
 * Starts at index 0, moving rightwards.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEach" startLine="385" endLine="391">
      <declaration type="Object[]" name="theElements" />
      <declaration type="int" name="theSize" />
    </method>
    <javadoc>
      <text>* Returns the element at the specified position in the receiver.</text>
      <param>index index of element to return.</param>
      <exception>IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).</exception>
    </javadoc>
    <method type="Object" name="get" startLine="398" endLine="402" />
    <javadoc>
      <text>* Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions. 
 * Provided with invalid parameters this method may return invalid elements without throwing any exception!
 * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
 * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.</text>
      <param>index index of element to return.</param>
    </javadoc>
    <method type="Object" name="getQuick" startLine="411" endLine="413" />
    <javadoc>
      <text>* Returns the index of the first occurrence of the specified
 * element. Returns <code>-1</code> if the receiver does not contain this element.
 * Tests for equality or identity as specified by testForEquality.</text>
      <param>testForEquality if <code>true</code> -> test for equality, otherwise for identity.</param>
      <return>the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.</return>
    </javadoc>
    <method type="int" name="indexOf" startLine="423" endLine="425" />
    <javadoc>
      <text>* Returns the index of the first occurrence of the specified
 * element. Returns <code>-1</code> if the receiver does not contain this element.
 * Searches between <code>from</code>, inclusive and <code>to</code>, inclusive.
 * Tests for equality or identity as specified by <code>testForEquality</code>.</text>
      <param>element element to search for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <param>testForEquality if </code>true</code> -> test for equality, otherwise for identity.</param>
      <return>the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="int" name="indexOfFromTo" startLine="440" endLine="457">
      <declaration type="Object[]" name="theElements" />
      <scope startLine="445" endLine="450">
        <scope startLine="446" endLine="448">
          <scope startLine="447" endLine="447" />
        </scope>
        <comment>found</comment>
      </scope>
      <scope startLine="451" endLine="455">
        <scope startLine="452" endLine="454">
          <scope startLine="453" endLine="453" />
        </scope>
        <comment>found</comment>
      </scope>
      <comment>not found</comment>
    </method>
    <javadoc>
      <text>* Determines whether the receiver is sorted ascending, according to the <i>natural ordering</i> of its
 * elements.  All elements in this range must implement the
 * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 * must not throw a <tt>ClassCastException</tt> for any elements
 * <tt>e1</tt> and <tt>e2</tt> in the array).<p></text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <return><tt>true</tt> if the receiver is sorted ascending, <tt>false</tt> otherwise.</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="boolean" name="isSortedFromTo" startLine="471" endLine="480">
      <declaration type="Object[]" name="theElements" />
      <scope startLine="476" endLine="478" />
    </method>
    <javadoc>
      <text>* Returns the index of the last occurrence of the specified
 * element. Returns <code>-1</code> if the receiver does not contain this element.
 * Tests for equality or identity as specified by <code>testForEquality</code>.</text>
      <param>element   the element to be searched for.</param>
      <param>testForEquality if <code>true</code> -> test for equality, otherwise for identity.</param>
      <return>the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.</return>
    </javadoc>
    <method type="int" name="lastIndexOf" startLine="490" endLine="492" />
    <javadoc>
      <text>* Returns the index of the last occurrence of the specified
 * element. Returns <code>-1</code> if the receiver does not contain this element.
 * Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive.
 * Tests for equality or identity as specified by <code>testForEquality</code>.</text>
      <param>element element to search for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <param>testForEquality if <code>true</code> -> test for equality, otherwise for identity.</param>
      <return>the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="int" name="lastIndexOfFromTo" startLine="506" endLine="523">
      <declaration type="Object[]" name="theElements" />
      <scope startLine="511" endLine="516">
        <scope startLine="512" endLine="514">
          <scope startLine="513" endLine="513" />
        </scope>
        <comment>found</comment>
      </scope>
      <scope startLine="517" endLine="521">
        <scope startLine="518" endLine="520">
          <scope startLine="519" endLine="519" />
        </scope>
        <comment>found</comment>
      </scope>
      <comment>not found</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified range of the receiver into
 * ascending order, according to the <i>natural ordering</i> of its
 * elements.  All elements in this range must implement the
 * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 * must not throw a <tt>ClassCastException</tt> for any elements
 * <tt>e1</tt> and <tt>e2</tt> in the array).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.
 * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
 * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="mergeSortFromTo" startLine="549" endLine="553" />
    <javadoc>
      <text>* Sorts the receiver according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.</text>
      <param>from the index of the first element (inclusive) to be
 * sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the receiver.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
      <see>Comparator</see>
    </javadoc>
    <method type="void" name="mergeSortFromTo" startLine="583" endLine="587" />
    <javadoc>
      <text>* Returns a new list of the part of the receiver between <code>from</code>, inclusive, and <code>to</code>, inclusive.</text>
      <param>from the index of the first element (inclusive).</param>
      <param>to the index of the last element (inclusive).</param>
      <return>a new list</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="ObjectArrayList" name="partFromTo" startLine="595" endLine="603">
      <declaration type="Object[]" name="part" />
    </method>
    <javadoc>
      <text>* Sorts the specified range of the receiver into
 * ascending order, according to the <i>natural ordering</i> of its
 * elements.  All elements in this range must implement the
 * <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 * must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 * must not throw a <tt>ClassCastException</tt> for any elements
 * <tt>e1</tt> and <tt>e2</tt> in the array).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.
 * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
 * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="quickSortFromTo" startLine="627" endLine="631" />
    <javadoc>
      <text>* Sorts the receiver according
 * to the order induced by the specified comparator.  All elements in the
 * range must be <i>mutually comparable</i> by the specified comparator
 * (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 * <tt>e2</tt> in the range).<p>
 * The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <param>c the comparator to determine the order of the receiver.</param>
      <throws>ClassCastException if the array contains elements that are not
 * <i>mutually comparable</i> using the specified comparator.</throws>
      <throws>IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt></throws>
      <throws>ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
 * <tt>toIndex &gt; a.length</tt></throws>
      <see>Comparator</see>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="quickSortFromTo" startLine="658" endLine="662" />
    <javadoc>
      <text>* Removes from the receiver all elements that are contained in the specified list.
 * Tests for equality or identity as specified by <code>testForEquality</code>.</text>
      <param>other the other list.</param>
      <param>testForEquality if <code>true</code> -> test for equality, otherwise for identity.</param>
      <return><code>true</code> if the receiver changed as a result of the call.</return>
    </javadoc>
    <method type="boolean" name="removeAll" startLine="671" endLine="683">
      <declaration type="int" name="limit" />
      <declaration type="int" name="j" />
      <declaration type="Object[]" name="theElements" />
      <scope startLine="676" endLine="678" />
      <declaration type="boolean" name="modified" />
      <comment>nothing to do</comment>
    </method>
    <javadoc>
      <text>* Removes from the receiver all elements whose index is between
 * <code>from</code>, inclusive and <code>to</code>, inclusive.  Shifts any succeeding
 * elements to the left (reduces their index).
 * This call shortens the list by <tt>(to - from + 1)</tt> elements.</text>
      <param>from index of first element to be removed.</param>
      <param>to index of last element to be removed.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="removeFromTo" startLine="694" endLine="703">
      <declaration type="int" name="numMoved" />
      <scope startLine="697" endLine="700">
        <comment>delta</comment>
      </scope>
      <declaration type="int" name="width" />
    </method>
    <javadoc>
      <text>* Replaces a number of elements in the receiver with the same number of elements of another list.
 * Replaces elements in the receiver, between <code>from</code> (inclusive) and <code>to</code> (inclusive),
 * with elements of <code>other</code>, starting from <code>otherFrom</code> (inclusive).</text>
      <param>from the position of the first element to be replaced in the receiver</param>
      <param>to the position of the last element to be replaced in the receiver</param>
      <param>other list holding elements to be copied into the receiver.</param>
      <param>otherFrom position of first element within other list to be copied.</param>
    </javadoc>
    <method type="void" name="replaceFromToWithFrom" startLine="714" endLine="721">
      <declaration type="int" name="length" />
      <scope startLine="716" endLine="720" />
    </method>
    <javadoc>
      <text>* Replaces the part between <code>from</code> (inclusive) and <code>to</code> (inclusive) with the other list's
 * part between <code>otherFrom</code> and <code>otherTo</code>. 
 * Powerful (and tricky) method!
 * Both parts need not be of the same size (part A can both be smaller or larger than part B).
 * Parts may overlap.
 * Receiver and other list may (but most not) be identical.
 * If <code>from &gt; to</code>, then inserts other part before <code>from</code>.</text>
      <param>from the first element of the receiver (inclusive)</param>
      <param>to the last element of the receiver (inclusive)</param>
      <param>other the other list (may be identical with receiver)</param>
      <param>otherFrom the first element of the other list (inclusive)</param>
      <param>otherTo the last element of the other list (inclusive)
 * <p><b>Examples:</b><pre>
 * a=[0, 1, 2, 3, 4, 5, 6, 7]
 * b=[50, 60, 70, 80, 90]
 * a.R(...)=a.replaceFromToWithFromTo(...)
 * a.R(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
 * a.R(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7]
 * a.R(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7]
 * a.R(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7]
 * a.R(1,6,b,1,2)-->[0, 60, 70, 7]
 * a.R(0,6,b,1,2)-->[60, 70, 7]
 * a.R(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
 * a.R(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
 * a.R(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
 * a.R(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
 * Extreme cases:
 * a.R(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7]
 * a.R(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7]
 * a.R(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7]
 * a.R(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7]
 * a.R(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
 * a.R(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
 * </pre></param>
    </javadoc>
    <method type="void" name="replaceFromToWithFromTo" startLine="765" endLine="799">
      <scope startLine="766" endLine="768" />
      <scope startLine="769" endLine="772">
        <comment>avoid stumbling over my own feet</comment>
      </scope>
      <declaration type="int" name="length" />
      <declaration type="int" name="diff" />
      <declaration type="int" name="theLast" />
      <scope startLine="782" endLine="785" />
      <scope startLine="787" endLine="789" />
      <scope startLine="790" endLine="794">
        <scope startLine="791" endLine="793" />
      </scope>
      <scope startLine="796" endLine="798" />
      <comment>System.out.println("from="+from);</comment>
      <comment>System.out.println("to="+to);</comment>
      <comment>System.out.println("diff="+diff);</comment>
    </method>
    <javadoc>
      <text>* Replaces the part of the receiver starting at <code>from</code> (inclusive) with all the elements of the specified collection.
 * Does not alter the size of the receiver.
 * Replaces exactly <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.</text>
      <param>from the index at which to copy the first element from the specified collection.</param>
      <param>other Collection to replace part of the receiver</param>
      <exception>IndexOutOfBoundsException index is out of range (index &lt; 0 || index &gt;= size()).</exception>
    </javadoc>
    <method type="void" name="replaceFromWith" startLine="809" endLine="816">
      <declaration type="java.util.Iterator" name="e" />
      <declaration type="int" name="index" />
      <declaration type="int" name="limit" />
      <comment>delta</comment>
    </method>
    <javadoc>
      <text>* Retains (keeps) only the elements in the receiver that are contained in the specified other list.
 * In other words, removes from the receiver all of its elements that are not contained in the
 * specified other list. 
 * Tests for equality or identity as specified by <code>testForEquality</code>.</text>
      <param>other the other list to test against.</param>
      <param>testForEquality if <code>true</code> -> test for equality, otherwise for identity.</param>
      <return><code>true</code> if the receiver changed as a result of the call.</return>
    </javadoc>
    <method type="boolean" name="retainAll" startLine="826" endLine="844">
      <scope startLine="827" endLine="831" />
      <declaration type="int" name="limit" />
      <declaration type="int" name="j" />
      <declaration type="Object[]" name="theElements" />
      <scope startLine="837" endLine="839" />
      <declaration type="boolean" name="modified" />
    </method>
    <javadoc>
      <text>* Reverses the elements of the receiver.
 * Last becomes first, second last becomes second first, and so on.</text>
    </javadoc>
    <method type="void" name="reverse" startLine="849" endLine="860">
      <declaration type="Object" name="tmp" />
      <declaration type="int" name="limit" />
      <declaration type="int" name="j" />
      <declaration type="Object[]" name="theElements" />
      <scope startLine="855" endLine="859">
        <comment>swap</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Replaces the element at the specified position in the receiver with the specified element.</text>
      <param>index index of element to replace.</param>
      <param>element element to be stored at the specified position.</param>
      <exception>IndexOutOfBoundsException index is out of range (index
 * &lt; 0 || index &gt;= size()).</exception>
    </javadoc>
    <method type="void" name="set" startLine="869" endLine="873" />
    <javadoc>
      <text>* Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not check preconditions.
 * Provided with invalid parameters this method may access invalid indexes without throwing any exception!
 * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
 * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.</text>
      <param>index index of element to replace.</param>
      <param>element element to be stored at the specified position.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="883" endLine="885" />
    <javadoc>
      <text>* Randomly permutes the part of the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive).</text>
      <param>from the index of the first element (inclusive) to be permuted.</param>
      <param>to the index of the last element (inclusive) to be permuted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="shuffleFromTo" startLine="892" endLine="908">
      <declaration type="cern.jet.random.Uniform" name="gen" />
      <declaration type="Object" name="tmpElement" />
      <declaration type="Object[]" name="theElements" />
      <declaration type="int" name="random" />
      <scope startLine="900" endLine="907">
        <comment>swap(i, random)</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the number of elements contained in the receiver.</text>
      <returns>the number of elements contained in the receiver.</returns>
    </javadoc>
    <method type="int" name="size" startLine="914" endLine="916" />
    <javadoc>
      <text>* Returns a list which is a concatenation of <code>times</code> times the receiver.</text>
      <param>times the number of times the receiver shall be copied.</param>
    </javadoc>
    <method type="ObjectArrayList" name="times" startLine="921" endLine="927">
      <declaration type="ObjectArrayList" name="newList" />
      <scope startLine="923" endLine="925" />
    </method>
    <javadoc>
      <text>* Returns an array containing all of the elements in the receiver in the
 * correct order.  The runtime type of the returned array is that of the
 * specified array.  If the receiver fits in the specified array, it is
 * returned therein.  Otherwise, a new array is allocated with the runtime
 * type of the specified array and the size of the receiver.
 * <p>
 * If the receiver fits in the specified array with room to spare
 * (i.e., the array has more elements than the receiver),
 * the element in the array immediately following the end of the
 * receiver is set to null.  This is useful in determining the length
 * of the receiver <em>only</em> if the caller knows that the receiver
 * does not contain any null elements.</text>
      <param>array the array into which the elements of the receiver are to
 * be stored, if it is big enough; otherwise, a new array of the
 * same runtime type is allocated for this purpose.</param>
      <return>an array containing the elements of the receiver.</return>
      <exception>ArrayStoreException the runtime type of <tt>array</tt> is not a supertype
 * of the runtime type of every element in the receiver.</exception>
    </javadoc>
    <method type="Object[]" name="toArray" startLine="949" endLine="959">
      <declaration type="Object[]" name="theElements" />
    </method>
    <javadoc>
      <text>* Returns a <code>java.util.ArrayList</code> containing all the elements in the receiver.</text>
    </javadoc>
    <method type="java.util.ArrayList" name="toList" startLine="963" endLine="969">
      <declaration type="int" name="mySize" />
      <declaration type="Object[]" name="theElements" />
      <declaration type="java.util.ArrayList" name="list" />
    </method>
    <javadoc>
      <text>* Returns a string representation of the receiver, containing
 * the String representation of each element.</text>
    </javadoc>
    <method type="String" name="toString" startLine="974" endLine="976" />
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. Releases any superfluos internal memory. An application can use this operation to minimize the 
 * storage of the receiver.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="982" endLine="984" />
  </class>
</source>
