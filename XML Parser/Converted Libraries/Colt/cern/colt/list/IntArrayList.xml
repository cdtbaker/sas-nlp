<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.list">
  <import name="cern.colt.function.IntProcedure" />
  <class name="IntArrayList" extends="AbstractIntList" startLine="12">
    <javadoc>
      <text>* Resizable list holding <code>int</code> elements; implemented with arrays.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.</text>
    </javadoc>
    <javadoc>
      <text>* The array buffer into which the elements of the list are stored.
 * The capacity of the list is the length of this array buffer.</text>
      <serial />
    </javadoc>
    <declaration type="int[]" name="elements" />
    <javadoc>
      <text>* Constructs an empty list.</text>
    </javadoc>
    <method type="constructor" name="IntArrayList" startLine="26" endLine="28" />
    <javadoc>
      <text>* Constructs a list containing the specified elements. 
 * The initial size and capacity of the list is the length of the array.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.</text>
      <param>elements the array to be backed by the the constructed list</param>
    </javadoc>
    <method type="constructor" name="IntArrayList" startLine="38" endLine="40" />
    <javadoc>
      <text>* Constructs an empty list with the specified initial capacity.</text>
      <param>initialCapacity   the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory.</param>
    </javadoc>
    <method type="constructor" name="IntArrayList" startLine="46" endLine="49" />
    <javadoc>
      <text>* Appends the specified element to the end of this list.</text>
      <param>element element to be appended to this list.</param>
    </javadoc>
    <method type="void" name="add" startLine="55" endLine="61">
      <scope startLine="57" endLine="59" />
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Inserts the specified element before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.</text>
      <param>index index before which the specified element is to be inserted (must be in [0,size]).</param>
      <param>element element to be inserted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).</exception>
    </javadoc>
    <method type="void" name="beforeInsert" startLine="71" endLine="83">
      <scope startLine="73" endLine="76" />
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Searches the receiver for the specified value using
 * the binary search algorithm.  The receiver must <strong>must</strong> be
 * sorted (as by the sort method) prior to making this call.  If
 * it is not sorted, the results are undefined: in particular, the call
 * may enter an infinite loop.  If the receiver contains multiple elements
 * equal to the specified object, there is no guarantee which instance
 * will be found.</text>
      <param>key the value to be searched for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>index of the search key, if it is contained in the receiver;
 * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
 * point</i> is defined as the the point at which the value would
 * be inserted into the receiver: the index of the first
 * element greater than the key, or <tt>receiver.size()</tt>, if all
 * elements in the receiver are less than the specified key.  Note
 * that this guarantees that the return value will be &gt;= 0 if
 * and only if the key is found.</return>
      <see>cern.colt.Sorting</see>
      <see>java.util.Arrays</see>
    </javadoc>
    <method type="int" name="binarySearchFromTo" startLine="107" endLine="109" />
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="115" endLine="120">
      <declaration type="IntArrayList[]" name="clone" />
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver; uses <code>clone()</code> and casts the result.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="IntArrayList" name="copy" startLine="126" endLine="128" />
    <javadoc>
      <text>* Sorts the specified range of the receiver into ascending numerical order. 
 * The sorting algorithm is a count sort. This algorithm offers guaranteed
 * <dt>Performance: O(Max(n,max-min+1)).
 * <dt>Space requirements: int[max-min+1] buffer.
 * <p>This algorithm is only applicable if max-min+1 is not large!
 * But if applicable, it usually outperforms quicksort by a factor of 3-4.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <param>min the smallest element contained in the range.</param>
      <param>max the largest element contained in the range.</param>
    </javadoc>
    <method type="void" name="countSortFromTo" startLine="143" endLine="166">
      <declaration type="int" name="width" />
      <declaration type="int[]" name="counts" />
      <declaration type="int[]" name="theElements" />
      <declaration type="int" name="fromIndex" />
      <declaration type="int" name="val" />
      <scope startLine="155" endLine="165">
        <declaration type="int" name="c" />
        <scope startLine="157" endLine="164">
          <scope startLine="159" endLine="163">
            <declaration type="int" name="toIndex" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Returns the elements currently stored, including invalid elements between size and capacity, if any.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing.</text>
      <return>the elements currently stored.</return>
    </javadoc>
    <method type="int[]" name="elements" startLine="175" endLine="177" />
    <javadoc>
      <text>* Sets the receiver's elements to be the specified array (not a copy of it).
 * The size and capacity of the list is the length of the array.
 * <b>WARNING:</b> For efficiency reasons and to keep memory usage low, <b>the array is not copied</b>.
 * So if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing.</text>
      <param>elements the new elements to be stored.</param>
      <return>the receiver itself.</return>
    </javadoc>
    <method type="AbstractIntList" name="elements" startLine="188" endLine="192" />
    <javadoc>
      <text>* Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
 * If necessary, allocates new internal memory and increases the capacity of the receiver.</text>
      <param>minCapacity   the desired minimum capacity.</param>
    </javadoc>
    <method type="void" name="ensureCapacity" startLine="199" endLine="201" />
    <javadoc>
      <text>* Compares the specified Object with the receiver.  
 * Returns true if and only if the specified Object is also an ArrayList of the same type, both Lists have the
 * same size, and all corresponding pairs of elements in the two Lists are identical.
 * In other words, two Lists are defined to be equal if they contain the
 * same elements in the same order.</text>
      <param>otherObj the Object to be compared for equality with the receiver.</param>
      <return>true if the specified Object is equal to the receiver.</return>
    </javadoc>
    <method type="boolean" name="equals" startLine="212" endLine="226">
      <declaration type="IntArrayList" name="other" />
      <declaration type="int[]" name="theElements" />
      <declaration type="int[]" name="otherElements" />
      <scope startLine="222" endLine="224" />
      <comment>delta</comment>
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Applies a procedure to each element of the receiver, if any.
 * Starts at index 0, moving rightwards.</text>
      <param>procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.</param>
      <return><tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.</return>
    </javadoc>
    <method type="boolean" name="forEach" startLine="233" endLine="240">
      <declaration type="int[]" name="theElements" />
      <declaration type="int" name="theSize" />
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Returns the element at the specified position in the receiver.</text>
      <param>index index of element to return.</param>
      <exception>IndexOutOfBoundsException index is out of range (index
 * &lt; 0 || index &gt;= size()).</exception>
    </javadoc>
    <method type="int" name="get" startLine="248" endLine="253">
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Returns the element at the specified position in the receiver; <b>WARNING:</b> Does not check preconditions. 
 * Provided with invalid parameters this method may return invalid elements without throwing any exception!
 * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
 * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.</text>
      <param>index index of element to return.</param>
    </javadoc>
    <method type="int" name="getQuick" startLine="262" endLine="264" />
    <javadoc>
      <text>* Returns the index of the first occurrence of the specified
 * element. Returns <code>-1</code> if the receiver does not contain this element.
 * Searches between <code>from</code>, inclusive and <code>to</code>, inclusive.
 * Tests for identity.</text>
      <param>element element to search for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="int" name="indexOfFromTo" startLine="277" endLine="287">
      <declaration type="int[]" name="theElements" />
      <scope startLine="283" endLine="285">
        <scope startLine="284" endLine="284" />
        <comment>found</comment>
      </scope>
      <comment>overridden for performance only.</comment>
      <comment>not found</comment>
    </method>
    <javadoc>
      <text>* Returns the index of the last occurrence of the specified
 * element. Returns <code>-1</code> if the receiver does not contain this element.
 * Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive.
 * Tests for identity.</text>
      <param>element element to search for.</param>
      <param>from the leftmost search position, inclusive.</param>
      <param>to the rightmost search position, inclusive.</param>
      <return>the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="int" name="lastIndexOfFromTo" startLine="300" endLine="310">
      <declaration type="int[]" name="theElements" />
      <scope startLine="306" endLine="308">
        <scope startLine="307" endLine="307" />
        <comment>found</comment>
      </scope>
      <comment>overridden for performance only.</comment>
      <comment>not found</comment>
    </method>
    <javadoc>
      <text>* Returns a new list of the part of the receiver between <code>from</code>, inclusive, and <code>to</code>, inclusive.</text>
      <param>from the index of the first element (inclusive).</param>
      <param>to the index of the last element (inclusive).</param>
      <return>a new list</return>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="AbstractIntList" name="partFromTo" startLine="318" endLine="326">
      <declaration type="int[]" name="part" />
    </method>
    <javadoc>
      <text>* Removes from the receiver all elements that are contained in the specified list.
 * Tests for identity.</text>
      <param>other the other list.</param>
      <return><code>true</code> if the receiver changed as a result of the call.</return>
    </javadoc>
    <method type="boolean" name="removeAll" startLine="334" endLine="375">
      <scope startLine="348" endLine="348">
        <comment>nothing to do</comment>
      </scope>
      <declaration type="int" name="limit" />
      <declaration type="int" name="j" />
      <declaration type="int[]" name="theElements" />
      <declaration type="int" name="mySize" />
      <declaration type="double" name="N" />
      <declaration type="double" name="M" />
      <scope startLine="356" endLine="364">
        <declaration type="IntArrayList" name="sortedList" />
        <scope startLine="361" endLine="363" />
        <comment>it is faster to sort other before searching in it</comment>
      </scope>
      <scope startLine="365" endLine="370">
        <scope startLine="367" endLine="369" />
        <comment>it is faster to search in other without sorting</comment>
      </scope>
      <declaration type="boolean" name="modified" />
      <comment>overridden for performance only.</comment>
      <comment>There are two possibilities to do the thing
a) use other.indexOf(...)
b) sort other, then use other.binarySearch(...)

Let's try to figure out which one is faster. Let M=size, N=other.size, then
a) takes O(MN) steps
b) takes O(NlogN + MlogN) steps (sorting is O(NlogN) and binarySearch is O(logN))

Hence, if NlogN + MlogN < MN, we use b) otherwise we use a).</comment>
    </method>
    <javadoc>
      <text>* Replaces a number of elements in the receiver with the same number of elements of another list.
 * Replaces elements in the receiver, between <code>from</code> (inclusive) and <code>to</code> (inclusive),
 * with elements of <code>other</code>, starting from <code>otherFrom</code> (inclusive).</text>
      <param>from the position of the first element to be replaced in the receiver</param>
      <param>to the position of the last element to be replaced in the receiver</param>
      <param>other list holding elements to be copied into the receiver.</param>
      <param>otherFrom position of first element within other list to be copied.</param>
    </javadoc>
    <method type="void" name="replaceFromToWithFrom" startLine="386" endLine="399">
      <scope startLine="388" endLine="392">
        <comment>slower</comment>
      </scope>
      <declaration type="int" name="length" />
      <scope startLine="394" endLine="398" />
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Retains (keeps) only the elements in the receiver that are contained in the specified other list.
 * In other words, removes from the receiver all of its elements that are not contained in the
 * specified other list.</text>
      <param>other the other list to test against.</param>
      <return><code>true</code> if the receiver changed as a result of the call.</return>
    </javadoc>
    <method type="boolean" name="retainAll" startLine="407" endLine="447">
      <declaration type="int" name="limit" />
      <declaration type="int" name="j" />
      <declaration type="int[]" name="theElements" />
      <declaration type="int" name="mySize" />
      <declaration type="double" name="N" />
      <declaration type="double" name="M" />
      <scope startLine="428" endLine="436">
        <declaration type="IntArrayList" name="sortedList" />
        <scope startLine="433" endLine="435" />
        <comment>it is faster to sort other before searching in it</comment>
      </scope>
      <scope startLine="437" endLine="442">
        <scope startLine="439" endLine="441" />
        <comment>it is faster to search in other without sorting</comment>
      </scope>
      <declaration type="boolean" name="modified" />
      <comment>overridden for performance only.</comment>
      <comment>There are two possibilities to do the thing
a) use other.indexOf(...)
b) sort other, then use other.binarySearch(...)

Let's try to figure out which one is faster. Let M=size, N=other.size, then
a) takes O(MN) steps
b) takes O(NlogN + MlogN) steps (sorting is O(NlogN) and binarySearch is O(logN))

Hence, if NlogN + MlogN < MN, we use b) otherwise we use a).</comment>
    </method>
    <javadoc>
      <text>* Reverses the elements of the receiver.
 * Last becomes first, second last becomes second first, and so on.</text>
    </javadoc>
    <method type="void" name="reverse" startLine="452" endLine="464">
      <declaration type="int" name="tmp" />
      <declaration type="int" name="limit" />
      <declaration type="int" name="j" />
      <declaration type="int[]" name="theElements" />
      <scope startLine="459" endLine="463">
        <comment>swap</comment>
      </scope>
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Replaces the element at the specified position in the receiver with the specified element.</text>
      <param>index index of element to replace.</param>
      <param>element element to be stored at the specified position.</param>
      <exception>IndexOutOfBoundsException index is out of range (index
 * &lt; 0 || index &gt;= size()).</exception>
    </javadoc>
    <method type="void" name="set" startLine="473" endLine="478">
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Replaces the element at the specified position in the receiver with the specified element; <b>WARNING:</b> Does not check preconditions.
 * Provided with invalid parameters this method may access invalid indexes without throwing any exception!
 * <b>You should only use this method when you are absolutely sure that the index is within bounds.</b>
 * Precondition (unchecked): <tt>index &gt;= 0 && index &lt; size()</tt>.</text>
      <param>index index of element to replace.</param>
      <param>element element to be stored at the specified position.</param>
    </javadoc>
    <method type="void" name="setQuick" startLine="488" endLine="490" />
    <javadoc>
      <text>* Randomly permutes the part of the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive).</text>
      <param>from the index of the first element (inclusive) to be permuted.</param>
      <param>to the index of the last element (inclusive) to be permuted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="shuffleFromTo" startLine="497" endLine="514">
      <scope startLine="499" endLine="499" />
      <declaration type="cern.jet.random.Uniform" name="gen" />
      <declaration type="int" name="tmpElement" />
      <declaration type="int[]" name="theElements" />
      <declaration type="int" name="random" />
      <scope startLine="506" endLine="513">
        <comment>swap(i, random)</comment>
      </scope>
      <comment>overridden for performance only.</comment>
    </method>
    <javadoc>
      <text>* Sorts the specified range of the receiver into ascending order. 
 * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
 * Currently quicksort and countsort are considered.
 * Countsort is not always applicable, but if applicable, it usually outperforms quicksort by a factor of 3-4.
 * <p>Best case performance: O(N).
 * <dt>Worst case performance: O(N^2) (a degenerated quicksort).
 * <dt>Best case space requirements: 0 KB. 
 * <dt>Worst case space requirements: 40 KB.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <exception>IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).</exception>
    </javadoc>
    <method type="void" name="sortFromTo" startLine="531" endLine="565">
      <declaration type="int" name="widthThreshold" />
      <declaration type="int" name="min" />
      <declaration type="int" name="max" />
      <declaration type="int[]" name="theElements" />
      <scope startLine="546" endLine="550">
        <declaration type="int" name="elem" />
      </scope>
      <declaration type="double" name="N" />
      <declaration type="double" name="quickSortEstimate" />
      <declaration type="double" name="width" />
      <declaration type="double" name="countSortEstimate" />
      <scope startLine="559" endLine="561" />
      <scope startLine="562" endLine="564" />
      <comment>Computes min and max and decides on this basis.
 In practice the additional overhead is very small compared to the potential gains.</comment>
      <comment>never consider options resulting in outrageous memory allocations.</comment>
      <comment>determine minimum and maximum.</comment>
      <comment>try to figure out which option is fastest.</comment>
      <comment>O(N*log(N,base=2)) ; ln(2)=0.6931471805599453</comment>
      <comment>O(Max(width,N))</comment>
    </method>
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
 * storage of the receiver.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="571" endLine="573" />
  </class>
</source>
