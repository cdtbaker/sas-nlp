<?xml version="1.0" encoding="UTF-8"?>
<source package="cern.colt.list">
  <class name="AbstractList" extends="AbstractCollection" startLine="11">
    <javadoc>
      <text>* Abstract base class for resizable lists holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc.
 * First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
 * <p>
 * <b>Note that this implementation is not synchronized.</b></text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>1.0, 09/24/99</version>
      <see>java.util.ArrayList</see>
      <see>java.util.Vector</see>
      <see>java.util.Arrays</see>
    </javadoc>
    <javadoc>
      <text>* Makes this class non instantiable, but still let's others inherit from it.</text>
    </javadoc>
    <method type="constructor" name="AbstractList" startLine="27" endLine="27" />
    <javadoc>
      <text>* Appends all of the elements of the specified Collection to the
 * receiver.</text>
      <exception>ClassCastException if an element in the collection is not
 * of the same parameter type of the receiver.</exception>
    </javadoc>
    <method type="void" name="addAllOf" startLine="35" endLine="37" />
    <javadoc>
      <text>* Inserts all elements of the specified collection before the specified position into the receiver. 
 * Shifts the element
 * currently at that position (if any) and any subsequent elements to
 * the right (increases their indices).</text>
      <param>index index before which to insert first element from the specified collection.</param>
      <param>collection the collection to be inserted</param>
      <exception>ClassCastException if an element in the collection is not
 * of the same parameter type of the receiver.</exception>
      <throws>IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.</throws>
    </javadoc>
    <method type="void" name="beforeInsertAllOf" startLine="49" endLine="52" />
    <method name="beforeInsertDummies" type="void" startLine="53" endLine="63" />
    <javadoc>
      <text>* Inserts <tt>length</tt> dummy elements before the specified position into the receiver. 
 * Shifts the element currently at that position (if any) and
 * any subsequent elements to the right.
 * <b>This method must set the new size to be <tt>size()+length</tt>.</text>
      <param>index index before which to insert dummy elements (must be in [0,size])..</param>
      <param>length number of dummy elements to be inserted.</param>
      <throws>IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt; size()</tt>.</throws>
    </javadoc>
    <javadoc>
      <text>* Checks if the given index is in range.</text>
    </javadoc>
    <method type="void" name="checkRange" startLine="67" endLine="70" />
    <javadoc>
      <text>* Checks if the given range is within the contained array's bounds.</text>
      <throws>IndexOutOfBoundsException if <tt>to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size()</tt>.</throws>
    </javadoc>
    <method type="void" name="checkRangeFromTo" startLine="75" endLine="79" />
    <javadoc>
      <text>* Removes all elements from the receiver.  The receiver will
 * be empty after this call returns, but keep its current capacity.</text>
    </javadoc>
    <method type="void" name="clear" startLine="84" endLine="86" />
    <javadoc>
      <text>* Sorts the receiver into ascending order.  
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.
 * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
 * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.</text>
    </javadoc>
    <method type="void" name="mergeSort" startLine="101" endLine="103" />
    <method name="mergeSortFromTo" type="void" startLine="104" endLine="122" />
    <javadoc>
      <text>* Sorts the receiver into ascending order.  
 * This sort is guaranteed to be <i>stable</i>:  equal elements will
 * not be reordered as a result of the sort.<p>
 * The sorting algorithm is a modified mergesort (in which the merge is
 * omitted if the highest element in the low sublist is less than the
 * lowest element in the high sublist).  This algorithm offers guaranteed
 * n*log(n) performance, and can approach linear performance on nearly
 * sorted lists.
 * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
 * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <throws>IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.</throws>
    </javadoc>
    <javadoc>
      <text>* Sorts the receiver into
 * ascending order.  The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.
 * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
 * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.</text>
    </javadoc>
    <method type="void" name="quickSort" startLine="135" endLine="137" />
    <method name="quickSortFromTo" type="void" startLine="138" endLine="154" />
    <javadoc>
      <text>* Sorts the specified range of the receiver into
 * ascending order.  The sorting algorithm is a tuned quicksort,
 * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 * Sort Function", Software-Practice and Experience, Vol. 23(11)
 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 * performance on many data sets that cause other quicksorts to degrade to
 * quadratic performance.
 * <p><b>You should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set.</b>
 * It is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt> instead, because those methods automatically choose the best sorting algorithm.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <throws>IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.</throws>
    </javadoc>
    <javadoc>
      <text>* Removes the element at the specified position from the receiver.
 * Shifts any subsequent elements to the left.</text>
      <param>index the index of the element to removed.</param>
      <throws>IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.</throws>
    </javadoc>
    <method type="void" name="remove" startLine="162" endLine="164" />
    <method name="removeFromTo" type="void" startLine="165" endLine="175" />
    <javadoc>
      <text>* Removes from the receiver all elements whose index is between
 * <code>from</code>, inclusive and <code>to</code>, inclusive.  Shifts any succeeding
 * elements to the left (reduces their index).
 * This call shortens the list by <tt>(to - from + 1)</tt> elements.</text>
      <param>from index of first element to be removed.</param>
      <param>to index of last element to be removed.</param>
      <throws>IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.</throws>
    </javadoc>
    <method name="replaceFromWith" type="void" startLine="176" endLine="185" />
    <javadoc>
      <text>* Replaces the part of the receiver starting at <code>from</code> (inclusive) with all the elements of the specified collection.
 * Does not alter the size of the receiver.
 * Replaces exactly <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.</text>
      <param>from the index at which to copy the first element from the specified collection.</param>
      <param>other Collection to replace part of the receiver</param>
      <throws>IndexOutOfBoundsException if <tt>index &lt; 0 || index &gt;= size()</tt>.</throws>
    </javadoc>
    <method name="reverse" type="void" startLine="186" endLine="190" />
    <javadoc>
      <text>* Reverses the elements of the receiver.
 * Last becomes first, second last becomes second first, and so on.</text>
    </javadoc>
    <javadoc>
      <text>* Sets the size of the receiver.
 * If the new size is greater than the current size, new null or zero items are added to the end of the receiver.
 * If the new size is less than the current size, all components at index newSize and greater are discarded.
 * This method does not release any superfluos internal memory. Use method <tt>trimToSize</tt> to release superfluos internal memory.</text>
      <param>newSize the new size of the receiver.</param>
      <throws>IndexOutOfBoundsException if <tt>newSize &lt; 0</tt>.</throws>
    </javadoc>
    <method type="void" name="setSize" startLine="199" endLine="207">
      <declaration type="int" name="currentSize" />
      <scope startLine="203" endLine="206" />
    </method>
    <javadoc>
      <text>* Randomly permutes the receiver. After invocation, all elements will be at random positions.</text>
    </javadoc>
    <method type="void" name="shuffle" startLine="211" endLine="213" />
    <method name="shuffleFromTo" type="void" startLine="214" endLine="220" />
    <javadoc>
      <text>* Randomly permutes the receiver between <code>from</code> (inclusive) and <code>to</code> (inclusive).</text>
      <param>from the start position (inclusive)</param>
      <param>to the end position (inclusive)</param>
      <throws>IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.</throws>
    </javadoc>
    <javadoc>
      <text>* Sorts the receiver into ascending order. 
 * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
 * This implementation simply calls <tt>sortFromTo(...)</tt>.
 * Override <tt>sortFromTo(...)</tt> if you can determine which sort is most appropriate for the given data set.</text>
    </javadoc>
    <method type="void" name="sort" startLine="229" endLine="231" />
    <javadoc>
      <text>* Sorts the specified range of the receiver into ascending order. 
 * The sorting algorithm is dynamically chosen according to the characteristics of the data set.
 * This default implementation simply calls quickSort.
 * Override this method if you can determine which sort is most appropriate for the given data set.</text>
      <param>from the index of the first element (inclusive) to be sorted.</param>
      <param>to the index of the last element (inclusive) to be sorted.</param>
      <throws>IndexOutOfBoundsException if <tt>(from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1</tt>.</throws>
    </javadoc>
    <method type="void" name="sortFromTo" startLine="243" endLine="245" />
    <javadoc>
      <text>* Trims the capacity of the receiver to be the receiver's current 
 * size. Releases any superfluos internal memory. An application can use this operation to minimize the 
 * storage of the receiver.
 * <p>
 * This default implementation does nothing. Override this method in space efficient implementations.</text>
    </javadoc>
    <method type="void" name="trimToSize" startLine="253" endLine="254" />
  </class>
</source>
