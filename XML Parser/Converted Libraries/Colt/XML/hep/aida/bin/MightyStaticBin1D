<?xml version="1.0" encoding="UTF-8"?>
    <source package="hep.aida.bin">
        <import package="cern.colt.list.DoubleArrayList"/>
        <import package="cern.jet.stat.Descriptive"/>
        <class name="MightyStaticBin1D" extends="StaticBin1D" line="5">
            <comment line="6">
                otected double sumOfLogarithms = 0.0; // Sum( Log(x[i]) )                
            </comment>
            <comment line="6">
                otected double sumOfInversions = 0.0; // Sum( 1/x[i] )                
            </comment>
            <comment line="6">
                otected double[] sumOfPowers = null;  // Sum( x[i]^3 ) .. Sum( x[i]^max_k )                
            </comment>
            <javadoc line="5">
                Static and the same as its superclass, except that it can do more: Additionally computes moments of arbitrary integer order, harmonic mean, geometric mean, etc.
                 * Constructors need to be told what functionality is required for the given use case.
                 * Only maintains aggregate measures (incrementally) - the added elements themselves are not kept.                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 0.9, 03-Jul-99                    
                </@version>
            </javadoc>
            <declaration name="hasSumOfLogarithms" type="boolean" line="15"/>
            <declaration name="sumOfLogarithms" type="double" line="16"/>
            <declaration name="hasSumOfInversions" type="boolean" line="18"/>
            <declaration name="sumOfInversions" type="double" line="19"/>
            <declaration name="sumOfPowers" type="double[]" line="21"/>
            <javadoc line="22">
                Constructs and returns an empty bin with limited functionality but good performance; equivalent to &lt;tt&gt;MightyStaticBin1D(false,false,4)&lt;/tt&gt;.                
            </javadoc>
            <method name="MightyStaticBin1D" type="constructor" line="25"/>
            <javadoc line="28">
                Constructs and returns an empty bin with the given capabilities.                
                <@param>
                    m hasSumOfLogarithms  Tells whether {@link #sumOfLogarithms()} can return meaningful results.
                     * Set this parameter to <tt>false</tt> if measures of sum of logarithms, geometric mean and product are not required.
                     * <p>                    
                </@param>
                <@param>
                    m hasSumOfInversions  Tells whether {@link #sumOfInversions()} can return meaningful results.
                     * Set this parameter to <tt>false</tt> if measures of sum of inversions, harmonic mean and sumOfPowers(-1) are not required.
                     * <p>                    
                </@param>
                <@param>
                    m maxOrderForSumOfPowers  The maximum order <tt>k</tt> for which {@link #sumOfPowers(int)} can return meaningful results.
                     * Set this parameter to at least 3 if the skew is required, to at least 4 if the kurtosis is required.
                     * In general, if moments are required set this parameter at least as large as the largest required moment.
                     * This method always substitutes <tt>Math.max(2,maxOrderForSumOfPowers)</tt> for the parameter passed in.
                     * Thus, <tt>sumOfPowers(0..2)</tt> always returns meaningful results.                    
                </@param>
                <@see>
                    e #hasSumOfPowers(int)                    
                </@see>
                <@see>
                    e #moment(int,double)                    
                </@see>
            </javadoc>
            <method name="MightyStaticBin1D" type="constructor" line="46"/>
            <javadoc line="52">
                Adds the part of the specified list between indexes &lt;tt&gt;from&lt;/tt&gt; (inclusive) and &lt;tt&gt;to&lt;/tt&gt; (inclusive) to the receiver.                
                <@param>
                    m list the list of which elements shall be added.                    
                </@param>
                <@param>
                    m from the index of the first element to be added (inclusive).                    
                </@param>
                <@param>
                    m to the index of the last element to be added (inclusive).                    
                </@param>
                <@throws>
                    s IndexOutOfBoundsException if <tt>list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size())</tt>.                    
                </@throws>
            </javadoc>
            <method name="addAllOfFromTo" type="void" line="60">
                <scope line="63"/>
                <scope line="68"/>
                <scope line="72"/>
            </method>
            <javadoc line="76">
                Resets the values of all measures.                
            </javadoc>
            <method name="clearAllMeasures" type="void" line="79">
                <scope line="85">
                    <scope line="86"/>
                </scope>
            </method>
            <javadoc line="91">
                Returns a deep copy of the receiver.                
                <@return>
                    n a deep copy of the receiver.                    
                </@return>
            </javadoc>
            <method name="clone" type="Object" line="96">
                <declaration name="clone" type="MightyStaticBin1D" line="97"/>
            </method>
            <javadoc line="101">
                Computes the deviations from the receiver&apos;s measures to another bin&apos;s measures.                
                <@param>
                    m other the other bin to compare with                    
                </@param>
                <@return>
                    n a summary of the deviations.                    
                </@return>
            </javadoc>
            <method name="compareWith" type="String" line="106">
                <declaration name="buf" type="StringBuffer" line="107"/>
                <scope line="108">
                    <declaration name="m" type="MightyStaticBin1D" line="109"/>
                </scope>
            </method>
            <javadoc line="122">
                Returns the geometric mean, which is &lt;tt&gt;Product( x[i] )&lt;sup&gt;1.0/size()&lt;/sup&gt;&lt;/tt&gt;.
                 * This method tries to avoid overflows at the expense of an equivalent but somewhat inefficient definition:
                 * &lt;tt&gt;geoMean = exp( Sum( Log(x[i]) ) / size())&lt;/tt&gt;.
                 * Note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.                
                <@return>
                    n the geometric mean; <tt>Double.NaN</tt> if <tt>!hasSumOfLogarithms()</tt>.                    
                </@return>
            </javadoc>
            <method name="geometricMean" type="double" line="130"/>
            <javadoc line="133">
                Returns the maximum order &lt;tt&gt;k&lt;/tt&gt; for which sums of powers are retrievable, as specified upon instance construction.                
                <@see>
                    e #hasSumOfPowers(int)                    
                </@see>
                <@see>
                    e #sumOfPowers(int)                    
                </@see>
            </javadoc>
            <method name="getMaxOrderForSumOfPowers" type="int" line="138">
                <comment line="139">
                    order 0..2 is always recorded.
                    order 0 is size()
                    order 1 is sum()
                    order 2 is sum_xx()                    
                </comment>
            </method>
            <javadoc line="148">
                Returns the minimum order &lt;tt&gt;k&lt;/tt&gt; for which sums of powers are retrievable, as specified upon instance construction.                
                <@see>
                    e #hasSumOfPowers(int)                    
                </@see>
                <@see>
                    e #sumOfPowers(int)                    
                </@see>
            </javadoc>
            <method name="getMinOrderForSumOfPowers" type="int" line="153">
                <declaration name="minOrder" type="int" line="154"/>
            </method>
            <javadoc line="158">
                Returns the harmonic mean, which is &lt;tt&gt;size() / Sum( 1/x[i] )&lt;/tt&gt;.
                 * Remember: If the receiver contains at least one element of &lt;tt&gt;0.0&lt;/tt&gt;, the harmonic mean is &lt;tt&gt;0.0&lt;/tt&gt;.                
                <@return>
                    n the harmonic mean; <tt>Double.NaN</tt> if <tt>!hasSumOfInversions()</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfInversions()                    
                </@see>
            </javadoc>
            <method name="harmonicMean" type="double" line="164"/>
            <javadoc line="167">
                Returns whether &lt;tt&gt;sumOfInversions()&lt;/tt&gt; can return meaningful results.                
                <@return>
                    n <tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.
                     * See the constructors for proper parametrization.                    
                </@return>
            </javadoc>
            <method name="hasSumOfInversions" type="boolean" line="172"/>
            <javadoc line="175">
                Tells whether &lt;tt&gt;sumOfLogarithms()&lt;/tt&gt; can return meaningful results.                
                <@return>
                    n <tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.
                     * See the constructors for proper parametrization.                    
                </@return>
            </javadoc>
            <method name="hasSumOfLogarithms" type="boolean" line="180"/>
            <javadoc line="183">
                Tells whether &lt;tt&gt;sumOfPowers(k)&lt;/tt&gt; can return meaningful results.
                 * Defined as &lt;tt&gt;hasSumOfPowers(k) &lt;==&gt; getMinOrderForSumOfPowers() &lt;= k &amp;&amp; k &lt;= getMaxOrderForSumOfPowers()&lt;/tt&gt;.
                 * A return value of &lt;tt&gt;true&lt;/tt&gt; implies that &lt;tt&gt;hasSumOfPowers(k-1) .. hasSumOfPowers(0)&lt;/tt&gt; will also return &lt;tt&gt;true&lt;/tt&gt;.
                 * See the constructors for proper parametrization.
                 * &lt;p&gt;
                 * &lt;b&gt;Details&lt;/b&gt;: 
                 * &lt;tt&gt;hasSumOfPowers(0..2)&lt;/tt&gt; will always yield &lt;tt&gt;true&lt;/tt&gt;.
                 * &lt;tt&gt;hasSumOfPowers(-1) &lt;==&gt; hasSumOfInversions()&lt;/tt&gt;.                
                <@return>
                    n <tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.                    
                </@return>
                <@see>
                    e #getMinOrderForSumOfPowers()                    
                </@see>
                <@see>
                    e #getMaxOrderForSumOfPowers()                    
                </@see>
            </javadoc>
            <method name="hasSumOfPowers" type="boolean" line="197"/>
            <javadoc line="200">
                Returns the kurtosis (aka excess), which is &lt;tt&gt;-3 + moment(4,mean()) / standardDeviation()&lt;sup&gt;4&lt;/sup&gt;&lt;/tt&gt;.                
                <@return>
                    n the kurtosis; <tt>Double.NaN</tt> if <tt>!hasSumOfPowers(4)</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfPowers(int)                    
                </@see>
            </javadoc>
            <method name="kurtosis" type="double" line="205"/>
            <javadoc line="208">
                Returns the moment of &lt;tt&gt;k&lt;/tt&gt;-th order with value &lt;tt&gt;c&lt;/tt&gt;,
                 * which is &lt;tt&gt;Sum( (x[i]-c)&lt;sup&gt;k&lt;/sup&gt; ) / size()&lt;/tt&gt;.                
                <@param>
                    m k the order; must be greater than or equal to zero.                    
                </@param>
                <@param>
                    m c any number.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>k < 0</tt>.                    
                </@throws>
                <@return>
                    n <tt>Double.NaN</tt> if <tt>!hasSumOfPower(k)</tt>.                    
                </@return>
            </javadoc>
            <method name="moment" type="double" line="217">
                <comment line="218">
                    checkOrder(k);                    
                </comment>
                <declaration name="maxOrder" type="int" line="222"/>
                <declaration name="sumOfPows" type="DoubleArrayList" line="223"/>
            </method>
            <javadoc line="231">
                Returns the product, which is &lt;tt&gt;Prod( x[i] )&lt;/tt&gt;.
                 * In other words: &lt;tt&gt;x[0]*x[1]*...*x[size()-1]&lt;/tt&gt;.                
                <@return>
                    n the product; <tt>Double.NaN</tt> if <tt>!hasSumOfLogarithms()</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfLogarithms()                    
                </@see>
            </javadoc>
            <method name="product" type="double" line="237"/>
            <javadoc line="240">
                Sets the range of orders in which sums of powers are to be computed.
                 * In other words, &lt;tt&gt;sumOfPower(k)&lt;/tt&gt; will return &lt;tt&gt;Sum( x[i]^k )&lt;/tt&gt; if &lt;tt&gt;min_k &lt;= k &lt;= max_k || 0 &lt;= k &lt;= 2&lt;/tt&gt;
                 * and throw an exception otherwise.                
                <@see>
                    e #isLegalOrder(int)                    
                </@see>
                <@see>
                    e #sumOfPowers(int)                    
                </@see>
                <@see>
                    e #getRangeForSumOfPowers()                    
                </@see>
            </javadoc>
            <method name="setMaxOrderForSumOfPowers" type="void" line="248">
                <comment line="249">
                    if (max_k &lt; ) throw new IllegalArgumentException();                    
                </comment>
                <scope line="251"/>
                <scope line="254"/>
            </method>
            <javadoc line="258">
                Returns the skew, which is &lt;tt&gt;moment(3,mean()) / standardDeviation()&lt;sup&gt;3&lt;/sup&gt;&lt;/tt&gt;.                
                <@return>
                    n the skew; <tt>Double.NaN</tt> if <tt>!hasSumOfPowers(3)</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfPowers(int)                    
                </@see>
            </javadoc>
            <method name="skew" type="double" line="263"/>
            <javadoc line="266">
                Returns the sum of inversions, which is &lt;tt&gt;Sum( 1 / x[i] )&lt;/tt&gt;.                
                <@return>
                    n the sum of inversions; <tt>Double.NaN</tt> if <tt>!hasSumOfInversions()</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfInversions()                    
                </@see>
            </javadoc>
            <method name="sumOfInversions" type="double" line="271">
                <comment line="272">
                    if (! this.hasSumOfInversions) throw new IllegalOperationException(&quot;You must specify upon instance construction that the sum of inversions shall be computed.&quot;);                    
                </comment>
            </method>
            <javadoc line="276">
                Returns the sum of logarithms, which is &lt;tt&gt;Sum( Log(x[i]) )&lt;/tt&gt;.                
                <@return>
                    n the sum of logarithms; <tt>Double.NaN</tt> if <tt>!hasSumOfLogarithms()</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfLogarithms()                    
                </@see>
            </javadoc>
            <method name="sumOfLogarithms" type="double" line="281">
                <comment line="282">
                    if (! this.hasSumOfLogarithms) throw new IllegalOperationException(&quot;You must specify upon instance construction that the sum of logarithms shall be computed.&quot;);                    
                </comment>
            </method>
            <javadoc line="286">
                Returns the &lt;tt&gt;k-th&lt;/tt&gt; order sum of powers, which is &lt;tt&gt;Sum( x[i]&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt;.                
                <@param>
                    m k the order of the powers.                    
                </@param>
                <@return>
                    n the sum of powers; <tt>Double.NaN</tt> if <tt>!hasSumOfPowers(k)</tt>.                    
                </@return>
                <@see>
                    e #hasSumOfPowers(int)                    
                </@see>
            </javadoc>
            <method name="sumOfPowers" type="double" line="292">
                <comment line="293">
                    checkOrder(k);                    
                </comment>
            </method>
            <javadoc line="302">
                Returns a String representation of the receiver.                
            </javadoc>
            <method name="toString" type="String" line="305">
                <comment line="306">
                    t maxPrintOrder = Math.min(6,maxOrder); // don&apos;t print tons of measures                    
                </comment>
                <declaration name="buf" type="StringBuffer" line="306"/>
                <scope line="308"/>
                <scope line="313"/>
                <declaration name="maxOrder" type="int" line="318"/>
                <declaration name="maxPrintOrder" type="int" line="319"/>
                <scope line="320">
                    <scope line="321"/>
                    <scope line="324"/>
                    <scope line="327"/>
                    <scope line="330"/>
                    <scope line="333"/>
                </scope>
            </method>
            <javadoc line="339">
                @throws IllegalOperationException if &lt;tt&gt;! isLegalOrder(k)&lt;/tt&gt;.                
            </javadoc>
            <method name="xcheckOrder" type="void" line="342">
                <comment line="343">
                    if (! isLegalOrder(k)) return Double.NaN;                    
                </comment>
                <comment line="343">
                    if (! xisLegalOrder(k)) throw new IllegalOperationException(&quot;Illegal order of sum of powers: k=&quot;+k+&quot;. Upon instance construction legal range was fixed to be &quot;+getMinOrderForSumOfPowers()+&quot; &lt;= k &lt;= &quot;+getMaxOrderForSumOfPowers());                    
                </comment>
            </method>
            <javadoc line="346">
                Returns whether two bins are equal; 
                 * They are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum, sumOfSquares, sumOfInversions and sumOfLogarithms.                
            </javadoc>
            <method name="xequals" type="boolean" line="350">
                <declaration name="other" type="MightyStaticBin1D" line="352"/>
            </method>
            <javadoc line="355">
                Tells whether &lt;tt&gt;sumOfPowers(fromK) .. sumOfPowers(toK)&lt;/tt&gt; can return meaningful results.                
                <@return>
                    n <tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.
                     * See the constructors for proper parametrization.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>fromK > toK</tt>.                    
                </@throws>
            </javadoc>
            <method name="xhasSumOfPowers" type="boolean" line="361"/>
            <javadoc line="365">
                Returns &lt;tt&gt;getMinOrderForSumOfPowers() &lt;= k &amp;&amp; k &lt;= getMaxOrderForSumOfPowers()&lt;/tt&gt;.                
            </javadoc>
            <method name="xisLegalOrder" type="boolean" line="368"/>
        </class>
    </source>