<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.list">
        <import package="cern.colt.function.LongProcedure"/>
        <class name="LongArrayList" line="12">
            <extends class="AbstractLongList"/>
            <javadoc line="12">
                Resizable list holding &lt;code&gt;long&lt;/code&gt; elements; implemented with arrays.
                  First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.                
            </javadoc>
            <declaration name="elements" type="long[]" line="17"/>
            <javadoc line="17">
                The array buffer into which the elements of the list are stored.
                  The capacity of the list is the length of this array buffer.                
                <@serial>
                    l                    
                </@serial>
            </javadoc>
            <javadoc line="23">
                Constructs an empty list.                
            </javadoc>
            <method name="LongArrayList" type="constructor" line="26"/>
            <javadoc line="29">
                Constructs a list containing the specified elements. 
                  The initial size and capacity of the list is the length of the array.
                  &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
                  So if subsequently you modify the specified array directly via the [] operator, be sure you know what you&apos;re doing.                
                <@param>
                    m elements the array to be backed by the the constructed list                    
                </@param>
            </javadoc>
            <method name="LongArrayList" type="constructor" line="38">
                <params>
                    <param name="elements" type="long[]"/>
                </params>
            </method>
            <javadoc line="41">
                Constructs an empty list with the specified initial capacity.                
                <@param>
                    m initialCapacity   the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory.                    
                </@param>
            </javadoc>
            <method name="LongArrayList" type="constructor" line="46">
                <params>
                    <param name="initialCapacity" type="int"/>
                </params>
            </method>
            <javadoc line="50">
                Appends the specified element to the end of this list.                
                <@param>
                    m element element to be appended to this list.                    
                </@param>
            </javadoc>
            <method name="add" type="void" line="55">
                <params>
                    <param name="element" type="long"/>
                </params>
                <comment line="56">
                    overridden for performance only.                    
                </comment>
            </method>
            <javadoc line="60">
                Inserts the specified element before the specified position into the receiver. 
                  Shifts the element currently at that position (if any) and
                  any subsequent elements to the right.                
                <@param>
                    m index index before which the specified element is to be inserted (must be in [0,size]).                    
                </@param>
                <@param>
                    m element element to be inserted.                    
                </@param>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (<tt>index &lt; 0 || index &gt; size()</tt>).                    
                </@exception>
            </javadoc>
            <method name="beforeInsert" type="void" line="69">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="long"/>
                </params>
                <comment line="70">
                    overridden for performance only.                    
                </comment>
            </method>
            <javadoc line="78">
                Searches the receiver for the specified value using
                  the binary search algorithm.  The receiver must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the receiver contains multiple elements
                  equal to the specified object, there is no guarantee which instance
                  will be found.                
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the receiver;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                      point</i> is defined as the the point at which the value would
                      be inserted into the receiver: the index of the first
                      element greater than the key, or <tt>receiver.size()</tt>, if all
                      elements in the receiver are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </@return>
                <@see>
                    e cern.colt.Sorting                    
                </@see>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="101">
                <params>
                    <param name="key" type="long"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
            </method>
            <javadoc line="104">
                Returns a deep copy of the receiver.                
                <@return>
                    n  a deep copy of the receiver.                    
                </@return>
            </javadoc>
            <method name="clone" type="Object" line="109">
                <comment line="110">
                    overridden for performance only.                    
                </comment>
                <declaration name="clone" type="LongArrayList" line="111"/>
            </method>
            <javadoc line="115">
                Returns a deep copy of the receiver; uses &lt;code&gt;clone()&lt;/code&gt; and casts the result.                
                <@return>
                    n  a deep copy of the receiver.                    
                </@return>
            </javadoc>
            <method name="copy" type="LongArrayList" line="120"/>
            <javadoc line="123">
                Sorts the specified range of the receiver into ascending numerical order. 
                  The sorting algorithm is a count sort. This algorithm offers guaranteed
                  &lt;dt&gt;Performance: O(Max(n,max-min+1)).
                  &lt;dt&gt;Space requirements: int[max-min+1] buffer.
                  &lt;p&gt;This algorithm is only applicable if max-min+1 is not large!
                  But if applicable, it usually outperforms quicksort by a factor of 3-4.                
                <@param>
                    m from the index of the first element (inclusive) to be sorted.                    
                </@param>
                <@param>
                    m to the index of the last element (inclusive) to be sorted.                    
                </@param>
                <@param>
                    m min the smallest element contained in the range.                    
                </@param>
                <@param>
                    m max the largest element contained in the range.                    
                </@param>
            </javadoc>
            <method name="countSortFromTo" type="void" line="137">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="min" type="long"/>
                    <param name="max" type="long"/>
                </params>
                <declaration name="width" type="int" line="141"/>
                <declaration name="counts" type="int[]" line="143"/>
                <declaration name="theElements" type="long[]" line="144"/>
                <declaration name="fromIndex" type="int" line="147"/>
                <declaration name="val" type="long" line="148"/>
                <scope line="149">
                    <declaration name="c" type="int" line="150"/>
                    <scope line="151">
                        <scope line="153">
                            <declaration name="toIndex" type="int" line="154"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="161">
                Returns the elements currently stored, including invalid elements between size and capacity, if any.
                  &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
                  So if subsequently you modify the returned array directly via the [] operator, be sure you know what you&apos;re doing.                
                <@return>
                    n the elements currently stored.                    
                </@return>
            </javadoc>
            <method name="elements" type="long[]" line="169"/>
            <javadoc line="172">
                Sets the receiver&apos;s elements to be the specified array (not a copy of it).
                  The size and capacity of the list is the length of the array.
                  &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
                  So if subsequently you modify the specified array directly via the [] operator, be sure you know what you&apos;re doing.                
                <@param>
                    m elements the new elements to be stored.                    
                </@param>
                <@return>
                    n the receiver itself.                    
                </@return>
            </javadoc>
            <method name="elements" type="AbstractLongList" line="182">
                <params>
                    <param name="elements" type="long[]"/>
                </params>
            </method>
            <javadoc line="187">
                Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
                  If necessary, allocates new internal memory and increases the capacity of the receiver.                
                <@param>
                    m minCapacity   the desired minimum capacity.                    
                </@param>
            </javadoc>
            <method name="ensureCapacity" type="void" line="193">
                <params>
                    <param name="minCapacity" type="int"/>
                </params>
            </method>
            <javadoc line="196">
                Compares the specified Object with the receiver.  
                  Returns true if and only if the specified Object is also an ArrayList of the same type, both Lists have the
                  same size, and all corresponding pairs of elements in the two Lists are identical.
                  In other words, two Lists are defined to be equal if they contain the
                  same elements in the same order.                
                <@param>
                    m otherObj the Object to be compared for equality with the receiver.                    
                </@param>
                <@return>
                    n true if the specified Object is equal to the receiver.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="206">
                <params>
                    <param name="otherObj" type="Object"/>
                </params>
                <comment line="207">
                    blic boolean equals(Object otherObj) { //delta                    
                </comment>
                <comment line="207">
                    overridden for performance only.                    
                </comment>
                <declaration name="other" type="LongArrayList" line="211"/>
                <declaration name="theElements" type="long[]" line="214"/>
                <declaration name="otherElements" type="long[]" line="215"/>
                <scope line="216"/>
            </method>
            <javadoc line="221">
                Applies a procedure to each element of the receiver, if any.
                  Starts at index 0, moving rightwards.                
                <@param>
                    m procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </@param>
                <@return>
                    n <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.                    
                </@return>
            </javadoc>
            <method name="forEach" type="boolean" line="227">
                <params>
                    <param name="procedure" type="LongProcedure"/>
                </params>
                <comment line="228">
                    overridden for performance only.                    
                </comment>
                <declaration name="theElements" type="long[]" line="229"/>
                <declaration name="theSize" type="int" line="230"/>
            </method>
            <javadoc line="235">
                Returns the element at the specified position in the receiver.                
                <@param>
                    m index index of element to return.                    
                </@param>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (index
                      &lt; 0 || index &gt;= size()).                    
                </@exception>
            </javadoc>
            <method name="get" type="long" line="242">
                <params>
                    <param name="index" type="int"/>
                </params>
                <comment line="243">
                    overridden for performance only.                    
                </comment>
            </method>
            <javadoc line="248">
                Returns the element at the specified position in the receiver; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions. 
                  Provided with invalid parameters this method may return invalid elements without throwing any exception!
                  &lt;b&gt;You should only use this method when you are absolutely sure that the index is within bounds.&lt;/b&gt;
                  Precondition (unchecked): &lt;tt&gt;index &amp;gt;= 0 &amp;&amp; index &amp;lt; size()&lt;/tt&gt;.                
                <@param>
                    m index index of element to return.                    
                </@param>
            </javadoc>
            <method name="getQuick" type="long" line="256">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="259">
                Returns the index of the first occurrence of the specified
                  element. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this element.
                  Searches between &lt;code&gt;from&lt;/code&gt;, inclusive and &lt;code&gt;to&lt;/code&gt;, inclusive.
                  Tests for identity.                
                <@param>
                    m element element to search for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n  the index of the first occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.                    
                </@return>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).                    
                </@exception>
            </javadoc>
            <method name="indexOfFromTo" type="int" line="271">
                <params>
                    <param name="element" type="long"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="272">
                    overridden for performance only.                    
                </comment>
                <comment line="272">
                    turn -1; //not found                    
                </comment>
                <declaration name="theElements" type="long[]" line="276"/>
                <scope line="277">
                    <scope line="278"/>
                </scope>
            </method>
            <javadoc line="282">
                Returns the index of the last occurrence of the specified
                  element. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this element.
                  Searches beginning at &lt;code&gt;to&lt;/code&gt;, inclusive until &lt;code&gt;from&lt;/code&gt;, inclusive.
                  Tests for identity.                
                <@param>
                    m element element to search for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n  the index of the last occurrence of the element in the receiver; returns <code>-1</code> if the element is not found.                    
                </@return>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).                    
                </@exception>
            </javadoc>
            <method name="lastIndexOfFromTo" type="int" line="294">
                <params>
                    <param name="element" type="long"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="295">
                    overridden for performance only.                    
                </comment>
                <comment line="295">
                    turn -1; //not found                    
                </comment>
                <declaration name="theElements" type="long[]" line="299"/>
                <scope line="300">
                    <scope line="301"/>
                </scope>
            </method>
            <javadoc line="305">
                Returns a new list of the part of the receiver between &lt;code&gt;from&lt;/code&gt;, inclusive, and &lt;code&gt;to&lt;/code&gt;, inclusive.                
                <@param>
                    m from the index of the first element (inclusive).                    
                </@param>
                <@param>
                    m to the index of the last element (inclusive).                    
                </@param>
                <@return>
                    n a new list                    
                </@return>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).                    
                </@exception>
            </javadoc>
            <method name="partFromTo" type="AbstractLongList" line="312">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="part" type="long[]" line="317"/>
            </method>
            <javadoc line="321">
                Removes from the receiver all elements that are contained in the specified list.
                  Tests for identity.                
                <@param>
                    m other the other list.                    
                </@param>
                <@return>
                    n <code>true</code> if the receiver changed as a result of the call.                    
                </@return>
            </javadoc>
            <method name="removeAll" type="boolean" line="328">
                <params>
                    <param name="other" type="AbstractLongList"/>
                </params>
                <comment line="329">
                    overridden for performance only.                    
                </comment>
                <comment line="329">
                    There are two possibilities to do the thing
                    a) use other.indexOf(...)
                    b) sort other, then use other.binarySearch(...)
                    
                    Let&apos;s try to figure out which one is faster. Let M=size, N=other.size, then                    
                </comment>
                <comment line="329">
                    (other.size()==0) {return false;} //nothing to do                    
                </comment>
                <scope line="342"/>
                <declaration name="limit" type="int" line="343"/>
                <declaration name="j" type="int" line="344"/>
                <declaration name="theElements" type="long[]" line="345"/>
                <declaration name="mySize" type="int" line="346"/>
                <declaration name="N" type="double" line="348"/>
                <declaration name="M" type="double" line="349"/>
                <scope line="350">
                    <declaration name="sortedList" type="LongArrayList" line="352"/>
                    <scope line="355"/>
                </scope>
                <scope line="359">
                    <scope line="361"/>
                </scope>
                <declaration name="modified" type="boolean" line="366"/>
            </method>
            <javadoc line="370">
                Replaces a number of elements in the receiver with the same number of elements of another list.
                  Replaces elements in the receiver, between &lt;code&gt;from&lt;/code&gt; (inclusive) and &lt;code&gt;to&lt;/code&gt; (inclusive),
                  with elements of &lt;code&gt;other&lt;/code&gt;, starting from &lt;code&gt;otherFrom&lt;/code&gt; (inclusive).                
                <@param>
                    m from the position of the first element to be replaced in the receiver                    
                </@param>
                <@param>
                    m to the position of the last element to be replaced in the receiver                    
                </@param>
                <@param>
                    m other list holding elements to be copied into the receiver.                    
                </@param>
                <@param>
                    m otherFrom position of first element within other list to be copied.                    
                </@param>
            </javadoc>
            <method name="replaceFromToWithFrom" type="void" line="380">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="other" type="AbstractLongList"/>
                    <param name="otherFrom" type="int"/>
                </params>
                <comment line="381">
                    overridden for performance only.                    
                </comment>
                <scope line="382"/>
                <declaration name="length" type="int" line="387"/>
                <scope line="388"/>
            </method>
            <javadoc line="394">
                Retains (keeps) only the elements in the receiver that are contained in the specified other list.
                  In other words, removes from the receiver all of its elements that are not contained in the
                  specified other list.                
                <@param>
                    m other the other list to test against.                    
                </@param>
                <@return>
                    n <code>true</code> if the receiver changed as a result of the call.                    
                </@return>
            </javadoc>
            <method name="retainAll" type="boolean" line="401">
                <params>
                    <param name="other" type="AbstractLongList"/>
                </params>
                <comment line="402">
                    overridden for performance only.                    
                </comment>
                <comment line="402">
                    There are two possibilities to do the thing
                    a) use other.indexOf(...)
                    b) sort other, then use other.binarySearch(...)
                    
                    Let&apos;s try to figure out which one is faster. Let M=size, N=other.size, then                    
                </comment>
                <declaration name="limit" type="int" line="415"/>
                <declaration name="j" type="int" line="416"/>
                <declaration name="theElements" type="long[]" line="417"/>
                <declaration name="mySize" type="int" line="418"/>
                <declaration name="N" type="double" line="420"/>
                <declaration name="M" type="double" line="421"/>
                <scope line="422">
                    <declaration name="sortedList" type="LongArrayList" line="424"/>
                    <scope line="427"/>
                </scope>
                <scope line="431">
                    <scope line="433"/>
                </scope>
                <declaration name="modified" type="boolean" line="438"/>
            </method>
            <javadoc line="442">
                Reverses the elements of the receiver.
                  Last becomes first, second last becomes second first, and so on.                
            </javadoc>
            <method name="reverse" type="void" line="446">
                <comment line="447">
                    overridden for performance only.                    
                </comment>
                <declaration name="tmp" type="long" line="448"/>
                <declaration name="limit" type="int" line="449"/>
                <declaration name="j" type="int" line="450"/>
                <declaration name="theElements" type="long[]" line="452"/>
                <scope line="453"/>
            </method>
            <javadoc line="459">
                Replaces the element at the specified position in the receiver with the specified element.                
                <@param>
                    m index index of element to replace.                    
                </@param>
                <@param>
                    m element element to be stored at the specified position.                    
                </@param>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (index
                      &lt; 0 || index &gt;= size()).                    
                </@exception>
            </javadoc>
            <method name="set" type="void" line="467">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="long"/>
                </params>
                <comment line="468">
                    overridden for performance only.                    
                </comment>
            </method>
            <javadoc line="473">
                Replaces the element at the specified position in the receiver with the specified element; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions.
                  Provided with invalid parameters this method may access invalid indexes without throwing any exception!
                  &lt;b&gt;You should only use this method when you are absolutely sure that the index is within bounds.&lt;/b&gt;
                  Precondition (unchecked): &lt;tt&gt;index &amp;gt;= 0 &amp;&amp; index &amp;lt; size()&lt;/tt&gt;.                
                <@param>
                    m index index of element to replace.                    
                </@param>
                <@param>
                    m element element to be stored at the specified position.                    
                </@param>
            </javadoc>
            <method name="setQuick" type="void" line="482">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="long"/>
                </params>
            </method>
            <javadoc line="485">
                Randomly permutes the part of the receiver between &lt;code&gt;from&lt;/code&gt; (inclusive) and &lt;code&gt;to&lt;/code&gt; (inclusive).                
                <@param>
                    m from the index of the first element (inclusive) to be permuted.                    
                </@param>
                <@param>
                    m to the index of the last element (inclusive) to be permuted.                    
                </@param>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).                    
                </@exception>
            </javadoc>
            <method name="shuffleFromTo" type="void" line="491">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="492">
                    overridden for performance only.                    
                </comment>
                <declaration name="gen" type="cern.jet.random.Uniform" line="496"/>
                <declaration name="tmpElement" type="long" line="497"/>
                <declaration name="theElements" type="long[]" line="498"/>
                <declaration name="random" type="int" line="499"/>
                <scope line="500"/>
            </method>
            <javadoc line="509">
                Sorts the specified range of the receiver into ascending order. 
                  The sorting algorithm is dynamically chosen according to the characteristics of the data set.
                  Currently quicksort and countsort are considered.
                  Countsort is not always applicable, but if applicable, it usually outperforms quicksort by a factor of 3-4.
                  &lt;p&gt;Best case performance: O(N).
                  &lt;dt&gt;Worst case performance: O(N^2) (a degenerated quicksort).
                  &lt;dt&gt;Best case space requirements: 0 KB. 
                  &lt;dt&gt;Worst case space requirements: 40 KB.                
                <@param>
                    m from the index of the first element (inclusive) to be sorted.                    
                </@param>
                <@param>
                    m to the index of the last element (inclusive) to be sorted.                    
                </@param>
                <@exception>
                    n IndexOutOfBoundsException index is out of range (<tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>).                    
                </@exception>
            </javadoc>
            <method name="sortFromTo" type="void" line="525">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="526">
                    Computes min and max and decides on this basis.                    
                </comment>
                <comment line="526">
                    nal int widthThreshold = 10000; // never consider options resulting in outrageous memory allocations.                    
                </comment>
                <comment line="526">
                    determine minimum and maximum.                    
                </comment>
                <comment line="526">
                    try to figure out which option is fastest.                    
                </comment>
                <comment line="526">
                    uble quickSortEstimate = 	N * Math.log(N)/0.6931471805599453; // O(N*log(N,base=2)) ; ln(2)=0.6931471805599453                    
                </comment>
                <comment line="526">
                    uble countSortEstimate = 	Math.max(width,N); // O(Max(width,N))                    
                </comment>
                <declaration name="widthThreshold" type="int" line="530"/>
                <declaration name="min" type="long" line="536"/>
                <declaration name="max" type="long" line="537"/>
                <declaration name="theElements" type="long[]" line="539"/>
                <scope line="540">
                    <declaration name="elem" type="long" line="541"/>
                </scope>
                <declaration name="N" type="double" line="547"/>
                <declaration name="quickSortEstimate" type="double" line="548"/>
                <declaration name="width" type="double" line="550"/>
                <declaration name="countSortEstimate" type="double" line="551"/>
                <scope line="553"/>
                <scope line="556"/>
            </method>
            <javadoc line="560">
                Trims the capacity of the receiver to be the receiver&apos;s current 
                  size. Releases any superfluous internal memory. An application can use this operation to minimize the 
                  storage of the receiver.                
            </javadoc>
            <method name="trimToSize" type="void" line="565"/>
        </class>
    </source>