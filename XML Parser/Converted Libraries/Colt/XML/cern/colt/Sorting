<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt">
        <import package="java.util.Comparator"/>
        <import package="cern.colt.function.ByteComparator"/>
        <import package="cern.colt.function.CharComparator"/>
        <import package="cern.colt.function.DoubleComparator"/>
        <import package="cern.colt.function.FloatComparator"/>
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.function.LongComparator"/>
        <import package="cern.colt.function.ShortComparator"/>
        <class name="Sorting" extends="Object" line="20">
            <javadoc line="20">
                Quicksorts, mergesorts and binary searches; complements &lt;tt&gt;java.util.Arrays&lt;/tt&gt;.
                 * Contains, for example, the quicksort on Comparators and Comparables, which are still missing in &lt;tt&gt;java.util.Arrays&lt;/tt&gt; of JDK 1.2.
                 * Also provides mergesorts for types not supported in &lt;tt&gt;java.util.Arrays&lt;/tt&gt;, as well as a couple of other methods for primitive arrays.
                 * The quicksorts and mergesorts are the JDK 1.2 V1.26 algorithms, modified as necessary.                
                <@see>
                    e cern.colt.GenericSorting                    
                </@see>
                <@see>
                    e cern.colt.matrix.doublealgo.Sorting                    
                </@see>
                <@see>
                    e java.util.Arrays                    
                </@see>
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 03-Jul-99                    
                </@version>
            </javadoc>
            <declaration name="SMALL" type="int" line="34"/>
            <declaration name="MEDIUM" type="int" line="35"/>
            <javadoc line="36">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Sorting" type="constructor" line="39"/>
            <javadoc line="40">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="63">
                <comment line="64">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="byte" line="64"/>
                <scope line="65">
                    <declaration name="mid" type="int" line="66"/>
                </scope>
            </method>
            <javadoc line="74">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="97">
                <comment line="98">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="char" line="98"/>
                <scope line="99">
                    <declaration name="mid" type="int" line="100"/>
                </scope>
            </method>
            <javadoc line="108">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="131">
                <comment line="132">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="double" line="132"/>
                <scope line="133">
                    <declaration name="mid" type="int" line="134"/>
                </scope>
            </method>
            <javadoc line="142">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="165">
                <comment line="166">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="float" line="166"/>
                <scope line="167">
                    <declaration name="mid" type="int" line="168"/>
                </scope>
            </method>
            <javadoc line="176">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="199">
                <comment line="200">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <comment line="200">
                    even for very short lists (0,1,2,3 elems) this is only 10% faster
                    while (from&lt;=to &amp;&amp; list[from++] &lt; key) ;                    
                </comment>
                <declaration name="midVal" type="int" line="200"/>
                <scope line="201">
                    <declaration name="mid" type="int" line="202"/>
                </scope>
            </method>
            <javadoc line="219">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="242">
                <comment line="243">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="long" line="243"/>
                <scope line="244">
                    <declaration name="mid" type="int" line="245"/>
                </scope>
            </method>
            <javadoc line="253">
                Searches the list for the specified value using
                 * the binary search algorithm. The list must be sorted into ascending order
                 * according to the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * If the list is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which instance
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@param>
                    m comparator the comparator by which the list is sorted.                    
                </@param>
                <@throws>
                    s ClassCastException if the list contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
                <@see>
                    e java.util.Comparator                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="286">
                <comment line="287">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="Object" line="287"/>
                <scope line="288">
                    <declaration name="mid" type="int" line="289"/>
                    <declaration name="cmp" type="int" line="291"/>
                </scope>
            </method>
            <javadoc line="299">
                Searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="322">
                <comment line="323">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="midVal" type="short" line="323"/>
                <scope line="324">
                    <declaration name="mid" type="int" line="325"/>
                </scope>
            </method>
            <javadoc line="333">
                Generically searches the list for the specified value using
                 * the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                 * sorted (as by the sort method) prior to making this call.  If
                 * it is not sorted, the results are undefined: in particular, the call
                 * may enter an infinite loop.  If the list contains multiple elements
                 * equal to the specified key, there is no guarantee which of the multiple elements
                 * will be found.                
                <@param>
                    m list the list to be searched.                    
                </@param>
                <@param>
                    m key the value to be searched for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="356">
                <comment line="357">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <declaration name="dummy" type="int" line="357"/>
                <scope line="358">
                    <declaration name="mid" type="int" line="359"/>
                    <declaration name="comparison" type="int" line="360"/>
                </scope>
            </method>
            <method name="lower_bound" type="int" line="368">
                <declaration name="len" type="int" line="369"/>
                <scope line="370">
                    <declaration name="half" type="int" line="371"/>
                    <declaration name="middle" type="int" line="372"/>
                    <scope line="373"/>
                </scope>
            </method>
            <method name="upper_bound" type="int" line="382">
                <declaration name="len" type="int" line="383"/>
                <scope line="384">
                    <declaration name="half" type="int" line="385"/>
                    <declaration name="middle" type="int" line="386"/>
                    <scope line="389"/>
                </scope>
            </method>
            <method name="inplace_merge" type="void" line="397">
                <comment line="398">
                    rotate(array, firstCut, middle, secondCut);                    
                </comment>
                <comment line="398">
                    is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are &quot;static private&quot;)                    
                </comment>
                <comment line="398">
                    speedup = 1.7                    
                </comment>
                <comment line="398">
                    begin inline                    
                </comment>
                <comment line="398">
                    end inline                    
                </comment>
                <scope line="400">
                    <scope line="401">
                        <declaration name="tmp" type="int" line="402"/>
                    </scope>
                </scope>
                <declaration name="firstCut" type="int" line="408"/>
                <declaration name="secondCut" type="int" line="409"/>
                <scope line="410"/>
                <scope line="413"/>
                <declaration name="first2" type="int" line="422"/>
                <declaration name="middle2" type="int" line="422"/>
                <declaration name="last2" type="int" line="422"/>
                <scope line="423">
                    <declaration name="first1" type="int" line="424"/>
                    <declaration name="last1" type="int" line="424"/>
                    <declaration name="tmp" type="int" line="425"/>
                    <scope line="426"/>
                    <scope line="428"/>
                    <scope line="430"/>
                </scope>
            </method>
            <javadoc line="439">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="442">
                <declaration name="ab" type="int" line="443"/>
                <declaration name="ac" type="int" line="444"/>
                <declaration name="bc" type="int" line="445"/>
            </method>
            <javadoc line="450">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="453">
                <declaration name="ab" type="int" line="454"/>
                <declaration name="ac" type="int" line="455"/>
                <declaration name="bc" type="int" line="456"/>
            </method>
            <javadoc line="461">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="464">
                <declaration name="ab" type="int" line="465"/>
                <declaration name="ac" type="int" line="466"/>
                <declaration name="bc" type="int" line="467"/>
            </method>
            <javadoc line="472">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="475">
                <declaration name="ab" type="int" line="476"/>
                <declaration name="ac" type="int" line="477"/>
                <declaration name="bc" type="int" line="478"/>
            </method>
            <javadoc line="483">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="486">
                <declaration name="ab" type="int" line="487"/>
                <declaration name="ac" type="int" line="488"/>
                <declaration name="bc" type="int" line="489"/>
            </method>
            <javadoc line="494">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="497">
                <declaration name="ab" type="int" line="498"/>
                <declaration name="ac" type="int" line="499"/>
                <declaration name="bc" type="int" line="500"/>
            </method>
            <javadoc line="505">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="508">
                <declaration name="ab" type="int" line="509"/>
                <declaration name="ac" type="int" line="510"/>
                <declaration name="bc" type="int" line="511"/>
            </method>
            <javadoc line="516">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="519">
                <declaration name="ab" type="int" line="520"/>
                <declaration name="ac" type="int" line="521"/>
                <declaration name="bc" type="int" line="522"/>
            </method>
            <javadoc line="527">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="530">
                <declaration name="ab" type="int" line="531"/>
                <declaration name="ac" type="int" line="532"/>
                <declaration name="bc" type="int" line="533"/>
            </method>
            <javadoc line="539">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="559">
                <declaration name="aux" type="byte" line="561"/>
            </method>
            <javadoc line="564">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="593">
                <declaration name="aux" type="byte" line="595"/>
            </method>
            <javadoc line="598">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="618">
                <declaration name="aux" type="char" line="620"/>
            </method>
            <javadoc line="623">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="652">
                <declaration name="aux" type="char" line="654"/>
            </method>
            <javadoc line="657">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="677"/>
            <javadoc line="680">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="709">
                <declaration name="aux" type="double" line="711"/>
            </method>
            <javadoc line="714">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="734"/>
            <javadoc line="737">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="766">
                <declaration name="aux" type="float" line="768"/>
            </method>
            <javadoc line="771">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="791">
                <declaration name="aux" type="int" line="793"/>
            </method>
            <javadoc line="796">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="825">
                <declaration name="aux" type="int" line="827"/>
            </method>
            <javadoc line="830">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="850">
                <declaration name="aux" type="long" line="852"/>
            </method>
            <javadoc line="855">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="884">
                <declaration name="aux" type="long" line="886"/>
            </method>
            <javadoc line="889">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSort" type="void" line="909">
                <declaration name="aux" type="short" line="911"/>
            </method>
            <javadoc line="914">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="mergeSort" type="void" line="943">
                <declaration name="aux" type="short" line="945"/>
            </method>
            <method name="mergeSort1" type="void" line="948">
                <comment line="949">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="949">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="949">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="949">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="949">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="949"/>
                <scope line="952"/>
                <declaration name="mid" type="int" line="960"/>
                <scope line="966"/>
                <scope line="972"/>
            </method>
            <method name="mergeSort1" type="void" line="979">
                <comment line="980">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="980">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="980">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="980">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="980">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="980"/>
                <scope line="983"/>
                <declaration name="mid" type="int" line="991"/>
                <scope line="997"/>
                <scope line="1003"/>
            </method>
            <method name="mergeSort1" type="void" line="1010">
                <comment line="1011">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1011">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1011">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1011">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1011">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1011"/>
                <scope line="1014"/>
                <declaration name="mid" type="int" line="1022"/>
                <scope line="1028"/>
                <scope line="1034"/>
            </method>
            <method name="mergeSort1" type="void" line="1041">
                <comment line="1042">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1042">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1042">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1042">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1042">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1042"/>
                <scope line="1045"/>
                <declaration name="mid" type="int" line="1053"/>
                <scope line="1059"/>
                <scope line="1065"/>
            </method>
            <method name="mergeSort1" type="void" line="1072">
                <comment line="1073">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1073">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1073">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1073">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1073">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1073"/>
                <scope line="1076"/>
                <declaration name="mid" type="int" line="1084"/>
                <scope line="1090"/>
                <scope line="1096"/>
            </method>
            <method name="mergeSort1" type="void" line="1103">
                <comment line="1104">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1104">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1104">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1104">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1104">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1104"/>
                <scope line="1107"/>
                <declaration name="mid" type="int" line="1115"/>
                <scope line="1121"/>
                <scope line="1127"/>
            </method>
            <method name="mergeSort1" type="void" line="1134">
                <comment line="1135">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1135">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1135">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1135">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1135">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1135"/>
                <scope line="1138"/>
                <declaration name="mid" type="int" line="1146"/>
                <scope line="1152"/>
                <scope line="1158"/>
            </method>
            <method name="mergeSort1" type="void" line="1165">
                <comment line="1166">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1166">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1166">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1166">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1166">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1166"/>
                <scope line="1169"/>
                <declaration name="mid" type="int" line="1177"/>
                <scope line="1183"/>
                <scope line="1189"/>
            </method>
            <method name="mergeSort1" type="void" line="1196">
                <comment line="1197">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1197">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1197">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1197">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1197">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1197"/>
                <scope line="1200"/>
                <declaration name="mid" type="int" line="1208"/>
                <scope line="1214"/>
                <scope line="1220"/>
            </method>
            <method name="mergeSort1" type="void" line="1227">
                <comment line="1228">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1228">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1228">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1228">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1228">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1228"/>
                <scope line="1231"/>
                <declaration name="mid" type="int" line="1239"/>
                <scope line="1245"/>
                <scope line="1251"/>
            </method>
            <method name="mergeSort1" type="void" line="1258">
                <comment line="1259">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1259">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1259">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1259">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1259">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1259"/>
                <scope line="1262"/>
                <declaration name="mid" type="int" line="1270"/>
                <scope line="1276"/>
                <scope line="1282"/>
            </method>
            <method name="mergeSort1" type="void" line="1289">
                <comment line="1290">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1290">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1290">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1290">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1290">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1290"/>
                <scope line="1293"/>
                <declaration name="mid" type="int" line="1301"/>
                <scope line="1307"/>
                <scope line="1313"/>
            </method>
            <method name="mergeSort1" type="void" line="1320">
                <comment line="1321">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1321">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1321">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1321">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1321">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1321"/>
                <scope line="1324"/>
                <declaration name="mid" type="int" line="1332"/>
                <scope line="1338"/>
                <scope line="1344"/>
            </method>
            <method name="mergeSort1" type="void" line="1351">
                <comment line="1352">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1352">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1352">
                    If list is already sorted, just copy from src to dest.  This is an                    
                </comment>
                <comment line="1352">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1352">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1352"/>
                <scope line="1355"/>
                <declaration name="mid" type="int" line="1363"/>
                <scope line="1369"/>
                <scope line="1375"/>
            </method>
            <method name="mergeSort2" type="void" line="1382">
                <comment line="1383">
                    The sort is done in three phases to avoid the expense of using                    
                </comment>
                <comment line="1383">
                    Preprocessing phase:  Move any NaN&apos;s to end of array, count the                    
                </comment>
                <comment line="1383">
                    Main sort phase: mergesort everything but the NaN&apos;s                    
                </comment>
                <comment line="1383">
                    Postprocessing phase: change 0.0&apos;s to -0.0&apos;s as required                    
                </comment>
                <declaration name="NEG_ZERO_BITS" type="long" line="1384"/>
                <declaration name="numNegZeros" type="int" line="1394"/>
                <declaration name="i" type="int" line="1395"/>
                <scope line="1396">
                    <scope line="1397"/>
                    <scope line="1400">
                        <scope line="1401"/>
                    </scope>
                </scope>
                <declaration name="aux" type="double" line="1410"/>
                <scope line="1414">
                    <declaration name="j" type="int" line="1415"/>
                    <scope line="1416"/>
                </scope>
            </method>
            <method name="mergeSort2" type="void" line="1425">
                <comment line="1426">
                    The sort is done in three phases to avoid the expense of using                    
                </comment>
                <comment line="1426">
                    Preprocessing phase:  Move any NaN&apos;s to end of array, count the                    
                </comment>
                <comment line="1426">
                    Main sort phase: mergesort everything but the NaN&apos;s                    
                </comment>
                <comment line="1426">
                    Postprocessing phase: change 0.0&apos;s to -0.0&apos;s as required                    
                </comment>
                <declaration name="NEG_ZERO_BITS" type="int" line="1427"/>
                <declaration name="numNegZeros" type="int" line="1437"/>
                <declaration name="i" type="int" line="1438"/>
                <scope line="1439">
                    <scope line="1440"/>
                    <scope line="1443">
                        <scope line="1444"/>
                    </scope>
                </scope>
                <declaration name="aux" type="float" line="1453"/>
                <scope line="1457">
                    <declaration name="j" type="int" line="1458"/>
                    <scope line="1459"/>
                </scope>
            </method>
            <javadoc line="1468">
                Sorts the specified range of the specified array of elements.
                 * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="mergeSortInPlace" type="void" line="1488">
                <comment line="1489">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1489">
                    Recursively sort halves                    
                </comment>
                <comment line="1489">
                    If list is already sorted, nothing left to do.  This is an                    
                </comment>
                <comment line="1489">
                    optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1489">
                    Merge sorted halves                    
                </comment>
                <comment line="1489">
                    jal.INT.Sorting.inplace_merge(a, fromIndex, mid, toIndex);                    
                </comment>
                <declaration name="length" type="int" line="1490"/>
                <scope line="1493">
                    <scope line="1494">
                        <scope line="1495">
                            <declaration name="tmp" type="int" line="1496"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="mid" type="int" line="1503"/>
            </method>
            <javadoc line="1515">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1542"/>
            <javadoc line="1546">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1573"/>
            <javadoc line="1577">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1604"/>
            <javadoc line="1608">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1635"/>
            <javadoc line="1639">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1666"/>
            <javadoc line="1670">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1697"/>
            <javadoc line="1701">
                Sorts the specified range of the receiver into
                 * ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of its
                 * elements.  All elements in this range must implement the
                 * &lt;tt&gt;Comparable&lt;/tt&gt; interface.  Furthermore, all elements in this range
                 * must be &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt;
                 * must not throw a &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements
                 * &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in the array).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort, adapted from Jon
                 * L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a Sort Function&quot;,
                 * Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November
                 * 1993).  This algorithm offers n*log(n) performance on many data sets
                 * that cause other quicksorts to degrade to quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
            </javadoc>
            <method name="quickSort" type="void" line="1718"/>
            <javadoc line="1721">
                Sorts the specified range of the receiver into
                 * ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of its
                 * elements.  All elements in this range must implement the
                 * &lt;tt&gt;Comparable&lt;/tt&gt; interface.  Furthermore, all elements in this range
                 * must be &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt;
                 * must not throw a &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements
                 * &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in the array).&lt;p&gt;                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
            </javadoc>
            <method name="quickSort" type="void" line="1738"/>
            <javadoc line="1742">
                Sorts the specified range of the specified array according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the receiver.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1769"/>
            <javadoc line="1773">
                Sorts the specified array according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * The sorting algorithm is a tuned quicksort,
                 * adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                 * Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                 * P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
                 * performance on many data sets that cause other quicksorts to degrade to
                 * quadratic performance.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the receiver.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1797"/>
            <javadoc line="1800">
                Sorts the specified range of the specified array of elements according
                 * to the order induced by the specified comparator.  All elements in the
                 * range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                 * (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                 * &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                 * not be reordered as a result of the sort.&lt;p&gt;
                 * The sorting algorithm is a modified mergesort (in which the merge is
                 * omitted if the highest element in the low sublist is less than the
                 * lowest element in the high sublist).  This algorithm offers guaranteed
                 * n*log(n) performance, and can approach linear performance on nearly
                 * sorted lists.                
                <@param>
                    m a the array to be sorted.                    
                </@param>
                <@param>
                    m fromIndex the index of the first element (inclusive) to be
                     * sorted.                    
                </@param>
                <@param>
                    m toIndex the index of the last element (exclusive) to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order of the array.                    
                </@param>
                <@throws>
                    s ClassCastException if the array contains elements that are not
                     * <i>mutually comparable</i> using the specified comparator.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </@throws>
                <@throws>
                    s ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                     * <tt>toIndex &gt; a.length</tt>                    
                </@throws>
                <@see>
                    e Comparator                    
                </@see>
            </javadoc>
            <method name="quickSort" type="void" line="1829"/>
            <javadoc line="1833">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="1836">
                <comment line="1837">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1837">
                    Choose a partition element, v                    
                </comment>
                <comment line="1837">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="1837">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="1837">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="1837">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="1838"/>
                <declaration name="m" type="int" line="1846"/>
                <scope line="1847">
                    <declaration name="l" type="int" line="1848"/>
                    <declaration name="n" type="int" line="1849"/>
                    <scope line="1850">
                        <declaration name="s" type="int" line="1851"/>
                    </scope>
                </scope>
                <declaration name="v" type="byte" line="1858"/>
                <declaration name="a" type="int" line="1861"/>
                <scope line="1862">
                    <declaration name="comparison" type="int" line="1863"/>
                    <scope line="1864"/>
                    <scope line="1869"/>
                </scope>
                <declaration name="s" type="int" line="1880"/>
            </method>
            <javadoc line="1890">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="1893">
                <comment line="1894">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1894">
                    Choose a partition element, v                    
                </comment>
                <comment line="1894">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="1894">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="1894">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="1894">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="1895"/>
                <declaration name="m" type="int" line="1903"/>
                <scope line="1904">
                    <declaration name="l" type="int" line="1905"/>
                    <declaration name="n" type="int" line="1906"/>
                    <scope line="1907">
                        <declaration name="s" type="int" line="1908"/>
                    </scope>
                </scope>
                <declaration name="v" type="char" line="1915"/>
                <declaration name="a" type="int" line="1918"/>
                <scope line="1919">
                    <declaration name="comparison" type="int" line="1920"/>
                    <scope line="1921"/>
                    <scope line="1926"/>
                </scope>
                <declaration name="s" type="int" line="1937"/>
            </method>
            <javadoc line="1947">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="1950">
                <comment line="1951">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1951">
                    Choose a partition element, v                    
                </comment>
                <comment line="1951">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="1951">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="1951">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="1951">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="1952"/>
                <declaration name="m" type="int" line="1960"/>
                <scope line="1961">
                    <declaration name="l" type="int" line="1962"/>
                    <declaration name="n" type="int" line="1963"/>
                    <scope line="1964">
                        <declaration name="s" type="int" line="1965"/>
                    </scope>
                </scope>
                <declaration name="v" type="double" line="1972"/>
                <declaration name="a" type="int" line="1975"/>
                <scope line="1976">
                    <declaration name="comparison" type="int" line="1977"/>
                    <scope line="1978"/>
                    <scope line="1983"/>
                </scope>
                <declaration name="s" type="int" line="1994"/>
            </method>
            <javadoc line="2004">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2007">
                <comment line="2008">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2008">
                    Choose a partition element, v                    
                </comment>
                <comment line="2008">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="2008">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2008">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2008">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2009"/>
                <declaration name="m" type="int" line="2017"/>
                <scope line="2018">
                    <declaration name="l" type="int" line="2019"/>
                    <declaration name="n" type="int" line="2020"/>
                    <scope line="2021">
                        <declaration name="s" type="int" line="2022"/>
                    </scope>
                </scope>
                <declaration name="v" type="float" line="2029"/>
                <declaration name="a" type="int" line="2032"/>
                <scope line="2033">
                    <declaration name="comparison" type="int" line="2034"/>
                    <scope line="2035"/>
                    <scope line="2040"/>
                </scope>
                <declaration name="s" type="int" line="2051"/>
            </method>
            <javadoc line="2061">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2064">
                <comment line="2065">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2065">
                    Choose a partition element, v                    
                </comment>
                <comment line="2065">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="2065">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2065">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2065">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2066"/>
                <declaration name="m" type="int" line="2074"/>
                <scope line="2075">
                    <declaration name="l" type="int" line="2076"/>
                    <declaration name="n" type="int" line="2077"/>
                    <scope line="2078">
                        <declaration name="s" type="int" line="2079"/>
                    </scope>
                </scope>
                <declaration name="v" type="int" line="2086"/>
                <declaration name="a" type="int" line="2089"/>
                <scope line="2090">
                    <declaration name="comparison" type="int" line="2091"/>
                    <scope line="2092"/>
                    <scope line="2097"/>
                </scope>
                <declaration name="s" type="int" line="2108"/>
            </method>
            <javadoc line="2118">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2121">
                <comment line="2122">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2122">
                    Choose a partition element, v                    
                </comment>
                <comment line="2122">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="2122">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2122">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2122">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2123"/>
                <declaration name="m" type="int" line="2131"/>
                <scope line="2132">
                    <declaration name="l" type="int" line="2133"/>
                    <declaration name="n" type="int" line="2134"/>
                    <scope line="2135">
                        <declaration name="s" type="int" line="2136"/>
                    </scope>
                </scope>
                <declaration name="v" type="long" line="2143"/>
                <declaration name="a" type="int" line="2146"/>
                <scope line="2147">
                    <declaration name="comparison" type="int" line="2148"/>
                    <scope line="2149"/>
                    <scope line="2154"/>
                </scope>
                <declaration name="s" type="int" line="2165"/>
            </method>
            <javadoc line="2175">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2178">
                <comment line="2179">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2179">
                    Choose a partition element, v                    
                </comment>
                <comment line="2179">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="2179">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2179">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2179">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2180"/>
                <declaration name="m" type="int" line="2188"/>
                <scope line="2189">
                    <declaration name="l" type="int" line="2190"/>
                    <declaration name="n" type="int" line="2191"/>
                    <scope line="2192">
                        <declaration name="s" type="int" line="2193"/>
                    </scope>
                </scope>
                <declaration name="v" type="Comparable" line="2200"/>
                <declaration name="a" type="int" line="2203"/>
                <scope line="2204">
                    <declaration name="comparison" type="int" line="2205"/>
                    <scope line="2206"/>
                    <scope line="2211"/>
                </scope>
                <declaration name="s" type="int" line="2222"/>
            </method>
            <javadoc line="2232">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2235">
                <comment line="2236">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2236">
                    Choose a partition element, v                    
                </comment>
                <comment line="2236">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="2236">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2236">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2236">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2237"/>
                <declaration name="m" type="int" line="2245"/>
                <scope line="2246">
                    <declaration name="l" type="int" line="2247"/>
                    <declaration name="n" type="int" line="2248"/>
                    <scope line="2249">
                        <declaration name="s" type="int" line="2250"/>
                    </scope>
                </scope>
                <declaration name="v" type="Object" line="2257"/>
                <declaration name="a" type="int" line="2260"/>
                <scope line="2261">
                    <declaration name="comparison" type="int" line="2262"/>
                    <scope line="2263"/>
                    <scope line="2268"/>
                </scope>
                <declaration name="s" type="int" line="2279"/>
            </method>
            <javadoc line="2289">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2292">
                <comment line="2293">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2293">
                    Choose a partition element, v                    
                </comment>
                <comment line="2293">
                    t m = off + len/2;       // Small arrays, middle element                    
                </comment>
                <comment line="2293">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2293">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2293">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2294"/>
                <declaration name="m" type="int" line="2302"/>
                <scope line="2303">
                    <declaration name="l" type="int" line="2304"/>
                    <declaration name="n" type="int" line="2305"/>
                    <scope line="2306">
                        <declaration name="s" type="int" line="2307"/>
                    </scope>
                </scope>
                <declaration name="v" type="short" line="2314"/>
                <declaration name="a" type="int" line="2317"/>
                <scope line="2318">
                    <declaration name="comparison" type="int" line="2319"/>
                    <scope line="2320"/>
                    <scope line="2325"/>
                </scope>
                <declaration name="s" type="int" line="2336"/>
            </method>
            <javadoc line="2346">
                Check that fromIndex and toIndex are in range, and throw an
                 * appropriate exception if they aren&apos;t.                
            </javadoc>
            <method name="rangeCheck" type="void" line="2350"/>
            <javadoc line="2359">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2362">
                <declaration name="t" type="byte" line="2363"/>
            </method>
            <javadoc line="2367">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2370">
                <declaration name="t" type="char" line="2371"/>
            </method>
            <javadoc line="2375">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2378">
                <declaration name="t" type="double" line="2379"/>
            </method>
            <javadoc line="2383">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2386">
                <declaration name="t" type="float" line="2387"/>
            </method>
            <javadoc line="2391">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2394">
                <declaration name="t" type="int" line="2395"/>
            </method>
            <javadoc line="2399">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2402">
                <declaration name="t" type="long" line="2403"/>
            </method>
            <javadoc line="2407">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2410">
                <declaration name="t" type="Object" line="2411"/>
            </method>
            <javadoc line="2415">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2418">
                <declaration name="t" type="short" line="2419"/>
            </method>
            <javadoc line="2423">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2426"/>
            <javadoc line="2430">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2433"/>
            <javadoc line="2437">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2440"/>
            <javadoc line="2444">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2447"/>
            <javadoc line="2451">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2454"/>
            <javadoc line="2458">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2461"/>
            <javadoc line="2465">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2468"/>
            <javadoc line="2472">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2475"/>
        </class>
    </source>