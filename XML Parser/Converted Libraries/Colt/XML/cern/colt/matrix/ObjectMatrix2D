<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix">
        <import package="cern.colt.list.IntArrayList"/>
        <import package="cern.colt.list.ObjectArrayList"/>
        <import package="cern.colt.matrix.impl.AbstractMatrix2D"/>
        <class name="ObjectMatrix2D" extends="AbstractMatrix2D" line="14">
            <javadoc line="14">
                Abstract base class for 2-d matrices holding &lt;tt&gt;Object&lt;/tt&gt; elements.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * A matrix has a number of rows and columns, which are assigned upon instance construction - The matrix&apos;s size is then &lt;tt&gt;rows()*columns()&lt;/tt&gt;.
                 * Elements are accessed via &lt;tt&gt;[row,column]&lt;/tt&gt; coordinates.
                 * Legal coordinates range from &lt;tt&gt;[0,0]&lt;/tt&gt; to &lt;tt&gt;[rows()-1,columns()-1]&lt;/tt&gt;.
                 * Any attempt to access an element at a coordinate &lt;tt&gt;column&amp;lt;0 || column&amp;gt;=columns() || row&amp;lt;0 || row&amp;gt;=rows()&lt;/tt&gt; will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Note&lt;/b&gt; that this implementation is not synchronized.                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <javadoc line="29">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="ObjectMatrix2D" type="constructor" line="32"/>
            <javadoc line="33">
                Applies a function to each cell and aggregates the results.
                 * Returns a value &lt;tt&gt;v&lt;/tt&gt; such that &lt;tt&gt;v==a(size())&lt;/tt&gt; where &lt;tt&gt;a(i) == aggr( a(i-1), f(get(row,column)) )&lt;/tt&gt; and terminators are &lt;tt&gt;a(1) == f(get(0,0)), a(0)==null&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
                 * 2 x 2 matrix
                 * 0 1
                 * 2 3
                 * // Sum( x[row,col]*x[row,col] ) 
                 * matrix.aggregate(F.plus,F.square);
                 * --&gt; 14
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value.                    
                </@param>
                <@param>
                    m f a function transforming the current cell value.                    
                </@param>
                <@return>
                    n the aggregated measure.                    
                </@return>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="aggregate" type="Object" line="55">
                <comment line="56">
                    t d = 1; // last cell already done                    
                </comment>
                <declaration name="a" type="Object" line="57"/>
                <declaration name="d" type="int" line="58"/>
                <scope line="59">
                    <scope line="60"/>
                </scope>
            </method>
            <javadoc line="67">
                Applies a function to each corresponding cell of two matrices and aggregates the results.
                 * Returns a value &lt;tt&gt;v&lt;/tt&gt; such that &lt;tt&gt;v==a(size())&lt;/tt&gt; where &lt;tt&gt;a(i) == aggr( a(i-1), f(get(row,column),other.get(row,column)) )&lt;/tt&gt; and terminators are &lt;tt&gt;a(1) == f(get(0,0),other.get(0,0)), a(0)==null&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
                 * x == 2 x 2 matrix
                 * 0 1
                 * 2 3
                 * y == 2 x 2 matrix
                 * 0 1
                 * 2 3
                 * // Sum( x[row,col] * y[row,col] ) 
                 * x.aggregate(y, F.plus, F.mult);
                 * --&gt; 14
                 * // Sum( (x[row,col] + y[row,col])^2 )
                 * x.aggregate(y, F.plus, F.chain(F.square,F.plus));
                 * --&gt; 56
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values.                    
                </@param>
                <@param>
                    m f a function transforming the current cell values.                    
                </@param>
                <@return>
                    n the aggregated measure.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>                    
                </@throws>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="aggregate" type="Object" line="98">
                <comment line="99">
                    t d = 1; // last cell already done                    
                </comment>
                <declaration name="a" type="Object" line="101"/>
                <declaration name="d" type="int" line="102"/>
                <scope line="103">
                    <scope line="104"/>
                </scope>
            </method>
            <javadoc line="111">
                Sets all cells to the state specified by &lt;tt&gt;values&lt;/tt&gt;.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and have exactly the same number of rows and columns as the receiver.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values the values to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="122">
                <scope line="124">
                    <declaration name="currentRow" type="Object[]" line="125"/>
                    <scope line="127"/>
                </scope>
            </method>
            <javadoc line="133">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * matrix = 2 x 2 matrix 
                 * 0.5 1.5      
                 * 2.5 3.5
                 * // change each cell to its sine
                 * matrix.assign(cern.jet.math.Functions.sin);
                 * --&gt;
                 * 2 x 2 matrix
                 * 0.479426  0.997495 
                 * 0.598472 -0.350783
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m function a function object taking as argument the current cell's value.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="155">
                <scope line="156">
                    <scope line="157"/>
                </scope>
            </method>
            <javadoc line="163">
                Replaces all cell values of the receiver with the values of another matrix.
                 * Both matrices must have the same number of rows and columns.
                 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces &lt;i&gt;as if&lt;/i&gt; using an intermediate auxiliary deep copy of &lt;tt&gt;other&lt;/tt&gt;.                
                <@param>
                    m other   the source matrix to copy from (may be identical to the receiver).                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>                    
                </@throws>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="172">
                <scope line="177">
                    <scope line="178"/>
                </scope>
            </method>
            <javadoc line="184">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col],y[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // assign x[row,col] = x[row,col]&lt;sup&gt;y[row,col]&lt;/sup&gt;
                 * m1 = 2 x 2 matrix 
                 * 0 1 
                 * 2 3
                 * m2 = 2 x 2 matrix 
                 * 0 2 
                 * 4 6
                 * m1.assign(m2, cern.jet.math.Functions.pow);
                 * --&gt;
                 * m1 == 2 x 2 matrix
                 * 1   1 
                 * 16 729
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m y the secondary matrix to operate on.                    
                </@param>
                <@param>
                    m function a function object taking as first argument the current cell's value of <tt>this</tt>,
                     * and as second argument the current cell's value of <tt>y</tt>,                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>                    
                </@throws>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="213">
                <scope line="215">
                    <scope line="216"/>
                </scope>
            </method>
            <javadoc line="222">
                Sets all cells to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <@param>
                    m value the value to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="227">
                <scope line="228">
                    <scope line="229"/>
                </scope>
            </method>
            <javadoc line="235">
                Returns the number of cells having non-zero values; ignores tolerance.                
            </javadoc>
            <method name="cardinality" type="int" line="238">
                <declaration name="cardinality" type="int" line="239"/>
                <scope line="240">
                    <scope line="241"/>
                </scope>
            </method>
            <javadoc line="247">
                Constructs and returns a deep copy of the receiver.
                 * &lt;p&gt;
                 * &lt;b&gt;Note that the returned matrix is an independent deep copy.&lt;/b&gt;
                 * The returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa.                
                <@return>
                    n  a deep copy of the receiver.                    
                </@return>
            </javadoc>
            <method name="copy" type="ObjectMatrix2D" line="255"/>
            <javadoc line="258">
                Compares the specified Object with the receiver for equality.
                 * Equivalent to &lt;tt&gt;equals(otherObj,true)&lt;/tt&gt;.                
                <@param>
                    m otherObj the Object to be compared for equality with the receiver.                    
                </@param>
                <@return>
                    n true if the specified Object is equal to the receiver.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="265">
                <comment line="266">
                    blic boolean equals(Object otherObj) { //delta                    
                </comment>
            </method>
            <javadoc line="268">
                Compares the specified Object with the receiver for equality.
                 * Returns true if and only if the specified Object is also at least an ObjectMatrix2D, both matrices have the
                 * same size, and all corresponding pairs of cells in the two matrices are the same.
                 * In other words, two matrices are defined to be equal if they contain the
                 * same cell values in the same order.
                 * Tests elements for equality or identity as specified by &lt;tt&gt;testForEquality&lt;/tt&gt;.
                 * When testing for equality, two elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; are &lt;i&gt;equal&lt;/i&gt; if &lt;tt&gt;(e1==null ? e2==null :
                 * e1.equals(e2))&lt;/tt&gt;.)                
                <@param>
                    m otherObj the Object to be compared for equality with the receiver.                    
                </@param>
                <@param>
                    m testForEquality if true -> tests for equality, otherwise for identity.                    
                </@param>
                <@return>
                    n true if the specified Object is equal to the receiver.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="283">
                <comment line="284">
                    blic boolean equals(Object otherObj, boolean testForEquality) { //delta                    
                </comment>
                <scope line="284"/>
                <declaration name="other" type="ObjectMatrix2D" line="287"/>
                <scope line="291">
                    <scope line="292">
                        <scope line="293"/>
                    </scope>
                </scope>
                <scope line="298">
                    <scope line="299">
                        <scope line="300"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="309">
                Returns the matrix cell value at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@return>
                    n    the value of the specified cell.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt>                    
                </@throws>
            </javadoc>
            <method name="get" type="Object" line="317"/>
            <javadoc line="321">
                Returns the content of this matrix if it is a wrapper; or &lt;tt&gt;this&lt;/tt&gt; otherwise.
                 * Override this method in wrappers.                
            </javadoc>
            <method name="getContent" type="ObjectMatrix2D" line="325"/>
            <javadoc line="328">
                Fills the coordinates and values of cells having non-zero values into the specified lists.
                 * Fills into the lists, starting at index 0.
                 * After this call returns the specified lists all have a new size, the number of non-zero values.
                 * &lt;p&gt;
                 * In general, fill order is &lt;i&gt;unspecified&lt;/i&gt;.
                 * This implementation fills like &lt;tt&gt;for (row = 0..rows-1) for (column = 0..columns-1) do ... &lt;/tt&gt;.
                 * However, subclasses are free to us any other order, even an order that may change over time as cell values are changed.
                 * (Of course, result lists indexes are guaranteed to correspond to the same cell).
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;br&gt;
                 * &lt;pre&gt;
                 * 2 x 3 matrix:
                 * 0, 0, 8
                 * 0, 7, 0
                 * --&gt;
                 * rowList    = (0,1)
                 * columnList = (2,1)
                 * valueList  = (8,7)
                 * &lt;/pre&gt;
                 * In other words, &lt;tt&gt;get(0,2)==8, get(1,1)==7&lt;/tt&gt;.                
                <@param>
                    m rowList the list to be filled with row indexes, can have any size.                    
                </@param>
                <@param>
                    m columnList the list to be filled with column indexes, can have any size.                    
                </@param>
                <@param>
                    m valueList the list to be filled with values, can have any size.                    
                </@param>
            </javadoc>
            <method name="getNonZeros" type="void" line="355">
                <declaration name="r" type="int" line="359"/>
                <declaration name="c" type="int" line="360"/>
                <scope line="361">
                    <scope line="362">
                        <declaration name="value" type="Object" line="363"/>
                        <scope line="364"/>
                    </scope>
                </scope>
            </method>
            <method name="getQuick" type="Object" line="372"/>
            <javadoc line="372">
                Returns the matrix cell value at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt;.
                 * &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@return>
                    n    the value at the specified coordinate.                    
                </@return>
            </javadoc>
            <javadoc line="384">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share at least one identical cell.                
            </javadoc>
            <method name="haveSharedCells" type="boolean" line="387"/>
            <javadoc line="392">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share at least one identical cell.                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="395"/>
            <javadoc line="398">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the same number of rows and columns.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like" type="ObjectMatrix2D" line="406"/>
            <method name="like" type="ObjectMatrix2D" line="409"/>
            <javadoc line="409">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified number of rows and columns.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="ObjectMatrix1D" line="420"/>
            <javadoc line="420">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, entirelly independent of the receiver.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="ObjectMatrix1D" line="429"/>
            <javadoc line="429">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, sharing the same cells.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@param>
                    m zero the index of the first element.                    
                </@param>
                <@param>
                    m stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <javadoc line="440">
                Sets the matrix cell at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt; to the specified value.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows()</tt>                    
                </@throws>
            </javadoc>
            <method name="set" type="void" line="448"/>
            <method name="setQuick" type="void" line="452"/>
            <javadoc line="452">
                Sets the matrix cell at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt; to the specified value.
                 * &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
            </javadoc>
            <javadoc line="464">
                Constructs and returns a 2-dimensional array containing the cell values.
                 * The returned array &lt;tt&gt;values&lt;/tt&gt; has the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and has the same number of rows and columns as the receiver.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@return>
                    n an array filled with the values of the cells.                    
                </@return>
            </javadoc>
            <method name="toArray" type="Object[][]" line="473">
                <declaration name="values" type="Object[][]" line="474"/>
                <scope line="475">
                    <declaration name="currentRow" type="Object[]" line="476"/>
                    <scope line="477"/>
                </scope>
            </method>
            <javadoc line="483">
                Returns a string representation using default formatting.                
                <@see>
                    e cern.colt.matrix.objectalgo.Formatter                    
                </@see>
            </javadoc>
            <method name="toString" type="String" line="487"/>
            <javadoc line="490">
                Constructs and returns a new view equal to the receiver.
                 * The view is a shallow clone. Calls &lt;code&gt;clone()&lt;/code&gt; and casts the result.
                 * &lt;p&gt;
                 * &lt;b&gt;Note that the view is not a deep copy.&lt;/b&gt;
                 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
                 * &lt;p&gt;
                 * Use {@link #copy()} to construct an independent deep copy rather than a new view.                
                <@return>
                    n  a new view of the receiver.                    
                </@return>
            </javadoc>
            <method name="view" type="ObjectMatrix2D" line="501"/>
            <javadoc line="504">
                Constructs and returns a new &lt;i&gt;slice view&lt;/i&gt; representing the rows of the given column.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To obtain a slice view on subranges, construct a sub-ranging view (&lt;tt&gt;viewPart(...)&lt;/tt&gt;), then apply this method to the sub-range view.
                 * &lt;p&gt; 
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;td&gt;viewColumn(0) ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;Matrix1D of size 2:&lt;br&gt;
                 * 1, 4&lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@param>
                    m column the column to fix.                    
                </@param>
                <@return>
                    n a new slice view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.                    
                </@throws>
                <@see>
                    e #viewRow(int)                    
                </@see>
            </javadoc>
            <method name="viewColumn" type="ObjectMatrix1D" line="526">
                <declaration name="viewSize" type="int" line="528"/>
                <declaration name="viewZero" type="int" line="529"/>
                <declaration name="viewStride" type="int" line="530"/>
            </method>
            <javadoc line="533">
                Constructs and returns a new &lt;i&gt;flip view&lt;/i&gt; along the column axis.
                 * What used to be column &lt;tt&gt;0&lt;/tt&gt; is now column &lt;tt&gt;columns()-1&lt;/tt&gt;, ..., what used to be column &lt;tt&gt;columns()-1&lt;/tt&gt; is now column &lt;tt&gt;0&lt;/tt&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * &lt;p&gt; 
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;td&gt;columnFlip ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix:&lt;br&gt;
                 * 3, 2, 1 &lt;br&gt;
                 * 6, 5, 4&lt;/td&gt;
                 * &lt;td&gt;columnFlip ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@return>
                    n a new flip view.                    
                </@return>
                <@see>
                    e #viewRowFlip()                    
                </@see>
            </javadoc>
            <method name="viewColumnFlip" type="ObjectMatrix2D" line="558"/>
            <javadoc line="561">
                Constructs and returns a new &lt;i&gt;dice (transposition) view&lt;/i&gt;; Swaps axes; example: 3 x 4 matrix --&gt; 4 x 3 matrix.
                 * The view has both dimensions exchanged; what used to be columns become rows, what used to be rows become columns.
                 * In other words: &lt;tt&gt;view.get(row,column)==this.get(column,row)&lt;/tt&gt;.
                 * This is a zero-copy transposition, taking O(1), i.e. constant time.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
                 * Use idioms like &lt;tt&gt;result = viewDice(A).copy()&lt;/tt&gt; to generate an independent transposed matrix.
                 * &lt;p&gt; 
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;td&gt;transpose ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;3 x 2 matrix:&lt;br&gt;
                 * 1, 4 &lt;br&gt;
                 * 2, 5 &lt;br&gt;
                 * 3, 6&lt;/td&gt;
                 * &lt;td&gt;transpose ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@return>
                    n a new dice view.                    
                </@return>
            </javadoc>
            <method name="viewDice" type="ObjectMatrix2D" line="589"/>
            <javadoc line="592">
                Constructs and returns a new &lt;i&gt;sub-range view&lt;/i&gt; that is a &lt;tt&gt;height x width&lt;/tt&gt; sub matrix starting at &lt;tt&gt;[row,column]&lt;/tt&gt;.
                 * Operations on the returned view can only be applied to the restricted range.
                 * Any attempt to access coordinates not contained in the view will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Note that the view is really just a range restriction:&lt;/b&gt; 
                 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
                 * &lt;p&gt;
                 * The view contains the cells from &lt;tt&gt;[row,column]&lt;/tt&gt; to &lt;tt&gt;[row+height-1,column+width-1]&lt;/tt&gt;, all inclusive.
                 * and has &lt;tt&gt;view.rows() == height; view.columns() == width;&lt;/tt&gt;.
                 * A view&apos;s legal coordinates are again zero based, as usual.
                 * In other words, legal coordinates of the view range from &lt;tt&gt;[0,0]&lt;/tt&gt; to &lt;tt&gt;[view.rows()-1==height-1,view.columns()-1==width-1]&lt;/tt&gt;.
                 * As usual, any attempt to access a cell at a coordinate &lt;tt&gt;column&amp;lt;0 || column&amp;gt;=view.columns() || row&amp;lt;0 || row&amp;gt;=view.rows()&lt;/tt&gt; will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.                
                <@param>
                    m row   The index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   The index of the column-coordinate.                    
                </@param>
                <@param>
                    m height   The height of the box.                    
                </@param>
                <@param>
                    m width   The width of the box.                    
                </@param>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column<0 || width<0 || column+width>columns() || row<0 || height<0 || row+height>rows()</tt>                    
                </@throws>
                <@return>
                    n the new view.                    
                </@return>
            </javadoc>
            <method name="viewPart" type="ObjectMatrix2D" line="615"/>
            <javadoc line="618">
                Constructs and returns a new &lt;i&gt;slice view&lt;/i&gt; representing the columns of the given row.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To obtain a slice view on subranges, construct a sub-ranging view (&lt;tt&gt;viewPart(...)&lt;/tt&gt;), then apply this method to the sub-range view.
                 * &lt;p&gt; 
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;td&gt;viewRow(0) ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;Matrix1D of size 3:&lt;br&gt;
                 * 1, 2, 3&lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@param>
                    m row the row to fix.                    
                </@param>
                <@return>
                    n a new slice view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>row < 0 || row >= rows()</tt>.                    
                </@throws>
                <@see>
                    e #viewColumn(int)                    
                </@see>
            </javadoc>
            <method name="viewRow" type="ObjectMatrix1D" line="640">
                <declaration name="viewSize" type="int" line="642"/>
                <declaration name="viewZero" type="int" line="643"/>
                <declaration name="viewStride" type="int" line="644"/>
            </method>
            <javadoc line="647">
                Constructs and returns a new &lt;i&gt;flip view&lt;/i&gt; along the row axis.
                 * What used to be row &lt;tt&gt;0&lt;/tt&gt; is now row &lt;tt&gt;rows()-1&lt;/tt&gt;, ..., what used to be row &lt;tt&gt;rows()-1&lt;/tt&gt; is now row &lt;tt&gt;0&lt;/tt&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * &lt;p&gt; 
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;td&gt;rowFlip ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix:&lt;br&gt;
                 * 4, 5, 6 &lt;br&gt;
                 * 1, 2, 3&lt;/td&gt;
                 * &lt;td&gt;rowFlip ==&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                 * 1, 2, 3&lt;br&gt;
                 * 4, 5, 6 &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@return>
                    n a new flip view.                    
                </@return>
                <@see>
                    e #viewColumnFlip()                    
                </@see>
            </javadoc>
            <method name="viewRowFlip" type="ObjectMatrix2D" line="672"/>
            <javadoc line="675">
                Constructs and returns a new &lt;i&gt;selection view&lt;/i&gt; that is a matrix holding the indicated cells.
                 * There holds &lt;tt&gt;view.rows() == rowIndexes.length, view.columns() == columnIndexes.length&lt;/tt&gt; and &lt;tt&gt;view.get(i,j) == this.get(rowIndexes[i],columnIndexes[j])&lt;/tt&gt;.
                 * Indexes can occur multiple times and can be in arbitrary order.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * this = 2 x 3 matrix:
                 * 1, 2, 3
                 * 4, 5, 6
                 * rowIndexes     = (0,1)
                 * columnIndexes  = (1,0,1,0)
                 * --&gt;
                 * view = 2 x 4 matrix:
                 * 2, 1, 2, 1
                 * 5, 4, 5, 4
                 * &lt;/pre&gt;
                 * Note that modifying the index arguments after this call has returned has no effect on the view.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
                 * &lt;p&gt;
                 * To indicate &quot;all&quot; rows or &quot;all columns&quot;, simply set the respective parameter                
                <@param>
                    m rowIndexes   The rows of the cells that shall be visible in the new view. To indicate that <i>all</i> rows shall be visible, simply set this parameter to <tt>null</tt>.                    
                </@param>
                <@param>
                    m columnIndexes   The columns of the cells that shall be visible in the new view. To indicate that <i>all</i> columns shall be visible, simply set this parameter to <tt>null</tt>.                    
                </@param>
                <@return>
                    n the new view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>!(0 <= rowIndexes[i] < rows())</tt> for any <tt>i=0..rowIndexes.length()-1</tt>.                    
                </@throws>
                <@throws>
                    s IndexOutOfBoundsException if <tt>!(0 <= columnIndexes[i] < columns())</tt> for any <tt>i=0..columnIndexes.length()-1</tt>.                    
                </@throws>
            </javadoc>
            <method name="viewSelection" type="ObjectMatrix2D" line="702">
                <comment line="703">
                    check for &quot;all&quot;                    
                </comment>
                <scope line="704"/>
                <scope line="708"/>
                <declaration name="rowOffsets" type="int[]" line="715"/>
                <declaration name="columnOffsets" type="int[]" line="716"/>
                <scope line="717"/>
                <scope line="720"/>
            </method>
            <javadoc line="725">
                Constructs and returns a new &lt;i&gt;selection view&lt;/i&gt; that is a matrix holding all &lt;b&gt;rows&lt;/b&gt; matching the given condition.
                 * Applies the condition to each row and takes only those row where &lt;tt&gt;condition.apply(viewRow(i))&lt;/tt&gt; yields &lt;tt&gt;true&lt;/tt&gt;.
                 * To match columns, use a dice view.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;br&gt;
                 * &lt;pre&gt;
                 * // extract and view all rows which have a value &lt; threshold in the first column (representing &quot;age&quot;)
                 * final Object threshold = 16;
                 * matrix.viewSelection( 
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;new ObjectMatrix1DProcedure() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public final boolean apply(ObjectMatrix1D m) { return m.get(0) &lt; threshold; }
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * );
                 * // extract and view all rows with RMS &lt; threshold
                 * // The RMS (Root-Mean-Square) is a measure of the average &quot;size&quot; of the elements of a data sequence.
                 * matrix = 0 1 2 3
                 * final Object threshold = 0.5;
                 * matrix.viewSelection( 
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;new ObjectMatrix1DProcedure() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public final boolean apply(ObjectMatrix1D m) { return Math.sqrt(m.aggregate(F.plus,F.square) / m.size()) &lt; threshold; }
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * );
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.                
                <@param>
                    m condition The condition to be matched.                    
                </@param>
                <@return>
                    n the new view.                    
                </@return>
            </javadoc>
            <method name="viewSelection" type="ObjectMatrix2D" line="757">
                <comment line="758">
                    turn viewSelection(matches.elements(), null); // take all columns                    
                </comment>
                <declaration name="matches" type="IntArrayList" line="758"/>
                <scope line="759"/>
            </method>
            <method name="viewSelectionLike" type="ObjectMatrix2D" line="766"/>
            <javadoc line="766">
                Construct and returns a new selection view.                
                <@param>
                    m rowOffsets the offsets of the visible elements.                    
                </@param>
                <@param>
                    m columnOffsets the offsets of the visible elements.                    
                </@param>
                <@return>
                    n  a new view.                    
                </@return>
            </javadoc>
            <javadoc line="774">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given column.
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;.
                 * For further information, see {@link cern.colt.matrix.objectalgo.Sorting#sort(ObjectMatrix2D,int)}.
                 * For more advanced sorting functionality, see {@link cern.colt.matrix.objectalgo.Sorting}.                
                <@return>
                    n a new sorted vector (matrix) view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="viewSorted" type="ObjectMatrix2D" line="782"/>
            <javadoc line="785">
                Constructs and returns a new &lt;i&gt;stride view&lt;/i&gt; which is a sub matrix consisting of every i-th cell.
                 * More specifically, the view has &lt;tt&gt;this.rows()/rowStride&lt;/tt&gt; rows and &lt;tt&gt;this.columns()/columnStride&lt;/tt&gt; columns holding cells &lt;tt&gt;this.get(i*rowStride,j*columnStride)&lt;/tt&gt; for all &lt;tt&gt;i = 0..rows()/rowStride - 1, j = 0..columns()/columnStride - 1&lt;/tt&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.                
                <@param>
                    m rowStride the row step factor.                    
                </@param>
                <@param>
                    m columnStride the column step factor.                    
                </@param>
                <@return>
                    n a new view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>rowStride<=0 || columnStride<=0</tt>.                    
                </@throws>
            </javadoc>
            <method name="viewStrides" type="ObjectMatrix2D" line="795"/>
            <javadoc line="798">
                Applies a procedure to each cell&apos;s value.
                 * Iterates downwards from &lt;tt&gt;[rows()-1,columns()-1]&lt;/tt&gt; to &lt;tt&gt;[0,0]&lt;/tt&gt;,
                 * as demonstrated by this snippet:
                 * &lt;pre&gt;
                 * for (int row=rows; --row &gt;=0;) {
                 * for (int column=columns; --column &gt;= 0;) {
                 * if (!procedure.apply(getQuick(row,column))) return false;
                 * }
                 * }
                 * return true;
                 * &lt;/pre&gt;
                 * Note that an implementation may use more efficient techniques, but must not use any other order.                
                <@param>
                    m procedure a procedure object taking as argument the current cell's value. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </@param>
                <@return>
                    n <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.                    
                </@return>
            </javadoc>
            <method name="xforEach" type="boolean" line="815">
                <scope line="816">
                    <scope line="817"/>
                </scope>
            </method>
        </class>
    </source>