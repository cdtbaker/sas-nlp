<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix">
        <import package="cern.colt.list.IntArrayList"/>
        <import package="cern.colt.list.ObjectArrayList"/>
        <import package="cern.colt.matrix.impl.AbstractMatrix1D"/>
        <class name="ObjectMatrix1D" extends="AbstractMatrix1D" line="14">
            <javadoc line="14">
                Abstract base class for 1-d matrices (aka &lt;i&gt;vectors&lt;/i&gt;) holding &lt;tt&gt;Object&lt;/tt&gt; elements.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * A matrix has a number of cells (its &lt;i&gt;size&lt;/i&gt;), which are assigned upon instance construction.
                 * Elements are accessed via zero based indexes.
                 * Legal indexes are of the form &lt;tt&gt;[0..size()-1]&lt;/tt&gt;.
                 * Any attempt to access an element at a coordinate &lt;tt&gt;index&amp;lt;0 || index&amp;gt;=size()&lt;/tt&gt; will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <javadoc line="27">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="ObjectMatrix1D" type="constructor" line="30"/>
            <javadoc line="31">
                Applies a function to each cell and aggregates the results.
                 * Returns a value &lt;tt&gt;v&lt;/tt&gt; such that &lt;tt&gt;v==a(size())&lt;/tt&gt; where &lt;tt&gt;a(i) == aggr( a(i-1), f(get(i)) )&lt;/tt&gt; and terminators are &lt;tt&gt;a(1) == f(get(0)), a(0)==null&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
                 * matrix = 0 1 2 3 
                 * // Sum( x[i]*x[i] ) 
                 * matrix.aggregate(F.plus,F.square);
                 * --&gt; 14
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value.                    
                </@param>
                <@param>
                    m f a function transforming the current cell value.                    
                </@param>
                <@return>
                    n the aggregated measure.                    
                </@return>
            </javadoc>
            <method name="aggregate" type="Object" line="50">
                <declaration name="a" type="Object" line="52"/>
                <scope line="53"/>
            </method>
            <javadoc line="58">
                Applies a function to each corresponding cell of two matrices and aggregates the results.
                 * Returns a value &lt;tt&gt;v&lt;/tt&gt; such that &lt;tt&gt;v==a(size())&lt;/tt&gt; where &lt;tt&gt;a(i) == aggr( a(i-1), f(get(i),other.get(i)) )&lt;/tt&gt; and terminators are &lt;tt&gt;a(1) == f(get(0),other.get(0)), a(0)==null&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * cern.jet.math.Functions F = cern.jet.math.Functions.functions;
                 * x = 0 1 2 3 
                 * y = 0 1 2 3 
                 * // Sum( x[i]*y[i] )
                 * x.aggregate(y, F.plus, F.mult);
                 * --&gt; 14
                 * // Sum( (x[i]+y[i])^2 )
                 * x.aggregate(y, F.plus, F.chain(F.square,F.plus));
                 * --&gt; 56
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m aggr an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values.                    
                </@param>
                <@param>
                    m f a function transforming the current cell values.                    
                </@param>
                <@return>
                    n the aggregated measure.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>size() != other.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="aggregate" type="Object" line="83">
                <declaration name="a" type="Object" line="86"/>
                <scope line="87"/>
            </method>
            <javadoc line="92">
                Sets all cells to the state specified by &lt;tt&gt;values&lt;/tt&gt;.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the same number of cells as the receiver.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values the values to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>values.length != size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="assign" type="ObjectMatrix1D" line="102">
                <scope line="104"/>
            </method>
            <javadoc line="109">
                Assigns the result of a function to each cell; &lt;tt&gt;x[i] = function(x[i])&lt;/tt&gt;.
                 * (Iterates downwards from &lt;tt&gt;[size()-1]&lt;/tt&gt; to &lt;tt&gt;[0]&lt;/tt&gt;).
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // change each cell to its sine
                 * matrix =   0.5      1.5      2.5       3.5 
                 * matrix.assign(cern.jet.math.Functions.sin);
                 * --&gt;
                 * matrix ==  0.479426 0.997495 0.598472 -0.350783
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m function a function object taking as argument the current cell's value.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="ObjectMatrix1D" line="127">
                <scope line="128"/>
            </method>
            <javadoc line="133">
                Replaces all cell values of the receiver with the values of another matrix.
                 * Both matrices must have the same size.
                 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces &lt;i&gt;as if&lt;/i&gt; using an intermediate auxiliary deep copy of &lt;tt&gt;other&lt;/tt&gt;.                
                <@param>
                    m other   the source matrix to copy from (may be identical to the receiver).                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>size() != other.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="assign" type="ObjectMatrix1D" line="142">
                <scope line="147"/>
            </method>
            <javadoc line="152">
                Assigns the result of a function to each cell; &lt;tt&gt;x[i] = function(x[i],y[i])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // assign x[i] = x[i]&lt;sup&gt;y[i]&lt;/sup&gt;
                 * m1 = 0 1 2 3;
                 * m2 = 0 2 4 6;
                 * m1.assign(m2, cern.jet.math.Functions.pow);
                 * --&gt;
                 * m1 == 1 1 16 729
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m y the secondary matrix to operate on.                    
                </@param>
                <@param>
                    m function a function object taking as first argument the current cell's value of <tt>this</tt>,
                     * and as second argument the current cell's value of <tt>y</tt>,                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>size() != y.size()</tt>.                    
                </@throws>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="ObjectMatrix1D" line="173">
                <scope line="175"/>
            </method>
            <javadoc line="180">
                Sets all cells to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <@param>
                    m value the value to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
            </javadoc>
            <method name="assign" type="ObjectMatrix1D" line="185">
                <scope line="186"/>
            </method>
            <javadoc line="191">
                Returns the number of cells having non-zero values; ignores tolerance.                
            </javadoc>
            <method name="cardinality" type="int" line="194">
                <declaration name="cardinality" type="int" line="195"/>
                <scope line="196"/>
            </method>
            <javadoc line="201">
                Constructs and returns a deep copy of the receiver.
                 * &lt;p&gt;
                 * &lt;b&gt;Note that the returned matrix is an independent deep copy.&lt;/b&gt;
                 * The returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa.                
                <@return>
                    n  a deep copy of the receiver.                    
                </@return>
            </javadoc>
            <method name="copy" type="ObjectMatrix1D" line="209">
                <declaration name="copy" type="ObjectMatrix1D" line="210"/>
            </method>
            <javadoc line="214">
                Compares the specified Object with the receiver for equality.
                 * Equivalent to &lt;tt&gt;equals(otherObj,true)&lt;/tt&gt;.                
                <@param>
                    m otherObj the Object to be compared for equality with the receiver.                    
                </@param>
                <@return>
                    n true if the specified Object is equal to the receiver.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="221">
                <comment line="222">
                    blic boolean equals(Object otherObj) { //delta                    
                </comment>
            </method>
            <javadoc line="224">
                Compares the specified Object with the receiver for equality.
                 * Returns true if and only if the specified Object is also at least an ObjectMatrix1D, both matrices have the
                 * same size, and all corresponding pairs of cells in the two matrices are the same.
                 * In other words, two matrices are defined to be equal if they contain the
                 * same cell values in the same order.
                 * Tests elements for equality or identity as specified by &lt;tt&gt;testForEquality&lt;/tt&gt;.
                 * When testing for equality, two elements &lt;tt&gt;e1&lt;/tt&gt; and
                 * &lt;tt&gt;e2&lt;/tt&gt; are &lt;i&gt;equal&lt;/i&gt; if &lt;tt&gt;(e1==null ? e2==null :
                 * e1.equals(e2))&lt;/tt&gt;.)                
                <@param>
                    m otherObj the Object to be compared for equality with the receiver.                    
                </@param>
                <@param>
                    m testForEquality if true -> tests for equality, otherwise for identity.                    
                </@param>
                <@return>
                    n true if the specified Object is equal to the receiver.                    
                </@return>
            </javadoc>
            <method name="equals" type="boolean" line="239">
                <comment line="240">
                    blic boolean equals(Object otherObj, boolean testForEquality) { //delta                    
                </comment>
                <scope line="240"/>
                <declaration name="other" type="ObjectMatrix1D" line="243"/>
                <scope line="246">
                    <scope line="247"/>
                </scope>
                <scope line="251">
                    <scope line="252"/>
                </scope>
            </method>
            <javadoc line="260">
                Returns the matrix cell value at coordinate &lt;tt&gt;index&lt;/tt&gt;.                
                <@param>
                    m index   the index of the cell.                    
                </@param>
                <@return>
                    n    the value of the specified cell.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>index&lt;0 || index&gt;=size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="get" type="Object" line="267"/>
            <javadoc line="271">
                Returns the content of this matrix if it is a wrapper; or &lt;tt&gt;this&lt;/tt&gt; otherwise.
                 * Override this method in wrappers.                
            </javadoc>
            <method name="getContent" type="ObjectMatrix1D" line="275"/>
            <javadoc line="278">
                Fills the coordinates and values of cells having non-zero values into the specified lists.
                 * Fills into the lists, starting at index 0.
                 * After this call returns the specified lists all have a new size, the number of non-zero values.
                 * &lt;p&gt;
                 * In general, fill order is &lt;i&gt;unspecified&lt;/i&gt;.
                 * This implementation fills like: &lt;tt&gt;for (index = 0..size()-1)  do ... &lt;/tt&gt;.
                 * However, subclasses are free to us any other order, even an order that may change over time as cell values are changed.
                 * (Of course, result lists indexes are guaranteed to correspond to the same cell).
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;br&gt;
                 * &lt;pre&gt;
                 * 0, 0, 8, 0, 7
                 * --&gt;
                 * indexList  = (2,4)
                 * valueList  = (8,7)
                 * &lt;/pre&gt;
                 * In other words, &lt;tt&gt;get(2)==8, get(4)==7&lt;/tt&gt;.                
                <@param>
                    m indexList the list to be filled with indexes, can have any size.                    
                </@param>
                <@param>
                    m valueList the list to be filled with values, can have any size.                    
                </@param>
            </javadoc>
            <method name="getNonZeros" type="void" line="301">
                <declaration name="fillIndexList" type="boolean" line="302"/>
                <declaration name="fillValueList" type="boolean" line="303"/>
                <declaration name="s" type="int" line="306"/>
                <scope line="307">
                    <declaration name="value" type="Object" line="308"/>
                    <scope line="309"/>
                </scope>
            </method>
            <method name="getQuick" type="Object" line="315"/>
            <javadoc line="315">
                Returns the matrix cell value at coordinate &lt;tt&gt;index&lt;/tt&gt;.
                 * &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;index&amp;lt;0 || index&amp;gt;=size()&lt;/tt&gt;.                
                <@param>
                    m index   the index of the cell.                    
                </@param>
                <@return>
                    n    the value of the specified cell.                    
                </@return>
            </javadoc>
            <javadoc line="326">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share at least one identical cell.                
            </javadoc>
            <method name="haveSharedCells" type="boolean" line="329"/>
            <javadoc line="334">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share at least one identical cell.                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="337"/>
            <javadoc line="340">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the same size.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like" type="ObjectMatrix1D" line="348"/>
            <method name="like" type="ObjectMatrix1D" line="351"/>
            <javadoc line="351">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified size.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@param>
                    m size the number of cell the matrix shall have.                    
                </@param>
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like2D" type="ObjectMatrix2D" line="361"/>
            <javadoc line="361">
                Construct and returns a new 2-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, entirelly independent of the receiver.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt;, etc.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <javadoc line="371">
                Sets the matrix cell at coordinate &lt;tt&gt;index&lt;/tt&gt; to the specified value.                
                <@param>
                    m index   the index of the cell.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
                <@throws>
                    s IndexOutOfBoundsException if <tt>index&lt;0 || index&gt;=size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="set" type="void" line="378"/>
            <method name="setQuick" type="void" line="382"/>
            <javadoc line="382">
                Sets the matrix cell at coordinate &lt;tt&gt;index&lt;/tt&gt; to the specified value.
                 * &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;index&amp;lt;0 || index&amp;gt;=size()&lt;/tt&gt;.                
                <@param>
                    m index   the index of the cell.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
            </javadoc>
            <javadoc line="393">
                Swaps each element &lt;tt&gt;this[i]&lt;/tt&gt; with &lt;tt&gt;other[i]&lt;/tt&gt;.                
                <@throws>
                    s IllegalArgumentException if <tt>size() != other.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="swap" type="void" line="397">
                <scope line="399">
                    <declaration name="tmp" type="Object" line="400"/>
                </scope>
            </method>
            <javadoc line="406">
                Constructs and returns a 1-dimensional array containing the cell values.
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.
                 * The returned array &lt;tt&gt;values&lt;/tt&gt; has the form 
                 * &lt;br&gt;
                 * &lt;tt&gt;for (int i=0; i &lt; size(); i++) values[i] = get(i);&lt;/tt&gt;                
                <@return>
                    n an array filled with the values of the cells.                    
                </@return>
            </javadoc>
            <method name="toArray" type="Object[]" line="415">
                <declaration name="values" type="Object[]" line="416"/>
            </method>
            <javadoc line="420">
                Fills the cell values into the specified 1-dimensional array.
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.
                 * After this call returns the array &lt;tt&gt;values&lt;/tt&gt; has the form 
                 * &lt;br&gt;
                 * &lt;tt&gt;for (int i=0; i &lt; size(); i++) values[i] = get(i);&lt;/tt&gt;                
                <@throws>
                    s IllegalArgumentException if <tt>values.length < size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="toArray" type="void" line="429">
                <scope line="431"/>
            </method>
            <javadoc line="435">
                Returns a string representation using default formatting.                
                <@see>
                    e cern.colt.matrix.objectalgo.Formatter                    
                </@see>
            </javadoc>
            <method name="toString" type="String" line="439"/>
            <javadoc line="442">
                Constructs and returns a new view equal to the receiver.
                 * The view is a shallow clone. Calls &lt;code&gt;clone()&lt;/code&gt; and casts the result.
                 * &lt;p&gt;
                 * &lt;b&gt;Note that the view is not a deep copy.&lt;/b&gt;
                 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
                 * &lt;p&gt;
                 * Use {@link #copy()} to construct an independent deep copy rather than a new view.                
                <@return>
                    n  a new view of the receiver.                    
                </@return>
            </javadoc>
            <method name="view" type="ObjectMatrix1D" line="453"/>
            <javadoc line="456">
                Constructs and returns a new &lt;i&gt;flip view&lt;/i&gt;.
                 * What used to be index &lt;tt&gt;0&lt;/tt&gt; is now index &lt;tt&gt;size()-1&lt;/tt&gt;, ..., what used to be index &lt;tt&gt;size()-1&lt;/tt&gt; is now index &lt;tt&gt;0&lt;/tt&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.                
                <@return>
                    n a new flip view.                    
                </@return>
            </javadoc>
            <method name="viewFlip" type="ObjectMatrix1D" line="463"/>
            <javadoc line="466">
                Constructs and returns a new &lt;i&gt;sub-range view&lt;/i&gt; that is a &lt;tt&gt;width&lt;/tt&gt; sub matrix starting at &lt;tt&gt;index&lt;/tt&gt;.
                 * Operations on the returned view can only be applied to the restricted range.
                 * Any attempt to access coordinates not contained in the view will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Note that the view is really just a range restriction:&lt;/b&gt; 
                 * The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. 
                 * &lt;p&gt;
                 * The view contains the cells from &lt;tt&gt;index..index+width-1&lt;/tt&gt;.
                 * and has &lt;tt&gt;view.size() == width&lt;/tt&gt;.
                 * A view&apos;s legal coordinates are again zero based, as usual.
                 * In other words, legal coordinates of the view are &lt;tt&gt;0 .. view.size()-1==width-1&lt;/tt&gt;.
                 * As usual, any attempt to access a cell at other coordinates will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.                
                <@param>
                    m index   The index of the first cell.                    
                </@param>
                <@param>
                    m width   The width of the range.                    
                </@param>
                <@throws>
                    s IndexOutOfBoundsException if <tt>index<0 || width<0 || index+width>size()</tt>.                    
                </@throws>
                <@return>
                    n the new view.                    
                </@return>
            </javadoc>
            <method name="viewPart" type="ObjectMatrix1D" line="487"/>
            <javadoc line="490">
                Constructs and returns a new &lt;i&gt;selection view&lt;/i&gt; that is a matrix holding the indicated cells.
                 * There holds &lt;tt&gt;view.size() == indexes.length&lt;/tt&gt; and &lt;tt&gt;view.get(i) == this.get(indexes[i])&lt;/tt&gt;.
                 * Indexes can occur multiple times and can be in arbitrary order.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;br&gt;
                 * &lt;pre&gt;
                 * this     = (0,0,8,0,7)
                 * indexes  = (0,2,4,2)
                 * --&gt;
                 * view     = (0,8,7,8)
                 * &lt;/pre&gt;
                 * Note that modifying &lt;tt&gt;indexes&lt;/tt&gt; after this call has returned has no effect on the view.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.                
                <@param>
                    m indexes   The indexes of the cells that shall be visible in the new view. To indicate that <i>all</i> cells shall be visible, simply set this parameter to <tt>null</tt>.                    
                </@param>
                <@return>
                    n the new view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>!(0 <= indexes[i] < size())</tt> for any <tt>i=0..indexes.length()-1</tt>.                    
                </@throws>
            </javadoc>
            <method name="viewSelection" type="ObjectMatrix1D" line="510">
                <comment line="511">
                    check for &quot;all&quot;                    
                </comment>
                <scope line="512"/>
                <declaration name="offsets" type="int[]" line="518"/>
                <scope line="519"/>
            </method>
            <javadoc line="524">
                Constructs and returns a new &lt;i&gt;selection view&lt;/i&gt; that is a matrix holding the cells matching the given condition.
                 * Applies the condition to each cell and takes only those cells where &lt;tt&gt;condition.apply(get(i))&lt;/tt&gt; yields &lt;tt&gt;true&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;br&gt;
                 * &lt;pre&gt;
                 * // extract and view all cells with even value
                 * matrix = 0 1 2 3 
                 * matrix.viewSelection( 
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;new ObjectProcedure() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public final boolean apply(Object a) { return a % 2 == 0; }
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * );
                 * --&gt;
                 * matrix ==  0 2
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.                
                <@param>
                    m condition The condition to be matched.                    
                </@param>
                <@return>
                    n the new view.                    
                </@return>
            </javadoc>
            <method name="viewSelection" type="ObjectMatrix1D" line="547">
                <declaration name="matches" type="IntArrayList" line="548"/>
                <scope line="549"/>
            </method>
            <method name="viewSelectionLike" type="ObjectMatrix1D" line="555"/>
            <javadoc line="555">
                Construct and returns a new selection view.                
                <@param>
                    m offsets the offsets of the visible elements.                    
                </@param>
                <@return>
                    n  a new view.                    
                </@return>
            </javadoc>
            <javadoc line="562">
                Sorts the vector into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt;.
                 * This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;.
                 * For further information, see {@link cern.colt.matrix.objectalgo.Sorting#sort(ObjectMatrix1D)}.
                 * For more advanced sorting functionality, see {@link cern.colt.matrix.objectalgo.Sorting}.                
                <@return>
                    n a new sorted vector (matrix) view.                    
                </@return>
            </javadoc>
            <method name="viewSorted" type="ObjectMatrix1D" line="569"/>
            <javadoc line="572">
                Constructs and returns a new &lt;i&gt;stride view&lt;/i&gt; which is a sub matrix consisting of every i-th cell.
                 * More specifically, the view has size &lt;tt&gt;this.size()/stride&lt;/tt&gt; holding cells &lt;tt&gt;this.get(i*stride)&lt;/tt&gt; for all &lt;tt&gt;i = 0..size()/stride - 1&lt;/tt&gt;.                
                <@param>
                    m stride  the step factor.                    
                </@param>
                <@throws>
                    s IndexOutOfBoundsException if <tt>stride <= 0</tt>.                    
                </@throws>
                <@return>
                    n the new view.                    
                </@return>
            </javadoc>
            <method name="viewStrides" type="ObjectMatrix1D" line="581"/>
            <javadoc line="584">
                Applies a procedure to each cell&apos;s value.
                 * Iterates downwards from &lt;tt&gt;[size()-1]&lt;/tt&gt; to &lt;tt&gt;[0]&lt;/tt&gt;,
                 * as demonstrated by this snippet:
                 * &lt;pre&gt;
                 * for (int i=size(); --i &gt;=0;) {
                 * if (!procedure.apply(getQuick(i))) return false;
                 * }
                 * return true;
                 * &lt;/pre&gt;
                 * Note that an implementation may use more efficient techniques, but must not use any other order.                
                <@param>
                    m procedure a procedure object taking as argument the current cell's value. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </@param>
                <@return>
                    n <tt>false</tt> if the procedure stopped before all elements where iterated over, <tt>true</tt> otherwise.                    
                </@return>
            </javadoc>
            <method name="xforEach" type="boolean" line="599">
                <scope line="600"/>
            </method>
        </class>
    </source>