<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.impl">
        <import package="cern.colt.map.AbstractIntDoubleMap"/>
        <import package="cern.colt.map.OpenIntDoubleHashMap"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="SparseDoubleMatrix2D" extends="DoubleMatrix2D" line="15">
            <comment line="16">
                                
            </comment>
            <javadoc line="15">
                Sparse hashed 2-d matrix holding &lt;tt&gt;double&lt;/tt&gt; elements.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * &lt;b&gt;Implementation:&lt;/b&gt;
                 * &lt;p&gt;
                 * Note that this implementation is not synchronized.
                 * Uses a {@link cern.colt.map.OpenIntDoubleHashMap}, which is a compact and performant hashing technique.
                 * &lt;p&gt;
                 * &lt;b&gt;Memory requirements:&lt;/b&gt;
                 * &lt;p&gt;
                 * Cells that
                 * &lt;ul&gt;
                 * &lt;li&gt;are never set to non-zero values do not use any memory.
                 * &lt;li&gt;switch from zero to non-zero state do use memory.
                 * &lt;li&gt;switch back from non-zero to zero state also do use memory. However, their memory is automatically reclaimed from time to time. It can also manually be reclaimed by calling {@link #trimToSize()}.
                 * &lt;/ul&gt;
                 * &lt;p&gt;
                 * worst case: &lt;tt&gt;memory [bytes] = (1/minLoadFactor) * nonZeros * 13&lt;/tt&gt;.
                 * &lt;br&gt;best  case: &lt;tt&gt;memory [bytes] = (1/maxLoadFactor) * nonZeros * 13&lt;/tt&gt;.
                 * &lt;br&gt;Where &lt;tt&gt;nonZeros = cardinality()&lt;/tt&gt; is the number of non-zero cells.
                 * Thus, a 1000 x 1000 matrix with minLoadFactor=0.25 and maxLoadFactor=0.5 and 1000000 non-zero cells consumes between 25 MB and 50 MB.
                 * The same 1000 x 1000 matrix with 1000 non-zero cells consumes between 25 and 50 KB.
                 * &lt;p&gt;
                 * &lt;b&gt;Time complexity:&lt;/b&gt;
                 * &lt;p&gt;
                 * This class offers &lt;i&gt;expected&lt;/i&gt; time complexity &lt;tt&gt;O(1)&lt;/tt&gt; (i.e. constant time) for the basic operations
                 * &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;getQuick&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, &lt;tt&gt;setQuick&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;
                 * assuming the hash function disperses the elements properly among the buckets.
                 * Otherwise, pathological cases, although highly improbable, can occur, degrading performance to &lt;tt&gt;O(N)&lt;/tt&gt; in the worst case.
                 * As such this sparse class is expected to have no worse time complexity than its dense counterpart {@link DenseDoubleMatrix2D}.
                 * However, constant factors are considerably larger.
                 * &lt;p&gt;
                 * Cells are internally addressed in row-major.
                 * Performance sensitive applications can exploit this fact.
                 * Setting values in a loop row-by-row is quicker than column-by-column, because fewer hash collisions occur.
                 * Thus
                 * &lt;pre&gt;
                 * for (int row=0; row &lt; rows; row++) {
                 * for (int column=0; column &lt; columns; column++) {
                 * matrix.setQuick(row,column,someValue);
                 * }
                 * }
                 * &lt;/pre&gt;
                 * is quicker than
                 * &lt;pre&gt;
                 * for (int column=0; column &lt; columns; column++) {
                 * for (int row=0; row &lt; rows; row++) {
                 * matrix.setQuick(row,column,someValue);
                 * }
                 * }
                 * &lt;/pre&gt;                
                <@see>
                    e cern.colt.map                    
                </@see>
                <@see>
                    e cern.colt.map.OpenIntDoubleHashMap                    
                </@see>
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <declaration name="elements" type="AbstractIntDoubleMap" line="77"/>
            <declaration name="dummy" type="int" line="78"/>
            <javadoc line="79">
                Constructs a matrix with a copy of the given values.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and have exactly the same number of columns in every row.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values The values to be filled into the new matrix.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.                    
                </@throws>
            </javadoc>
            <method name="SparseDoubleMatrix2D" type="constructor" line="89"/>
            <javadoc line="93">
                Constructs a matrix with a given number of rows and columns and default memory usage.
                 * All entries are initially &lt;tt&gt;0&lt;/tt&gt;.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.                    
                </@throws>
            </javadoc>
            <method name="SparseDoubleMatrix2D" type="constructor" line="100"/>
            <javadoc line="103">
                Constructs a matrix with a given number of rows and columns using memory as specified.
                 * All entries are initially &lt;tt&gt;0&lt;/tt&gt;.
                 * For details related to memory usage see {@link cern.colt.map.OpenIntDoubleHashMap}.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@param>
                    m initialCapacity   the initial capacity of the hash map.
                     * If not known, set <tt>initialCapacity=0</tt> or small.                    
                </@param>
                <@param>
                    m minLoadFactor        the minimum load factor of the hash map.                    
                </@param>
                <@param>
                    m maxLoadFactor        the maximum load factor of the hash map.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.                    
                </@throws>
            </javadoc>
            <method name="SparseDoubleMatrix2D" type="constructor" line="117"/>
            <javadoc line="121">
                Constructs a view with the given parameters.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@param>
                    m elements the cells.                    
                </@param>
                <@param>
                    m rowZero the position of the first element.                    
                </@param>
                <@param>
                    m columnZero the position of the first element.                    
                </@param>
                <@param>
                    m rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.                    
                </@param>
                <@param>
                    m columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt> or flip's are illegal.                    
                </@throws>
            </javadoc>
            <method name="SparseDoubleMatrix2D" type="constructor" line="132"/>
            <javadoc line="137">
                Sets all cells to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <@param>
                    m value the value to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="142">
                <comment line="143">
                    overriden for performance only                    
                </comment>
            </method>
            <javadoc line="148">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * matrix = 2 x 2 matrix
                 * 0.5 1.5      
                 * 2.5 3.5
                 * // change each cell to its sine
                 * matrix.assign(cern.jet.math.Functions.sin);
                 * --&gt;
                 * 2 x 2 matrix
                 * 0.479426  0.997495 
                 * 0.598472 -0.350783
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m function a function object taking as argument the current cell's value.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="170">
                <scope line="171"/>
                <scope line="174"/>
            </method>
            <javadoc line="179">
                Replaces all cell values of the receiver with the values of another matrix.
                 * Both matrices must have the same number of rows and columns.
                 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces &lt;i&gt;as if&lt;/i&gt; using an intermediate auxiliary deep copy of &lt;tt&gt;other&lt;/tt&gt;.                
                <@param>
                    m source   the source matrix to copy from (may be identical to the receiver).                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt>                    
                </@throws>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="188">
                <comment line="189">
                    overriden for performance only                    
                </comment>
                <comment line="189">
                    (other==this) return this; // nothing to do                    
                </comment>
                <scope line="190"/>
                <declaration name="other" type="SparseDoubleMatrix2D" line="193"/>
                <scope line="197"/>
            </method>
            <method name="assign" type="DoubleMatrix2D" line="203">
                <scope line="208">
                    <declaration name="alpha" type="double" line="209"/>
                    <anonymous_class line="212">
                        <method name="apply" type="double" line="213"/>
                    </anonymous_class>
                </scope>
                <scope line="222">
                    <anonymous_class line="224">
                        <method name="apply" type="boolean" line="225">
                            <declaration name="i" type="int" line="226"/>
                            <declaration name="j" type="int" line="227"/>
                            <declaration name="r" type="double" line="228"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="236">
                    <anonymous_class line="238">
                        <method name="apply" type="boolean" line="239">
                            <declaration name="i" type="int" line="240"/>
                            <declaration name="j" type="int" line="241"/>
                            <declaration name="r" type="double" line="242"/>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <javadoc line="252">
                Returns the number of cells having non-zero values.                
            </javadoc>
            <method name="cardinality" type="int" line="255"/>
            <javadoc line="259">
                Ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory.
                 * If necessary, allocates new internal memory and increases the capacity of the receiver.
                 * &lt;p&gt;
                 * This method never need be called; it is for performance tuning only.
                 * Calling this method before tt&gt;set()&lt;/tt&gt;ing a large number of non-zero values boosts performance,
                 * because the receiver will grow only once instead of potentially many times and hash collisions get less probable.                
                <@param>
                    m minNonZeros   the desired minimum number of non-zero cells.                    
                </@param>
            </javadoc>
            <method name="ensureCapacity" type="void" line="269"/>
            <method name="forEachNonZero" type="DoubleMatrix2D" line="272">
                <scope line="273">
                    <anonymous_class line="275">
                        <method name="apply" type="boolean" line="276">
                            <declaration name="i" type="int" line="277"/>
                            <declaration name="j" type="int" line="278"/>
                            <declaration name="r" type="double" line="279"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="286"/>
            </method>
            <javadoc line="291">
                Returns the matrix cell value at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt;.
                 * &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@return>
                    n    the value at the specified coordinate.                    
                </@return>
            </javadoc>
            <method name="getQuick" type="double" line="302">
                <comment line="303">
                    if (debug) if (column&lt;0 || column&gt;=columns || row&lt;0 || row&gt;=rows) throw new IndexOutOfBoundsException(&quot;row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="303">
                    return this.elements.get(index(row,column));                    
                </comment>
                <comment line="303">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="308">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share common cells.
                 * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if at least one of the following conditions is met
                 * &lt;ul&gt;
                 * &lt;li&gt;the receiver is a view of the other matrix
                 * &lt;li&gt;the other matrix is a view of the receiver
                 * &lt;li&gt;&lt;tt&gt;this == other&lt;/tt&gt;
                 * &lt;/ul&gt;                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="317">
                <scope line="318">
                    <declaration name="otherMatrix" type="SelectedSparseDoubleMatrix2D" line="319"/>
                </scope>
                <scope line="322">
                    <declaration name="otherMatrix" type="SparseDoubleMatrix2D" line="323"/>
                </scope>
            </method>
            <javadoc line="328">
                Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
            </javadoc>
            <method name="index" type="int" line="334">
                <comment line="335">
                    return super.index(row,column);                    
                </comment>
                <comment line="335">
                    manually inlined for speed:                    
                </comment>
            </method>
            <javadoc line="339">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified number of rows and columns.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like" type="DoubleMatrix2D" line="349"/>
            <javadoc line="352">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, entirelly independent of the receiver.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseDoubleMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseDoubleMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="DoubleMatrix1D" line="360"/>
            <javadoc line="363">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, sharing the same cells.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseDoubleMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseDoubleMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@param>
                    m offset the index of the first element.                    
                </@param>
                <@param>
                    m stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="DoubleMatrix1D" line="373"/>
            <javadoc line="376">
                Sets the matrix cell at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt; to the specified value.
                 * &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
            </javadoc>
            <method name="setQuick" type="void" line="387">
                <comment line="388">
                    if (debug) if (column&lt;0 || column&gt;=columns || row&lt;0 || row&gt;=rows) throw new IndexOutOfBoundsException(&quot;row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="388">
                    int index =	index(row,column);                    
                </comment>
                <comment line="388">
                    manually inlined:                    
                </comment>
                <comment line="388">
                    if (value == 0 || Math.abs(value) &lt; TOLERANCE)                    
                </comment>
                <declaration name="index" type="int" line="391"/>
            </method>
            <javadoc line="399">
                Releases any superfluous memory created by explicitly putting zero values into cells formerly having non-zero values; 
                 * An application can use this operation to minimize the
                 * storage of the receiver.
                 * &lt;p&gt;
                 * &lt;b&gt;Background:&lt;/b&gt;
                 * &lt;p&gt;
                 * Cells that &lt;ul&gt;
                 * &lt;li&gt;are never set to non-zero values do not use any memory.
                 * &lt;li&gt;switch from zero to non-zero state do use memory.
                 * &lt;li&gt;switch back from non-zero to zero state also do use memory. However, their memory can be reclaimed by calling &lt;tt&gt;trimToSize()&lt;/tt&gt;.
                 * &lt;/ul&gt;
                 * A sequence like &lt;tt&gt;set(r,c,5); set(r,c,0);&lt;/tt&gt;
                 * sets a cell to non-zero state and later back to zero state.
                 * Such as sequence generates obsolete memory that is automatically reclaimed from time to time or can manually be reclaimed by calling &lt;tt&gt;trimToSize()&lt;/tt&gt;.
                 * Putting zeros into cells already containing zeros does not generate obsolete memory since no memory was allocated to them in the first place.                
            </javadoc>
            <method name="trimToSize" type="void" line="416"/>
            <javadoc line="419">
                Construct and returns a new selection view.                
                <@param>
                    m rowOffsets the offsets of the visible elements.                    
                </@param>
                <@param>
                    m columnOffsets the offsets of the visible elements.                    
                </@param>
                <@return>
                    n  a new view.                    
                </@return>
            </javadoc>
            <method name="viewSelectionLike" type="DoubleMatrix2D" line="426"/>
            <method name="zMult" type="DoubleMatrix1D" line="429">
                <comment line="430">
                    forEachNonZero(
                    new cern.colt.function.IntIntDoubleFunction() {
                    public double apply(int i, int j, double value) {
                    if (transposeA) { int tmp=i; i=j; j=tmp; }                    
                </comment>
                <declaration name="m" type="int" line="430"/>
                <declaration name="n" type="int" line="431"/>
                <scope line="432"/>
                <declaration name="ignore" type="boolean" line="437"/>
                <scope line="440"/>
                <declaration name="zz" type="DenseDoubleMatrix1D" line="449"/>
                <declaration name="zElements" type="double[]" line="450"/>
                <declaration name="zStride" type="int" line="451"/>
                <declaration name="zi" type="int" line="452"/>
                <declaration name="yy" type="DenseDoubleMatrix1D" line="454"/>
                <declaration name="yElements" type="double[]" line="455"/>
                <declaration name="yStride" type="int" line="456"/>
                <declaration name="yi" type="int" line="457"/>
                <anonymous_class line="462">
                    <method name="apply" type="boolean" line="463">
                        <comment line="464">
                            System.out.println(&quot;[&quot;+i+&quot;,&quot;+j+&quot;]--&gt;&quot;+value);                            
                        </comment>
                        <declaration name="i" type="int" line="464"/>
                        <declaration name="j" type="int" line="465"/>
                        <scope line="466">
                            <declaration name="tmp" type="int" line="466"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <method name="zMult" type="DoubleMatrix2D" line="491">
                <comment line="492">
                    cache views                    
                </comment>
                <scope line="492"/>
                <declaration name="m" type="int" line="496"/>
                <declaration name="n" type="int" line="497"/>
                <scope line="498"/>
                <declaration name="p" type="int" line="502"/>
                <declaration name="ignore" type="boolean" line="503"/>
                <declaration name="Brows" type="DoubleMatrix1D[]" line="516"/>
                <declaration name="Crows" type="DoubleMatrix1D[]" line="518"/>
                <declaration name="fun" type="cern.jet.math.PlusMult" line="521"/>
                <anonymous_class line="524">
                    <method name="apply" type="boolean" line="525">
                        <declaration name="i" type="int" line="526"/>
                        <declaration name="j" type="int" line="527"/>
                    </method>
                </anonymous_class>
            </method>
        </class>
    </source>