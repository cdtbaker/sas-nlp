<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.impl">
        <import package="cern.colt.map.AbstractIntObjectMap"/>
        <import package="cern.colt.matrix.ObjectMatrix2D"/>
        <import package="cern.colt.matrix.ObjectMatrix3D"/>
        <class name="SelectedSparseObjectMatrix3D" extends="ObjectMatrix3D" line="14">
            <javadoc line="14">
                Selection view on sparse 3-d matrices holding &lt;tt&gt;Object&lt;/tt&gt; elements.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * &lt;b&gt;Implementation:&lt;/b&gt;
                 * &lt;p&gt;
                 * Objects of this class are typically constructed via &lt;tt&gt;viewIndexes&lt;/tt&gt; methods on some source matrix.
                 * The interface introduced in abstract super classes defines everything a user can do.
                 * From a user point of view there is nothing special about this class; it presents the same functionality with the same signatures and semantics as its abstract superclass(es) while introducing no additional functionality.
                 * Thus, this class need not be visible to users.
                 * By the way, the same principle applies to concrete DenseXXX and SparseXXX classes: they presents the same functionality with the same signatures and semantics as abstract superclass(es) while introducing no additional functionality.
                 * Thus, they need not be visible to users, either. 
                 * Factory methods could hide all these concrete types.
                 * &lt;p&gt;
                 * This class uses no delegation. 
                 * Its instances point directly to the data. 
                 * Cell addressing overhead is is 1 additional int addition and 3 additional array index accesses per get/set.
                 * &lt;p&gt;
                 * Note that this implementation is not synchronized.
                 * &lt;p&gt;
                 * &lt;b&gt;Memory requirements:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;memory [bytes] = 4*(sliceIndexes.length+rowIndexes.length+columnIndexes.length)&lt;/tt&gt;.
                 * Thus, an index view with 100 x 100 x 100 indexes additionally uses 8 KB.
                 * &lt;p&gt;
                 * &lt;b&gt;Time complexity:&lt;/b&gt;
                 * &lt;p&gt;
                 * Depends on the parent view holding cells.
                 * &lt;p&gt;                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <declaration name="elements" type="AbstractIntObjectMap" line="47"/>
            <javadoc line="47">
                The elements of this matrix.                
            </javadoc>
            <declaration name="sliceOffsets" type="int[]" line="52"/>
            <javadoc line="52">
                The offsets of the visible cells of this matrix.                
            </javadoc>
            <declaration name="rowOffsets" type="int[]" line="56"/>
            <declaration name="columnOffsets" type="int[]" line="57"/>
            <declaration name="offset" type="int" line="59"/>
            <javadoc line="59">
                The offset.                
            </javadoc>
            <javadoc line="64">
                Constructs a matrix view with the given parameters.                
                <@param>
                    m elements the cells.                    
                </@param>
                <@param>
                    m sliceOffsets   The slice offsets of the cells that shall be visible.                    
                </@param>
                <@param>
                    m rowOffsets   The row offsets of the cells that shall be visible.                    
                </@param>
                <@param>
                    m columnOffsets   The column offsets of the cells that shall be visible.                    
                </@param>
            </javadoc>
            <method name="SelectedSparseObjectMatrix3D" type="constructor" line="71">
                <comment line="72">
                    be sure parameters are valid, we do not check...                    
                </comment>
                <declaration name="slices" type="int" line="73"/>
                <declaration name="rows" type="int" line="74"/>
                <declaration name="columns" type="int" line="75"/>
            </method>
            <javadoc line="88">
                Returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. 
                 * Default implementation. Override, if necessary.                
                <@param>
                    m rank   the absolute rank of the element.                    
                </@param>
                <@return>
                    n the position.                    
                </@return>
            </javadoc>
            <method name="_columnOffset" type="int" line="95"/>
            <javadoc line="98">
                Returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. 
                 * Default implementation. Override, if necessary.                
                <@param>
                    m rank   the absolute rank of the element.                    
                </@param>
                <@return>
                    n the position.                    
                </@return>
            </javadoc>
            <method name="_rowOffset" type="int" line="105"/>
            <javadoc line="108">
                Returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. 
                 * Default implementation. Override, if necessary.                
                <@param>
                    m rank   the absolute rank of the element.                    
                </@param>
                <@return>
                    n the position.                    
                </@return>
            </javadoc>
            <method name="_sliceOffset" type="int" line="115"/>
            <javadoc line="118">
                Returns the matrix cell value at coordinate &lt;tt&gt;[slice,row,column]&lt;/tt&gt;.
                 * &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;slice&amp;lt;0 || slice&amp;gt;=slices() || row&amp;lt;0 || row&amp;gt;=rows() || column&amp;lt;0 || column&amp;gt;=column()&lt;/tt&gt;.                
                <@param>
                    m slice   the index of the slice-coordinate.                    
                </@param>
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@return>
                    n    the value at the specified coordinate.                    
                </@return>
            </javadoc>
            <method name="getQuick" type="Object" line="130">
                <comment line="131">
                    if (debug) if (slice&lt;0 || slice&gt;=slices || row&lt;0 || row&gt;=rows || column&lt;0 || column&gt;=columns) throw new IndexOutOfBoundsException(&quot;slice:&quot;+slice+&quot;, row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="131">
                    return elements.get(index(slice,row,column));                    
                </comment>
                <comment line="131">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="136">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share common cells.
                 * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;other != null&lt;/tt&gt; and at least one of the following conditions is met
                 * &lt;ul&gt;
                 * &lt;li&gt;the receiver is a view of the other matrix
                 * &lt;li&gt;the other matrix is a view of the receiver
                 * &lt;li&gt;&lt;tt&gt;this == other&lt;/tt&gt;
                 * &lt;/ul&gt;                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="145">
                <scope line="146">
                    <declaration name="otherMatrix" type="SelectedSparseObjectMatrix3D" line="147"/>
                </scope>
                <scope line="150">
                    <declaration name="otherMatrix" type="SparseObjectMatrix3D" line="151"/>
                </scope>
            </method>
            <javadoc line="156">
                Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.                
                <@param>
                    m slice   the index of the slice-coordinate.                    
                </@param>
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the third-coordinate.                    
                </@param>
            </javadoc>
            <method name="index" type="int" line="163">
                <comment line="164">
                    return this.offset + super.index(slice,row,column);                    
                </comment>
                <comment line="164">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="168">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified number of slices, rows and columns.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix3D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix3D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@param>
                    m slices the number of slices the matrix shall have.                    
                </@param>
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like" type="ObjectMatrix3D" line="179"/>
            <javadoc line="182">
                Construct and returns a new 2-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, sharing the same cells.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt;, etc.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@param>
                    m rowZero the position of the first element.                    
                </@param>
                <@param>
                    m columnZero the position of the first element.                    
                </@param>
                <@param>
                    m rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.                    
                </@param>
                <@param>
                    m columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like2D" type="ObjectMatrix2D" line="195">
                <comment line="196">
                    row new InternalError(); // this method is never called since viewRow() and viewColumn are overridden properly.                    
                </comment>
            </method>
            <javadoc line="198">
                Sets the matrix cell at coordinate &lt;tt&gt;[slice,row,column]&lt;/tt&gt; to the specified value.
                 * &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;slice&amp;lt;0 || slice&amp;gt;=slices() || row&amp;lt;0 || row&amp;gt;=rows() || column&amp;lt;0 || column&amp;gt;=column()&lt;/tt&gt;.                
                <@param>
                    m slice   the index of the slice-coordinate.                    
                </@param>
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
            </javadoc>
            <method name="setQuick" type="void" line="210">
                <comment line="211">
                    if (debug) if (slice&lt;0 || slice&gt;=slices || row&lt;0 || row&gt;=rows || column&lt;0 || column&gt;=columns) throw new IndexOutOfBoundsException(&quot;slice:&quot;+slice+&quot;, row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="211">
                    int index =	index(slice,row,column);                    
                </comment>
                <comment line="211">
                    manually inlined:                    
                </comment>
                <declaration name="index" type="int" line="214"/>
            </method>
            <javadoc line="220">
                Sets up a matrix with a given number of slices and rows.                
                <@param>
                    m slices the number of slices the matrix shall have.                    
                </@param>
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>(Object)rows*slices > Integer.MAX_VALUE</tt>.                    
                </@throws>
            </javadoc>
            <method name="setUp" type="void" line="227"/>
            <javadoc line="234">
                Self modifying version of viewDice().                
                <@throws>
                    s IllegalArgumentException if some of the parameters are equal or not in range 0..2.                    
                </@throws>
            </javadoc>
            <method name="vDice" type="AbstractMatrix3D" line="238">
                <comment line="239">
                    swap offsets                    
                </comment>
                <declaration name="offsets" type="int[][]" line="242"/>
            </method>
            <javadoc line="253">
                Constructs and returns a new 2-dimensional &lt;i&gt;slice view&lt;/i&gt; representing the slices and rows of the given column.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * &lt;p&gt;
                 * To obtain a slice view on subranges, construct a sub-ranging view (&lt;tt&gt;view().part(...)&lt;/tt&gt;), then apply this method to the sub-range view.
                 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods &lt;tt&gt;viewColumn&lt;/tt&gt;, &lt;tt&gt;viewRow&lt;/tt&gt;) on the intermediate 2-dimensional view.
                 * To obtain 1-dimensional views on subranges, apply both steps.                
                <@param>
                    m column the index of the column to fix.                    
                </@param>
                <@return>
                    n a new 2-dimensional slice view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column < 0 || column >= columns()</tt>.                    
                </@throws>
                <@see>
                    e #viewSlice(int)                    
                </@see>
                <@see>
                    e #viewRow(int)                    
                </@see>
            </javadoc>
            <method name="viewColumn" type="ObjectMatrix2D" line="267">
                <declaration name="viewRows" type="int" line="270"/>
                <declaration name="viewColumns" type="int" line="271"/>
                <declaration name="viewRowZero" type="int" line="273"/>
                <declaration name="viewColumnZero" type="int" line="274"/>
                <declaration name="viewOffset" type="int" line="275"/>
                <declaration name="viewRowStride" type="int" line="277"/>
                <declaration name="viewColumnStride" type="int" line="278"/>
                <declaration name="viewRowOffsets" type="int[]" line="280"/>
                <declaration name="viewColumnOffsets" type="int[]" line="281"/>
            </method>
            <javadoc line="285">
                Constructs and returns a new 2-dimensional &lt;i&gt;slice view&lt;/i&gt; representing the slices and columns of the given row.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * &lt;p&gt;
                 * To obtain a slice view on subranges, construct a sub-ranging view (&lt;tt&gt;view().part(...)&lt;/tt&gt;), then apply this method to the sub-range view.
                 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods &lt;tt&gt;viewColumn&lt;/tt&gt;, &lt;tt&gt;viewRow&lt;/tt&gt;) on the intermediate 2-dimensional view.
                 * To obtain 1-dimensional views on subranges, apply both steps.                
                <@param>
                    m row the index of the row to fix.                    
                </@param>
                <@return>
                    n a new 2-dimensional slice view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>row < 0 || row >= row()</tt>.                    
                </@throws>
                <@see>
                    e #viewSlice(int)                    
                </@see>
                <@see>
                    e #viewColumn(int)                    
                </@see>
            </javadoc>
            <method name="viewRow" type="ObjectMatrix2D" line="299">
                <declaration name="viewRows" type="int" line="302"/>
                <declaration name="viewColumns" type="int" line="303"/>
                <declaration name="viewRowZero" type="int" line="305"/>
                <declaration name="viewColumnZero" type="int" line="306"/>
                <declaration name="viewOffset" type="int" line="307"/>
                <declaration name="viewRowStride" type="int" line="309"/>
                <declaration name="viewColumnStride" type="int" line="310"/>
                <declaration name="viewRowOffsets" type="int[]" line="312"/>
                <declaration name="viewColumnOffsets" type="int[]" line="313"/>
            </method>
            <javadoc line="317">
                Construct and returns a new selection view.                
                <@param>
                    m sliceOffsets the offsets of the visible elements.                    
                </@param>
                <@param>
                    m rowOffsets the offsets of the visible elements.                    
                </@param>
                <@param>
                    m columnOffsets the offsets of the visible elements.                    
                </@param>
                <@return>
                    n  a new view.                    
                </@return>
            </javadoc>
            <method name="viewSelectionLike" type="ObjectMatrix3D" line="325"/>
            <javadoc line="328">
                Constructs and returns a new 2-dimensional &lt;i&gt;slice view&lt;/i&gt; representing the rows and columns of the given slice.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * &lt;p&gt;
                 * To obtain a slice view on subranges, construct a sub-ranging view (&lt;tt&gt;view().part(...)&lt;/tt&gt;), then apply this method to the sub-range view.
                 * To obtain 1-dimensional views, apply this method, then apply another slice view (methods &lt;tt&gt;viewColumn&lt;/tt&gt;, &lt;tt&gt;viewRow&lt;/tt&gt;) on the intermediate 2-dimensional view.
                 * To obtain 1-dimensional views on subranges, apply both steps.                
                <@param>
                    m slice the index of the slice to fix.                    
                </@param>
                <@return>
                    n a new 2-dimensional slice view.                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>slice < 0 || slice >= slices()</tt>.                    
                </@throws>
                <@see>
                    e #viewRow(int)                    
                </@see>
                <@see>
                    e #viewColumn(int)                    
                </@see>
            </javadoc>
            <method name="viewSlice" type="ObjectMatrix2D" line="342">
                <declaration name="viewRows" type="int" line="345"/>
                <declaration name="viewColumns" type="int" line="346"/>
                <declaration name="viewRowZero" type="int" line="348"/>
                <declaration name="viewColumnZero" type="int" line="349"/>
                <declaration name="viewOffset" type="int" line="350"/>
                <declaration name="viewRowStride" type="int" line="352"/>
                <declaration name="viewColumnStride" type="int" line="353"/>
                <declaration name="viewRowOffsets" type="int[]" line="355"/>
                <declaration name="viewColumnOffsets" type="int[]" line="356"/>
            </method>
        </class>
    </source>