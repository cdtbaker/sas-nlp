<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.impl">
        <import package="cern.colt.matrix.ObjectMatrix1D"/>
        <import package="cern.colt.matrix.ObjectMatrix2D"/>
        <class name="DenseObjectMatrix2D" extends="ObjectMatrix2D" line="13">
            <javadoc line="13">
                Dense 2-d matrix holding &lt;tt&gt;Object&lt;/tt&gt; elements.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * &lt;b&gt;Implementation:&lt;/b&gt;
                 * &lt;p&gt;
                 * Internally holds one single contigous one-dimensional array, addressed in row major. 
                 * Note that this implementation is not synchronized.
                 * &lt;p&gt;
                 * &lt;b&gt;Memory requirements:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;memory [bytes] = 8*rows()*columns()&lt;/tt&gt;.
                 * Thus, a 1000*1000 matrix uses 8 MB.
                 * &lt;p&gt;
                 * &lt;b&gt;Time complexity:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;O(1)&lt;/tt&gt; (i.e. constant time) for the basic operations
                 * &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;getQuick&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, &lt;tt&gt;setQuick&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;,
                 * &lt;p&gt;
                 * Cells are internally addressed in row-major.
                 * Applications demanding utmost speed can exploit this fact.
                 * Setting/getting values in a loop row-by-row is quicker than column-by-column.
                 * Thus
                 * &lt;pre&gt;
                 * for (int row=0; row &lt; rows; row++) {
                 * for (int column=0; column &lt; columns; column++) {
                 * matrix.setQuick(row,column,someValue);
                 * }
                 * }
                 * &lt;/pre&gt;
                 * is quicker than
                 * &lt;pre&gt;
                 * for (int column=0; column &lt; columns; column++) {
                 * for (int row=0; row &lt; rows; row++) {
                 * matrix.setQuick(row,column,someValue);
                 * }
                 * }
                 * &lt;/pre&gt;                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <declaration name="elements" type="Object[]" line="55"/>
            <javadoc line="55">
                The elements of this matrix.
                 * elements are stored in row major, i.e.
                 * index==row*columns + column
                 * columnOf(index)==index%columns
                 * rowOf(index)==index/columns
                 * i.e. {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m}                
            </javadoc>
            <javadoc line="64">
                Constructs a matrix with a copy of the given values.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and have exactly the same number of columns in every row.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values The values to be filled into the new matrix.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.                    
                </@throws>
            </javadoc>
            <method name="DenseObjectMatrix2D" type="constructor" line="74"/>
            <javadoc line="78">
                Constructs a matrix with a given number of rows and columns.
                 * All entries are initially &lt;tt&gt;0&lt;/tt&gt;.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (Object)columns*rows > Integer.MAX_VALUE</tt>.                    
                </@throws>
            </javadoc>
            <method name="DenseObjectMatrix2D" type="constructor" line="85"/>
            <javadoc line="89">
                Constructs a view with the given parameters.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@param>
                    m elements the cells.                    
                </@param>
                <@param>
                    m rowZero the position of the first element.                    
                </@param>
                <@param>
                    m columnZero the position of the first element.                    
                </@param>
                <@param>
                    m rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.                    
                </@param>
                <@param>
                    m columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (Object)columns*rows > Integer.MAX_VALUE</tt> or flip's are illegal.                    
                </@throws>
            </javadoc>
            <method name="DenseObjectMatrix2D" type="constructor" line="100"/>
            <javadoc line="105">
                Sets all cells to the state specified by &lt;tt&gt;values&lt;/tt&gt;.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and have exactly the same number of rows and columns as the receiver.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values the values to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="116">
                <scope line="117">
                    <declaration name="i" type="int" line="119"/>
                    <scope line="120">
                        <declaration name="currentRow" type="Object[]" line="121"/>
                    </scope>
                </scope>
                <scope line="127"/>
            </method>
            <javadoc line="132">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * matrix = 2 x 2 matrix
                 * 0.5 1.5      
                 * 2.5 3.5
                 * // change each cell to its sine
                 * matrix.assign(cern.jet.math.Functions.sin);
                 * --&gt;
                 * 2 x 2 matrix
                 * 0.479426  0.997495 
                 * 0.598472 -0.350783
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m function a function object taking as argument the current cell's value.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="154">
                <comment line="155">
                    the general case x[i] = f(x[i])                    
                </comment>
                <declaration name="elems" type="Object[]" line="155"/>
                <declaration name="index" type="int" line="157"/>
                <declaration name="cs" type="int" line="158"/>
                <declaration name="rs" type="int" line="159"/>
                <scope line="162">
                    <scope line="163"/>
                </scope>
            </method>
            <javadoc line="171">
                Replaces all cell values of the receiver with the values of another matrix.
                 * Both matrices must have the same number of rows and columns.
                 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces &lt;i&gt;as if&lt;/i&gt; using an intermediate auxiliary deep copy of &lt;tt&gt;other&lt;/tt&gt;.                
                <@param>
                    m source   the source matrix to copy from (may be identical to the receiver).                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt>                    
                </@throws>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="180">
                <comment line="181">
                    overriden for performance only                    
                </comment>
                <comment line="181">
                    (other==this) return this; // nothing to do                    
                </comment>
                <scope line="182"/>
                <declaration name="other" type="DenseObjectMatrix2D" line="185"/>
                <scope line="189"/>
                <scope line="194">
                    <declaration name="c" type="ObjectMatrix2D" line="195"/>
                    <scope line="196"/>
                </scope>
                <declaration name="elems" type="Object[]" line="202"/>
                <declaration name="otherElems" type="Object[]" line="203"/>
                <declaration name="cs" type="int" line="205"/>
                <declaration name="ocs" type="int" line="206"/>
                <declaration name="rs" type="int" line="207"/>
                <declaration name="ors" type="int" line="208"/>
                <declaration name="otherIndex" type="int" line="210"/>
                <declaration name="index" type="int" line="211"/>
                <scope line="212">
                    <scope line="213"/>
                </scope>
            </method>
            <javadoc line="223">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col],y[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // assign x[row,col] = x[row,col]&lt;sup&gt;y[row,col]&lt;/sup&gt;
                 * m1 = 2 x 2 matrix 
                 * 0 1 
                 * 2 3
                 * m2 = 2 x 2 matrix 
                 * 0 2 
                 * 4 6
                 * m1.assign(m2, cern.jet.math.Functions.pow);
                 * --&gt;
                 * m1 == 2 x 2 matrix
                 * 1   1 
                 * 16 729
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m y the secondary matrix to operate on.                    
                </@param>
                <@param>
                    m function a function object taking as first argument the current cell's value of <tt>this</tt>,
                     * and as second argument the current cell's value of <tt>y</tt>,                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>                    
                </@throws>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="ObjectMatrix2D" line="252">
                <comment line="253">
                    overriden for performance only                    
                </comment>
                <comment line="253">
                    the general case x[i] = f(x[i],y[i])                    
                </comment>
                <scope line="254"/>
                <declaration name="other" type="DenseObjectMatrix2D" line="257"/>
                <declaration name="elems" type="Object[]" line="260"/>
                <declaration name="otherElems" type="Object[]" line="261"/>
                <declaration name="cs" type="int" line="263"/>
                <declaration name="ocs" type="int" line="264"/>
                <declaration name="rs" type="int" line="265"/>
                <declaration name="ors" type="int" line="266"/>
                <declaration name="otherIndex" type="int" line="268"/>
                <declaration name="index" type="int" line="269"/>
                <scope line="272">
                    <scope line="273"/>
                </scope>
            </method>
            <javadoc line="283">
                Returns the matrix cell value at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt;.
                 * &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@return>
                    n    the value at the specified coordinate.                    
                </@return>
            </javadoc>
            <method name="getQuick" type="Object" line="294">
                <comment line="295">
                    if (debug) if (column&lt;0 || column&gt;=columns || row&lt;0 || row&gt;=rows) throw new IndexOutOfBoundsException(&quot;row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="295">
                    return elements[index(row,column)];                    
                </comment>
                <comment line="295">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="300">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share common cells.
                 * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;other != null&lt;/tt&gt; and at least one of the following conditions is met
                 * &lt;ul&gt;
                 * &lt;li&gt;the receiver is a view of the other matrix
                 * &lt;li&gt;the other matrix is a view of the receiver
                 * &lt;li&gt;&lt;tt&gt;this == other&lt;/tt&gt;
                 * &lt;/ul&gt;                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="309">
                <scope line="310">
                    <declaration name="otherMatrix" type="SelectedDenseObjectMatrix2D" line="311"/>
                </scope>
                <scope line="314">
                    <declaration name="otherMatrix" type="DenseObjectMatrix2D" line="315"/>
                </scope>
            </method>
            <javadoc line="320">
                Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
            </javadoc>
            <method name="index" type="int" line="326">
                <comment line="327">
                    return super.index(row,column);                    
                </comment>
                <comment line="327">
                    manually inlined for speed:                    
                </comment>
            </method>
            <javadoc line="331">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified number of rows and columns.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like" type="ObjectMatrix2D" line="341"/>
            <javadoc line="344">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, entirelly independent of the receiver.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="ObjectMatrix1D" line="352"/>
            <javadoc line="355">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, sharing the same cells.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseObjectMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseObjectMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseObjectMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@param>
                    m zero the index of the first element.                    
                </@param>
                <@param>
                    m stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="ObjectMatrix1D" line="365"/>
            <javadoc line="368">
                Sets the matrix cell at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt; to the specified value.
                 * &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
            </javadoc>
            <method name="setQuick" type="void" line="379">
                <comment line="380">
                    if (debug) if (column&lt;0 || column&gt;=columns || row&lt;0 || row&gt;=rows) throw new IndexOutOfBoundsException(&quot;row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="380">
                    elements[index(row,column)] = value;                    
                </comment>
                <comment line="380">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="385">
                Construct and returns a new selection view.                
                <@param>
                    m rowOffsets the offsets of the visible elements.                    
                </@param>
                <@param>
                    m columnOffsets the offsets of the visible elements.                    
                </@param>
                <@return>
                    n  a new view.                    
                </@return>
            </javadoc>
            <method name="viewSelectionLike" type="ObjectMatrix2D" line="392"/>
        </class>
    </source>