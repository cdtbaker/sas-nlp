<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.impl">
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="DenseDoubleMatrix2D" extends="DoubleMatrix2D" line="13">
            <javadoc line="13">
                Dense 2-d matrix holding &lt;tt&gt;double&lt;/tt&gt; elements.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * &lt;b&gt;Implementation:&lt;/b&gt;
                 * &lt;p&gt;
                 * Internally holds one single contigous one-dimensional array, addressed in row major. 
                 * Note that this implementation is not synchronized.
                 * &lt;p&gt;
                 * &lt;b&gt;Memory requirements:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;memory [bytes] = 8*rows()*columns()&lt;/tt&gt;.
                 * Thus, a 1000*1000 matrix uses 8 MB.
                 * &lt;p&gt;
                 * &lt;b&gt;Time complexity:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;O(1)&lt;/tt&gt; (i.e. constant time) for the basic operations
                 * &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;getQuick&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, &lt;tt&gt;setQuick&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;,
                 * &lt;p&gt;
                 * Cells are internally addressed in row-major.
                 * Applications demanding utmost speed can exploit this fact.
                 * Setting/getting values in a loop row-by-row is quicker than column-by-column.
                 * Thus
                 * &lt;pre&gt;
                 * for (int row=0; row &lt; rows; row++) {
                 * for (int column=0; column &lt; columns; column++) {
                 * matrix.setQuick(row,column,someValue);
                 * }
                 * }
                 * &lt;/pre&gt;
                 * is quicker than
                 * &lt;pre&gt;
                 * for (int column=0; column &lt; columns; column++) {
                 * for (int row=0; row &lt; rows; row++) {
                 * matrix.setQuick(row,column,someValue);
                 * }
                 * }
                 * &lt;/pre&gt;                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="55"/>
            <declaration name="elements" type="double[]" line="56"/>
            <javadoc line="56">
                The elements of this matrix.
                 * elements are stored in row major, i.e.
                 * index==row*columns + column
                 * columnOf(index)==index%columns
                 * rowOf(index)==index/columns
                 * i.e. {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m}                
            </javadoc>
            <javadoc line="65">
                Constructs a matrix with a copy of the given values.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and have exactly the same number of columns in every row.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values The values to be filled into the new matrix.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.                    
                </@throws>
            </javadoc>
            <method name="DenseDoubleMatrix2D" type="constructor" line="75"/>
            <javadoc line="79">
                Constructs a matrix with a given number of rows and columns.
                 * All entries are initially &lt;tt&gt;0&lt;/tt&gt;.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.                    
                </@throws>
            </javadoc>
            <method name="DenseDoubleMatrix2D" type="constructor" line="86"/>
            <javadoc line="90">
                Constructs a view with the given parameters.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@param>
                    m elements the cells.                    
                </@param>
                <@param>
                    m rowZero the position of the first element.                    
                </@param>
                <@param>
                    m columnZero the position of the first element.                    
                </@param>
                <@param>
                    m rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.                    
                </@param>
                <@param>
                    m columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt> or flip's are illegal.                    
                </@throws>
            </javadoc>
            <method name="DenseDoubleMatrix2D" type="constructor" line="101"/>
            <javadoc line="106">
                Sets all cells to the state specified by &lt;tt&gt;values&lt;/tt&gt;.
                 * &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[row][column]&lt;/tt&gt;
                 * and have exactly the same number of rows and columns as the receiver.
                 * &lt;p&gt;
                 * The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <@param>
                    m values the values to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="117">
                <scope line="118">
                    <declaration name="i" type="int" line="120"/>
                    <scope line="121">
                        <declaration name="currentRow" type="double[]" line="122"/>
                    </scope>
                </scope>
                <scope line="128"/>
            </method>
            <javadoc line="133">
                Sets all cells to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <@param>
                    m value the value to be filled into the cells.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="138">
                <declaration name="elems" type="double[]" line="139"/>
                <declaration name="index" type="int" line="140"/>
                <declaration name="cs" type="int" line="141"/>
                <declaration name="rs" type="int" line="142"/>
                <scope line="143">
                    <scope line="144"/>
                </scope>
            </method>
            <javadoc line="152">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * matrix = 2 x 2 matrix
                 * 0.5 1.5      
                 * 2.5 3.5
                 * // change each cell to its sine
                 * matrix.assign(cern.jet.math.Functions.sin);
                 * --&gt;
                 * 2 x 2 matrix
                 * 0.479426  0.997495 
                 * 0.598472 -0.350783
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m function a function object taking as argument the current cell's value.                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="174">
                <comment line="175">
                    specialization for speed                    
                </comment>
                <declaration name="elems" type="double[]" line="175"/>
                <declaration name="index" type="int" line="177"/>
                <declaration name="cs" type="int" line="178"/>
                <declaration name="rs" type="int" line="179"/>
                <scope line="182">
                    <declaration name="multiplicator" type="double" line="183"/>
                    <scope line="186">
                        <scope line="187"/>
                    </scope>
                </scope>
                <scope line="194">
                    <scope line="195">
                        <scope line="196"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="205">
                Replaces all cell values of the receiver with the values of another matrix.
                 * Both matrices must have the same number of rows and columns.
                 * If both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces &lt;i&gt;as if&lt;/i&gt; using an intermediate auxiliary deep copy of &lt;tt&gt;other&lt;/tt&gt;.                
                <@param>
                    m source   the source matrix to copy from (may be identical to the receiver).                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != source.columns() || rows() != source.rows()</tt>                    
                </@throws>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="214">
                <comment line="215">
                    overriden for performance only                    
                </comment>
                <comment line="215">
                    (other==this) return this; // nothing to do                    
                </comment>
                <scope line="216"/>
                <declaration name="other" type="DenseDoubleMatrix2D" line="219"/>
                <scope line="223"/>
                <scope line="228">
                    <declaration name="c" type="DoubleMatrix2D" line="229"/>
                    <scope line="230"/>
                </scope>
                <declaration name="elems" type="double[]" line="236"/>
                <declaration name="otherElems" type="double[]" line="237"/>
                <declaration name="cs" type="int" line="239"/>
                <declaration name="ocs" type="int" line="240"/>
                <declaration name="rs" type="int" line="241"/>
                <declaration name="ors" type="int" line="242"/>
                <declaration name="otherIndex" type="int" line="244"/>
                <declaration name="index" type="int" line="245"/>
                <scope line="246">
                    <scope line="247"/>
                </scope>
            </method>
            <javadoc line="257">
                Assigns the result of a function to each cell; &lt;tt&gt;x[row,col] = function(x[row,col],y[row,col])&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // assign x[row,col] = x[row,col]&lt;sup&gt;y[row,col]&lt;/sup&gt;
                 * m1 = 2 x 2 matrix 
                 * 0 1 
                 * 2 3
                 * m2 = 2 x 2 matrix 
                 * 0 2 
                 * 4 6
                 * m1.assign(m2, cern.jet.math.Functions.pow);
                 * --&gt;
                 * m1 == 2 x 2 matrix
                 * 1   1 
                 * 16 729
                 * &lt;/pre&gt;
                 * For further examples, see the &lt;a href=&quot;package-summary.html#FunctionObjects&quot;&gt;package doc&lt;/a&gt;.                
                <@param>
                    m y the secondary matrix to operate on.                    
                </@param>
                <@param>
                    m function a function object taking as first argument the current cell's value of <tt>this</tt>,
                     * and as second argument the current cell's value of <tt>y</tt>,                    
                </@param>
                <@return>
                    n <tt>this</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>columns() != other.columns() || rows() != other.rows()</tt>                    
                </@throws>
                <@see>
                    e cern.jet.math.Functions                    
                </@see>
            </javadoc>
            <method name="assign" type="DoubleMatrix2D" line="286">
                <comment line="287">
                    overriden for performance only                    
                </comment>
                <comment line="287">
                    specialized for speed                    
                </comment>
                <scope line="288"/>
                <declaration name="other" type="DenseDoubleMatrix2D" line="291"/>
                <declaration name="elems" type="double[]" line="294"/>
                <declaration name="otherElems" type="double[]" line="295"/>
                <declaration name="cs" type="int" line="297"/>
                <declaration name="ocs" type="int" line="298"/>
                <declaration name="rs" type="int" line="299"/>
                <declaration name="ors" type="int" line="300"/>
                <declaration name="otherIndex" type="int" line="302"/>
                <declaration name="index" type="int" line="303"/>
                <scope line="306">
                    <scope line="307">
                        <scope line="308"/>
                    </scope>
                </scope>
                <scope line="317">
                    <scope line="318">
                        <scope line="319"/>
                    </scope>
                </scope>
                <scope line="328">
                    <declaration name="multiplicator" type="double" line="329"/>
                    <scope line="330"/>
                    <scope line="333">
                        <scope line="334">
                            <scope line="335"/>
                        </scope>
                    </scope>
                    <scope line="344">
                        <scope line="345">
                            <scope line="346"/>
                        </scope>
                    </scope>
                    <scope line="355">
                        <scope line="356">
                            <scope line="357"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="367">
                    <scope line="368">
                        <scope line="369"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="380">
                Returns the matrix cell value at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt;.
                 * &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@return>
                    n    the value at the specified coordinate.                    
                </@return>
            </javadoc>
            <method name="getQuick" type="double" line="391">
                <comment line="392">
                    if (debug) if (column&lt;0 || column&gt;=columns || row&lt;0 || row&gt;=rows) throw new IndexOutOfBoundsException(&quot;row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="392">
                    return elements[index(row,column)];                    
                </comment>
                <comment line="392">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="397">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share common cells.
                 * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;other != null&lt;/tt&gt; and at least one of the following conditions is met
                 * &lt;ul&gt;
                 * &lt;li&gt;the receiver is a view of the other matrix
                 * &lt;li&gt;the other matrix is a view of the receiver
                 * &lt;li&gt;&lt;tt&gt;this == other&lt;/tt&gt;
                 * &lt;/ul&gt;                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="406">
                <scope line="407">
                    <declaration name="otherMatrix" type="SelectedDenseDoubleMatrix2D" line="408"/>
                </scope>
                <scope line="411">
                    <declaration name="otherMatrix" type="DenseDoubleMatrix2D" line="412"/>
                </scope>
            </method>
            <javadoc line="417">
                Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
            </javadoc>
            <method name="index" type="int" line="423">
                <comment line="424">
                    return super.index(row,column);                    
                </comment>
                <comment line="424">
                    manually inlined for speed:                    
                </comment>
            </method>
            <javadoc line="428">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified number of rows and columns.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt;, etc.
                 * In general, the new matrix should have internal parametrization as similar as possible.                
                <@param>
                    m rows the number of rows the matrix shall have.                    
                </@param>
                <@param>
                    m columns the number of columns the matrix shall have.                    
                </@param>
                <@return>
                    n  a new empty matrix of the same dynamic type.                    
                </@return>
            </javadoc>
            <method name="like" type="DoubleMatrix2D" line="438"/>
            <javadoc line="441">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, entirelly independent of the receiver.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseDoubleMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseDoubleMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="DoubleMatrix1D" line="449"/>
            <javadoc line="452">
                Construct and returns a new 1-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, sharing the same cells.
                 * For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;DenseDoubleMatrix1D&lt;/tt&gt;,
                 * if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt; the new matrix must be of type &lt;tt&gt;SparseDoubleMatrix1D&lt;/tt&gt;, etc.                
                <@param>
                    m size the number of cells the matrix shall have.                    
                </@param>
                <@param>
                    m zero the index of the first element.                    
                </@param>
                <@param>
                    m stride the number of indexes between any two elements, i.e. <tt>index(i+1)-index(i)</tt>.                    
                </@param>
                <@return>
                    n  a new matrix of the corresponding dynamic type.                    
                </@return>
            </javadoc>
            <method name="like1D" type="DoubleMatrix1D" line="462"/>
            <javadoc line="465">
                Sets the matrix cell at coordinate &lt;tt&gt;[row,column]&lt;/tt&gt; to the specified value.
                 * &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                 * &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                 * Precondition (unchecked): &lt;tt&gt;0 &amp;lt;= column &amp;lt; columns() &amp;&amp; 0 &amp;lt;= row &amp;lt; rows()&lt;/tt&gt;.                
                <@param>
                    m row   the index of the row-coordinate.                    
                </@param>
                <@param>
                    m column   the index of the column-coordinate.                    
                </@param>
                <@param>
                    m value the value to be filled into the specified cell.                    
                </@param>
            </javadoc>
            <method name="setQuick" type="void" line="476">
                <comment line="477">
                    if (debug) if (column&lt;0 || column&gt;=columns || row&lt;0 || row&gt;=rows) throw new IndexOutOfBoundsException(&quot;row:&quot;+row+&quot;, column:&quot;+column);                    
                </comment>
                <comment line="477">
                    elements[index(row,column)] = value;                    
                </comment>
                <comment line="477">
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="482">
                Construct and returns a new selection view.                
                <@param>
                    m rowOffsets the offsets of the visible elements.                    
                </@param>
                <@param>
                    m columnOffsets the offsets of the visible elements.                    
                </@param>
                <@return>
                    n  a new view.                    
                </@return>
            </javadoc>
            <method name="viewSelectionLike" type="DoubleMatrix2D" line="489"/>
            <javadoc line="492">
                8 neighbor stencil transformation. For efficient finite difference operations.
                 * Applies a function to a moving &lt;tt&gt;3 x 3&lt;/tt&gt; window.
                 * Does nothing if &lt;tt&gt;rows() &lt; 3 || columns() &lt; 3&lt;/tt&gt;.
                 * &lt;pre&gt;
                 * B[i,j] = function.apply(
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;A[i-1,j-1], A[i-1,j], A[i-1,j+1],
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;A[i,  j-1], A[i,  j], A[i,  j+1],
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;A[i+1,j-1], A[i+1,j], A[i+1,j+1]
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;)
                 * x x x - &amp;nbsp;&amp;nbsp;&amp;nbsp; - x x x &amp;nbsp;&amp;nbsp;&amp;nbsp; - - - - 
                 * x o x - &amp;nbsp;&amp;nbsp;&amp;nbsp; - x o x &amp;nbsp;&amp;nbsp;&amp;nbsp; - - - - 
                 * x x x - &amp;nbsp;&amp;nbsp;&amp;nbsp; - x x x ... - x x x 
                 * - - - - &amp;nbsp;&amp;nbsp;&amp;nbsp; - - - - &amp;nbsp;&amp;nbsp;&amp;nbsp; - x o x 
                 * - - - - &amp;nbsp;&amp;nbsp;&amp;nbsp; - - - - &amp;nbsp;&amp;nbsp;&amp;nbsp; - x x x 
                 * &lt;/pre&gt;
                 * Make sure that cells of &lt;tt&gt;this&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; do not overlap.
                 * In case of overlapping views, behaviour is unspecified.
                 * &lt;/pre&gt;
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * final double alpha = 0.25;
                 * final double beta = 0.75;
                 * // 8 neighbors
                 * cern.colt.function.Double9Function f = new cern.colt.function.Double9Function() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public final double apply(
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a00, double a01, double a02,
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a10, double a11, double a12,
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a20, double a21, double a22) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return beta*a11 + alpha*(a00+a01+a02 + a10+a12 + a20+a21+a22);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * };
                 * A.zAssign8Neighbors(B,f);
                 * // 4 neighbors
                 * cern.colt.function.Double9Function g = new cern.colt.function.Double9Function() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public final double apply(
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a00, double a01, double a02,
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a10, double a11, double a12,
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a20, double a21, double a22) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return beta*a11 + alpha*(a01+a10+a12+a21);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * C.zAssign8Neighbors(B,g); // fast, even though it doesn&apos;t look like it
                 * };
                 * &lt;/pre&gt;                
                <@param>
                    m B the matrix to hold the results.                    
                </@param>
                <@param>
                    m function the function to be applied to the 9 cells.                    
                </@param>
                <@throws>
                    s NullPointerException if <tt>function==null</tt>.                    
                </@throws>
                <@throws>
                    s IllegalArgumentException if <tt>rows() != B.rows() || columns() != B.columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="zAssign8Neighbors" type="void" line="546">
                <comment line="547">
                    1. using only 4-5 out of the 9 cells in &quot;function&quot; is *not* the limiting factor for performance.                    
                </comment>
                <comment line="547">
                    2. if the &quot;function&quot; would be hardwired into the innermost loop, a speedup of 1.5-2.0 would be seen                    
                </comment>
                <comment line="547">
                    but then the multi-purpose interface is gone...                    
                </comment>
                <comment line="547">
                    (rows&lt;3 || columns&lt;3) return; // nothing to do                    
                </comment>
                <scope line="552"/>
                <declaration name="r" type="int" line="558"/>
                <declaration name="c" type="int" line="559"/>
                <declaration name="BB" type="DenseDoubleMatrix2D" line="562"/>
                <declaration name="A_rs" type="int" line="563"/>
                <declaration name="B_rs" type="int" line="564"/>
                <declaration name="A_cs" type="int" line="565"/>
                <declaration name="B_cs" type="int" line="566"/>
                <declaration name="elems" type="double[]" line="567"/>
                <declaration name="B_elems" type="double[]" line="568"/>
                <declaration name="A_index" type="int" line="571"/>
                <declaration name="B_index" type="int" line="572"/>
                <scope line="573">
                    <declaration name="a00" type="double" line="574"/>
                    <declaration name="a10" type="double" line="575"/>
                    <declaration name="a20" type="double" line="576"/>
                    <declaration name="B11" type="int" line="578"/>
                    <declaration name="A02" type="int" line="580"/>
                    <declaration name="A12" type="int" line="581"/>
                    <declaration name="A22" type="int" line="582"/>
                    <scope line="589"/>
                </scope>
            </method>
            <method name="zMult" type="DoubleMatrix1D" line="611">
                <declaration name="yy" type="DenseDoubleMatrix1D" line="619"/>
                <declaration name="zz" type="DenseDoubleMatrix1D" line="620"/>
                <declaration name="AElems" type="double[]" line="621"/>
                <declaration name="yElems" type="double[]" line="622"/>
                <declaration name="zElems" type="double[]" line="623"/>
                <declaration name="As" type="int" line="625"/>
                <declaration name="ys" type="int" line="626"/>
                <declaration name="zs" type="int" line="627"/>
                <declaration name="indexA" type="int" line="629"/>
                <declaration name="indexY" type="int" line="630"/>
                <declaration name="indexZ" type="int" line="631"/>
                <declaration name="cols" type="int" line="633"/>
                <scope line="634">
                    <declaration name="sum" type="double" line="635"/>
                    <declaration name="i" type="int" line="647"/>
                    <declaration name="j" type="int" line="648"/>
                    <scope line="649"/>
                    <scope line="652"/>
                </scope>
            </method>
            <method name="zMult" type="DoubleMatrix2D" line="666">
                <comment line="667">
                    overriden for performance only                    
                </comment>
                <comment line="667">
                    A is blocked to hide memory latency
                    xxxxxxx B                    
                </comment>
                <comment line="667">
                    nal int BLOCK_SIZE = 30000; // * 8 == Level 2 cache in bytes                    
                </comment>
                <comment line="667">
                    if (n+p == 0) return C;                    
                </comment>
                <comment line="667">
                    int m_optimal = (BLOCK_SIZE - n*p) / (n+p);                    
                </comment>
                <scope line="669">
                    <scope line="672"/>
                    <scope line="675"/>
                </scope>
                <declaration name="m" type="int" line="695"/>
                <declaration name="n" type="int" line="696"/>
                <declaration name="p" type="int" line="697"/>
                <declaration name="BB" type="DenseDoubleMatrix2D" line="707"/>
                <declaration name="CC" type="DenseDoubleMatrix2D" line="708"/>
                <declaration name="AElems" type="double[]" line="709"/>
                <declaration name="BElems" type="double[]" line="710"/>
                <declaration name="CElems" type="double[]" line="711"/>
                <declaration name="cA" type="int" line="714"/>
                <declaration name="cB" type="int" line="715"/>
                <declaration name="cC" type="int" line="716"/>
                <declaration name="rA" type="int" line="718"/>
                <declaration name="rB" type="int" line="719"/>
                <declaration name="rC" type="int" line="720"/>
                <declaration name="BLOCK_SIZE" type="int" line="736"/>
                <declaration name="m_optimal" type="int" line="739"/>
                <declaration name="blocks" type="int" line="741"/>
                <declaration name="rr" type="int" line="742"/>
                <scope line="744">
                    <declaration name="jB" type="int" line="745"/>
                    <declaration name="indexA" type="int" line="746"/>
                    <declaration name="jC" type="int" line="747"/>
                    <scope line="751">
                        <declaration name="iA" type="int" line="752"/>
                        <declaration name="iC" type="int" line="753"/>
                        <scope line="754">
                            <declaration name="kA" type="int" line="755"/>
                            <declaration name="kB" type="int" line="756"/>
                            <declaration name="s" type="double" line="757"/>
                            <scope line="773"/>
                            <scope line="776"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="793">
                Returns the sum of all cells; &lt;tt&gt;Sum( x[i,j] )&lt;/tt&gt;.                
                <@return>
                    n the sum.                    
                </@return>
            </javadoc>
            <method name="zSum" type="double" line="797">
                <declaration name="sum" type="double" line="798"/>
                <declaration name="elems" type="double[]" line="799"/>
                <declaration name="index" type="int" line="801"/>
                <declaration name="cs" type="int" line="802"/>
                <declaration name="rs" type="int" line="803"/>
                <scope line="804">
                    <scope line="805"/>
                </scope>
            </method>
        </class>
    </source>