<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.doublealgo">
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.matrix.DoubleFactory2D"/>
        <import package="cern.colt.matrix.DoubleFactory3D"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <import package="cern.colt.matrix.DoubleMatrix3D"/>
        <import package="cern.colt.matrix.impl.DenseDoubleMatrix1D"/>
        <class name="Sorting" extends="cern.colt.PersistentObject" line="18">
            <comment line="19">
                blic static final Sorting quickSort = new Sorting(); // already has quicksort implemented                
            </comment>
            <javadoc line="18">
                Matrix quicksorts and mergesorts.
                 * Use idioms like &lt;tt&gt;Sorting.quickSort.sort(...)&lt;/tt&gt; and &lt;tt&gt;Sorting.mergeSort.sort(...)&lt;/tt&gt;.
                 * &lt;p&gt;
                 * This is another case demonstrating one primary goal of this library: Delivering easy to use, yet very efficient APIs.
                 * The sorts return convenient &lt;i&gt;sort views&lt;/i&gt;.
                 * This enables the usage of algorithms which scale well with the problem size:
                 * For example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix.
                 * This is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices.
                 * The original matrix is left unaffected.
                 * &lt;p&gt;
                 * The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in turn, based on Bentley&apos;s and McIlroy&apos;s fine work).
                 * The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
                 * Mergesort is &lt;i&gt;stable&lt;/i&gt; (by definition), while quicksort is not.
                 * A stable sort is, for example, helpful, if matrices are sorted successively 
                 * by multiple columns. It preserves the relative position of equal elements.                
                <@see>
                    e cern.colt.GenericSorting                    
                </@see>
                <@see>
                    e cern.colt.Sorting                    
                </@see>
                <@see>
                    e java.util.Arrays                    
                </@see>
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.1, 25/May/2000                    
                </@version>
            </javadoc>
            <declaration name="quickSort" type="Sorting" line="43"/>
            <javadoc line="43">
                A prefabricated quicksort.                
            </javadoc>
            <declaration name="mergeSort" type="Sorting" line="48"/>
            <javadoc line="48">
                A prefabricated mergesort.                
            </javadoc>
            <anonymous_class line="51">
                <method name="runSort" type="void" line="52"/>
                <method name="runSort" type="void" line="55"/>
            </anonymous_class>
            <javadoc line="59">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Sorting" type="constructor" line="62"/>
            <javadoc line="63">
                Compare two values, one of which is assumed to be Double.NaN                
            </javadoc>
            <method name="compareNaN" type="int" line="66">
                <comment line="67">
                    turn -1; // e.g. 5 &lt; NaN                    
                </comment>
                <scope line="67"/>
            </method>
            <method name="runSort" type="void" line="73"/>
            <method name="runSort" type="void" line="76"/>
            <javadoc line="79">
                Sorts the vector into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt;.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt; 7, 1, 3, 1&lt;br&gt;
                 * &lt;/tt&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt; 
                 * &lt;p&gt;&lt;tt&gt; ==&amp;gt; 1, 1, 3, 7&lt;br&gt;
                 * The vector IS NOT SORTED.&lt;br&gt;
                 * The new VIEW IS SORTED.&lt;/tt&gt;&lt;/p&gt;
                 * &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@param>
                    m vector the vector to be sorted.                    
                </@param>
                <@return>
                    n a new sorted vector (matrix) view. 
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
            </javadoc>
            <method name="sort" type="DoubleMatrix1D" line="101">
                <comment line="102">
                    t[] indexes = new int[vector.size()]; // row indexes to reorder instead of matrix itself                    
                </comment>
                <declaration name="indexes" type="int[]" line="102"/>
                <anonymous_class line="105">
                    <method name="compare" type="int" line="106">
                        <comment line="107">
                            (av!=av || bv!=bv) return compareNaN(av,bv); // swap NaNs to the end                            
                        </comment>
                        <declaration name="av" type="double" line="107"/>
                        <declaration name="bv" type="double" line="108"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="105"/>
            </method>
            <javadoc line="118">
                Sorts the vector into ascending order, according to the order induced by the specified comparator.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * The algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other.
                 * To sort ranges use sub-ranging views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // sort by sinus of cells
                 * DoubleComparator comp = new DoubleComparator() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(double a, double b) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double as = Math.sin(a); double bs = Math.sin(b);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * };
                 * sorted = quickSort(vector,comp);
                 * &lt;/pre&gt;                
                <@param>
                    m vector the vector to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order.                    
                </@param>
                <@return>
                    n a new matrix view sorted as specified.
                     * <b>Note that the original vector (matrix) is left unaffected.</b>                    
                </@return>
            </javadoc>
            <method name="sort" type="DoubleMatrix1D" line="141">
                <comment line="142">
                    t[] indexes = new int[vector.size()]; // row indexes to reorder instead of matrix itself                    
                </comment>
                <declaration name="indexes" type="int[]" line="142"/>
                <anonymous_class line="145">
                    <method name="compare" type="int" line="146"/>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="145"/>
            </method>
            <javadoc line="155">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the virtual column &lt;tt&gt;aggregates&lt;/tt&gt;;
                 * Particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts.
                 * Essentially, this algorithm makes expensive comparisons cheap.
                 * Normally each element of &lt;tt&gt;aggregates&lt;/tt&gt; is a summary measure of a row.
                 * Speedup over comparator based sorting = &lt;tt&gt;2*log(rows)&lt;/tt&gt;, on average.
                 * For this operation, quicksort is usually faster.
                 * &lt;p&gt;
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * Each aggregate is the sum of a row
                 * &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
                 * 1, 1&lt;br&gt;
                 * 5, 4&lt;br&gt;
                 * 3, 0&lt;br&gt;
                 * 4, 4 &lt;br&gt;
                 * &lt;/tt&gt;&lt;/td&gt;
                 * &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                 * &lt;tt&gt;aggregates=&lt;br&gt;
                 * 2&lt;br&gt;
                 * 9&lt;br&gt;
                 * 3&lt;br&gt;
                 * 8&lt;br&gt;
                 * ==&gt;&lt;/tt&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt; 
                 * &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
                 * 1, 1&lt;br&gt;
                 * 3, 0&lt;br&gt;
                 * 4, 4&lt;br&gt;
                 * 5, 4&lt;/tt&gt;&lt;br&gt;
                 * The matrix IS NOT SORTED.&lt;br&gt;
                 * The new VIEW IS SORTED.&lt;/p&gt;
                 * &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;
                 * &lt;table&gt;
                 * &lt;td class=&quot;PRE&quot;&gt; 
                 * &lt;pre&gt;
                 * // sort 10000 x 1000 matrix by sum of logarithms in a row (i.e. by geometric mean)
                 * DoubleMatrix2D matrix = new DenseDoubleMatrix2D(10000,1000);
                 * matrix.assign(new cern.jet.random.engine.MersenneTwister()); // initialized randomly
                 * cern.jet.math.Functions F = cern.jet.math.Functions.functions; // alias for convenience
                 * // THE QUICK VERSION (takes some 3 secs)
                 * // aggregates[i] = Sum(log(row));
                 * double[] aggregates = new double[matrix.rows()];
                 * for (int i = matrix.rows(); --i &gt;= 0; ) aggregates[i] = matrix.viewRow(i).aggregate(F.plus, F.log);
                 * DoubleMatrix2D sorted = quickSort(matrix,aggregates);
                 * // THE SLOW VERSION (takes some 90 secs)
                 * DoubleMatrix1DComparator comparator = new DoubleMatrix1DComparator() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix1D x, DoubleMatrix1D y) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a = x.aggregate(F.plus,F.log);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double b = y.aggregate(F.plus,F.log);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return a &lt; b ? -1 : a==b ? 0 : 1;
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * };
                 * DoubleMatrix2D sorted = quickSort(matrix,comparator);
                 * &lt;/pre&gt;
                 * &lt;/td&gt;
                 * &lt;/table&gt;                
                <@param>
                    m matrix the matrix to be sorted.                    
                </@param>
                <@param>
                    m aggregates the values to sort on. (As a side effect, this array will also get sorted).                    
                </@param>
                <@return>
                    n a new matrix view having rows sorted.
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>aggregates.length != matrix.rows()</tt>.                    
                </@throws>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="228">
                <comment line="229">
                    set up index reordering                    
                </comment>
                <comment line="229">
                    compares two aggregates at a time                    
                </comment>
                <comment line="229">
                    swaps aggregates and reorders indexes                    
                </comment>
                <comment line="229">
                    sort indexes and aggregates                    
                </comment>
                <comment line="229">
                    view the matrix according to the reordered row indexes                    
                </comment>
                <comment line="229">
                    take all columns in the original order                    
                </comment>
                <declaration name="rows" type="int" line="229"/>
                <declaration name="indexes" type="int[]" line="233"/>
                <anonymous_class line="237">
                    <method name="compare" type="int" line="238">
                        <comment line="239">
                            (a!=a || b!=b) return compareNaN(a,b); // swap NaNs to the end                            
                        </comment>
                        <declaration name="a" type="double" line="239"/>
                        <declaration name="b" type="double" line="240"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.IntComparator" line="237"/>
                <anonymous_class line="246">
                    <method name="swap" type="void" line="247">
                        <declaration name="t1" type="int" line="248"/>
                        <declaration name="t2" type="double" line="248"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="246"/>
            </method>
            <javadoc line="261">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given column.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt; 
                 * &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
                 * 7, 6&lt;br&gt;
                 * 5, 4&lt;br&gt;
                 * 3, 2&lt;br&gt;
                 * 1, 0 &lt;br&gt;
                 * &lt;/tt&gt;&lt;/td&gt;
                 * &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                 * &lt;p&gt;&lt;tt&gt;column = 0;&lt;br&gt;
                 * view = quickSort(matrix,column);&lt;br&gt;
                 * System.out.println(view); &lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
                 * ==&gt; &lt;/tt&gt;&lt;/p&gt;
                 * &lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt; 
                 * &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
                 * 1, 0&lt;br&gt;
                 * 3, 2&lt;br&gt;
                 * 5, 4&lt;br&gt;
                 * 7, 6&lt;/tt&gt;&lt;br&gt;
                 * The matrix IS NOT SORTED.&lt;br&gt;
                 * The new VIEW IS SORTED.&lt;/p&gt;
                 * &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;                
                <@param>
                    m matrix the matrix to be sorted.                    
                </@param>
                <@param>
                    m column the index of the column inducing the order.                    
                </@param>
                <@return>
                    n a new matrix view having rows sorted by the given column.
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>column < 0 || column >= matrix.columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="299">
                <comment line="300">
                    t[] rowIndexes = new int[matrix.rows()]; // row indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="300">
                    view the matrix according to the reordered row indexes                    
                </comment>
                <comment line="300">
                    take all columns in the original order                    
                </comment>
                <declaration name="rowIndexes" type="int[]" line="302"/>
                <declaration name="col" type="DoubleMatrix1D" line="305"/>
                <anonymous_class line="306">
                    <method name="compare" type="int" line="307">
                        <comment line="308">
                            (av!=av || bv!=bv) return compareNaN(av,bv); // swap NaNs to the end                            
                        </comment>
                        <declaration name="av" type="double" line="308"/>
                        <declaration name="bv" type="double" line="309"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="306"/>
            </method>
            <javadoc line="321">
                Sorts the matrix rows according to the order induced by the specified comparator.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * The algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
                 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // sort by sum of values in a row
                 * DoubleMatrix1DComparator comp = new DoubleMatrix1DComparator() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix1D a, DoubleMatrix1D b) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double as = a.zSum(); double bs = b.zSum();
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * };
                 * sorted = quickSort(matrix,comp);
                 * &lt;/pre&gt;                
                <@param>
                    m matrix the matrix to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order.                    
                </@param>
                <@return>
                    n a new matrix view having rows sorted as specified.
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="344">
                <comment line="345">
                    t[] rowIndexes = new int[matrix.rows()]; // row indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="345">
                    nal DoubleMatrix1D[] views = new DoubleMatrix1D[matrix.rows()]; // precompute views for speed                    
                </comment>
                <comment line="345">
                    view the matrix according to the reordered row indexes                    
                </comment>
                <comment line="345">
                    take all columns in the original order                    
                </comment>
                <declaration name="rowIndexes" type="int[]" line="345"/>
                <declaration name="views" type="DoubleMatrix1D[]" line="348"/>
                <anonymous_class line="351">
                    <method name="compare" type="int" line="352">
                        <comment line="353">
                            return c.compare(matrix.viewRow(a), matrix.viewRow(b));                            
                        </comment>
                        <comment line="518">
                            return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));                            
                        </comment>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="351"/>
            </method>
            <javadoc line="364">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the values computed by applying the given aggregation function to each row;
                 * Particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts.
                 * Essentially, this algorithm makes expensive comparisons cheap.
                 * Normally &lt;tt&gt;aggregates&lt;/tt&gt; defines a summary measure of a row.
                 * Speedup over comparator based sorting = &lt;tt&gt;2*log(rows)&lt;/tt&gt;, on average.
                 * &lt;p&gt;
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * Each aggregate is the sum of a row
                 * &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                 * &lt;tr nowrap&gt; 
                 * &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
                 * 1, 1&lt;br&gt;
                 * 5, 4&lt;br&gt;
                 * 3, 0&lt;br&gt;
                 * 4, 4 &lt;br&gt;
                 * &lt;/tt&gt;&lt;/td&gt;
                 * &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                 * &lt;tt&gt;aggregates=&lt;br&gt;
                 * hep.aida.bin.BinFunctions1D.sum&lt;br&gt;
                 * ==&gt;&lt;/tt&gt;&lt;/td&gt;
                 * &lt;td valign=&quot;top&quot;&gt; 
                 * &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
                 * 1, 1&lt;br&gt;
                 * 3, 0&lt;br&gt;
                 * 4, 4&lt;br&gt;
                 * 5, 4&lt;/tt&gt;&lt;br&gt;
                 * The matrix IS NOT SORTED.&lt;br&gt;
                 * The new VIEW IS SORTED.&lt;/p&gt;
                 * &lt;/td&gt;
                 * &lt;/tr&gt;
                 * &lt;/table&gt;
                 * &lt;table&gt;
                 * &lt;td class=&quot;PRE&quot;&gt; 
                 * &lt;pre&gt;
                 * // sort 10000 x 1000 matrix by median or by sum of logarithms in a row (i.e. by geometric mean)
                 * DoubleMatrix2D matrix = new DenseDoubleMatrix2D(10000,1000);
                 * matrix.assign(new cern.jet.random.engine.MersenneTwister()); // initialized randomly
                 * cern.jet.math.Functions F = cern.jet.math.Functions.functions; // alias for convenience
                 * // THE QUICK VERSION (takes some 10 secs)
                 * DoubleMatrix2D sorted = quickSort(matrix,hep.aida.bin.BinFunctions1D.median);
                 * //DoubleMatrix2D sorted = quickSort(matrix,hep.aida.bin.BinFunctions1D.sumOfLogarithms);
                 * // THE SLOW VERSION (takes some 300 secs)
                 * DoubleMatrix1DComparator comparator = new DoubleMatrix1DComparator() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix1D x, DoubleMatrix1D y) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a = cern.colt.matrix.doublealgo.Statistic.bin(x).median();
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double b = cern.colt.matrix.doublealgo.Statistic.bin(y).median();
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// double a = x.aggregate(F.plus,F.log);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// double b = y.aggregate(F.plus,F.log);
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return a &lt; b ? -1 : a==b ? 0 : 1;
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * };
                 * DoubleMatrix2D sorted = quickSort(matrix,comparator);
                 * &lt;/pre&gt;
                 * &lt;/td&gt;
                 * &lt;/table&gt;                
                <@param>
                    m matrix the matrix to be sorted.                    
                </@param>
                <@param>
                    m aggregate the function to sort on; aggregates values in a row.                    
                </@param>
                <@return>
                    n a new matrix view having rows sorted.
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="432">
                <comment line="433">
                    precompute aggregates over rows, as defined by &quot;aggregate&quot;                    
                </comment>
                <comment line="433">
                    a bit clumsy, because Statistic.aggregate(...) is defined on columns, so we need to transpose views                    
                </comment>
                <declaration name="tmp" type="DoubleMatrix2D" line="436"/>
                <declaration name="func" type="hep.aida.bin.BinFunction1D[]" line="437"/>
                <declaration name="aggr" type="double[]" line="439"/>
            </method>
            <javadoc line="442">
                Sorts the matrix slices into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given &lt;tt&gt;[row,column]&lt;/tt&gt; position.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * The algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other.
                 * Comparison is based on the cell &lt;tt&gt;[row,column]&lt;/tt&gt; within a slice.
                 * Let &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; be two 2-d slices. Then we have the following rules
                 * &lt;ul&gt;
                 * &lt;li&gt;&lt;tt&gt;A &amp;lt;  B  iff A.get(row,column) &amp;lt;  B.get(row,column)&lt;/tt&gt;
                 * &lt;li&gt;&lt;tt&gt;A == B iff A.get(row,column) == B.get(row,column)&lt;/tt&gt;
                 * &lt;li&gt;&lt;tt&gt;A &amp;gt;  B  iff A.get(row,column) &amp;gt;  B.get(row,column)&lt;/tt&gt;
                 * &lt;/ul&gt;                
                <@param>
                    m matrix the matrix to be sorted.                    
                </@param>
                <@param>
                    m row the index of the row inducing the order.                    
                </@param>
                <@param>
                    m column the index of the column inducing the order.                    
                </@param>
                <@return>
                    n a new matrix view having slices sorted by the values of the slice view <tt>matrix.viewRow(row).viewColumn(column)</tt>.
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
                <@throws>
                    s IndexOutOfBoundsException if <tt>row < 0 || row >= matrix.rows() || column < 0 || column >= matrix.columns()</tt>.                    
                </@throws>
            </javadoc>
            <method name="sort" type="DoubleMatrix3D" line="463">
                <comment line="464">
                    t[] sliceIndexes = new int[matrix.slices()]; // indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="464">
                    view the matrix according to the reordered slice indexes                    
                </comment>
                <comment line="464">
                    take all rows and columns in the original order                    
                </comment>
                <declaration name="sliceIndexes" type="int[]" line="467"/>
                <declaration name="sliceView" type="DoubleMatrix1D" line="470"/>
                <anonymous_class line="471">
                    <method name="compare" type="int" line="472">
                        <comment line="473">
                            (av!=av || bv!=bv) return compareNaN(av,bv); // swap NaNs to the end                            
                        </comment>
                        <declaration name="av" type="double" line="473"/>
                        <declaration name="bv" type="double" line="474"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="471"/>
            </method>
            <javadoc line="486">
                Sorts the matrix slices according to the order induced by the specified comparator.
                 * The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                 * The algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
                 * To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;pre&gt;
                 * // sort by sum of values in a slice
                 * DoubleMatrix2DComparator comp = new DoubleMatrix2DComparator() {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix2D a, DoubleMatrix2D b) {
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double as = a.zSum(); double bs = b.zSum();
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
                 * &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                 * };
                 * sorted = quickSort(matrix,comp);
                 * &lt;/pre&gt;                
                <@param>
                    m matrix the matrix to be sorted.                    
                </@param>
                <@param>
                    m c the comparator to determine the order.                    
                </@param>
                <@return>
                    n a new matrix view having slices sorted as specified.
                     * <b>Note that the original matrix is left unaffected.</b>                    
                </@return>
            </javadoc>
            <method name="sort" type="DoubleMatrix3D" line="509">
                <comment line="510">
                    t[] sliceIndexes = new int[matrix.slices()]; // indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="510">
                    nal DoubleMatrix2D[] views = new DoubleMatrix2D[matrix.slices()]; // precompute views for speed                    
                </comment>
                <comment line="510">
                    view the matrix according to the reordered slice indexes                    
                </comment>
                <comment line="510">
                    take all rows and columns in the original order                    
                </comment>
                <declaration name="sliceIndexes" type="int[]" line="510"/>
                <declaration name="views" type="DoubleMatrix2D[]" line="513"/>
                <anonymous_class line="516">
                    <method name="compare" type="int" line="517">
                        <comment line="353">
                            return c.compare(matrix.viewRow(a), matrix.viewRow(b));                            
                        </comment>
                        <comment line="518">
                            return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));                            
                        </comment>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="516"/>
            </method>
            <javadoc line="529">
                Demonstrates advanced sorting.
                 * Sorts by sum of row.                
            </javadoc>
            <method name="zdemo1" type="void" line="533">
                <declaration name="sort" type="Sorting" line="534"/>
                <declaration name="matrix" type="DoubleMatrix2D" line="535"/>
                <anonymous_class line="536">
                    <method name="compare" type="int" line="537">
                        <declaration name="as" type="double" line="538"/>
                        <declaration name="bs" type="double" line="538"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="DoubleMatrix1DComparator" line="536"/>
            </method>
            <javadoc line="545">
                Demonstrates advanced sorting.
                 * Sorts by sum of slice.                
            </javadoc>
            <method name="zdemo2" type="void" line="549">
                <declaration name="sort" type="Sorting" line="550"/>
                <declaration name="matrix" type="DoubleMatrix3D" line="551"/>
                <anonymous_class line="552">
                    <method name="compare" type="int" line="553">
                        <declaration name="as" type="double" line="554"/>
                        <declaration name="bs" type="double" line="555"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="DoubleMatrix2DComparator" line="552"/>
            </method>
            <javadoc line="562">
                Demonstrates advanced sorting.
                 * Sorts by sinus of cell values.                
            </javadoc>
            <method name="zdemo3" type="void" line="566">
                <comment line="567">
                    check whether it is really sorted                    
                </comment>
                <comment line="567">
                    sorted.assign(                    
                </comment>
                <declaration name="sort" type="Sorting" line="567"/>
                <declaration name="values" type="double[]" line="568"/>
                <declaration name="matrix" type="DoubleMatrix1D" line="569"/>
                <anonymous_class line="570">
                    <method name="compare" type="int" line="571">
                        <declaration name="as" type="double" line="572"/>
                        <declaration name="bs" type="double" line="572"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.DoubleComparator" line="570"/>
                <declaration name="sorted" type="DoubleMatrix1D" line="578"/>
            </method>
            <javadoc line="592">
                Demonstrates applying functions.                
            </javadoc>
            <method name="zdemo4" type="void" line="595">
                <comment line="596">
                    matrix1.assign(matrix2,                    
                </comment>
                <declaration name="values1" type="double[]" line="596"/>
                <declaration name="values2" type="double[]" line="597"/>
                <declaration name="matrix1" type="DoubleMatrix1D" line="598"/>
                <declaration name="matrix2" type="DoubleMatrix1D" line="599"/>
            </method>
            <javadoc line="615">
                Demonstrates sorting with precomputation of aggregates (median and sum of logarithms).                
            </javadoc>
            <method name="zdemo5" type="void" line="618">
                <comment line="619">
                    for reliable benchmarks, call this method twice: once with small dummy parameters to &quot;warm up&quot; the jitter, then with your real work-load                    
                </comment>
                <comment line="619">
                    assign(new cern.jet.random.engine.DRand()); // initialize randomly                    
                </comment>
                <comment line="619">
                    also benchmark copying in its several implementation flavours                    
                </comment>
                <comment line="619">
                    System.out.println(A);                    
                </comment>
                <comment line="619">
                    THE QUICK VERSION (takes some 10 secs)                    
                </comment>
                <comment line="619">
                    A = sort.sort(A,hep.aida.bin.BinFunctions1D.sumLog);                    
                </comment>
                <comment line="619">
                    check results for correctness                    
                </comment>
                <comment line="619">
                    WARNING: be sure NOT TO PRINT huge matrices unless you have tons of main memory and time!!                    
                </comment>
                <comment line="619">
                    so we just show the first 5 rows                    
                </comment>
                <declaration name="sort" type="Sorting" line="619"/>
                <declaration name="timer" type="cern.colt.Timer" line="624"/>
                <declaration name="F" type="cern.jet.math.Functions" line="626"/>
                <declaration name="A" type="DoubleMatrix2D" line="627"/>
                <declaration name="B" type="DoubleMatrix2D" line="632"/>
                <scope line="659">
                    <declaration name="r" type="int" line="660"/>
                    <declaration name="funs" type="hep.aida.bin.BinFunction1D[]" line="661"/>
                    <declaration name="rowNames" type="String[]" line="662"/>
                    <declaration name="columnNames" type="String[]" line="663"/>
                </scope>
                <anonymous_class line="674">
                    <method name="compare" type="int" line="675">
                        <comment line="676">
                            double a = x.aggregate(F.plus,F.log);                            
                        </comment>
                        <comment line="676">
                            double b = y.aggregate(F.plus,F.log);                            
                        </comment>
                        <declaration name="a" type="double" line="676"/>
                        <declaration name="b" type="double" line="677"/>
                    </method>
                </anonymous_class>
                <declaration name="fun" type="cern.colt.matrix.doublealgo.DoubleMatrix1DComparator" line="674"/>
            </method>
            <javadoc line="687">
                Demonstrates advanced sorting.
                 * Sorts by sum of row.                
            </javadoc>
            <method name="zdemo6" type="void" line="691">
                <comment line="692">
                    DoubleMatrix1DComparator comp = new DoubleMatrix1DComparator() {
                    public int compare(DoubleMatrix1D a, DoubleMatrix1D b) {                    
                </comment>
                <declaration name="sort" type="Sorting" line="692"/>
                <declaration name="values" type="double[][]" line="693"/>
                <declaration name="A" type="DoubleMatrix2D" line="705"/>
                <declaration name="B" type="DoubleMatrix2D" line="706"/>
            </method>
            <javadoc line="725">
                Demonstrates sorting with precomputation of aggregates, comparing mergesort with quicksort.                
            </javadoc>
            <method name="zdemo7" type="void" line="728">
                <comment line="729">
                    for reliable benchmarks, call this method twice: once with small dummy parameters to &quot;warm up&quot; the jitter, then with your real work-load                    
                </comment>
                <comment line="729">
                    assign(new cern.jet.random.engine.DRand()); // initialize randomly                    
                </comment>
                <declaration name="F" type="cern.jet.math.Functions" line="734"/>
                <declaration name="A" type="DoubleMatrix2D" line="735"/>
                <declaration name="B" type="DoubleMatrix2D" line="737"/>
                <declaration name="v1" type="double[]" line="739"/>
                <declaration name="v2" type="double[]" line="740"/>
                <declaration name="timer" type="cern.colt.Timer" line="742"/>
            </method>
        </class>
    </source>