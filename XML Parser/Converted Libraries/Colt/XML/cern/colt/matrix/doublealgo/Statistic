<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.doublealgo">
        <import package="hep.aida.bin.DynamicBin1D"/>
        <import package="cern.colt.function.DoubleDoubleFunction"/>
        <import package="cern.colt.matrix.DoubleFactory1D"/>
        <import package="cern.colt.matrix.DoubleFactory2D"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <import package="cern.colt.matrix.DoubleMatrix3D"/>
        <import package="cern.jet.random.engine.RandomEngine"/>
        <class name="Statistic" line="19">
            <extends class="Object"/>
            <javadoc line="19">
                Basic statistics operations on matrices.
                  Computation of covariance, correlation, distance matrix.
                  Random sampling views.
                  Conversion to histograms with and without OLAP cube operators.
                  Conversion to bins with retrieval of statistical bin measures.
                  Also see {@link cern.jet.stat} and {@link hep.aida.bin}, in particular {@link hep.aida.bin.DynamicBin1D}.
                  &lt;p&gt;
                  Examples:
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; dwcopytype=&quot;CopyTableRow&quot;&gt;
                  &lt;tr valign=&quot;top&quot; align=&quot;center&quot;&gt; 
                  &lt;td&gt;&lt;tt&gt;A&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;covariance(A)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;correlation(covariance(A))&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;distance(A,EUCLID)&lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;top&quot;&gt; 
                  &lt;td&gt;&lt;tt&gt; 4&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
                  1&amp;nbsp;&amp;nbsp;2&amp;nbsp;&amp;nbsp;&amp;nbsp;3&lt;br&gt;
                  2&amp;nbsp;&amp;nbsp;4&amp;nbsp;&amp;nbsp;&amp;nbsp;6&lt;br&gt;
                  3&amp;nbsp;&amp;nbsp;6&amp;nbsp;&amp;nbsp;&amp;nbsp;9&lt;br&gt;
                  4&amp;nbsp;-8&amp;nbsp;-10 &lt;/tt&gt; &lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt; 3&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
                  &amp;nbsp;1.25&amp;nbsp;-3.5&amp;nbsp;-4.5&lt;br&gt;
                  -3.5&amp;nbsp;&amp;nbsp;29&amp;nbsp;&amp;nbsp;&amp;nbsp;39&amp;nbsp;&amp;nbsp;&lt;br&gt;
                  -4.5&amp;nbsp;&amp;nbsp;39&amp;nbsp;&amp;nbsp;&amp;nbsp;52.5 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt; 3&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
                  &amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-0.581318&amp;nbsp;-0.555492&lt;br&gt;
                  -0.581318&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.999507&lt;br&gt;
                  -0.555492&amp;nbsp;&amp;nbsp;0.999507&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
                  &lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt; 3&amp;nbsp;x&amp;nbsp;3&amp;nbsp;matrix&lt;br&gt;
                  &amp;nbsp;0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;12.569805&amp;nbsp;15.874508&lt;br&gt;
                  12.569805&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4.242641&lt;br&gt;
                  15.874508&amp;nbsp;&amp;nbsp;4.242641&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
                  &lt;/tt&gt; &lt;tt&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <declaration name="F" type="cern.jet.math.Functions" line="62"/>
            <declaration name="EUCLID" type="VectorVectorFunction" line="63"/>
            <javadoc line="63">
                Euclidean distance function; &lt;tt&gt;Sqrt(Sum( (x[i]-y[i])^2 ))&lt;/tt&gt;.                
            </javadoc>
            <anonymous_class line="66">
                <method name="apply" type="double" line="67">
                    <params>
                        <param name="a" type="DoubleMatrix1D"/>
                        <param name="b" type="DoubleMatrix1D"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="BRAY_CURTIS" type="VectorVectorFunction" line="72"/>
            <javadoc line="72">
                Bray-Curtis distance function; &lt;tt&gt;Sum( abs(x[i]-y[i]) )  /  Sum( x[i]+y[i] )&lt;/tt&gt;.                
            </javadoc>
            <anonymous_class line="75">
                <method name="apply" type="double" line="76">
                    <params>
                        <param name="a" type="DoubleMatrix1D"/>
                        <param name="b" type="DoubleMatrix1D"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="CANBERRA" type="VectorVectorFunction" line="81"/>
            <javadoc line="81">
                Canberra distance function; &lt;tt&gt;Sum( abs(x[i]-y[i]) / abs(x[i]+y[i]) )&lt;/tt&gt;.                
            </javadoc>
            <anonymous_class line="84">
                <declaration name="fun" type="DoubleDoubleFunction" line="85"/>
                <anonymous_class line="85">
                    <method name="apply" type="double" line="86">
                        <params>
                            <param name="a" type="double"/>
                            <param name="b" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
                <method name="apply" type="double" line="90">
                    <params>
                        <param name="a" type="DoubleMatrix1D"/>
                        <param name="b" type="DoubleMatrix1D"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="MAXIMUM" type="VectorVectorFunction" line="95"/>
            <javadoc line="95">
                Maximum distance function; &lt;tt&gt;Max( abs(x[i]-y[i]) )&lt;/tt&gt;.                
            </javadoc>
            <anonymous_class line="98">
                <method name="apply" type="double" line="99">
                    <params>
                        <param name="a" type="DoubleMatrix1D"/>
                        <param name="b" type="DoubleMatrix1D"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="MANHATTAN" type="VectorVectorFunction" line="104"/>
            <javadoc line="104">
                Manhattan distance function; &lt;tt&gt;Sum( abs(x[i]-y[i]) )&lt;/tt&gt;.                
            </javadoc>
            <anonymous_class line="107">
                <method name="apply" type="double" line="108">
                    <params>
                        <param name="a" type="DoubleMatrix1D"/>
                        <param name="b" type="DoubleMatrix1D"/>
                    </params>
                </method>
            </anonymous_class>
            <interface name="VectorVectorFunction">
                <javadoc line="116">
                    Interface that represents a function object: a function that takes 
                      two argument vectors and returns a single value.                    
                </javadoc>
                <method name="apply" type="double" line="121"/>
                <javadoc line="121">
                    Applies a function to two argument vectors.                    
                    <@param>
                        m x   the first argument vector passed to the function.                        
                    </@param>
                    <@param>
                        m y   the second argument vector passed to the function.                        
                    </@param>
                    <@return>
                        n the result of the function.                        
                    </@return>
                </javadoc>
            </interface>
            <javadoc line="131">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Statistic" type="constructor" line="134"/>
            <javadoc line="135">
                Applies the given aggregation functions to each column and stores the results in a the result matrix.
                  If matrix has shape &lt;tt&gt;m x n&lt;/tt&gt;, then result must have shape &lt;tt&gt;aggr.length x n&lt;/tt&gt;.
                  Tip: To do aggregations on rows use dice views (transpositions), as in &lt;tt&gt;aggregate(matrix.viewDice(),aggr,result.viewDice())&lt;/tt&gt;.                
                <@param>
                    m matrix any matrix; a column holds the values of a given variable.                    
                </@param>
                <@param>
                    m aggr the aggregation functions to be applied to each column.                    
                </@param>
                <@param>
                    m result the matrix to hold the aggregation results.                    
                </@param>
                <@return>
                    n <tt>result</tt> (for convenience only).                    
                </@return>
                <@see>
                    e Formatter                    
                </@see>
                <@see>
                    e hep.aida.bin.BinFunction1D                    
                </@see>
                <@see>
                    e hep.aida.bin.BinFunctions1D                    
                </@see>
            </javadoc>
            <method name="aggregate" type="DoubleMatrix2D" line="148">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="aggr" type="hep.aida.bin.BinFunction1D[]"/>
                    <param name="result" type="DoubleMatrix2D"/>
                </params>
                <declaration name="bin" type="DynamicBin1D" line="149"/>
                <declaration name="elements" type="double[]" line="150"/>
                <declaration name="values" type="cern.colt.list.DoubleArrayList" line="151"/>
                <scope line="152">
                    <scope line="156"/>
                </scope>
            </method>
            <javadoc line="162">
                Fills all cell values of the given vector into a bin from which statistics measures can be retrieved efficiently.
                  Cells values are copied.
                  &lt;br&gt;
                  Tip: Use &lt;tt&gt;System.out.println(bin(vector))&lt;/tt&gt; to print most measures computed by the bin. Example:
                  &lt;table&gt;
                  &lt;td class=&quot;PRE&quot;&gt; 
                  &lt;pre&gt;
                  Size: 20000
                  Sum: 299858.02350278624
                  SumOfSquares: 5399184.154095971
                  Min: 0.8639113139711261
                  Max: 59.75331890541892
                  Mean: 14.992901175139313
                  RMS: 16.43043540825375
                  Variance: 45.17438077634358
                  Standard deviation: 6.721188940681818
                  Standard error: 0.04752598277592142
                  Geometric mean: 13.516615397064466
                  Product: Infinity
                  Harmonic mean: 11.995174297952191
                  Sum of inversions: 1667.337172700724
                  Skew: 0.8922838940067878
                  Kurtosis: 1.1915828121825598
                  Sum of powers(3): 1.1345828465808412E8
                  Sum of powers(4): 2.7251055344494686E9
                  Sum of powers(5): 7.367125643433887E10
                  Sum of powers(6): 2.215370909100143E12
                  Moment(0,0): 1.0
                  Moment(1,0): 14.992901175139313
                  Moment(2,0): 269.95920770479853
                  Moment(3,0): 5672.914232904206
                  Moment(4,0): 136255.27672247344
                  Moment(5,0): 3683562.8217169433
                  Moment(6,0): 1.1076854545500715E8
                  Moment(0,mean()): 1.0
                  Moment(1,mean()): -2.0806734113421045E-14
                  Moment(2,mean()): 45.172122057305664
                  Moment(3,mean()): 270.92018671421
                  Moment(4,mean()): 8553.8664869067
                  Moment(5,mean()): 153357.41712233616
                  Moment(6,mean()): 4273757.570142922
                  25%, 50% and 75% Quantiles: 10.030074811938091, 13.977982089912224,
                  18.86124362967137
                  quantileInverse(mean): 0.559163335012079
                  Distinct elements &amp; frequencies not printed (too many).
                  &lt;/pre&gt;
                  &lt;/td&gt;
                  &lt;/table&gt;                
                <@param>
                    m vector the vector to analyze.                    
                </@param>
                <@return>
                    n a bin holding the statistics measures of the vector.                    
                </@return>
            </javadoc>
            <method name="bin" type="DynamicBin1D" line="215">
                <params>
                    <param name="vector" type="DoubleMatrix1D"/>
                </params>
                <declaration name="bin" type="DynamicBin1D" line="216"/>
            </method>
            <javadoc line="220">
                Modifies the given covariance matrix to be a correlation matrix (in-place).
                  The correlation matrix is a square, symmetric matrix consisting of nothing but correlation coefficients.
                  The rows and the columns represent the variables, the cells represent correlation coefficients. 
                  The diagonal cells (i.e. the correlation between a variable and itself) will equal 1, for the simple reason that the correlation coefficient of a variable with itself equals 1. 
                  The correlation of two column vectors x and y is given by &lt;tt&gt;corr(x,y) = cov(x,y) / (stdDev(x)stdDev(y))&lt;/tt&gt; (Pearson&apos;s correlation coefficient).
                  A correlation coefficient varies between -1 (for a perfect negative relationship) to +1 (for a perfect positive relationship). 
                  See the &lt;A HREF=&quot;http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html&quot;&gt; math definition&lt;/A&gt;
                  and &lt;A HREF=&quot;http://www.stat.berkeley.edu/users/stark/SticiGui/Text/gloss.htm#correlation_coef&quot;&gt; another def&lt;/A&gt;.
                  Compares two column vectors at a time. Use dice views to compare two row vectors at a time.                
                <@param>
                    m covariance a covariance matrix, as, for example, returned by method {@link #covariance(DoubleMatrix2D)}.                    
                </@param>
                <@return>
                    n the modified covariance, now correlation matrix (for convenience only).                    
                </@return>
            </javadoc>
            <method name="correlation" type="DoubleMatrix2D" line="234">
                <params>
                    <param name="covariance" type="DoubleMatrix2D"/>
                </params>
                <scope line="235">
                    <scope line="236">
                        <declaration name="stdDev1" type="double" line="237"/>
                        <declaration name="stdDev2" type="double" line="238"/>
                        <declaration name="cov" type="double" line="239"/>
                        <declaration name="corr" type="double" line="240"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="250">
                Constructs and returns the covariance matrix of the given matrix.
                  The covariance matrix is a square, symmetric matrix consisting of nothing but covariance coefficients. 
                  The rows and the columns represent the variables, the cells represent covariance coefficients. 
                  The diagonal cells (i.e. the covariance between a variable and itself) will equal the variances.
                  The covariance of two column vectors x and y is given by &lt;tt&gt;cov(x,y) = (1/n)  Sum((x[i]-mean(x))  (y[i]-mean(y)))&lt;/tt&gt;.
                  See the &lt;A HREF=&quot;http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html&quot;&gt; math definition&lt;/A&gt;.
                  Compares two column vectors at a time. Use dice views to compare two row vectors at a time.                
                <@param>
                    m matrix any matrix; a column holds the values of a given variable.                    
                </@param>
                <@return>
                    n the covariance matrix (<tt>n x n, n=matrix.columns</tt>).                    
                </@return>
            </javadoc>
            <method name="covariance" type="DoubleMatrix2D" line="262">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
                <declaration name="rows" type="int" line="263"/>
                <declaration name="columns" type="int" line="264"/>
                <declaration name="covariance" type="DoubleMatrix2D" line="265"/>
                <declaration name="sums" type="double[]" line="267"/>
                <declaration name="cols" type="DoubleMatrix1D[]" line="268"/>
                <scope line="269"/>
                <scope line="274">
                    <scope line="275">
                        <declaration name="sumOfProducts" type="double" line="276"/>
                        <declaration name="cov" type="double" line="277"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="284">
                2-d OLAP cube operator; Fills all cells of the given vectors into the given histogram.
                  If you use hep.aida.ref.Converter.toString(histo) on the result, the OLAP cube of x-&quot;column&quot; vs. y-&quot;column&quot; , summing the weights &quot;column&quot; will be printed.
                  For example, aggregate sales by product by region.
                  &lt;p&gt;
                  Computes the distinct values of x and y, yielding histogram axes that capture one distinct value per bin.
                  Then fills the histogram.
                  &lt;p&gt;
                  Example output:
                  &lt;table&gt;
                  &lt;td class=&quot;PRE&quot;&gt; 
                  &lt;pre&gt;
                  Cube:
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;Entries=5000, ExtraEntries=0
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;MeanX=4.9838, RmsX=NaN
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;MeanY=2.5304, RmsY=NaN
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;xAxis: Min=0, Max=10, Bins=11
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;yAxis: Min=0, Max=5, Bins=6
                  Heights:
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;| X
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;| 0   1   2   3   4   5   6   7   8   9   10  | Sum 
                  ----------------------------------------------------------
                  Y 5   |  30  53  51  52  57  39  65  61  55  49  22 |  534
                  &amp;nbsp;&amp;nbsp;4   |  43 106 112  96  92  94 107  98  98 110  47 | 1003
                  &amp;nbsp;&amp;nbsp;3   |  39 134  87  93 102 103 110  90 114  98  51 | 1021
                  &amp;nbsp;&amp;nbsp;2   |  44  81 113  96 101  86 109  83 111  93  42 |  959
                  &amp;nbsp;&amp;nbsp;1   |  54  94 103  99 115  92  98  97 103  90  44 |  989
                  &amp;nbsp;&amp;nbsp;0   |  24  54  52  44  42  56  46  47  56  53  20 |  494
                  ----------------------------------------------------------
                  &amp;nbsp;&amp;nbsp;Sum | 234 522 518 480 509 470 535 476 537 493 226 |     
                  &lt;/pre&gt;
                  &lt;/td&gt;
                  &lt;/table&gt;                
                <@return>
                    n the histogram containing the cube.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>x.size() != y.size() || y.size() != weights.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="cube" type="hep.aida.IHistogram2D" line="320">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                    <param name="weights" type="DoubleMatrix1D"/>
                </params>
                <comment line="321">
                    compute distinct values of x                    
                </comment>
                <comment line="321">
                    toArray(vals); // copy x into vals                    
                </comment>
                <comment line="321">
                    since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin                    
                </comment>
                <comment line="321">
                    compute distinct values of y                    
                </comment>
                <comment line="321">
                    since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin                    
                </comment>
                <declaration name="epsilon" type="double" line="323"/>
                <declaration name="distinct" type="cern.colt.list.DoubleArrayList" line="324"/>
                <declaration name="vals" type="double[]" line="325"/>
                <declaration name="sorted" type="cern.colt.list.DoubleArrayList" line="326"/>
                <declaration name="xaxis" type="hep.aida.IAxis" line="335"/>
                <declaration name="yaxis" type="hep.aida.IAxis" line="344"/>
                <declaration name="histo" type="hep.aida.IHistogram2D" line="346"/>
            </method>
            <javadoc line="349">
                3-d OLAP cube operator; Fills all cells of the given vectors into the given histogram.
                  If you use hep.aida.ref.Converter.toString(histo) on the result, the OLAP cube of x-&quot;column&quot; vs. y-&quot;column&quot; vs. z-&quot;column&quot;, summing the weights &quot;column&quot; will be printed.
                  For example, aggregate sales by product by region by time.
                  &lt;p&gt;
                  Computes the distinct values of x and y and z, yielding histogram axes that capture one distinct value per bin.
                  Then fills the histogram.                
                <@return>
                    n the histogram containing the cube.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>x.size() != y.size() || x.size() != z.size() || x.size() != weights.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="cube" type="hep.aida.IHistogram3D" line="359">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                    <param name="z" type="DoubleMatrix1D"/>
                    <param name="weights" type="DoubleMatrix1D"/>
                </params>
                <comment line="360">
                    compute distinct values of x                    
                </comment>
                <comment line="360">
                    toArray(vals); // copy x into vals                    
                </comment>
                <comment line="360">
                    since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin                    
                </comment>
                <comment line="360">
                    compute distinct values of y                    
                </comment>
                <comment line="360">
                    since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin                    
                </comment>
                <comment line="360">
                    compute distinct values of z                    
                </comment>
                <comment line="360">
                    since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin                    
                </comment>
                <declaration name="epsilon" type="double" line="362"/>
                <declaration name="distinct" type="cern.colt.list.DoubleArrayList" line="363"/>
                <declaration name="vals" type="double[]" line="364"/>
                <declaration name="sorted" type="cern.colt.list.DoubleArrayList" line="365"/>
                <declaration name="xaxis" type="hep.aida.IAxis" line="374"/>
                <declaration name="yaxis" type="hep.aida.IAxis" line="383"/>
                <declaration name="zaxis" type="hep.aida.IAxis" line="392"/>
                <declaration name="histo" type="hep.aida.IHistogram3D" line="394"/>
            </method>
            <javadoc line="397">
                Demonstrates usage of this class.                
            </javadoc>
            <method name="demo1" type="void" line="400">
                <comment line="401">
                    System.out.println(correlation(covariance(A)));                    
                </comment>
                <comment line="401">
                    System.out.println(distance(A,EUCLID));                    
                </comment>
                <comment line="401">
                    System.out.println(cern.colt.matrixpattern.Converting.toHTML(A.toString()));                    
                </comment>
                <comment line="401">
                    System.out.println(cern.colt.matrixpattern.Converting.toHTML(covariance(A).toString()));                    
                </comment>
                <comment line="401">
                    System.out.println(cern.colt.matrixpattern.Converting.toHTML(correlation(covariance(A)).toString()));                    
                </comment>
                <comment line="401">
                    System.out.println(cern.colt.matrixpattern.Converting.toHTML(distance(A,EUCLID).toString()));                    
                </comment>
                <declaration name="values" type="double[][]" line="401"/>
                <declaration name="factory" type="DoubleFactory2D" line="407"/>
                <declaration name="A" type="DoubleMatrix2D" line="408"/>
            </method>
            <javadoc line="420">
                Demonstrates usage of this class.                
            </javadoc>
            <method name="demo2" type="void" line="423">
                <params>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="424">
                    double value = 1;                    
                </comment>
                <comment line="424">
                    DoubleMatrix2D A = factory.make(rows,columns);                    
                </comment>
                <comment line="424">
                    A.assign(value);                    
                </comment>
                <declaration name="factory" type="DoubleFactory2D" line="425"/>
                <declaration name="A" type="DoubleMatrix2D" line="426"/>
                <declaration name="timer" type="cern.colt.Timer" line="433"/>
                <declaration name="corr" type="DoubleMatrix2D" line="434"/>
                <scope line="437"/>
            </method>
            <javadoc line="443">
                Demonstrates usage of this class.                
            </javadoc>
            <method name="demo3" type="void" line="446">
                <params>
                    <param name="norm" type="VectorVectorFunction"/>
                </params>
                <declaration name="values" type="double[][]" line="447"/>
                <declaration name="factory" type="DoubleFactory2D" line="456"/>
                <declaration name="A" type="DoubleMatrix2D" line="457"/>
            </method>
            <javadoc line="462">
                Constructs and returns the distance matrix of the given matrix.
                  The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
                  The rows and the columns represent the variables, the cells represent distance coefficients. 
                  The diagonal cells (i.e. the distance between a variable and itself) will be zero.
                  Compares two column vectors at a time. Use dice views to compare two row vectors at a time.                
                <@param>
                    m matrix any matrix; a column holds the values of a given variable (vector).                    
                </@param>
                <@param>
                    m distanceFunction (EUCLID, CANBERRA, ..., or any user defined distance function operating on two vectors).                    
                </@param>
                <@return>
                    n the distance matrix (<tt>n x n, n=matrix.columns</tt>).                    
                </@return>
            </javadoc>
            <method name="distance" type="DoubleMatrix2D" line="473">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="distanceFunction" type="VectorVectorFunction"/>
                </params>
                <comment line="474">
                    cache views                    
                </comment>
                <comment line="474">
                    work out all permutations                    
                </comment>
                <declaration name="columns" type="int" line="474"/>
                <declaration name="distance" type="DoubleMatrix2D" line="475"/>
                <declaration name="cols" type="DoubleMatrix1D[]" line="478"/>
                <scope line="479"/>
                <scope line="484">
                    <scope line="485">
                        <declaration name="d" type="double" line="486"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="493">
                Fills all cells of the given vector into the given histogram.                
                <@return>
                    n <tt>histo</tt> (for convenience only).                    
                </@return>
            </javadoc>
            <method name="histogram" type="hep.aida.IHistogram1D" line="497">
                <params>
                    <param name="histo" type="hep.aida.IHistogram1D"/>
                    <param name="vector" type="DoubleMatrix1D"/>
                </params>
                <scope line="498"/>
            </method>
            <javadoc line="503">
                Fills all cells of the given vectors into the given histogram.                
                <@return>
                    n <tt>histo</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>x.size() != y.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="histogram" type="hep.aida.IHistogram2D" line="508">
                <params>
                    <param name="histo" type="hep.aida.IHistogram2D"/>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
                <scope line="510"/>
            </method>
            <javadoc line="515">
                Fills all cells of the given vectors into the given histogram.                
                <@return>
                    n <tt>histo</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>x.size() != y.size() || y.size() != weights.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="histogram" type="hep.aida.IHistogram2D" line="520">
                <params>
                    <param name="histo" type="hep.aida.IHistogram2D"/>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                    <param name="weights" type="DoubleMatrix1D"/>
                </params>
                <scope line="522"/>
            </method>
            <javadoc line="527">
                Fills all cells of the given vectors into the given histogram.                
                <@return>
                    n <tt>histo</tt> (for convenience only).                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>x.size() != y.size() || x.size() != z.size() || x.size() != weights.size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="histogram" type="hep.aida.IHistogram3D" line="532">
                <params>
                    <param name="histo" type="hep.aida.IHistogram3D"/>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                    <param name="z" type="DoubleMatrix1D"/>
                    <param name="weights" type="DoubleMatrix1D"/>
                </params>
                <scope line="534"/>
            </method>
            <javadoc line="539">
                Benchmarks covariance computation.                
            </javadoc>
            <method name="main" type="void" line="542">
                <params>
                    <param name="args" type="String[]"/>
                </params>
                <declaration name="rows" type="int" line="543"/>
                <declaration name="columns" type="int" line="544"/>
                <declaration name="print" type="boolean" line="545"/>
            </method>
            <javadoc line="548">
                Constructs and returns a sampling view with a size of &lt;tt&gt;round(matrix.size()  fraction)&lt;/tt&gt;.
                  Samples &quot;without replacement&quot; from the uniform distribution.                
                <@param>
                    m matrix any matrix.                    
                </@param>
                <@param>
                    m rowFraction the percentage of rows to be included in the view.                    
                </@param>
                <@param>
                    m columnFraction the percentage of columns to be included in the view.                    
                </@param>
                <@param>
                    m randomGenerator a uniform random number generator; set this parameter to <tt>null</tt> to use a default generator seeded with the current time.                    
                </@param>
                <@return>
                    n the sampling view.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>! (0 <= rowFraction <= 1 && 0 <= columnFraction <= 1)</tt>.                    
                </@throws>
                <@see>
                    e cern.jet.random.sampling.RandomSampler                    
                </@see>
            </javadoc>
            <method name="viewSample" type="DoubleMatrix1D" line="559">
                <params>
                    <param name="matrix" type="DoubleMatrix1D"/>
                    <param name="fraction" type="double"/>
                    <param name="randomGenerator" type="RandomEngine"/>
                </params>
                <comment line="560">
                    check preconditions and allow for a little tolerance                    
                </comment>
                <comment line="560">
                    random generator seeded with current time                    
                </comment>
                <comment line="560">
                    ng[] selected = new long[max]; // sampler works on long&apos;s, not int&apos;s                    
                </comment>
                <comment line="560">
                    sample                    
                </comment>
                <declaration name="epsilon" type="double" line="561"/>
                <declaration name="ncols" type="int" line="569"/>
                <declaration name="max" type="int" line="570"/>
                <declaration name="selected" type="long[]" line="571"/>
                <declaration name="n" type="int" line="574"/>
                <declaration name="N" type="int" line="575"/>
                <declaration name="selectedCols" type="int[]" line="577"/>
            </method>
            <javadoc line="582">
                Constructs and returns a sampling view with &lt;tt&gt;round(matrix.rows()  rowFraction)&lt;/tt&gt; rows and &lt;tt&gt;round(matrix.columns()  columnFraction)&lt;/tt&gt; columns.
                  Samples &quot;without replacement&quot;.
                  Rows and columns are randomly chosen from the uniform distribution.
                  Examples: 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr valign=&quot;top&quot; align=&quot;center&quot;&gt; 
                  &lt;td&gt; 
                  &lt;div align=&quot;left&quot;&gt;&lt;tt&gt;matrix&lt;/tt&gt;&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td&gt; 
                  &lt;div align=&quot;left&quot;&gt;&lt;tt&gt;rowFraction=0.2&lt;br&gt;
                  columnFraction=0.2&lt;/tt&gt;&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td&gt; 
                  &lt;div align=&quot;left&quot;&gt;&lt;tt&gt;rowFraction=0.2&lt;br&gt;
                  columnFraction=1.0 &lt;/tt&gt;&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td&gt; 
                  &lt;div align=&quot;left&quot;&gt;&lt;tt&gt;rowFraction=1.0&lt;br&gt;
                  columnFraction=0.2 &lt;/tt&gt;&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;top&quot;&gt; 
                  &lt;td&gt;&lt;tt&gt; 10&amp;nbsp;x&amp;nbsp;10&amp;nbsp;matrix&lt;br&gt;
                  &amp;nbsp;1&amp;nbsp;&amp;nbsp;2&amp;nbsp;&amp;nbsp;3&amp;nbsp;&amp;nbsp;4&amp;nbsp;&amp;nbsp;5&amp;nbsp;&amp;nbsp;6&amp;nbsp;&amp;nbsp;7&amp;nbsp;&amp;nbsp;8&amp;nbsp;&amp;nbsp;9&amp;nbsp;&amp;nbsp;10&lt;br&gt;
                  11&amp;nbsp;12&amp;nbsp;13&amp;nbsp;14&amp;nbsp;15&amp;nbsp;16&amp;nbsp;17&amp;nbsp;18&amp;nbsp;19&amp;nbsp;&amp;nbsp;20&lt;br&gt;
                  21&amp;nbsp;22&amp;nbsp;23&amp;nbsp;24&amp;nbsp;25&amp;nbsp;26&amp;nbsp;27&amp;nbsp;28&amp;nbsp;29&amp;nbsp;&amp;nbsp;30&lt;br&gt;
                  31&amp;nbsp;32&amp;nbsp;33&amp;nbsp;34&amp;nbsp;35&amp;nbsp;36&amp;nbsp;37&amp;nbsp;38&amp;nbsp;39&amp;nbsp;&amp;nbsp;40&lt;br&gt;
                  41&amp;nbsp;42&amp;nbsp;43&amp;nbsp;44&amp;nbsp;45&amp;nbsp;46&amp;nbsp;47&amp;nbsp;48&amp;nbsp;49&amp;nbsp;&amp;nbsp;50&lt;br&gt;
                  51&amp;nbsp;52&amp;nbsp;53&amp;nbsp;54&amp;nbsp;55&amp;nbsp;56&amp;nbsp;57&amp;nbsp;58&amp;nbsp;59&amp;nbsp;&amp;nbsp;60&lt;br&gt;
                  61&amp;nbsp;62&amp;nbsp;63&amp;nbsp;64&amp;nbsp;65&amp;nbsp;66&amp;nbsp;67&amp;nbsp;68&amp;nbsp;69&amp;nbsp;&amp;nbsp;70&lt;br&gt;
                  71&amp;nbsp;72&amp;nbsp;73&amp;nbsp;74&amp;nbsp;75&amp;nbsp;76&amp;nbsp;77&amp;nbsp;78&amp;nbsp;79&amp;nbsp;&amp;nbsp;80&lt;br&gt;
                  81&amp;nbsp;82&amp;nbsp;83&amp;nbsp;84&amp;nbsp;85&amp;nbsp;86&amp;nbsp;87&amp;nbsp;88&amp;nbsp;89&amp;nbsp;&amp;nbsp;90&lt;br&gt;
                  91&amp;nbsp;92&amp;nbsp;93&amp;nbsp;94&amp;nbsp;95&amp;nbsp;96&amp;nbsp;97&amp;nbsp;98&amp;nbsp;99&amp;nbsp;100 
                  &lt;/tt&gt; &lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt; 2&amp;nbsp;x&amp;nbsp;2&amp;nbsp;matrix&lt;br&gt;
                  43&amp;nbsp;50&lt;br&gt;
                  53&amp;nbsp;60 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt; 2&amp;nbsp;x&amp;nbsp;10&amp;nbsp;matrix&lt;br&gt;
                  41&amp;nbsp;42&amp;nbsp;43&amp;nbsp;44&amp;nbsp;45&amp;nbsp;46&amp;nbsp;47&amp;nbsp;48&amp;nbsp;49&amp;nbsp;&amp;nbsp;50&lt;br&gt;
                  91&amp;nbsp;92&amp;nbsp;93&amp;nbsp;94&amp;nbsp;95&amp;nbsp;96&amp;nbsp;97&amp;nbsp;98&amp;nbsp;99&amp;nbsp;100 
                  &lt;/tt&gt; &lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt; 10&amp;nbsp;x&amp;nbsp;2&amp;nbsp;matrix&lt;br&gt;
                  &amp;nbsp;4&amp;nbsp;&amp;nbsp;8&lt;br&gt;
                  14&amp;nbsp;18&lt;br&gt;
                  24&amp;nbsp;28&lt;br&gt;
                  34&amp;nbsp;38&lt;br&gt;
                  44&amp;nbsp;48&lt;br&gt;
                  54&amp;nbsp;58&lt;br&gt;
                  64&amp;nbsp;68&lt;br&gt;
                  74&amp;nbsp;78&lt;br&gt;
                  84&amp;nbsp;88&lt;br&gt;
                  94&amp;nbsp;98 &lt;/tt&gt; &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <@param>
                    m matrix any matrix.                    
                </@param>
                <@param>
                    m rowFraction the percentage of rows to be included in the view.                    
                </@param>
                <@param>
                    m columnFraction the percentage of columns to be included in the view.                    
                </@param>
                <@param>
                    m randomGenerator a uniform random number generator; set this parameter to <tt>null</tt> to use a default generator seeded with the current time.                    
                </@param>
                <@return>
                    n the sampling view.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>! (0 <= rowFraction <= 1 && 0 <= columnFraction <= 1)</tt>.                    
                </@throws>
                <@see>
                    e cern.jet.random.sampling.RandomSampler                    
                </@see>
            </javadoc>
            <method name="viewSample" type="DoubleMatrix2D" line="646">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="rowFraction" type="double"/>
                    <param name="columnFraction" type="double"/>
                    <param name="randomGenerator" type="RandomEngine"/>
                </params>
                <comment line="647">
                    check preconditions and allow for a little tolerance                    
                </comment>
                <comment line="647">
                    random generator seeded with current time                    
                </comment>
                <comment line="647">
                    ng[] selected = new long[max]; // sampler works on long&apos;s, not int&apos;s                    
                </comment>
                <comment line="647">
                    sample rows                    
                </comment>
                <comment line="647">
                    sample columns                    
                </comment>
                <declaration name="epsilon" type="double" line="648"/>
                <declaration name="nrows" type="int" line="660"/>
                <declaration name="ncols" type="int" line="661"/>
                <declaration name="max" type="int" line="662"/>
                <declaration name="selected" type="long[]" line="663"/>
                <declaration name="n" type="int" line="666"/>
                <declaration name="N" type="int" line="667"/>
                <declaration name="selectedRows" type="int[]" line="669"/>
                <declaration name="selectedCols" type="int[]" line="676"/>
            </method>
            <javadoc line="681">
                Constructs and returns a sampling view with &lt;tt&gt;round(matrix.slices()  sliceFraction)&lt;/tt&gt; slices and &lt;tt&gt;round(matrix.rows()  rowFraction)&lt;/tt&gt; rows and &lt;tt&gt;round(matrix.columns()  columnFraction)&lt;/tt&gt; columns.
                  Samples &quot;without replacement&quot;.
                  Slices, rows and columns are randomly chosen from the uniform distribution.                
                <@param>
                    m matrix any matrix.                    
                </@param>
                <@param>
                    m sliceFraction the percentage of slices to be included in the view.                    
                </@param>
                <@param>
                    m rowFraction the percentage of rows to be included in the view.                    
                </@param>
                <@param>
                    m columnFraction the percentage of columns to be included in the view.                    
                </@param>
                <@param>
                    m randomGenerator a uniform random number generator; set this parameter to <tt>null</tt> to use a default generator seeded with the current time.                    
                </@param>
                <@return>
                    n the sampling view.                    
                </@return>
                <@throws>
                    s IllegalArgumentException if <tt>! (0 <= sliceFraction <= 1 && 0 <= rowFraction <= 1 && 0 <= columnFraction <= 1)</tt>.                    
                </@throws>
                <@see>
                    e cern.jet.random.sampling.RandomSampler                    
                </@see>
            </javadoc>
            <method name="viewSample" type="DoubleMatrix3D" line="694">
                <params>
                    <param name="matrix" type="DoubleMatrix3D"/>
                    <param name="sliceFraction" type="double"/>
                    <param name="rowFraction" type="double"/>
                    <param name="columnFraction" type="double"/>
                    <param name="randomGenerator" type="RandomEngine"/>
                </params>
                <comment line="695">
                    check preconditions and allow for a little tolerance                    
                </comment>
                <comment line="695">
                    random generator seeded with current time                    
                </comment>
                <comment line="695">
                    ng[] selected = new long[max]; // sampler works on long&apos;s, not int&apos;s                    
                </comment>
                <comment line="695">
                    sample slices                    
                </comment>
                <comment line="695">
                    sample rows                    
                </comment>
                <comment line="695">
                    sample columns                    
                </comment>
                <declaration name="epsilon" type="double" line="696"/>
                <declaration name="nslices" type="int" line="712"/>
                <declaration name="nrows" type="int" line="713"/>
                <declaration name="ncols" type="int" line="714"/>
                <declaration name="max" type="int" line="715"/>
                <declaration name="selected" type="long[]" line="716"/>
                <declaration name="n" type="int" line="719"/>
                <declaration name="N" type="int" line="720"/>
                <declaration name="selectedSlices" type="int[]" line="722"/>
                <declaration name="selectedRows" type="int[]" line="729"/>
                <declaration name="selectedCols" type="int[]" line="736"/>
            </method>
            <javadoc line="741">
                Constructs and returns the distance matrix of the given matrix.
                  The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
                  The rows and the columns represent the variables, the cells represent distance coefficients. 
                  The diagonal cells (i.e. the distance between a variable and itself) will be zero.
                  Compares two column vectors at a time. Use dice views to compare two row vectors at a time.                
                <@param>
                    m matrix any matrix; a column holds the values of a given variable (vector).                    
                </@param>
                <@param>
                    m norm the kind of norm to be used (EUCLID, CANBERRA, ...).                    
                </@param>
                <@return>
                    n the distance matrix (<tt>n x n, n=matrix.columns</tt>).                    
                </@return>
            </javadoc>
            <method name="xdistanceOld" type="DoubleMatrix2D" line="752">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="norm" type="int"/>
                </params>
                <comment line="753">
                    int rows = matrix.rows();
                    int columns = matrix.columns();
                    DoubleMatrix2D distance = new cern.colt.matrix.impl.DenseDoubleMatrix2D(columns,columns);
                    
                     cache views
                    DoubleMatrix1D[] cols = new DoubleMatrix1D[columns];
                    for (int i=columns; --i &gt;= 0; ) {
                    cols[i] = matrix.viewColumn(i);
                    }
                    
                     setup distance function
                    cern.jet.math.Functions F = cern.jet.math.Functions.functions;
                    DoubleDoubleFunction function = null;
                    DoubleDoubleFunction function2 = null;
                    if (norm==EUCLID) function = F.chain(F.square,F.minus);
                    else if (norm==BRAY_CURTIS) function = F.chain(F.abs,F.minus);
                    else if (norm==CANBERRA) function = new DoubleDoubleFunction() {
                    public final double apply(double a, double b) {	return Math.abs(a-b)  Math.abs(a+b);}
                    };
                    else if (norm==MAXIMUM) function = F.chain(F.abs,F.minus);
                    else if (norm==MANHATTAN) function = F.chain(F.abs,F.minus);
                    else throw new IllegalArgumentException(&quot;Unknown norm&quot;);
                    
                     work out all permutations
                    for (int i=columns; --i &gt;= 0; ) {
                    for (int j=i; --j &gt;= 0; ) {
                    double d = 0;
                    if (norm==EUCLID) d = Math.sqrt(cols[i].aggregate(cols[j], F.plus, function));
                    else if (norm==BRAY_CURTIS) d = cols[i].aggregate(cols[j], F.plus, function)  cols[i].aggregate(cols[j], F.plus, F.plus);
                    else if (norm==CANBERRA) d = cols[i].aggregate(cols[j], F.plus, function);
                    else if (norm==MAXIMUM) d = cols[i].aggregate(cols[j], F.max, function);
                    else if (norm==MANHATTAN) d = cols[i].aggregate(cols[j], F.plus, function);
                    distance.setQuick(i,j,d);
                    distance.setQuick(j,i,d);  symmetric
                    }                    
                </comment>
            </method>
            <javadoc line="794">
                Constructs and returns the distance matrix of the given matrix.
                  The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
                  The rows and the columns represent the variables, the cells represent distance coefficients. 
                  The diagonal cells (i.e. the distance between a variable and itself) will be zero.
                  Compares two column vectors at a time. Use dice views to compare two row vectors at a time.                
                <@param>
                    m matrix any matrix; a column holds the values of a given variable (vector).                    
                </@param>
                <@param>
                    m norm the kind of norm to be used (EUCLID, CANBERRA, ...).                    
                </@param>
                <@return>
                    n the distance matrix (<tt>n x n, n=matrix.columns</tt>).                    
                </@return>
            </javadoc>
            <method name="xdistanceOld2" type="DoubleMatrix2D" line="805">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="norm" type="int"/>
                </params>
                <comment line="806">
                    setup distance function
                    final cern.jet.math.Functions F = cern.jet.math.Functions.functions;
                    VectorVectorFunction function;
                    if (norm==EUCLID) function = new VectorVectorFunction() {
                    public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
                    return Math.sqrt(a.aggregate(b, F.plus, F.chain(F.square,F.minus)));
                    }
                    };
                    else if (norm==BRAY_CURTIS) function = new VectorVectorFunction() {
                    public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
                    return a.aggregate(b, F.plus, F.chain(F.abs,F.minus))  a.aggregate(b, F.plus, F.plus);
                    }
                    };
                    else if (norm==CANBERRA) function = new VectorVectorFunction() {
                    DoubleDoubleFunction fun = new DoubleDoubleFunction() {
                    public final double apply(double a, double b) {
                    return Math.abs(a-b)  Math.abs(a+b);
                    }
                    };
                    public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
                    return a.aggregate(b, F.plus, fun);
                    }
                    };
                    else if (norm==MAXIMUM) function = new VectorVectorFunction() {
                    public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {
                    return a.aggregate(b, F.max, F.chain(F.abs,F.minus));
                    }
                    };
                    else if (norm==MANHATTAN) function = new VectorVectorFunction() {
                    public final double apply(DoubleMatrix1D a, DoubleMatrix1D b) {                    
                </comment>
            </method>
        </class>
    </source>