<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.map">
        <class name="PrimeFinder" line="3">
            <extends class="Object"/>
            <comment line="4">
                blic static final int largestPrime = Integer.MAX_VALUE; //yes, it is prime.                
            </comment>
            <javadoc line="3">
                Not of interest for users; only for implementors of hashtables.
                  Used to keep hash table capacities prime numbers.
                  &lt;p&gt;Choosing prime numbers as hash table capacities is a good idea to keep them working fast,
                  particularly under hash table expansions.
                  &lt;p&gt;However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to keep capacities prime.
                  This class provides efficient means to choose prime capacities.
                  &lt;p&gt;Choosing a prime is &lt;tt&gt;O(log 300)&lt;/tt&gt; (binary search in a list of 300 int&apos;s).
                  Memory requirements: 1 KB static memory.                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
            </javadoc>
            <declaration name="largestPrime" type="int" line="20"/>
            <javadoc line="20">
                The largest prime this class can generate; currently equal to &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.                
            </javadoc>
            <declaration name="primeCapacities" type="int[]" line="25"/>
            <javadoc line="25">
                The prime number list consists of 11 chunks.
                  Each chunk contains prime numbers.
                  A chunk starts with a prime P1. The next element is a prime P2. P2 is the smallest prime for which holds: P2 &gt;= 2P1.
                  The next element is P3, for which the same holds with respect to P2, and so on.
                  Chunks are chosen such that for any desired capacity &gt;= 1000 
                  the list includes a prime number &lt;= desired capacity  1.11 (11%).
                  For any desired capacity &gt;= 200 
                  the list includes a prime number &lt;= desired capacity  1.16 (16%).
                  For any desired capacity &gt;= 16
                  the list includes a prime number &lt;= desired capacity  1.21 (21%).
                  Therefore, primes can be retrieved which are quite close to any desired capacity,
                  which in turn avoids wasting memory.
                  For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081.
                  So if you need a prime &gt;= 1040, you will find a prime &lt;= 10401.11=1154.
                  Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0;
                  If your hashtable has such a growthfactor then,  
                  after initially &quot;rounding to a prime&quot; upon hashtable construction, 
                  it will later expand to prime capacities such that there exist no better primes.
                  In total these are about 3210=320 numbers -&gt; 1 KB of static memory needed.
                  If you are stingy, then delete every second or fourth chunk.                
            </javadoc>
            <scope line="124"/>
            <javadoc line="132">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="PrimeFinder" type="constructor" line="135"/>
            <javadoc line="136">
                Tests correctness. Try 
                  from=1000, to=10000
                  from=200,  to=1000
                  from=16,   to=1000
                  from=1000, to=Integer.MAX_VALUE                
            </javadoc>
            <method name="main" type="void" line="143">
                <params>
                    <param name="args" type="String"/>
                </params>
                <declaration name="from" type="int" line="144"/>
                <declaration name="to" type="int" line="145"/>
            </method>
            <javadoc line="149">
                Returns a prime number which is &lt;code&gt;&amp;gt;= desiredCapacity&lt;/code&gt; and very close to &lt;code&gt;desiredCapacity&lt;/code&gt; (within 11% if &lt;code&gt;desiredCapacity &amp;gt;= 1000&lt;/code&gt;).                
                <@param>
                    m desiredCapacity the capacity desired by the user.                    
                </@param>
                <@return>
                    n the capacity which should be used for a hashtable.                    
                </@return>
            </javadoc>
            <method name="nextPrime" type="int" line="154">
                <params>
                    <param name="desiredCapacity" type="int"/>
                </params>
                <comment line="155">
                    int i = new cern.colt.list.IntArrayList(primeCapacities).binarySearch(desiredCapacity); // for debug only TODO                    
                </comment>
                <declaration name="i" type="int" line="155"/>
                <scope line="157"/>
            </method>
            <javadoc line="163">
                Tests correctness.                
            </javadoc>
            <method name="statistics" type="void" line="166">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="167">
                    check that primes contain no accidental errors                    
                </comment>
                <scope line="168"/>
                <declaration name="accDeviation" type="double" line="172"/>
                <declaration name="maxDeviation" type="double" line="173"/>
                <scope line="175">
                    <declaration name="primeCapacity" type="int" line="176"/>
                    <declaration name="deviation" type="double" line="178"/>
                    <scope line="180"/>
                </scope>
                <declaration name="width" type="long" line="187"/>
                <declaration name="meanDeviation" type="double" line="189"/>
            </method>
        </class>
    </source>