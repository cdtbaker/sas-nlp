<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.map">
        <class name="AbstractMap" extends="cern.colt.PersistentObject" line="11">
            <comment line="12">
                public static boolean debug = false; // debug only                
            </comment>
            <javadoc line="11">
                Abstract base class for hash maps holding objects or primitive data types such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, etc. as keys and/or values.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * &lt;p&gt;
                 * Note that implementations are not synchronized.                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
                <@see>
                    e java.util.HashMap                    
                </@see>
            </javadoc>
            <declaration name="distinct" type="int" line="24"/>
            <javadoc line="24">
                The number of distinct associations in the map; its &quot;size()&quot;.                
            </javadoc>
            <declaration name="lowWaterMark" type="int" line="29"/>
            <javadoc line="29">
                The table capacity c=table.length always satisfies the invariant
                 * &lt;tt&gt;c * minLoadFactor &lt;= s &lt;= c * maxLoadFactor&lt;/tt&gt;, where s=size() is the number of associations currently contained.
                 * The term &quot;c * minLoadFactor&quot; is called the &quot;lowWaterMark&quot;, &quot;c * maxLoadFactor&quot; is called the &quot;highWaterMark&quot;.
                 * In other words, the table capacity (and proportionally the memory used by this class) oscillates within these constraints.
                 * The terms are precomputed and cached to avoid recalculating them each time put(..) or removeKey(...) is called.                
            </javadoc>
            <declaration name="highWaterMark" type="int" line="37"/>
            <declaration name="minLoadFactor" type="double" line="39"/>
            <javadoc line="39">
                The minimum load factor for the hashtable.                
            </javadoc>
            <declaration name="maxLoadFactor" type="double" line="44"/>
            <javadoc line="44">
                The maximum load factor for the hashtable.                
            </javadoc>
            <declaration name="defaultCapacity" type="int" line="49"/>
            <declaration name="defaultMinLoadFactor" type="double" line="50"/>
            <declaration name="defaultMaxLoadFactor" type="double" line="51"/>
            <javadoc line="52">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="AbstractMap" type="constructor" line="55"/>
            <javadoc line="56">
                Chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant
                 * &lt;tt&gt;c * minLoadFactor &lt;= size &lt;= c * maxLoadFactor&lt;/tt&gt;
                 * and has at least one FREE slot for the given size.                
            </javadoc>
            <method name="chooseGrowCapacity" type="int" line="61"/>
            <javadoc line="64">
                Returns new high water mark threshold based on current capacity and maxLoadFactor.                
                <@return>
                    n int the new threshold.                    
                </@return>
            </javadoc>
            <method name="chooseHighWaterMark" type="int" line="68">
                <comment line="69">
                    turn Math.min(capacity-2, (int) (capacity * maxLoad)); //makes sure there is always at least one FREE slot                    
                </comment>
            </method>
            <javadoc line="71">
                Returns new low water mark threshold based on current capacity and minLoadFactor.                
                <@return>
                    n int the new threshold.                    
                </@return>
            </javadoc>
            <method name="chooseLowWaterMark" type="int" line="75"/>
            <javadoc line="78">
                Chooses a new prime table capacity neither favoring shrinking nor growing,
                 * that (approximately) satisfies the invariant
                 * &lt;tt&gt;c * minLoadFactor &lt;= size &lt;= c * maxLoadFactor&lt;/tt&gt;
                 * and has at least one FREE slot for the given size.                
            </javadoc>
            <method name="chooseMeanCapacity" type="int" line="84"/>
            <javadoc line="87">
                Chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant
                 * &lt;tt&gt;c * minLoadFactor &lt;= size &lt;= c * maxLoadFactor&lt;/tt&gt;
                 * and has at least one FREE slot for the given size.                
            </javadoc>
            <method name="chooseShrinkCapacity" type="int" line="92"/>
            <method name="clear" type="void" line="95"/>
            <javadoc line="95">
                Removes all (key,value) associations from the receiver.                
            </javadoc>
            <javadoc line="99">
                Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
                 * If necessary, allocates new internal memory and increases the capacity of the receiver.
                 * &lt;p&gt;
                 * This method never need be called; it is for performance tuning only.
                 * Calling this method before &lt;tt&gt;put()&lt;/tt&gt;ing a large number of associations boosts performance,
                 * because the receiver will grow only once instead of potentially many times.
                 * &lt;p&gt;
                 * &lt;b&gt;This default implementation does nothing.&lt;/b&gt; Override this method if necessary.                
                <@param>
                    m minCapacity   the desired minimum capacity.                    
                </@param>
            </javadoc>
            <method name="ensureCapacity" type="void" line="111"/>
            <javadoc line="112">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the receiver contains no (key,value) associations.                
                <@return>
                    n <tt>true</tt> if the receiver contains no (key,value) associations.                    
                </@return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="117"/>
            <javadoc line="120">
                Returns a prime number which is &lt;code&gt;&amp;gt;= desiredCapacity&lt;/code&gt; and very close to &lt;code&gt;desiredCapacity&lt;/code&gt; (within 11% if &lt;code&gt;desiredCapacity &amp;gt;= 1000&lt;/code&gt;).                
                <@param>
                    m desiredCapacity the capacity desired by the user.                    
                </@param>
                <@return>
                    n the capacity which should be used for a hashtable.                    
                </@return>
            </javadoc>
            <method name="nextPrime" type="int" line="125"/>
            <javadoc line="128">
                Initializes the receiver.
                 * You will almost certainly need to override this method in subclasses to initialize the hash table.                
                <@param>
                    m initialCapacity   the initial capacity of the receiver.                    
                </@param>
                <@param>
                    m minLoadFactor     the minLoadFactor of the receiver.                    
                </@param>
                <@param>
                    m maxLoadFactor     the maxLoadFactor of the receiver.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.                    
                </@throws>
            </javadoc>
            <method name="setUp" type="void" line="137"/>
            <javadoc line="147">
                Returns the number of (key,value) associations currently contained.                
                <@return>
                    n the number of (key,value) associations currently contained.                    
                </@return>
            </javadoc>
            <method name="size" type="int" line="152"/>
            <javadoc line="155">
                Trims the capacity of the receiver to be the receiver&apos;s current 
                 * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
                 * storage of the receiver.
                 * &lt;p&gt;
                 * This default implementation does nothing. Override this method if necessary.                
            </javadoc>
            <method name="trimToSize" type="void" line="162"/>
        </class>
    </source>