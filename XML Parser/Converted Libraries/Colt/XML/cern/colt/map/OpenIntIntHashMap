<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.map">
        <import package="cern.colt.function.IntIntProcedure"/>
        <import package="cern.colt.function.IntProcedure"/>
        <import package="cern.colt.list.ByteArrayList"/>
        <import package="cern.colt.list.IntArrayList"/>
        <class name="OpenIntIntHashMap" extends="AbstractIntIntMap" line="15">
            <javadoc line="15">
                Hash map holding (key,value) associations of type &lt;tt&gt;(int--&gt;int)&lt;/tt&gt;; Automatically grows and shrinks as needed; Implemented using open addressing with double hashing.
                 * First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                 * Overrides many methods for performance reasons only.                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
                <@see>
                    e java.util.HashMap                    
                </@see>
            </javadoc>
            <declaration name="table" type="int" line="26"/>
            <javadoc line="26">
                The hash table keys.                
                <@serial>
                    l                    
                </@serial>
            </javadoc>
            <declaration name="values" type="int" line="32"/>
            <javadoc line="32">
                The hash table values.                
                <@serial>
                    l                    
                </@serial>
            </javadoc>
            <declaration name="state" type="byte" line="38"/>
            <javadoc line="38">
                The state of each hash table entry (FREE, FULL, REMOVED).                
                <@serial>
                    l                    
                </@serial>
            </javadoc>
            <declaration name="freeEntries" type="int" line="44"/>
            <javadoc line="44">
                The number of table entries in state==FREE.                
                <@serial>
                    l                    
                </@serial>
            </javadoc>
            <declaration name="FREE" type="byte" line="51"/>
            <declaration name="FULL" type="byte" line="52"/>
            <declaration name="REMOVED" type="byte" line="53"/>
            <javadoc line="55">
                Constructs an empty map with default capacity and default load factors.                
            </javadoc>
            <method name="OpenIntIntHashMap" type="constructor" line="58"/>
            <javadoc line="61">
                Constructs an empty map with the specified initial capacity and default load factors.                
                <@param>
                    m initialCapacity   the initial capacity of the map.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if the initial capacity is less
                     * than zero.                    
                </@throws>
            </javadoc>
            <method name="OpenIntIntHashMap" type="constructor" line="68"/>
            <javadoc line="71">
                Constructs an empty map with
                 * the specified initial capacity and the specified minimum and maximum load factor.                
                <@param>
                    m initialCapacity   the initial capacity.                    
                </@param>
                <@param>
                    m minLoadFactor        the minimum load factor.                    
                </@param>
                <@param>
                    m maxLoadFactor        the maximum load factor.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.                    
                </@throws>
            </javadoc>
            <method name="OpenIntIntHashMap" type="constructor" line="80"/>
            <javadoc line="83">
                Removes all (key,value) associations from the receiver.
                 * Implicitly calls &lt;tt&gt;trimToSize()&lt;/tt&gt;.                
            </javadoc>
            <method name="clear" type="void" line="87">
                <comment line="88">
                    new IntArrayList(values).fillFromToWith(0, state.length-1, 0); // delta                    
                </comment>
                <comment line="88">
                    is.freeEntries = table.length; // delta                    
                </comment>
            </method>
            <javadoc line="95">
                Returns a deep copy of the receiver.                
                <@return>
                    n  a deep copy of the receiver.                    
                </@return>
            </javadoc>
            <method name="clone" type="Object" line="100">
                <declaration name="copy" type="OpenIntIntHashMap" line="101"/>
            </method>
            <javadoc line="107">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the receiver contains the specified key.                
                <@return>
                    n <tt>true</tt> if the receiver contains the specified key.                    
                </@return>
            </javadoc>
            <method name="containsKey" type="boolean" line="112"/>
            <javadoc line="115">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the receiver contains the specified value.                
                <@return>
                    n <tt>true</tt> if the receiver contains the specified value.                    
                </@return>
            </javadoc>
            <method name="containsValue" type="boolean" line="120"/>
            <javadoc line="123">
                Ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory.
                 * If necessary, allocates new internal memory and increases the capacity of the receiver.
                 * &lt;p&gt;
                 * This method never need be called; it is for performance tuning only.
                 * Calling this method before &lt;tt&gt;put()&lt;/tt&gt;ing a large number of associations boosts performance,
                 * because the receiver will grow only once instead of potentially many times and hash collisions get less probable.                
                <@param>
                    m minCapacity   the desired minimum capacity.                    
                </@param>
            </javadoc>
            <method name="ensureCapacity" type="void" line="133">
                <scope line="134">
                    <declaration name="newCapacity" type="int" line="135"/>
                </scope>
            </method>
            <javadoc line="139">
                Applies a procedure to each key of the receiver, if any.
                 * Note: Iterates over the keys in no particular order.
                 * Subclasses can define a particular order, for example, &quot;sorted by key&quot;.
                 * All methods which &lt;i&gt;can&lt;/i&gt; be expressed in terms of this method (most methods can) &lt;i&gt;must guarantee&lt;/i&gt; to use the &lt;i&gt;same&lt;/i&gt; order defined by this method, even if it is no particular order.
                 * This is necessary so that, for example, methods &lt;tt&gt;keys&lt;/tt&gt; and &lt;tt&gt;values&lt;/tt&gt; will yield association pairs, not two uncorrelated lists.                
                <@param>
                    m procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </@param>
                <@return>
                    n <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.                    
                </@return>
            </javadoc>
            <method name="forEachKey" type="boolean" line="149">
                <scope line="150"/>
            </method>
            <javadoc line="155">
                Applies a procedure to each (key,value) pair of the receiver, if any.
                 * Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(IntProcedure)}.                
                <@param>
                    m procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </@param>
                <@return>
                    n <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.                    
                </@return>
            </javadoc>
            <method name="forEachPair" type="boolean" line="162">
                <scope line="163"/>
            </method>
            <javadoc line="168">
                Returns the value associated with the specified key.
                 * It is often a good idea to first check with {@link #containsKey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.                
                <@param>
                    m key the key to be searched for.                    
                </@param>
                <@return>
                    n the value associated with the specified key; <tt>0</tt> if no such key is present.                    
                </@return>
            </javadoc>
            <method name="get" type="int" line="175">
                <comment line="176">
                    (i&lt;0) return 0; //not contained                    
                </comment>
                <declaration name="i" type="int" line="176"/>
            </method>
            <javadoc line="180">
                @param key the key to be added to the receiver.                
                <@return>
                    n the index where the key would need to be inserted, if it is not already contained.
                     * Returns -index-1 if the key is already contained at slot index.
                     * Therefore, if the returned index < 0, then it is already contained at slot -index-1.
                     * If the returned index >= 0, then it is NOT already contained and should be inserted at slot index.                    
                </@return>
            </javadoc>
            <method name="indexOfInsertion" type="int" line="187">
                <comment line="188">
                    System.out.println(&quot;key=&quot;+key);                    
                </comment>
                <comment line="188">
                    t decrement = hash % (length-2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html                    
                </comment>
                <comment line="188">
                    int decrement = (hash / length) % length;                    
                </comment>
                <comment line="188">
                    stop if we find a removed or free slot, or if we find the key itself                    
                </comment>
                <comment line="188">
                    do NOT skip over removed slots (yes, open addressing is like that...)                    
                </comment>
                <comment line="188">
                    not already contained, should be inserted at slot i.                    
                </comment>
                <comment line="188">
                    return a number &gt;= 0 identifying the slot.                    
                </comment>
                <declaration name="tab" type="int" line="189"/>
                <declaration name="stat" type="byte" line="190"/>
                <declaration name="length" type="int" line="191"/>
                <declaration name="hash" type="int" line="193"/>
                <declaration name="i" type="int" line="194"/>
                <declaration name="decrement" type="int" line="195"/>
                <scope line="201"/>
                <scope line="207">
                    <declaration name="j" type="int" line="211"/>
                    <scope line="212"/>
                </scope>
                <scope line="221"/>
            </method>
            <javadoc line="230">
                @param key the key to be searched in the receiver.                
                <@return>
                    n the index where the key is contained in the receiver, returns -1 if the key was not found.                    
                </@return>
            </javadoc>
            <method name="indexOfKey" type="int" line="234">
                <comment line="235">
                    t decrement = hash % (length-2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html                    
                </comment>
                <comment line="235">
                    int decrement = (hash / length) % length;                    
                </comment>
                <comment line="235">
                    stop if we find a free slot, or if we find the key itself.                    
                </comment>
                <comment line="235">
                    do skip over removed slots (yes, open addressing is like that...)                    
                </comment>
                <comment line="235">
                    (stat[i] == FREE) return -1; // not found                    
                </comment>
                <comment line="235">
                    turn i; //found, return index where key is contained                    
                </comment>
                <declaration name="tab" type="int" line="235"/>
                <declaration name="stat" type="byte" line="236"/>
                <declaration name="length" type="int" line="237"/>
                <declaration name="hash" type="int" line="239"/>
                <declaration name="i" type="int" line="240"/>
                <declaration name="decrement" type="int" line="241"/>
                <scope line="247"/>
            </method>
            <javadoc line="256">
                @param value the value to be searched in the receiver.                
                <@return>
                    n the index where the value is contained in the receiver, returns -1 if the value was not found.                    
                </@return>
            </javadoc>
            <method name="indexOfValue" type="int" line="260">
                <comment line="261">
                    turn -1; // not found                    
                </comment>
                <declaration name="val" type="int" line="261"/>
                <declaration name="stat" type="byte" line="262"/>
                <scope line="264"/>
            </method>
            <javadoc line="270">
                Returns the first key the given value is associated with.
                 * It is often a good idea to first check with {@link #containsValue(int)} whether there exists an association from a key to this value.
                 * Search order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(IntProcedure)}.                
                <@param>
                    m value the value to search for.                    
                </@param>
                <@return>
                    n the first key for which holds <tt>get(key) == value</tt>; 
                     * returns <tt>Integer.MIN_VALUE</tt> if no such key exists.                    
                </@return>
            </javadoc>
            <method name="keyOf" type="int" line="279">
                <comment line="280">
                    returns the first key found; there may be more matching keys, however.                    
                </comment>
                <declaration name="i" type="int" line="281"/>
            </method>
            <javadoc line="285">
                Fills all keys contained in the receiver into the specified list.
                 * Fills the list, starting at index 0.
                 * After this call returns the specified list has a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                 * Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(IntProcedure)}.
                 * &lt;p&gt;
                 * This method can be used to iterate over the keys of the receiver.                
                <@param>
                    m list the list to be filled, can have any size.                    
                </@param>
            </javadoc>
            <method name="keys" type="void" line="295">
                <declaration name="elements" type="int[]" line="297"/>
                <declaration name="tab" type="int[]" line="299"/>
                <declaration name="stat" type="byte[]" line="300"/>
                <declaration name="j" type="int" line="302"/>
                <scope line="303"/>
            </method>
            <javadoc line="307">
                Fills all pairs satisfying a given condition into the specified lists.
                 * Fills into the lists, starting at index 0.
                 * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
                 * Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(IntProcedure)}.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;br&gt;
                 * &lt;pre&gt;
                 * IntIntProcedure condition = new IntIntProcedure() { // match even keys only
                 * public boolean apply(int key, int value) { return key%2==0; }
                 * }
                 * keys = (8,7,6), values = (1,2,2) --&gt; keyList = (6,8), valueList = (2,1)&lt;/tt&gt;
                 * &lt;/pre&gt;                
                <@param>
                    m condition    the condition to be matched. Takes the current key as first and the current value as second argument.                    
                </@param>
                <@param>
                    m keyList the list to be filled with keys, can have any size.                    
                </@param>
                <@param>
                    m valueList the list to be filled with values, can have any size.                    
                </@param>
            </javadoc>
            <method name="pairsMatching" type="void" line="326">
                <scope line="330">
                    <scope line="331"/>
                </scope>
            </method>
            <javadoc line="337">
                Associates the given key with the given value.
                 * Replaces any old &lt;tt&gt;(key,someOtherValue)&lt;/tt&gt; association, if existing.                
                <@param>
                    m key the key the value shall be associated with.                    
                </@param>
                <@param>
                    m value the value to be associated.                    
                </@param>
                <@return>
                    n <tt>true</tt> if the receiver did not already contain such a key;
                     * <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.                    
                </@return>
            </javadoc>
            <method name="put" type="boolean" line="346">
                <declaration name="i" type="int" line="347"/>
                <scope line="348"/>
                <scope line="354">
                    <declaration name="newCapacity" type="int" line="355"/>
                </scope>
                <scope line="370">
                    <declaration name="newCapacity" type="int" line="371"/>
                </scope>
            </method>
            <javadoc line="377">
                Rehashes the contents of the receiver into a new table
                 * with a smaller or larger capacity.
                 * This method is called automatically when the
                 * number of keys in the receiver exceeds the high water mark or falls below the low water mark.                
            </javadoc>
            <method name="rehash" type="void" line="383">
                <comment line="384">
                    if (oldCapacity == newCapacity) return;                    
                </comment>
                <comment line="384">
                    is.freeEntries = newCapacity-this.distinct; // delta                    
                </comment>
                <declaration name="oldCapacity" type="int" line="384"/>
                <declaration name="oldTable" type="int" line="387"/>
                <declaration name="oldValues" type="int" line="388"/>
                <declaration name="oldState" type="byte" line="389"/>
                <declaration name="newTable" type="int" line="391"/>
                <declaration name="newValues" type="int" line="392"/>
                <declaration name="newState" type="byte" line="393"/>
                <scope line="403">
                    <scope line="404">
                        <declaration name="element" type="int" line="405"/>
                        <declaration name="index" type="int" line="406"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="413">
                Removes the given key with its associated element from the receiver, if present.                
                <@param>
                    m key the key to be removed from the receiver.                    
                </@param>
                <@return>
                    n <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.                    
                </@return>
            </javadoc>
            <method name="removeKey" type="boolean" line="419">
                <comment line="420">
                    (i&lt;0) return false; // key not contained                    
                </comment>
                <comment line="420">
                    this.values[i]=0; // delta                    
                </comment>
                <declaration name="i" type="int" line="420"/>
                <scope line="427">
                    <declaration name="newCapacity" type="int" line="428"/>
                </scope>
            </method>
            <javadoc line="440">
                Initializes the receiver.                
                <@param>
                    m initialCapacity   the initial capacity of the receiver.                    
                </@param>
                <@param>
                    m minLoadFactor        the minLoadFactor of the receiver.                    
                </@param>
                <@param>
                    m maxLoadFactor        the maxLoadFactor of the receiver.                    
                </@param>
                <@throws>
                    s IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.                    
                </@throws>
            </javadoc>
            <method name="setUp" type="void" line="448">
                <comment line="449">
                    (capacity==0) capacity=1; // open addressing needs at least one FREE slot at any time.                    
                </comment>
                <comment line="449">
                    memory will be exhausted long before this pathological case happens, anyway.                    
                </comment>
                <comment line="449">
                    is.freeEntries = capacity; // delta                    
                </comment>
                <comment line="449">
                    lowWaterMark will be established upon first expansion.                    
                </comment>
                <comment line="449">
                    establishing it now (upon instance construction) would immediately make the table shrink upon first put(...).                    
                </comment>
                <comment line="449">
                    After all the idea of an &quot;initialCapacity&quot; implies violating lowWaterMarks when an object is young.                    
                </comment>
                <comment line="449">
                    See ensureCapacity(...)                    
                </comment>
                <declaration name="capacity" type="int" line="449"/>
            </method>
            <javadoc line="473">
                Trims the capacity of the receiver to be the receiver&apos;s current 
                 * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
                 * storage of the receiver.                
            </javadoc>
            <method name="trimToSize" type="void" line="478">
                <comment line="479">
                    * 1.2 because open addressing&apos;s performance exponentially degrades beyond that point                    
                </comment>
                <comment line="479">
                    so that even rehashing the table can take very long                    
                </comment>
                <declaration name="newCapacity" type="int" line="481"/>
                <scope line="482"/>
            </method>
            <javadoc line="486">
                Fills all values contained in the receiver into the specified list.
                 * Fills the list, starting at index 0.
                 * After this call returns the specified list has a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                 * Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(IntProcedure)}.
                 * &lt;p&gt;
                 * This method can be used to iterate over the values of the receiver.                
                <@param>
                    m list the list to be filled, can have any size.                    
                </@param>
            </javadoc>
            <method name="values" type="void" line="496">
                <declaration name="elements" type="int[]" line="498"/>
                <declaration name="val" type="int[]" line="500"/>
                <declaration name="stat" type="byte[]" line="501"/>
                <declaration name="j" type="int" line="503"/>
                <scope line="504"/>
            </method>
        </class>
    </source>