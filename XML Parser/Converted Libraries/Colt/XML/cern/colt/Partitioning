<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt">
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.list.DoubleArrayList"/>
        <import package="cern.colt.list.IntArrayList"/>
        <class name="Partitioning" extends="Object" line="14">
            <comment line="15">
                benchmark only                
            </comment>
            <javadoc line="14">
                Given some interval boundaries, partitions arrays such that all elements falling into an interval are placed next to each other.
                 * &lt;p&gt;
                 * The algorithms partition arrays into two or more intervals. 
                 * They distinguish between &lt;i&gt;synchronously&lt;/i&gt; partitioning either one, two or three arrays.
                 * They further come in templated versions, either partitioning &lt;tt&gt;int[]&lt;/tt&gt; arrays or &lt;tt&gt;double[]&lt;/tt&gt; arrays.
                 * &lt;p&gt;
                 * You may want to start out reading about the simplest case: Partitioning one &lt;tt&gt;int[]&lt;/tt&gt; array into two intervals.
                 * To do so, read {@link #partition(int[],int,int,int)}.
                 * Next, building upon that foundation comes a method partitioning &lt;tt&gt;int[]&lt;/tt&gt; arrays into multiple intervals.
                 * See {@link #partition(int[],int,int,int[],int,int,int[])} for related documentation.
                 * &lt;p&gt;
                 * All other methods are no different than the one&apos;s you now already understand, except that they operate on slightly different data types.
                 * &lt;p&gt;
                 * &lt;b&gt;Performance&lt;/b&gt;
                 * &lt;p&gt;
                 * Partitioning into two intervals is &lt;tt&gt;O( N )&lt;/tt&gt;.
                 * Partitioning into k intervals is &lt;tt&gt;O( N * log(k))&lt;/tt&gt;.
                 * Constants factors are minimized.
                 * No temporary memory is allocated; Partitioning is in-place.                
                <@see>
                    e cern.colt.matrix.doublealgo.Partitioning                    
                </@see>
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 03-Jul-99                    
                </@version>
            </javadoc>
            <declaration name="SMALL" type="int" line="42"/>
            <declaration name="MEDIUM" type="int" line="43"/>
            <declaration name="steps" type="int" line="46"/>
            <declaration name="swappedElements" type="int" line="47"/>
            <javadoc line="48">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Partitioning" type="constructor" line="51"/>
            <javadoc line="52">
                Finds the given key &quot;a&quot; within some generic data using the binary search algorithm.                
                <@param>
                    m a the index of the key to search for.                    
                </@param>
                <@param>
                    m from the leftmost search position, inclusive.                    
                </@param>
                <@param>
                    m to the rightmost search position, inclusive.                    
                </@param>
                <@param>
                    m comp the comparator determining the order of the generic data.
                     * Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
                     * Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.                    
                </@param>
                <@return>
                    n index of the search key, if it is contained in the list;
                     * otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                     * point</i> is defined as the the point at which the value would
                     * be inserted into the list: the index of the first
                     * element greater than the key, or <tt>list.length</tt>, if all
                     * elements in the list are less than the specified key.  Note
                     * that this guarantees that the return value will be &gt;= 0 if
                     * and only if the key is found.                    
                </@return>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="69">
                <comment line="70">
                    turn -(from + 1);  // key not found.                    
                </comment>
                <scope line="70">
                    <declaration name="mid" type="int" line="71"/>
                    <declaration name="comparison" type="int" line="72"/>
                </scope>
            </method>
            <javadoc line="79">
                Same as {@link #dualPartition(int[],int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="dualPartition" type="void" line="83">
                <comment line="84">
                    uble splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="84">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="84">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="84">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="84">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="84">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="84">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="84">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="84">
                    recursively partition left half                    
                </comment>
                <comment line="84">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="double" line="84"/>
                <scope line="87"/>
                <declaration name="medianIndex" type="int" line="96"/>
                <scope line="97"/>
                <scope line="100">
                    <declaration name="m" type="int" line="101"/>
                    <declaration name="len" type="int" line="102"/>
                    <scope line="103">
                        <declaration name="l" type="int" line="104"/>
                        <declaration name="n" type="int" line="105"/>
                        <scope line="106">
                            <declaration name="s" type="int" line="107"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="125"/>
                <scope line="129">
                    <declaration name="i" type="int" line="131"/>
                </scope>
                <scope line="135">
                    <declaration name="i" type="int" line="137"/>
                </scope>
                <scope line="143"/>
                <scope line="148"/>
            </method>
            <javadoc line="152">
                Same as {@link #dualPartition(int[],int[],int,int,int)} 
                 * except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="dualPartition" type="int" line="156">
                <comment line="157">
                    uble element;  // int, double --&gt; template type dependent                    
                </comment>
                <declaration name="element" type="double" line="157"/>
                <scope line="158">
                    <scope line="160"/>
                </scope>
            </method>
            <javadoc line="172">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions two arrays at the same time;
                 * both arrays are partially sorted according to the elements of the primary array.
                 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array is also moved from index A to B.
                 * &lt;p&gt;
                 * &lt;b&gt;Use cases:&lt;/b&gt;
                 * &lt;p&gt;
                 * Image having a large list of 2-dimensional points. 
                 * If memory consumption and performance matter, it is a good idea to physically lay them out as two 1-dimensional arrays
                 * (using something like &lt;tt&gt;Point2D&lt;/tt&gt; objects would be prohibitively expensive, both in terms of time and space).
                 * Now imagine wanting to histogram the points.
                 * We may want to partially sort the points by x-coordinate into intervals.
                 * This method efficiently does the job.
                 * &lt;p&gt;
                 * &lt;b&gt;Performance:&lt;/b&gt;
                 * &lt;p&gt;
                 * Same as for single-partition methods.                
            </javadoc>
            <method name="dualPartition" type="void" line="190">
                <comment line="191">
                    t splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="191">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="191">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="191">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="191">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="191">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="191">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="191">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="191">
                    recursively partition left half                    
                </comment>
                <comment line="191">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="int" line="191"/>
                <scope line="194"/>
                <declaration name="medianIndex" type="int" line="203"/>
                <scope line="204"/>
                <scope line="207">
                    <declaration name="m" type="int" line="208"/>
                    <declaration name="len" type="int" line="209"/>
                    <scope line="210">
                        <declaration name="l" type="int" line="211"/>
                        <declaration name="n" type="int" line="212"/>
                        <scope line="213">
                            <declaration name="s" type="int" line="214"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="232"/>
                <scope line="236">
                    <declaration name="i" type="int" line="238"/>
                </scope>
                <scope line="242">
                    <declaration name="i" type="int" line="244"/>
                </scope>
                <scope line="250"/>
                <scope line="255"/>
            </method>
            <javadoc line="259">
                Same as {@link #partition(int[],int,int,int)} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions two arrays at the same time;
                 * both arrays are partially sorted according to the elements of the primary array.
                 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array is also moved from index A to B.
                 * &lt;p&gt;
                 * &lt;b&gt;Performance:&lt;/b&gt;
                 * &lt;p&gt;
                 * Same as for single-partition methods.                
            </javadoc>
            <method name="dualPartition" type="int" line="268">
                <comment line="269">
                    t element;  // int, double --&gt; template type dependent                    
                </comment>
                <declaration name="element" type="int" line="269"/>
                <scope line="270">
                    <scope line="272"/>
                </scope>
            </method>
            <javadoc line="284">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;generically&lt;/i&gt; partitions arbitrary shaped data (for example matrices or multiple arrays) rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.
                 * &lt;p&gt;
                 * This method operates on arbitrary shaped data and arbitrary shaped splitters. 
                 * In fact, it has no idea what kind of data by what kind of splitters it is partitioning. Comparisons and swapping 
                 * are delegated to user provided objects which know their data and can do the 
                 * job. 
                 * &lt;p&gt;
                 * Lets call the generic data &lt;tt&gt;g&lt;/tt&gt; (it may be a matrix, one array, three linked lists 
                 * or whatever). Lets call the generic splitters &lt;tt&gt;s&lt;/tt&gt;.
                 * This class takes a user comparison function operating on two indexes 
                 * &lt;tt&gt;(a,b)&lt;/tt&gt;, namely an {@link IntComparator}. 
                 * The comparison function determines whether &lt;tt&gt;s[a]&lt;/tt&gt; is equal, less or greater than &lt;tt&gt;g[b]&lt;/tt&gt;. 
                 * This method can then decide to swap the data &lt;tt&gt;g[b]&lt;/tt&gt; 
                 * with the data &lt;tt&gt;g[c]&lt;/tt&gt; (yes, &lt;tt&gt;c&lt;/tt&gt;, not &lt;tt&gt;a&lt;/tt&gt;). 
                 * It calls a user provided {@link cern.colt.Swapper} 
                 * object that knows how to swap the data of these two indexes.
                 * &lt;p&gt;
                 * Again, note the details: Comparisons compare &lt;tt&gt;s[a]&lt;/tt&gt; with &lt;tt&gt;g[b]&lt;/tt&gt;.
                 * Swaps swap &lt;tt&gt;g[b]&lt;/tt&gt; with &lt;tt&gt;g[c]&lt;/tt&gt;. 
                 * Prior to calling this method, the generic splitters &lt;tt&gt;s&lt;/tt&gt; must be sorted ascending and must not contain multiple equal values.
                 * These preconditions are not checked; be sure that they are met.                
                <@param>
                    m from the index of the first element within <tt>g</tt> to be considered.                    
                </@param>
                <@param>
                    m to the index of the last element within <tt>g</tt> to be considered.
                     * The method considers the elements <tt>g[from] .. g[to]</tt>.                    
                </@param>
                <@param>
                    m splitFrom the index of the first splitter element to be considered.                    
                </@param>
                <@param>
                    m splitTo the index of the last splitter element to be considered.
                     * The method considers the splitter elements <tt>s[splitFrom] .. s[splitTo]</tt>.                    
                </@param>
                <@param>
                    m splitIndexes a list into which this method fills the indexes of elements delimiting intervals.
                     * Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
                     * Therefore, must satisfy <tt>splitIndexes.length > splitTo</tt>.                    
                </@param>
                <@param>
                    m comp the comparator comparing a splitter with an element of the generic data.
                     * Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
                     * Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.                    
                </@param>
                <@param>
                    m comp2 the comparator to determine the order of the generic data.
                     * Takes as first argument the index <tt>a</tt> within the generic data <tt>g</tt>.
                     * Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.                    
                </@param>
                <@param>
                    m comp3 the comparator comparing a splitter with another splitter.
                     * Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
                     * Takes as second argument the index <tt>b</tt> within the generic splitters <tt>g</tt>.                    
                </@param>
                <@param>
                    m swapper an object that knows how to swap the elements at any two indexes (a,b).
                     * Takes as first argument the index <tt>b</tt> within the generic data <tt>g</tt>.
                     * Takes as second argument the index <tt>c</tt> within the generic data <tt>g</tt>.
                     * <p>
                     * Tip: Normally you will have <tt>splitIndexes.length == s.length</tt> as well as <tt>from==0, to==g.length-1</tt> and <tt>splitFrom==0, splitTo==s.length-1</tt>.                    
                </@param>
                <@see>
                    e Sort                    
                </@see>
                <@see>
                    e Sort#sort(int,int,IntComparator,Swapper)                    
                </@see>
                <@see>
                    e Sorting#binarySearchFromTo(int,int,IntComparator)                    
                </@see>
            </javadoc>
            <method name="genericPartition" type="void" line="341">
                <comment line="342">
                    t splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="342">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="342">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="342">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="342">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="342">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="342">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="342">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="342">
                    recursively partition left half                    
                </comment>
                <comment line="342">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="int" line="342"/>
                <scope line="345"/>
                <declaration name="medianIndex" type="int" line="354"/>
                <scope line="355"/>
                <scope line="358">
                    <declaration name="m" type="int" line="359"/>
                    <declaration name="len" type="int" line="360"/>
                    <scope line="361">
                        <declaration name="l" type="int" line="362"/>
                        <declaration name="n" type="int" line="363"/>
                        <scope line="364">
                            <declaration name="s" type="int" line="365"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="383"/>
                <scope line="388">
                    <declaration name="i" type="int" line="390"/>
                </scope>
                <scope line="394">
                    <declaration name="i" type="int" line="396"/>
                </scope>
                <scope line="403"/>
                <scope line="408"/>
            </method>
            <javadoc line="412">
                Same as {@link #partition(int[],int,int,int)} 
                 * except that it &lt;i&gt;generically&lt;/i&gt; partitions arbitrary shaped data (for example matrices or multiple arrays) rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="genericPartition" type="int" line="416">
                <scope line="417">
                    <scope line="418"/>
                </scope>
            </method>
            <javadoc line="426">
                Returns the index of the median of the three indexed elements.                
            </javadoc>
            <method name="med3" type="int" line="429"/>
            <javadoc line="434">
                Returns the index of the median of the three indexed elements.                
            </javadoc>
            <method name="med3" type="int" line="437"/>
            <javadoc line="442">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="445">
                <declaration name="ab" type="int" line="446"/>
                <declaration name="ac" type="int" line="447"/>
                <declaration name="bc" type="int" line="448"/>
            </method>
            <javadoc line="453">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="456">
                <declaration name="ab" type="int" line="457"/>
                <declaration name="ac" type="int" line="458"/>
                <declaration name="bc" type="int" line="459"/>
            </method>
            <javadoc line="464">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="partition" type="void" line="468">
                <comment line="469">
                    uble splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="469">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="469">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="469">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="469">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="469">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="469">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="469">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="469">
                    recursively partition left half                    
                </comment>
                <comment line="469">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="double" line="469"/>
                <scope line="472"/>
                <declaration name="medianIndex" type="int" line="481"/>
                <scope line="482"/>
                <scope line="485">
                    <declaration name="m" type="int" line="486"/>
                    <declaration name="len" type="int" line="487"/>
                    <scope line="488">
                        <declaration name="l" type="int" line="489"/>
                        <declaration name="n" type="int" line="490"/>
                        <scope line="491">
                            <declaration name="s" type="int" line="492"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="510"/>
                <scope line="514">
                    <declaration name="i" type="int" line="516"/>
                </scope>
                <scope line="520">
                    <declaration name="i" type="int" line="522"/>
                </scope>
                <scope line="528"/>
                <scope line="533"/>
            </method>
            <javadoc line="537">
                Same as {@link #partition(int[],int,int,int)}except that it partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="partition" type="int" line="541">
                <comment line="542">
                    uble element;  // int, double --&gt; template type dependent                    
                </comment>
                <declaration name="element" type="double" line="542"/>
                <scope line="543">
                    <scope line="545"/>
                </scope>
            </method>
            <javadoc line="553">
                Partitions (partially sorts) the given list such that all elements falling into some intervals are placed next to each other.
                 * Returns the indexes of elements delimiting intervals.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;list = (7, 4, 5, 50, 6, 4, 3, 6), splitters = (5, 10, 30)&lt;/tt&gt;
                 * defines the three intervals &lt;tt&gt;[-infinity,5), [5,10), [10,30)&lt;/tt&gt;.
                 * Lets define to sort the entire list (&lt;tt&gt;from=0, to=7&lt;/tt&gt;) using all splitters (&lt;tt&gt;splitFrom==0, splitTo=2&lt;/tt&gt;).
                 * &lt;p&gt;
                 * The method modifies the list to be &lt;tt&gt;list = (4, 4, 3, 6, 7, 5, 6, 50)&lt;/tt&gt;
                 * and returns the &lt;tt&gt;splitIndexes = (2, 6, 6)&lt;/tt&gt;.
                 * In other words,
                 * &lt;ul&gt;
                 * &lt;li&gt;All values &lt;tt&gt;list[0..2]&lt;/tt&gt; fall into &lt;tt&gt;[-infinity,5)&lt;/tt&gt;.
                 * &lt;li&gt;All values &lt;tt&gt;list[3..6]&lt;/tt&gt; fall into &lt;tt&gt;[5,10)&lt;/tt&gt;.
                 * &lt;li&gt;All values &lt;tt&gt;list[7..6]&lt;/tt&gt; fall into &lt;tt&gt;[10,30)&lt;/tt&gt;, i.e. no elements, since &lt;tt&gt;7&gt;6&lt;/tt&gt;.
                 * &lt;li&gt;All values &lt;tt&gt;list[7 .. 7=list.length-1]&lt;/tt&gt; fall into &lt;tt&gt;[30,infinity]&lt;/tt&gt;.
                 * &lt;li&gt;In general, all values &lt;tt&gt;list[splitIndexes[j-1]+1 .. splitIndexes[j]]&lt;/tt&gt; fall into interval &lt;tt&gt;j&lt;/tt&gt;.
                 * &lt;/ul&gt;
                 * As can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other.
                 * Note that &lt;i&gt;within&lt;/i&gt; an interval, elements are entirelly unsorted.
                 * They are only sorted across interval boundaries.
                 * In particular, this partitioning algorithm is not &lt;i&gt;stable&lt;/i&gt;: the relative order of elements is not preserved
                 * (Producing a stable algorithm would require no more than minor modifications to method partition(int[],int,int,int)).
                 * &lt;p&gt;
                 * More formally, this method guarantees that upon return &lt;tt&gt;for all j = splitFrom .. splitTo&lt;/tt&gt; there holds:
                 * &lt;br&gt;&lt;tt&gt;for all i = splitIndexes[j-1]+1 .. splitIndexes[j]: splitters[j-1] &lt;= list[i] &lt; splitters[j]&lt;/tt&gt;.
                 * &lt;p&gt;
                 * &lt;b&gt;Performance:&lt;/b&gt;
                 * &lt;p&gt;
                 * Let &lt;tt&gt;N=to-from+1&lt;/tt&gt; be the number of elements to be partitioned.
                 * Let &lt;tt&gt;k=splitTo-splitFrom+1&lt;/tt&gt; be the number of splitter elements.
                 * Then we have the following time complexities
                 * &lt;ul&gt;
                 * &lt;li&gt;Worst case:  &lt;tt&gt;O( N * log(k) )&lt;/tt&gt;.
                 * &lt;li&gt;Average case: &lt;tt&gt;O( N * log(k) )&lt;/tt&gt;.
                 * &lt;li&gt;Best case: &lt;tt&gt;O( N )&lt;/tt&gt;. 
                 * In general, the more uniform (skewed) the data is spread across intervals, the more performance approaches the worst (best) case.
                 * If no elements fall into the given intervals, running time is linear.
                 * &lt;/ul&gt;
                 * No temporary memory is allocated; the sort is in-place.
                 * &lt;p&gt;
                 * &lt;b&gt;Implementation:&lt;/b&gt;
                 * &lt;p&gt;
                 * The algorithm can be seen as a Bentley/McIlroy quicksort where swapping and insertion sort are omitted.
                 * It is designed to detect and take advantage of skew while maintaining good performance in the uniform case.                
                <@param>
                    m list the list to be partially sorted.                    
                </@param>
                <@param>
                    m from the index of the first element within <tt>list</tt> to be considered.                    
                </@param>
                <@param>
                    m to the index of the last element within <tt>list</tt> to be considered.
                     * The method considers the elements <tt>list[from] .. list[to]</tt>.                    
                </@param>
                <@param>
                    m splitters the values at which the list shall be split into intervals.
                     * Must be sorted ascending and must not contain multiple identical values.
                     * These preconditions are not checked; be sure that they are met.                    
                </@param>
                <@param>
                    m splitFrom the index of the first splitter element to be considered.                    
                </@param>
                <@param>
                    m splitTo the index of the last splitter element to be considered.
                     * The method considers the splitter elements <tt>splitters[splitFrom] .. splitters[splitTo]</tt>.                    
                </@param>
                <@param>
                    m splitIndexes a list into which this method fills the indexes of elements delimiting intervals.
                     * Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
                     * Therefore, must satisfy <tt>splitIndexes.length > splitTo</tt>.
                     * <p>
                     * Tip: Normally you will have <tt>splitIndexes.length == splitters.length</tt> as well as <tt>from==0, to==list.length-1</tt> and <tt>splitFrom==0, splitTo==splitters.length-1</tt>.                    
                </@param>
                <@see>
                    e cern.colt.Arrays                    
                </@see>
                <@see>
                    e cern.colt.GenericSorting                    
                </@see>
                <@see>
                    e java.util.Arrays                    
                </@see>
            </javadoc>
            <method name="partition" type="void" line="625">
                <comment line="626">
                    t element,splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="626">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="626">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="626">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="626">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="626">
                    System.out.println(&quot;medianIndex=&quot;+medianIndex);                    
                </comment>
                <comment line="626">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="626">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="626">
                    Could simply call:                    
                </comment>
                <comment line="626">
                    but for speed the code is manually inlined.                    
                </comment>
                <comment line="626">
                    steps += to-from+1;
                    int head = from;
                    for (int i=from-1; ++i&lt;=to; ) {  swap all elements &lt; splitter to front                    
                </comment>
                <comment line="626">
                    System.out.println(&quot;splitIndex=&quot;+splitIndex);                    
                </comment>
                <comment line="626">
                    if (splitFrom == splitTo) return; // done                    
                </comment>
                <comment line="626">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="626">
                    recursively partition left half                    
                </comment>
                <comment line="626">
                    recursively partition right half                    
                </comment>
                <comment line="626">
                    System.out.println(&quot;BACK TRACKING\n\n&quot;);                    
                </comment>
                <declaration name="element" type="int" line="626"/>
                <scope line="629"/>
                <declaration name="medianIndex" type="int" line="638"/>
                <scope line="639"/>
                <scope line="642">
                    <declaration name="m" type="int" line="643"/>
                    <declaration name="len" type="int" line="644"/>
                    <scope line="645">
                        <declaration name="l" type="int" line="646"/>
                        <declaration name="n" type="int" line="647"/>
                        <scope line="648">
                            <declaration name="s" type="int" line="649"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="700"/>
                <scope line="728">
                    <declaration name="i" type="int" line="730"/>
                </scope>
                <scope line="734">
                    <declaration name="i" type="int" line="736"/>
                </scope>
                <scope line="742"/>
                <scope line="748"/>
            </method>
            <javadoc line="754">
                Partitions (partially sorts) the given list such that all elements falling into the given interval are placed next to each other.
                 * Returns the index of the element delimiting the interval.
                 * &lt;p&gt;
                 * &lt;b&gt;Example:&lt;/b&gt;
                 * &lt;p&gt;
                 * &lt;tt&gt;list = (7, 4, 5, 50, 6, 4, 3, 6), splitter = 5&lt;/tt&gt;
                 * defines the two intervals &lt;tt&gt;[-infinity,5), [5,+infinity]&lt;/tt&gt;.
                 * &lt;p&gt;
                 * The method modifies the list to be &lt;tt&gt;list = (4, 4, 3, 50, 6, 7, 5, 6)&lt;/tt&gt;
                 * and returns the split index &lt;tt&gt;2&lt;/tt&gt;.
                 * In other words,
                 * &lt;ul&gt;
                 * &lt;li&gt;All values &lt;tt&gt;list[0..2]&lt;/tt&gt; fall into &lt;tt&gt;[-infinity,5)&lt;/tt&gt;.
                 * &lt;li&gt;All values &lt;tt&gt;list[3=2+1 .. 7=list.length-1]&lt;/tt&gt; fall into &lt;tt&gt;[5,+infinity]&lt;/tt&gt;.
                 * &lt;/ul&gt;
                 * As can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other.
                 * Note that &lt;i&gt;within&lt;/i&gt; an interval, elements are entirelly unsorted.
                 * They are only sorted across interval boundaries.
                 * In particular, this partitioning algorithm is not &lt;i&gt;stable&lt;/i&gt;.
                 * &lt;p&gt;
                 * More formally, this method guarantees that upon return there holds:
                 * &lt;ul&gt;
                 * &lt;li&gt;for all &lt;tt&gt;i = from .. returnValue: list[i] &lt; splitter&lt;/tt&gt; and
                 * &lt;li&gt;for all &lt;tt&gt;i = returnValue+1 .. list.length-1: !(list[i] &lt; splitter)&lt;/tt&gt;.
                 * &lt;/ul&gt;
                 * &lt;p&gt;
                 * &lt;b&gt;Performance:&lt;/b&gt;
                 * &lt;p&gt;
                 * Let &lt;tt&gt;N=to-from+1&lt;/tt&gt; be the number of elements to be partially sorted.
                 * Then the time complexity is &lt;tt&gt;O( N )&lt;/tt&gt;.
                 * No temporary memory is allocated; the sort is in-place.
                 * &lt;p&gt;                
                <@param>
                    m list the list to be partially sorted.                    
                </@param>
                <@param>
                    m from the index of the first element within <tt>list</tt> to be considered.                    
                </@param>
                <@param>
                    m to the index of the last element within <tt>list</tt> to be considered.
                     * The method considers the elements <tt>list[from] .. list[to]</tt>.                    
                </@param>
                <@param>
                    m splitter the value at which the list shall be split.                    
                </@param>
                <@return>
                    n the index of the largest element falling into the interval <tt>[-infinity,splitter)</tt>, as seen after partitioning.                    
                </@return>
            </javadoc>
            <method name="partition" type="int" line="798">
                <comment line="799">
                    System.out.println();
                    if (from&lt;=to) {                    
                </comment>
                <comment line="799">
                    returns index of last element &lt; splitter                    
                </comment>
                <comment line="799">
                    for (int i=from-1; ++i&lt;=to; ) {                    
                </comment>
                <comment line="799">
                    if (from&lt;=to) System.out.println(&quot;Swapped &quot;+(head-from)+&quot; elements&quot;);                    
                </comment>
                <comment line="799">
                    JAL:
                    int first = from;
                    int last = to+1;                    
                </comment>
                <comment line="799">
                    System.out.println(&quot;splitter=&quot;+splitter);
                    System.out.println(&quot;before=&quot;+new IntArrayList(list));
                    int head = from;
                    int trail = to;
                    int element;
                    while (head&lt;=trail) {
                    head--;                    
                </comment>
                <comment line="799">
                    System.out.println(&quot;splitter=&quot;+splitter);
                    System.out.println(&quot;before=&quot;+new IntArrayList(list));
                    to++;
                    int head = from;
                    int element;
                    int oldHead;
                    while (--to &gt;= from) {
                    element = list[to];
                    if (element &lt; splitter) {
                    from--;                    
                </comment>
                <comment line="799">
                    int i=from-1;
                    int head = from;
                    int trail = to;
                    while (++i &lt;= trail) {                    
                </comment>
                <comment line="799">
                    return head-1;                    
                </comment>
                <declaration name="element" type="int" line="831"/>
                <scope line="832">
                    <scope line="834"/>
                </scope>
            </method>
            <javadoc line="939">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it partitions &lt;tt&gt;Object[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="partition" type="void" line="943">
                <comment line="944">
                    ject splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="944">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="944">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="944">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="944">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="944">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="944">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="944">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="944">
                    recursively partition left half                    
                </comment>
                <comment line="944">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="Object" line="944"/>
                <scope line="947"/>
                <declaration name="medianIndex" type="int" line="956"/>
                <scope line="957"/>
                <scope line="960">
                    <declaration name="m" type="int" line="961"/>
                    <declaration name="len" type="int" line="962"/>
                    <scope line="963">
                        <declaration name="l" type="int" line="964"/>
                        <declaration name="n" type="int" line="965"/>
                        <scope line="966">
                            <declaration name="s" type="int" line="967"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="985"/>
                <scope line="989">
                    <declaration name="i" type="int" line="991"/>
                </scope>
                <scope line="995">
                    <declaration name="i" type="int" line="997"/>
                </scope>
                <scope line="1003"/>
                <scope line="1008"/>
            </method>
            <javadoc line="1012">
                Same as {@link #partition(int[],int,int,int)} 
                 * except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the objects of the given list by the order of the given comparator.                
            </javadoc>
            <method name="partition" type="int" line="1016">
                <comment line="1017">
                    ject element;  // int, double --&gt; template type dependent                    
                </comment>
                <declaration name="element" type="Object" line="1017"/>
                <scope line="1018">
                    <scope line="1020"/>
                </scope>
            </method>
            <javadoc line="1029">
                Equivalent to &lt;tt&gt;partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())&lt;/tt&gt;.                
            </javadoc>
            <method name="partition" type="void" line="1032"/>
            <javadoc line="1035">
                Equivalent to &lt;tt&gt;partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())&lt;/tt&gt;.                
            </javadoc>
            <method name="partition" type="void" line="1038"/>
            <javadoc line="1041">
                Same as {@link #triplePartition(int[],int[],int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="triplePartition" type="void" line="1045">
                <comment line="1046">
                    uble splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="1046">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="1046">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="1046">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="1046">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="1046">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="1046">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="1046">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="1046">
                    recursively partition left half                    
                </comment>
                <comment line="1046">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="double" line="1046"/>
                <scope line="1049"/>
                <declaration name="medianIndex" type="int" line="1058"/>
                <scope line="1059"/>
                <scope line="1062">
                    <declaration name="m" type="int" line="1063"/>
                    <declaration name="len" type="int" line="1064"/>
                    <scope line="1065">
                        <declaration name="l" type="int" line="1066"/>
                        <declaration name="n" type="int" line="1067"/>
                        <scope line="1068">
                            <declaration name="s" type="int" line="1069"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="1087"/>
                <scope line="1091">
                    <declaration name="i" type="int" line="1093"/>
                </scope>
                <scope line="1097">
                    <declaration name="i" type="int" line="1099"/>
                </scope>
                <scope line="1105"/>
                <scope line="1110"/>
            </method>
            <javadoc line="1114">
                Same as {@link #triplePartition(int[],int[],int[],int,int,int)} 
                 * except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="triplePartition" type="int" line="1118">
                <comment line="1119">
                    uble element;  // int, double --&gt; template type dependent                    
                </comment>
                <declaration name="element" type="double" line="1119"/>
                <scope line="1120">
                    <scope line="1122"/>
                </scope>
            </method>
            <javadoc line="1139">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions three arrays at the same time;
                 * all three arrays are partially sorted according to the elements of the primary array.
                 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index A to B.
                 * &lt;p&gt;
                 * &lt;b&gt;Use cases:&lt;/b&gt;
                 * &lt;p&gt;
                 * Image having a large list of 3-dimensional points. 
                 * If memory consumption and performance matter, it is a good idea to physically lay them out as three 1-dimensional arrays
                 * (using something like &lt;tt&gt;Point3D&lt;/tt&gt; objects would be prohibitively expensive, both in terms of time and space).
                 * Now imagine wanting to histogram the points.
                 * We may want to partially sort the points by x-coordinate into intervals.
                 * This method efficiently does the job.
                 * &lt;p&gt;
                 * &lt;b&gt;Performance:&lt;/b&gt;
                 * &lt;p&gt;
                 * Same as for single-partition methods.                
            </javadoc>
            <method name="triplePartition" type="void" line="1157">
                <comment line="1158">
                    t splitter; // int, double --&gt; template type dependent                    
                </comment>
                <comment line="1158">
                    (splitFrom&gt;splitTo) return; // nothing to do                    
                </comment>
                <comment line="1158">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="1158">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="1158">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="1158">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="1158">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="1158">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="1158">
                    recursively partition left half                    
                </comment>
                <comment line="1158">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="int" line="1158"/>
                <scope line="1161"/>
                <declaration name="medianIndex" type="int" line="1170"/>
                <scope line="1171"/>
                <scope line="1174">
                    <declaration name="m" type="int" line="1175"/>
                    <declaration name="len" type="int" line="1176"/>
                    <scope line="1177">
                        <declaration name="l" type="int" line="1178"/>
                        <declaration name="n" type="int" line="1179"/>
                        <scope line="1180">
                            <declaration name="s" type="int" line="1181"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="1199"/>
                <scope line="1203">
                    <declaration name="i" type="int" line="1205"/>
                </scope>
                <scope line="1209">
                    <declaration name="i" type="int" line="1211"/>
                </scope>
                <scope line="1217"/>
                <scope line="1222"/>
            </method>
            <javadoc line="1226">
                Same as {@link #partition(int[],int,int,int)} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions three arrays at the same time;
                 * all three arrays are partially sorted according to the elements of the primary array.
                 * In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index A to B.
                 * &lt;p&gt;
                 * &lt;b&gt;Performance:&lt;/b&gt;
                 * &lt;p&gt;
                 * Same as for single-partition methods.                
            </javadoc>
            <method name="triplePartition" type="int" line="1235">
                <comment line="1236">
                    t element;  // int, double --&gt; template type dependent                    
                </comment>
                <declaration name="element" type="int" line="1236"/>
                <scope line="1237">
                    <scope line="1239"/>
                </scope>
            </method>
        </class>
    </source>