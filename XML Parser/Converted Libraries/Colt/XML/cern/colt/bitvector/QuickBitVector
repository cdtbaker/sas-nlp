<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.bitvector">
        <class name="QuickBitVector" extends="Object" line="11">
            <comment line="12">
                otected final static int ADDRESS_BITS_PER_UNIT = 6; // 64=2^6                
            </comment>
            <comment line="12">
                otected final static int BITS_PER_UNIT = 64; // = 1 &lt;&lt; ADDRESS_BITS_PER_UNIT                
            </comment>
            <comment line="12">
                otected final static int BIT_INDEX_MASK = 63; // = BITS_PER_UNIT - 1;                
            </comment>
            <comment line="12">
                ivate static final long[] pows = precomputePows(); //precompute bitmasks for speed                
            </comment>
            <javadoc line="11">
                Implements quick non polymorphic non bounds checking low level bitvector operations.
                 * Includes some operations that interpret sub-bitstrings as long integers.
                 * &lt;p&gt;
                 * &lt;b&gt;WARNING: Methods of this class do not check preconditions.&lt;/b&gt;
                 * Provided with invalid parameters these method may return (or set) invalid values without throwing any exception.
                 * &lt;b&gt;You should only use this class when performance is critical and you are absolutely sure that indexes are within bounds.&lt;/b&gt;
                 * &lt;p&gt;	 
                 * A bitvector is modelled as a long array, i.e. &lt;tt&gt;long[] bits&lt;/tt&gt; holds bits of a bitvector.
                 * Each long value holds 64 bits.
                 * The i-th bit is stored in bits[i/64] at
                 * bit position i % 64 (where bit position 0 refers to the least
                 * significant bit and 63 refers to the most significant bit).                
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 1.0, 09/24/99                    
                </@version>
                <@see>
                    e BitVector                    
                </@see>
                <@see>
                    e BitMatrix                    
                </@see>
                <@see>
                    e java.util.BitSet                    
                </@see>
            </javadoc>
            <declaration name="ADDRESS_BITS_PER_UNIT" type="int" line="32"/>
            <declaration name="BITS_PER_UNIT" type="int" line="33"/>
            <declaration name="BIT_INDEX_MASK" type="int" line="34"/>
            <declaration name="pows" type="long[]" line="36"/>
            <javadoc line="37">
                Makes this class non instantiable, but still inheritable.                
            </javadoc>
            <method name="QuickBitVector" type="constructor" line="40"/>
            <javadoc line="42">
                Returns a bit mask with bits in the specified range set to 1, all the rest set to 0.
                 * In other words, returns a bit mask having 0,1,2,3,...,64 bits set.
                 * If &lt;tt&gt;to-from+1==0&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).
                 * Precondition (not checked): &lt;tt&gt;to-from+1 &amp;gt;= 0 &amp;&amp; to-from+1 &amp;lt;= 64&lt;/tt&gt;.                
                <@param>
                    m from index of start bit (inclusive)                    
                </@param>
                <@param>
                    m to index of end bit (inclusive).                    
                </@param>
                <@return>
                    n the bit mask having all bits between <tt>from</tt> and <tt>to</tt> set to 1.                    
                </@return>
            </javadoc>
            <method name="bitMaskWithBitsSetFromTo" type="long" line="52">
                <comment line="53">
                    This turned out to be slower:                    
                </comment>
                <comment line="53">
                    0xffffffffffffffffL == ~0L == -1L == all 64 bits set.                    
                </comment>
                <comment line="53">
                    int width;                    
                </comment>
                <comment line="53">
                    return (width=to-from+1) == 0 ? 0L : (0xffffffffffffffffL &gt;&gt;&gt; (BITS_PER_UNIT-width)) &lt;&lt; from;                    
                </comment>
            </method>
            <javadoc line="60">
                Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the &quot;clear&quot; (&lt;tt&gt;false&lt;/tt&gt;) state.                
                <@param>
                    m bits   the bitvector.                    
                </@param>
                <@param>
                    m bitIndex   the index of the bit to be cleared.                    
                </@param>
            </javadoc>
            <method name="clear" type="void" line="66"/>
            <javadoc line="69">
                Returns from the bitvector the value of the bit with the specified index.
                 * The value is &lt;tt&gt;true&lt;/tt&gt; if the bit with the index &lt;tt&gt;bitIndex&lt;/tt&gt; 
                 * is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.                
                <@param>
                    m bits   the bitvector.                    
                </@param>
                <@param>
                    m bitIndex   the bit index.                    
                </@param>
                <@return>
                    n    the value of the bit with the specified index.                    
                </@return>
            </javadoc>
            <method name="get" type="boolean" line="78"/>
            <javadoc line="81">
                Returns a long value representing bits of a bitvector from index &lt;tt&gt;from&lt;/tt&gt; to index &lt;tt&gt;to&lt;/tt&gt;.
                 * Bits are returned as a long value with the return value having bit 0 set to bit &lt;code&gt;from&lt;/code&gt;, ..., bit &lt;code&gt;to-from&lt;/code&gt; set to bit &lt;code&gt;to&lt;/code&gt;.
                 * All other bits of return value are set to 0.
                 * If &lt;tt&gt;from &amp;gt; to&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).
                 * Precondition (not checked): &lt;tt&gt;to-from+1 &amp;lt;= 64&lt;/tt&gt;.                
                <@param>
                    m bits the bitvector.                    
                </@param>
                <@param>
                    m from index of start bit (inclusive).                    
                </@param>
                <@param>
                    m to index of end bit (inclusive).                    
                </@param>
                <@return>
                    n the specified bits as long value.                    
                </@return>
            </javadoc>
            <method name="getLongFromTo" type="long" line="92">
                <comment line="93">
                    nal int fromIndex = from &gt;&gt; ADDRESS_BITS_PER_UNIT; //equivalent to from/64                    
                </comment>
                <comment line="93">
                    nal int fromOffset = from &amp; BIT_INDEX_MASK; //equivalent to from%64                    
                </comment>
                <comment line="93">
                    this is equivalent to the above, but slower:                    
                </comment>
                <comment line="93">
                    final int fromIndex=from/BITS_PER_UNIT;                    
                </comment>
                <comment line="93">
                    final int toIndex=to/BITS_PER_UNIT;                    
                </comment>
                <comment line="93">
                    final int fromOffset=from%BITS_PER_UNIT;                    
                </comment>
                <comment line="93">
                    final int toOffset=to%BITS_PER_UNIT;                    
                </comment>
                <comment line="93">
                    range crosses unit boundaries; value to retrieve is spread over two long values.                    
                </comment>
                <comment line="93">
                    get part from first long value                    
                </comment>
                <comment line="93">
                    get part from second long value                    
                </comment>
                <comment line="93">
                    combine                    
                </comment>
                <declaration name="fromIndex" type="int" line="95"/>
                <declaration name="toIndex" type="int" line="96"/>
                <declaration name="fromOffset" type="int" line="97"/>
                <declaration name="toOffset" type="int" line="98"/>
                <declaration name="mask" type="long" line="106"/>
                <scope line="107"/>
                <declaration name="x1" type="long" line="116"/>
                <declaration name="x2" type="long" line="120"/>
            </method>
            <javadoc line="125">
                Returns the index of the least significant bit in state &quot;true&quot;.
                 * Returns 32 if no bit is in state &quot;true&quot;.
                 * Examples: 
                 * &lt;pre&gt;
                 * 0x80000000 --&gt; 31
                 * 0x7fffffff --&gt; 0
                 * 0x00000001 --&gt; 0
                 * 0x00000000 --&gt; 32
                 * &lt;/pre&gt;                
            </javadoc>
            <method name="leastSignificantBit" type="int" line="136">
                <declaration name="i" type="int" line="137"/>
            </method>
            <javadoc line="141">
                Constructs a low level bitvector that holds &lt;tt&gt;size&lt;/tt&gt; elements, with each element taking &lt;tt&gt;bitsPerElement&lt;/tt&gt; bits.                
                <@param>
                    m size   the number of elements to be stored in the bitvector (must be &gt;= 0).                    
                </@param>
                <@param>
                    m bitsPerElement   the number of bits one single element takes.                    
                </@param>
                <@return>
                    n    a low level bitvector.                    
                </@return>
            </javadoc>
            <method name="makeBitVector" type="long[]" line="148">
                <declaration name="nBits" type="int" line="149"/>
                <declaration name="unitIndex" type="int" line="150"/>
                <declaration name="bitVector" type="long[]" line="151"/>
            </method>
            <javadoc line="154">
                Returns the index of the most significant bit in state &quot;true&quot;.
                 * Returns -1 if no bit is in state &quot;true&quot;.
                 * Examples: 
                 * &lt;pre&gt;
                 * 0x80000000 --&gt; 31
                 * 0x7fffffff --&gt; 30
                 * 0x00000001 --&gt; 0
                 * 0x00000000 --&gt; -1
                 * &lt;/pre&gt;                
            </javadoc>
            <method name="mostSignificantBit" type="int" line="165">
                <declaration name="i" type="int" line="166"/>
            </method>
            <javadoc line="170">
                Returns the index within the unit that contains the given bitIndex.                
            </javadoc>
            <method name="offset" type="int" line="173">
                <comment line="174">
                    equivalent to bitIndex%64                    
                </comment>
            </method>
            <javadoc line="177">
                Initializes a table with numbers having 1,2,3,...,64 bits set.
                 * pows[i] has bits [0..i-1] set.
                 * pows[64] == -1L == ~0L == has all 64 bits set --&gt; correct.
                 * to speedup calculations in subsequent methods.                
            </javadoc>
            <method name="precomputePows" type="long[]" line="183">
                <comment line="184">
                    System.out.println((0)+&quot;:&quot;+pows[0]);                    
                </comment>
                <comment line="184">
                    OLD STUFF                    
                </comment>
                <comment line="184">
                    for (int i=BITS_PER_UNIT+1; --i &gt;= 0; ) {                    
                </comment>
                <comment line="184">
                    long[] pows=new long[BITS_PER_UNIT];
                    for (int i=0; i&lt;BITS_PER_UNIT-1; i++) {
                    pows[i]=Math.round(Math.pow(2.0,i+1))-1;                    
                </comment>
                <declaration name="pows" type="long[]" line="184"/>
                <declaration name="value" type="long" line="185"/>
                <scope line="186"/>
            </method>
            <javadoc line="214">
                Sets the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <@param>
                    m bits   the bitvector.                    
                </@param>
                <@param>
                    m bitIndex   the index of the bit to be changed.                    
                </@param>
                <@param>
                    m value   the value to be stored in the bit.                    
                </@param>
            </javadoc>
            <method name="put" type="void" line="221"/>
            <javadoc line="227">
                Sets bits of a bitvector from index &lt;code&gt;from&lt;/code&gt; to index &lt;code&gt;to&lt;/code&gt; to the bits of &lt;code&gt;value&lt;/code&gt;.
                 * Bit &lt;code&gt;from&lt;/code&gt; is set to bit 0 of &lt;code&gt;value&lt;/code&gt;, ..., bit &lt;code&gt;to&lt;/code&gt; is set to bit &lt;code&gt;to-from&lt;/code&gt; of &lt;code&gt;value&lt;/code&gt;.
                 * All other bits stay unaffected.
                 * If &lt;tt&gt;from &amp;gt; to&lt;/tt&gt; then does nothing.
                 * Precondition (not checked): &lt;tt&gt;to-from+1 &amp;lt;= 64&lt;/tt&gt;.                
                <@param>
                    m bits the bitvector.                    
                </@param>
                <@param>
                    m value the value to be copied into the bitvector.                    
                </@param>
                <@param>
                    m from index of start bit (inclusive).                    
                </@param>
                <@param>
                    m to index of end bit (inclusive).                    
                </@param>
            </javadoc>
            <method name="putLongFromTo" type="void" line="239">
                <comment line="240">
                    nal int fromIndex=from &gt;&gt; ADDRESS_BITS_PER_UNIT; //equivalent to from/64                    
                </comment>
                <comment line="240">
                    nal int fromOffset=from &amp; BIT_INDEX_MASK; //equivalent to from%64                    
                </comment>
                <comment line="240">
                    this is equivalent to the above, but slower:
                    int fromIndex=fromBITS_PER_UNIT;                    
                </comment>
                <comment line="240">
                    make sure all unused bits to the left are cleared.                    
                </comment>
                <comment line="240">
                    range crosses unit boundaries; value should go into two long values.                    
                </comment>
                <comment line="240">
                    copy into first long value.                    
                </comment>
                <comment line="240">
                    copy into second long value.                    
                </comment>
                <declaration name="fromIndex" type="int" line="242"/>
                <declaration name="toIndex" type="int" line="243"/>
                <declaration name="fromOffset" type="int" line="244"/>
                <declaration name="toOffset" type="int" line="245"/>
                <declaration name="mask" type="long" line="255"/>
                <declaration name="cleanValue" type="long" line="257"/>
                <declaration name="shiftedValue" type="long" line="259"/>
                <scope line="261"/>
            </method>
            <javadoc line="280">
                Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the &quot;set&quot; (&lt;tt&gt;true&lt;/tt&gt;) state.                
                <@param>
                    m bits   the bitvector.                    
                </@param>
                <@param>
                    m bitIndex   the index of the bit to be set.                    
                </@param>
            </javadoc>
            <method name="set" type="void" line="286"/>
            <javadoc line="289">
                Returns the index of the unit that contains the given bitIndex.                
            </javadoc>
            <method name="unit" type="int" line="292">
                <comment line="293">
                    equivalent to bitIndex/64                    
                </comment>
            </method>
        </class>
    </source>