<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.jet.math">
        <class name="Arithmetic" line="11">
            <extends class="Constants"/>
            <comment line="12">
                for method stirlingCorrection(...)                
            </comment>
            <comment line="12">
                for method logFactorial(...)                
            </comment>
            <comment line="12">
                log(k!) for k = 0, ..., 29                
            </comment>
            <comment line="12">
                k! for k = 0, ..., 20                
            </comment>
            <comment line="12">
                k! for k = 21, ..., 170                
            </comment>
            <javadoc line="11">
                Arithmetic functions.                
            </javadoc>
            <declaration name="stirlingCorrection" type="double[]" line="16"/>
            <declaration name="logFactorials" type="double[]" line="37"/>
            <declaration name="longFactorials" type="long[]" line="51"/>
            <declaration name="doubleFactorials" type="double[]" line="76"/>
            <javadoc line="229">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Arithmetic" type="constructor" line="232"/>
            <javadoc line="233">
                Efficiently returns the binomial coefficient, often also referred to as &quot;n over k&quot; or &quot;n choose k&quot;.
                  The binomial coefficient is defined as &lt;tt&gt;(n  n-1  ...  n-k+1 ) / ( 1  2  ...  k )&lt;/tt&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;k&lt;0&lt;tt&gt;: &lt;tt&gt;0&lt;/tt&gt;.
                  &lt;li&gt;k==0&lt;tt&gt;: &lt;tt&gt;1&lt;/tt&gt;.
                  &lt;li&gt;k==1&lt;tt&gt;: &lt;tt&gt;n&lt;/tt&gt;.
                  &lt;li&gt;else: &lt;tt&gt;(n  n-1  ...  n-k+1 ) / ( 1  2  ...  k )&lt;/tt&gt;.
                  &lt;/ul&gt;                
                <@return>
                    n the binomial coefficient.                    
                </@return>
            </javadoc>
            <method name="binomial" type="double" line="244">
                <params>
                    <param name="n" type="double"/>
                    <param name="k" type="long"/>
                </params>
                <comment line="245">
                    binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )                    
                </comment>
                <declaration name="a" type="double" line="250"/>
                <declaration name="b" type="double" line="251"/>
                <declaration name="binomial" type="double" line="252"/>
                <scope line="253"/>
            </method>
            <javadoc line="258">
                Efficiently returns the binomial coefficient, often also referred to as &quot;n over k&quot; or &quot;n choose k&quot;.
                  The binomial coefficient is defined as
                  &lt;ul&gt;
                  &lt;li&gt;k&lt;0&lt;tt&gt;: &lt;tt&gt;0&lt;/tt&gt;.
                  &lt;li&gt;k==0 || k==n&lt;tt&gt;: &lt;tt&gt;1&lt;/tt&gt;.
                  &lt;li&gt;k==1 || k==n-1&lt;tt&gt;: &lt;tt&gt;n&lt;/tt&gt;.
                  &lt;li&gt;else: &lt;tt&gt;(n  n-1  ...  n-k+1 ) / ( 1  2  ...  k )&lt;/tt&gt;.
                  &lt;/ul&gt;                
                <@return>
                    n the binomial coefficient.                    
                </@return>
            </javadoc>
            <method name="binomial" type="double" line="269">
                <params>
                    <param name="n" type="long"/>
                    <param name="k" type="long"/>
                </params>
                <comment line="270">
                    try quick version and see whether we get numeric overflows.                    
                </comment>
                <comment line="270">
                    factorial(..) is O(1); requires no loop; only a table lookup.                    
                </comment>
                <comment line="270">
                    binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )                    
                </comment>
                <scope line="276">
                    <declaration name="max" type="int" line="277"/>
                    <scope line="278">
                        <declaration name="n_fac" type="double" line="279"/>
                        <declaration name="k_fac" type="double" line="280"/>
                        <declaration name="n_minus_k_fac" type="double" line="281"/>
                        <declaration name="nk" type="double" line="282"/>
                        <scope line="283"/>
                    </scope>
                </scope>
                <declaration name="a" type="long" line="292"/>
                <declaration name="b" type="long" line="293"/>
                <declaration name="binomial" type="double" line="294"/>
                <scope line="295"/>
            </method>
            <javadoc line="300">
                Returns the smallest &lt;code&gt;long &amp;gt;= value&lt;/code&gt;.
                  &lt;dt&gt;Examples: &lt;code&gt;1.0 -&gt; 1, 1.2 -&gt; 2, 1.9 -&gt; 2&lt;/code&gt;.
                  This method is safer than using (long) Math.ceil(value), because of possible rounding error.                
            </javadoc>
            <method name="ceil" type="long" line="305">
                <params>
                    <param name="value" type="double"/>
                </params>
            </method>
            <javadoc line="308">
                Evaluates the series of Chebyshev polynomials Ti at argument x/2.
                  The series is given by
                  &lt;pre&gt;
                  N-1
                  - &apos;
                  y  =   &gt;   coef[i] T (x/2)
                  -            i
                  i=0
                  &lt;/pre&gt;
                  Coefficients are stored in reverse order, i.e. the zero
                  order term is last in the array.  Note N is the number of
                  coefficients, not the order.
                  &lt;p&gt;
                  If coefficients are for the interval a to b, x must
                  have been transformed to x -&gt; 2(2x - b - a)/(b-a) before
                  entering the routine.  This maps x from (a, b) to (-1, 1),
                  over which the Chebyshev polynomials are defined.
                  &lt;p&gt;
                  If the coefficients are for the inverted interval, in
                  which (a, b) is mapped to (1/b, 1/a), the transformation
                  required is x -&gt; 2(2ab/x - b - a)/(b-a).  If b is infinity,
                  this becomes x -&gt; 4a/x - 1.
                  &lt;p&gt;
                  SPEED:
                  &lt;p&gt;
                  Taking advantage of the recurrence properties of the
                  Chebyshev polynomials, the routine requires one more
                  addition per loop than evaluating a nested polynomial of
                  the same degree.                
                <@param>
                    m x argument to the polynomial.                    
                </@param>
                <@param>
                    m coef the coefficients of the polynomial.                    
                </@param>
                <@param>
                    m N the number of coefficients.                    
                </@param>
            </javadoc>
            <method name="chbevl" type="double" line="343">
                <params>
                    <param name="x" type="double"/>
                    <param name="coef" type="double"/>
                    <param name="N" type="int"/>
                </params>
                <declaration name="b0" type="double" line="344"/>
                <declaration name="p" type="int" line="346"/>
                <declaration name="i" type="int" line="347"/>
                <scope line="353"/>
            </method>
            <javadoc line="361">
                Returns the factorial of the argument.                
            </javadoc>
            <method name="fac1" type="long" line="364">
                <params>
                    <param name="j" type="int"/>
                </params>
                <declaration name="i" type="long" line="365"/>
                <declaration name="d" type="long" line="369"/>
            </method>
            <javadoc line="375">
                Returns the factorial of the argument.                
            </javadoc>
            <method name="fac2" type="double" line="378">
                <params>
                    <param name="j" type="int"/>
                </params>
                <declaration name="i" type="long" line="379"/>
                <declaration name="d" type="double" line="382"/>
            </method>
            <javadoc line="388">
                Instantly returns the factorial &lt;tt&gt;k!&lt;/tt&gt;.                
                <@param>
                    m k must hold <tt>k &gt;= 0</tt>.                    
                </@param>
            </javadoc>
            <method name="factorial" type="double" line="392">
                <params>
                    <param name="k" type="int"/>
                </params>
                <declaration name="length1" type="int" line="395"/>
                <declaration name="length2" type="int" line="398"/>
            </method>
            <javadoc line="402">
                Returns the largest &lt;code&gt;long &amp;lt;= value&lt;/code&gt;.
                  &lt;dt&gt;Examples: &lt;code&gt;
                  1.0 -&gt; 1, 1.2 -&gt; 1, 1.9 -&gt; 1 &lt;dt&gt;
                  2.0 -&gt; 2, 2.2 -&gt; 2, 2.9 -&gt; 2 &lt;/code&gt;&lt;dt&gt;
                  This method is safer than using (long) Math.floor(value), because of possible rounding error.                
            </javadoc>
            <method name="floor" type="long" line="409">
                <params>
                    <param name="value" type="double"/>
                </params>
            </method>
            <javadoc line="412">
                Returns &lt;tt&gt;log&lt;sub&gt;base&lt;/sub&gt;value&lt;/tt&gt;.                
            </javadoc>
            <method name="log" type="double" line="415">
                <params>
                    <param name="base" type="double"/>
                    <param name="value" type="double"/>
                </params>
            </method>
            <javadoc line="418">
                Returns &lt;tt&gt;log&lt;sub&gt;10&lt;/sub&gt;value&lt;/tt&gt;.                
            </javadoc>
            <method name="log10" type="double" line="421">
                <params>
                    <param name="value" type="double"/>
                </params>
                <comment line="422">
                    1.0 / Math.log(10) == 0.43429448190325176                    
                </comment>
            </method>
            <javadoc line="425">
                Returns &lt;tt&gt;log&lt;sub&gt;2&lt;/sub&gt;value&lt;/tt&gt;.                
            </javadoc>
            <method name="log2" type="double" line="428">
                <params>
                    <param name="value" type="double"/>
                </params>
                <comment line="429">
                    1.0 / Math.log(2) == 1.4426950408889634                    
                </comment>
            </method>
            <javadoc line="432">
                Returns &lt;tt&gt;log(k!)&lt;/tt&gt;.
                  Tries to avoid overflows.
                  For &lt;tt&gt;k&lt;30&lt;/tt&gt; simply looks up a table in O(1).
                  For &lt;tt&gt;k&gt;=30&lt;/tt&gt; uses stirlings approximation.                
                <@param>
                    m k must hold <tt>k &gt;= 0</tt>.                    
                </@param>
            </javadoc>
            <method name="logFactorial" type="double" line="439">
                <params>
                    <param name="k" type="int"/>
                </params>
                <scope line="440">
                    <declaration name="r" type="double" line="441"/>
                    <declaration name="C0" type="double" line="442"/>
                    <declaration name="C1" type="double" line="443"/>
                    <declaration name="C3" type="double" line="444"/>
                    <declaration name="C5" type="double" line="445"/>
                    <declaration name="C7" type="double" line="446"/>
                </scope>
            </method>
            <javadoc line="455">
                Instantly returns the factorial &lt;tt&gt;k!&lt;/tt&gt;.                
                <@param>
                    m k must hold <tt>k &gt;= 0 && k &lt; 21</tt>.                    
                </@param>
            </javadoc>
            <method name="longFactorial" type="long" line="459">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="465">
                Returns the StirlingCorrection.                 
                  &lt;p&gt;                                                                      
                  Correction term of the Stirling approximation for &lt;tt&gt;log(k!)&lt;/tt&gt;
                  (series in 1/k, or table values for small k)                         
                  with int parameter k.                                            
                  &lt;p&gt;                                                                                                                              
                  &lt;tt&gt;
                  log k! = (k + 1/2)log(k + 1) - (k + 1) + (1/2)log(2Pi) +
                  stirlingCorrection(k + 1)                                    
                  &lt;p&gt;                                                                      
                  log k! = (k + 1/2)log(k)     -  k      + (1/2)log(2Pi) +              
                  stirlingCorrection(k)
                  &lt;/tt&gt;                
            </javadoc>
            <method name="stirlingCorrection" type="double" line="480">
                <params>
                    <param name="k" type="int"/>
                </params>
                <comment line="481">
                    nal double C1 =  8.33333333333333333e-02;     //  +1/12                    
                </comment>
                <comment line="481">
                    nal double C3 = -2.77777777777777778e-03;     //  -1/360                    
                </comment>
                <comment line="481">
                    nal double C5 =  7.93650793650793651e-04;     //  +1/1260                    
                </comment>
                <comment line="481">
                    nal double C7 = -5.95238095238095238e-04;     //  -1/1680                    
                </comment>
                <declaration name="C1" type="double" line="481"/>
                <declaration name="C3" type="double" line="482"/>
                <declaration name="C5" type="double" line="483"/>
                <declaration name="C7" type="double" line="484"/>
                <declaration name="r" type="double" line="486"/>
                <scope line="488"/>
            </method>
            <javadoc line="495">
                Equivalent to &lt;tt&gt;Math.round(binomial(n,k))&lt;/tt&gt;.                
            </javadoc>
            <method name="xlongBinomial" type="long" line="498">
                <params>
                    <param name="n" type="long"/>
                    <param name="k" type="long"/>
                </params>
            </method>
        </class>
    </source>