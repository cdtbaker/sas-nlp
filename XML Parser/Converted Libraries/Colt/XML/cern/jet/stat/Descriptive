<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.jet.stat">
        <import package="cern.colt.list.DoubleArrayList"/>
        <import package="cern.colt.list.IntArrayList"/>
        <class name="Descriptive" line="13">
            <extends class="Object"/>
            <comment line="14">
                Both covariance versions yield the same results but the one above is faster                
            </comment>
            <javadoc line="13">
                Basic descriptive statistics.                
                <@author>
                    r peter.gedeck@pharma.Novartis.com                    
                </@author>
                <@author>
                    r wolfgang.hoschek@cern.ch                    
                </@author>
                <@version>
                    n 0.91, 08-Dec-99                    
                </@version>
            </javadoc>
            <javadoc line="21">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Descriptive" type="constructor" line="24"/>
            <javadoc line="25">
                Returns the auto-correlation of a data sequence.                
            </javadoc>
            <method name="autoCorrelation" type="double" line="28">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="lag" type="int"/>
                    <param name="mean" type="double"/>
                    <param name="variance" type="double"/>
                </params>
                <declaration name="N" type="int" line="29"/>
                <declaration name="elements" type="double[]" line="32"/>
                <declaration name="run" type="double" line="33"/>
            </method>
            <javadoc line="39">
                Checks if the given range is within the contained array&apos;s bounds.                
                <@throws>
                    s IndexOutOfBoundsException if <tt>to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size()</tt>.                    
                </@throws>
            </javadoc>
            <method name="checkRangeFromTo" type="void" line="43">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="theSize" type="int"/>
                </params>
            </method>
            <javadoc line="48">
                Returns the correlation of two data sequences.
                  That is &lt;tt&gt;covariance(data1,data2)/(standardDev1standardDev2)&lt;/tt&gt;.                
            </javadoc>
            <method name="correlation" type="double" line="52">
                <params>
                    <param name="data1" type="DoubleArrayList"/>
                    <param name="standardDev1" type="double"/>
                    <param name="data2" type="DoubleArrayList"/>
                    <param name="standardDev2" type="double"/>
                </params>
            </method>
            <javadoc line="55">
                Returns the covariance of two data sequences, which is 
                  &lt;tt&gt;cov(x,y) = (1/(size()-1))  Sum((x[i]-mean(x))  (y[i]-mean(y)))&lt;/tt&gt;.
                  See the &lt;A HREF=&quot;http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html&quot;&gt; math definition&lt;/A&gt;.                
            </javadoc>
            <method name="covariance" type="double" line="60">
                <params>
                    <param name="data1" type="DoubleArrayList"/>
                    <param name="data2" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="61"/>
                <declaration name="elements1" type="double[]" line="63"/>
                <declaration name="elements2" type="double[]" line="64"/>
                <declaration name="sumx" type="double" line="66"/>
                <scope line="67">
                    <declaration name="x" type="double" line="68"/>
                    <declaration name="y" type="double" line="69"/>
                </scope>
            </method>
            <method name="covariance2" type="double" line="81">
                <params>
                    <param name="data1" type="DoubleArrayList"/>
                    <param name="data2" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="82"/>
                <declaration name="mean1" type="double" line="83"/>
                <declaration name="mean2" type="double" line="84"/>
                <declaration name="covariance" type="double" line="85"/>
                <scope line="86">
                    <declaration name="x" type="double" line="87"/>
                    <declaration name="y" type="double" line="88"/>
                </scope>
            </method>
            <javadoc line="97">
                Durbin-Watson computation.                
            </javadoc>
            <method name="durbinWatson" type="double" line="100">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="101"/>
                <declaration name="elements" type="double[]" line="104"/>
                <declaration name="run" type="double" line="105"/>
                <declaration name="run_sq" type="double" line="106"/>
                <scope line="108">
                    <declaration name="x" type="double" line="109"/>
                </scope>
            </method>
            <javadoc line="116">
                Computes the frequency (number of occurances, count) of each distinct value in the given sorted data.
                  After this call returns both &lt;tt&gt;distinctValues&lt;/tt&gt; and &lt;tt&gt;frequencies&lt;/tt&gt; have a new size (which is equal for both), which is the number of distinct values in the sorted data.
                  &lt;p&gt;
                  Distinct values are filled into &lt;tt&gt;distinctValues&lt;/tt&gt;, starting at index 0.
                  The frequency of each distinct value is filled into &lt;tt&gt;frequencies&lt;/tt&gt;, starting at index 0.
                  As a result, the smallest distinct value (and its frequency) can be found at index 0, the second smallest distinct value (and its frequency) at index 1, ..., the largest distinct value (and its frequency) at index &lt;tt&gt;distinctValues.size()-1&lt;/tt&gt;.
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;br&gt;
                  &lt;tt&gt;elements = (5,6,6,7,8,8) --&gt; distinctValues = (5,6,7,8), frequencies = (1,2,1,2)&lt;/tt&gt;                
                <@param>
                    m sortedData the data; must be sorted ascending.                    
                </@param>
                <@param>
                    m distinctValues a list to be filled with the distinct values; can have any size.                    
                </@param>
                <@param>
                    m frequencies      a list to be filled with the frequencies; can have any size; set this parameter to <tt>null</tt> to ignore it.                    
                </@param>
            </javadoc>
            <method name="frequencies" type="void" line="132">
                <params>
                    <param name="sortedData" type="DoubleArrayList"/>
                    <param name="distinctValues" type="DoubleArrayList"/>
                    <param name="frequencies" type="IntArrayList"/>
                </params>
                <declaration name="sortedElements" type="double[]" line="136"/>
                <declaration name="size" type="int" line="137"/>
                <declaration name="i" type="int" line="138"/>
                <scope line="140">
                    <declaration name="element" type="double" line="141"/>
                    <declaration name="cursor" type="int" line="142"/>
                    <declaration name="runLength" type="int" line="147"/>
                </scope>
            </method>
            <javadoc line="152">
                Returns the geometric mean of a data sequence.
                  Note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.
                  &lt;br&gt;
                  The geometric mean is given by &lt;tt&gt;pow( Product( data[i] ), 1/size)&lt;/tt&gt;
                  which is equivalent to &lt;tt&gt;Math.exp( Sum( Log(data[i]) ) / size)&lt;/tt&gt;.                
            </javadoc>
            <method name="geometricMean" type="double" line="159">
                <params>
                    <param name="size" type="int"/>
                    <param name="sumOfLogarithms" type="double"/>
                </params>
                <comment line="160">
                    this version would easily results in overflows                    
                </comment>
                <comment line="160">
                    return Math.pow(product, 1/size);                    
                </comment>
            </method>
            <javadoc line="165">
                Returns the geometric mean of a data sequence.
                  Note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.
                  &lt;br&gt;
                  The geometric mean is given by &lt;tt&gt;pow( Product( data[i] ), 1/data.size())&lt;/tt&gt;.
                  This method tries to avoid overflows at the expense of an equivalent but somewhat slow definition:
                  &lt;tt&gt;geo = Math.exp( Sum( Log(data[i]) ) / data.size())&lt;/tt&gt;.                
            </javadoc>
            <method name="geometricMean" type="double" line="173">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
            </method>
            <javadoc line="176">
                Returns the harmonic mean of a data sequence.                
                <@param>
                    m size the number of elements in the data sequence.                    
                </@param>
                <@param>
                    m sumOfInversions <tt>Sum( 1.0 / data[i])</tt>.                    
                </@param>
            </javadoc>
            <method name="harmonicMean" type="double" line="182">
                <params>
                    <param name="size" type="int"/>
                    <param name="sumOfInversions" type="double"/>
                </params>
            </method>
            <javadoc line="185">
                Incrementally maintains and updates minimum, maximum, sum and sum of squares of a data sequence.
                  Assume we have already recorded some data sequence elements 
                  and know their minimum, maximum, sum and sum of squares.
                  Assume further, we are to record some more elements 
                  and to derive updated values of minimum, maximum, sum and sum of squares.
                  &lt;p&gt;
                  This method computes those updated values without needing to know the already recorded elements.
                  This is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory.
                  &lt;p&gt;
                  &lt;br&gt;Definition of sumOfSquares: &lt;tt&gt;sumOfSquares(n) = Sum ( data[i]  data[i] )&lt;/tt&gt;.                
                <@param>
                    m data the additional elements to be incorporated into min, max, etc.                    
                </@param>
                <@param>
                    m from the index of the first element within <tt>data</tt> to consider.                    
                </@param>
                <@param>
                    m to the index of the last element within <tt>data</tt> to consider.
                      The method incorporates elements <tt>data[from], ..., data[to]</tt>.                    
                </@param>
                <@param>
                    m inOut the old values in the following format:
                      <ul>
                      <li><tt>inOut[0]</tt> is the old minimum.
                      <li><tt>inOut[1]</tt> is the old maximum.
                      <li><tt>inOut[2]</tt> is the old sum.
                      <li><tt>inOut[3]</tt> is the old sum of squares.
                      </ul>
                      If no data sequence elements have so far been recorded set the values as follows 
                      <ul>
                      <li><tt>inOut[0] = Double.POSITIVE_INFINITY</tt> as the old minimum.
                      <li><tt>inOut[1] = Double.NEGATIVE_INFINITY</tt> as the old maximum.
                      <li><tt>inOut[2] = 0.0</tt> as the old sum.
                      <li><tt>inOut[3] = 0.0</tt> as the old sum of squares.
                      </ul>                    
                </@param>
                <@return>
                    n the updated values filled into the <tt>inOut</tt> array.                    
                </@return>
            </javadoc>
            <method name="incrementalUpdate" type="void" line="220">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="inOut" type="double[]"/>
                </params>
                <comment line="221">
                    read current values                    
                </comment>
                <comment line="221">
                    store new values                    
                </comment>
                <comment line="221">
                    At this point of return the following postcondition holds:                    
                </comment>
                <comment line="221">
                    data.size()-from elements have been consumed by this call.                    
                </comment>
                <declaration name="min" type="double" line="224"/>
                <declaration name="max" type="double" line="225"/>
                <declaration name="sum" type="double" line="226"/>
                <declaration name="sumSquares" type="double" line="227"/>
                <declaration name="elements" type="double[]" line="229"/>
                <scope line="231">
                    <declaration name="element" type="double" line="232"/>
                </scope>
            </method>
            <javadoc line="263">
                Incrementally maintains and updates various sums of powers of the form &lt;tt&gt;Sum(data[i]&lt;sup&gt;k&lt;/sup&gt;)&lt;/tt&gt;.
                  Assume we have already recorded some data sequence elements &lt;tt&gt;data[i]&lt;/tt&gt;
                  and know the values of &lt;tt&gt;Sum(data[i]&lt;sup&gt;from&lt;/sup&gt;), Sum(data[i]&lt;sup&gt;from+1&lt;/sup&gt;), ..., Sum(data[i]&lt;sup&gt;to&lt;/sup&gt;)&lt;/tt&gt;.
                  Assume further, we are to record some more elements 
                  and to derive updated values of these sums.
                  &lt;p&gt;
                  This method computes those updated values without needing to know the already recorded elements.
                  This is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory.
                  For example, the incremental computation of moments is based upon such sums of powers:
                  &lt;p&gt;
                  The moment of &lt;tt&gt;k&lt;/tt&gt;-th order with constant &lt;tt&gt;c&lt;/tt&gt; of a data sequence,
                  is given by &lt;tt&gt;Sum( (data[i]-c)&lt;sup&gt;k&lt;/sup&gt; ) / data.size()&lt;/tt&gt;.
                  It can incrementally be computed by using the equivalent formula
                  &lt;p&gt;
                  &lt;tt&gt;moment(k,c) = m(k,c) / data.size()&lt;/tt&gt; where
                  &lt;br&gt;&lt;tt&gt;m(k,c) = Sum( -1&lt;sup&gt;i&lt;/sup&gt;  b(k,i)  c&lt;sup&gt;i&lt;/sup&gt;  sumOfPowers(k-i))&lt;/tt&gt; for &lt;tt&gt;i = 0 .. k&lt;/tt&gt; and
                  &lt;br&gt;&lt;tt&gt;b(k,i) = &lt;/tt&gt;{@link cern.jet.math.Arithmetic#binomial(long,long) binomial(k,i)} and
                  &lt;br&gt;&lt;tt&gt;sumOfPowers(k) = Sum( data[i]&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt;.
                  &lt;p&gt;                
                <@param>
                    m data the additional elements to be incorporated into min, max, etc.                    
                </@param>
                <@param>
                    m from the index of the first element within <tt>data</tt> to consider.                    
                </@param>
                <@param>
                    m to the index of the last element within <tt>data</tt> to consider.
                      The method incorporates elements <tt>data[from], ..., data[to]</tt>.                    
                </@param>
                <@param>
                    m inOut the old values of the sums in the following format:
                      <ul>
                      <li><tt>sumOfPowers[0]</tt> is the old <tt>Sum(data[i]<sup>fromSumIndex</sup>)</tt>.
                      <li><tt>sumOfPowers[1]</tt> is the old <tt>Sum(data[i]<sup>fromSumIndex+1</sup>)</tt>.
                      <li>...
                      <li><tt>sumOfPowers[toSumIndex-fromSumIndex]</tt> is the old <tt>Sum(data[i]<sup>toSumIndex</sup>)</tt>.
                      </ul>
                      If no data sequence elements have so far been recorded set all old values of the sums to <tt>0.0</tt>.                    
                </@param>
                <@return>
                    n the updated values filled into the <tt>sumOfPowers</tt> array.                    
                </@return>
            </javadoc>
            <method name="incrementalUpdateSumsOfPowers" type="void" line="300">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="fromSumIndex" type="int"/>
                    <param name="toSumIndex" type="int"/>
                    <param name="sumOfPowers" type="double[]"/>
                </params>
                <comment line="301">
                    optimized for common parameters                    
                </comment>
                <comment line="301">
                    now the most general case:                    
                </comment>
                <comment line="301">
                    optimized for maximum speed, but still not quite quick                    
                </comment>
                <comment line="301">
                    At this point of return the following postcondition holds:                    
                </comment>
                <comment line="301">
                    data.size()-fromIndex elements have been consumed by this call.                    
                </comment>
                <declaration name="size" type="int" line="301"/>
                <declaration name="lastIndex" type="int" line="302"/>
                <scope line="306">
                    <scope line="307">
                        <declaration name="elements" type="double[]" line="308"/>
                        <declaration name="sum" type="double" line="309"/>
                        <declaration name="sumSquares" type="double" line="310"/>
                        <scope line="311">
                            <declaration name="element" type="double" line="312"/>
                        </scope>
                    </scope>
                    <scope line="322">
                        <declaration name="elements" type="double[]" line="323"/>
                        <declaration name="sum" type="double" line="324"/>
                        <declaration name="sumSquares" type="double" line="325"/>
                        <declaration name="sum_xxx" type="double" line="326"/>
                        <scope line="327">
                            <declaration name="element" type="double" line="328"/>
                        </scope>
                    </scope>
                    <scope line="340">
                        <declaration name="elements" type="double[]" line="341"/>
                        <declaration name="sum" type="double" line="342"/>
                        <declaration name="sumSquares" type="double" line="343"/>
                        <declaration name="sum_xxx" type="double" line="344"/>
                        <declaration name="sum_xxxx" type="double" line="345"/>
                        <scope line="346">
                            <declaration name="element" type="double" line="347"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="363">
                    <scope line="364"/>
                </scope>
                <declaration name="elements" type="double[]" line="373"/>
                <scope line="375">
                    <declaration name="element" type="double" line="376"/>
                    <declaration name="pow" type="double" line="377"/>
                    <declaration name="j" type="int" line="379"/>
                    <scope line="380"/>
                </scope>
            </method>
            <javadoc line="390">
                Incrementally maintains and updates sum and sum of squares of a &lt;i&gt;weighted&lt;/i&gt; data sequence.
                  Assume we have already recorded some data sequence elements 
                  and know their sum and sum of squares.
                  Assume further, we are to record some more elements 
                  and to derive updated values of sum and sum of squares.
                  &lt;p&gt;
                  This method computes those updated values without needing to know the already recorded elements.
                  This is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory.
                  &lt;p&gt;
                  &lt;br&gt;Definition of sum: &lt;tt&gt;sum = Sum ( data[i]  weights[i] )&lt;/tt&gt;.
                  &lt;br&gt;Definition of sumOfSquares: &lt;tt&gt;sumOfSquares = Sum ( data[i]  data[i]  weights[i])&lt;/tt&gt;.                
                <@param>
                    m data the additional elements to be incorporated into min, max, etc.                    
                </@param>
                <@param>
                    m weights the weight of each element within <tt>data</tt>.                    
                </@param>
                <@param>
                    m from the index of the first element within <tt>data</tt> (and <tt>weights</tt>) to consider.                    
                </@param>
                <@param>
                    m to the index of the last element within <tt>data</tt> (and <tt>weights</tt>) to consider.
                      The method incorporates elements <tt>data[from], ..., data[to]</tt>.                    
                </@param>
                <@param>
                    m inOut the old values in the following format:
                      <ul>
                      <li><tt>inOut[0]</tt> is the old sum.
                      <li><tt>inOut[1]</tt> is the old sum of squares.
                      </ul>
                      If no data sequence elements have so far been recorded set the values as follows 
                      <ul>
                      <li><tt>inOut[0] = 0.0</tt> as the old sum.
                      <li><tt>inOut[1] = 0.0</tt> as the old sum of squares.
                      </ul>                    
                </@param>
                <@return>
                    n the updated values filled into the <tt>inOut</tt> array.                    
                </@return>
            </javadoc>
            <method name="incrementalWeightedUpdate" type="void" line="423">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="weights" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="inOut" type="double[]"/>
                </params>
                <comment line="424">
                    read current values                    
                </comment>
                <comment line="424">
                    store new values                    
                </comment>
                <comment line="424">
                    At this point of return the following postcondition holds:                    
                </comment>
                <comment line="424">
                    data.size()-from elements have been consumed by this call.                    
                </comment>
                <declaration name="dataSize" type="int" line="424"/>
                <declaration name="sum" type="double" line="429"/>
                <declaration name="sumOfSquares" type="double" line="430"/>
                <declaration name="elements" type="double[]" line="432"/>
                <declaration name="w" type="double[]" line="433"/>
                <scope line="435">
                    <declaration name="element" type="double" line="436"/>
                    <declaration name="weight" type="double" line="437"/>
                    <declaration name="prod" type="double" line="438"/>
                </scope>
            </method>
            <javadoc line="451">
                Returns the kurtosis (aka excess) of a data sequence.                
                <@param>
                    m moment4 the fourth central moment, which is <tt>moment(data,4,mean)</tt>.                    
                </@param>
                <@param>
                    m standardDeviation the standardDeviation.                    
                </@param>
            </javadoc>
            <method name="kurtosis" type="double" line="456">
                <params>
                    <param name="moment4" type="double"/>
                    <param name="standardDeviation" type="double"/>
                </params>
            </method>
            <javadoc line="459">
                Returns the kurtosis (aka excess) of a data sequence, which is &lt;tt&gt;-3 + moment(data,4,mean) / standardDeviation&lt;sup&gt;4&lt;/sup&gt;&lt;/tt&gt;.                
            </javadoc>
            <method name="kurtosis" type="double" line="462">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="standardDeviation" type="double"/>
                </params>
            </method>
            <javadoc line="465">
                Returns the lag-1 autocorrelation of a dataset; 
                  Note that this method has semantics different from &lt;tt&gt;autoCorrelation(..., 1)&lt;/tt&gt;;                
            </javadoc>
            <method name="lag1" type="double" line="469">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                </params>
                <declaration name="size" type="int" line="470"/>
                <declaration name="elements" type="double[]" line="471"/>
                <declaration name="r1" type="double" line="472"/>
                <declaration name="q" type="double" line="473"/>
                <declaration name="v" type="double" line="474"/>
                <scope line="476">
                    <declaration name="delta0" type="double" line="477"/>
                    <declaration name="delta1" type="double" line="478"/>
                </scope>
            </method>
            <javadoc line="486">
                Returns the largest member of a data sequence.                
            </javadoc>
            <method name="max" type="double" line="489">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="490"/>
                <declaration name="elements" type="double[]" line="493"/>
                <declaration name="max" type="double" line="494"/>
                <scope line="495"/>
            </method>
            <javadoc line="501">
                Returns the arithmetic mean of a data sequence; 
                  That is &lt;tt&gt;Sum( data[i] ) / data.size()&lt;/tt&gt;.                
            </javadoc>
            <method name="mean" type="double" line="505">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
            </method>
            <javadoc line="508">
                Returns the mean deviation of a dataset.
                  That is &lt;tt&gt;Sum (Math.abs(data[i]-mean)) / data.size())&lt;/tt&gt;.                
            </javadoc>
            <method name="meanDeviation" type="double" line="512">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                </params>
                <declaration name="elements" type="double[]" line="513"/>
                <declaration name="size" type="int" line="514"/>
                <declaration name="sum" type="double" line="515"/>
            </method>
            <javadoc line="519">
                Returns the median of a sorted data sequence.                
                <@param>
                    m sortedData the data sequence; <b>must be sorted ascending</b>.                    
                </@param>
            </javadoc>
            <method name="median" type="double" line="524">
                <params>
                    <param name="sortedData" type="DoubleArrayList"/>
                </params>
                <comment line="525">
                    double[] sortedElements = sortedData.elements();
                    int n = sortedData.size();
                    int lhs = (n - 1)  2 ;                    
                </comment>
            </method>
            <javadoc line="541">
                Returns the smallest member of a data sequence.                
            </javadoc>
            <method name="min" type="double" line="544">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="545"/>
                <declaration name="elements" type="double[]" line="548"/>
                <declaration name="min" type="double" line="549"/>
                <scope line="550"/>
            </method>
            <javadoc line="556">
                Returns the moment of &lt;tt&gt;k&lt;/tt&gt;-th order with constant &lt;tt&gt;c&lt;/tt&gt; of a data sequence,
                  which is &lt;tt&gt;Sum( (data[i]-c)&lt;sup&gt;k&lt;/sup&gt; ) / data.size()&lt;/tt&gt;.                
                <@param>
                    m sumOfPowers <tt>sumOfPowers[m] == Sum( data[i]<sup>m</sup>) )</tt> for <tt>m = 0,1,..,k</tt> as returned by method {@link #incrementalUpdateSumsOfPowers(DoubleArrayList,int,int,int,int,double[])}.
                      In particular there must hold <tt>sumOfPowers.length == k+1</tt>.                    
                </@param>
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
            </javadoc>
            <method name="moment" type="double" line="564">
                <params>
                    <param name="k" type="int"/>
                    <param name="c" type="double"/>
                    <param name="size" type="int"/>
                    <param name="sumOfPowers" type="double[]"/>
                </params>
                <comment line="565">
                    for (int i=0; i&lt;=k; i++) {                    
                </comment>
                <declaration name="sum" type="double" line="565"/>
                <declaration name="sign" type="int" line="566"/>
                <scope line="567">
                    <declaration name="y" type="double" line="568"/>
                </scope>
            </method>
            <javadoc line="586">
                Returns the moment of &lt;tt&gt;k&lt;/tt&gt;-th order with constant &lt;tt&gt;c&lt;/tt&gt; of a data sequence,
                  which is &lt;tt&gt;Sum( (data[i]-c)&lt;sup&gt;k&lt;/sup&gt; ) / data.size()&lt;/tt&gt;.                
            </javadoc>
            <method name="moment" type="double" line="590">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="k" type="int"/>
                    <param name="c" type="double"/>
                </params>
            </method>
            <javadoc line="593">
                Returns the pooled mean of two data sequences.
                  That is &lt;tt&gt;(size1  mean1 + size2  mean2) / (size1 + size2)&lt;/tt&gt;.                
                <@param>
                    m size1 the number of elements in data sequence 1.                    
                </@param>
                <@param>
                    m mean1 the mean of data sequence 1.                    
                </@param>
                <@param>
                    m size2 the number of elements in data sequence 2.                    
                </@param>
                <@param>
                    m mean2 the mean of data sequence 2.                    
                </@param>
            </javadoc>
            <method name="pooledMean" type="double" line="602">
                <params>
                    <param name="size1" type="int"/>
                    <param name="mean1" type="double"/>
                    <param name="size2" type="int"/>
                    <param name="mean2" type="double"/>
                </params>
            </method>
            <javadoc line="605">
                Returns the pooled variance of two data sequences.
                  That is &lt;tt&gt;(size1  variance1 + size2  variance2) / (size1 + size2)&lt;/tt&gt;;                
                <@param>
                    m size1 the number of elements in data sequence 1.                    
                </@param>
                <@param>
                    m variance1 the variance of data sequence 1.                    
                </@param>
                <@param>
                    m size2 the number of elements in data sequence 2.                    
                </@param>
                <@param>
                    m variance2 the variance of data sequence 2.                    
                </@param>
            </javadoc>
            <method name="pooledVariance" type="double" line="614">
                <params>
                    <param name="size1" type="int"/>
                    <param name="variance1" type="double"/>
                    <param name="size2" type="int"/>
                    <param name="variance2" type="double"/>
                </params>
            </method>
            <javadoc line="617">
                Returns the product, which is &lt;tt&gt;Prod( data[i] )&lt;/tt&gt;.
                  In other words: &lt;tt&gt;data[0]data[1]...data[data.size()-1]&lt;/tt&gt;.
                  This method uses the equivalent definition:
                  &lt;tt&gt;prod = pow( exp( Sum( Log(x[i]) ) / size(), size())&lt;/tt&gt;.                
            </javadoc>
            <method name="product" type="double" line="623">
                <params>
                    <param name="size" type="int"/>
                    <param name="sumOfLogarithms" type="double"/>
                </params>
            </method>
            <javadoc line="626">
                Returns the product of a data sequence, which is &lt;tt&gt;Prod( data[i] )&lt;/tt&gt;.
                  In other words: &lt;tt&gt;data[0]data[1]...data[data.size()-1]&lt;/tt&gt;.
                  Note that you may easily get numeric overflows.                
            </javadoc>
            <method name="product" type="double" line="631">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="632"/>
                <declaration name="elements" type="double[]" line="633"/>
                <declaration name="product" type="double" line="635"/>
            </method>
            <javadoc line="640">
                Returns the &lt;tt&gt;phi-&lt;/tt&gt;quantile; that is, an element &lt;tt&gt;elem&lt;/tt&gt; for which holds that &lt;tt&gt;phi&lt;/tt&gt; percent of data elements are less than &lt;tt&gt;elem&lt;/tt&gt;.
                  The quantile need not necessarily be contained in the data sequence, it can be a linear interpolation.                
                <@param>
                    m sortedData the data sequence; <b>must be sorted ascending</b>.                    
                </@param>
                <@param>
                    m phi the percentage; must satisfy <tt>0 &lt;= phi &lt;= 1</tt>.                    
                </@param>
            </javadoc>
            <method name="quantile" type="double" line="646">
                <params>
                    <param name="sortedData" type="DoubleArrayList"/>
                    <param name="phi" type="double"/>
                </params>
                <declaration name="sortedElements" type="double[]" line="647"/>
                <declaration name="n" type="int" line="648"/>
                <declaration name="index" type="double" line="650"/>
                <declaration name="lhs" type="int" line="651"/>
                <declaration name="delta" type="double" line="652"/>
                <declaration name="result" type="double" line="653"/>
                <scope line="657"/>
                <scope line="660"/>
            </method>
            <javadoc line="666">
                Returns how many percent of the elements contained in the receiver are &lt;tt&gt;&amp;lt;= element&lt;/tt&gt;.
                  Does linear interpolation if the element is not contained but lies in between two contained elements.                
                <@param>
                    m sortedList the list to be searched (must be sorted ascending).                    
                </@param>
                <@param>
                    m element the element to search for.                    
                </@param>
                <@return>
                    n the percentage <tt>phi</tt> of elements <tt>&lt;= element</tt> (<tt>0.0 &lt;= phi &lt;= 1.0)</tt>.                    
                </@return>
            </javadoc>
            <method name="quantileInverse" type="double" line="674">
                <params>
                    <param name="sortedList" type="DoubleArrayList"/>
                    <param name="element" type="double"/>
                </params>
            </method>
            <javadoc line="677">
                Returns the quantiles of the specified percentages.
                  The quantiles need not necessarily be contained in the data sequence, it can be a linear interpolation.                
                <@param>
                    m sortedData the data sequence; <b>must be sorted ascending</b>.                    
                </@param>
                <@param>
                    m percentages the percentages for which quantiles are to be computed.
                      Each percentage must be in the interval <tt>[0.0,1.0]</tt>.                    
                </@param>
                <@return>
                    n the quantiles.                    
                </@return>
            </javadoc>
            <method name="quantiles" type="DoubleArrayList" line="685">
                <params>
                    <param name="sortedData" type="DoubleArrayList"/>
                    <param name="percentages" type="DoubleArrayList"/>
                </params>
                <declaration name="s" type="int" line="686"/>
                <declaration name="quantiles" type="DoubleArrayList" line="687"/>
                <scope line="689"/>
            </method>
            <javadoc line="695">
                Returns the linearly interpolated number of elements in a list less or equal to a given element.
                  The rank is the number of elements &lt;= element.
                  Ranks are of the form &lt;tt&gt;{0, 1, 2,..., sortedList.size()}&lt;/tt&gt;.
                  If no element is &lt;= element, then the rank is zero.
                  If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned.                
                <@param>
                    m sortedList the list to be searched (must be sorted ascending).                    
                </@param>
                <@param>
                    m element the element to search for.                    
                </@param>
                <@return>
                    n the rank of the element.                    
                </@return>
            </javadoc>
            <method name="rankInterpolated" type="double" line="706">
                <params>
                    <param name="sortedList" type="DoubleArrayList"/>
                    <param name="element" type="double"/>
                </params>
                <comment line="707">
                    element not found                    
                </comment>
                <comment line="707">
                    uble delta = (element-from) / (to-from); //linear interpolation                    
                </comment>
                <declaration name="index" type="int" line="707"/>
                <scope line="708">
                    <declaration name="to" type="int" line="710"/>
                    <declaration name="s" type="int" line="711"/>
                </scope>
                <declaration name="insertionPoint" type="int" line="717"/>
                <declaration name="from" type="double" line="720"/>
                <declaration name="to" type="double" line="721"/>
                <declaration name="delta" type="double" line="722"/>
            </method>
            <javadoc line="725">
                Returns the RMS (Root-Mean-Square) of a data sequence.
                  That is &lt;tt&gt;Math.sqrt(Sum( data[i]data[i] ) / data.size())&lt;/tt&gt;.
                  The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence.
                  It is a measure of the average &quot;size&quot; of the elements of a data sequence.                
                <@param>
                    m sumOfSquares <tt>sumOfSquares(data) == Sum( data[i]data[i] )</tt> of the data sequence.                    
                </@param>
                <@param>
                    m size the number of elements in the data sequence.                    
                </@param>
            </javadoc>
            <method name="rms" type="double" line="734">
                <params>
                    <param name="size" type="int"/>
                    <param name="sumOfSquares" type="double"/>
                </params>
            </method>
            <javadoc line="737">
                Returns the sample kurtosis (aka excess) of a data sequence.
                  Ref: R.R. Sokal, F.J. Rohlf, Biometry: the principles and practice of statistics
                  in biological research (W.H. Freeman and Company, New York, 1998, 3rd edition)
                  p. 114-115.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
                <@param>
                    m moment4 the fourth central moment, which is <tt>moment(data,4,mean)</tt>.                    
                </@param>
                <@param>
                    m sampleVariance the <b>sample variance</b>.                    
                </@param>
            </javadoc>
            <method name="sampleKurtosis" type="double" line="748">
                <params>
                    <param name="size" type="int"/>
                    <param name="moment4" type="double"/>
                    <param name="sampleVariance" type="double"/>
                </params>
                <comment line="749">
                    uble s2=sampleVariance; // (y-ymean)^2/(n-1)                    
                </comment>
                <comment line="749">
                    uble m4 = moment4*n;    // (y-ymean)^4                    
                </comment>
                <declaration name="n" type="int" line="749"/>
                <declaration name="s2" type="double" line="750"/>
                <declaration name="m4" type="double" line="751"/>
            </method>
            <javadoc line="755">
                Returns the sample kurtosis (aka excess) of a data sequence.                
            </javadoc>
            <method name="sampleKurtosis" type="double" line="758">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="sampleVariance" type="double"/>
                </params>
            </method>
            <javadoc line="761">
                Return the standard error of the sample kurtosis.
                  Ref: R.R. Sokal, F.J. Rohlf, Biometry: the principles and practice of statistics
                  in biological research (W.H. Freeman and Company, New York, 1998, 3rd edition)
                  p. 138.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
            </javadoc>
            <method name="sampleKurtosisStandardError" type="double" line="770">
                <params>
                    <param name="size" type="int"/>
                </params>
                <declaration name="n" type="int" line="771"/>
            </method>
            <javadoc line="774">
                Returns the sample skew of a data sequence.
                  Ref: R.R. Sokal, F.J. Rohlf, Biometry: the principles and practice of statistics
                  in biological research (W.H. Freeman and Company, New York, 1998, 3rd edition)
                  p. 114-115.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
                <@param>
                    m moment3 the third central moment, which is <tt>moment(data,3,mean)</tt>.                    
                </@param>
                <@param>
                    m sampleVariance the <b>sample variance</b>.                    
                </@param>
            </javadoc>
            <method name="sampleSkew" type="double" line="785">
                <params>
                    <param name="size" type="int"/>
                    <param name="moment3" type="double"/>
                    <param name="sampleVariance" type="double"/>
                </params>
                <comment line="786">
                    uble s=Math.sqrt(sampleVariance); // sqrt( (y-ymean)^2/(n-1) )                    
                </comment>
                <comment line="786">
                    uble m3 = moment3*n;    // (y-ymean)^3                    
                </comment>
                <declaration name="n" type="int" line="786"/>
                <declaration name="s" type="double" line="787"/>
                <declaration name="m3" type="double" line="788"/>
            </method>
            <javadoc line="791">
                Returns the sample skew of a data sequence.                
            </javadoc>
            <method name="sampleSkew" type="double" line="794">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="sampleVariance" type="double"/>
                </params>
            </method>
            <javadoc line="797">
                Return the standard error of the sample skew.
                  Ref: R.R. Sokal, F.J. Rohlf, Biometry: the principles and practice of statistics
                  in biological research (W.H. Freeman and Company, New York, 1998, 3rd edition)
                  p. 138.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
            </javadoc>
            <method name="sampleSkewStandardError" type="double" line="806">
                <params>
                    <param name="size" type="int"/>
                </params>
                <declaration name="n" type="int" line="807"/>
            </method>
            <javadoc line="810">
                Returns the sample standard deviation.
                  Ref: R.R. Sokal, F.J. Rohlf, Biometry: the principles and practice of statistics
                  in biological research (W.H. Freeman and Company, New York, 1998, 3rd edition)
                  p. 53.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
                <@param>
                    m sampleVariance the <b>sample variance</b>.                    
                </@param>
            </javadoc>
            <method name="sampleStandardDeviation" type="double" line="820">
                <params>
                    <param name="size" type="int"/>
                    <param name="sampleVariance" type="double"/>
                </params>
                <comment line="821">
                    The standard deviation calculated as the sqrt of the variance underestimates                    
                </comment>
                <comment line="821">
                    the unbiased standard deviation.                    
                </comment>
                <comment line="821">
                    It needs to be multiplied by this correction factor.                    
                </comment>
                <declaration name="s" type="double" line="821"/>
                <declaration name="n" type="int" line="822"/>
                <scope line="828"/>
                <scope line="830"/>
            </method>
            <javadoc line="835">
                Returns the sample variance of a data sequence.
                  That is &lt;tt&gt;(sumOfSquares - meansum) / (size - 1)&lt;/tt&gt; with &lt;tt&gt;mean = sum/size&lt;/tt&gt;.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
                <@param>
                    m sum <tt>== Sum( data[i] )</tt>.                    
                </@param>
                <@param>
                    m sumOfSquares <tt>== Sum( data[i]data[i] )</tt>.                    
                </@param>
            </javadoc>
            <method name="sampleVariance" type="double" line="843">
                <params>
                    <param name="size" type="int"/>
                    <param name="sum" type="double"/>
                    <param name="sumOfSquares" type="double"/>
                </params>
                <declaration name="mean" type="double" line="844"/>
            </method>
            <javadoc line="847">
                Returns the sample variance of a data sequence.
                  That is &lt;tt&gt;Sum ( (data[i]-mean)^2 ) / (data.size()-1)&lt;/tt&gt;.                
            </javadoc>
            <method name="sampleVariance" type="double" line="851">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                </params>
                <comment line="852">
                    find the sum of the squares                    
                </comment>
                <declaration name="elements" type="double[]" line="852"/>
                <declaration name="size" type="int" line="853"/>
                <declaration name="sum" type="double" line="854"/>
                <scope line="856">
                    <declaration name="delta" type="double" line="857"/>
                </scope>
            </method>
            <javadoc line="863">
                Returns the sample weighted variance of a data sequence.
                  That is &lt;tt&gt;(sumOfSquaredProducts  -  sumOfProducts  sumOfProducts / sumOfWeights) / (sumOfWeights - 1)&lt;/tt&gt;.                
                <@param>
                    m sumOfWeights <tt>== Sum( weights[i] )</tt>.                    
                </@param>
                <@param>
                    m sumOfProducts <tt>== Sum( data[i]  weights[i] )</tt>.                    
                </@param>
                <@param>
                    m sumOfSquaredProducts <tt>== Sum( data[i]  data[i]  weights[i] )</tt>.                    
                </@param>
            </javadoc>
            <method name="sampleWeightedVariance" type="double" line="871">
                <params>
                    <param name="sumOfWeights" type="double"/>
                    <param name="sumOfProducts" type="double"/>
                    <param name="sumOfSquaredProducts" type="double"/>
                </params>
            </method>
            <javadoc line="874">
                Returns the skew of a data sequence.                
                <@param>
                    m moment3 the third central moment, which is <tt>moment(data,3,mean)</tt>.                    
                </@param>
                <@param>
                    m standardDeviation the standardDeviation.                    
                </@param>
            </javadoc>
            <method name="skew" type="double" line="879">
                <params>
                    <param name="moment3" type="double"/>
                    <param name="standardDeviation" type="double"/>
                </params>
            </method>
            <javadoc line="882">
                Returns the skew of a data sequence, which is &lt;tt&gt;moment(data,3,mean) / standardDeviation&lt;sup&gt;3&lt;/sup&gt;&lt;/tt&gt;.                
            </javadoc>
            <method name="skew" type="double" line="885">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="standardDeviation" type="double"/>
                </params>
            </method>
            <javadoc line="888">
                Splits (partitions) a list into sublists such that each sublist contains the elements with a given range.
                  &lt;tt&gt;splitters=(a,b,c,...,y,z)&lt;/tt&gt; defines the ranges &lt;tt&gt;[-inf,a), [a,b), [b,c), ..., [y,z), [z,inf]&lt;/tt&gt;.
                  &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;br&gt;
                  &lt;ul&gt;
                  &lt;tt&gt;data = (1,2,3,4,5,8,8,8,10,11)&lt;/tt&gt;.
                  &lt;br&gt;&lt;tt&gt;splitters=(2,8)&lt;/tt&gt; yields 3 bins: &lt;tt&gt;(1), (2,3,4,5) (8,8,8,10,11)&lt;/tt&gt;.
                  &lt;br&gt;&lt;tt&gt;splitters=()&lt;/tt&gt; yields 1 bin: &lt;tt&gt;(1,2,3,4,5,8,8,8,10,11)&lt;/tt&gt;.
                  &lt;br&gt;&lt;tt&gt;splitters=(-5)&lt;/tt&gt; yields 2 bins: &lt;tt&gt;(), (1,2,3,4,5,8,8,8,10,11)&lt;/tt&gt;.
                  &lt;br&gt;&lt;tt&gt;splitters=(100)&lt;/tt&gt; yields 2 bins: &lt;tt&gt;(1,2,3,4,5,8,8,8,10,11), ()&lt;/tt&gt;.
                  &lt;/ul&gt;                
                <@param>
                    m sortedList the list to be partitioned (must be sorted ascending).                    
                </@param>
                <@param>
                    m splitters the points at which the list shall be partitioned (must be sorted ascending).                    
                </@param>
                <@return>
                    n the sublists (an array with <tt>length == splitters.size() + 1</tt>.
                      Each sublist is returned sorted ascending.                    
                </@return>
            </javadoc>
            <method name="split" type="DoubleArrayList[]" line="904">
                <params>
                    <param name="sortedList" type="DoubleArrayList"/>
                    <param name="splitters" type="DoubleArrayList"/>
                </params>
                <comment line="905">
                    assertion: data is sorted ascending.                    
                </comment>
                <comment line="905">
                    assertion: splitValues is sorted ascending.                    
                </comment>
                <comment line="905">
                    now fill the remainder                    
                </comment>
                <declaration name="noOfBins" type="int" line="907"/>
                <declaration name="bins" type="DoubleArrayList[]" line="909"/>
                <declaration name="listSize" type="int" line="912"/>
                <declaration name="nextStart" type="int" line="913"/>
                <declaration name="i" type="int" line="914"/>
                <scope line="915">
                    <declaration name="splitValue" type="double" line="916"/>
                    <declaration name="index" type="int" line="917"/>
                    <scope line="918">
                        <declaration name="insertionPosition" type="int" line="919"/>
                    </scope>
                    <scope line="923">
                        <scope line="926"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="941">
                Returns the standard deviation from a variance.                
            </javadoc>
            <method name="standardDeviation" type="double" line="944">
                <params>
                    <param name="variance" type="double"/>
                </params>
            </method>
            <javadoc line="947">
                Returns the standard error of a data sequence.
                  That is &lt;tt&gt;Math.sqrt(variance/size)&lt;/tt&gt;.                
                <@param>
                    m size the number of elements in the data sequence.                    
                </@param>
                <@param>
                    m variance the variance of the data sequence.                    
                </@param>
            </javadoc>
            <method name="standardError" type="double" line="954">
                <params>
                    <param name="size" type="int"/>
                    <param name="variance" type="double"/>
                </params>
            </method>
            <javadoc line="957">
                Modifies a data sequence to be standardized.
                  Changes each element &lt;tt&gt;data[i]&lt;/tt&gt; as follows: &lt;tt&gt;data[i] = (data[i]-mean)/standardDeviation&lt;/tt&gt;.                
            </javadoc>
            <method name="standardize" type="void" line="961">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="standardDeviation" type="double"/>
                </params>
                <declaration name="elements" type="double[]" line="962"/>
            </method>
            <javadoc line="965">
                Returns the sum of a data sequence.
                  That is &lt;tt&gt;Sum( data[i] )&lt;/tt&gt;.                
            </javadoc>
            <method name="sum" type="double" line="969">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
            </method>
            <javadoc line="972">
                Returns the sum of inversions of a data sequence,
                  which is &lt;tt&gt;Sum( 1.0 / data[i])&lt;/tt&gt;.                
                <@param>
                    m data the data sequence.                    
                </@param>
                <@param>
                    m from the index of the first data element (inclusive).                    
                </@param>
                <@param>
                    m to the index of the last data element (inclusive).                    
                </@param>
            </javadoc>
            <method name="sumOfInversions" type="double" line="979">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
            </method>
            <javadoc line="982">
                Returns the sum of logarithms of a data sequence, which is &lt;tt&gt;Sum( Log(data[i])&lt;/tt&gt;.                
                <@param>
                    m data the data sequence.                    
                </@param>
                <@param>
                    m from the index of the first data element (inclusive).                    
                </@param>
                <@param>
                    m to the index of the last data element (inclusive).                    
                </@param>
            </javadoc>
            <method name="sumOfLogarithms" type="double" line="988">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="elements" type="double[]" line="989"/>
                <declaration name="logsum" type="double" line="990"/>
            </method>
            <javadoc line="994">
                Returns &lt;tt&gt;Sum( (data[i]-c)&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt;; optimized for common parameters like &lt;tt&gt;c == 0.0&lt;/tt&gt; and/or &lt;tt&gt;k == -2 .. 4&lt;/tt&gt;.                
            </javadoc>
            <method name="sumOfPowerDeviations" type="double" line="997">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="k" type="int"/>
                    <param name="c" type="double"/>
                </params>
            </method>
            <javadoc line="1000">
                Returns &lt;tt&gt;Sum( (data[i]-c)&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt; for all &lt;tt&gt;i = from .. to&lt;/tt&gt;; optimized for common parameters like &lt;tt&gt;c == 0.0&lt;/tt&gt; and/or &lt;tt&gt;k == -2 .. 5&lt;/tt&gt;.                
            </javadoc>
            <method name="sumOfPowerDeviations" type="double" line="1003">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="k" type="int"/>
                    <param name="c" type="double"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="elements" type="double[]" line="1004"/>
                <declaration name="sum" type="double" line="1005"/>
                <declaration name="v" type="double" line="1006"/>
                <declaration name="i" type="int" line="1007"/>
                <scope line="1010"/>
                <scope line="1011"/>
                <scope line="1025"/>
                <scope line="1026"/>
                <scope line="1029"/>
                <scope line="1030"/>
                <scope line="1033"/>
                <scope line="1034"/>
                <scope line="1037"/>
                <scope line="1038"/>
            </method>
            <javadoc line="1046">
                Returns the sum of powers of a data sequence, which is &lt;tt&gt;Sum ( data[i]&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt;.                
            </javadoc>
            <method name="sumOfPowers" type="double" line="1049">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="1052">
                Returns the sum of squared mean deviation of of a data sequence.
                  That is &lt;tt&gt;variance  (size-1) == Sum( (data[i] - mean)^2 )&lt;/tt&gt;.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
                <@param>
                    m variance the variance of the data sequence.                    
                </@param>
            </javadoc>
            <method name="sumOfSquaredDeviations" type="double" line="1059">
                <params>
                    <param name="size" type="int"/>
                    <param name="variance" type="double"/>
                </params>
            </method>
            <javadoc line="1062">
                Returns the sum of squares of a data sequence.
                  That is &lt;tt&gt;Sum ( data[i]data[i] )&lt;/tt&gt;.                
            </javadoc>
            <method name="sumOfSquares" type="double" line="1066">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                </params>
            </method>
            <javadoc line="1069">
                Returns the trimmed mean of a sorted data sequence.                
                <@param>
                    m sortedData the data sequence; <b>must be sorted ascending</b>.                    
                </@param>
                <@param>
                    m mean the mean of the (full) sorted data sequence.                    
                </@param>
                <@left>
                    t the number of leading elements to trim.                    
                </@left>
                <@right>
                    t the number of trailing elements to trim.                    
                </@right>
            </javadoc>
            <method name="trimmedMean" type="double" line="1077">
                <params>
                    <param name="sortedData" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="left" type="int"/>
                    <param name="right" type="int"/>
                </params>
                <declaration name="N" type="int" line="1078"/>
                <declaration name="sortedElements" type="double[]" line="1082"/>
                <declaration name="N0" type="int" line="1083"/>
            </method>
            <javadoc line="1090">
                Returns the variance from a standard deviation.                
            </javadoc>
            <method name="variance" type="double" line="1093">
                <params>
                    <param name="standardDeviation" type="double"/>
                </params>
            </method>
            <javadoc line="1096">
                Returns the variance of a data sequence.
                  That is &lt;tt&gt;(sumOfSquares - meansum) / size&lt;/tt&gt; with &lt;tt&gt;mean = sum/size&lt;/tt&gt;.                
                <@param>
                    m size the number of elements of the data sequence.                    
                </@param>
                <@param>
                    m sum <tt>== Sum( data[i] )</tt>.                    
                </@param>
                <@param>
                    m sumOfSquares <tt>== Sum( data[i]data[i] )</tt>.                    
                </@param>
            </javadoc>
            <method name="variance" type="double" line="1104">
                <params>
                    <param name="size" type="int"/>
                    <param name="sum" type="double"/>
                    <param name="sumOfSquares" type="double"/>
                </params>
                <declaration name="mean" type="double" line="1105"/>
            </method>
            <javadoc line="1108">
                Returns the weighted mean of a data sequence.
                  That is &lt;tt&gt; Sum (data[i]  weights[i]) / Sum ( weights[i] )&lt;/tt&gt;.                
            </javadoc>
            <method name="weightedMean" type="double" line="1112">
                <params>
                    <param name="data" type="DoubleArrayList"/>
                    <param name="weights" type="DoubleArrayList"/>
                </params>
                <declaration name="size" type="int" line="1113"/>
                <declaration name="elements" type="double[]" line="1116"/>
                <declaration name="theWeights" type="double[]" line="1117"/>
                <declaration name="sum" type="double" line="1118"/>
                <declaration name="weightsSum" type="double" line="1119"/>
                <scope line="1120">
                    <declaration name="w" type="double" line="1121"/>
                </scope>
            </method>
            <javadoc line="1128">
                Returns the weighted RMS (Root-Mean-Square) of a data sequence.
                  That is &lt;tt&gt;Sum( data[i]  data[i]  weights[i]) / Sum( data[i]  weights[i] )&lt;/tt&gt;,
                  or in other words &lt;tt&gt;sumOfProducts / sumOfSquaredProducts&lt;/tt&gt;.                
                <@param>
                    m sumOfProducts <tt>== Sum( data[i]  weights[i] )</tt>.                    
                </@param>
                <@param>
                    m sumOfSquaredProducts <tt>== Sum( data[i]  data[i]  weights[i] )</tt>.                    
                </@param>
            </javadoc>
            <method name="weightedRMS" type="double" line="1136">
                <params>
                    <param name="sumOfProducts" type="double"/>
                    <param name="sumOfSquaredProducts" type="double"/>
                </params>
            </method>
            <javadoc line="1139">
                Returns the winsorized mean of a sorted data sequence.                
                <@param>
                    m sortedData the data sequence; <b>must be sorted ascending</b>.                    
                </@param>
                <@param>
                    m mean the mean of the (full) sorted data sequence.                    
                </@param>
                <@left>
                    t the number of leading elements to trim.                    
                </@left>
                <@right>
                    t the number of trailing elements to trim.                    
                </@right>
            </javadoc>
            <method name="winsorizedMean" type="double" line="1147">
                <params>
                    <param name="sortedData" type="DoubleArrayList"/>
                    <param name="mean" type="double"/>
                    <param name="left" type="int"/>
                    <param name="right" type="int"/>
                </params>
                <declaration name="N" type="int" line="1148"/>
                <declaration name="sortedElements" type="double[]" line="1152"/>
                <declaration name="leftElement" type="double" line="1154"/>
                <declaration name="rightElement" type="double" line="1158"/>
            </method>
        </class>
    </source>