<?xml version="1.0" encoding="UTF-8"?>
<source package="hep.aida.bin">
  <import name="cern.colt.list.DoubleArrayList" />
  <import name="cern.jet.stat.Descriptive" />
  <class name="MightyStaticBin1D" extends="StaticBin1D" startLine="5">
    <javadoc>
      <text>* Static and the same as its superclass, except that it can do more: Additionally computes moments of arbitrary integer order, harmonic mean, geometric mean, etc.
 * Constructors need to be told what functionality is required for the given use case.
 * Only maintains aggregate measures (incrementally) - the added elements themselves are not kept.</text>
      <author>wolfgang.hoschek@cern.ch</author>
      <version>0.9, 03-Jul-99</version>
    </javadoc>
    <declaration type="boolean" name="hasSumOfLogarithms" />
    <declaration type="double" name="sumOfLogarithms" />
    <declaration type="boolean" name="hasSumOfInversions" />
    <declaration type="double" name="sumOfInversions" />
    <declaration type="double[]" name="sumOfPowers" />
    <javadoc>
      <text>* Constructs and returns an empty bin with limited functionality but good performance; equivalent to <tt>MightyStaticBin1D(false,false,4)</tt>.</text>
    </javadoc>
    <method type="constructor" name="MightyStaticBin1D" startLine="25" endLine="27" />
    <javadoc>
      <text>* Constructs and returns an empty bin with the given capabilities.</text>
      <param>hasSumOfLogarithms  Tells whether {@link #sumOfLogarithms()} can return meaningful results.
 * Set this parameter to <tt>false</tt> if measures of sum of logarithms, geometric mean and product are not required.
 * <p></param>
      <param>hasSumOfInversions  Tells whether {@link #sumOfInversions()} can return meaningful results.
 * Set this parameter to <tt>false</tt> if measures of sum of inversions, harmonic mean and sumOfPowers(-1) are not required.
 * <p></param>
      <param>maxOrderForSumOfPowers  The maximum order <tt>k</tt> for which {@link #sumOfPowers(int)} can return meaningful results.
 * Set this parameter to at least 3 if the skew is required, to at least 4 if the kurtosis is required.
 * In general, if moments are required set this parameter at least as large as the largest required moment.
 * This method always substitutes <tt>Math.max(2,maxOrderForSumOfPowers)</tt> for the parameter passed in.
 * Thus, <tt>sumOfPowers(0..2)</tt> always returns meaningful results.</param>
      <see>#hasSumOfPowers(int)</see>
      <see>#moment(int,double)</see>
    </javadoc>
    <method type="constructor" name="MightyStaticBin1D" startLine="46" endLine="51" />
    <javadoc>
      <text>* Adds the part of the specified list between indexes <tt>from</tt> (inclusive) and <tt>to</tt> (inclusive) to the receiver.</text>
      <param>list the list of which elements shall be added.</param>
      <param>from the index of the first element to be added (inclusive).</param>
      <param>to the index of the last element to be added (inclusive).</param>
      <throws>IndexOutOfBoundsException if <tt>list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size())</tt>.</throws>
    </javadoc>
    <method type="void" name="addAllOfFromTo" startLine="60" endLine="75">
      <scope startLine="63" endLine="66">
        <comment>int max_k = this.min_k + this.sumOfPowers.length-1;</comment>
      </scope>
      <scope startLine="68" endLine="70" />
      <scope startLine="72" endLine="74" />
    </method>
    <javadoc>
      <text>* Resets the values of all measures.</text>
    </javadoc>
    <method type="void" name="clearAllMeasures" startLine="79" endLine="90">
      <scope startLine="85" endLine="89">
        <scope startLine="86" endLine="88" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a deep copy of the receiver.</text>
      <return>a deep copy of the receiver.</return>
    </javadoc>
    <method type="Object" name="clone" startLine="96" endLine="100">
      <declaration type="MightyStaticBin1D" name="clone" />
    </method>
    <javadoc>
      <text>* Computes the deviations from the receiver's measures to another bin's measures.</text>
      <param>other the other bin to compare with</param>
      <return>a summary of the deviations.</return>
    </javadoc>
    <method type="String" name="compareWith" startLine="106" endLine="121">
      <declaration type="StringBuffer" name="buf" />
      <scope startLine="108" endLine="119">
        <declaration type="MightyStaticBin1D" name="m" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns the geometric mean, which is <tt>Product( x[i] )<sup>1.0/size()</sup></tt>.
 * This method tries to avoid overflows at the expense of an equivalent but somewhat inefficient definition:
 * <tt>geoMean = exp( Sum( Log(x[i]) ) / size())</tt>.
 * Note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.</text>
      <return>the geometric mean; <tt>Double.NaN</tt> if <tt>!hasSumOfLogarithms()</tt>.</return>
    </javadoc>
    <method type="double" name="geometricMean" startLine="130" endLine="132" />
    <javadoc>
      <text>* Returns the maximum order <tt>k</tt> for which sums of powers are retrievable, as specified upon instance construction.</text>
      <see>#hasSumOfPowers(int)</see>
      <see>#sumOfPowers(int)</see>
    </javadoc>
    <method type="int" name="getMaxOrderForSumOfPowers" startLine="138" endLine="147">
      <comment>order 0..2 is always recorded.
order 0 is size()
order 1 is sum()
order 2 is sum_xx()</comment>
    </method>
    <javadoc>
      <text>* Returns the minimum order <tt>k</tt> for which sums of powers are retrievable, as specified upon instance construction.</text>
      <see>#hasSumOfPowers(int)</see>
      <see>#sumOfPowers(int)</see>
    </javadoc>
    <method type="int" name="getMinOrderForSumOfPowers" startLine="153" endLine="157">
      <declaration type="int" name="minOrder" />
    </method>
    <javadoc>
      <text>* Returns the harmonic mean, which is <tt>size() / Sum( 1/x[i] )</tt>.
 * Remember: If the receiver contains at least one element of <tt>0.0</tt>, the harmonic mean is <tt>0.0</tt>.</text>
      <return>the harmonic mean; <tt>Double.NaN</tt> if <tt>!hasSumOfInversions()</tt>.</return>
      <see>#hasSumOfInversions()</see>
    </javadoc>
    <method type="double" name="harmonicMean" startLine="164" endLine="166" />
    <javadoc>
      <text>* Returns whether <tt>sumOfInversions()</tt> can return meaningful results.</text>
      <return><tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.
 * See the constructors for proper parametrization.</return>
    </javadoc>
    <method type="boolean" name="hasSumOfInversions" startLine="172" endLine="174" />
    <javadoc>
      <text>* Tells whether <tt>sumOfLogarithms()</tt> can return meaningful results.</text>
      <return><tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.
 * See the constructors for proper parametrization.</return>
    </javadoc>
    <method type="boolean" name="hasSumOfLogarithms" startLine="180" endLine="182" />
    <javadoc>
      <text>* Tells whether <tt>sumOfPowers(k)</tt> can return meaningful results.
 * Defined as <tt>hasSumOfPowers(k) <==> getMinOrderForSumOfPowers() <= k && k <= getMaxOrderForSumOfPowers()</tt>.
 * A return value of <tt>true</tt> implies that <tt>hasSumOfPowers(k-1) .. hasSumOfPowers(0)</tt> will also return <tt>true</tt>.
 * See the constructors for proper parametrization.
 * <p>
 * <b>Details</b>: 
 * <tt>hasSumOfPowers(0..2)</tt> will always yield <tt>true</tt>.
 * <tt>hasSumOfPowers(-1) <==> hasSumOfInversions()</tt>.</text>
      <return><tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.</return>
      <see>#getMinOrderForSumOfPowers()</see>
      <see>#getMaxOrderForSumOfPowers()</see>
    </javadoc>
    <method type="boolean" name="hasSumOfPowers" startLine="197" endLine="199" />
    <javadoc>
      <text>* Returns the kurtosis (aka excess), which is <tt>-3 + moment(4,mean()) / standardDeviation()<sup>4</sup></tt>.</text>
      <return>the kurtosis; <tt>Double.NaN</tt> if <tt>!hasSumOfPowers(4)</tt>.</return>
      <see>#hasSumOfPowers(int)</see>
    </javadoc>
    <method type="double" name="kurtosis" startLine="205" endLine="207" />
    <javadoc>
      <text>* Returns the moment of <tt>k</tt>-th order with value <tt>c</tt>,
 * which is <tt>Sum( (x[i]-c)<sup>k</sup> ) / size()</tt>.</text>
      <param>k the order; must be greater than or equal to zero.</param>
      <param>c any number.</param>
      <throws>IllegalArgumentException if <tt>k < 0</tt>.</throws>
      <return><tt>Double.NaN</tt> if <tt>!hasSumOfPower(k)</tt>.</return>
    </javadoc>
    <method type="double" name="moment" startLine="217" endLine="230">
      <declaration type="int" name="maxOrder" />
      <declaration type="DoubleArrayList" name="sumOfPows" />
      <comment>checkOrder(k);</comment>
    </method>
    <javadoc>
      <text>* Returns the product, which is <tt>Prod( x[i] )</tt>.
 * In other words: <tt>x[0]*x[1]*...*x[size()-1]</tt>.</text>
      <return>the product; <tt>Double.NaN</tt> if <tt>!hasSumOfLogarithms()</tt>.</return>
      <see>#hasSumOfLogarithms()</see>
    </javadoc>
    <method type="double" name="product" startLine="237" endLine="239" />
    <javadoc>
      <text>* Sets the range of orders in which sums of powers are to be computed.
 * In other words, <tt>sumOfPower(k)</tt> will return <tt>Sum( x[i]^k )</tt> if <tt>min_k <= k <= max_k || 0 <= k <= 2</tt>
 * and throw an exception otherwise.</text>
      <see>#isLegalOrder(int)</see>
      <see>#sumOfPowers(int)</see>
      <see>#getRangeForSumOfPowers()</see>
    </javadoc>
    <method type="void" name="setMaxOrderForSumOfPowers" startLine="248" endLine="257">
      <scope startLine="251" endLine="253" />
      <scope startLine="254" endLine="256" />
      <comment>if (max_k < ) throw new IllegalArgumentException();</comment>
    </method>
    <javadoc>
      <text>* Returns the skew, which is <tt>moment(3,mean()) / standardDeviation()<sup>3</sup></tt>.</text>
      <return>the skew; <tt>Double.NaN</tt> if <tt>!hasSumOfPowers(3)</tt>.</return>
      <see>#hasSumOfPowers(int)</see>
    </javadoc>
    <method type="double" name="skew" startLine="263" endLine="265" />
    <javadoc>
      <text>* Returns the sum of inversions, which is <tt>Sum( 1 / x[i] )</tt>.</text>
      <return>the sum of inversions; <tt>Double.NaN</tt> if <tt>!hasSumOfInversions()</tt>.</return>
      <see>#hasSumOfInversions()</see>
    </javadoc>
    <method type="double" name="sumOfInversions" startLine="271" endLine="275">
      <comment>if (! this.hasSumOfInversions) throw new IllegalOperationException("You must specify upon instance construction that the sum of inversions shall be computed.");</comment>
    </method>
    <javadoc>
      <text>* Returns the sum of logarithms, which is <tt>Sum( Log(x[i]) )</tt>.</text>
      <return>the sum of logarithms; <tt>Double.NaN</tt> if <tt>!hasSumOfLogarithms()</tt>.</return>
      <see>#hasSumOfLogarithms()</see>
    </javadoc>
    <method type="double" name="sumOfLogarithms" startLine="281" endLine="285">
      <comment>if (! this.hasSumOfLogarithms) throw new IllegalOperationException("You must specify upon instance construction that the sum of logarithms shall be computed.");</comment>
    </method>
    <javadoc>
      <text>* Returns the <tt>k-th</tt> order sum of powers, which is <tt>Sum( x[i]<sup>k</sup> )</tt>.</text>
      <param>k the order of the powers.</param>
      <return>the sum of powers; <tt>Double.NaN</tt> if <tt>!hasSumOfPowers(k)</tt>.</return>
      <see>#hasSumOfPowers(int)</see>
    </javadoc>
    <method type="double" name="sumOfPowers" startLine="292" endLine="301">
      <comment>checkOrder(k);</comment>
    </method>
    <javadoc>
      <text>* Returns a String representation of the receiver.</text>
    </javadoc>
    <method type="String" name="toString" startLine="305" endLine="338">
      <declaration type="StringBuffer" name="buf" />
      <scope startLine="308" endLine="311" />
      <scope startLine="313" endLine="316" />
      <declaration type="int" name="maxOrder" />
      <declaration type="int" name="maxPrintOrder" />
      <scope startLine="320" endLine="336">
        <scope startLine="321" endLine="323" />
        <scope startLine="324" endLine="326" />
        <scope startLine="327" endLine="329" />
        <scope startLine="330" endLine="332" />
        <scope startLine="333" endLine="335" />
      </scope>
      <comment>don't print tons of measures</comment>
    </method>
    <javadoc>
      <throws>IllegalOperationException if <tt>! isLegalOrder(k)</tt>.</throws>
    </javadoc>
    <method type="void" name="xcheckOrder" startLine="342" endLine="345">
      <comment>if (! isLegalOrder(k)) return Double.NaN;</comment>
      <comment>if (! xisLegalOrder(k)) throw new IllegalOperationException("Illegal order of sum of powers: k="+k+". Upon instance construction legal range was fixed to be "+getMinOrderForSumOfPowers()+" <= k <= "+getMaxOrderForSumOfPowers());</comment>
    </method>
    <javadoc>
      <text>* Returns whether two bins are equal; 
 * They are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum, sumOfSquares, sumOfInversions and sumOfLogarithms.</text>
    </javadoc>
    <method type="boolean" name="xequals" startLine="350" endLine="354">
      <declaration type="MightyStaticBin1D" name="other" />
    </method>
    <javadoc>
      <text>* Tells whether <tt>sumOfPowers(fromK) .. sumOfPowers(toK)</tt> can return meaningful results.</text>
      <return><tt>false</tt> if the bin was constructed with insufficient parametrization, <tt>true</tt> otherwise.
 * See the constructors for proper parametrization.</return>
      <throws>IllegalArgumentException if <tt>fromK > toK</tt>.</throws>
    </javadoc>
    <method type="boolean" name="xhasSumOfPowers" startLine="361" endLine="364" />
    <javadoc>
      <text>* Returns <tt>getMinOrderForSumOfPowers() <= k && k <= getMaxOrderForSumOfPowers()</tt>.</text>
    </javadoc>
    <method type="boolean" name="xisLegalOrder" startLine="368" endLine="370" />
    <comment>Sum( Log(x[i]) )</comment>
    <comment>Sum( 1/x[i] )</comment>
    <comment>Sum( x[i]^3 ) .. Sum( x[i]^max_k )</comment>
  </class>
</source>
