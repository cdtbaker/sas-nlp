<?xml version="1.0" encoding="UTF-8"?>
<source package="Jama">
  <class name="LUDecomposition" startLine="3">
    <implements name="java.io.Serializable" />
    <javadoc>
      <text>* LU Decomposition.
 * <P>
 * For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
 * unit lower triangular matrix L, an n-by-n upper triangular matrix U,
 * and a permutation vector piv of length m so that A(piv,:) = L*U.
 * If m < n, then L is m-by-m and U is m-by-n.
 * <P>
 * The LU decompostion with pivoting always exists, even if the matrix is
 * singular, so the constructor will never fail.  The primary use of the
 * LU decomposition is in the solution of square systems of simultaneous
 * linear equations.  This will fail if isNonsingular() returns false.</text>
    </javadoc>
    <javadoc>
      <text>* Array for internal storage of decomposition.</text>
      <serial>internal array storage.</serial>
    </javadoc>
    <declaration type="double[][]" name="LU" />
    <javadoc>
      <text>* Row and column dimensions, and pivot sign.</text>
      <serial>column dimension.</serial>
      <serial>row dimension.</serial>
      <serial>pivot sign.</serial>
    </javadoc>
    <declaration type="int" name="m" />
    <javadoc>
      <text>* Internal storage of pivot vector.</text>
      <serial>pivot vector.</serial>
    </javadoc>
    <declaration type="int[]" name="piv" />
    <javadoc>
      <text>* LU Decomposition
 * Structure to access L, U and piv.</text>
      <param>A Rectangular matrix</param>
    </javadoc>
    <method type="constructor" name="LUDecomposition" startLine="48" endLine="113">
      <scope startLine="56" endLine="58" />
      <declaration type="double[]" name="LUrowi" />
      <declaration type="double[]" name="LUcolj" />
      <scope startLine="65" endLine="112">
        <scope startLine="69" endLine="71" />
        <scope startLine="75" endLine="87">
          <declaration type="int" name="kmax" />
          <declaration type="double" name="s" />
          <scope startLine="82" endLine="84" />
        </scope>
        <declaration type="int" name="p" />
        <scope startLine="92" endLine="96">
          <scope startLine="93" endLine="95" />
        </scope>
        <scope startLine="97" endLine="103">
          <scope startLine="98" endLine="100">
            <declaration type="double" name="t" />
          </scope>
          <declaration type="int" name="k" />
        </scope>
        <scope startLine="107" endLine="111">
          <scope startLine="108" endLine="110" />
        </scope>
        <comment>Make a copy of the j-th column to localize references.</comment>
        <comment>Apply previous transformations.</comment>
        <comment>Most of the time is spent in the following dot product.</comment>
        <comment>Find pivot and exchange if necessary.</comment>
        <comment>Compute multipliers.</comment>
      </scope>
      <comment>Use a "left-looking", dot-product, Crout/Doolittle algorithm.</comment>
      <comment>Outer loop.</comment>
    </method>
    <javadoc>
      <text>* Is the matrix nonsingular?</text>
      <return>true if U, and hence A, is nonsingular.</return>
    </javadoc>
    <method type="boolean" name="isNonsingular" startLine="182" endLine="188">
      <scope startLine="183" endLine="186" />
    </method>
    <javadoc>
      <text>* Return lower triangular factor</text>
      <return>L</return>
    </javadoc>
    <method type="Matrix" name="getL" startLine="194" endLine="209">
      <declaration type="Matrix" name="X" />
      <declaration type="double[][]" name="L" />
      <scope startLine="197" endLine="207">
        <scope startLine="198" endLine="206">
          <scope startLine="199" endLine="201" />
          <scope startLine="201" endLine="203" />
          <scope startLine="203" endLine="205" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Return upper triangular factor</text>
      <return>U</return>
    </javadoc>
    <method type="Matrix" name="getU" startLine="215" endLine="228">
      <declaration type="Matrix" name="X" />
      <declaration type="double[][]" name="U" />
      <scope startLine="218" endLine="226">
        <scope startLine="219" endLine="225">
          <scope startLine="220" endLine="222" />
          <scope startLine="222" endLine="224" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Return pivot permutation vector</text>
      <return>piv</return>
    </javadoc>
    <method type="int[]" name="getPivot" startLine="234" endLine="240">
      <declaration type="int[]" name="p" />
      <scope startLine="236" endLine="238" />
    </method>
    <javadoc>
      <text>* Return pivot permutation vector as a one-dimensional double array</text>
      <return>(double) piv</return>
    </javadoc>
    <method type="double[]" name="getDoublePivot" startLine="246" endLine="252">
      <declaration type="double[]" name="vals" />
      <scope startLine="248" endLine="250" />
    </method>
    <javadoc>
      <text>* Determinant</text>
      <return>det(A)</return>
      <exception>IllegalArgumentException  Matrix must be square</exception>
    </javadoc>
    <method type="double" name="det" startLine="259" endLine="268">
      <scope startLine="260" endLine="262" />
      <declaration type="double" name="d" />
      <scope startLine="264" endLine="266" />
    </method>
    <javadoc>
      <text>* Solve A*X = B</text>
      <param>B   A Matrix with as many rows as A and any number of columns.</param>
      <return>X so that L*U*X = B(piv,:)</return>
      <exception>IllegalArgumentException Matrix row dimensions must agree.</exception>
      <exception>RuntimeException  Matrix is singular.</exception>
    </javadoc>
    <method type="Matrix" name="solve" startLine="277" endLine="310">
      <scope startLine="278" endLine="280" />
      <scope startLine="281" endLine="283" />
      <declaration type="int" name="nx" />
      <declaration type="Matrix" name="Xmat" />
      <declaration type="double[][]" name="X" />
      <scope startLine="291" endLine="297">
        <scope startLine="292" endLine="296">
          <scope startLine="293" endLine="295" />
        </scope>
      </scope>
      <scope startLine="299" endLine="308">
        <scope startLine="300" endLine="302" />
        <scope startLine="303" endLine="307">
          <scope startLine="304" endLine="306" />
        </scope>
      </scope>
      <comment>Copy right hand side with pivoting</comment>
      <comment>Solve L*Y = B(piv,:)</comment>
      <comment>Solve U*X = Y;</comment>
    </method>
    <declaration type="long" name="serialVersionUID" />
    <comment>------------------------
Class variables
 ------------------------</comment>
    <comment>------------------------
Constructor
 ------------------------</comment>
    <comment>------------------------
Temporary, experimental code.
------------------------ \

\ LU Decomposition, computed by Gaussian elimination.
<P>
This constructor computes L and U with the "daxpy"-based elimination
algorithm used in LINPACK and MATLAB.  In Java, we suspect the dot-product,
Crout algorithm will be faster.  We have temporarily included this
constructor until timing experiments confirm this suspicion.
<P>
@param  A             Rectangular matrix
@param  linpackflag   Use Gaussian elimination.  Actual value ignored.
@return               Structure to access L, U and piv.
\

public LUDecomposition (Matrix A, int linpackflag) {
 Initialize.
LU = A.getArrayCopy();
m = A.getRowDimension();
n = A.getColumnDimension();
piv = new int[m];
for (int i = 0; i < m; i++) {
piv[i] = i;
}
pivsign = 1;
 Main loop.
for (int k = 0; k < n; k++) {
 Find pivot.
int p = k;
for (int i = k+1; i < m; i++) {
if (Math.abs(LU[i][k]) > Math.abs(LU[p][k])) {
p = i;
}
}
 Exchange if necessary.
if (p != k) {
for (int j = 0; j < n; j++) {
double t = LU[p][j]; LU[p][j] = LU[k][j]; LU[k][j] = t;
}
int t = piv[p]; piv[p] = piv[k]; piv[k] = t;
pivsign = -pivsign;
}
 Compute multipliers and eliminate k-th column.
if (LU[k][k] != 0.0) {
for (int i = k+1; i < m; i++) {
LU[i][k] = LU[k][k];
for (int j = k+1; j < n; j++) {
LU[i][j] -= LU[i][k]LU[k][j];
}
}
}
}
}

\ ------------------------
End of temporary code.
 ------------------------</comment>
    <comment>------------------------
Public Methods
 ------------------------</comment>
  </class>
</source>
