<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ojalgo.matrix.decomposition">
        <import package="org.ojalgo.access.Access2D"/>
        <import package="org.ojalgo.matrix.decomposition.task.DeterminantTask"/>
        <import package="org.ojalgo.matrix.store.ColumnsStore"/>
        <import package="org.ojalgo.matrix.store.IdentityStore"/>
        <import package="org.ojalgo.matrix.store.MatrixStore"/>
        <import package="org.ojalgo.matrix.store.RowsStore"/>
        <interface name="LU">
            <type_params>
                <type_param name="N"/>
            </type_params>
            <implements interface="MatrixDecomposition">
                <type_params>
                    <type_param name="N"/>
                </type_params>
            </implements>
            <implements interface="DeterminantTask">
                <type_params>
                    <type_param name="N"/>
                </type_params>
            </implements>
            <javadoc line="31">
                LU: [A] = [L][U]
                  &lt;p&gt;
                  Decomposes [this] into [L] and [U] (with pivot order information in an int[]) where:
                  &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;[L] is a unit lower (left) triangular matrix. It has the same number of rows as [this], and ones on the diagonal.
                  &lt;/li&gt;
                  &lt;li&gt;[U] is an upper (right) triangular matrix. It has the same number of columns as [this].&lt;/li&gt;
                  &lt;li&gt;[this] = [L][U] (with reordered rows according to the pivot order)&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;
                  Note: The number of columns in [L] and the number of rows in [U] is not specified by this interface.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The LU decomposition always exists - the compute method should always succeed - even for non-square and/or singular
                  matrices. The primary use of the LU decomposition is in the solution of systems of simultaneous linear equations.
                  That will, however, only work for square non-singular matrices.
                  &lt;/p&gt;                
                <@author>
                    r apete                    
                </@author>
            </javadoc>
            <method name="computeWithoutPivoting" type="boolean" line="55"/>
            <javadoc line="55">
                The normal {@link #compute(Access2D)} method must handle cases where pivoting is required. If you know that
                  pivoting is not needed you may call this method instead - it&apos;s faster.                
            </javadoc>
            <method name="getDeterminant" type="N" line="61"/>
            <method name="getL" type="MatrixStore<N>" line="63"/>
            <method name="getPivotOrder" type="int[]" line="65"/>
            <javadoc line="65">
                This can be used to create a [P] matrix using {@linkplain IdentityStore} in combination with{@linkplain RowsStore} or {@linkplain ColumnsStore}.                
            </javadoc>
            <method name="getRank" type="int" line="71"/>
            <method name="getReducedPivots" type="int[]" line="73"/>
            <method name="getU" type="MatrixStore<N>" line="75"/>
            <javadoc line="75">
                http://en.wikipedia.org/wiki/Row_echelon_form &lt;br&gt;
                  &lt;br&gt;
                  This is the same as [D][U]. Together with the pivotOrder and [L] this constitutes an alternative, more compact,
                  way to express the decomposition.                
                <@see>
                    e #getPivotOrder()                    
                </@see>
                <@see>
                    e #getL()                    
                </@see>
            </javadoc>
            <method name="isSquareAndNotSingular" type="boolean" line="86"/>
        </interface>
    </source>