<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.matrix.decomposition">
  <import name="java.math.BigDecimal" />
  <import name="org.ojalgo.access.Access2D" />
  <import name="org.ojalgo.array.Array1D" />
  <import name="org.ojalgo.array.SimpleArray" />
  <import name="org.ojalgo.constant.PrimitiveMath" />
  <import name="org.ojalgo.function.BinaryFunction" />
  <import name="org.ojalgo.function.aggregator.AggregatorFunction" />
  <import name="org.ojalgo.function.aggregator.ComplexAggregator" />
  <import name="org.ojalgo.matrix.MatrixUtils" />
  <import name="org.ojalgo.matrix.store.BigDenseStore" />
  <import name="org.ojalgo.matrix.store.ComplexDenseStore" />
  <import name="org.ojalgo.matrix.store.MatrixStore" />
  <import name="org.ojalgo.matrix.store.PhysicalStore" />
  <import name="org.ojalgo.matrix.store.PrimitiveDenseStore" />
  <import name="org.ojalgo.matrix.store.TransposedStore" />
  <import name="org.ojalgo.scalar.ComplexNumber" />
  <import name="org.ojalgo.type.TypeUtils" />
  <import name="org.ojalgo.type.context.NumberContext" />
  <class name="HermitianEvD32" extends="EigenvalueDecomposition<N>" startLine="44">
    <class name="Big" extends="HermitianEvD32<BigDecimal>" startLine="46">
      <method type="constructor" name="Big" startLine="48" endLine="50" />
      <class name="Complex" extends="HermitianEvD32<ComplexNumber>" startLine="54">
        <method type="constructor" name="Complex" startLine="56" endLine="58" />
        <class name="Primitive" extends="HermitianEvD32<Double>" startLine="62">
          <javadoc>
            <text>* Eigenvalues and eigenvectors of a real matrix.
 * <P>
 * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector matrix V is
 * orthogonal. I.e. A = V.times(D.times(V.transpose())) and V.times(V.transpose()) equals the identity matrix.
 * <P>
 * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues in 1-by-1 blocks
 * and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda]. The columns of V
 * represent the eigenvectors in the sense that A*V = V*D, i.e. A.times(V) equals V.times(D). The matrix V may be
 * badly conditioned, or even singular, so the validity of the equation A = V*D*inverse(V) depends upon V.cond().</text>
          </javadoc>
          <method type="constructor" name="Primitive" startLine="75" endLine="77" />
          <method type="Array1D<Double>" name="toDiagonal" startLine="81" endLine="229">
            <declaration type="Array1D<?>" name="tmpMainDiagonal" />
            <declaration type="Array1D<?>" name="tmpSubdiagonal" />
            <declaration type="int" name="tmpDim" />
            <declaration type="double[]" name="tmpMainDiagData" />
            <declaration type="double[]" name="tmpOffDiagData" />
            <declaration type="int" name="tmpLength" />
            <scope startLine="93" endLine="95" />
            <declaration type="double" name="tmpShift" />
            <declaration type="double" name="tmpShiftIncr" />
            <declaration type="double" name="tmpMagnitude" />
            <declaration type="double" name="tmpLocalEpsilon" />
            <declaration type="int" name="m" />
            <scope startLine="111" endLine="215">
              <scope startLine="120" endLine="125">
                <scope startLine="121" endLine="123" />
              </scope>
              <scope startLine="128" endLine="206">
                <scope startLine="130" endLine="205">
                  <declaration type="double" name="tmp1Ml0" />
                  <declaration type="double" name="tmp1Ml1" />
                  <declaration type="double" name="tmp1Sl0" />
                  <declaration type="double" name="p" />
                  <declaration type="double" name="r" />
                  <scope startLine="140" endLine="142" />
                  <declaration type="double" name="tmp2Ml0" />
                  <declaration type="double" name="tmp2Ml1" />
                  <declaration type="double" name="tmp2Sl1" />
                  <scope startLine="149" endLine="151" />
                  <declaration type="double" name="tmpRotCos" />
                  <declaration type="double" name="tmpRotSin" />
                  <declaration type="double" name="tmpRotCos2" />
                  <declaration type="double" name="tmpRotSin2" />
                  <declaration type="double" name="tmpRotCos3" />
                  <scope startLine="168" endLine="198">
                    <declaration type="double" name="tmp1Mi0" />
                    <declaration type="double" name="tmp1Si0" />
                    <scope startLine="192" endLine="194" />
                  </scope>
                </scope>
              </scope>
              <declaration type="double" name="tmpEigenvalue" />
              <scope startLine="209" endLine="211" />
              <scope startLine="211" endLine="213" />
              <comment>BasicLogger.logDebug("Loop l=" + l, tmpMainDiagonal, tmpOffDiagonal);</comment>
              <comment>Find small subdiagonal element</comment>
              <comment>If m == l, aMainDiagonal[l] is an eigenvalue, otherwise, iterate.</comment>
              <comment>(l,l)</comment>
              <comment>(l+1,l+1)</comment>
              <comment>(l+1,l) and (l,l+1)</comment>
              <comment>Compute implicit shift</comment>
              <comment>(l,l)</comment>
              <comment>(l+1,l+1)</comment>
              <comment>(l+1,l) and (l,l+1)</comment>
              <comment>BasicLogger.logDebug("New shift =" + tmpShift, tmpMainDiagonal, tmpOffDiagonal);</comment>
              <comment>Implicit QL transformation</comment>
              <comment>Initiate p</comment>
              <comment>BasicLogger.logDebug("m={} l={}", m, l);</comment>
              <comment>Next p</comment>
              <comment>Accumulate transformation - rotate the eigenvector matrix</comment>
              <comment>aV.transformRight(new Rotation.Primitive(i, i + 1, tmpRotCos, tmpRotSin));</comment>
              <comment>BasicLogger.logDebug("low={} high={} cos={} sin={}", i, i + 1, tmpRotCos, tmpRotSin);</comment>
              <comment>EigenvalueDecomposition.log("QL step done i=" + i, tmpMainDiagonal, tmpOffDiagonal);</comment>
              <comment>Final p</comment>
              <comment>Check for convergence</comment>
              <comment>End if (m > l)</comment>
              <comment>End main loop - l</comment>
            </scope>
            <comment>BasicLogger.logDebug("Tridiagonal={}", aTridiagonal.toString());</comment>
            <comment>Actually unnecessary to copy</comment>
            <comment>The algorith needs the array to be the same length as the main diagonal</comment>
            <comment>BasicLogger.logDebug("BEGIN diagonalize");</comment>
            <comment>BasicLogger.logDebug("Main D: {}", Arrays.toString(tmpMainDiagonal));</comment>
            <comment>BasicLogger.logDebug("Seco D: {}", Arrays.toString(tmpOffDiagonal));</comment>
            <comment>BasicLogger.logDebug("V", aV);</comment>
            <comment>BasicLogger.logDebug();</comment>
            <comment>Main loop</comment>
            <comment>BasicLogger.logDebug("END diagonalize");</comment>
            <comment>BasicLogger.logDebug("Main D: {}", Arrays.toString(tmpMainDiagonal));</comment>
            <comment>BasicLogger.logDebug("Seco D: {}", Arrays.toString(tmpOffDiagonal));</comment>
            <comment>BasicLogger.logDebug("V", aV);</comment>
            <comment>BasicLogger.logDebug();</comment>
            <comment>for (int i = 0; i < tmpMainDiagData.length; i++) {</comment>
            <comment>tmpMainDiagonal.set(i, tmpMainDiagData[i]);</comment>
            <comment>}</comment>
            <comment>return new PrimitiveArray(tmpMainDiagonal).asArray1D();</comment>
          </method>
          <declaration type="Array1D<Double>" name="myDiagonalValues" />
          <declaration type="MatrixStore<N>" name="myInverse" />
          <declaration type="TridiagonalDecomposition<N>" name="myTridiagonal" />
          <method type="constructor" name="HermitianEvD32" startLine="237" endLine="239" />
          <method type="constructor" name="HermitianEvD32" startLine="241" endLine="246" />
          <method type="boolean" name="compute" startLine="248" endLine="250" />
          <method type="boolean" name="equals" startLine="252" endLine="254" />
          <method type="N" name="getDeterminant" startLine="256" endLine="263">
            <declaration type="AggregatorFunction<ComplexNumber>" name="tmpVisitor" />
          </method>
          <method type="MatrixStore<N>" name="getInverse" startLine="265" endLine="291">
            <scope startLine="267" endLine="288">
              <declaration type="MatrixStore<N>" name="tmpV" />
              <declaration type="MatrixStore<N>" name="tmpD" />
              <declaration type="int" name="tmpDim" />
              <declaration type="PhysicalStore<N>" name="tmpMtrx" />
              <declaration type="N" name="tmpZero" />
              <declaration type="BinaryFunction<N>" name="tmpDivide" />
              <scope startLine="279" endLine="285">
                <scope startLine="280" endLine="282" />
                <scope startLine="282" endLine="284" />
              </scope>
            </scope>
          </method>
          <method type="MatrixStore<N>" name="getInverse" startLine="293" endLine="320">
            <scope startLine="295" endLine="317">
              <declaration type="MatrixStore<N>" name="tmpV" />
              <declaration type="MatrixStore<N>" name="tmpD" />
              <declaration type="int" name="tmpDim" />
              <declaration type="PhysicalStore<N>" name="tmpMtrx" />
              <declaration type="N" name="tmpZero" />
              <declaration type="BinaryFunction<N>" name="tmpDivide" />
              <scope startLine="308" endLine="314">
                <scope startLine="309" endLine="311" />
                <scope startLine="311" endLine="313" />
              </scope>
            </scope>
          </method>
          <method type="ComplexNumber" name="getTrace" startLine="322" endLine="329">
            <declaration type="AggregatorFunction<ComplexNumber>" name="tmpVisitor" />
          </method>
          <method type="boolean" name="isFullSize" startLine="331" endLine="333" />
          <method type="boolean" name="isHermitian" startLine="335" endLine="337" />
          <method type="boolean" name="isOrdered" startLine="339" endLine="341" />
          <method type="boolean" name="isSolvable" startLine="343" endLine="345" />
          <method type="void" name="reset" startLine="348" endLine="355" />
          <method type="boolean" name="doNonsymmetric" startLine="358" endLine="360" />
          <method type="boolean" name="doSymmetric" startLine="363" endLine="408">
            <declaration type="int" name="tmpDim" />
            <declaration type="DiagonalAccess<N>" name="tmpTridiagonal" />
            <declaration type="DecompositionStore<N>" name="tmpV" />
            <declaration type="Array1D<Double>" name="tmpDiagonal" />
            <scope startLine="379" endLine="401">
              <declaration type="double" name="tmpValue1" />
              <declaration type="int" name="ij2" />
              <declaration type="double" name="tmpValue2" />
              <scope startLine="385" endLine="392">
                <declaration type="double" name="tmpValue2exp" />
                <scope startLine="388" endLine="391" />
              </scope>
              <scope startLine="394" endLine="400">
                <scope startLine="397" endLine="399" />
              </scope>
            </scope>
            <scope startLine="403" endLine="405" />
            <comment>BasicLogger.logDebug("Tridiagonal1={}", tmpTridiagonal);</comment>
            <comment>BasicLogger.logDebug("Tridiagonal2={}", tmpTridiagonal);</comment>
          </method>
          <method type="MatrixStore<N>" name="makeD" startLine="411" endLine="413" />
          <method type="Array1D<ComplexNumber>" name="makeEigenvalues" startLine="416" endLine="427">
            <declaration type="int" name="tmpDim" />
            <declaration type="Array1D<ComplexNumber>" name="retVal" />
            <scope startLine="422" endLine="424" />
          </method>
          <method type="MatrixStore<N>" name="makeV" startLine="430" endLine="432" />
        </class>
      </class>
    </class>
  </class>
</source>
