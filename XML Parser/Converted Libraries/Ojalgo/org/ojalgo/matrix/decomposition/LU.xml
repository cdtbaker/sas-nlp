<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.matrix.decomposition">
  <import name="org.ojalgo.access.Access2D" />
  <import name="org.ojalgo.matrix.decomposition.task.DeterminantTask" />
  <import name="org.ojalgo.matrix.store.ColumnsStore" />
  <import name="org.ojalgo.matrix.store.IdentityStore" />
  <import name="org.ojalgo.matrix.store.MatrixStore" />
  <import name="org.ojalgo.matrix.store.RowsStore" />
  <interface name="LU" startLine="31">
    <implements name="MatrixDecomposition<N>" />
    <implements name="DeterminantTask<N>" />
    <javadoc>
      <text>* LU: [A] = [L][U]
 * <p>
 * Decomposes [this] into [L] and [U] (with pivot order information in an int[]) where:
 * </p>
 * <ul>
 * <li>[L] is a unit lower (left) triangular matrix. It has the same number of rows as [this], and ones on the diagonal.
 * </li>
 * <li>[U] is an upper (right) triangular matrix. It has the same number of columns as [this].</li>
 * <li>[this] = [L][U] (with reordered rows according to the pivot order)</li>
 * </ul>
 * <p>
 * Note: The number of columns in [L] and the number of rows in [U] is not specified by this interface.
 * </p>
 * <p>
 * The LU decomposition always exists - the compute method should always succeed - even for non-square and/or singular
 * matrices. The primary use of the LU decomposition is in the solution of systems of simultaneous linear equations.
 * That will, however, only work for square non-singular matrices.
 * </p></text>
      <author>apete</author>
    </javadoc>
    <method name="computeWithoutPivoting" type="boolean" startLine="55" endLine="59" />
    <javadoc>
      <text>* The normal {@link #compute(Access2D)} method must handle cases where pivoting is required. If you know that
 * pivoting is not needed you may call this method instead - it's faster.</text>
    </javadoc>
    <method name="getDeterminant" type="N" startLine="61" endLine="61" />
    <method name="getL" type="MatrixStore<N>" startLine="63" endLine="63" />
    <method name="getPivotOrder" type="int[]" startLine="65" endLine="69" />
    <javadoc>
      <text>* This can be used to create a [P] matrix using {@linkplain IdentityStore} in combination with{@linkplain RowsStore} or {@linkplain ColumnsStore}.</text>
    </javadoc>
    <method name="getRank" type="int" startLine="71" endLine="71" />
    <method name="getReducedPivots" type="int[]" startLine="73" endLine="73" />
    <method name="getU" type="MatrixStore<N>" startLine="75" endLine="84" />
    <javadoc>
      <text>* http://en.wikipedia.org/wiki/Row_echelon_form <br>
 * <br>
 * This is the same as [D][U]. Together with the pivotOrder and [L] this constitutes an alternative, more compact,
 * way to express the decomposition.</text>
      <see>#getPivotOrder()</see>
      <see>#getL()</see>
    </javadoc>
    <method name="isSquareAndNotSingular" type="boolean" startLine="86" endLine="86" />
  </interface>
</source>
