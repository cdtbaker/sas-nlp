<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.matrix.decomposition">
  <import name="org.ojalgo.access.Access2D" />
  <import name="org.ojalgo.matrix.BasicMatrix" />
  <import name="org.ojalgo.matrix.decomposition.task.SolverTask" />
  <import name="org.ojalgo.matrix.decomposition.task.InverterTask" />
  <import name="org.ojalgo.matrix.store.MatrixStore" />
  <import name="org.ojalgo.type.context.NumberContext" />
  <interface name="MatrixDecomposition" startLine="31">
    <implements name="InverterTask<N>" />
    <implements name="SolverTask<N>" />
    <javadoc>
      <text>* Notation used to describe the various matrix decompositions:
 * <ul>
 * <li>[A] could be any matrix. (The matrix to decompose.)</li>
 * <li>[A]<sup>-1</sup> is the inverse of [A].</li>
 * <li>[A]<sup>T</sup> is the transpose of [A].</li>
 * <li>[A]<sup>H</sup> is the conjugate transpose of [A]. [A]<sup>H</sup> is equilvalent to [A]<sup>T</sup> if the
 * elements are all real.</li>
 * <li>[D] is a diagonal matrix. Possibly bi-, tri- or block-diagonal.</li>
 * <li>[H] is an, upper or lower, Hessenberg matrix.</il>
 * <li>[I] is an identity matrix - obvioulsly orthogonal/unitary.</li>
 * <li>[L] is a lower (left) triangular matrix.</li>
 * <li>[P] is a permutation matrix - an identity matrix with interchanged rows or columns - and orthogonal/unitary.</li>
 * <li>[Q] is an orthogonal/unitary matrix. [Q]<sup>-1</sup> = [Q]<sup>H</sup>, and with real matrices =
 * [Q]<sup>T</sup>.</li>
 * <li>[R] is a right (upper) tringular matrix. It is equivalent to [U].</li>
 * <li>[U] is an upper (right) triangular matrix. It is equivalent to [R].</li>
 * <li>[V] is an eigenvector matrix. The columns are the eigenvectors</il>
 * </ul></text>
      <author>apete</author>
    </javadoc>
    <method name="compute" type="boolean" startLine="55" endLine="59" />
    <javadoc>
      <param>matrix A matrix to decompose</param>
      <return>true if the computation suceeded; false if not</return>
    </javadoc>
    <method name="equals" type="boolean" startLine="61" endLine="61" />
    <method name="equals" type="boolean" startLine="63" endLine="63" />
    <method name="getInverse" type="MatrixStore<N>" startLine="65" endLine="70" />
    <javadoc>
      <text>* The output must be a "right inverse" and a "generalised inverse".</text>
      <see>BasicMatrix#invert()</see>
    </javadoc>
    <method name="getInverse" type="MatrixStore<N>" startLine="72" endLine="89" />
    <javadoc>
      <text>* <p>
 * Implementiong this method is optional.
 * </p>
 * <p>
 * Exactly how a specific implementation makes use of <code>preallocated</code> is not specified by this interface.
 * It must be documented for each implementation.
 * </p>
 * <p>
 * Should produce the same results as calling {@link #getInverse()}.
 * </p></text>
      <param>preallocated Preallocated memory for the results, possibly some intermediate results. You must assume this
 * is modified, but you cannot assume it will contain the full/final/correct solution.</param>
      <return>The inverse</return>
      <throws>UnsupportedOperationException When/if this feature is not implemented</throws>
    </javadoc>
    <method name="isComputed" type="boolean" startLine="91" endLine="96" />
    <javadoc>
      <return>true if computation has been attemped; false if not.</return>
      <see>#compute(Access2D)</see>
      <see>#isSolvable()</see>
    </javadoc>
    <method name="isFullSize" type="boolean" startLine="98" endLine="101" />
    <javadoc>
      <return>True if the implementation generates a full sized decomposition.</return>
    </javadoc>
    <method name="isSolvable" type="boolean" startLine="103" endLine="108" />
    <javadoc>
      <return>true if it is ok to call {@linkplain #solve(Access2D)} (computation was successful); false if not</return>
      <see>#solve(Access2D)</see>
      <see>#isComputed()</see>
    </javadoc>
    <method name="preallocate" type="DecompositionStore<N>" startLine="110" endLine="123" />
    <javadoc>
      <text>* <p>
 * Implementiong this method is optional.
 * </p>
 * Will create a {@linkplain DecompositionStore} instance suitable for use with{@link #solve(Access2D,DecompositionStore)}. When solving an equation system [A][X]=[B] ([mxn][nxb]=[mxb]) the
 * preallocated memory/matrix will typically be either mxb or nxb (if A is square then there is no doubt).</text>
      <param>templateBody</param>
      <param>templateRHS</param>
      <return />
      <throws>UnsupportedOperationException When/if this feature is not implemented</throws>
    </javadoc>
    <method name="reconstruct" type="MatrixStore<N>" startLine="125" endLine="125" />
    <method name="reset" type="void" startLine="127" endLine="130" />
    <javadoc>
      <text>* Delete computed results, and resets attributes to default values</text>
    </javadoc>
    <method name="solve" type="MatrixStore<N>" startLine="132" endLine="135" />
    <javadoc>
      <text>* [A][X]=[B] or [this][return]=[aRHS]</text>
    </javadoc>
    <method name="solve" type="MatrixStore<N>" startLine="137" endLine="155" />
    <javadoc>
      <text>* <p>
 * Implementiong this method is optional.
 * </p>
 * <p>
 * Exactly how a specific implementation makes use of <code>preallocated</code> is not specified by this interface.
 * It must be documented for each implementation.
 * </p>
 * <p>
 * Should produce the same results as calling {@link #solve(Access2D)}.
 * </p></text>
      <param>rhs The Right Hand Side, wont be modfied</param>
      <param>preallocated Preallocated memory for the results, possibly some intermediate results. You must assume this
 * is modified, but you cannot assume it will contain the full/final/correct solution.</param>
      <return>The solution</return>
      <throws>UnsupportedOperationException When/if this feature is not implemented</throws>
    </javadoc>
  </interface>
</source>
