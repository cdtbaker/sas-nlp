<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.matrix.jama">
  <class name="LUDecomposition" startLine="3">
    <implements name="java.io.Serializable" />
    <javadoc>
      <text>* LU Decomposition.
 * <P>
 * For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
 * unit lower triangular matrix L, an n-by-n upper triangular matrix U,
 * and a permutation vector piv of length m so that A(piv,:) = L*U.
 * If m < n, then L is m-by-m and U is m-by-n.
 * <P>
 * The LU decompostion with pivoting always exists, even if the matrix is
 * singular, so the constructor will never fail.  The primary use of the
 * LU decomposition is in the solution of square systems of simultaneous
 * linear equations.  This will fail if isNonsingular() returns false.</text>
    </javadoc>
    <javadoc>
      <text>* Array for internal storage of decomposition.</text>
      <serial>internal array storage.</serial>
    </javadoc>
    <declaration type="double[][]" name="LU" />
    <javadoc>
      <text>* Row and column dimensions, and pivot sign.</text>
      <serial>column dimension.</serial>
      <serial>row dimension.</serial>
      <serial>pivot sign.</serial>
    </javadoc>
    <declaration type="int" name="m" />
    <declaration type="int" name="pivsign" />
    <javadoc>
      <text>* Internal storage of pivot vector.</text>
      <serial>pivot vector.</serial>
    </javadoc>
    <declaration type="int[]" name="piv" />
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* LU Decomposition
 * Structure to access L, U and piv.</text>
      <param>A Rectangular matrix</param>
    </javadoc>
    <method type="constructor" name="LUDecomposition" startLine="115" endLine="185">
      <scope startLine="124" endLine="126" />
      <declaration type="double[]" name="LUrowi" />
      <declaration type="double[]" name="LUcolj" />
      <scope startLine="133" endLine="184">
        <scope startLine="137" endLine="139" />
        <scope startLine="143" endLine="155">
          <declaration type="int" name="kmax" />
          <declaration type="double" name="s" />
          <scope startLine="150" endLine="152" />
        </scope>
        <declaration type="int" name="p" />
        <scope startLine="160" endLine="164">
          <scope startLine="161" endLine="163" />
        </scope>
        <scope startLine="165" endLine="175">
          <scope startLine="166" endLine="170">
            <declaration type="double" name="t" />
          </scope>
          <declaration type="int" name="k" />
        </scope>
        <scope startLine="179" endLine="183">
          <scope startLine="180" endLine="182" />
        </scope>
        <comment>Make a copy of the j-th column to localize references.</comment>
        <comment>Apply previous transformations.</comment>
        <comment>Most of the time is spent in the following dot product.</comment>
        <comment>Find pivot and exchange if necessary.</comment>
        <comment>Compute multipliers.</comment>
      </scope>
      <comment>Use a "left-looking", dot-product, Crout/Doolittle algorithm.</comment>
      <comment>Outer loop.</comment>
    </method>
    <javadoc>
      <text>* Determinant</text>
      <return>det(A)</return>
      <exception>IllegalArgumentException  Matrix must be square</exception>
    </javadoc>
    <method type="double" name="det" startLine="192" endLine="201">
      <scope startLine="193" endLine="195" />
      <declaration type="double" name="d" />
      <scope startLine="197" endLine="199" />
    </method>
    <javadoc>
      <text>* Return pivot permutation vector as a one-dimensional double array</text>
      <return>(double) piv</return>
    </javadoc>
    <method type="double[]" name="getDoublePivot" startLine="207" endLine="213">
      <declaration type="double[]" name="vals" />
      <scope startLine="209" endLine="211" />
    </method>
    <javadoc>
      <text>* Return lower triangular factor</text>
      <return>L</return>
    </javadoc>
    <method type="Matrix" name="getL" startLine="219" endLine="234">
      <declaration type="Matrix" name="X" />
      <declaration type="double[][]" name="L" />
      <scope startLine="222" endLine="232">
        <scope startLine="223" endLine="231">
          <scope startLine="224" endLine="226" />
          <scope startLine="226" endLine="228" />
          <scope startLine="228" endLine="230" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Return pivot permutation vector</text>
      <return>piv</return>
    </javadoc>
    <method type="int[]" name="getPivot" startLine="240" endLine="246">
      <declaration type="int[]" name="p" />
      <scope startLine="242" endLine="244" />
    </method>
    <javadoc>
      <text>* Return upper triangular factor</text>
      <return>U</return>
    </javadoc>
    <method type="Matrix" name="getU" startLine="252" endLine="265">
      <declaration type="Matrix" name="X" />
      <declaration type="double[][]" name="U" />
      <scope startLine="255" endLine="263">
        <scope startLine="256" endLine="262">
          <scope startLine="257" endLine="259" />
          <scope startLine="259" endLine="261" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Is the matrix nonsingular?</text>
      <return>true if U, and hence A, is nonsingular.</return>
    </javadoc>
    <method type="boolean" name="isNonsingular" startLine="271" endLine="278">
      <scope startLine="272" endLine="276">
        <scope startLine="273" endLine="275" />
      </scope>
    </method>
    <javadoc>
      <text>* Solve A*X = B</text>
      <param>B   A Matrix with as many rows as A and any number of columns.</param>
      <return>X so that L*U*X = B(piv,:)</return>
      <exception>IllegalArgumentException Matrix row dimensions must agree.</exception>
      <exception>RuntimeException  Matrix is singular.</exception>
    </javadoc>
    <method type="Matrix" name="solve" startLine="287" endLine="320">
      <scope startLine="288" endLine="290" />
      <scope startLine="291" endLine="293" />
      <declaration type="int" name="nx" />
      <declaration type="Matrix" name="Xmat" />
      <declaration type="double[][]" name="X" />
      <scope startLine="301" endLine="307">
        <scope startLine="302" endLine="306">
          <scope startLine="303" endLine="305" />
        </scope>
      </scope>
      <scope startLine="309" endLine="318">
        <scope startLine="310" endLine="312" />
        <scope startLine="313" endLine="317">
          <scope startLine="314" endLine="316" />
        </scope>
      </scope>
      <comment>Copy right hand side with pivoting</comment>
      <comment>Solve L*Y = B(piv,:)</comment>
      <comment>Solve U*X = Y;</comment>
    </method>
    <comment>------------------------
Class variables
 ------------------------</comment>
    <comment>------------------------
Constructor
 ------------------------</comment>
    <comment>------------------------
Temporary, experimental code.
------------------------ \

\ LU Decomposition, computed by Gaussian elimination.
<P>
This constructor computes L and U with the "daxpy"-based elimination
algorithm used in LINPACK and MATLAB.  In Java, we suspect the dot-product,
Crout algorithm will be faster.  We have temporarily included this
constructor until timing experiments confirm this suspicion.
<P>
@param  A             Rectangular matrix
@param  linpackflag   Use Gaussian elimination.  Actual value ignored.
@return               Structure to access L, U and piv.
\

public LUDecomposition (Matrix A, int linpackflag) {
 Initialize.
LU = A.getArrayCopy();
m = A.getRowDimension();
n = A.getColumnDimension();
piv = new int[m];
for (int i = 0; i < m; i++) {
piv[i] = i;
}
pivsign = 1;
 Main loop.
for (int k = 0; k < n; k++) {
 Find pivot.
int p = k;
for (int i = k+1; i < m; i++) {
if (Math.abs(LU[i][k]) > Math.abs(LU[p][k])) {
p = i;
}
}
 Exchange if necessary.
if (p != k) {
for (int j = 0; j < n; j++) {
double t = LU[p][j]; LU[p][j] = LU[k][j]; LU[k][j] = t;
}
int t = piv[p]; piv[p] = piv[k]; piv[k] = t;
pivsign = -pivsign;
}
 Compute multipliers and eliminate k-th column.
if (LU[k][k] != 0.0) {
for (int i = k+1; i < m; i++) {
LU[i][k] = LU[k][k];
for (int j = k+1; j < n; j++) {
LU[i][j] -= LU[i][k]LU[k][j];
}
}
}
}
}

\ ------------------------
End of temporary code.
 ------------------------</comment>
    <comment>------------------------
Public Methods
 ------------------------</comment>
  </class>
</source>
