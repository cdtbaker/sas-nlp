<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.matrix">
  <import name="java.math.BigDecimal" />
  <import name="java.util.List" />
  <import name="org.ojalgo.access.Access2D" />
  <import name="org.ojalgo.function.UnaryFunction" />
  <import name="org.ojalgo.matrix.decomposition.Cholesky" />
  <import name="org.ojalgo.matrix.decomposition.Eigenvalue" />
  <import name="org.ojalgo.matrix.decomposition.LU" />
  <import name="org.ojalgo.matrix.decomposition.QR" />
  <import name="org.ojalgo.matrix.decomposition.SingularValue" />
  <import name="org.ojalgo.matrix.store.MatrixStore" />
  <import name="org.ojalgo.matrix.store.PhysicalStore" />
  <import name="org.ojalgo.scalar.ComplexNumber" />
  <import name="org.ojalgo.scalar.Scalar" />
  <import name="org.ojalgo.type.context.NumberContext" />
  <interface name="BasicMatrix" startLine="40">
    <implements name="Access2D<N>" />
    <javadoc>
      <text>* <p>
 * This interface declares a set of high level methods for linear algebra. Only
 * the most basic set of matrix functionality is defined here. Various matrix
 * decompositions may be used to do some of the more advanced tasks. 
 * </p><p>
 * A vector is a matrix with column (or perhaps row) dimension 1.
 * </p></text>
      <see>LU</see>
      <see>Cholesky</see>
      <see>QR</see>
      <see>Eigenvalue</see>
      <see>SingularValue</see>
      <see>MatrixStore</see>
      <author>apete</author>
    </javadoc>
    <interface name="Factory" startLine="60">
      <implements name="Access2D.Factory<I>" />
      <javadoc>
        <author>apete</author>
      </javadoc>
      <method name="getBuilder" type="Access2D.Builder<I>" startLine="65" endLine="65" />
      <method name="getBuilder" type="Access2D.Builder<I>" startLine="67" endLine="67" />
      <method name="add" type="BasicMatrix<N>" startLine="71" endLine="78" />
      <javadoc>
        <text>* Adds the elements of aMtrx to the elements of this matrix. The matrices
 * must have equal dimensions.</text>
        <param>aMtrx What to add.</param>
        <return>A new matrix whos elements are the sum of this' and aMtrx'.</return>
      </javadoc>
      <method name="add" type="BasicMatrix<N>" startLine="80" endLine="86" />
      <javadoc>
        <param>aRow The row index of where to superimpose the top left element of aMtrx</param>
        <param>aCol The column index of where to superimpose the top left element of aMtrx</param>
        <param>aMtrx A matrix to superimpose</param>
        <return>A new matrix</return>
      </javadoc>
      <method name="add" type="BasicMatrix<N>" startLine="88" endLine="92" />
      <javadoc>
        <text>* Do not use this method to populate large dense matrices!
 * Only use it to change a few (a small number) of elements.</text>
      </javadoc>
      <method name="add" type="BasicMatrix<N>" startLine="94" endLine="100" />
      <javadoc>
        <text>* Adds aNmbr to the elements of this.</text>
        <param>aNmbr What to add</param>
        <return>A new matrix whos elements are the sum of this' elements and aNmbr.</return>
      </javadoc>
      <method name="conjugate" type="BasicMatrix<N>" startLine="102" endLine="110" />
      <javadoc>
        <text>* For real matrices conjugate() and transpose() are identical. For complex
 * matrices they're not.</text>
        <return>The conjugate transpose of this.</return>
        <see>org.ojalgo.matrix.BasicMatrix#transpose()</see>
      </javadoc>
      <method name="copyToBuilder" type="Builder<? extends BasicMatrix<N>>" startLine="112" endLine="116" />
      <javadoc>
        <return>A fully mutable matrix builder with the elements initially set to
 * a copy of this matrix.</return>
      </javadoc>
      <method name="divide" type="BasicMatrix<N>" startLine="118" endLine="124" />
      <javadoc>
        <text>* Divides the elements of this with aNmbr.</text>
        <param>aNmbr The denominator.</param>
        <return>A new matrix whos elements are the elements of this divided with aNmbr.</return>
      </javadoc>
      <method name="divideElements" type="BasicMatrix<N>" startLine="126" endLine="133" />
      <javadoc>
        <text>* Divides the elements of this with the elements of aMtrx. The matrices
 * must have equal dimensions.</text>
        <param>aMtrx The denominator elements.</param>
        <return>A new matrix whos elements are the elements of this divided with the elements of aMtrx.</return>
      </javadoc>
      <method name="enforce" type="BasicMatrix<N>" startLine="135" endLine="139" />
      <javadoc>
        <deprecated>Since v27 Use {@link #round(NumberContext)} instead.</deprecated>
      </javadoc>
      <method name="equals" type="boolean" startLine="141" endLine="145" />
      <javadoc>
        <return>true if the frobenius norm of the difference between
 * [this] and [aStore] is zero within the limits of aCntxt.</return>
      </javadoc>
      <method name="flushCache" type="void" startLine="147" endLine="152" />
      <javadoc>
        <text>* BasicMatrix instances are intended to be immutable. If they are
 * it is possible to cache (partial) calculation results. Calling
 * this method should flush any cached calculation results.</text>
      </javadoc>
      <method name="getColumnsRange" type="BasicMatrix<N>" startLine="154" endLine="159" />
      <javadoc>
        <param>aFirst The first column to include.</param>
        <param>aLimit The limit (exclusive) - the first column not to include.</param>
        <return>A new matrix with only the specified range of columns</return>
      </javadoc>
      <method name="getCondition" type="Scalar<N>" startLine="161" endLine="161" />
      <method name="getDeterminant" type="Scalar<N>" startLine="163" endLine="166" />
      <javadoc>
        <return>The matrix' determinant.</return>
      </javadoc>
      <method name="getEigenvalues" type="List<ComplexNumber>" startLine="168" endLine="168" />
      <method name="getFrobeniusNorm" type="Scalar<N>" startLine="170" endLine="184" />
      <javadoc>
        <text>* The Frobenius norm is the square root of the sum of the squares of each
 * element, or the square root of the sum of the square of the singular values.</text>
        <return>The matrix' Frobenius norm</return>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="getInfinityNorm" type="Scalar<N>" startLine="186" endLine="197" />
      <javadoc>
        <return>Max row sum</return>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="getKyFanNorm" type="Scalar<N>" startLine="199" endLine="209" />
      <javadoc>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="getOneNorm" type="Scalar<N>" startLine="211" endLine="222" />
      <javadoc>
        <return>Max col sum</return>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="getOperatorNorm" type="Scalar<N>" startLine="224" endLine="235" />
      <javadoc>
        <text>* 2-norm, max singular value</text>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="getRank" type="int" startLine="237" endLine="244" />
      <javadoc>
        <text>* The rank of a matrix is the (maximum) number of linearly independent
 * rows or columns it contains. It is also equal to the number of nonzero
 * singular values of the matrix.</text>
        <return>The matrix' rank.</return>
      </javadoc>
      <method name="getRowsRange" type="BasicMatrix<N>" startLine="246" endLine="251" />
      <javadoc>
        <param>aFirst The first row to include.</param>
        <param>aLimit The limit (exclusive) - the first row not to include.</param>
        <return>A new matrix with only the specified range of rows</return>
      </javadoc>
      <method name="getSingularValues" type="List<? extends Number>" startLine="253" endLine="253" />
      <method name="getTrace" type="Scalar<N>" startLine="255" endLine="260" />
      <javadoc>
        <text>* The sum of the diagonal elements.</text>
        <return>The matrix' trace.</return>
      </javadoc>
      <method name="getTraceNorm" type="Scalar<N>" startLine="262" endLine="272" />
      <javadoc>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="getVectorNorm" type="Scalar<N>" startLine="274" endLine="287" />
      <javadoc>
        <text>* Treats [this] as if it is one dimensional (a vector) and
 * calculates the vector norm. The interface only requires that
 * implementations can handle arguments 0, 1, 2 and {@linkplain Integer#MAX_VALUE}.</text>
        <see>#getFrobeniusNorm()</see>
        <see>#getInfinityNorm()</see>
        <see>#getKyFanNorm(int)</see>
        <see>#getOneNorm()</see>
        <see>#getOperatorNorm()</see>
        <see>#getTraceNorm()</see>
        <see>#getVectorNorm(int)</see>
      </javadoc>
      <method name="invert" type="BasicMatrix<N>" startLine="289" endLine="315" />
      <javadoc>
        <text>* <p> 
 * About inverting matrices:
 * </p>
 * <ul>
 * <li>"right inverse": [this][right inverse]=[I]. You may calculate it
 * using {@linkplain #solve(BasicMatrix)}.</li>
 * <li>"left inverse": [left inverse][this]=[I]. You may calculate it
 * using {@linkplain #solve(BasicMatrix)} and transposing.</li>
 * <li>"generalised inverse": [this][generalised inverse][this]=[this]. Note
 * that if [this] is singular or non-square, then [generalised inverse] is 
 * not unique.</li>
 * <li>"pseudoinverse": The generalised inverse (there are 
 * typically/possibly many) with the smallest frobenius norm is called the 
 * pseudoinverse. You may calculate it using the {@linkplain QR} or{@linkplain SingularValue} decompositions.</li>
 * <li>"inverse": <ul><li>
 * If [left inverse]=[right inverse] then it is also [inverse].
 * </li><li>
 * If [this] is square and has full rank then the [generalised inverse]
 * is unique, with the [pseudoinverse] given, and equal to [inverse].
 * </li></ul></li>
 * </ul></text>
        <return>The "best possible" inverse....</return>
      </javadoc>
      <method name="isEmpty" type="boolean" startLine="317" endLine="322" />
      <javadoc>
        <text>* Matrices are either square, tall, fat or empty. m <= 0 or n <= 0</text>
        <return>true if matrix is empty</return>
      </javadoc>
      <method name="isFat" type="boolean" startLine="324" endLine="329" />
      <javadoc>
        <text>* Matrices are either square, tall, fat or empty. 1 <= m < n</text>
        <return>true if matrix is fat</return>
      </javadoc>
      <method name="isFullRank" type="boolean" startLine="331" endLine="334" />
      <javadoc>
        <return>true if {@linkplain #getRank()} == min({@linkplain #getRowDim()},{@linkplain #getColDim()})</return>
      </javadoc>
      <method name="isHermitian" type="boolean" startLine="336" endLine="336" />
      <method name="isScalar" type="boolean" startLine="338" endLine="341" />
      <javadoc>
        <return>true if this is a 1x1 matrix</return>
      </javadoc>
      <method name="isSquare" type="boolean" startLine="343" endLine="348" />
      <javadoc>
        <text>* Matrices are either square, tall, fat or empty. m = n <> 0</text>
        <return>true if matrix is square</return>
      </javadoc>
      <method name="isSymmetric" type="boolean" startLine="350" endLine="350" />
      <method name="isTall" type="boolean" startLine="352" endLine="357" />
      <javadoc>
        <text>* Matrices are either square, tall, fat or empty. m > n >= 1</text>
        <return>true if matrix is tall</return>
      </javadoc>
      <method name="isVector" type="boolean" startLine="359" endLine="362" />
      <javadoc>
        <return>true if the row or column dimensions are equal to 1.</return>
      </javadoc>
      <method name="mergeColumns" type="BasicMatrix<N>" startLine="364" endLine="371" />
      <javadoc>
        <text>* [aMtrx] is appended to the bottom of [this].
 * The two matrices must have the same number of columns.</text>
        <param>aMtrx The matrix to merge.</param>
        <return>A new matrix with more rows.</return>
      </javadoc>
      <method name="mergeRows" type="BasicMatrix<N>" startLine="373" endLine="380" />
      <javadoc>
        <text>* [aMtrx] is appended to the right side of [this].
 * The two matrices must have the same number of rows.</text>
        <param>aMtrx The matrix to merge.</param>
        <return>A new matrix with more columns.</return>
      </javadoc>
      <method name="modify" type="BasicMatrix<N>" startLine="382" endLine="382" />
      <method name="multiply" type="BasicMatrix<N>" startLine="384" endLine="391" />
      <javadoc>
        <text>* Multiplies the elements of this matrix with aNmbr.</text>
        <param>aNmbr What to multiply with.</param>
        <return>A new matrix whos elements are the elements of this multiplied
 * with aNmbr.</return>
      </javadoc>
      <method name="multiplyElements" type="BasicMatrix<N>" startLine="393" endLine="401" />
      <javadoc>
        <text>* Multiplies the elements of this matrix with the elements of aMtrx. The
 * matrices must have equal dimensions.</text>
        <param>aMtrx The elements to multiply by.</param>
        <return>A new matrix whos elements are the elements of this multiplied
 * with the elements of aMtrx.</return>
      </javadoc>
      <method name="multiplyLeft" type="BasicMatrix<N>" startLine="403" endLine="413" />
      <javadoc>
        <text>* Matrix multiplication: [aMtrx][this]
 * <br>
 * The column dimension of the left matrix must equal the row dimension of
 * the right matrix.</text>
        <param>aMtrx The left matrix.</param>
        <return>The product.</return>
        <see>org.ojalgo.matrix.BasicMatrix#multiplyRight(BasicMatrix)</see>
      </javadoc>
      <method name="multiplyRight" type="BasicMatrix<N>" startLine="415" endLine="425" />
      <javadoc>
        <text>* Matrix multiplication: [this][aMtrx]
 * <br>
 * The column dimension of the left matrix must equal the row dimension of
 * the right matrix.</text>
        <param>aMtrx The right matrix.</param>
        <return>The product.</return>
        <see>org.ojalgo.matrix.BasicMatrix#multiplyLeft(BasicMatrix)</see>
      </javadoc>
      <method name="multiplyVectors" type="Scalar<N>" startLine="427" endLine="432" />
      <javadoc>
        <text>* Assumes that both [this] and [aVctr] have row or column dimension,
 * doesn't matter which, equal to 1. The two vectors must have the
 * same number of elements.</text>
      </javadoc>
      <method name="negate" type="BasicMatrix<N>" startLine="434" endLine="437" />
      <javadoc>
        <return>A new matrix with negated elements.</return>
      </javadoc>
      <method name="round" type="BasicMatrix<N>" startLine="439" endLine="445" />
      <javadoc>
        <param>aCntxt</param>
        <return />
        <deprecated>v34 Use {@link #modifyAll(UnaryFunction)} instead</deprecated>
      </javadoc>
      <method name="selectColumns" type="BasicMatrix<N>" startLine="447" endLine="451" />
      <javadoc>
        <param>someCols An ordered array of column indeces.</param>
        <return>A matrix with a subset of, reordered, columns.</return>
      </javadoc>
      <method name="selectRows" type="BasicMatrix<N>" startLine="453" endLine="457" />
      <javadoc>
        <param>someRows An ordered array of row indeces.</param>
        <return>A matrix with a subset of, reordered, rows.</return>
      </javadoc>
      <method name="solve" type="BasicMatrix<N>" startLine="459" endLine="477" />
      <javadoc>
        <text>* <p>
 * This method solves a system of linear equations: [this][X]=[aRHS].
 * A combination of columns in [this] should produce a column in [aRHS].
 * It is ok for [aRHS] to have more than 1 column.
 * </p>
 * <ul>
 * <li>If the problem is over-qualified an approximate solution is returned.</li>
 * <li>If the problem is under-qualified one possible solution is returned.</li>
 * </ul>
 * <p>
 * Remember that: [X][this]=[aRHS] is equivalent to
 * [this]<sup>T</sup>[X]<sup>T</sup>=[aRHS]<sup>T</sup>
 * </p></text>
        <param>aRHS The right hand side of the equation.</param>
        <return>The solution, [X].</return>
      </javadoc>
      <method name="subtract" type="BasicMatrix<N>" startLine="479" endLine="486" />
      <javadoc>
        <text>* Subtracts the elements of aMtrx from the elements of this matrix. The
 * matrices must have equal dimensions.</text>
        <param>aMtrx What to subtract.</param>
        <return>A new matrix whos elements are the difference of this' and aMtrx'.</return>
      </javadoc>
      <method name="subtract" type="BasicMatrix<N>" startLine="488" endLine="494" />
      <javadoc>
        <text>* Subtracts aNmbr from the elements of this matrix.</text>
        <param>value What to subtract.</param>
        <return>A new matrix whos elements are the differences between this' elements and aNmbr.</return>
      </javadoc>
      <method name="toBigDecimal" type="BigDecimal" startLine="496" endLine="503" />
      <javadoc>
        <text>* Extracts one element of this matrix as a BigDecimal.</text>
        <param>row A row index.</param>
        <param>column A column index.</param>
        <return>One matrix element</return>
      </javadoc>
      <method name="toBigStore" type="PhysicalStore<BigDecimal>" startLine="505" endLine="511" />
      <javadoc>
        <text>* Must be a copy that is safe to modify.</text>
        <see>org.ojalgo.matrix.BasicMatrix#toComplexStore()</see>
        <see>org.ojalgo.matrix.BasicMatrix#toPrimitiveStore()</see>
      </javadoc>
      <method name="toComplexNumber" type="ComplexNumber" startLine="513" endLine="520" />
      <javadoc>
        <text>* Extracts one element of this matrix as a ComplexNumber.</text>
        <param>row A row index.</param>
        <param>column A column index.</param>
        <return>One matrix element</return>
      </javadoc>
      <method name="toComplexStore" type="PhysicalStore<ComplexNumber>" startLine="522" endLine="528" />
      <javadoc>
        <text>* Must be a copy that is safe to modify.</text>
        <see>org.ojalgo.matrix.BasicMatrix#toBigStore()</see>
        <see>org.ojalgo.matrix.BasicMatrix#toPrimitiveStore()</see>
      </javadoc>
      <method name="toListOfColumns" type="List<BasicMatrix<N>>" startLine="530" endLine="530" />
      <method name="toListOfElements" type="List<N>" startLine="532" endLine="536" />
      <javadoc>
        <text>* It is also possible to call {@linkplain #toBigStore()}, {@linkplain #toComplexStore()}or {@linkplain #toPrimitiveStore()} and then {@linkplain PhysicalStore#asList()}.</text>
      </javadoc>
      <method name="toListOfRows" type="List<BasicMatrix<N>>" startLine="538" endLine="538" />
      <method name="toPrimitiveStore" type="PhysicalStore<Double>" startLine="540" endLine="546" />
      <javadoc>
        <text>* Must be a copy that is safe to modify.</text>
        <see>org.ojalgo.matrix.BasicMatrix#toBigStore()</see>
        <see>org.ojalgo.matrix.BasicMatrix#toComplexStore()</see>
      </javadoc>
      <method name="toScalar" type="Scalar<N>" startLine="548" endLine="555" />
      <javadoc>
        <text>* Extracts one element of this matrix as a Scalar.</text>
        <param>row A row index.</param>
        <param>column A column index.</param>
        <return>One matrix element</return>
      </javadoc>
      <method name="toString" type="String" startLine="557" endLine="557" />
      <method name="transpose" type="BasicMatrix<N>" startLine="559" endLine="567" />
      <javadoc>
        <text>* Transposes this matrix.
 * For complex matrices conjugate() and transpose() are NOT EQUAL.</text>
        <return>A matrix that is the transpose of this matrix.</return>
        <see>org.ojalgo.matrix.BasicMatrix#conjugate()</see>
      </javadoc>
    </interface>
  </interface>
</source>
