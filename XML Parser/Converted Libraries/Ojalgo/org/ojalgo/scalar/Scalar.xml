<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.scalar">
  <import name="java.math.BigDecimal" />
  <import name="org.ojalgo.type.context.NumberContext" />
  <interface name="Scalar" startLine="28">
    <implements name="Comparable<N>" />
    <javadoc>
      <text>* <p>
 * A {@linkplain Scalar} is:
 * <ol>
 * <li>An abstraction of a vector/matrix element.</li>
 * <li>A {@linkplain Number} decorator, increasing the number of things you can do with them.</li>
 * </ol>
 * </p>
 * <p>
 * Theoretically it is a Field or at least a Division ring.
 * </p>
 * <p>
 * A group is a set of elements paired with a binary operation. Four conditions called the group axioms must be
 * satisfied:
 * <ol>
 * <li>Closure: If A and B are both members of the set then the result of A op B is also a member.</li>
 * <li>Associativity: Invocation/execution order doesn't matter - ((A op B) op C) == (A op (B op C))</li>
 * <li>The identity property: There is an identity element in the set, I, so that I op A == A op I == A</li>
 * <li>The inverse property: For each element in the set there must be an inverse element (opposite or reciprocal) so
 * that A<sup>-1</sup> op A == A op A<sup>-1</sup> == I</li>
 * </ol>
 * Note that commutativity is not a requirement - A op B doesn't always have to be equal to B op A. If the operation is
 * commutative then the group is called an abelian group or simply a commutative group.
 * </p>
 * <p>
 * A ring is a commutative {@linkplain Group} (add operation) with a second binary operation (multiply) that is
 * distributive over the commutative group operation and is associative.
 * </p>
 * <p>
 * A field is a commutative ring (even the multiplication operation) with notions of addition, subtraction,
 * multiplication, and division. Any field may be used as the scalars for a vector space, which is the standard general
 * context for linear algebra.
 * </p>
 * <p>
 * A division ring is a ring in which division is possible. Division rings differ from fields only in that their
 * multiplication is not required to be commutative.
 * </p></text>
      <author>apete</author>
      <see><a href="http://en.wikipedia.org/wiki/Operation_%28mathematics%29">Operation</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Group_%28mathematics%29">Group</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Ring_%28mathematics%29">Ring</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Field_%28mathematics%29">Field</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Division_ring">Division ring</a></see>
      <see><a href="http://en.wikipedia.org/wiki/Vector_space">Vector space</a></see>
    </javadoc>
    <interface name="Factory" startLine="76">
      <method name="cast" type="N" startLine="78" endLine="78" />
      <method name="cast" type="N" startLine="80" endLine="80" />
      <method name="convert" type="Scalar<N>" startLine="82" endLine="82" />
      <method name="convert" type="Scalar<N>" startLine="84" endLine="84" />
      <method name="one" type="Scalar<N>" startLine="86" endLine="89" />
      <javadoc>
        <return>The multiplicative identity element</return>
      </javadoc>
      <method name="zero" type="Scalar<N>" startLine="91" endLine="94" />
      <javadoc>
        <return>The additive identity element</return>
      </javadoc>
      <method name="add" type="Scalar<N>" startLine="98" endLine="108" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="add" type="Scalar<N>" startLine="110" endLine="120" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="conjugate" type="Scalar<N>" startLine="122" endLine="127" />
      <javadoc>
        <see>#conjugate()</see>
        <see>#invert()</see>
        <see>#negate()</see>
      </javadoc>
      <method name="divide" type="Scalar<N>" startLine="129" endLine="139" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="divide" type="Scalar<N>" startLine="141" endLine="151" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="doubleValue" type="double" startLine="153" endLine="153" />
      <method name="getNumber" type="N" startLine="155" endLine="155" />
      <method name="invert" type="Scalar<N>" startLine="157" endLine="162" />
      <javadoc>
        <see>#conjugate()</see>
        <see>#invert()</see>
        <see>#negate()</see>
      </javadoc>
      <method name="isAbsolute" type="boolean" startLine="164" endLine="173" />
      <javadoc>
        <return>true if this is equal to its own modulus (non-negative real part and no imaginary part); otherwise false.</return>
        <see>#isAbsolute()</see>
        <see>#isInfinite()</see>
        <see>#isNaN()</see>
        <see>#isReal()</see>
        <see>#isPositive()</see>
        <see>#isZero()</see>
      </javadoc>
      <method name="isInfinite" type="boolean" startLine="175" endLine="183" />
      <javadoc>
        <see>#isAbsolute()</see>
        <see>#isInfinite()</see>
        <see>#isNaN()</see>
        <see>#isReal()</see>
        <see>#isPositive()</see>
        <see>#isZero()</see>
      </javadoc>
      <method name="isNaN" type="boolean" startLine="185" endLine="193" />
      <javadoc>
        <see>#isAbsolute()</see>
        <see>#isInfinite()</see>
        <see>#isNaN()</see>
        <see>#isReal()</see>
        <see>#isPositive()</see>
        <see>#isZero()</see>
      </javadoc>
      <method name="isPositive" type="boolean" startLine="195" endLine="207" />
      <javadoc>
        <text>* Strictly Positive, and definately real. Real, as defined by {@link #isReal()}, not zero, as defined by{@link #isZero()}, and > 0.0.</text>
        <return>true if the real part is strictly positive (not zero) and the imaginary part negligible; otherwise false.</return>
        <see>#isAbsolute()</see>
        <see>#isInfinite()</see>
        <see>#isNaN()</see>
        <see>#isReal()</see>
        <see>#isPositive()</see>
        <see>#isZero()</see>
      </javadoc>
      <method name="isReal" type="boolean" startLine="209" endLine="218" />
      <javadoc>
        <return>true if there is the imaginary part is negligible; otherwise false.</return>
        <see>#isAbsolute()</see>
        <see>#isInfinite()</see>
        <see>#isNaN()</see>
        <see>#isReal()</see>
        <see>#isPositive()</see>
        <see>#isZero()</see>
      </javadoc>
      <method name="isZero" type="boolean" startLine="220" endLine="233" />
      <javadoc>
        <text>* Intends to capture if a scalar is numerically/practically zero, and in a way that is concistent between different
 * implementations. The potential exactness of {@link BigScalar} and {@link RationalNumber} should not be reflected
 * here.</text>
        <return>true if the modulus is (practically) zero; otherwise false.</return>
        <see>#isAbsolute()</see>
        <see>#isInfinite()</see>
        <see>#isNaN()</see>
        <see>#isReal()</see>
        <see>#isPositive()</see>
        <see>#isZero()</see>
      </javadoc>
      <method name="multiply" type="Scalar<N>" startLine="235" endLine="245" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="multiply" type="Scalar<N>" startLine="247" endLine="257" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="negate" type="Scalar<N>" startLine="259" endLine="264" />
      <javadoc>
        <see>#conjugate()</see>
        <see>#invert()</see>
        <see>#negate()</see>
      </javadoc>
      <method name="norm" type="double" startLine="266" endLine="266" />
      <method name="signum" type="Scalar<N>" startLine="268" endLine="268" />
      <method name="subtract" type="Scalar<N>" startLine="270" endLine="280" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="subtract" type="Scalar<N>" startLine="282" endLine="292" />
      <javadoc>
        <see>#add(double)</see>
        <see>#add(Number)</see>
        <see>#divide(double)</see>
        <see>#divide(Number)</see>
        <see>#multiply(double)</see>
        <see>#multiply(Number)</see>
        <see>#subtract(double)</see>
        <see>#subtract(Number)</see>
      </javadoc>
      <method name="toBigDecimal" type="BigDecimal" startLine="294" endLine="294" />
      <method name="toPlainString" type="String" startLine="296" endLine="296" />
      <method name="toString" type="String" startLine="298" endLine="298" />
    </interface>
  </interface>
</source>
