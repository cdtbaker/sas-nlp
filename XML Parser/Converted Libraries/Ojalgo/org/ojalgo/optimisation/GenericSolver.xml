<?xml version="1.0" encoding="UTF-8"?>
<source package="org.ojalgo.optimisation">
  <import name="java.io.Serializable" />
  <import name="java.util.concurrent.atomic.AtomicInteger" />
  <import name="org.ojalgo.RecoverableCondition" />
  <import name="org.ojalgo.access.Access1D" />
  <import name="org.ojalgo.access.Access2D" />
  <import name="org.ojalgo.function.multiary.MultiaryFunction" />
  <import name="org.ojalgo.matrix.store.MatrixStore" />
  <import name="org.ojalgo.netio.BasicLogger" />
  <class name="GenericSolver" startLine="34">
    <implements name="Optimisation.Solver" />
    <implements name="Serializable" />
    <declaration type="Optimisation.Options" name="options" />
    <declaration type="MultiaryFunction<Double>" name="myFunction" />
    <declaration type="AtomicInteger" name="myIterationsCount" />
    <declaration type="ExpressionsBasedModel" name="myModel" />
    <declaration type="long" name="myResetTime" />
    <declaration type="State" name="myState" />
    <method type="constructor" name="GenericSolver" startLine="45" endLine="47" />
    <javadoc>
      <param>model</param>
    </javadoc>
    <method type="constructor" name="GenericSolver" startLine="52" endLine="73">
      <scope startLine="56" endLine="64">
        <scope startLine="59" endLine="61" />
        <scope startLine="61" endLine="63" />
      </scope>
      <scope startLine="64" endLine="72">
        <scope startLine="67" endLine="69" />
        <scope startLine="69" endLine="71" />
      </scope>
    </method>
    <method type="Optimisation.Result" name="solve" startLine="75" endLine="77" />
    <method type="Optimisation.Result" name="buildResult" startLine="79" endLine="86">
      <declaration type="MatrixStore<Double>" name="tmpSolution" />
      <declaration type="double" name="tmpValue" />
      <declaration type="Optimisation.State" name="tmpState" />
    </method>
    <method type="int" name="countIterations" startLine="88" endLine="90" />
    <method type="long" name="countTime" startLine="92" endLine="94" />
    <method type="double" name="evaluateFunction" startLine="96" endLine="102">
      <scope startLine="97" endLine="99" />
      <scope startLine="99" endLine="101" />
    </method>
    <method name="extractSolution" type="MatrixStore<Double>" startLine="104" endLine="107" />
    <javadoc>
      <text>* Should be able to feed this to {@link #evaluateFunction(Access1D)}.</text>
    </javadoc>
    <method type="MatrixStore<Double>" name="getGradient" startLine="109" endLine="111" />
    <method type="ExpressionsBasedModel" name="getModel" startLine="113" endLine="115" />
    <method type="State" name="getState" startLine="117" endLine="119" />
    <javadoc>
      <text>* Should be called after a completed iteration. The iterations count is not "1" untill the first iteration is
 * completed.</text>
    </javadoc>
    <method type="int" name="incrementIterationsCount" startLine="125" endLine="134">
      <declaration type="int" name="retVal" />
      <scope startLine="129" endLine="131" />
    </method>
    <method name="initialise" type="boolean" startLine="136" endLine="136" />
    <method type="boolean" name="isDebug" startLine="138" endLine="140" />
    <method type="boolean" name="isFunctionSet" startLine="142" endLine="144" />
    <javadoc>
      <text>* Should be called at the start of an iteration (before it actually starts) to check if you should abort instead.
 * Will return false if either the iterations count or the execution time has reached their respective limits.</text>
    </javadoc>
    <method type="boolean" name="isIterationAllowed" startLine="150" endLine="164">
      <declaration type="int" name="tmpIterations" />
      <declaration type="long" name="tmpTime" />
      <declaration type="boolean" name="tmpIterationOk" />
      <declaration type="boolean" name="tmpTimeOk" />
      <comment>if (this.isDebug()) {</comment>
      <comment>this.logDebug("Iterations OK? {} {} < {}", tmpIterationOk, tmpIterations, options.iterations_abort);</comment>
      <comment>this.logDebug("Time OK? {} {} < {}", tmpTimeOk, tmpTime, options.time_abort);</comment>
      <comment>}</comment>
    </method>
    <method type="boolean" name="isModelSet" startLine="166" endLine="168" />
    <method type="void" name="logDebug" startLine="170" endLine="174">
      <scope startLine="171" endLine="173" />
    </method>
    <method type="void" name="logDebug" startLine="176" endLine="180">
      <scope startLine="177" endLine="179" />
    </method>
    <method type="void" name="logDebug" startLine="182" endLine="186">
      <scope startLine="183" endLine="185" />
    </method>
    <method type="void" name="logError" startLine="188" endLine="190" />
    <method name="needsAnotherIteration" type="boolean" startLine="192" endLine="192" />
    <method type="void" name="resetIterationsCount" startLine="194" endLine="197" />
    <method type="void" name="setState" startLine="199" endLine="201" />
    <method name="validate" type="boolean" startLine="203" endLine="212" />
    <javadoc>
      <text>* Should validate the solver data/input/structue. Even "expensive" validation can be performed as the method should
 * only be called if {@linkplain Optimisation.Options#validate} is set to true. In addition to returning true or
 * false the implementation should set the state to either {@linkplain Optimisation.State#VALID} or{@linkplain Optimisation.State#INVALID} (or possibly {@linkplain Optimisation.State#FAILED}). Typically the
 * method should be called at the very beginning of the solve-method.</text>
      <return>Is the solver instance valid?</return>
    </javadoc>
  </class>
</source>
