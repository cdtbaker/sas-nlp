<?xml version="1.0" encoding="UTF-8"?>
    <source package="edu.umd.cs.piccolox.swing">
        <import package="java.awt.Component"/>
        <import package="java.awt.Container"/>
        <import package="java.awt.Dimension"/>
        <import package="java.awt.FlowLayout"/>
        <import package="java.awt.LayoutManager"/>
        <import package="java.beans.PropertyChangeEvent"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="javax.swing.JComponent"/>
        <import package="javax.swing.JPanel"/>
        <import package="edu.umd.cs.piccolo.PNode"/>
        <class name="SwingLayoutNode" extends="PNode" line="46">
            <comment line="47">
                How the space allocated by the Swing layout manager is used differs
                 depending on Swing component type. The behavior of a default JLabel
                 (Anchors.WEST) seems to make the most sense for PNodes.                
            </comment>
            <comment line="47">
                NOTE We don&apos;t need to override removeChild(PNode) or removeChildren,
                 because they call removeChild(int index). If their implementation ever
                 changes, then we&apos;ll need to override them.                
            </comment>
            <javadoc line="46">
                Uses Swing layout managers to position PNodes.                
                <@author>
                    r Sam Reid                    
                </@author>
                <@author>
                    r Chris Malley (cmalley@pixelzoom.com)                    
                </@author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="53"/>
            <declaration name="DEFAULT_ANCHOR" type="Anchor" line="59"/>
            <declaration name="container" type="Container" line="61"/>
            <javadoc line="61">
                Container for ProxyComponents.                
            </javadoc>
            <declaration name="propertyChangeListener" type="PropertyChangeListener" line="64"/>
            <declaration name="defaultAnchor" type="Anchor" line="66"/>
            <javadoc line="66">
                Anchor to use when adding child nodes and they don&apos;t specify one.                
            </javadoc>
            <javadoc line="69">
                Construct a SwingLayoutNode that uses FlowLayout.                
            </javadoc>
            <method name="SwingLayoutNode" type="constructor" line="72"/>
            <javadoc line="76">
                Constructs a SwingLayoutNode that uses the provided LayoutManager to
                 * layout its children.                
                <@param>
                    m layoutManager LayoutManager to use for laying out children. Must
                     * not be null.                    
                </@param>
            </javadoc>
            <method name="SwingLayoutNode" type="constructor" line="83"/>
            <javadoc line="87">
                Constructs a SwingLayoutNode that lays out its children as though they
                 * were children of the provided Container.
                 * Whatever LayoutManager is being used by the container will be used when
                 * laying out nodes.                
                <@param>
                    m container Container in which child nodes will effectively be laid
                     * out                    
                </@param>
            </javadoc>
            <method name="SwingLayoutNode" type="constructor" line="97">
                <anonymous_class line="99">
                    <method name="propertyChange" type="void" line="100">
                        <declaration name="propertyName" type="String" line="101"/>
                        <scope line="102"/>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="110">
                Sets the default anchor. If no anchor is specified when a node is added,
                 * then the default anchor determines where the node is positioned in the
                 * space allocated by the Swing layout manager.                
                <@param>
                    m anchor anchor to use when a node is added but its anchor is not
                     * specified                    
                </@param>
            </javadoc>
            <method name="setAnchor" type="void" line="118"/>
            <javadoc line="122">
                Returns the anchor being used by this LayoutManager.                
                <@return>
                    n anchor currently being used when laying out children.                    
                </@return>
            </javadoc>
            <method name="getAnchor" type="Anchor" line="127"/>
            <javadoc line="131">
                Some Swing layout managers (like BoxLayout) require a reference to the
                 * proxy Container.
                 * For example: &lt;code&gt;
                 * SwingLayoutNode layoutNode = new SwingLayoutNode();
                 * layoutNode.setLayout( new BoxLayout( layoutNode.getContainer(), BoxLayout.Y_AXIS ) );
                 * &lt;/code&gt;                
                <@return>
                    n container in which children will logically be laid out in                    
                </@return>
            </javadoc>
            <method name="getContainer" type="Container" line="142"/>
            <javadoc line="146">
                Adds a child at the specified index. Like Swing, bad things can happen if
                 * the type of the constraints isn&apos;t compatible with the layout manager.                
                <@param>
                    m index 0 based index at which to add the child                    
                </@param>
                <@param>
                    m child child to be added                    
                </@param>
                <@param>
                    m constraints constraints the layout manager uses when laying out
                     * the child                    
                </@param>
                <@param>
                    m childAnchor specifies the location from which layout takes place                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="156">
                <comment line="157">
                    NOTE: This must be the only super.addChild call that we make in our
                     entire implementation, because all PNode.addChild methods are
                     implemented in terms of this one. Calling other variants of
                     super.addChild will incorrectly invoke our overrides, resulting in
                     StackOverflowException.
                    
                    super.addChild(index, child);                    
                </comment>
            </method>
            <javadoc line="168">
                {@inheritDoc}                
            </javadoc>
            <method name="addChild" type="void" line="169"/>
            <javadoc line="173">
                Adds a child at the specified index. Like Swing, bad things can happen if
                 * the type of the constraints isn&apos;t compatible with the layout manager.                
                <@param>
                    m index 0 based index at which to add the child                    
                </@param>
                <@param>
                    m child child to be added                    
                </@param>
                <@param>
                    m constraints constraints the layout manager uses when laying out
                     * the child                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="182"/>
            <javadoc line="186">
                Adds a child at the specified index.                
                <@param>
                    m index 0 based index at which to add the child                    
                </@param>
                <@param>
                    m child child to be added                    
                </@param>
                <@param>
                    m anchor specifies the location from which layout takes place                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="193"/>
            <javadoc line="197">
                Adds a child to the end of the node list.                
                <@param>
                    m child child to be added                    
                </@param>
                <@param>
                    m constraints constraints the layout manager uses when laying out
                     * the child                    
                </@param>
                <@param>
                    m anchor specifies the location from which layout takes place                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="205">
                <comment line="206">
                    NOTE: since PNode.addChild(PNode) is implemented in terms of                    
                </comment>
                <comment line="206">
                    PNode.addChild(int index), we must do the same.                    
                </comment>
                <comment line="206">
                    workaround a flaw in PNode.addChild(PNode), they should have handled                    
                </comment>
                <comment line="206">
                    this in PNode.addChild(int index).                    
                </comment>
                <declaration name="index" type="int" line="208"/>
                <scope line="211"/>
            </method>
            <javadoc line="217">
                Adds a child to the end of the node list.                
                <@param>
                    m child child to be added                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="222"/>
            <javadoc line="226">
                Adds a child to the end of the node list and specifies the given
                 * constraints.                
                <@param>
                    m child child to be added                    
                </@param>
                <@param>
                    m constraints constraints the layout manager uses when laying out
                     * the child                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="234"/>
            <javadoc line="238">
                Adds a child to the end of the node list.                
                <@param>
                    m child child to be added                    
                </@param>
                <@param>
                    m anchor specifies the location from which layout takes place                    
                </@param>
            </javadoc>
            <method name="addChild" type="void" line="244"/>
            <javadoc line="248">
                Adds a collection of nodes to the end of the list.                
                <@param>
                    m nodes nodes to add to the end of the list                    
                </@param>
                <@param>
                    m constraints constraints the layout manager uses when laying out
                     * the child                    
                </@param>
                <@param>
                    m anchor specifies the location from which layout takes place                    
                </@param>
            </javadoc>
            <method name="addChildren" type="void" line="256">
                <declaration name="i" type="Iterator" line="257"/>
                <scope line="258">
                    <declaration name="each" type="PNode" line="259"/>
                </scope>
            </method>
            <javadoc line="264">
                {@inheritDoc}                
            </javadoc>
            <method name="addChildren" type="void" line="265"/>
            <javadoc line="269">
                Adds a collection of nodes to the end of the list.                
                <@param>
                    m nodes nodes to add to the end of the list                    
                </@param>
                <@param>
                    m constraints constraints the layout manager uses when laying out
                     * the child                    
                </@param>
            </javadoc>
            <method name="addChildren" type="void" line="276"/>
            <javadoc line="280">
                Adds a collection of nodes to the end of the list.                
                <@param>
                    m nodes nodes to add to the end of the list                    
                </@param>
                <@param>
                    m anchor specifies the location from which layout takes place                    
                </@param>
            </javadoc>
            <method name="addChildren" type="void" line="286"/>
            <javadoc line="290">
                Removes a node at a specified index.                
                <@param>
                    m index 0 based index of the child to be removed                    
                </@param>
            </javadoc>
            <method name="removeChild" type="PNode" line="295">
                <comment line="296">
                    NOTE: This must be the only super.removeChild call that we make in
                     our entire implementation, because all PNode.removeChild methods are
                     implemented in terms of this one. Calling other variants of
                     super.removeChild will incorrectly invoke our overrides, resulting in
                     StackOverflowException.
                    
                    final PNode node = super.removeChild(index);                    
                </comment>
                <declaration name="node" type="PNode" line="303"/>
            </method>
            <javadoc line="314">
                PNode.removeAllChildren does not call removeChild, it manipulates an
                 * internal data structure. So we must override this in a more careful (and
                 * less efficient) manner.                
            </javadoc>
            <method name="removeAllChildren" type="void" line="319">
                <declaration name="i" type="Iterator" line="320"/>
                <scope line="321"/>
            </method>
            <javadoc line="326">
                Adds a proxy component for a node.                
                <@param>
                    m node node for which to add the proxy component                    
                </@param>
                <@param>
                    m constraints Constraints to apply when laying out the component                    
                </@param>
                <@param>
                    m anchor relative anchor point of the underyling proxy component on
                     * its container                    
                </@param>
            </javadoc>
            <method name="addProxyComponent" type="void" line="334">
                <declaration name="component" type="ProxyComponent" line="335"/>
            </method>
            <javadoc line="341">
                Removes a proxy component for a node. Does nothing if the node is not a
                 * child of the layout.                
                <@param>
                    m node node from which the proxy container should be removed from.                    
                </@param>
            </javadoc>
            <method name="removeProxyComponent" type="void" line="347">
                <scope line="348">
                    <declaration name="component" type="ProxyComponent" line="349"/>
                    <scope line="350"/>
                </scope>
            </method>
            <javadoc line="358">
                Finds the component that is serving as the proxy for a specific node.
                 * Returns null if not found.                
            </javadoc>
            <method name="getComponentForNode" type="ProxyComponent" line="362">
                <declaration name="nodeComponent" type="ProxyComponent" line="363"/>
                <declaration name="components" type="Component[]" line="364"/>
                <scope line="365">
                    <scope line="366">
                        <scope line="367">
                            <declaration name="n" type="ProxyComponent" line="368"/>
                            <scope line="369"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="378">
                Helper to figure out if the given property name relates to layout.                
                <@param>
                    m propertyName name of property being tested                    
                </@param>
                <@return>
                    n true property name relates to layout.                    
                </@return>
            </javadoc>
            <method name="isLayoutProperty" type="boolean" line="385"/>
            <javadoc line="390">
                Updates the Proxy Container&apos;s layout.                
            </javadoc>
            <method name="updateContainerLayout" type="void" line="393">
                <comment line="394">
                    ntainer.invalidate(); // necessary for layouts like BoxLayout that                    
                </comment>
                <comment line="394">
                    would otherwise use stale state                    
                </comment>
            </method>
            <class name="ProxyComponent" extends="JComponent" line="400">
                <comment line="463">
                    Base class that provides utilities for computing common anchor                    
                </comment>
                <javadoc line="400">
                    JComponent that acts as a proxy for a PNode. Provides the PNode&apos;s bounds
                     * info for all bounds-related requests.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="405"/>
                <declaration name="node" type="PNode" line="406"/>
                <declaration name="anchor" type="Anchor" line="407"/>
                <method name="ProxyComponent" type="constructor" line="409"/>
                <javadoc line="414">
                    Returns the associated PNode.                    
                    <@return>
                        n associated PNode                        
                    </@return>
                </javadoc>
                <method name="getNode" type="PNode" line="419"/>
                <javadoc line="423">
                    Report the node&apos;s dimensions as the ProxyComponent&apos;s preferred size.                    
                </javadoc>
                <method name="getPreferredSize" type="Dimension" line="426">
                    <comment line="427">
                        Round up fractional part instead of rounding down; better to                        
                    </comment>
                    <comment line="427">
                        include the whole node than to chop off part.                        
                    </comment>
                    <declaration name="w" type="double" line="429"/>
                    <declaration name="h" type="double" line="430"/>
                </method>
                <method name="roundUp" type="int" line="434"/>
                <javadoc line="438">
                    Return the PNode size as the minimum dimension; required by layouts
                     * such as BoxLayout.                    
                    <@return>
                        n the minimum size for this component                        
                    </@return>
                </javadoc>
                <method name="getMinimumSize" type="Dimension" line="444"/>
                <javadoc line="448">
                    Sets the bounds of the ProxyComponent and positions the node in the
                     * area (x,y,w,h) allocated by the layout manager.                    
                </javadoc>
                <method name="setBounds" type="void" line="452">
                    <comment line="453">
                        important to check that the bounds have really changed, or we&apos;ll                        
                    </comment>
                    <comment line="453">
                        cause StackOverflowException                        
                    </comment>
                    <scope line="455"/>
                </method>
            </class>
            <interface name="Anchor">
                <comment line="463">
                    Base class that provides utilities for computing common anchor                    
                </comment>
                <javadoc line="462">
                    Determines where nodes are anchored in the area allocated by the Swing
                     * layout manager. Predefined anchor names are similar to GridBagConstraint
                     * anchors and have the same semantics.                    
                </javadoc>
                <method name="positionNode" type="void" line="469"/>
                <javadoc line="469">
                    Positions the node in the bounds defined.                    
                    <@param>
                        m node node to be laid out                        
                    </@param>
                    <@param>
                        m x left of bounds                        
                    </@param>
                    <@param>
                        m y top of bounds                        
                    </@param>
                    <@param>
                        m width width of bounds                        
                    </@param>
                    <@param>
                        m height height of bounds                        
                    </@param>
                </javadoc>
                <declaration name="CENTER" type="Anchor" line="485"/>
                <javadoc line="485">
                    Anchors the node&apos;s center as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="486">
                    <javadoc line="487">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="488"/>
                </anonymous_class>
                <declaration name="NORTH" type="Anchor" line="493"/>
                <javadoc line="493">
                    Anchors the node&apos;s top center as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="494">
                    <javadoc line="495">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="496"/>
                </anonymous_class>
                <declaration name="NORTHEAST" type="Anchor" line="501"/>
                <javadoc line="501">
                    Anchors the node&apos;s top right as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="502">
                    <javadoc line="503">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="504"/>
                </anonymous_class>
                <declaration name="EAST" type="Anchor" line="509"/>
                <javadoc line="509">
                    Anchors the node&apos;s middle right as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="512">
                    <javadoc line="513">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="514"/>
                </anonymous_class>
                <declaration name="SOUTHEAST" type="Anchor" line="519"/>
                <javadoc line="519">
                    Anchors the node&apos;s bottom right as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="522">
                    <javadoc line="523">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="524"/>
                </anonymous_class>
                <declaration name="SOUTH" type="Anchor" line="529"/>
                <javadoc line="529">
                    Anchors the node&apos;s center bottom as the point used when laying it
                     * out.                    
                </javadoc>
                <anonymous_class line="533">
                    <javadoc line="534">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="535"/>
                </anonymous_class>
                <declaration name="SOUTHWEST" type="Anchor" line="540"/>
                <javadoc line="540">
                    Anchors the node&apos;s bottom left as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="541">
                    <javadoc line="542">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="543"/>
                </anonymous_class>
                <declaration name="WEST" type="Anchor" line="548"/>
                <javadoc line="548">
                    Anchors the node&apos;s middle left as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="549">
                    <javadoc line="550">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="551"/>
                </anonymous_class>
                <declaration name="NORTHWEST" type="Anchor" line="556"/>
                <javadoc line="556">
                    Anchors the node&apos;s top left as the point used when laying it out.                    
                </javadoc>
                <anonymous_class line="557">
                    <javadoc line="558">
                        {@inheritDoc}                        
                    </javadoc>
                    <method name="positionNode" type="void" line="559"/>
                </anonymous_class>
                <class name="AbstractAnchor" line="564">
                    <implements interface="Anchor"/>
                    <javadoc line="565">
                        Returns the x at which the given node would need to be placed so
                         * that its center was in the middle of the horizontal segment
                         * defined by x and width.                        
                        <@param>
                            m node node which is being analyzed                            
                        </@param>
                        <@param>
                            m x x component of horizontal line segment                            
                        </@param>
                        <@param>
                            m width width of horizontal line segment                            
                        </@param>
                        <@return>
                            n x at which node would need to be placed so that its
                             * center matched the center of the line segment                            
                        </@return>
                    </javadoc>
                    <method name="centerX" type="double" line="576"/>
                    <javadoc line="580">
                        Returns the y at which the given node would need to be placed so
                         * that its center was in the middle of the vertical segment defined
                         * by y and h.                        
                        <@param>
                            m node node which is being analyzed                            
                        </@param>
                        <@param>
                            m y y component of horizontal line segment                            
                        </@param>
                        <@param>
                            m height height of vertical line segment                            
                        </@param>
                        <@return>
                            n y at which node would need to be placed so that its
                             * center matched the center of the line segment                            
                        </@return>
                    </javadoc>
                    <method name="centerY" type="double" line="591"/>
                    <javadoc line="595">
                        Returns the y at which the given node would need to be placed so
                         * that its top was against the top of the vertical segment defined.                        
                        <@param>
                            m node node which is being analyzed                            
                        </@param>
                        <@param>
                            m y y component of horizontal line segment                            
                        </@param>
                        <@param>
                            m height height of vertical line segment                            
                        </@param>
                        <@return>
                            n y at which node would need to be placed so that its top
                             * matched the start of the line segment (y)                            
                        </@return>
                    </javadoc>
                    <method name="north" type="double" line="605"/>
                    <javadoc line="609">
                        Returns the y at which the given node would need to be placed so
                         * that its bottom was against the bottom of the vertical range
                         * defined.                        
                        <@param>
                            m node node which is being analyzed                            
                        </@param>
                        <@param>
                            m y y component of vertical range                            
                        </@param>
                        <@param>
                            m height height of vertical range                            
                        </@param>
                        <@return>
                            n y at which node would need to be placed so that its
                             * bottom matched the bottom of the range                            
                        </@return>
                    </javadoc>
                    <method name="south" type="double" line="620"/>
                    <javadoc line="624">
                        Returns the x at which the given node would need to be placed so
                         * that its right side was against the right side of the horizontal
                         * range defined.                        
                        <@param>
                            m node node which is being analyzed                            
                        </@param>
                        <@param>
                            m x x component of horizontal range                            
                        </@param>
                        <@param>
                            m width width of horizontal range                            
                        </@param>
                        <@return>
                            n x at which node would need to be placed so that its right
                             * side touched the right side of the range defined.                            
                        </@return>
                    </javadoc>
                    <method name="east" type="double" line="635"/>
                    <javadoc line="639">
                        Returns the x at which the given node would need to be placed so
                         * that its left side was against the left side of the horizontal
                         * range defined.                        
                        <@param>
                            m node node which is being analyzed                            
                        </@param>
                        <@param>
                            m x x component of horizontal range                            
                        </@param>
                        <@param>
                            m width width of horizontal range                            
                        </@param>
                        <@return>
                            n x at which node would need to be placed so that its left
                             * side touched the left side of the range defined (x)                            
                        </@return>
                    </javadoc>
                    <method name="west" type="double" line="650"/>
                </class>
            </interface>
        </class>
    </source>