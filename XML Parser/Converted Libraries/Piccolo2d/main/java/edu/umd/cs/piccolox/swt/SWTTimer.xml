<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolox.swt">
  <import name="java.awt.event.ActionEvent" />
  <import name="java.awt.event.ActionListener" />
  <import name="javax.swing.Timer" />
  <import name="org.eclipse.swt.widgets.Display" />
  <class name="SWTTimer" extends="Timer" startLine="38">
    <javadoc>
      <text>* SWT timer.</text>
      <author>Lance Good</author>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <declaration type="boolean" name="notify" />
    <declaration type="int" name="initialDelay" />
    <declaration type="int" name="delay" />
    <declaration type="boolean" name="repeats" />
    <declaration type="boolean" name="coalesce" />
    <declaration type="Runnable" name="doPostEvent" />
    <declaration type="Display" name="display" />
    <declaration type="long" name="expirationTime" />
    <declaration type="SWTTimer" name="nextTimer" />
    <declaration type="boolean" name="running" />
    <class name="SWTDoPostEvent" startLine="62">
      <implements name="Runnable" />
      <javadoc>
        <text>* DoPostEvent is a runnable class that fires actionEvents to the listeners
 * on the EventDispatchThread, via invokeLater.</text>
        <see>#post</see>
      </javadoc>
      <method type="void" name="run" startLine="69" endLine="76">
        <scope startLine="70" endLine="75">
          <scope startLine="72" endLine="74" />
        </scope>
      </method>
      <method type="SWTTimer" name="getTimer" startLine="78" endLine="80" />
      <javadoc>
        <text>* Constructor for SWTTimer.</text>
        <param>display display associated with this timer</param>
        <param>delay time in milliseconds between firings of this timer</param>
        <param>listener action listener to fire when the timer fires</param>
      </javadoc>
      <method type="constructor" name="SWTTimer" startLine="90" endLine="97" />
      <javadoc>
        <text>* Notifies all listeners that have registered interest for notification on
 * this event type.</text>
        <param>e the action event to fire</param>
      </javadoc>
      <method type="void" name="fireActionPerformed" startLine="105" endLine="116">
        <declaration type="Object[]" name="listeners" />
        <scope startLine="111" endLine="115">
          <scope startLine="112" endLine="114" />
        </scope>
        <comment>Guaranteed to return a non-null array</comment>
        <comment>Process the listeners last to first, notifying</comment>
        <comment>those that are interested in this event</comment>
      </method>
      <javadoc>
        <text>* Returns the timer queue.</text>
      </javadoc>
      <method type="SWTTimerQueue" name="timerQueue" startLine="121" endLine="123" />
      <javadoc>
        <text>* Sets the <code>Timer</code>'s delay, the number of milliseconds between
 * successive action events.</text>
        <param>delay the delay in milliseconds</param>
        <see>#setInitialDelay</see>
      </javadoc>
      <method type="void" name="setDelay" startLine="132" endLine="139">
        <scope startLine="133" endLine="135" />
        <scope startLine="136" endLine="138" />
      </method>
      <javadoc>
        <text>* Returns the delay, in milliseconds, between firings of action events.</text>
        <see>#setDelay</see>
        <see>#getInitialDelay</see>
        <return>delay in milliseconds between firings of this timer</return>
      </javadoc>
      <method type="int" name="getDelay" startLine="148" endLine="150" />
      <javadoc>
        <text>* Sets the <code>Timer</code>'s initial delay, which by default is the same
 * as the between-event delay. This is used only for the first action event.
 * Subsequent action events are spaced using the delay property.</text>
        <param>initialDelay the delay, in milliseconds, between the invocation of
 * the <code>start</code> method and the first action event fired
 * by this timer</param>
        <see>#setDelay</see>
      </javadoc>
      <method type="void" name="setInitialDelay" startLine="163" endLine="170">
        <scope startLine="164" endLine="166" />
        <scope startLine="167" endLine="169" />
      </method>
      <javadoc>
        <text>* Returns the <code>Timer</code>'s initial delay. By default this is the
 * same as the value returned by getDelay.</text>
        <see>#setInitialDelay</see>
        <see>#setDelay</see>
        <return>the initial delay of this timer</return>
      </javadoc>
      <method type="int" name="getInitialDelay" startLine="180" endLine="182" />
      <javadoc>
        <text>* If <code>flag</code> is <code>false</code>, instructs the
 * <code>Timer</code> to send only one action event to its listeners.</text>
        <param>flag specify <code>false</code> to make the timer stop after
 * sending its first action event</param>
      </javadoc>
      <method type="void" name="setRepeats" startLine="191" endLine="193" />
      <javadoc>
        <text>* Returns <code>true</code> (the default) if the <code>Timer</code> will
 * send an action event to its listeners multiple times.</text>
        <see>#setRepeats</see>
        <return>true if this timer should repeat when completed</return>
      </javadoc>
      <method type="boolean" name="isRepeats" startLine="202" endLine="204" />
      <javadoc>
        <text>* Sets whether the <code>Timer</code> coalesces multiple pending
 * <code>ActionEvent</code> firings. A busy application may not be able to
 * keep up with a <code>Timer</code>'s event generation, causing multiple
 * action events to be queued. When processed, the application sends these
 * events one after the other, causing the <code>Timer</code>'s listeners to
 * receive a sequence of events with no delay between them. Coalescing
 * avoids this situation by reducing multiple pending events to a single
 * event. <code>Timer</code>s coalesce events by default.</text>
        <param>flag specify <code>false</code> to turn off coalescing</param>
      </javadoc>
      <method type="void" name="setCoalesce" startLine="218" endLine="227">
        <declaration type="boolean" name="old" />
        <scope startLine="221" endLine="226">
          <comment>We must do this as otherwise if the Timer once notified</comment>
          <comment>in !coalese mode notify will be stuck to true and never</comment>
          <comment>become false.</comment>
        </scope>
      </method>
      <javadoc>
        <text>* Returns <code>true</code> if the <code>Timer</code> coalesces multiple
 * pending action events.</text>
        <see>#setCoalesce</see>
        <return>true if this timer coalesces multiple pending action events</return>
      </javadoc>
      <method type="boolean" name="isCoalesce" startLine="236" endLine="238" />
      <javadoc>
        <text>* Starts the <code>Timer</code>, causing it to start sending action events
 * to its listeners.</text>
        <see>#stop</see>
      </javadoc>
      <method type="void" name="start" startLine="246" endLine="248" />
      <javadoc>
        <text>* Returns <code>true</code> if the <code>Timer</code> is running.</text>
        <see>#start</see>
        <return>true if this timer is scheduled to run</return>
      </javadoc>
      <method type="boolean" name="isRunning" startLine="256" endLine="258" />
      <javadoc>
        <text>* Stops the <code>Timer</code>, causing it to stop sending action events to
 * its listeners.</text>
        <see>#start</see>
      </javadoc>
      <method type="void" name="stop" startLine="266" endLine="269" />
      <javadoc>
        <text>* Restarts the <code>Timer</code>, canceling any pending firings and
 * causing it to fire with its initial delay.</text>
      </javadoc>
      <method type="void" name="restart" startLine="275" endLine="278" />
      <javadoc>
        <text>* Resets the internal state to indicate this Timer shouldn't notify any of
 * its listeners. This does not stop a repeatable Timer from firing again,
 * use <code>stop</code> for that.</text>
      </javadoc>
      <method type="void" name="cancelEventOverride" startLine="285" endLine="287" />
      <method type="void" name="postOverride" startLine="289" endLine="294">
        <scope startLine="290" endLine="293" />
      </method>
      <javadoc>
        <param>expirationTime the expirationTime to set</param>
      </javadoc>
      <method type="void" name="setExpirationTime" startLine="299" endLine="301" />
      <javadoc>
        <return>the expirationTime</return>
      </javadoc>
      <method type="long" name="getExpirationTime" startLine="306" endLine="308" />
      <javadoc>
        <param>nextTimer the nextTimer to set</param>
      </javadoc>
      <method type="void" name="setNextTimer" startLine="313" endLine="315" />
      <javadoc>
        <return>the nextTimer</return>
      </javadoc>
      <method type="SWTTimer" name="getNextTimer" startLine="320" endLine="322" />
      <javadoc>
        <param>running the running to set</param>
      </javadoc>
      <method type="void" name="setRunning" startLine="327" endLine="329" />
    </class>
    <comment>These fields are maintained by TimerQueue.</comment>
    <comment>eventQueued can also be reset by the TimerQueue, but will only ever</comment>
    <comment>happen in applet case when TimerQueues thread is destroyed.</comment>
  </class>
</source>
