<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolo">
  <import name="java.awt.Color" />
  <import name="java.awt.Component" />
  <import name="java.awt.Cursor" />
  <import name="java.awt.Graphics" />
  <import name="java.awt.Graphics2D" />
  <import name="java.awt.KeyEventPostProcessor" />
  <import name="java.awt.KeyboardFocusManager" />
  <import name="java.awt.event.ActionListener" />
  <import name="java.awt.event.HierarchyEvent" />
  <import name="java.awt.event.HierarchyListener" />
  <import name="java.awt.event.InputEvent" />
  <import name="java.awt.event.KeyEvent" />
  <import name="java.awt.event.MouseEvent" />
  <import name="java.awt.event.MouseListener" />
  <import name="java.awt.event.MouseMotionListener" />
  <import name="java.awt.event.MouseWheelEvent" />
  <import name="java.awt.event.MouseWheelListener" />
  <import name="javax.swing.FocusManager" />
  <import name="javax.swing.JComponent" />
  <import name="javax.swing.RepaintManager" />
  <import name="javax.swing.Timer" />
  <import name="edu.umd.cs.piccolo.event.PInputEventListener" />
  <import name="edu.umd.cs.piccolo.event.PPanEventHandler" />
  <import name="edu.umd.cs.piccolo.event.PZoomEventHandler" />
  <import name="edu.umd.cs.piccolo.util.PBounds" />
  <import name="edu.umd.cs.piccolo.util.PDebug" />
  <import name="edu.umd.cs.piccolo.util.PPaintContext" />
  <import name="edu.umd.cs.piccolo.util.PStack" />
  <import name="edu.umd.cs.piccolo.util.PUtil" />
  <class name="PCanvas" extends="JComponent" startLine="63">
    <implements name="PComponent" />
    <javadoc>
      <text>* <b>PCanvas</b> is a simple Swing component that can be used to embed Piccolo
 * into a Java Swing application. Canvases view the Piccolo scene graph through
 * a camera. The canvas manages screen updates coming from this camera, and
 * forwards swing mouse and keyboard events to the camera.
 * <P></text>
      <version>1.0</version>
      <author>Jesse Grosjean</author>
    </javadoc>
    <javadoc>
      <text>* Allows for future serialization code to understand versioned binary
 * formats.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <deprecated>this is a typo and clients should change their code to
 * reflect the correct spelling</deprecated>
    </javadoc>
    <declaration type="String" name="INTERATING_CHANGED_NOTIFICATION" />
    <javadoc>
      <text>* The property name that identifies a change in the interacting state.</text>
      <since>1.3</since>
      <deprecated>in favor of PROPERTY_INTERACTING</deprecated>
    </javadoc>
    <declaration type="String" name="INTERACTING_CHANGED_NOTIFICATION" />
    <javadoc>
      <text>* The property name that identifies a change in the interacting state.</text>
      <since>1.3</since>
    </javadoc>
    <declaration type="String" name="PROPERTY_INTERACTING" />
    <javadoc>
      <text>* Used as a public global to track the current canvas.</text>
      <deprecated>since it falsely assumes that there is only one PCanvas per
 * program</deprecated>
    </javadoc>
    <declaration type="PCanvas" name="CURRENT_ZCANVAS" />
    <javadoc>
      <text>* The camera though which this Canvas is viewing.</text>
    </javadoc>
    <declaration type="PCamera" name="camera" />
    <javadoc>
      <text>* Stack of cursors used to keep track of cursors as they change through
 * interactions.</text>
    </javadoc>
    <declaration type="PStack" name="cursorStack" />
    <javadoc>
      <text>* Whether the canvas is considered to be interacting, will probably mean
 * worse render quality.</text>
    </javadoc>
    <declaration type="int" name="interacting" />
    <javadoc>
      <text>* The render quality to use when the scene is not being interacted or
 * animated.</text>
    </javadoc>
    <declaration type="int" name="normalRenderQuality" />
    <javadoc>
      <text>* The quality to use while the scene is being animated.</text>
    </javadoc>
    <declaration type="int" name="animatingRenderQuality" />
    <javadoc>
      <text>* The quality to use while the scene is being interacted with.</text>
    </javadoc>
    <declaration type="int" name="interactingRenderQuality" />
    <javadoc>
      <text>* The one and only pan handler.</text>
    </javadoc>
    <declaration type="PPanEventHandler" name="panEventHandler" />
    <javadoc>
      <text>* The one and only ZoomEventHandler.</text>
    </javadoc>
    <declaration type="PZoomEventHandler" name="zoomEventHandler" />
    <declaration type="boolean" name="paintingImmediately" />
    <javadoc>
      <text>* Used to track whether the last paint operation was during an animation.</text>
    </javadoc>
    <declaration type="boolean" name="animatingOnLastPaint" />
    <javadoc>
      <text>* The mouse listener that is registered for large scale mouse events.</text>
    </javadoc>
    <declaration type="MouseListener" name="mouseListener" />
    <javadoc>
      <text>* Remembers the key processor.</text>
    </javadoc>
    <declaration type="KeyEventPostProcessor" name="keyEventPostProcessor" />
    <javadoc>
      <text>* The mouse wheel listeners that's registered to receive wheel events.</text>
    </javadoc>
    <declaration type="MouseWheelListener" name="mouseWheelListener" />
    <javadoc>
      <text>* The mouse listener that is registered to receive small scale mouse events
 * (like motion).</text>
    </javadoc>
    <declaration type="MouseMotionListener" name="mouseMotionListener" />
    <declaration type="int" name="ALL_BUTTONS_MASK" />
    <javadoc>
      <text>* Construct a canvas with the basic scene graph consisting of a root,
 * camera, and layer. Zooming and panning are automatically installed.</text>
    </javadoc>
    <method type="constructor" name="PCanvas" startLine="167" endLine="191">
      <method type="void" name="hierarchyChanged" startLine="180" endLine="189">
        <scope startLine="181" endLine="188">
          <scope startLine="182" endLine="184" />
          <scope startLine="185" endLine="187" />
        </scope>
      </method>
    </method>
    <javadoc>
      <text>* Creates and returns a basic Scene Graph.</text>
      <return>a built PCamera scene</return>
    </javadoc>
    <method type="PCamera" name="createDefaultCamera" startLine="198" endLine="200" />
    <javadoc>
      <text>* Get the pan event handler associated with this canvas. This event handler
 * is set up to get events from the camera associated with this canvas by
 * default.</text>
      <return>the current pan event handler, may be null</return>
    </javadoc>
    <method type="PPanEventHandler" name="getPanEventHandler" startLine="213" endLine="215" />
    <javadoc>
      <text>* Set the pan event handler associated with this canvas.</text>
      <param>handler the new zoom event handler</param>
    </javadoc>
    <method type="void" name="setPanEventHandler" startLine="222" endLine="232">
      <scope startLine="223" endLine="225" />
      <scope startLine="229" endLine="231" />
    </method>
    <javadoc>
      <text>* Get the zoom event handler associated with this canvas. This event
 * handler is set up to get events from the camera associated with this
 * canvas by default.</text>
      <return>the current zoom event handler, may be null</return>
    </javadoc>
    <method type="PZoomEventHandler" name="getZoomEventHandler" startLine="241" endLine="243" />
    <javadoc>
      <text>* Set the zoom event handler associated with this canvas.</text>
      <param>handler the new zoom event handler</param>
    </javadoc>
    <method type="void" name="setZoomEventHandler" startLine="250" endLine="260">
      <scope startLine="251" endLine="253" />
      <scope startLine="257" endLine="259" />
    </method>
    <javadoc>
      <text>* Return the camera associated with this canvas. All input events from this
 * canvas go through this camera. And this is the camera that paints this
 * canvas.</text>
      <return>camera through which this PCanvas views the scene</return>
    </javadoc>
    <method type="PCamera" name="getCamera" startLine="269" endLine="271" />
    <javadoc>
      <text>* Set the camera associated with this canvas. All input events from this
 * canvas go through this camera. And this is the camera that paints this
 * canvas.</text>
      <param>newCamera the camera which this PCanvas should view the scene</param>
    </javadoc>
    <method type="void" name="setCamera" startLine="280" endLine="291">
      <scope startLine="281" endLine="283" />
      <scope startLine="287" endLine="290" />
    </method>
    <javadoc>
      <text>* Return root for this canvas.</text>
      <return>the root PNode at the "bottom" of the scene</return>
    </javadoc>
    <method type="PRoot" name="getRoot" startLine="298" endLine="300" />
    <javadoc>
      <text>* Return layer for this canvas.</text>
      <return>the first layer attached to this camera</return>
    </javadoc>
    <method type="PLayer" name="getLayer" startLine="307" endLine="309" />
    <javadoc>
      <text>* Add an input listener to the camera associated with this canvas.</text>
      <param>listener listener to register for event notifications</param>
    </javadoc>
    <method type="void" name="addInputEventListener" startLine="316" endLine="318" />
    <javadoc>
      <text>* Remove an input listener to the camera associated with this canvas.</text>
      <param>listener listener to unregister from event notifications</param>
    </javadoc>
    <method type="void" name="removeInputEventListener" startLine="325" endLine="327" />
    <javadoc>
      <text>* Return true if this canvas has been marked as interacting, or whether
 * it's root is interacting. If so the canvas will normally render at a
 * lower quality that is faster.</text>
      <return>whether the canvas has been flagged as being interacted with</return>
    </javadoc>
    <method type="boolean" name="getInteracting" startLine="340" endLine="342" />
    <javadoc>
      <text>* Return true if any activities that respond with true to the method
 * isAnimating were run in the last PRoot.processInputs() loop. This values
 * is used by this canvas to determine the render quality to use for the
 * next paint.</text>
      <return>whether the PCanvas is currently being animated</return>
    </javadoc>
    <method type="boolean" name="getAnimating" startLine="352" endLine="354" />
    <javadoc>
      <text>* Set if this canvas is interacting. If so the canvas will normally render
 * at a lower quality that is faster. Also repaints the canvas if the render
 * quality should change.</text>
      <param>isInteracting whether the PCanvas should be considered interacting</param>
    </javadoc>
    <method type="void" name="setInteracting" startLine="363" endLine="390">
      <declaration type="boolean" name="wasInteracting" />
      <scope startLine="366" endLine="368" />
      <scope startLine="369" endLine="371" />
      <scope startLine="373" endLine="383">
        <declaration type="int" name="nextRenderQuality" />
        <scope startLine="377" endLine="379" />
        <scope startLine="380" endLine="382" />
        <comment>determine next render quality and repaint if</comment>
        <comment>it's greater then the old</comment>
        <comment>interacting render quality.</comment>
      </scope>
      <declaration type="boolean" name="newInteracting" />
      <scope startLine="387" endLine="389" />
    </method>
    <javadoc>
      <text>* Set the render quality that should be used when rendering this canvas
 * when it is not interacting or animating. The default value is
 * PPaintContext. HIGH_QUALITY_RENDERING.</text>
      <param>defaultRenderQuality supports PPaintContext.HIGH_QUALITY_RENDERING
 * or PPaintContext.LOW_QUALITY_RENDERING</param>
    </javadoc>
    <method type="void" name="setDefaultRenderQuality" startLine="400" endLine="403" />
    <javadoc>
      <text>* Set the render quality that should be used when rendering this canvas
 * when it is animating. The default value is
 * PPaintContext.LOW_QUALITY_RENDERING.</text>
      <param>animatingRenderQuality supports
 * PPaintContext.HIGH_QUALITY_RENDERING or
 * PPaintContext.LOW_QUALITY_RENDERING</param>
    </javadoc>
    <method type="void" name="setAnimatingRenderQuality" startLine="414" endLine="419">
      <scope startLine="416" endLine="418" />
    </method>
    <javadoc>
      <text>* Set the render quality that should be used when rendering this canvas
 * when it is interacting. The default value is
 * PPaintContext.LOW_QUALITY_RENDERING.</text>
      <param>interactingRenderQuality supports
 * PPaintContext.HIGH_QUALITY_RENDERING or
 * PPaintContext.LOW_QUALITY_RENDERING</param>
    </javadoc>
    <method type="void" name="setInteractingRenderQuality" startLine="430" endLine="435">
      <scope startLine="432" endLine="434" />
    </method>
    <javadoc>
      <text>* Set the canvas cursor, and remember the previous cursor on the cursor
 * stack.</text>
      <param>cursor the cursor to push onto the cursor stack</param>
    </javadoc>
    <method type="void" name="pushCursor" startLine="443" endLine="446" />
    <javadoc>
      <text>* Pop the cursor on top of the cursorStack and set it as the canvas cursor.</text>
    </javadoc>
    <method type="void" name="popCursor" startLine="451" endLine="455">
      <scope startLine="452" endLine="454" />
    </method>
    <javadoc>
      <text>* Tracks whether button1 of the mouse is down.</text>
    </javadoc>
    <declaration type="boolean" name="isButton1Pressed" />
    <javadoc>
      <text>* Tracks whether button2 of the mouse is down.</text>
    </javadoc>
    <declaration type="boolean" name="isButton2Pressed" />
    <javadoc>
      <text>* Tracks whether button3 of the mouse is down.</text>
    </javadoc>
    <declaration type="boolean" name="isButton3Pressed" />
    <javadoc>
      <text>* Override setEnabled to install/remove canvas input sources as needed.</text>
      <param>enabled new enable status of the Pcanvas</param>
    </javadoc>
    <method type="void" name="setEnabled" startLine="482" endLine="491">
      <scope startLine="485" endLine="487" />
      <scope startLine="488" endLine="490" />
    </method>
    <javadoc>
      <text>* This method installs mouse and key listeners on the canvas that forward
 * those events to piccolo.</text>
    </javadoc>
    <method type="void" name="installInputSources" startLine="497" endLine="517">
      <scope startLine="498" endLine="501" />
      <scope startLine="503" endLine="506" />
      <scope startLine="508" endLine="511" />
      <scope startLine="513" endLine="516" />
    </method>
    <javadoc>
      <text>* This method removes mouse and key listeners on the canvas that forward
 * those events to piccolo.</text>
    </javadoc>
    <method type="void" name="removeInputSources" startLine="523" endLine="533" />
    <javadoc>
      <text>* Sends the given input event with the given type to the current
 * InputManager.</text>
      <param>event event to dispatch</param>
      <param>type type of event being dispatched</param>
    </javadoc>
    <method type="void" name="sendInputEventToInputManager" startLine="542" endLine="544" />
    <javadoc>
      <text>* Updates the bounds of the component and updates the camera accordingly.</text>
      <param>x left of bounds</param>
      <param>y top of bounds</param>
      <param>width width of bounds</param>
      <param>height height of bounds</param>
    </javadoc>
    <method type="void" name="setBounds" startLine="554" endLine="557" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="repaint" startLine="562" endLine="569" />
    <declaration type="PBounds" name="repaintBounds" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="paintComponent" startLine="576" endLine="621">
      <declaration type="Graphics2D" name="g2" />
      <scope startLine="584" endLine="587" />
      <scope startLine="589" endLine="591" />
      <declaration type="PPaintContext" name="paintContext" />
      <scope startLine="596" endLine="603">
        <scope startLine="597" endLine="599" />
        <scope startLine="600" endLine="602" />
      </scope>
      <scope startLine="604" endLine="606" />
      <scope startLine="613" endLine="616" />
      <comment>support for non-opaque canvases</comment>
      <comment>see</comment>
      <comment>http:groups.google.com/group/piccolo2d-dev/browse_thread/thread/134e2792d3a54cf</comment>
      <comment>create new paint context and set render quality to lowest common</comment>
      <comment>denominator render quality.</comment>
      <comment>if switched state from animating to not animating invalidate the</comment>
      <comment>repaint bounds so that it will be drawn with the default instead of</comment>
      <comment>animating render quality.</comment>
    </method>
    <javadoc>
      <text>* If not painting immediately, send paint notification to RepaintManager,
 * otherwise does nothing.</text>
    </javadoc>
    <method type="void" name="paintImmediately" startLine="627" endLine="635">
      <scope startLine="628" endLine="630" />
    </method>
    <javadoc>
      <text>* Helper for creating a timer. It's an extension point for subclasses to
 * install their own timers.</text>
      <param>delay the number of milliseconds to wait before invoking the
 * listener</param>
      <param>listener the listener to invoke after the delay</param>
      <return>the created Timer</return>
    </javadoc>
    <method type="Timer" name="createTimer" startLine="647" endLine="649" />
    <javadoc>
      <text>* Returns the quality to use when not animating or interacting.</text>
      <since>1.3</since>
      <deprecated>in favor or getNormalRenderQuality</deprecated>
      <return>the render quality to use when not animating or interacting</return>
    </javadoc>
    <method type="int" name="getDefaultRenderQuality" startLine="658" endLine="660" />
    <javadoc>
      <text>* Returns the quality to use when not animating or interacting.</text>
      <since>1.3</since>
      <return>the render quality to use when not animating or interacting</return>
    </javadoc>
    <method type="int" name="getNormalRenderQuality" startLine="668" endLine="670" />
    <javadoc>
      <text>* Returns the quality to use when animating.</text>
      <since>1.3</since>
      <return>Returns the quality to use when animating</return>
    </javadoc>
    <method type="int" name="getAnimatingRenderQuality" startLine="678" endLine="680" />
    <javadoc>
      <text>* Returns the quality to use when interacting.</text>
      <since>1.3</since>
      <return>Returns the quality to use when interacting</return>
    </javadoc>
    <method type="int" name="getInteractingRenderQuality" startLine="688" endLine="690" />
    <javadoc>
      <text>* Returns the input event listeners registered to receive input events.</text>
      <since>1.3</since>
      <return>array or input event listeners</return>
    </javadoc>
    <method type="PInputEventListener[]" name="getInputEventListeners" startLine="698" endLine="700" />
    <javadoc>
      <text>* Prints the entire scene regardless of what the viewable area is.</text>
      <param>graphics Graphics context onto which to paint the scene for printing</param>
    </javadoc>
    <method type="void" name="printAll" startLine="707" endLine="738">
      <scope startLine="708" endLine="710" />
      <declaration type="Graphics2D" name="g2" />
      <declaration type="PBounds" name="clippingRect" />
      <declaration type="PBounds" name="originalCameraBounds" />
      <declaration type="PBounds" name="layerBounds" />
      <declaration type="double" name="clipRatio" />
      <declaration type="double" name="nodeRatio" />
      <declaration type="double" name="scale" />
      <scope startLine="724" endLine="726" />
      <scope startLine="727" endLine="729" />
      <declaration type="PPaintContext" name="pc" />
    </method>
    <class name="MouseMotionInputSourceListener" startLine="740">
      <implements name="MouseMotionListener" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="mouseDragged" startLine="742" endLine="744" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="mouseMoved" startLine="747" endLine="749" />
      <class name="MouseEventInputSource" startLine="752">
        <implements name="MouseListener" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="mouseClicked" startLine="754" endLine="756" />
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="mouseEntered" startLine="759" endLine="771">
          <declaration type="MouseEvent" name="simulated" />
          <scope startLine="762" endLine="764" />
          <scope startLine="765" endLine="767" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="mouseExited" startLine="774" endLine="786">
          <declaration type="MouseEvent" name="simulated" />
          <scope startLine="777" endLine="779" />
          <scope startLine="780" endLine="782" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="mousePressed" startLine="789" endLine="827">
          <declaration type="boolean" name="shouldBalanceEvent" />
          <declaration type="MouseEvent" name="event" />
          <scope startLine="798" endLine="800" />
          <scope startLine="805" endLine="807" />
          <scope startLine="812" endLine="814" />
          <scope startLine="822" endLine="824" />
        </method>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="mouseReleased" startLine="830" endLine="865">
          <declaration type="boolean" name="shouldBalanceEvent" />
          <declaration type="MouseEvent" name="event" />
          <scope startLine="837" endLine="839" />
          <scope startLine="844" endLine="846" />
          <scope startLine="851" endLine="853" />
          <scope startLine="860" endLine="862" />
        </method>
        <method type="MouseEvent" name="copyButtonsFromModifiers" startLine="867" endLine="885">
          <scope startLine="868" endLine="870" />
          <declaration type="int" name="newButton" />
          <scope startLine="874" endLine="876" />
          <scope startLine="877" endLine="879" />
          <scope startLine="880" endLine="882" />
        </method>
        <method type="boolean" name="hasButtonModifier" startLine="887" endLine="889" />
        <method type="MouseEvent" name="buildRetypedMouseEvent" startLine="891" endLine="893" />
        <method type="MouseEvent" name="buildModifiedMouseEvent" startLine="895" endLine="898" />
        <method type="void" name="sendRetypedMouseEventToInputManager" startLine="900" endLine="903">
          <declaration type="MouseEvent" name="retypedEvent" />
        </method>
        <method type="boolean" name="isAnyButtonDown" startLine="906" endLine="908" />
        <class name="KeyEventInputSourceListener" startLine="910">
          <implements name="KeyEventPostProcessor" />
          <javadoc>
            <text>* Class responsible for sending key events to the the InputManager.</text>
          </javadoc>
          <javadoc>
            <text>* {@inheritDoc}</text>
          </javadoc>
          <method type="boolean" name="postProcessKeyEvent" startLine="915" endLine="925">
            <declaration type="Component" name="owner" />
            <scope startLine="917" endLine="923">
              <scope startLine="918" endLine="921" />
            </scope>
          </method>
          <class name="MouseWheelInputSourceListener" startLine="928">
            <implements name="MouseWheelListener" />
            <javadoc>
              <text>* Class responsible for sending mouse events to the the InputManager.</text>
            </javadoc>
            <javadoc>
              <text>* {@inheritDoc}</text>
            </javadoc>
            <method type="void" name="mouseWheelMoved" startLine="933" endLine="938">
              <scope startLine="935" endLine="937" />
            </method>
          </class>
        </class>
      </class>
    </class>
    <comment>****************************************************************</comment>
    <comment>Basic - Methods for accessing common piccolo nodes.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Painting</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Code to manage connection to Swing. There appears to be a bug in</comment>
    <comment>swing where it will occasionally send too many mouse pressed or mouse</comment>
    <comment>released events. Below we attempt to filter out those cases before</comment>
    <comment>they get delivered to the Piccolo framework.</comment>
    <comment>****************************************************************</comment>
  </class>
</source>
