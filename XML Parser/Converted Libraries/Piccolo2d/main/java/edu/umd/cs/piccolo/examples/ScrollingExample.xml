<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolo.examples">
  <import name="java.awt.BorderLayout" />
  <import name="java.awt.Color" />
  <import name="java.awt.Point" />
  <import name="java.awt.event.ActionEvent" />
  <import name="java.awt.event.ActionListener" />
  <import name="java.awt.geom.Point2D" />
  <import name="java.awt.geom.Rectangle2D" />
  <import name="java.util.Iterator" />
  <import name="javax.swing.ButtonGroup" />
  <import name="javax.swing.JPanel" />
  <import name="javax.swing.JToggleButton" />
  <import name="javax.swing.JToolBar" />
  <import name="edu.umd.cs.piccolo.PCanvas" />
  <import name="edu.umd.cs.piccolo.PLayer" />
  <import name="edu.umd.cs.piccolo.nodes.PPath" />
  <import name="edu.umd.cs.piccolo.util.PAffineTransform" />
  <import name="edu.umd.cs.piccolo.util.PBounds" />
  <import name="edu.umd.cs.piccolox.PFrame" />
  <import name="edu.umd.cs.piccolox.swing.PDefaultScrollDirector" />
  <import name="edu.umd.cs.piccolox.swing.PScrollDirector" />
  <import name="edu.umd.cs.piccolox.swing.PScrollPane" />
  <import name="edu.umd.cs.piccolox.swing.PViewport" />
  <class name="ScrollingExample" extends="PFrame" startLine="56">
    <javadoc>
      <text>* This creates a simple scene and allows switching between traditional
 * scrolling where the scrollbars control the view and alternate scrolling where
 * the scrollbars control the document. In laymans terms - in traditional window
 * scrolling the stuff in the window moves in the opposite direction of the
 * scroll bars and in document scrolling the stuff moves in the same direction
 * as the scrollbars.
 * Toggle buttons are provided to toggle between these two types of scrolling.</text>
      <author>Lance Good</author>
      <author>Ben Bederson</author>
    </javadoc>
    <javadoc />
    <declaration type="long" name="serialVersionUID" />
    <method type="constructor" name="ScrollingExample" startLine="76" endLine="78" />
    <method type="constructor" name="ScrollingExample" startLine="80" endLine="82" />
    <method type="void" name="initialize" startLine="84" endLine="127">
      <declaration type="PCanvas" name="canvas" />
      <declaration type="PScrollPane" name="scrollPane" />
      <declaration type="PViewport" name="viewport" />
      <declaration type="PScrollDirector" name="windowSD" />
      <declaration type="PScrollDirector" name="documentSD" />
      <declaration type="JToolBar" name="toolBar" />
      <declaration type="JToggleButton" name="window" />
      <declaration type="JToggleButton" name="document" />
      <declaration type="ButtonGroup" name="bg" />
      <method type="void" name="actionPerformed" startLine="105" endLine="110" />
      <method type="void" name="actionPerformed" startLine="113" endLine="118" />
      <declaration type="JPanel" name="contentPane" />
      <comment>Now, create the toolbar</comment>
    </method>
    <class name="DocumentScrollDirector" extends="PDefaultScrollDirector" startLine="129">
      <javadoc>
        <text>* A modified scroll director that performs document based scroling rather
 * than window based scrolling (ie. the scrollbars act in the inverse
 * direction as normal)</text>
      </javadoc>
      <javadoc>
        <text>* Get the View position given the specified camera bounds - modified
 * such that:
 * Rather than finding the distance from the upper left corner of the
 * window to the upper left corner of the document - we instead find the
 * distance from the lower right corner of the window to the upper left
 * corner of the document THEN we subtract that value from total
 * document width so that the position is inverted</text>
        <param>viewBounds The bounds for which the view position will be
 * computed</param>
        <return>The view position</return>
      </javadoc>
      <method type="Point" name="getViewPosition" startLine="150" endLine="181">
        <declaration type="Point" name="pos" />
        <declaration type="PBounds" name="layerBounds" />
        <declaration type="java.util.List" name="layers" />
        <scope startLine="158" endLine="161">
          <declaration type="PLayer" name="layer" />
        </scope>
        <comment>First we compute the union of all the layers</comment>
        <comment>Then we put the bounds into camera coordinates and</comment>
        <comment>union the camera bounds</comment>
        <comment>Rather than finding the distance from the upper left corner</comment>
        <comment>of the window to the upper left corner of the document -</comment>
        <comment>we instead find the distance from the lower right corner</comment>
        <comment>of the window to the upper left corner of the document</comment>
        <comment>THEN we measure the offset from the lower right corner</comment>
        <comment>of the document</comment>
      </method>
      <javadoc>
        <text>* We do the same thing we did in getViewPosition above to flip the
 * document-window position relationship</text>
        <param>x The new x position</param>
        <param>y The new y position</param>
      </javadoc>
      <method type="void" name="setViewPosition" startLine="190" endLine="239">
        <declaration type="PBounds" name="layerBounds" />
        <declaration type="java.util.List" name="layers" />
        <scope startLine="205" endLine="208">
          <declaration type="PLayer" name="layer" />
        </scope>
        <declaration type="PAffineTransform" name="at" />
        <declaration type="PBounds" name="viewBounds" />
        <declaration type="Point2D" name="newPoint" />
        <declaration type="double" name="newX" />
        <declaration type="double" name="newY" />
        <comment>If a scroll is in progress - we ignore new scrolls - if we</comment>
        <comment>didn't, since the scrollbars depend on the camera</comment>
        <comment>location we can end up with an infinite loop</comment>
        <comment>Get the union of all the layers' bounds</comment>
        <comment>Union the camera view bounds</comment>
        <comment>Now find the new view position in view coordinates -</comment>
        <comment>This is basically the distance from the lower right</comment>
        <comment>corner of the window to the upper left corner of the</comment>
        <comment>document. We then measure the offset from the lower right corner</comment>
        <comment>of the document</comment>
        <comment>Now transform the new view position into global coords</comment>
        <comment>Compute the new matrix values to put the camera at the</comment>
        <comment>correct location</comment>
        <comment>Now actually set the camera's transform</comment>
      </method>
      <method type="void" name="addBackgroundShapes" startLine="242" endLine="261">
        <scope startLine="243" endLine="260">
          <declaration type="int" name="x" />
          <declaration type="int" name="y" />
          <scope startLine="247" endLine="252">
            <declaration type="PPath" name="path" />
          </scope>
          <scope startLine="253" endLine="258">
            <declaration type="PPath" name="path" />
          </scope>
        </scope>
      </method>
      <method type="void" name="main" startLine="263" endLine="265" />
    </class>
  </class>
</source>
