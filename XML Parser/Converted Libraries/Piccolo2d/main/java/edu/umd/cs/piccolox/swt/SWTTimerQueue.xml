<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolox.swt">
  <import name="org.eclipse.swt.widgets.Display" />
  <class name="SWTTimerQueue" startLine="33">
    <implements name="Runnable" />
    <javadoc>
      <text>* The SWTTimerQueue is a queue of timers. It has been implemented as a linked
 * list of SWTTimer objects.</text>
      <author>Lance Good</author>
    </javadoc>
    <declaration type="SWTTimerQueue" name="instance" />
    <declaration type="Display" name="display" />
    <declaration type="SWTTimer" name="firstTimer" />
    <declaration type="boolean" name="running" />
    <javadoc>
      <text>* Creates a timer queue that will be attached the the provided display.
 * It's Timers are expected to modify only this display, or none.</text>
      <param>display the display that will get updated by this queue's timers.</param>
    </javadoc>
    <method type="constructor" name="SWTTimerQueue" startLine="53" endLine="58">
      <comment>Now start the TimerQueue thread.</comment>
    </method>
    <javadoc>
      <text>* Returns the singleton instance of the SWTTimerQueue. Take note that even
 * when called with different displays it will always return the same result
 * as the first call.</text>
      <param>display display to associate with this Timer Queue's Activities</param>
      <return>singleton instance of SWTTimerQueue</return>
    </javadoc>
    <method type="SWTTimerQueue" name="sharedInstance" startLine="68" endLine="73">
      <scope startLine="69" endLine="71" />
    </method>
    <javadoc>
      <text>* Starts the timer queue. If it is already running, a RuntimeException will
 * be thrown.</text>
    </javadoc>
    <method type="void" name="start" startLine="79" endLine="95">
      <scope startLine="80" endLine="82" />
      <method type="void" name="run" startLine="86" endLine="91">
        <declaration type="Thread" name="timerThread" />
      </method>
      <comment>Ensures that the Thread will be started from the display thread.</comment>
    </method>
    <javadoc>
      <text>* Stops the TimerQueue Thread.</text>
    </javadoc>
    <method type="void" name="stop" startLine="100" endLine="103" />
    <javadoc>
      <text>* Adds the provided timer to the queue of scheduled timers.</text>
      <param>timer timer to add</param>
      <param>expirationTime time at which the timer is to be stopped and
 * removed from the queue. Given in unix time.</param>
    </javadoc>
    <method type="void" name="addTimer" startLine="112" endLine="122">
      <scope startLine="114" endLine="121" />
      <comment>If the Timer is already in the queue, then do nothing</comment>
    </method>
    <javadoc>
      <text>* Insert the Timer into the queue in the order they will expire. If
 * multiple timers are set to expire at the same time, it will insert it
 * after the last one; that way they expire in the order they came in.</text>
      <param>timer timer to insert into the queue</param>
      <param>expirationTime time in UNIX time at which the new timer should
 * expire</param>
    </javadoc>
    <method type="void" name="insertTimer" startLine="133" endLine="142">
      <declaration type="SWTTimer" name="previousTimer" />
      <scope startLine="135" endLine="137" />
      <scope startLine="138" endLine="141" />
    </method>
    <javadoc>
      <text>* Finds the last timer that will expire before or at the given expiration
 * time. If there are multiple timers expiring at the same time, the last
 * one in the queue will be returned.</text>
      <param>expirationTime expiration to compare against timers in the queue</param>
      <return>last timer that will expire before or at the given expiration
 * time</return>
    </javadoc>
    <method type="SWTTimer" name="findLastTimerExpiringBefore" startLine="153" endLine="164">
      <declaration type="SWTTimer" name="previousTimer" />
      <declaration type="SWTTimer" name="nextTimer" />
      <scope startLine="157" endLine="160" />
    </method>
    <javadoc>
      <text>* Removes the provided timer from the Timer Queue. If it is not found, then
 * nothing happens.</text>
      <param>timer timer to remove from the queue</param>
    </javadoc>
    <method type="void" name="removeTimer" startLine="172" endLine="190">
      <scope startLine="173" endLine="175" />
      <scope startLine="177" endLine="179" />
      <scope startLine="180" endLine="185">
        <declaration type="SWTTimer" name="previousTimer" />
        <scope startLine="182" endLine="184" />
      </scope>
    </method>
    <javadoc>
      <text>* Finds the timer that immediately precedes the provided timer in the
 * queue.</text>
      <param>timer to search for</param>
      <return>timer immediately preceding found timer, or null if not found</return>
    </javadoc>
    <method type="SWTTimer" name="findLastTimerBefore" startLine="199" endLine="213">
      <declaration type="SWTTimer" name="previousTimer" />
      <declaration type="SWTTimer" name="currentTimer" />
      <scope startLine="203" endLine="210">
        <scope startLine="204" endLine="206" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns true if this timer queue contains the given timer.</text>
      <param>timer timer being checked</param>
      <return>true if timer is scheduled in this queue</return>
    </javadoc>
    <method type="boolean" name="containsTimer" startLine="221" endLine="224">
      <comment>TODO: making this use isRunning without causing an infinite loop</comment>
    </method>
    <javadoc>
      <text>* If there are a ton of timers, this method may never return. It loops
 * checking to see if the head of the Timer list has expired. If it has, it
 * posts the Timer and reschedules it if necessary.</text>
      <return>how long the app can take before it should invoke this method
 * again.</return>
    </javadoc>
    <method type="long" name="postExpiredTimers" startLine="234" endLine="283">
      <declaration type="SWTTimer" name="timer" />
      <declaration type="long" name="currentTime" />
      <declaration type="long" name="timeToWait" />
      <scope startLine="242" endLine="280">
        <scope startLine="244" endLine="246" />
        <scope startLine="251" endLine="279">
          <scope startLine="252" endLine="254" />
          <scope startLine="255" endLine="257" />
          <scope startLine="264" endLine="266" />
          <scope startLine="273" endLine="275" />
          <scope startLine="276" endLine="278" />
        </scope>
        <comment>have timer post an event</comment>
        <comment>Remove the timer from the queue</comment>
        <comment>This tries to keep the interval uniform at</comment>
        <comment>the cost of drift.</comment>
        <comment>Allow other threads to call addTimer() and removeTimer()</comment>
        <comment>even when we are posting Timers like mad. Since the wait()</comment>
        <comment>releases the lock, be sure not to maintain any state</comment>
        <comment>between iterations of the loop.</comment>
        <comment>Nothing to do</comment>
      </scope>
      <comment>The timeToWait we return should never be negative and only be zero</comment>
      <comment>when we have no Timers to wait for.</comment>
    </method>
    <javadoc>
      <text>* Dispatches work to timers until the queue is told to stop running.</text>
    </javadoc>
    <method type="void" name="run" startLine="288" endLine="313">
      <declaration type="long" name="timeToWait" />
      <scope startLine="291" endLine="301">
        <scope startLine="292" endLine="300">
          <scope startLine="294" endLine="296" />
          <scope startLine="297" endLine="299" />
        </scope>
        <comment>Nothing to do</comment>
      </scope>
      <scope startLine="302" endLine="312">
        <declaration type="SWTTimer" name="timer" />
        <scope startLine="306" endLine="309" />
        <comment>Mark all the timers we contain as not being queued.</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Generates a string handy for debugging the contents of the timer queue.</text>
      <return>String representation of the queue for use in debugging</return>
    </javadoc>
    <method type="String" name="toString" startLine="320" endLine="339">
      <declaration type="StringBuffer" name="buf" />
      <declaration type="SWTTimer" name="nextTimer" />
      <scope startLine="328" endLine="335">
        <scope startLine="332" endLine="334" />
      </scope>
    </method>
    <class name="SWTTimerQueueRestart" startLine="341">
      <implements name="Runnable" />
      <javadoc>
        <text>* Runnable that will message the shared instance of the Timer Queue to
 * restart.</text>
      </javadoc>
      <javadoc>
        <text>* Tracks whether a restart has been attempted.</text>
      </javadoc>
      <declaration type="boolean" name="attemptedStart" />
      <declaration type="Display" name="display" />
      <javadoc>
        <text>* Constructs a QueueRestart Runnable that will message the Timer Queue
 * to Restart.</text>
        <param>display display associated with the SWTTimerQueue</param>
      </javadoc>
      <method type="constructor" name="SWTTimerQueueRestart" startLine="357" endLine="359" />
      <javadoc>
        <text>* Attempts to restart the queue associated with the display.</text>
      </javadoc>
      <method type="void" name="run" startLine="364" endLine="378">
        <scope startLine="365" endLine="367" />
        <declaration type="SWTTimerQueue" name="q" />
        <scope startLine="371" endLine="375">
          <scope startLine="372" endLine="374" />
        </scope>
      </method>
    </class>
  </class>
</source>
