<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolox.swing">
  <import name="java.awt.Component" />
  <import name="java.awt.Container" />
  <import name="java.awt.Dimension" />
  <import name="java.awt.FlowLayout" />
  <import name="java.awt.LayoutManager" />
  <import name="java.beans.PropertyChangeEvent" />
  <import name="java.beans.PropertyChangeListener" />
  <import name="java.util.Collection" />
  <import name="java.util.Iterator" />
  <import name="javax.swing.JComponent" />
  <import name="javax.swing.JPanel" />
  <import name="edu.umd.cs.piccolo.PNode" />
  <class name="SwingLayoutNode" extends="PNode" startLine="46">
    <javadoc>
      <text>* Uses Swing layout managers to position PNodes.</text>
      <author>Sam Reid</author>
      <author>Chris Malley (cmalley@pixelzoom.com)</author>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <declaration type="Anchor" name="DEFAULT_ANCHOR" />
    <javadoc>
      <text>* Container for ProxyComponents.</text>
    </javadoc>
    <declaration type="Container" name="container" />
    <declaration type="PropertyChangeListener" name="propertyChangeListener" />
    <javadoc>
      <text>* Anchor to use when adding child nodes and they don't specify one.</text>
    </javadoc>
    <declaration type="Anchor" name="defaultAnchor" />
    <javadoc>
      <text>* Construct a SwingLayoutNode that uses FlowLayout.</text>
    </javadoc>
    <method type="constructor" name="SwingLayoutNode" startLine="72" endLine="74" />
    <javadoc>
      <text>* Constructs a SwingLayoutNode that uses the provided LayoutManager to
 * layout its children.</text>
      <param>layoutManager LayoutManager to use for laying out children. Must
 * not be null.</param>
    </javadoc>
    <method type="constructor" name="SwingLayoutNode" startLine="83" endLine="85" />
    <javadoc>
      <text>* Constructs a SwingLayoutNode that lays out its children as though they
 * were children of the provided Container.
 * Whatever LayoutManager is being used by the container will be used when
 * laying out nodes.</text>
      <param>container Container in which child nodes will effectively be laid
 * out</param>
    </javadoc>
    <method type="constructor" name="SwingLayoutNode" startLine="97" endLine="108">
      <method type="void" name="propertyChange" startLine="100" endLine="105">
        <declaration type="String" name="propertyName" />
        <scope startLine="102" endLine="104" />
      </method>
    </method>
    <javadoc>
      <text>* Sets the default anchor. If no anchor is specified when a node is added,
 * then the default anchor determines where the node is positioned in the
 * space allocated by the Swing layout manager.</text>
      <param>anchor anchor to use when a node is added but its anchor is not
 * specified</param>
    </javadoc>
    <method type="void" name="setAnchor" startLine="118" endLine="120" />
    <javadoc>
      <text>* Returns the anchor being used by this LayoutManager.</text>
      <return>anchor currently being used when laying out children.</return>
    </javadoc>
    <method type="Anchor" name="getAnchor" startLine="127" endLine="129" />
    <javadoc>
      <text>* Some Swing layout managers (like BoxLayout) require a reference to the
 * proxy Container.
 * For example: <code>
 * SwingLayoutNode layoutNode = new SwingLayoutNode();
 * layoutNode.setLayout( new BoxLayout( layoutNode.getContainer(), BoxLayout.Y_AXIS ) );
 * </code></text>
      <return>container in which children will logically be laid out in</return>
    </javadoc>
    <method type="Container" name="getContainer" startLine="142" endLine="144" />
    <javadoc>
      <text>* Adds a child at the specified index. Like Swing, bad things can happen if
 * the type of the constraints isn't compatible with the layout manager.</text>
      <param>index 0 based index at which to add the child</param>
      <param>child child to be added</param>
      <param>constraints constraints the layout manager uses when laying out
 * the child</param>
      <param>childAnchor specifies the location from which layout takes place</param>
    </javadoc>
    <method type="void" name="addChild" startLine="156" endLine="166">
      <comment>NOTE: This must be the only super.addChild call that we make in our
 entire implementation, because all PNode.addChild methods are
 implemented in terms of this one. Calling other variants of
 super.addChild will incorrectly invoke our overrides, resulting in
 StackOverflowException.</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="addChild" startLine="169" endLine="171" />
    <javadoc>
      <text>* Adds a child at the specified index. Like Swing, bad things can happen if
 * the type of the constraints isn't compatible with the layout manager.</text>
      <param>index 0 based index at which to add the child</param>
      <param>child child to be added</param>
      <param>constraints constraints the layout manager uses when laying out
 * the child</param>
    </javadoc>
    <method type="void" name="addChild" startLine="182" endLine="184" />
    <javadoc>
      <text>* Adds a child at the specified index.</text>
      <param>index 0 based index at which to add the child</param>
      <param>child child to be added</param>
      <param>anchor specifies the location from which layout takes place</param>
    </javadoc>
    <method type="void" name="addChild" startLine="193" endLine="195" />
    <javadoc>
      <text>* Adds a child to the end of the node list.</text>
      <param>child child to be added</param>
      <param>constraints constraints the layout manager uses when laying out
 * the child</param>
      <param>anchor specifies the location from which layout takes place</param>
    </javadoc>
    <method type="void" name="addChild" startLine="205" endLine="215">
      <declaration type="int" name="index" />
      <scope startLine="211" endLine="213" />
      <comment>NOTE: since PNode.addChild(PNode) is implemented in terms of</comment>
      <comment>PNode.addChild(int index), we must do the same.</comment>
      <comment>workaround a flaw in PNode.addChild(PNode), they should have handled</comment>
      <comment>this in PNode.addChild(int index).</comment>
    </method>
    <javadoc>
      <text>* Adds a child to the end of the node list.</text>
      <param>child child to be added</param>
    </javadoc>
    <method type="void" name="addChild" startLine="222" endLine="224" />
    <javadoc>
      <text>* Adds a child to the end of the node list and specifies the given
 * constraints.</text>
      <param>child child to be added</param>
      <param>constraints constraints the layout manager uses when laying out
 * the child</param>
    </javadoc>
    <method type="void" name="addChild" startLine="234" endLine="236" />
    <javadoc>
      <text>* Adds a child to the end of the node list.</text>
      <param>child child to be added</param>
      <param>anchor specifies the location from which layout takes place</param>
    </javadoc>
    <method type="void" name="addChild" startLine="244" endLine="246" />
    <javadoc>
      <text>* Adds a collection of nodes to the end of the list.</text>
      <param>nodes nodes to add to the end of the list</param>
      <param>constraints constraints the layout manager uses when laying out
 * the child</param>
      <param>anchor specifies the location from which layout takes place</param>
    </javadoc>
    <method type="void" name="addChildren" startLine="256" endLine="262">
      <declaration type="Iterator" name="i" />
      <scope startLine="258" endLine="261">
        <declaration type="PNode" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="addChildren" startLine="265" endLine="267" />
    <javadoc>
      <text>* Adds a collection of nodes to the end of the list.</text>
      <param>nodes nodes to add to the end of the list</param>
      <param>constraints constraints the layout manager uses when laying out
 * the child</param>
    </javadoc>
    <method type="void" name="addChildren" startLine="276" endLine="278" />
    <javadoc>
      <text>* Adds a collection of nodes to the end of the list.</text>
      <param>nodes nodes to add to the end of the list</param>
      <param>anchor specifies the location from which layout takes place</param>
    </javadoc>
    <method type="void" name="addChildren" startLine="286" endLine="288" />
    <javadoc>
      <text>* Removes a node at a specified index.</text>
      <param>index 0 based index of the child to be removed</param>
    </javadoc>
    <method type="PNode" name="removeChild" startLine="295" endLine="306">
      <declaration type="PNode" name="node" />
      <comment>NOTE: This must be the only super.removeChild call that we make in
 our entire implementation, because all PNode.removeChild methods are
 implemented in terms of this one. Calling other variants of
 super.removeChild will incorrectly invoke our overrides, resulting in
 StackOverflowException.</comment>
    </method>
    <javadoc>
      <text>* PNode.removeAllChildren does not call removeChild, it manipulates an
 * internal data structure. So we must override this in a more careful (and
 * less efficient) manner.</text>
    </javadoc>
    <method type="void" name="removeAllChildren" startLine="319" endLine="324">
      <declaration type="Iterator" name="i" />
      <scope startLine="321" endLine="323" />
    </method>
    <javadoc>
      <text>* Adds a proxy component for a node.</text>
      <param>node node for which to add the proxy component</param>
      <param>constraints Constraints to apply when laying out the component</param>
      <param>anchor relative anchor point of the underyling proxy component on
 * its container</param>
    </javadoc>
    <method type="void" name="addProxyComponent" startLine="334" endLine="339">
      <declaration type="ProxyComponent" name="component" />
    </method>
    <javadoc>
      <text>* Removes a proxy component for a node. Does nothing if the node is not a
 * child of the layout.</text>
      <param>node node from which the proxy container should be removed from.</param>
    </javadoc>
    <method type="void" name="removeProxyComponent" startLine="347" endLine="356">
      <scope startLine="348" endLine="355">
        <declaration type="ProxyComponent" name="component" />
        <scope startLine="350" endLine="354" />
      </scope>
    </method>
    <javadoc>
      <text>* Finds the component that is serving as the proxy for a specific node.
 * Returns null if not found.</text>
    </javadoc>
    <method type="ProxyComponent" name="getComponentForNode" startLine="362" endLine="376">
      <declaration type="ProxyComponent" name="nodeComponent" />
      <declaration type="Component[]" name="components" />
      <scope startLine="365" endLine="374">
        <scope startLine="366" endLine="373">
          <scope startLine="367" endLine="372">
            <declaration type="ProxyComponent" name="n" />
            <scope startLine="369" endLine="371" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Helper to figure out if the given property name relates to layout.</text>
      <param>propertyName name of property being tested</param>
      <return>true property name relates to layout.</return>
    </javadoc>
    <method type="boolean" name="isLayoutProperty" startLine="385" endLine="388" />
    <javadoc>
      <text>* Updates the Proxy Container's layout.</text>
    </javadoc>
    <method type="void" name="updateContainerLayout" startLine="393" endLine="398">
      <comment>necessary for layouts like BoxLayout that</comment>
      <comment>would otherwise use stale state</comment>
    </method>
    <class name="ProxyComponent" extends="JComponent" startLine="400">
      <javadoc>
        <text>* JComponent that acts as a proxy for a PNode. Provides the PNode's bounds
 * info for all bounds-related requests.</text>
      </javadoc>
      <declaration type="long" name="serialVersionUID" />
      <declaration type="PNode" name="node" />
      <declaration type="Anchor" name="anchor" />
      <method type="constructor" name="ProxyComponent" startLine="409" endLine="412" />
      <javadoc>
        <text>* Returns the associated PNode.</text>
        <return>associated PNode</return>
      </javadoc>
      <method type="PNode" name="getNode" startLine="419" endLine="421" />
      <javadoc>
        <text>* Report the node's dimensions as the ProxyComponent's preferred size.</text>
      </javadoc>
      <method type="Dimension" name="getPreferredSize" startLine="426" endLine="432">
        <declaration type="double" name="w" />
        <declaration type="double" name="h" />
        <comment>Round up fractional part instead of rounding down; better to</comment>
        <comment>include the whole node than to chop off part.</comment>
      </method>
      <method type="int" name="roundUp" startLine="434" endLine="436" />
      <javadoc>
        <text>* Return the PNode size as the minimum dimension; required by layouts
 * such as BoxLayout.</text>
        <return>the minimum size for this component</return>
      </javadoc>
      <method type="Dimension" name="getMinimumSize" startLine="444" endLine="446" />
      <javadoc>
        <text>* Sets the bounds of the ProxyComponent and positions the node in the
 * area (x,y,w,h) allocated by the layout manager.</text>
      </javadoc>
      <method type="void" name="setBounds" startLine="452" endLine="459">
        <scope startLine="455" endLine="458" />
        <comment>important to check that the bounds have really changed, or we'll</comment>
        <comment>cause StackOverflowException</comment>
      </method>
      <interface name="Anchor" startLine="462">
        <javadoc>
          <text>* Determines where nodes are anchored in the area allocated by the Swing
 * layout manager. Predefined anchor names are similar to GridBagConstraint
 * anchors and have the same semantics.</text>
        </javadoc>
        <method name="positionNode" type="void" startLine="469" endLine="478" />
        <javadoc>
          <text>* Positions the node in the bounds defined.</text>
          <param>node node to be laid out</param>
          <param>x left of bounds</param>
          <param>y top of bounds</param>
          <param>width width of bounds</param>
          <param>height height of bounds</param>
        </javadoc>
        <javadoc>
          <text>* Anchors the node's center as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="488" endLine="490" />
        <declaration type="Anchor" name="CENTER" />
        <javadoc>
          <text>* Anchors the node's top center as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="496" endLine="498" />
        <declaration type="Anchor" name="NORTH" />
        <javadoc>
          <text>* Anchors the node's top right as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="504" endLine="506" />
        <declaration type="Anchor" name="NORTHEAST" />
        <javadoc>
          <text>* Anchors the node's middle right as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="514" endLine="516" />
        <declaration type="Anchor" name="EAST" />
        <javadoc>
          <text>* Anchors the node's bottom right as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="524" endLine="526" />
        <declaration type="Anchor" name="SOUTHEAST" />
        <javadoc>
          <text>* Anchors the node's center bottom as the point used when laying it
 * out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="535" endLine="537" />
        <declaration type="Anchor" name="SOUTH" />
        <javadoc>
          <text>* Anchors the node's bottom left as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="543" endLine="545" />
        <declaration type="Anchor" name="SOUTHWEST" />
        <javadoc>
          <text>* Anchors the node's middle left as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="551" endLine="553" />
        <declaration type="Anchor" name="WEST" />
        <javadoc>
          <text>* Anchors the node's top left as the point used when laying it out.</text>
        </javadoc>
        <javadoc>
          <text>* {@inheritDoc}</text>
        </javadoc>
        <method type="void" name="positionNode" startLine="559" endLine="561" />
        <declaration type="Anchor" name="NORTHWEST" />
        <class name="AbstractAnchor" startLine="564">
          <implements name="Anchor" />
          <javadoc>
            <text>* Returns the x at which the given node would need to be placed so
 * that its center was in the middle of the horizontal segment
 * defined by x and width.</text>
            <param>node node which is being analyzed</param>
            <param>x x component of horizontal line segment</param>
            <param>width width of horizontal line segment</param>
            <return>x at which node would need to be placed so that its
 * center matched the center of the line segment</return>
          </javadoc>
          <method type="double" name="centerX" startLine="576" endLine="578" />
          <javadoc>
            <text>* Returns the y at which the given node would need to be placed so
 * that its center was in the middle of the vertical segment defined
 * by y and h.</text>
            <param>node node which is being analyzed</param>
            <param>y y component of horizontal line segment</param>
            <param>height height of vertical line segment</param>
            <return>y at which node would need to be placed so that its
 * center matched the center of the line segment</return>
          </javadoc>
          <method type="double" name="centerY" startLine="591" endLine="593" />
          <javadoc>
            <text>* Returns the y at which the given node would need to be placed so
 * that its top was against the top of the vertical segment defined.</text>
            <param>node node which is being analyzed</param>
            <param>y y component of horizontal line segment</param>
            <param>height height of vertical line segment</param>
            <return>y at which node would need to be placed so that its top
 * matched the start of the line segment (y)</return>
          </javadoc>
          <method type="double" name="north" startLine="605" endLine="607" />
          <javadoc>
            <text>* Returns the y at which the given node would need to be placed so
 * that its bottom was against the bottom of the vertical range
 * defined.</text>
            <param>node node which is being analyzed</param>
            <param>y y component of vertical range</param>
            <param>height height of vertical range</param>
            <return>y at which node would need to be placed so that its
 * bottom matched the bottom of the range</return>
          </javadoc>
          <method type="double" name="south" startLine="620" endLine="622" />
          <javadoc>
            <text>* Returns the x at which the given node would need to be placed so
 * that its right side was against the right side of the horizontal
 * range defined.</text>
            <param>node node which is being analyzed</param>
            <param>x x component of horizontal range</param>
            <param>width width of horizontal range</param>
            <return>x at which node would need to be placed so that its right
 * side touched the right side of the range defined.</return>
          </javadoc>
          <method type="double" name="east" startLine="635" endLine="637" />
          <javadoc>
            <text>* Returns the x at which the given node would need to be placed so
 * that its left side was against the left side of the horizontal
 * range defined.</text>
            <param>node node which is being analyzed</param>
            <param>x x component of horizontal range</param>
            <param>width width of horizontal range</param>
            <return>x at which node would need to be placed so that its left
 * side touched the left side of the range defined (x)</return>
          </javadoc>
          <method type="double" name="west" startLine="650" endLine="652" />
        </class>
      </interface>
    </class>
    <comment>How the space allocated by the Swing layout manager is used differs
 depending on Swing component type. The behavior of a default JLabel
 (Anchors.WEST) seems to make the most sense for PNodes.</comment>
    <comment>NOTE We don't need to override removeChild(PNode) or removeChildren,
 because they call removeChild(int index). If their implementation ever
 changes, then we'll need to override them.</comment>
    <javadoc>
      <text>* Base class that provides utilities for computing common anchor
 * points.</text>
    </javadoc>
  </class>
</source>
