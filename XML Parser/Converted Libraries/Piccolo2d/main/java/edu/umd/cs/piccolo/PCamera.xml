<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolo">
  <import name="java.awt.BasicStroke" />
  <import name="java.awt.Color" />
  <import name="java.awt.Graphics2D" />
  <import name="java.awt.geom.AffineTransform" />
  <import name="java.awt.geom.Dimension2D" />
  <import name="java.awt.geom.Point2D" />
  <import name="java.awt.geom.Rectangle2D" />
  <import name="java.io.IOException" />
  <import name="java.io.ObjectInputStream" />
  <import name="java.io.ObjectOutputStream" />
  <import name="java.util.ArrayList" />
  <import name="java.util.Iterator" />
  <import name="java.util.List" />
  <import name="edu.umd.cs.piccolo.activities.PTransformActivity" />
  <import name="edu.umd.cs.piccolo.util.PAffineTransform" />
  <import name="edu.umd.cs.piccolo.util.PBounds" />
  <import name="edu.umd.cs.piccolo.util.PDebug" />
  <import name="edu.umd.cs.piccolo.util.PDimension" />
  <import name="edu.umd.cs.piccolo.util.PObjectOutputStream" />
  <import name="edu.umd.cs.piccolo.util.PPaintContext" />
  <import name="edu.umd.cs.piccolo.util.PPickPath" />
  <import name="edu.umd.cs.piccolo.util.PUtil" />
  <class name="PCamera" extends="PNode" startLine="55">
    <javadoc>
      <text>* <b>PCamera</b> represents a viewport onto a list of layer nodes. Each camera
 * maintains a view transform through which it views these layers. Translating
 * and scaling this view transform is how zooming and panning are implemented.
 * <p>
 * Cameras are also the point through which all PInputEvents enter Piccolo. The
 * canvas coordinate system and the local coordinate system of the topmost
 * camera should always be the same.
 * </p></text>
      <see>PLayer</see>
      <version>1.0</version>
      <author>Jesse Grosjean</author>
    </javadoc>
    <javadoc>
      <text>* Default serial version UID.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* The property name that identifies a change in the set of this camera's
 * layers (see {@link #getLayer getLayer}, {@link #getLayerCountgetLayerCount}, {@link #getLayersReference getLayersReference}). A
 * property change event's new value will be a reference to the list of this
 * nodes layers, but old value will always be null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_LAYERS" />
    <javadoc>
      <text>* The property code that identifies a change in the set of this camera's
 * layers (see {@link #getLayer getLayer}, {@link #getLayerCountgetLayerCount}, {@link #getLayersReference getLayersReference}). A
 * property change event's new value will be a reference to the list of this
 * nodes layers, but old value will always be null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_LAYERS" />
    <javadoc>
      <text>* The property name that identifies a change in this camera's view
 * transform (see {@link #getViewTransform getViewTransform},{@link #getViewTransformReference getViewTransformReference}). A property
 * change event's new value will be a reference to the view transform, but
 * old value will always be null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_VIEW_TRANSFORM" />
    <javadoc>
      <text>* The property code that identifies a change in this camera's view
 * transform (see {@link #getViewTransform getViewTransform},{@link #getViewTransformReference getViewTransformReference}). A property
 * change event's new value will be a reference to the view transform, but
 * old value will always be null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_VIEW_TRANSFORM" />
    <javadoc>
      <text>* Denotes that the view has no constraints.</text>
    </javadoc>
    <declaration type="int" name="VIEW_CONSTRAINT_NONE" />
    <javadoc>
      <text>* Enforces that the view be able to see all nodes in the scene.</text>
    </javadoc>
    <declaration type="int" name="VIEW_CONSTRAINT_ALL" />
    <javadoc>
      <text>* Constrains the the view to be centered on the scene's full bounds.</text>
    </javadoc>
    <declaration type="int" name="VIEW_CONSTRAINT_CENTER" />
    <javadoc>
      <text>* Component which receives repaint notification from this camera.</text>
    </javadoc>
    <declaration type="PComponent" name="component" />
    <javadoc>
      <text>* List of layers viewed by this camera.</text>
    </javadoc>
    <declaration type="List" name="layers" />
    <javadoc>
      <text>* Transform applied to layers before they are rendered. This transform
 * differs from the transform applied to the children of this PCamera
 * (sticky objects).</text>
    </javadoc>
    <declaration type="PAffineTransform" name="viewTransform" />
    <javadoc>
      <text>* Constraints to apply to the viewing area.</text>
    </javadoc>
    <declaration type="int" name="viewConstraint" />
    <javadoc>
      <text>* Temporary bounds used as an optimization during repaint.</text>
    </javadoc>
    <declaration type="PBounds" name="TEMP_REPAINT_RECT" />
    <javadoc>
      <text>* Create a new camera with an empy list of layers.</text>
    </javadoc>
    <method type="constructor" name="PCamera" startLine="142" endLine="147">
      <comment>layers = new ArrayList<PLayer>();</comment>
    </method>
    <javadoc>
      <text>* Return the component for this camera, or <code>null</code> if no
 * component has been associated with this camera, as may be the case for
 * internal cameras.</text>
      <return>the component for this camera, or <code>null</code> if no such
 * component exists</return>
    </javadoc>
    <method type="PComponent" name="getComponent" startLine="158" endLine="160" />
    <javadoc>
      <text>* Set the component for this camera to <code>component</code>. The
 * component, if non-null, receives repaint notification from this camera.</text>
      <param>component component for this camera</param>
    </javadoc>
    <method type="void" name="setComponent" startLine="168" endLine="171" />
    <javadoc>
      <text>* Repaint this camera and forward the repaint request to the component
 * for this camera, if it is non-null.</text>
      <param>localBounds bounds that require repainting, in local coordinates</param>
      <param>sourceNode node from which the repaint message originates, may
 * be the camera itself</param>
    </javadoc>
    <method type="void" name="repaintFrom" startLine="181" endLine="191">
      <scope startLine="182" endLine="190">
        <scope startLine="183" endLine="185" />
        <scope startLine="186" endLine="188" />
      </scope>
    </method>
    <javadoc>
      <text>* Repaint from one of the camera's layers. The repaint region needs to be
 * transformed from view to local in this case. Unlike most repaint methods
 * in Piccolo2D this one must not modify the <code>viewBounds</code>
 * parameter.</text>
      <since>1.3</since>
      <param>viewBounds bounds that require repainting, in view coordinates</param>
      <param>repaintedLayer layer dispatching the repaint notification</param>
    </javadoc>
    <method type="void" name="repaintFromLayer" startLine="203" endLine="210">
      <scope startLine="206" endLine="209" />
    </method>
    <javadoc>
      <deprecated>by {@link #repaintFromLayer(PBounds,PLayer)}. Will be removed
 * in version 2.0.</deprecated>
      <param>viewBounds bounds that require repainting, in view coordinates</param>
      <param>repaintedLayer layer dispatching the repaint notification</param>
    </javadoc>
    <method type="void" name="repaintFromLayer" startLine="218" endLine="220" />
    <javadoc>
      <text>* Return a reference to the list of layers viewed by this camera.</text>
      <return>the list of layers viewed by this camera</return>
    </javadoc>
    <method type="List" name="getLayersReference" startLine="227" endLine="229">
      <comment>public List<PLayer> getLayersReference() {</comment>
    </method>
    <javadoc>
      <text>* Return the number of layers in the list of layers viewed by this camera.</text>
      <return>the number of layers in the list of layers viewed by this camera</return>
    </javadoc>
    <method type="int" name="getLayerCount" startLine="236" endLine="238" />
    <javadoc>
      <text>* Return the layer at the specified position in the list of layers viewed by this camera.</text>
      <param>index index of the layer to return</param>
      <return>the layer at the specified position in the list of layers viewed by this camera</return>
      <throws>IndexOutOfBoundsException if the specified index is out of range
 * (<code>index &lt; 0 || index &gt;= getLayerCount()</code>)</throws>
    </javadoc>
    <method type="PLayer" name="getLayer" startLine="248" endLine="250" />
    <javadoc>
      <text>* Return the index of the first occurrence of the specified layer in the
 * list of layers viewed by this camera, or <code>-1</code> if the list of layers
 * viewed by this camera does not contain the specified layer.</text>
      <param>layer layer to search for</param>
      <return>the index of the first occurrence of the specified layer in the
 * list of layers viewed by this camera, or <code>-1</code> if the list of
 * layers viewed by this camera does not contain the specified layer</return>
    </javadoc>
    <method type="int" name="indexOfLayer" startLine="262" endLine="264" />
    <javadoc>
      <text>* Inserts the specified layer at the end of the list of layers viewed by this camera.
 * Layers may be viewed by multiple cameras at once.</text>
      <param>layer layer to add</param>
    </javadoc>
    <method type="void" name="addLayer" startLine="272" endLine="274" />
    <javadoc>
      <text>* Inserts the specified layer at the specified position in the list of layers viewed by this camera.
 * Layers may be viewed by multiple cameras at once.</text>
      <param>index index at which the specified layer is to be inserted</param>
      <param>layer layer to add</param>
      <throws>IndexOutOfBoundsException if the specified index is out of range
 * (<code>index &lt; 0 || index &gt;= getLayerCount()</code>)</throws>
    </javadoc>
    <method type="void" name="addLayer" startLine="285" endLine="290" />
    <javadoc>
      <text>* Removes the first occurrence of the specified layer from the list of
 * layers viewed by this camera, if it is present.</text>
      <param>layer layer to be removed</param>
      <return>the specified layer</return>
    </javadoc>
    <method type="PLayer" name="removeLayer" startLine="299" endLine="306">
      <scope startLine="301" endLine="304" />
    </method>
    <javadoc>
      <text>* Removes the element at the specified position from the list of layers
 * viewed by this camera.</text>
      <param>index index of the layer to remove</param>
      <return>the layer previously at the specified position</return>
      <throws>IndexOutOfBoundsException if the specified index is out of range
 * (<code>index &lt; 0 || index &gt;= getLayerCount()</code>)</throws>
    </javadoc>
    <method type="PLayer" name="removeLayer" startLine="317" endLine="323">
      <declaration type="PLayer" name="layer" />
    </method>
    <javadoc>
      <text>* Return the union of the full bounds of each layer in the list of layers
 * viewed by this camera, or empty bounds if the list of layers viewed by
 * this camera is empty.</text>
      <return>the union of the full bounds of each layer in the list of layers
 * viewed by this camera, or empty bounds if the list of layers viewed
 * by this camera is empty</return>
    </javadoc>
    <method type="PBounds" name="getUnionOfLayerFullBounds" startLine="334" endLine="342">
      <declaration type="PBounds" name="result" />
      <declaration type="int" name="size" />
      <scope startLine="337" endLine="340">
        <declaration type="PLayer" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* Paint this camera and then paint this camera's view through its view
 * transform.</text>
      <param>paintContext context in which painting occurs</param>
    </javadoc>
    <method type="void" name="paint" startLine="350" endLine="361" />
    <javadoc>
      <text>* Paint all the layers in the list of layers viewed by this camera. This method
 * is called after the view transform and clip have been applied to the
 * specified paint context.</text>
      <param>paintContext context in which painting occurs</param>
    </javadoc>
    <method type="void" name="paintCameraView" startLine="370" endLine="376">
      <declaration type="int" name="size" />
      <scope startLine="372" endLine="375">
        <declaration type="PLayer" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* Renders debug info onto the newly painted scene. Things like full bounds
 * and bounds are painted as filled and outlines.</text>
      <param>paintContext context in which painting occurs</param>
    </javadoc>
    <method type="void" name="paintDebugInfo" startLine="384" endLine="436">
      <scope startLine="385" endLine="435">
        <declaration type="Graphics2D" name="g2" />
        <declaration type="ArrayList" name="nodes" />
        <declaration type="PBounds" name="nodeBounds" />
        <declaration type="Color" name="boundsColor" />
        <declaration type="Color" name="fullBoundsColor" />
        <declaration type="int" name="size" />
        <scope startLine="396" endLine="398" />
        <declaration type="Iterator" name="i" />
        <scope startLine="402" endLine="434">
          <declaration type="PNode" name="each" />
          <scope startLine="405" endLine="417">
            <scope startLine="409" endLine="416">
              <scope startLine="412" endLine="414" />
            </scope>
          </scope>
          <scope startLine="419" endLine="433">
            <scope startLine="423" endLine="432">
              <scope startLine="424" endLine="426" />
              <scope startLine="428" endLine="430" />
            </scope>
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * Pushes this camera onto the specified paint context so that it
 * can be accessed later by {@link PPaintContext#getCamera}.
 * </p></text>
    </javadoc>
    <method type="void" name="fullPaint" startLine="446" endLine="450" />
    <javadoc>
      <text>* Generate and return a PPickPath for the point x,y specified in the local
 * coord system of this camera. Picking is done with a rectangle, halo
 * specifies how large that rectangle will be.</text>
      <param>x the x coordinate of the pick path given in local coordinates</param>
      <param>y the y coordinate of the pick path given in local coordinates</param>
      <param>halo the distance from the x,y coordinate that is considered for
 * inclusion in the pick path</param>
      <return>the picked path</return>
    </javadoc>
    <method type="PPickPath" name="pick" startLine="464" endLine="477">
      <declaration type="PBounds" name="b" />
      <declaration type="PPickPath" name="result" />
      <scope startLine="471" endLine="474" />
      <comment>make sure this camera is pushed.</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}<p>
 * After the direct children of this camera have been given a chance to be
 * picked all of the layers in the list of layers viewed by this camera are
 * given a chance to be picked.
 * </p></text>
      <return>true if any of the layers in the list of layers viewed by this
 * camera were picked</return>
    </javadoc>
    <method type="boolean" name="pickAfterChildren" startLine="491" endLine="503">
      <scope startLine="492" endLine="501">
        <scope startLine="495" endLine="497" />
      </scope>
    </method>
    <javadoc>
      <text>* Try to pick all of the layers in the list of layers viewed by this
 * camera. This method is called after the view transform has been applied
 * to the specified pick path.</text>
      <param>pickPath pick path</param>
      <return>true if any of the layers in the list of layers viewed by this
 * camera were picked</return>
    </javadoc>
    <method type="boolean" name="pickCameraView" startLine="514" endLine="523">
      <declaration type="int" name="size" />
      <scope startLine="516" endLine="521">
        <declaration type="PLayer" name="each" />
        <scope startLine="518" endLine="520" />
      </scope>
    </method>
    <javadoc>
      <text>* Return the bounds of this camera in the view coordinate system.</text>
      <return>the bounds of this camera in the view coordinate system</return>
    </javadoc>
    <method type="PBounds" name="getViewBounds" startLine="539" endLine="541" />
    <javadoc>
      <text>* Animates the camera's view so that the given bounds (in camera layer's
 * coordinate system) are centered within the cameras view bounds. Use this
 * method to point the camera at a given location.</text>
      <param>centerBounds the targetBounds</param>
    </javadoc>
    <method type="void" name="setViewBounds" startLine="550" endLine="552" />
    <javadoc>
      <text>* Return the scale applied by the view transform to the list of layers
 * viewed by this camera.</text>
      <return>the scale applied by the view transform to the list of layers
 * viewed by this camera</return>
    </javadoc>
    <method type="double" name="getViewScale" startLine="561" endLine="563" />
    <javadoc>
      <text>* Scale the view transform applied to the list of layers viewed by this
 * camera by <code>scale</code> about the point <code>[0, 0]</code>.</text>
      <param>scale view transform scale</param>
    </javadoc>
    <method type="void" name="scaleView" startLine="571" endLine="573" />
    <javadoc>
      <text>* Scale the view transform applied to the list of layers viewed by this
 * camera by <code>scale</code> about the specified point
 * <code>[x, y]</code>.</text>
      <param>scale view transform scale</param>
      <param>x scale about point, x coordinate</param>
      <param>y scale about point, y coordinate</param>
    </javadoc>
    <method type="void" name="scaleViewAboutPoint" startLine="584" endLine="589" />
    <javadoc>
      <text>* Set the scale applied by the view transform to the list of layers
 * viewed by this camera to <code>scale</code>.</text>
      <param>scale view transform scale</param>
    </javadoc>
    <method type="void" name="setViewScale" startLine="597" endLine="599" />
    <javadoc>
      <text>* Translate the view transform applied to the list of layers viewed by this
 * camera by <code>[dx, dy]</code>.</text>
      <param>dx translate delta x</param>
      <param>dy translate delta y</param>
    </javadoc>
    <method type="void" name="translateView" startLine="608" endLine="613" />
    <javadoc>
      <text>* Set the offset for the view transform applied to the list of layers
 * viewed by this camera to <code>[x, y]</code>.</text>
      <param>x offset x</param>
      <param>y offset y</param>
    </javadoc>
    <method type="void" name="setViewOffset" startLine="636" endLine="641" />
    <javadoc>
      <text>* Return a copy of the view transform applied to the list of layers
 * viewed by this camera.</text>
      <return>a copy of the view transform applied to the list of layers
 * viewed by this camera</return>
    </javadoc>
    <method type="PAffineTransform" name="getViewTransform" startLine="650" endLine="652" />
    <javadoc>
      <text>* Return a reference to the view transform applied to the list of layers
 * viewed by this camera.</text>
      <return>the view transform applied to the list of layers
 * viewed by this camera</return>
    </javadoc>
    <method type="PAffineTransform" name="getViewTransformReference" startLine="661" endLine="663" />
    <javadoc>
      <text>* Set the view transform applied to the list of layers
 * viewed by this camera to <code>viewTransform</code>.</text>
      <param>viewTransform  view transform applied to the list of layers
 * viewed by this camera</param>
    </javadoc>
    <method type="void" name="setViewTransform" startLine="672" endLine="677" />
    <javadoc>
      <text>* Animate the camera's view from its current transform when the activity
 * starts to a new transform that centers the given bounds in the camera
 * layer's coordinate system into the cameras view bounds. If the duration is
 * 0 then the view will be transformed immediately, and null will be
 * returned. Else a new PTransformActivity will get returned that is set to
 * animate the camera's view transform to the new bounds. If shouldScale is
 * true, then the camera will also scale its view so that the given bounds
 * fit fully within the cameras view bounds, else the camera will maintain
 * its original scale.</text>
      <param>centerBounds the bounds which the animation will pace at the
 * center of the view</param>
      <param>shouldScaleToFit whether the camera should scale the view while
 * animating to it</param>
      <param>duration how many milliseconds the animations should take</param>
      <return>the scheduled PTransformActivity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateViewToCenterBounds" startLine="699" endLine="714">
      <declaration type="PBounds" name="viewBounds" />
      <declaration type="PDimension" name="delta" />
      <declaration type="PAffineTransform" name="newTransform" />
      <scope startLine="705" endLine="711">
        <declaration type="double" name="s" />
        <scope startLine="708" endLine="710" />
      </scope>
    </method>
    <javadoc>
      <text>* Pan the camera's view from its current transform when the activity starts
 * to a new transform so that the view bounds will contain (if possible,
 * intersect if not possible) the new bounds in the camera layers coordinate
 * system. If the duration is 0 then the view will be transformed
 * immediately, and null will be returned. Else a new PTransformActivity
 * will get returned that is set to animate the camera's view transform to
 * the new bounds.</text>
      <param>panToBounds the bounds to which the view will animate to</param>
      <param>duration the duration of the animation given in milliseconds</param>
      <return>the scheduled PTransformActivity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateViewToPanToBounds" startLine="730" endLine="746">
      <declaration type="PBounds" name="viewBounds" />
      <declaration type="PDimension" name="delta" />
      <scope startLine="734" endLine="743">
        <scope startLine="735" endLine="737" />
        <scope startLine="738" endLine="742">
          <declaration type="AffineTransform" name="at" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Pan the camera's view from its current transform when the activity starts
 * to a new transform so that the view bounds will contain (if possible,
 * intersect if not possible) the new bounds in the camera layers coordinate
 * system. If the duration is 0 then the view will be transformed
 * immediately, and null will be returned. Else a new PTransformActivity
 * will get returned that is set to animate the camera's view transform to
 * the new bounds.</text>
      <deprecated>Renamed to animateViewToPanToBounds</deprecated>
      <param>includeBounds the bounds to which the view will animate to</param>
      <param>duration the duration of the animation given in milliseconds</param>
      <return>the scheduled PTransformActivity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateViewToIncludeBounds" startLine="764" endLine="766" />
    <javadoc>
      <text>* Animate the cameras view transform from its current value when the
 * activity starts to the new destination transform value.</text>
      <param>destination the transform to which the view should be transformed
 * into</param>
      <param>duration the duraiton in milliseconds the animation should take</param>
      <return>the scheduled PTransformActivity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateViewToTransform" startLine="778" endLine="805">
      <scope startLine="779" endLine="782" />
      <declaration type="PTransformActivity.Target[]" name="t" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="setTransform" startLine="786" endLine="788" />
      <javadoc>
        <text>* {@inheritDoc}</text>
      </javadoc>
      <method type="void" name="getSourceMatrix" startLine="791" endLine="793" />
      <declaration type="PTransformActivity" name="transformActivity" />
      <declaration type="PRoot" name="r" />
      <scope startLine="800" endLine="802" />
    </method>
    <javadoc>
      <text>* Return the constraint applied to the view. The view constraint will be one of {@link #VIEW_CONSTRAINT_NONE},{@link #VIEW_CONSTRAINT_CENTER}, or {@link #VIEW_CONSTRAINT_CENTER}. Defaults to {@link #VIEW_CONSTRAINT_NONE}.</text>
      <return>the view constraint being applied to the view</return>
    </javadoc>
    <method type="int" name="getViewConstraint" startLine="818" endLine="820" />
    <javadoc>
      <text>* Set the view constraint to apply to the view to <code>viewConstraint</code>. The view constraint must be one of{@link #VIEW_CONSTRAINT_NONE}, {@link #VIEW_CONSTRAINT_CENTER}, or {@link #VIEW_CONSTRAINT_CENTER}.</text>
      <param>viewConstraint constraint to apply to the view</param>
      <throws>IllegalArgumentException if <code>viewConstraint</code> is not one of {@link #VIEW_CONSTRAINT_NONE},{@link #VIEW_CONSTRAINT_CENTER}, or {@link #VIEW_CONSTRAINT_CENTER}</throws>
    </javadoc>
    <method type="void" name="setViewConstraint" startLine="830" endLine="838">
      <scope startLine="832" endLine="835" />
    </method>
    <javadoc>
      <text>* Transforms the view so that it conforms to the given constraint.</text>
    </javadoc>
    <method type="void" name="applyViewConstraints" startLine="843" endLine="855">
      <scope startLine="844" endLine="846" />
      <declaration type="PBounds" name="viewBounds" />
      <declaration type="PBounds" name="layerBounds" />
      <scope startLine="850" endLine="852" />
      <declaration type="PDimension" name="constraintDelta" />
    </method>
    <javadoc>
      <text>* Convert the point from the camera's view coordinate system to the
 * camera's local coordinate system. The given point is modified by this.</text>
      <param>viewPoint the point to transform to the local coordinate system
 * from the view's coordinate system</param>
      <return>the transformed point</return>
    </javadoc>
    <method type="Point2D" name="viewToLocal" startLine="874" endLine="876" />
    <javadoc>
      <text>* Convert the dimension from the camera's view coordinate system to the
 * camera's local coordinate system. The given dimension is modified by
 * this.</text>
      <param>viewDimension the dimension to transform from the view system to
 * the local coordinate system</param>
      <return>returns the transformed dimension</return>
    </javadoc>
    <method type="Dimension2D" name="viewToLocal" startLine="888" endLine="890" />
    <javadoc>
      <text>* Convert the rectangle from the camera's view coordinate system to the
 * camera's local coordinate system. The given rectangle is modified by this
 * method.</text>
      <param>viewRectangle the rectangle to transform from view to local
 * coordinate System</param>
      <return>the transformed rectangle</return>
    </javadoc>
    <method type="Rectangle2D" name="viewToLocal" startLine="901" endLine="903" />
    <javadoc>
      <text>* Convert the point from the camera's local coordinate system to the
 * camera's view coordinate system. The given point is modified by this
 * method.</text>
      <param>localPoint point to transform from local to view coordinate system</param>
      <return>the transformed point</return>
    </javadoc>
    <method type="Point2D" name="localToView" startLine="913" endLine="915" />
    <javadoc>
      <text>* Convert the dimension from the camera's local coordinate system to the
 * camera's view coordinate system. The given dimension is modified by this
 * method.</text>
      <param>localDimension the dimension to transform from local to view
 * coordinate systems</param>
      <return>the transformed dimension</return>
    </javadoc>
    <method type="Dimension2D" name="localToView" startLine="926" endLine="928" />
    <javadoc>
      <text>* Convert the rectangle from the camera's local coordinate system to the
 * camera's view coordinate system. The given rectangle is modified by this
 * method.</text>
      <param>localRectangle the rectangle to transform from local to view
 * coordinate system</param>
      <return>the transformed rectangle</return>
    </javadoc>
    <method type="Rectangle2D" name="localToView" startLine="939" endLine="941" />
    <javadoc>
      <text>* Write this camera and all its children out to the given stream. Note that
 * the cameras layers are written conditionally, so they will only get
 * written out if someone else writes them unconditionally.</text>
      <param>out the PObjectOutputStream to which this camera should be
 * serialized</param>
      <throws>IOException if an error occured writing to the output stream</throws>
    </javadoc>
    <method type="void" name="writeObject" startLine="959" endLine="972">
      <scope startLine="960" endLine="962" />
      <declaration type="int" name="count" />
      <scope startLine="966" endLine="968" />
    </method>
    <javadoc>
      <text>* Deserializes this PCamera from the ObjectInputStream.</text>
      <param>in the source ObjectInputStream</param>
      <throws>IOException when error occurs during read</throws>
      <throws>ClassNotFoundException if the stream attempts to deserialize a
 * missing class</throws>
    </javadoc>
    <method type="void" name="readObject" startLine="982" endLine="1000">
      <scope startLine="987" endLine="997">
        <declaration type="Object" name="each" />
        <scope startLine="989" endLine="996">
          <scope startLine="990" endLine="992" />
          <scope startLine="993" endLine="995" />
        </scope>
      </scope>
    </method>
    <comment>private transient List<PLayer> layers;</comment>
    <comment>****************************************************************</comment>
    <comment>View Transform - Methods for accessing the view transform. The</comment>
    <comment>view transform is applied before painting and picking the cameras</comment>
    <comment>layers. But not before painting or picking its direct children.</comment>
    <comment />
    <comment>Changing the view transform is how zooming and panning are</comment>
    <comment>accomplished.</comment>
    <comment>****************************************************************</comment>
    <javadoc>
      <text>* Offset the view transform applied to the list of layers viewed by this camera by <code>[dx, dy]</code>. This is
 * NOT effected by the view transform's current scale or rotation. This is implemented by directly adding dx to the
 * m02 position and dy to the m12 position in the affine transform.</text>
      <param>dx offset delta x</param>
      <param>dy offset delta y</param>
    </javadoc>
    <comment>public void offsetView(final double dx, final double dy) {
setViewOffset(viewTransform.getTranslateX() + dx, viewTransform.getTranslateY() + dy);
}</comment>
    <comment>****************************************************************</comment>
    <comment>View Transform Constraints - Methods for setting and applying</comment>
    <comment>constraints to the view transform.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Camera View Coord System Conversions - Methods to translate from</comment>
    <comment>the camera's local coord system (above the camera's view transform) to</comment>
    <comment>the</comment>
    <comment>camera view coord system (below the camera's view transform). When</comment>
    <comment>converting geometry from one of the canvas's layers you must go</comment>
    <comment>through the view transform.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Serialization - Cameras conditionally serialize their layers.</comment>
    <comment>This means that only the layer references that were unconditionally</comment>
    <comment>(using writeObject) serialized by someone else will be restored</comment>
    <comment>when the camera is unserialized.</comment>
    <comment>****************************************************************/</comment>
  </class>
</source>
