<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolo.activities">
  <import name="java.awt.geom.AffineTransform" />
  <import name="edu.umd.cs.piccolo.util.PAffineTransform" />
  <class name="PTransformActivity" extends="PInterpolatingActivity" startLine="35">
    <javadoc>
      <text>* <b>PTransformActivity</b> interpolates between two transforms setting its
 * target's transform as it goes. See PNode. animate*() for an example of this
 * activity in used. The source transform is retrieved from the target just
 * before the animation is scheduled to start.
 * <P></text>
      <version>1.0</version>
      <author>Jesse Grosjean</author>
    </javadoc>
    <declaration type="PAffineTransform" name="STATIC_TRANSFORM" />
    <declaration type="double[]" name="source" />
    <declaration type="double[]" name="destination" />
    <declaration type="Target" name="target" />
    <interface name="Target" startLine="52">
      <javadoc>
        <text>* <b>Target</b> Objects that want to get transformed by the transform
 * activity must implement this interface. See PNode.animateToTransform()
 * for one way to do this.</text>
      </javadoc>
      <method name="setTransform" type="void" startLine="59" endLine="65" />
      <javadoc>
        <text>* This will be called by the transform activity for each new transform
 * that it computes while it is stepping.</text>
        <param>aTransform the transform to be applied to the target.</param>
      </javadoc>
      <method name="getSourceMatrix" type="void" startLine="67" endLine="73" />
      <javadoc>
        <text>* This method is called right before the transform activity starts.
 * That way an object is always animated from its current position.</text>
        <param>aSource array to be populated with the target's gurrent matrix</param>
      </javadoc>
      <javadoc>
        <text>* Constructs a transform activity that will last for the specified
 * duration, will update at the given step rate and will be applied to the
 * target.
 * Requires that the developer follow up with a setDestinationTransform
 * call, otherwise the transition is undefined.</text>
        <param>duration duration in milliseconds of the entire activity</param>
        <param>stepRate interval in milliseconds between successive animation
 * steps</param>
        <param>target the target of the activity</param>
      </javadoc>
      <method type="constructor" name="PTransformActivity" startLine="89" endLine="91" />
      <javadoc>
        <text>* Constructs a activity that will change the target's transform in the
 * destination transform. It will last for the specified duration, will
 * update at the given step rate.</text>
        <param>duration duration in milliseconds of the entire activity</param>
        <param>stepRate interval in milliseconds between successive animation
 * steps</param>
        <param>target the target of the activity</param>
        <param>destination transform that the target will be after the ativity is
 * finished</param>
      </javadoc>
      <method type="constructor" name="PTransformActivity" startLine="107" endLine="109" />
      <javadoc>
        <text>* Create a new PTransformActivity.
 * <P></text>
        <param>duration the length of one loop of the activity</param>
        <param>stepRate the amount of time between steps of the activity</param>
        <param>loopCount number of times the activity should reschedule itself</param>
        <param>mode defines how the activity interpolates between states</param>
        <param>target the object that the activity will be applied to and where
 * the source state will be taken from.</param>
        <param>destination the destination color state</param>
      </javadoc>
      <method type="constructor" name="PTransformActivity" startLine="124" endLine="132">
        <scope startLine="129" endLine="131" />
      </method>
      <javadoc>
        <text>* Whether each step invalidates paint.</text>
        <return>true since a node transform affects it's node's display</return>
      </javadoc>
      <method type="boolean" name="isAnimation" startLine="139" endLine="141" />
      <javadoc>
        <text>* Return the final transform that will be set on the transform activities
 * target when the transform activity stops stepping.</text>
        <return>returns the final transform as an array of doubles</return>
      </javadoc>
      <method type="double[]" name="getDestinationTransform" startLine="149" endLine="156">
        <scope startLine="150" endLine="152" />
        <scope startLine="153" endLine="155" />
      </method>
      <javadoc>
        <text>* Set the final transform that will be set on the transform activities
 * target when the transform activity stops stepping.</text>
        <param>newDestination an array of doubles representing the destination
 * transform</param>
      </javadoc>
      <method type="void" name="setDestinationTransform" startLine="165" endLine="172">
        <scope startLine="166" endLine="168" />
        <scope startLine="169" endLine="171" />
      </method>
      <javadoc>
        <text>* Is invoked when the activity is started. Ensures that setTransform is
 * called on the target even before the first step.</text>
      </javadoc>
      <method type="void" name="activityStarted" startLine="178" endLine="183">
        <scope startLine="179" endLine="181" />
      </method>
      <javadoc>
        <text>* Set's the target value to be the interpolation between the source and
 * destination transforms.
 * A value of 0 for zeroToOne means that the target should have the source
 * transform. A value of 1 for zeroToOne means that the target should have
 * the destination transform.</text>
        <param>zeroToOne how far along the activity has progressed. 0 = not at
 * all, 1 = completed</param>
      </javadoc>
      <method type="void" name="setRelativeTargetValue" startLine="196" endLine="205" />
    </interface>
  </class>
</source>
