<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolo.util">
  <import name="java.awt.geom.Dimension2D" />
  <import name="java.awt.geom.Point2D" />
  <import name="java.awt.geom.Rectangle2D" />
  <import name="java.util.HashMap" />
  <import name="javax.swing.event.EventListenerList" />
  <import name="edu.umd.cs.piccolo.PCamera" />
  <import name="edu.umd.cs.piccolo.PNode" />
  <import name="edu.umd.cs.piccolo.event.PInputEvent" />
  <import name="edu.umd.cs.piccolo.event.PInputEventListener" />
  <class name="PPickPath" startLine="43">
    <implements name="PInputEventListener" />
    <javadoc>
      <text>* <b>PPickPath</b> represents a ordered list of nodes that have been picked.
 * The topmost ancestor node is the first node in the list (and should be a
 * camera), the bottommost child node is at the end of the list. It is this
 * bottom node that is given first chance to handle events, and that any active
 * event handlers usually manipulate.
 * <p>
 * Note that because of layers (which can be picked by multiple camera's) the
 * ordered list of nodes in a pick path do not all share a parent child
 * relationship with the nodes in the list next to them. This means that the
 * normal localToGlobal methods don't work when trying to transform geometry up
 * and down the pick path, instead you should use the pick paths canvasToLocal
 * methods to get the mouse event points into your local coord system.
 * <p>
 * Note that PInputEvent wraps most of the useful PPickPath methods, so often
 * you can use a PInputEvent directly instead of having to access its pick path.
 * <p></text>
      <see>edu.umd.cs.piccolo.event.PInputEvent</see>
      <version>1.0</version>
      <author>Jesse Grosjean</author>
    </javadoc>
    <javadoc>
      <text>* Global pick path.</text>
    </javadoc>
    <declaration type="PPickPath" name="CURRENT_PICK_PATH" />
    <javadoc>
      <text>* Used when calculating the scale.</text>
    </javadoc>
    <declaration type="double[]" name="PTS" />
    <javadoc>
      <text>* Stack of nodes representing all picked nodes.</text>
    </javadoc>
    <declaration type="PStack" name="nodeStack" />
    <declaration type="PCamera" name="topCamera" />
    <declaration type="PStack" name="transformStack" />
    <declaration type="PStack" name="pickBoundsStack" />
    <declaration type="PCamera" name="bottomCamera" />
    <declaration type="HashMap" name="excludedNodes" />
    <javadoc>
      <text>* Creates a pick pack originating from the provided camera and with the
 * given screen pick bounds.</text>
      <param>camera camera from which the pickpath originates</param>
      <param>aScreenPickBounds bounds of pick area</param>
    </javadoc>
    <method type="constructor" name="PPickPath" startLine="88" endLine="97" />
    <javadoc>
      <text>* Returns the bounds of the entire PickPath taken as a whole.</text>
      <return>bounds of the entire PickPath</return>
    </javadoc>
    <method type="PBounds" name="getPickBounds" startLine="104" endLine="106" />
    <javadoc>
      <text>* Determines if the passed node has been excluded from being a member of
 * the pickpath.</text>
      <param>node node being tested</param>
      <return>true if node is acceptable to the path</return>
    </javadoc>
    <method type="boolean" name="acceptsNode" startLine="115" endLine="117" />
    <javadoc>
      <text>* Pushes the provided node to the top of the pick path.</text>
      <param>node node to be added to the pick path</param>
    </javadoc>
    <method type="void" name="pushNode" startLine="128" endLine="130" />
    <javadoc>
      <text>* Removes the topmost node from the node stack.</text>
      <param>node completely unused in this method, but is passed in so that
 * subclasses may be informed of it.</param>
    </javadoc>
    <method type="void" name="popNode" startLine="138" endLine="140" />
    <javadoc>
      <text>* Get the bottom node on the pick path node stack. That is the last node to
 * be picked.</text>
      <return>the bottom node on the pick path</return>
    </javadoc>
    <method type="PNode" name="getPickedNode" startLine="148" endLine="150" />
    <javadoc>
      <text>* Return the next node that will be picked after the current picked node.
 * For instance of you have two overlapping children nodes then the topmost
 * child will always be picked first, use this method to find the covered
 * child. Return the camera when no more visual will be picked.</text>
      <return>next node to picked after the picked node</return>
    </javadoc>
    <method type="PNode" name="nextPickedNode" startLine="164" endLine="197">
      <declaration type="PNode" name="picked" />
      <scope startLine="167" endLine="169" />
      <scope startLine="170" endLine="172" />
      <declaration type="Object" name="screenPickBounds" />
      <scope startLine="191" endLine="194" />
      <comment>exclude current picked node</comment>
      <comment>reset path state</comment>
      <comment>pick again</comment>
      <comment>make sure top camera is pushed.</comment>
    </method>
    <javadoc>
      <text>* Get the top camera on the pick path. This is the camera that originated
 * the pick action.</text>
      <return>the topmost camera of this pick pack</return>
    </javadoc>
    <method type="PCamera" name="getTopCamera" startLine="205" endLine="207" />
    <javadoc>
      <text>* Get the bottom camera on the pick path. This may be different then the
 * top camera if internal cameras are in use.</text>
      <return>the camera closest to the picked node</return>
    </javadoc>
    <method type="PCamera" name="getBottomCamera" startLine="215" endLine="220">
      <scope startLine="216" endLine="218" />
    </method>
    <method type="PCamera" name="calculateBottomCamera" startLine="222" endLine="230">
      <scope startLine="223" endLine="228">
        <declaration type="PNode" name="each" />
        <scope startLine="225" endLine="227" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns a reference to the node stack. Be Careful!</text>
      <return>the node stack</return>
    </javadoc>
    <method type="PStack" name="getNodeStackReference" startLine="237" endLine="239" />
    <javadoc>
      <text>* Returns the resulting scale of applying the transforms of the entire pick
 * path. In essence it gives you the scale at which interaction is
 * occurring.</text>
      <return>scale at which interaction is occurring.</return>
    </javadoc>
    <method type="double" name="getScale" startLine="252" endLine="268">
      <declaration type="int" name="count" />
      <scope startLine="260" endLine="265">
        <declaration type="PAffineTransform" name="each" />
        <scope startLine="262" endLine="264" />
      </scope>
      <comment>x1, y1, x2, y3</comment>
    </method>
    <javadoc>
      <text>* Adds the transform to the pick path's transform. This is used when
 * determining the context of the current interaction.</text>
      <param>transform transform to be added to applied to the pickpath.</param>
    </javadoc>
    <method type="void" name="pushTransform" startLine="276" endLine="283">
      <scope startLine="278" endLine="282">
        <declaration type="Rectangle2D" name="newPickBounds" />
      </scope>
    </method>
    <javadoc>
      <text>* Pops the top most transform from the pick path.</text>
      <param>transform unused in this method</param>
    </javadoc>
    <method type="void" name="popTransform" startLine="290" endLine="295">
      <scope startLine="292" endLine="294" />
    </method>
    <javadoc>
      <text>* Calculates the context at which the given node is being interacted with.</text>
      <param>nodeOnPath a node currently on the pick path. An exception will be
 * thrown if the node cannot be found.</param>
      <return>Transform at which the given node is being interacted with.</return>
    </javadoc>
    <method type="PAffineTransform" name="getPathTransformTo" startLine="305" endLine="320">
      <declaration type="PAffineTransform" name="aTransform" />
      <declaration type="int" name="count" />
      <scope startLine="309" endLine="317">
        <declaration type="PTuple" name="each" />
        <scope startLine="311" endLine="313" />
        <scope startLine="314" endLine="316" />
      </scope>
    </method>
    <javadoc>
      <text>* Process Events - Give each node in the pick path, starting at the bottom
 * most one, a chance to handle the event.</text>
      <param>event event to be processed</param>
      <param>eventType the type of event being processed</param>
    </javadoc>
    <method type="void" name="processEvent" startLine="329" endLine="349">
      <scope startLine="332" endLine="348">
        <declaration type="PNode" name="each" />
        <declaration type="EventListenerList" name="list" />
        <scope startLine="337" endLine="347">
          <declaration type="Object[]" name="listeners" />
          <scope startLine="340" endLine="346">
            <declaration type="PInputEventListener" name="listener" />
            <scope startLine="343" endLine="345" />
          </scope>
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Convert the given point from the canvas coordinates, down through the
 * pick path (and through any camera view transforms applied to the path) to
 * the local coordinates of the given node.</text>
      <param>canvasPoint point to be transformed</param>
      <param>nodeOnPath node into which the point is to be transformed
 * iteratively through the pick path</param>
      <return>transformed canvasPoint in local coordinates of the picked node</return>
    </javadoc>
    <method type="Point2D" name="canvasToLocal" startLine="375" endLine="377" />
    <javadoc>
      <text>* Convert the given dimension from the canvas coordinates, down through the
 * pick path (and through any camera view transforms applied to the path) to
 * the local coordinates of the given node.</text>
      <param>canvasDimension dimension to be transformed</param>
      <param>nodeOnPath node into which the dimension is to be transformed
 * iteratively through the stack</param>
      <return>transformed canvasDimension in local coordinates of the picked
 * node</return>
    </javadoc>
    <method type="Dimension2D" name="canvasToLocal" startLine="391" endLine="393" />
    <javadoc>
      <text>* Convert the given rectangle from the canvas coordinates, down through the
 * pick path (and through any camera view transforms applied to the path) to
 * the local coordinates of the given node.</text>
      <param>canvasRectangle rectangle to be transformed</param>
      <param>nodeOnPath node into which the rectangle is to be transformed
 * iteratively through the stack</param>
      <return>transformed canvasRectangle in local coordinates of the picked
 * node</return>
    </javadoc>
    <method type="Rectangle2D" name="canvasToLocal" startLine="406" endLine="408" />
    <class name="PTuple" startLine="410">
      <javadoc>
        <text>* Used to associated nodes with their transforms on the transform stack.</text>
      </javadoc>
      <declaration type="PNode" name="node" />
      <declaration type="PAffineTransform" name="transform" />
      <method type="constructor" name="PTuple" startLine="417" endLine="420" />
    </class>
    <comment>****************************************************************</comment>
    <comment>Picked Nodes</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Iterating over picked nodes.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Path Transform</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Transforming Geometry - Methods to transform geometry through</comment>
    <comment>this path.</comment>
    <comment><p></comment>
    <comment>Note that this is different that just using the</comment>
    <comment>PNode.localToGlobal (an other coord system transform methods).</comment>
    <comment>The PNode coord system transform methods always go directly up</comment>
    <comment>through their parents. The PPickPath coord system transform</comment>
    <comment>methods go up through the list of picked nodes instead. And since</comment>
    <comment>cameras can pick their layers in addition to their children these</comment>
    <comment>two paths may be different.</comment>
    <comment>****************************************************************</comment>
  </class>
</source>
