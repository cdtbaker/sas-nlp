<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolo">
  <import name="java.awt.Color" />
  <import name="java.awt.Graphics" />
  <import name="java.awt.Graphics2D" />
  <import name="java.awt.GraphicsConfiguration" />
  <import name="java.awt.GraphicsEnvironment" />
  <import name="java.awt.Image" />
  <import name="java.awt.Paint" />
  <import name="java.awt.Transparency" />
  <import name="java.awt.geom.AffineTransform" />
  <import name="java.awt.geom.Dimension2D" />
  <import name="java.awt.geom.NoninvertibleTransformException" />
  <import name="java.awt.geom.Point2D" />
  <import name="java.awt.geom.Rectangle2D" />
  <import name="java.awt.image.BufferedImage" />
  <import name="java.awt.print.Book" />
  <import name="java.awt.print.PageFormat" />
  <import name="java.awt.print.Printable" />
  <import name="java.awt.print.PrinterException" />
  <import name="java.awt.print.PrinterJob" />
  <import name="java.beans.PropertyChangeEvent" />
  <import name="java.beans.PropertyChangeListener" />
  <import name="java.io.ByteArrayInputStream" />
  <import name="java.io.IOException" />
  <import name="java.io.ObjectInputStream" />
  <import name="java.io.ObjectOutputStream" />
  <import name="java.io.Serializable" />
  <import name="java.util.ArrayList" />
  <import name="java.util.Collection" />
  <import name="java.util.Collections" />
  <import name="java.util.Enumeration" />
  <import name="java.util.EventListener" />
  <import name="java.util.Iterator" />
  <import name="java.util.List" />
  <import name="java.util.ListIterator" />
  <import name="javax.swing.event.EventListenerList" />
  <import name="javax.swing.event.SwingPropertyChangeSupport" />
  <import name="javax.swing.text.MutableAttributeSet" />
  <import name="javax.swing.text.SimpleAttributeSet" />
  <import name="edu.umd.cs.piccolo.activities.PActivity" />
  <import name="edu.umd.cs.piccolo.activities.PColorActivity" />
  <import name="edu.umd.cs.piccolo.activities.PInterpolatingActivity" />
  <import name="edu.umd.cs.piccolo.activities.PTransformActivity" />
  <import name="edu.umd.cs.piccolo.event.PInputEventListener" />
  <import name="edu.umd.cs.piccolo.util.PAffineTransform" />
  <import name="edu.umd.cs.piccolo.util.PAffineTransformException" />
  <import name="edu.umd.cs.piccolo.util.PBounds" />
  <import name="edu.umd.cs.piccolo.util.PNodeFilter" />
  <import name="edu.umd.cs.piccolo.util.PObjectOutputStream" />
  <import name="edu.umd.cs.piccolo.util.PPaintContext" />
  <import name="edu.umd.cs.piccolo.util.PPickPath" />
  <import name="edu.umd.cs.piccolo.util.PUtil" />
  <class name="PNode" startLine="85">
    <implements name="Cloneable" />
    <implements name="Serializable" />
    <implements name="Printable" />
    <javadoc>
      <text>* <b>PNode</b> is the central abstraction in Piccolo. All objects that are
 * visible on the screen are instances of the node class. All nodes may have
 * other "child" nodes added to them.
 * <p>
 * See edu.umd.piccolo.examples.NodeExample.java for demonstrations of how nodes
 * can be used and how new types of nodes can be created.
 * <P></text>
      <version>1.0</version>
      <author>Jesse Grosjean</author>
    </javadoc>
    <javadoc>
      <text>* The minimum difference in transparency required before the transparency
 * is allowed to change. Done for efficiency reasons. I doubt very much that
 * the human eye could tell the difference between 0.01 and 0.02
 * transparency.</text>
    </javadoc>
    <declaration type="float" name="TRANSPARENCY_RESOLUTION" />
    <javadoc>
      <text>* Allows for future serialization code to understand versioned binary
 * formats.</text>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* The property name that identifies a change in this node's client
 * propertie (see {@link #getClientProperty getClientProperty}). In an
 * property change event the new value will be a reference to the map of
 * client properties but old value will always be null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_CLIENT_PROPERTIES" />
    <javadoc>
      <text>* The property code that identifies a change in this node's client
 * propertie (see {@link #getClientProperty getClientProperty}). In an
 * property change event the new value will be a reference to the map of
 * client properties but old value will always be null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_CLIENT_PROPERTIES" />
    <javadoc>
      <text>* The property name that identifies a change of this node's bounds (see{@link #getBounds getBounds}, {@link #getBoundsReferencegetBoundsReference}). In any property change event the new value will be
 * a reference to this node's bounds, but old value will always be null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_BOUNDS" />
    <javadoc>
      <text>* The property code that identifies a change of this node's bounds (see{@link #getBounds getBounds}, {@link #getBoundsReferencegetBoundsReference}). In any property change event the new value will be
 * a reference to this node's bounds, but old value will always be null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_BOUNDS" />
    <javadoc>
      <text>* The property name that identifies a change of this node's full bounds
 * (see {@link #getFullBounds getFullBounds},{@link #getFullBoundsReference getFullBoundsReference}). In any property
 * change event the new value will be a reference to this node's full bounds
 * cache, but old value will always be null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_FULL_BOUNDS" />
    <javadoc>
      <text>* The property code that identifies a change of this node's full bounds
 * (see {@link #getFullBounds getFullBounds},{@link #getFullBoundsReference getFullBoundsReference}). In any property
 * change event the new value will be a reference to this node's full bounds
 * cache, but old value will always be null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_FULL_BOUNDS" />
    <javadoc>
      <text>* The property name that identifies a change of this node's transform (see{@link #getTransform getTransform}, {@link #getTransformReferencegetTransformReference}). In any property change event the new value will
 * be a reference to this node's transform, but old value will always be
 * null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_TRANSFORM" />
    <javadoc>
      <text>* The property code that identifies a change of this node's transform (see{@link #getTransform getTransform}, {@link #getTransformReferencegetTransformReference}). In any property change event the new value will
 * be a reference to this node's transform, but old value will always be
 * null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_TRANSFORM" />
    <javadoc>
      <text>* The property name that identifies a change of this node's visibility (see{@link #getVisible getVisible}). Both old value and new value will be
 * null in any property change event.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_VISIBLE" />
    <javadoc>
      <text>* The property code that identifies a change of this node's visibility (see{@link #getVisible getVisible}). Both old value and new value will be
 * null in any property change event.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_VISIBLE" />
    <javadoc>
      <text>* The property name that identifies a change of this node's paint (see{@link #getPaint getPaint}). Both old value and new value will be set
 * correctly in any property change event.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_PAINT" />
    <javadoc>
      <text>* The property code that identifies a change of this node's paint (see{@link #getPaint getPaint}). Both old value and new value will be set
 * correctly in any property change event.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_PAINT" />
    <javadoc>
      <text>* The property name that identifies a change of this node's transparency
 * (see {@link #getTransparency getTransparency}). Both old value and new
 * value will be null in any property change event.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_TRANSPARENCY" />
    <javadoc>
      <text>* The property code that identifies a change of this node's transparency
 * (see {@link #getTransparency getTransparency}). Both old value and new
 * value will be null in any property change event.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_TRANSPARENCY" />
    <javadoc>
      <text>* The property name that identifies a change of this node's pickable status
 * (see {@link #getPickable getPickable}). Both old value and new value will
 * be null in any property change event.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_PICKABLE" />
    <javadoc>
      <text>* The property code that identifies a change of this node's pickable status
 * (see {@link #getPickable getPickable}). Both old value and new value will
 * be null in any property change event.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_PICKABLE" />
    <javadoc>
      <text>* The property name that identifies a change of this node's children
 * pickable status (see {@link #getChildrenPickable getChildrenPickable}).
 * Both old value and new value will be null in any property change event.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_CHILDREN_PICKABLE" />
    <javadoc>
      <text>* The property code that identifies a change of this node's children
 * pickable status (see {@link #getChildrenPickable getChildrenPickable}).
 * Both old value and new value will be null in any property change event.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_CHILDREN_PICKABLE" />
    <javadoc>
      <text>* The property name that identifies a change in the set of this node's
 * direct children (see {@link #getChildrenReference getChildrenReference},{@link #getChildrenIterator getChildrenIterator}). In any property change
 * event the new value will be a reference to this node's children, but old
 * value will always be null.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_CHILDREN" />
    <javadoc>
      <text>* The property code that identifies a change in the set of this node's
 * direct children (see {@link #getChildrenReference getChildrenReference},{@link #getChildrenIterator getChildrenIterator}). In any property change
 * event the new value will be a reference to this node's children, but old
 * value will always be null.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_CHILDREN" />
    <javadoc>
      <text>* The property name that identifies a change of this node's parent (see{@link #getParent getParent}). Both old value and new value will be set
 * correctly in any property change event.</text>
    </javadoc>
    <declaration type="String" name="PROPERTY_PARENT" />
    <javadoc>
      <text>* The property code that identifies a change of this node's parent (see{@link #getParent getParent}). Both old value and new value will be set
 * correctly in any property change event.</text>
    </javadoc>
    <declaration type="int" name="PROPERTY_CODE_PARENT" />
    <javadoc>
      <text>* Is an optimization for use during repaints.</text>
    </javadoc>
    <declaration type="PBounds" name="TEMP_REPAINT_BOUNDS" />
    <javadoc>
      <text>* The single scene graph delegate that receives low level node events.</text>
    </javadoc>
    <declaration type="PSceneGraphDelegate" name="SCENE_GRAPH_DELEGATE" />
    <javadoc>
      <text>* Tracks the parent of this node, may be null.</text>
    </javadoc>
    <declaration type="PNode" name="parent" />
    <javadoc>
      <text>* Tracks all immediate child nodes.</text>
    </javadoc>
    <declaration type="List" name="children" />
    <javadoc>
      <text>* Bounds of the PNode.</text>
    </javadoc>
    <declaration type="PBounds" name="bounds" />
    <javadoc>
      <text>* Transform that applies to this node in relation to its parent.</text>
    </javadoc>
    <declaration type="PAffineTransform" name="transform" />
    <javadoc>
      <text>* The paint to use for the background of this node.</text>
    </javadoc>
    <declaration type="Paint" name="paint" />
    <javadoc>
      <text>* How Opaque this node should be 1f = fully opaque, 0f = completely
 * transparent.</text>
    </javadoc>
    <declaration type="float" name="transparency" />
    <javadoc>
      <text>* A modifiable set of client properties.</text>
    </javadoc>
    <declaration type="MutableAttributeSet" name="clientProperties" />
    <javadoc>
      <text>* An optimization that remembers the full bounds of a node rather than
 * computing it every time.</text>
    </javadoc>
    <declaration type="PBounds" name="fullBoundsCache" />
    <javadoc>
      <text>* Mask used when deciding whether to bubble up property change events to
 * parents.</text>
    </javadoc>
    <declaration type="int" name="propertyChangeParentMask" />
    <javadoc>
      <text>* Used to handle property change listeners.</text>
    </javadoc>
    <declaration type="SwingPropertyChangeSupport" name="changeSupport" />
    <javadoc>
      <text>* List of event listeners.</text>
    </javadoc>
    <declaration type="EventListenerList" name="listenerList" />
    <javadoc>
      <text>* Whether this node is pickable or not.</text>
    </javadoc>
    <declaration type="boolean" name="pickable" />
    <javadoc>
      <text>* Whether to stop processing pick at this node and not bother drilling down
 * into children.</text>
    </javadoc>
    <declaration type="boolean" name="childrenPickable" />
    <javadoc>
      <text>* Whether this node will be rendered.</text>
    </javadoc>
    <declaration type="boolean" name="visible" />
    <declaration type="boolean" name="childBoundsVolatile" />
    <javadoc>
      <text>* Whether this node needs to be repainted.</text>
    </javadoc>
    <declaration type="boolean" name="paintInvalid" />
    <javadoc>
      <text>* Whether children need to be repainted.</text>
    </javadoc>
    <declaration type="boolean" name="childPaintInvalid" />
    <javadoc>
      <text>* Whether this node's bounds have changed, and so needs to be relaid out.</text>
    </javadoc>
    <declaration type="boolean" name="boundsChanged" />
    <javadoc>
      <text>* Whether this node's full bounds need to be recomputed.</text>
    </javadoc>
    <declaration type="boolean" name="fullBoundsInvalid" />
    <javadoc>
      <text>* Whether this node's child bounds need to be recomputed.</text>
    </javadoc>
    <declaration type="boolean" name="childBoundsInvalid" />
    <declaration type="boolean" name="occluded" />
    <javadoc>
      <text>* Stores the name associated to this node.</text>
    </javadoc>
    <declaration type="String" name="name" />
    <javadoc>
      <text>* toImage fill strategy that stretches the node be as large as possible
 * while still retaining its aspect ratio.</text>
      <since>1.3</since>
    </javadoc>
    <declaration type="int" name="FILL_STRATEGY_ASPECT_FIT" />
    <javadoc>
      <text>* toImage fill strategy that stretches the node be large enough to cover
 * the image, and centers it.</text>
      <since>1.3</since>
    </javadoc>
    <declaration type="int" name="FILL_STRATEGY_ASPECT_COVER" />
    <javadoc>
      <text>* toImage fill strategy that stretches the node to be exactly the
 * dimensions of the image. Will result in distortion if the aspect ratios
 * are different.</text>
      <since>1.3</since>
    </javadoc>
    <declaration type="int" name="FILL_STRATEGY_EXACT_FIT" />
    <javadoc>
      <text>* Creates a new PNode with the given name.</text>
      <since>1.3</since>
      <param>newName name to assign to node</param>
    </javadoc>
    <method type="constructor" name="PNode" startLine="394" endLine="397" />
    <javadoc>
      <text>* Constructs a new PNode.
 * <P>
 * By default a node's paint is null, and bounds are empty. These values
 * must be set for the node to show up on the screen once it's added to a
 * scene graph.</text>
    </javadoc>
    <method type="constructor" name="PNode" startLine="406" endLine="413" />
    <javadoc>
      <text>* Animate this node's bounds from their current location when the activity
 * starts to the specified bounds. If this node descends from the root then
 * the activity will be scheduled, else the returned activity should be
 * scheduled manually. If two different transform activities are scheduled
 * for the same node at the same time, they will both be applied to the
 * node, but the last one scheduled will be applied last on each frame, so
 * it will appear to have replaced the original. Generally you will not want
 * to do that. Note this method animates the node's bounds, but does not
 * change the node's transform. Use animateTransformToBounds() to animate
 * the node's transform instead.</text>
      <param>x left of target bounds</param>
      <param>y top of target bounds</param>
      <param>width width of target bounds</param>
      <param>height height of target bounds</param>
      <param>duration amount of time that the animation should take</param>
      <return>the newly scheduled activity</return>
    </javadoc>
    <method type="PInterpolatingActivity" name="animateToBounds" startLine="448" endLine="480">
      <scope startLine="449" endLine="452" />
      <declaration type="PBounds" name="dst" />
      <declaration type="PInterpolatingActivity" name="interpolatingActivity" />
      <declaration type="PBounds" name="src" />
      <method type="void" name="activityStarted" startLine="460" endLine="464" />
      <method type="void" name="setRelativeTargetValue" startLine="466" endLine="470" />
      <method type="void" name="activityFinished" startLine="472" endLine="475" />
    </method>
    <javadoc>
      <text>* Animate this node from it's current transform when the activity starts a
 * new transform that will fit the node into the given bounds. If this node
 * descends from the root then the activity will be scheduled, else the
 * returned activity should be scheduled manually. If two different
 * transform activities are scheduled for the same node at the same time,
 * they will both be applied to the node, but the last one scheduled will be
 * applied last on each frame, so it will appear to have replaced the
 * original. Generally you will not want to do that. Note this method
 * animates the node's transform, but does not directly change the node's
 * bounds rectangle. Use animateToBounds() to animate the node's bounds
 * rectangle instead.</text>
      <param>x left of target bounds</param>
      <param>y top of target bounds</param>
      <param>width width of target bounds</param>
      <param>height height of target bounds</param>
      <param>duration amount of time that the animation should take</param>
      <return>the newly scheduled activity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateTransformToBounds" startLine="503" endLine="509">
      <declaration type="PAffineTransform" name="t" />
      <declaration type="double" name="scale" />
    </method>
    <javadoc>
      <text>* Animate this node's transform from its current location when the activity
 * starts to the specified location, scale, and rotation. If this node
 * descends from the root then the activity will be scheduled, else the
 * returned activity should be scheduled manually. If two different
 * transform activities are scheduled for the same node at the same time,
 * they will both be applied to the node, but the last one scheduled will be
 * applied last on each frame, so it will appear to have replaced the
 * original. Generally you will not want to do that.</text>
      <param>x the final target x position of node</param>
      <param>y the final target y position of node</param>
      <param>duration amount of time that the animation should take</param>
      <param>scale the final scale for the duration</param>
      <param>theta final theta value (in radians) for the animation</param>
      <return>the newly scheduled activity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateToPositionScaleRotation" startLine="529" endLine="535">
      <declaration type="PAffineTransform" name="t" />
    </method>
    <javadoc>
      <text>* Animate this node's transform from its current values when the activity
 * starts to the new values specified in the given transform. If this node
 * descends from the root then the activity will be scheduled, else the
 * returned activity should be scheduled manually. If two different
 * transform activities are scheduled for the same node at the same time,
 * they will both be applied to the node, but the last one scheduled will be
 * applied last on each frame, so it will appear to have replaced the
 * original. Generally you will not want to do that.</text>
      <param>destTransform the final transform value</param>
      <param>duration amount of time that the animation should take</param>
      <return>the newly scheduled activity</return>
    </javadoc>
    <method type="PTransformActivity" name="animateToTransform" startLine="551" endLine="572">
      <scope startLine="552" endLine="555" />
      <scope startLine="556" endLine="571">
        <declaration type="PTransformActivity.Target[]" name="t" />
        <method type="void" name="setTransform" startLine="558" endLine="560" />
        <method type="void" name="getSourceMatrix" startLine="562" endLine="564" />
        <declaration type="PTransformActivity" name="ta" />
      </scope>
    </method>
    <javadoc>
      <text>* Animate this node's color from its current value to the new value
 * specified. This meathod assumes that this nodes paint property is of type
 * color. If this node descends from the root then the activity will be
 * scheduled, else the returned activity should be scheduled manually. If
 * two different color activities are scheduled for the same node at the
 * same time, they will both be applied to the node, but the last one
 * scheduled will be applied last on each frame, so it will appear to have
 * replaced the original. Generally you will not want to do that.</text>
      <param>destColor final color value.</param>
      <param>duration amount of time that the animation should take</param>
      <return>the newly scheduled activity</return>
    </javadoc>
    <method type="PInterpolatingActivity" name="animateToColor" startLine="588" endLine="608">
      <scope startLine="589" endLine="592" />
      <scope startLine="593" endLine="607">
        <declaration type="PColorActivity.Target" name="t" />
        <method type="Color" name="getColor" startLine="595" endLine="597" />
        <method type="void" name="setColor" startLine="599" endLine="601" />
        <declaration type="PColorActivity" name="ca" />
      </scope>
    </method>
    <javadoc>
      <text>* Animate this node's transparency from its current value to the new value
 * specified. Transparency values must range from zero to one. If this node
 * descends from the root then the activity will be scheduled, else the
 * returned activity should be scheduled manually. If two different
 * transparency activities are scheduled for the same node at the same time,
 * they will both be applied to the node, but the last one scheduled will be
 * applied last on each frame, so it will appear to have replaced the
 * original. Generally you will not want to do that.</text>
      <param>zeroToOne final transparency value.</param>
      <param>duration amount of time that the animation should take</param>
      <return>the newly scheduled activity</return>
    </javadoc>
    <method type="PInterpolatingActivity" name="animateToTransparency" startLine="624" endLine="648">
      <scope startLine="625" endLine="628" />
      <scope startLine="629" endLine="647">
        <declaration type="float" name="dest" />
        <declaration type="PInterpolatingActivity" name="ta" />
        <declaration type="float" name="source" />
        <method type="void" name="activityStarted" startLine="635" endLine="638" />
        <method type="void" name="setRelativeTargetValue" startLine="640" endLine="642" />
      </scope>
    </method>
    <javadoc>
      <text>* Schedule the given activity with the root, note that only scheduled
 * activities will be stepped. If the activity is successfully added true is
 * returned, else false.</text>
      <param>activity new activity to schedule</param>
      <return>true if the activity is successfully scheduled.</return>
    </javadoc>
    <method type="boolean" name="addActivity" startLine="658" endLine="664">
      <declaration type="PRoot" name="r" />
      <scope startLine="660" endLine="662" />
    </method>
    <javadoc>
      <text>* Return mutable attributed set of client properties associated with this
 * node.</text>
      <return>the client properties associated to this node</return>
    </javadoc>
    <method type="MutableAttributeSet" name="getClientProperties" startLine="681" endLine="686">
      <scope startLine="682" endLine="684" />
    </method>
    <javadoc>
      <text>* Returns the value of the client attribute with the specified key. Only
 * attributes added with <code>addAttribute</code> will return a non-null
 * value.</text>
      <param>key key to use while fetching client attribute</param>
      <return>the value of this attribute or null</return>
    </javadoc>
    <method type="Object" name="getAttribute" startLine="697" endLine="704">
      <scope startLine="698" endLine="700" />
      <scope startLine="701" endLine="703" />
    </method>
    <javadoc>
      <text>* Add an arbitrary key/value to this node.
 * <p>
 * The <code>get/add attribute</code> methods provide access to a small
 * per-instance attribute set. Callers can use get/add attribute to annotate
 * nodes that were created by another module.
 * <p>
 * If value is null this method will remove the attribute.</text>
      <param>key to use when adding the attribute</param>
      <param>value value to associate to the new attribute</param>
    </javadoc>
    <method type="void" name="addAttribute" startLine="718" endLine="744">
      <scope startLine="719" endLine="721" />
      <declaration type="Object" name="oldValue" />
      <scope startLine="725" endLine="743">
        <scope startLine="726" endLine="728" />
        <scope startLine="730" endLine="732" />
        <scope startLine="733" endLine="735" />
        <scope startLine="737" endLine="739" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns an enumeration of all keys maped to attribute values values.</text>
      <return>an Enumeration over attribute keys</return>
    </javadoc>
    <method type="Enumeration" name="getClientPropertyKeysEnumeration" startLine="751" endLine="758">
      <scope startLine="752" endLine="754" />
      <scope startLine="755" endLine="757" />
    </method>
    <javadoc>
      <text>* Fetches the value of the requested attribute, returning defaultValue is
 * not found.</text>
      <param>key attribute to search for</param>
      <param>defaultValue value to return if attribute is not found</param>
      <return>value of attribute or defaultValue if not found</return>
    </javadoc>
    <method type="Object" name="getAttribute" startLine="771" endLine="778">
      <declaration type="Object" name="value" />
      <scope startLine="773" endLine="775" />
    </method>
    <javadoc>
      <text>* Fetches the boolean value of the requested attribute, returning
 * defaultValue is not found.</text>
      <param>key attribute to search for</param>
      <param>defaultValue value to return if attribute is not found</param>
      <return>value of attribute or defaultValue if not found</return>
    </javadoc>
    <method type="boolean" name="getBooleanAttribute" startLine="789" endLine="796">
      <declaration type="Boolean" name="value" />
      <scope startLine="791" endLine="793" />
    </method>
    <javadoc>
      <text>* Fetches the integer value of the requested attribute, returning
 * defaultValue is not found.</text>
      <param>key attribute to search for</param>
      <param>defaultValue value to return if attribute is not found</param>
      <return>value of attribute or defaultValue if not found</return>
    </javadoc>
    <method type="int" name="getIntegerAttribute" startLine="807" endLine="814">
      <declaration type="Number" name="value" />
      <scope startLine="809" endLine="811" />
    </method>
    <javadoc>
      <text>* Fetches the double value of the requested attribute, returning
 * defaultValue is not found.</text>
      <param>key attribute to search for</param>
      <param>defaultValue value to return if attribute is not found</param>
      <return>value of attribute or defaultValue if not found</return>
    </javadoc>
    <method type="double" name="getDoubleAttribute" startLine="825" endLine="832">
      <declaration type="Number" name="value" />
      <scope startLine="827" endLine="829" />
    </method>
    <javadoc>
      <deprecated>use getAttribute(Object key)instead.</deprecated>
      <param>key name of property to search for</param>
      <return>value of matching client property</return>
    </javadoc>
    <method type="Object" name="getClientProperty" startLine="840" endLine="842" />
    <javadoc>
      <deprecated>use addAttribute(Object key, Object value)instead.</deprecated>
      <param>key name of property to add</param>
      <param>value value or new attribute</param>
    </javadoc>
    <method type="void" name="addClientProperty" startLine="850" endLine="852" />
    <javadoc>
      <deprecated>use getClientPropertyKeysEnumerator() instead.</deprecated>
      <return>iterator for client property keys</return>
    </javadoc>
    <method type="Iterator" name="getClientPropertyKeysIterator" startLine="859" endLine="863">
      <declaration type="Enumeration" name="enumeration" />
    </method>
    <javadoc>
      <text>* The copy method copies this node and all of its descendants. Note that
 * copying is implemented in terms of java serialization. See the
 * serialization notes for more information.</text>
      <return>new copy of this node or null if the node was not serializable</return>
    </javadoc>
    <method type="Object" name="clone" startLine="877" endLine="888">
      <scope startLine="878" endLine="881">
        <declaration type="byte[]" name="ser" />
      </scope>
      <scope startLine="882" endLine="884" />
      <scope startLine="885" endLine="887" />
    </method>
    <javadoc>
      <text>* Transform the given point from this node's local coordinate system to its
 * parent's local coordinate system. Note that this will modify the point
 * parameter.</text>
      <param>localPoint point in local coordinate system to be transformed.</param>
      <return>point in parent's local coordinate system</return>
    </javadoc>
    <method type="Point2D" name="localToParent" startLine="935" endLine="940">
      <scope startLine="936" endLine="938" />
    </method>
    <javadoc>
      <text>* Transform the given dimension from this node's local coordinate system to
 * its parent's local coordinate system. Note that this will modify the
 * dimension parameter.</text>
      <param>localDimension dimension in local coordinate system to be
 * transformed.</param>
      <return>dimension in parent's local coordinate system</return>
    </javadoc>
    <method type="Dimension2D" name="localToParent" startLine="951" endLine="956">
      <scope startLine="952" endLine="954" />
    </method>
    <javadoc>
      <text>* Transform the given rectangle from this node's local coordinate system to
 * its parent's local coordinate system. Note that this will modify the
 * rectangle parameter.</text>
      <param>localRectangle rectangle in local coordinate system to be
 * transformed.</param>
      <return>rectangle in parent's local coordinate system</return>
    </javadoc>
    <method type="Rectangle2D" name="localToParent" startLine="967" endLine="972">
      <scope startLine="968" endLine="970" />
    </method>
    <javadoc>
      <text>* Transform the given point from this node's parent's local coordinate
 * system to the local coordinate system of this node. Note that this will
 * modify the point parameter.</text>
      <param>parentPoint point in parent's coordinate system to be transformed.</param>
      <return>point in this node's local coordinate system</return>
    </javadoc>
    <method type="Point2D" name="parentToLocal" startLine="982" endLine="988">
      <scope startLine="983" endLine="985" />
    </method>
    <javadoc>
      <text>* Transform the given dimension from this node's parent's local coordinate
 * system to the local coordinate system of this node. Note that this will
 * modify the dimension parameter.</text>
      <param>parentDimension dimension in parent's coordinate system to be
 * transformed.</param>
      <return>dimension in this node's local coordinate system</return>
    </javadoc>
    <method type="Dimension2D" name="parentToLocal" startLine="999" endLine="1004">
      <scope startLine="1000" endLine="1002" />
    </method>
    <javadoc>
      <text>* Transform the given rectangle from this node's parent's local coordinate
 * system to the local coordinate system of this node. Note that this will
 * modify the rectangle parameter.</text>
      <param>parentRectangle rectangle in parent's coordinate system to be
 * transformed.</param>
      <return>rectangle in this node's local coordinate system</return>
    </javadoc>
    <method type="Rectangle2D" name="parentToLocal" startLine="1015" endLine="1020">
      <scope startLine="1016" endLine="1018" />
    </method>
    <javadoc>
      <text>* Transform the given point from this node's local coordinate system to the
 * global coordinate system. Note that this will modify the point parameter.</text>
      <param>localPoint point in local coordinate system to be transformed.</param>
      <return>point in global coordinates</return>
    </javadoc>
    <method type="Point2D" name="localToGlobal" startLine="1029" endLine="1036">
      <declaration type="PNode" name="n" />
      <scope startLine="1031" endLine="1034" />
    </method>
    <javadoc>
      <text>* Transform the given dimension from this node's local coordinate system to
 * the global coordinate system. Note that this will modify the dimension
 * parameter.</text>
      <param>localDimension dimension in local coordinate system to be
 * transformed.</param>
      <return>dimension in global coordinates</return>
    </javadoc>
    <method type="Dimension2D" name="localToGlobal" startLine="1047" endLine="1054">
      <declaration type="PNode" name="n" />
      <scope startLine="1049" endLine="1052" />
    </method>
    <javadoc>
      <text>* Transform the given rectangle from this node's local coordinate system to
 * the global coordinate system. Note that this will modify the rectangle
 * parameter.</text>
      <param>localRectangle rectangle in local coordinate system to be
 * transformed.</param>
      <return>rectangle in global coordinates</return>
    </javadoc>
    <method type="Rectangle2D" name="localToGlobal" startLine="1065" endLine="1072">
      <declaration type="PNode" name="n" />
      <scope startLine="1067" endLine="1070" />
    </method>
    <javadoc>
      <text>* Transform the given point from global coordinates to this node's local
 * coordinate system. Note that this will modify the point parameter.</text>
      <param>globalPoint point in global coordinates to be transformed.</param>
      <return>point in this node's local coordinate system.</return>
    </javadoc>
    <method type="Point2D" name="globalToLocal" startLine="1081" endLine="1084">
      <declaration type="PAffineTransform" name="globalTransform" />
    </method>
    <method type="PAffineTransform" name="computeGlobalTransform" startLine="1086" endLine="1096">
      <scope startLine="1087" endLine="1089" />
      <declaration type="PAffineTransform" name="parentGlobalTransform" />
      <scope startLine="1092" endLine="1094" />
    </method>
    <javadoc>
      <text>* Transform the given dimension from global coordinates to this node's
 * local coordinate system. Note that this will modify the dimension
 * parameter.</text>
      <param>globalDimension dimension in global coordinates to be transformed.</param>
      <return>dimension in this node's local coordinate system.</return>
    </javadoc>
    <method type="Dimension2D" name="globalToLocal" startLine="1106" endLine="1111">
      <scope startLine="1107" endLine="1109" />
    </method>
    <javadoc>
      <text>* Transform the given rectangle from global coordinates to this node's
 * local coordinate system. Note that this will modify the rectangle
 * parameter.</text>
      <param>globalRectangle rectangle in global coordinates to be transformed.</param>
      <return>rectangle in this node's local coordinate system.</return>
    </javadoc>
    <method type="Rectangle2D" name="globalToLocal" startLine="1121" endLine="1126">
      <scope startLine="1122" endLine="1124" />
    </method>
    <javadoc>
      <text>* Return the transform that converts local coordinates at this node to the
 * global coordinate system.</text>
      <param>dest PAffineTransform to transform to global coordinates</param>
      <return>The concatenation of transforms from the top node down to this
 * node.</return>
    </javadoc>
    <method type="PAffineTransform" name="getLocalToGlobalTransform" startLine="1136" endLine="1155">
      <declaration type="PAffineTransform" name="result" />
      <scope startLine="1138" endLine="1143">
        <scope startLine="1140" endLine="1142" />
      </scope>
      <scope startLine="1144" endLine="1146" />
      <scope startLine="1147" endLine="1149" />
      <scope startLine="1150" endLine="1152" />
    </method>
    <javadoc>
      <text>* Return the transform that converts global coordinates to local
 * coordinates of this node.</text>
      <param>dest PAffineTransform to transform from global to local</param>
      <return>The inverse of the concatenation of transforms from the root down
 * to this node.</return>
    </javadoc>
    <method type="PAffineTransform" name="getGlobalToLocalTransform" startLine="1166" endLine="1175">
      <declaration type="PAffineTransform" name="result" />
      <scope startLine="1168" endLine="1170" />
      <scope startLine="1171" endLine="1173" />
    </method>
    <javadoc>
      <text>* Return the list of event listeners associated with this node.</text>
      <return>event listener list or null</return>
    </javadoc>
    <method type="EventListenerList" name="getListenerList" startLine="1193" endLine="1195" />
    <javadoc>
      <text>* Adds the specified input event listener to receive input events from this
 * node.</text>
      <param>listener the new input listener</param>
    </javadoc>
    <method type="void" name="addInputEventListener" startLine="1203" endLine="1208">
      <scope startLine="1204" endLine="1206" />
    </method>
    <javadoc>
      <text>* Removes the specified input event listener so that it no longer receives
 * input events from this node.</text>
      <param>listener the input listener to remove</param>
    </javadoc>
    <method type="void" name="removeInputEventListener" startLine="1216" endLine="1224">
      <scope startLine="1217" endLine="1219" />
      <scope startLine="1221" endLine="1223" />
    </method>
    <javadoc>
      <text>* Add a PropertyChangeListener to the listener list. The listener is
 * registered for all properties. See the fields in PNode and subclasses
 * that start with PROPERTY_ to find out which properties exist.</text>
      <param>listener The PropertyChangeListener to be added</param>
    </javadoc>
    <method type="void" name="addPropertyChangeListener" startLine="1233" endLine="1238">
      <scope startLine="1234" endLine="1236" />
    </method>
    <javadoc>
      <text>* Add a PropertyChangeListener for a specific property. The listener will
 * be invoked only when a call on firePropertyChange names that specific
 * property. See the fields in PNode and subclasses that start with
 * PROPERTY_ to find out which properties are supported.</text>
      <param>propertyName The name of the property to listen on.</param>
      <param>listener The PropertyChangeListener to be added</param>
    </javadoc>
    <method type="void" name="addPropertyChangeListener" startLine="1249" endLine="1257">
      <scope startLine="1250" endLine="1252" />
      <scope startLine="1253" endLine="1255" />
    </method>
    <javadoc>
      <text>* Remove a PropertyChangeListener from the listener list. This removes a
 * PropertyChangeListener that was registered for all properties.</text>
      <param>listener The PropertyChangeListener to be removed</param>
    </javadoc>
    <method type="void" name="removePropertyChangeListener" startLine="1265" endLine="1269">
      <scope startLine="1266" endLine="1268" />
    </method>
    <javadoc>
      <text>* Remove a PropertyChangeListener for a specific property.</text>
      <param>propertyName The name of the property that was listened on.</param>
      <param>listener The PropertyChangeListener to be removed</param>
    </javadoc>
    <method type="void" name="removePropertyChangeListener" startLine="1277" endLine="1285">
      <scope startLine="1278" endLine="1280" />
      <scope startLine="1281" endLine="1283" />
    </method>
    <javadoc>
      <text>* Return the propertyChangeParentMask that determines which property change
 * events are forwared to this nodes parent so that its property change
 * listeners will also be notified.</text>
      <return>mask used for deciding whether to bubble property changes up to
 * parent</return>
    </javadoc>
    <method type="int" name="getPropertyChangeParentMask" startLine="1295" endLine="1297" />
    <javadoc>
      <text>* Set the propertyChangeParentMask that determines which property change
 * events are forwared to this nodes parent so that its property change
 * listeners will also be notified.</text>
      <param>propertyChangeParentMask new mask for property change bubble up</param>
    </javadoc>
    <method type="void" name="setPropertyChangeParentMask" startLine="1306" endLine="1308" />
    <javadoc>
      <text>* Report a bound property update to any registered listeners. No event is
 * fired if old and new are equal and non-null. If the propertyCode exists
 * in this node's propertyChangeParentMask then a property change event will
 * also be fired on this nodes parent.</text>
      <param>propertyCode The code of the property changed.</param>
      <param>propertyName The name of the property that was changed.</param>
      <param>oldValue The old value of the property.</param>
      <param>newValue The new value of the property.</param>
    </javadoc>
    <method type="void" name="firePropertyChange" startLine="1322" endLine="1335">
      <declaration type="PropertyChangeEvent" name="event" />
      <scope startLine="1325" endLine="1328" />
      <scope startLine="1329" endLine="1334">
        <scope startLine="1330" endLine="1332" />
      </scope>
    </method>
    <javadoc>
      <text>* Called by child node to forward property change events up the node tree
 * so that property change listeners registered with this node will be
 * notified of property changes of its children nodes. For performance
 * reason only propertyCodes listed in the propertyChangeParentMask are
 * forwarded.</text>
      <param>event The property change event containing source node and changed
 * values.</param>
      <param>propertyCode The code of the property changed.</param>
    </javadoc>
    <method type="void" name="fireChildPropertyChange" startLine="1348" endLine="1355">
      <scope startLine="1349" endLine="1351" />
      <scope startLine="1352" endLine="1354" />
    </method>
    <javadoc>
      <text>* Return a copy of this node's bounds. These bounds are stored in the local
 * coordinate system of this node and do not include the bounds of any of
 * this node's children.</text>
      <return>copy of this node's local bounds</return>
    </javadoc>
    <method type="PBounds" name="getBounds" startLine="1384" endLine="1386" />
    <javadoc>
      <text>* Return a direct reference to this node's bounds. These bounds are stored
 * in the local coordinate system of this node and do not include the bounds
 * of any of this node's children. The value returned should not be
 * modified.</text>
      <return>direct reference to local bounds</return>
    </javadoc>
    <method type="PBounds" name="getBoundsReference" startLine="1396" endLine="1398" />
    <javadoc>
      <text>* Notify this node that you will begin to repeatedly call <code>setBounds
 * </code>. When you
 * are done call <code>endResizeBounds</code> to let the node know that you
 * are done.</text>
    </javadoc>
    <method type="void" name="startResizeBounds" startLine="1406" endLine="1407" />
    <javadoc>
      <text>* Notify this node that you have finished a resize bounds sequence.</text>
    </javadoc>
    <method type="void" name="endResizeBounds" startLine="1412" endLine="1413" />
    <javadoc>
      <text>* Set's this node's bounds left position, leaving y, width, and height
 * unchanged.</text>
      <param>x new x position of bounds</param>
      <return>whether the change was successful</return>
    </javadoc>
    <method type="boolean" name="setX" startLine="1423" endLine="1425" />
    <javadoc>
      <text>* Set's this node's bounds top position, leaving x, width, and height
 * unchanged.</text>
      <param>y new y position of bounds</param>
      <return>whether the change was successful</return>
    </javadoc>
    <method type="boolean" name="setY" startLine="1435" endLine="1437" />
    <javadoc>
      <text>* Set's this node's bounds width, leaving x, y, and height unchanged.</text>
      <param>width new width position of bounds</param>
      <return>whether the change was successful</return>
    </javadoc>
    <method type="boolean" name="setWidth" startLine="1446" endLine="1448" />
    <javadoc>
      <text>* Set's this node's bounds height, leaving x, y, and width unchanged.</text>
      <param>height new height position of bounds</param>
      <return>whether the change was successful</return>
    </javadoc>
    <method type="boolean" name="setHeight" startLine="1457" endLine="1459" />
    <javadoc>
      <text>* Set the bounds of this node to the given value. These bounds are stored
 * in the local coordinate system of this node.</text>
      <param>newBounds bounds to apply to this node</param>
      <return>true if the bounds changed.</return>
    </javadoc>
    <method type="boolean" name="setBounds" startLine="1469" endLine="1471" />
    <javadoc>
      <text>* Set the bounds of this node to the given position and size. These bounds
 * are stored in the local coordinate system of this node.
 * If the width or height is less then or equal to zero then the bound's
 * empty bit will be set to true.
 * Subclasses must call the super.setBounds() method.</text>
      <param>x x position of bounds</param>
      <param>y y position of bounds</param>
      <param>width width to apply to the bounds</param>
      <param>height height to apply to the bounds</param>
      <return>true if the bounds changed.</return>
    </javadoc>
    <method type="boolean" name="setBounds" startLine="1489" endLine="1508">
      <scope startLine="1490" endLine="1501">
        <scope startLine="1493" endLine="1495" />
      </scope>
      <comment>Don't put any invalidating code here or else nodes with volatile</comment>
      <comment>bounds will</comment>
      <comment>create a soft infinite loop (calling Swing.invokeLater()) when they</comment>
      <comment>validate</comment>
      <comment>their bounds.</comment>
    </method>
    <javadoc>
      <text>* Gives nodes a chance to update their internal structure before bounds
 * changed notifications are sent. When this message is recived the nodes
 * bounds field will contain the new value.
 * See PPath for an example that uses this method.</text>
      <param>x x position of bounds</param>
      <param>y y position of bounds</param>
      <param>width width to apply to the bounds</param>
      <param>height height to apply to the bounds</param>
    </javadoc>
    <method type="void" name="internalUpdateBounds" startLine="1522" endLine="1523" />
    <javadoc>
      <text>* Set the empty bit of this bounds to true.</text>
    </javadoc>
    <method type="void" name="resetBounds" startLine="1528" endLine="1530" />
    <javadoc>
      <text>* Return the x position (in local coords) of this node's bounds.</text>
      <return>local x position of bounds</return>
    </javadoc>
    <method type="double" name="getX" startLine="1537" endLine="1539" />
    <javadoc>
      <text>* Return the y position (in local coords) of this node's bounds.</text>
      <return>local y position of bounds</return>
    </javadoc>
    <method type="double" name="getY" startLine="1546" endLine="1548" />
    <javadoc>
      <text>* Return the width (in local coords) of this node's bounds.</text>
      <return>local width of bounds</return>
    </javadoc>
    <method type="double" name="getWidth" startLine="1555" endLine="1557" />
    <javadoc>
      <text>* Return the height (in local coords) of this node's bounds.</text>
      <return>local width of bounds</return>
    </javadoc>
    <method type="double" name="getHeight" startLine="1564" endLine="1566" />
    <javadoc>
      <text>* Return a copy of the bounds of this node in the global coordinate system.</text>
      <return>the bounds in global coordinate system.</return>
    </javadoc>
    <method type="PBounds" name="getGlobalBounds" startLine="1573" endLine="1575" />
    <javadoc>
      <text>* Center the bounds of this node so that they are centered on the given
 * point specified on the local coordinates of this node. Note that this
 * method will modify the nodes bounds, while centerFullBoundsOnPoint will
 * modify the nodes transform.</text>
      <param>localX x position of point around which to center bounds</param>
      <param>localY y position of point around which to center bounds</param>
      <return>true if the bounds changed.</return>
    </javadoc>
    <method type="boolean" name="centerBoundsOnPoint" startLine="1588" endLine="1592">
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
    </method>
    <javadoc>
      <text>* Center the full bounds of this node so that they are centered on the
 * given point specified on the local coordinates of this nodes parent. Note
 * that this method will modify the nodes transform, while
 * centerBoundsOnPoint will modify the nodes bounds.</text>
      <param>parentX x position around which to center full bounds</param>
      <param>parentY y position around which to center full bounds</param>
    </javadoc>
    <method type="void" name="centerFullBoundsOnPoint" startLine="1603" endLine="1607">
      <declaration type="double" name="dx" />
      <declaration type="double" name="dy" />
    </method>
    <javadoc>
      <text>* Return true if this node intersects the given rectangle specified in
 * local bounds. If the geometry of this node is complex this method can
 * become expensive, it is therefore recommended that
 * <code>fullIntersects</code> is used for quick rejects before calling this
 * method.</text>
      <param>localBounds the bounds to test for intersection against</param>
      <return>true if the given rectangle intersects this nodes geometry.</return>
    </javadoc>
    <method type="boolean" name="intersects" startLine="1619" endLine="1624">
      <scope startLine="1620" endLine="1622" />
    </method>
    <javadoc>
      <text>* Return a copy of this node's full bounds. These bounds are stored in the
 * parent coordinate system of this node and they include the union of this
 * node's bounds and all the bounds of it's descendants.</text>
      <return>a copy of this node's full bounds.</return>
    </javadoc>
    <method type="PBounds" name="getFullBounds" startLine="1649" endLine="1651" />
    <javadoc>
      <text>* Return a reference to this node's full bounds cache. These bounds are
 * stored in the parent coordinate system of this node and they include the
 * union of this node's bounds and all the bounds of it's descendants. The
 * bounds returned by this method should not be modified.</text>
      <return>a reference to this node's full bounds cache.</return>
    </javadoc>
    <method type="PBounds" name="getFullBoundsReference" startLine="1661" endLine="1664" />
    <javadoc>
      <text>* Compute and return the full bounds of this node. If the dstBounds
 * parameter is not null then it will be used to return the results instead
 * of creating a new PBounds.</text>
      <param>dstBounds if not null the new bounds will be stored here</param>
      <return>the full bounds in the parent coordinate system of this node</return>
    </javadoc>
    <method type="PBounds" name="computeFullBounds" startLine="1674" endLine="1679">
      <declaration type="PBounds" name="result" />
    </method>
    <javadoc>
      <text>* Compute and return the union of the full bounds of all the children of
 * this node. If the dstBounds parameter is not null then it will be used to
 * return the results instead of creating a new PBounds.</text>
      <param>dstBounds if not null the new bounds will be stored here</param>
      <return>union of children bounds</return>
    </javadoc>
    <method type="PBounds" name="getUnionOfChildrenBounds" startLine="1689" endLine="1706">
      <declaration type="PBounds" name="resultBounds" />
      <scope startLine="1691" endLine="1693" />
      <scope startLine="1694" endLine="1697" />
      <declaration type="int" name="count" />
      <scope startLine="1700" endLine="1703">
        <declaration type="PNode" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* Return a copy of the full bounds of this node in the global coordinate
 * system.</text>
      <return>the full bounds in global coordinate system.</return>
    </javadoc>
    <method type="PBounds" name="getGlobalFullBounds" startLine="1714" endLine="1720">
      <declaration type="PBounds" name="b" />
      <scope startLine="1716" endLine="1718" />
    </method>
    <javadoc>
      <text>* Return true if the full bounds of this node intersects with the specified
 * bounds.</text>
      <param>parentBounds the bounds to test for intersection against
 * (specified in parent's coordinate system)</param>
      <return>true if this nodes full bounds intersect the given bounds.</return>
    </javadoc>
    <method type="boolean" name="fullIntersects" startLine="1730" endLine="1735">
      <scope startLine="1731" endLine="1733" />
    </method>
    <javadoc>
      <text>* Return true if this nodes bounds may change at any time. The default
 * behavior is to return false, subclasses that override this method to
 * return true should also override getBoundsReference() and compute their
 * volatile bounds there before returning the reference.</text>
      <return>true if this node has volatile bounds</return>
    </javadoc>
    <method type="boolean" name="getBoundsVolatile" startLine="1750" endLine="1752" />
    <javadoc>
      <text>* Return true if this node has a child with volatile bounds.</text>
      <return>true if this node has a child with volatile bounds</return>
    </javadoc>
    <method type="boolean" name="getChildBoundsVolatile" startLine="1759" endLine="1761" />
    <javadoc>
      <text>* Set if this node has a child with volatile bounds. This should normally
 * be managed automatically by the bounds validation process.</text>
      <param>childBoundsVolatile true if this node has a descendant with
 * volatile bounds</param>
    </javadoc>
    <method type="void" name="setChildBoundsVolatile" startLine="1770" endLine="1772" />
    <javadoc>
      <text>* Return true if this node's bounds have recently changed. This flag will
 * be reset on the next call of validateFullBounds.</text>
      <return>true if this node's bounds have changed.</return>
    </javadoc>
    <method type="boolean" name="getBoundsChanged" startLine="1780" endLine="1782" />
    <javadoc>
      <text>* Set the bounds chnaged flag. This flag will be reset on the next call of
 * validateFullBounds.</text>
      <param>boundsChanged true if this nodes bounds have changed.</param>
    </javadoc>
    <method type="void" name="setBoundsChanged" startLine="1790" endLine="1792" />
    <javadoc>
      <text>* Return true if the full bounds of this node are invalid. This means that
 * the full bounds of this node have changed and need to be recomputed.</text>
      <return>true if the full bounds of this node are invalid</return>
    </javadoc>
    <method type="boolean" name="getFullBoundsInvalid" startLine="1800" endLine="1802" />
    <javadoc>
      <text>* Set the full bounds invalid flag. This flag is set when the full bounds
 * of this node need to be recomputed as is the case when this node is
 * transformed or when one of this node's children changes geometry.</text>
      <param>fullBoundsInvalid true=invalid, false=valid</param>
    </javadoc>
    <method type="void" name="setFullBoundsInvalid" startLine="1811" endLine="1813" />
    <javadoc>
      <text>* Return true if one of this node's descendants has invalid bounds.</text>
      <return>whether child bounds are invalid</return>
    </javadoc>
    <method type="boolean" name="getChildBoundsInvalid" startLine="1820" endLine="1822" />
    <javadoc>
      <text>* Set the flag indicating that one of this node's descendants has invalid
 * bounds.</text>
      <param>childBoundsInvalid true=invalid, false=valid</param>
    </javadoc>
    <method type="void" name="setChildBoundsInvalid" startLine="1830" endLine="1832" />
    <javadoc>
      <text>* This method should be called when the bounds of this node are changed. It
 * invalidates the full bounds of this node, and also notifies each of this
 * nodes children that their parent's bounds have changed. As a result of
 * this method getting called this nodes layoutChildren will be called.</text>
    </javadoc>
    <method type="void" name="signalBoundsChanged" startLine="1840" endLine="1850">
      <declaration type="int" name="count" />
      <scope startLine="1846" endLine="1849">
        <declaration type="PNode" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* Invalidate this node's layout, so that later layoutChildren will get
 * called.</text>
    </javadoc>
    <method type="void" name="invalidateLayout" startLine="1856" endLine="1858" />
    <javadoc>
      <text>* A notification that the bounds of this node's parent have changed.</text>
    </javadoc>
    <method type="void" name="parentBoundsChanged" startLine="1863" endLine="1864" />
    <javadoc>
      <text>* Invalidates the full bounds of this node, and sets the child bounds
 * invalid flag on each of this node's ancestors.</text>
    </javadoc>
    <method type="void" name="invalidateFullBounds" startLine="1870" endLine="1882">
      <declaration type="PNode" name="n" />
      <scope startLine="1874" endLine="1877" />
      <scope startLine="1879" endLine="1881" />
    </method>
    <javadoc>
      <text>* This method is called to validate the bounds of this node and all of its
 * descendants. It returns true if this nodes bounds or the bounds of any of
 * its descendants are marked as volatile.</text>
      <return>true if this node or any of its descendants have volatile bounds</return>
    </javadoc>
    <method type="boolean" name="validateFullBounds" startLine="1891" endLine="1982">
      <declaration type="boolean" name="boundsVolatile" />
      <scope startLine="1895" endLine="1979">
        <scope startLine="1907" endLine="1909" />
        <scope startLine="1913" endLine="1920">
          <declaration type="int" name="count" />
          <scope startLine="1916" endLine="1919">
            <declaration type="PNode" name="each" />
          </scope>
        </scope>
        <scope startLine="1935" endLine="1973">
          <declaration type="double" name="oldX" />
          <declaration type="double" name="oldY" />
          <declaration type="double" name="oldWidth" />
          <declaration type="double" name="oldHeight" />
          <declaration type="boolean" name="oldEmpty" />
          <declaration type="boolean" name="fullBoundsChanged" />
          <scope startLine="1958" endLine="1972">
            <scope startLine="1959" endLine="1961" />
            <scope startLine="1968" endLine="1971" />
          </scope>
        </scope>
        <comment>2. If my bounds are volatile and they have not been changed then</comment>
        <comment>signal a change.</comment>
        <comment />
        <comment>For most cases this will do nothing, but if a nodes bounds depend</comment>
        <comment>on its model, then</comment>
        <comment>validate bounds has the responsibility of making the bounds match</comment>
        <comment>the models value.</comment>
        <comment>For example PPaths validateBounds method makes sure that the</comment>
        <comment>bounds are equal to the</comment>
        <comment>bounds of the GeneralPath model.</comment>
        <comment>3. If the bounds of on of my decendents are invalidate then</comment>
        <comment>validate the bounds of all of my children.</comment>
        <comment>4. Now that my children's bounds are valid and my own bounds are</comment>
        <comment>valid run any layout algorithm here. Note that if you try to</comment>
        <comment>layout volatile</comment>
        <comment>children piccolo will most likely start a "soft" infinite loop.</comment>
        <comment>It won't freeze</comment>
        <comment>your program, but it will make an infinite number of calls to</comment>
        <comment>SwingUtilities</comment>
        <comment>invoke later. You don't want to do that.</comment>
        <comment>5. If the full bounds cache is invalid then recompute the full</comment>
        <comment>bounds cache here after our own bounds and the children's bounds</comment>
        <comment>have been computed above.</comment>
        <comment>6. This will call getFullBoundsReference on all of the</comment>
        <comment>children. So if the above</comment>
        <comment>layoutChildren method changed the bounds of any of the</comment>
        <comment>children they will be</comment>
        <comment>validated again here.</comment>
        <comment>7. If the new full bounds cache differs from the previous</comment>
        <comment>cache then</comment>
        <comment>tell our parent to invalidate their full bounds. This is how</comment>
        <comment>bounds changes</comment>
        <comment>deep in the tree percolate up.</comment>
        <comment>8. If our paint was invalid make sure to repaint our old</comment>
        <comment>full bounds. The</comment>
        <comment>new bounds will be computed later in the validatePaint</comment>
        <comment>pass.</comment>
        <comment>9. Clear the invalid bounds flags.</comment>
      </scope>
      <comment>1. Only compute new bounds if invalid flags are set.</comment>
    </method>
    <javadoc>
      <text>* Nodes that apply layout constraints to their children should override
 * this method and do the layout there.</text>
    </javadoc>
    <method type="void" name="layoutChildren" startLine="1988" endLine="1989" />
    <javadoc>
      <text>* Returns the rotation applied by this node's transform in radians. This
 * rotation affects this node and all its descendants. The value returned
 * will be between 0 and 2pi radians.</text>
      <return>rotation in radians.</return>
    </javadoc>
    <method type="double" name="getRotation" startLine="2014" endLine="2019">
      <scope startLine="2015" endLine="2017" />
    </method>
    <javadoc>
      <text>* Sets the rotation of this nodes transform in radians. This will affect
 * this node and all its descendents.</text>
      <param>theta rotation in radians</param>
    </javadoc>
    <method type="void" name="setRotation" startLine="2027" endLine="2029" />
    <javadoc>
      <text>* Rotates this node by theta (in radians) about the 0,0 point. This will
 * affect this node and all its descendants.</text>
      <param>theta the amount to rotate by in radians</param>
    </javadoc>
    <method type="void" name="rotate" startLine="2037" endLine="2039" />
    <javadoc>
      <text>* Rotates this node by theta (in radians), and then translates the node so
 * that the x, y position of its fullBounds stays constant.</text>
      <param>theta the amount to rotate by in radians</param>
    </javadoc>
    <method type="void" name="rotateInPlace" startLine="2047" endLine="2054">
      <declaration type="PBounds" name="b" />
      <declaration type="double" name="px" />
      <declaration type="double" name="py" />
    </method>
    <javadoc>
      <text>* Rotates this node by theta (in radians) about the given point. This will
 * affect this node and all its descendants.</text>
      <param>theta the amount to rotate by in radians</param>
      <param>point the point about which to rotate</param>
    </javadoc>
    <method type="void" name="rotateAboutPoint" startLine="2063" endLine="2065" />
    <javadoc>
      <text>* Rotates this node by theta (in radians) about the given point. This will
 * affect this node and all its descendants.</text>
      <param>theta the amount to rotate by in radians</param>
      <param>x the x coordinate of the point around which to rotate</param>
      <param>y the y coordinate of the point around which to rotate</param>
    </javadoc>
    <method type="void" name="rotateAboutPoint" startLine="2075" endLine="2080" />
    <javadoc>
      <text>* Return the total amount of rotation applied to this node by its own
 * transform together with the transforms of all its ancestors. The value
 * returned will be between 0 and 2pi radians.</text>
      <return>the total amount of rotation applied to this node in radians</return>
    </javadoc>
    <method type="double" name="getGlobalRotation" startLine="2089" endLine="2091" />
    <javadoc>
      <text>* Set the global rotation (in radians) of this node. This is implemented by
 * rotating this nodes transform the required amount so that the nodes
 * global rotation is as requested.</text>
      <param>theta the amount to rotate by in radians relative to the global
 * coordinate system.</param>
    </javadoc>
    <method type="void" name="setGlobalRotation" startLine="2101" endLine="2108">
      <scope startLine="2102" endLine="2104" />
      <scope startLine="2105" endLine="2107" />
    </method>
    <javadoc>
      <text>* Return the scale applied by this node's transform. The scale is effecting
 * this node and all its descendants.</text>
      <return>scale applied by this nodes transform.</return>
    </javadoc>
    <method type="double" name="getScale" startLine="2116" endLine="2121">
      <scope startLine="2117" endLine="2119" />
    </method>
    <javadoc>
      <text>* Set the scale of this node's transform. The scale will affect this node
 * and all its descendants.</text>
      <param>scale the scale to set the transform to</param>
    </javadoc>
    <method type="void" name="setScale" startLine="2129" endLine="2134">
      <scope startLine="2130" endLine="2132" />
    </method>
    <javadoc>
      <text>* Scale this nodes transform by the given amount. This will affect this
 * node and all of its descendants.</text>
      <param>scale the amount to scale by</param>
    </javadoc>
    <method type="void" name="scale" startLine="2142" endLine="2144" />
    <javadoc>
      <text>* Scale this nodes transform by the given amount about the specified point.
 * This will affect this node and all of its descendants.</text>
      <param>scale the amount to scale by</param>
      <param>point the point to scale about</param>
    </javadoc>
    <method type="void" name="scaleAboutPoint" startLine="2153" endLine="2155" />
    <javadoc>
      <text>* Scale this nodes transform by the given amount about the specified point.
 * This will affect this node and all of its descendants.</text>
      <param>scale the amount to scale by</param>
      <param>x the x coordinate of the point around which to scale</param>
      <param>y the y coordinate of the point around which to scale</param>
    </javadoc>
    <method type="void" name="scaleAboutPoint" startLine="2165" endLine="2170" />
    <javadoc>
      <text>* Return the global scale that is being applied to this node by its
 * transform together with the transforms of all its ancestors.</text>
      <return>global scale of this node</return>
    </javadoc>
    <method type="double" name="getGlobalScale" startLine="2178" endLine="2180" />
    <javadoc>
      <text>* Set the global scale of this node. This is implemented by scaling this
 * nodes transform the required amount so that the nodes global scale is as
 * requested.</text>
      <param>scale the desired global scale</param>
    </javadoc>
    <method type="void" name="setGlobalScale" startLine="2189" endLine="2196">
      <scope startLine="2190" endLine="2192" />
      <scope startLine="2193" endLine="2195" />
    </method>
    <javadoc>
      <text>* Returns the x offset of this node as applied by its transform.</text>
      <return>x offset of this node as applied by its transform</return>
    </javadoc>
    <method type="double" name="getXOffset" startLine="2203" endLine="2208">
      <scope startLine="2204" endLine="2206" />
    </method>
    <javadoc>
      <text>* Returns the y offset of this node as applied by its transform.</text>
      <return>y offset of this node as applied by its transform</return>
    </javadoc>
    <method type="double" name="getYOffset" startLine="2215" endLine="2220">
      <scope startLine="2216" endLine="2218" />
    </method>
    <javadoc>
      <text>* Return the offset that is being applied to this node by its transform.
 * This offset effects this node and all of its descendants and is specified
 * in the parent coordinate system. This returns the values that are in the
 * m02 and m12 positions in the affine transform.</text>
      <return>a point representing the x and y offset</return>
    </javadoc>
    <method type="Point2D" name="getOffset" startLine="2230" endLine="2235">
      <scope startLine="2231" endLine="2233" />
    </method>
    <javadoc>
      <text>* Set the offset that is being applied to this node by its transform. This
 * offset effects this node and all of its descendants and is specified in
 * the nodes parent coordinate system. This directly sets the values of the
 * m02 and m12 positions in the affine transform. Unlike "PNode.translate()"
 * it is not effected by the transforms scale.</text>
      <param>point value of new offset</param>
    </javadoc>
    <method type="void" name="setOffset" startLine="2246" endLine="2248" />
    <javadoc>
      <text>* Set the offset that is being applied to this node by its transform. This
 * offset effects this node and all of its descendants and is specified in
 * the nodes parent coordinate system. This directly sets the values of the
 * m02 and m12 positions in the affine transform. Unlike "PNode.translate()"
 * it is not effected by the transforms scale.</text>
      <param>x amount of x offset</param>
      <param>y amount of y offset</param>
    </javadoc>
    <method type="void" name="setOffset" startLine="2260" endLine="2265" />
    <javadoc>
      <text>* Offset this node relative to the parents coordinate system, and is NOT
 * effected by this nodes current scale or rotation. This is implemented by
 * directly adding dx to the m02 position and dy to the m12 position in the
 * affine transform.</text>
      <param>dx amount to add to this nodes current x Offset</param>
      <param>dy amount to add to this nodes current y Offset</param>
    </javadoc>
    <method type="void" name="offset" startLine="2276" endLine="2279" />
    <javadoc>
      <text>* Translate this node's transform by the given amount, using the standard
 * affine transform translate method. This translation effects this node and
 * all of its descendants.</text>
      <param>dx amount to add to this nodes current x translation</param>
      <param>dy amount to add to this nodes current y translation</param>
    </javadoc>
    <method type="void" name="translate" startLine="2289" endLine="2294" />
    <javadoc>
      <text>* Return the global translation that is being applied to this node by its
 * transform together with the transforms of all its ancestors.</text>
      <return>the global translation applied to this node</return>
    </javadoc>
    <method type="Point2D" name="getGlobalTranslation" startLine="2302" endLine="2308">
      <declaration type="Point2D" name="p" />
      <scope startLine="2304" endLine="2306" />
    </method>
    <javadoc>
      <text>* Set the global translation of this node. This is implemented by
 * translating this nodes transform the required amount so that the nodes
 * global scale is as requested.</text>
      <param>globalPoint the desired global translation</param>
    </javadoc>
    <method type="void" name="setGlobalTranslation" startLine="2317" endLine="2322">
      <scope startLine="2318" endLine="2320" />
    </method>
    <javadoc>
      <text>* Transform this nodes transform by the given transform.</text>
      <param>aTransform the transform to apply.</param>
    </javadoc>
    <method type="void" name="transformBy" startLine="2329" endLine="2334" />
    <javadoc>
      <text>* Linearly interpolates between a and b, based on t. Specifically, it
 * computes lerp(a, b, t) = a + t*(b - a). This produces a result that
 * changes from a (when t = 0) to b (when t = 1).</text>
      <param>t variable 'time' parameter</param>
      <param>a from point</param>
      <param>b to Point</param>
      <return>linear interpolation between and b at time interval t (given as #
 * between 0f and 1f)</return>
    </javadoc>
    <method type="double" name="lerp" startLine="2348" endLine="2350" />
    <javadoc>
      <text>* This will calculate the necessary transform in order to make this node
 * appear at a particular position relative to the specified bounding box.
 * The source point specifies a point in the unit square (0, 0) - (1, 1)
 * that represents an anchor point on the corresponding node to this
 * transform. The destination point specifies an anchor point on the
 * reference node. The position method then computes the transform that
 * results in transforming this node so that the source anchor point
 * coincides with the reference anchor point. This can be useful for layout
 * algorithms as it is straightforward to position one object relative to
 * another.
 * <p>
 * For example, If you have two nodes, A and B, and you call
 * <PRE>
 * Point2D srcPt = new Point2D.Double(1.0, 0.0);
 * Point2D destPt = new Point2D.Double(0.0, 0.0);
 * A.position(srcPt, destPt, B.getGlobalBounds(), 750, null);
 * </PRE>
 * The result is that A will move so that its upper-right corner is at the
 * same place as the upper-left corner of B, and the transition will be
 * smoothly animated over a period of 750 milliseconds.</text>
      <since>1.3</since>
      <param>srcPt The anchor point on this transform's node (normalized to a
 * unit square)</param>
      <param>destPt The anchor point on destination bounds (normalized to a
 * unit square)</param>
      <param>destBounds The bounds (in global coordinates) used to calculate
 * this transform's node</param>
      <param>millis Number of milliseconds over which to perform the animation</param>
      <return>newly scheduled activity or node if activity could not be
 * scheduled</return>
    </javadoc>
    <method type="PActivity" name="animateToRelativePosition" startLine="2389" endLine="2419">
      <declaration type="double" name="srcx" />
      <declaration type="double" name="destx" />
      <declaration type="double" name="dx" />
      <declaration type="Point2D" name="pt1" />
      <scope startLine="2395" endLine="2397" />
      <scope startLine="2398" endLine="2418">
        <declaration type="Rectangle2D" name="srcBounds" />
        <declaration type="PAffineTransform" name="at" />
        <comment>First compute translation amount in global coordinates</comment>
        <comment>Convert vector to local coordinates</comment>
        <comment>Finally, animate change</comment>
      </scope>
    </method>
    <javadoc>
      <deprecated>in favor of animateToRelativePosition
 * It will calculate the necessary transform in order to make
 * this node appear at a particular position relative to the
 * specified bounding box. The source point specifies a point in
 * the unit square (0, 0) - (1, 1) that represents an anchor
 * point on the corresponding node to this transform. The
 * destination point specifies an anchor point on the reference
 * node. The position method then computes the transform that
 * results in transforming this node so that the source anchor
 * point coincides with the reference anchor point. This can be
 * useful for layout algorithms as it is straightforward to
 * position one object relative to another.
 * <p>
 * For example, If you have two nodes, A and B, and you call
 * <PRE>
 * Point2D srcPt = new Point2D.Double(1.0, 0.0);
 * Point2D destPt = new Point2D.Double(0.0, 0.0);
 * A.position(srcPt, destPt, B.getGlobalBounds(), 750, null);
 * </PRE>
 * The result is that A will move so that its upper-right corner
 * is at the same place as the upper-left corner of B, and the
 * transition will be smoothly animated over a period of 750
 * milliseconds.</deprecated>
      <param>srcPt The anchor point on this transform's node (normalized to a
 * unit square)</param>
      <param>destPt The anchor point on destination bounds (normalized to a
 * unit square)</param>
      <param>destBounds The bounds (in global coordinates) used to calculate
 * this transform's node</param>
      <param>millis Number of milliseconds over which to perform the animation</param>
    </javadoc>
    <method type="void" name="position" startLine="2457" endLine="2459" />
    <javadoc>
      <text>* Return a copy of the transform associated with this node.</text>
      <return>copy of this node's transform</return>
    </javadoc>
    <method type="PAffineTransform" name="getTransform" startLine="2466" endLine="2473">
      <scope startLine="2467" endLine="2469" />
      <scope startLine="2470" endLine="2472" />
    </method>
    <javadoc>
      <text>* Return a reference to the transform associated with this node. This
 * returned transform should not be modified. PNode transforms are created
 * lazily when needed. If you access the transform reference before the
 * transform has been created it may return null. The
 * createNewTransformIfNull parameter is used to specify that the PNode
 * should create a new transform (and assign that transform to the nodes
 * local transform variable) instead of returning null.</text>
      <param>createNewTransformIfNull if the transform has not been
 * initialised, should it be?</param>
      <return>reference to this node's transform</return>
    </javadoc>
    <method type="PAffineTransform" name="getTransformReference" startLine="2489" endLine="2494">
      <scope startLine="2490" endLine="2492" />
    </method>
    <javadoc>
      <text>* Return an inverted copy of the transform associated with this node.</text>
      <return>inverted copy of this node's transform</return>
    </javadoc>
    <method type="PAffineTransform" name="getInverseTransform" startLine="2501" endLine="2512">
      <scope startLine="2502" endLine="2504" />
      <scope startLine="2506" endLine="2508" />
      <scope startLine="2509" endLine="2511" />
    </method>
    <javadoc>
      <text>* Set the transform applied to this node.</text>
      <param>transform the new transform value</param>
    </javadoc>
    <method type="void" name="setTransform" startLine="2519" endLine="2530">
      <scope startLine="2520" endLine="2522" />
      <scope startLine="2523" endLine="2525" />
    </method>
    <javadoc>
      <text>* Return true if this nodes paint is invalid, in which case the node needs
 * to be repainted.</text>
      <return>true if this node needs to be repainted</return>
    </javadoc>
    <method type="boolean" name="getPaintInvalid" startLine="2564" endLine="2566" />
    <javadoc>
      <text>* Mark this node as having invalid paint. If this is set the node will
 * later be repainted. Node this method is most often used internally.</text>
      <param>paintInvalid true if this node should be repainted</param>
    </javadoc>
    <method type="void" name="setPaintInvalid" startLine="2574" endLine="2576" />
    <javadoc>
      <text>* Return true if this node has a child with invalid paint.</text>
      <return>true if this node has a child with invalid paint</return>
    </javadoc>
    <method type="boolean" name="getChildPaintInvalid" startLine="2583" endLine="2585" />
    <javadoc>
      <text>* Mark this node as having a child with invalid paint.</text>
      <param>childPaintInvalid true if this node has a child with invalid paint</param>
    </javadoc>
    <method type="void" name="setChildPaintInvalid" startLine="2592" endLine="2594" />
    <javadoc>
      <text>* Invalidate this node's paint, and mark all of its ancestors as having a
 * node with invalid paint.</text>
    </javadoc>
    <method type="void" name="invalidatePaint" startLine="2600" endLine="2612">
      <declaration type="PNode" name="n" />
      <scope startLine="2604" endLine="2607" />
      <scope startLine="2609" endLine="2611" />
    </method>
    <javadoc>
      <text>* Repaint this node and any of its descendants if they have invalid paint.</text>
    </javadoc>
    <method type="void" name="validateFullPaint" startLine="2617" endLine="2631">
      <scope startLine="2618" endLine="2621" />
      <scope startLine="2623" endLine="2630">
        <declaration type="int" name="count" />
        <scope startLine="2625" endLine="2628">
          <declaration type="PNode" name="each" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Mark the area on the screen represented by this nodes full bounds as
 * needing a repaint.</text>
    </javadoc>
    <method type="void" name="repaint" startLine="2637" endLine="2640" />
    <javadoc>
      <text>* Pass the given repaint request up the tree, so that any cameras can
 * invalidate that region on their associated canvas.</text>
      <param>localBounds the bounds to repaint</param>
      <param>childOrThis if childOrThis does not equal this then this nodes
 * transform will be applied to the localBounds param</param>
    </javadoc>
    <method type="void" name="repaintFrom" startLine="2650" endLine="2660">
      <scope startLine="2651" endLine="2659">
        <scope startLine="2652" endLine="2654" />
        <scope startLine="2655" endLine="2657" />
      </scope>
    </method>
    <javadoc>
      <text>* Returns whether this node is Opaque.</text>
      <param>boundary boundary to check and see if this node covers completely.</param>
      <return>true if opaque</return>
    </javadoc>
    <method type="boolean" name="isOpaque" startLine="2674" endLine="2676" />
    <javadoc>
      <text>* Returns whether this node has been flagged as occluded.</text>
      <return>true if occluded</return>
    </javadoc>
    <method type="boolean" name="getOccluded" startLine="2683" endLine="2685" />
    <javadoc>
      <text>* Flags this node as occluded.</text>
      <param>occluded new value for occluded</param>
    </javadoc>
    <method type="void" name="setOccluded" startLine="2692" endLine="2694" />
    <javadoc>
      <text>* Return true if this node is visible, that is if it will paint itself and
 * descendants.</text>
      <return>true if this node and its descendants are visible.</return>
    </javadoc>
    <method type="boolean" name="getVisible" startLine="2724" endLine="2726" />
    <javadoc>
      <text>* Set the visibility of this node and its descendants.</text>
      <param>isVisible true if this node and its descendants are visible</param>
    </javadoc>
    <method type="void" name="setVisible" startLine="2733" endLine="2742">
      <scope startLine="2734" endLine="2741">
        <scope startLine="2735" endLine="2737" />
      </scope>
    </method>
    <javadoc>
      <text>* Return the paint used while painting this node. This value may be null.</text>
      <return>the paint used while painting this node.</return>
    </javadoc>
    <method type="Paint" name="getPaint" startLine="2749" endLine="2751" />
    <javadoc>
      <text>* Set the paint used to paint this node, which may be null.</text>
      <param>newPaint paint that this node should use when painting itself.</param>
    </javadoc>
    <method type="void" name="setPaint" startLine="2758" endLine="2767">
      <scope startLine="2759" endLine="2761" />
      <declaration type="Paint" name="oldPaint" />
    </method>
    <javadoc>
      <text>* Return the transparency used when painting this node. Note that this
 * transparency is also applied to all of the node's descendants.</text>
      <return>how transparent this node is 0f = completely transparent, 1f =
 * completely opaque</return>
    </javadoc>
    <method type="float" name="getTransparency" startLine="2776" endLine="2778" />
    <javadoc>
      <text>* Set the transparency used to paint this node. Note that this transparency
 * applies to this node and all of its descendants.</text>
      <param>newTransparency transparency value for this node. 0f = fully
 * transparent, 1f = fully opaque</param>
    </javadoc>
    <method type="void" name="setTransparency" startLine="2787" endLine="2795">
      <scope startLine="2788" endLine="2794">
        <declaration type="float" name="oldTransparency" />
      </scope>
    </method>
    <javadoc>
      <text>* Paint this node behind any of its children nodes. Subclasses that define
 * a different appearance should override this method and paint themselves
 * there.</text>
      <param>paintContext the paint context to use for painting the node</param>
    </javadoc>
    <method type="void" name="paint" startLine="2804" endLine="2810">
      <scope startLine="2805" endLine="2809">
        <declaration type="Graphics2D" name="g2" />
      </scope>
    </method>
    <javadoc>
      <text>* Paint this node and all of its descendants. Most subclasses do not need
 * to override this method, they should override <code>paint</code> or
 * <code>paintAfterChildren</code> instead.</text>
      <param>paintContext the paint context to use for painting this node and
 * its children</param>
    </javadoc>
    <method type="void" name="fullPaint" startLine="2820" endLine="2840">
      <scope startLine="2821" endLine="2839">
        <scope startLine="2825" endLine="2827" />
        <declaration type="int" name="count" />
        <scope startLine="2830" endLine="2833">
          <declaration type="PNode" name="each" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Subclasses that wish to do additional painting after their children are
 * painted should override this method and do that painting here.</text>
      <param>paintContext the paint context to sue for painting after the
 * children are painted</param>
    </javadoc>
    <method type="void" name="paintAfterChildren" startLine="2849" endLine="2850" />
    <javadoc>
      <text>* Return a new Image representing this node and all of its children. The
 * image size will be equal to the size of this nodes full bounds.</text>
      <return>a new image representing this node and its descendants</return>
    </javadoc>
    <method type="Image" name="toImage" startLine="2858" endLine="2861">
      <declaration type="PBounds" name="b" />
    </method>
    <javadoc>
      <text>* Return a new Image of the requested size representing this node and all
 * of its children. If backGroundPaint is null the resulting image will have
 * transparent regions, otherwise those regions will be filled with the
 * backgroundPaint.</text>
      <param>width pixel width of the resulting image</param>
      <param>height pixel height of the resulting image</param>
      <param>backgroundPaint paint to fill the image with before drawing this
 * node, may be null</param>
      <return>a new image representing this node and its descendants</return>
    </javadoc>
    <method type="Image" name="toImage" startLine="2876" endLine="2889">
      <declaration type="BufferedImage" name="result" />
      <scope startLine="2879" endLine="2881" />
      <scope startLine="2882" endLine="2886">
        <declaration type="GraphicsConfiguration" name="graphicsConfiguration" />
      </scope>
    </method>
    <javadoc>
      <text>* Paint a representation of this node into the specified buffered image. If
 * background, paint is null, then the image will not be filled with a color
 * prior to rendering</text>
      <param>image Image onto which this node will be painted</param>
      <param>backGroundPaint will fill background of image with this. May be
 * null.</param>
      <return>a rendering of this image and its descendants onto the specified
 * image</return>
    </javadoc>
    <method type="Image" name="toImage" startLine="2902" endLine="2904" />
    <javadoc>
      <text>* Paint a representation of this node into the specified buffered image. If
 * background, paint is null, then the image will not be filled with a color
 * prior to rendering</text>
      <since>1.3</since>
      <param>image Image onto which this node will be painted</param>
      <param>backGroundPaint will fill background of image with this. May be
 * null.</param>
      <param>fillStrategy strategy to use regarding how node will cover the
 * image</param>
      <return>a rendering of this image and its descendants onto the specified
 * image</return>
    </javadoc>
    <method type="Image" name="toImage" startLine="2920" endLine="2979">
      <declaration type="int" name="imageWidth" />
      <declaration type="int" name="imageHeight" />
      <declaration type="Graphics2D" name="g2" />
      <scope startLine="2925" endLine="2928" />
      <declaration type="PBounds" name="nodeBounds" />
      <declaration type="double" name="nodeWidth" />
      <declaration type="double" name="nodeHeight" />
      <declaration type="double" name="imageRatio" />
      <declaration type="double" name="nodeRatio" />
      <declaration type="double" name="scale" />
      <scope startLine="2945" endLine="2947" />
      <scope startLine="2948" endLine="2950" />
      <scope startLine="2957" endLine="2959" />
      <scope startLine="2960" endLine="2962" />
      <declaration type="PPaintContext" name="pc" />
      <comment>scale the graphics so node's full bounds fit in the imageable</comment>
      <comment>bounds but aspect ration is retained</comment>
      <comment>scale the graphics so node completely covers the imageable</comment>
      <comment>area, but retains its aspect ratio.</comment>
      <comment>scale the node so that it covers then entire image,</comment>
      <comment>distorting it if necessary.</comment>
    </method>
    <javadoc>
      <text>* Constructs a new PrinterJob, allows the user to select which printer to
 * print to, And then prints the node.</text>
    </javadoc>
    <method type="void" name="print" startLine="2985" endLine="3000">
      <declaration type="PrinterJob" name="printJob" />
      <declaration type="PageFormat" name="pageFormat" />
      <declaration type="Book" name="book" />
      <scope startLine="2992" endLine="2999">
        <scope startLine="2993" endLine="2995" />
        <scope startLine="2996" endLine="2998" />
      </scope>
    </method>
    <javadoc>
      <text>* Prints the node into the given Graphics context using the specified
 * format. The zero based index of the requested page is specified by
 * pageIndex. If the requested page does not exist then this method returns
 * NO_SUCH_PAGE; otherwise PAGE_EXISTS is returned. If the printable object
 * aborts the print job then it throws a PrinterException.</text>
      <param>graphics the context into which the node is drawn</param>
      <param>pageFormat the size and orientation of the page</param>
      <param>pageIndex the zero based index of the page to be drawn</param>
      <return>Either NO_SUCH_PAGE or PAGE_EXISTS</return>
    </javadoc>
    <method type="int" name="print" startLine="3015" endLine="3046">
      <scope startLine="3016" endLine="3018" />
      <scope startLine="3020" endLine="3022" />
      <declaration type="Graphics2D" name="g2" />
      <declaration type="PBounds" name="imageBounds" />
      <declaration type="double" name="scale" />
      <scope startLine="3034" endLine="3036" />
      <declaration type="PPaintContext" name="pc" />
      <comment>scale the graphics so node's full bounds fit in the imageable bounds.</comment>
    </method>
    <javadoc>
      <text>* Return true if this node is pickable. Only pickable nodes can receive
 * input events. Nodes are pickable by default.</text>
      <return>true if this node is pickable</return>
    </javadoc>
    <method type="boolean" name="getPickable" startLine="3083" endLine="3085" />
    <javadoc>
      <text>* Set the pickable flag for this node. Only pickable nodes can receive
 * input events. Nodes are pickable by default.</text>
      <param>isPickable true if this node is pickable</param>
    </javadoc>
    <method type="void" name="setPickable" startLine="3093" endLine="3098">
      <scope startLine="3094" endLine="3097" />
    </method>
    <javadoc>
      <text>* Return true if the children of this node should be picked. If this flag
 * is false then this node will not try to pick its children. Children are
 * pickable by default.</text>
      <return>true if this node tries to pick its children</return>
    </javadoc>
    <method type="boolean" name="getChildrenPickable" startLine="3107" endLine="3109" />
    <javadoc>
      <text>* Set the children pickable flag. If this flag is false then this node will
 * not try to pick its children. Children are pickable by default.</text>
      <param>areChildrenPickable true if this node tries to pick its children</param>
    </javadoc>
    <method type="void" name="setChildrenPickable" startLine="3117" endLine="3122">
      <scope startLine="3118" endLine="3121" />
    </method>
    <javadoc>
      <text>* Try to pick this node before its children have had a chance to be picked.
 * Nodes that paint on top of their children may want to override this
 * method to if the pick path intersects that paint.</text>
      <param>pickPath the pick path used for the pick operation</param>
      <return>true if this node was picked</return>
    </javadoc>
    <method type="boolean" name="pick" startLine="3132" endLine="3134" />
    <javadoc>
      <text>* Try to pick this node and all of its descendants. Most subclasses should
 * not need to override this method. Instead they should override
 * <code>pick</code> or <code>pickAfterChildren</code>.</text>
      <param>pickPath the pick path to add the node to if its picked</param>
      <return>true if this node or one of its descendants was picked.</return>
    </javadoc>
    <method type="boolean" name="fullPick" startLine="3144" endLine="3174">
      <scope startLine="3145" endLine="3171">
        <declaration type="boolean" name="thisPickable" />
        <scope startLine="3151" endLine="3153" />
        <scope startLine="3155" endLine="3163">
          <declaration type="int" name="count" />
          <scope startLine="3157" endLine="3162">
            <declaration type="PNode" name="each" />
            <scope startLine="3159" endLine="3161" />
          </scope>
        </scope>
        <scope startLine="3165" endLine="3167" />
      </scope>
    </method>
    <javadoc>
      <text>* Finds all descendants of this node that intersect with the given bounds
 * and adds them to the results array.</text>
      <param>fullBounds bounds to compare against</param>
      <param>results array into which to add matches</param>
    </javadoc>
    <method type="void" name="findIntersectingNodes" startLine="3183" endLine="3197">
      <scope startLine="3184" endLine="3196">
        <declaration type="Rectangle2D" name="localBounds" />
        <scope startLine="3187" endLine="3189" />
        <declaration type="int" name="count" />
        <scope startLine="3192" endLine="3195">
          <declaration type="PNode" name="each" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Try to pick this node after its children have had a chance to be picked.
 * Most subclasses the define a different geometry will need to override
 * this method.</text>
      <param>pickPath the pick path used for the pick operation</param>
      <return>true if this node was picked</return>
    </javadoc>
    <method type="boolean" name="pickAfterChildren" startLine="3207" endLine="3212">
      <scope startLine="3208" endLine="3210" />
    </method>
    <javadoc>
      <text>* Add a node to be a new child of this node. The new node is added to the
 * end of the list of this node's children. If child was previously a child
 * of another node, it is removed from that first.</text>
      <param>child the new child to add to this node</param>
    </javadoc>
    <method type="void" name="addChild" startLine="3229" endLine="3235">
      <declaration type="int" name="insertIndex" />
      <scope startLine="3231" endLine="3233" />
    </method>
    <javadoc>
      <text>* Add a node to be a new child of this node at the specified index. If
 * child was previously a child of another node, it is removed from that
 * node first.</text>
      <param>index where in the children list to insert the child</param>
      <param>child the new child to add to this node</param>
    </javadoc>
    <method type="void" name="addChild" startLine="3245" endLine="3258">
      <declaration type="PNode" name="oldParent" />
      <scope startLine="3248" endLine="3250" />
    </method>
    <javadoc>
      <text>* Add a collection of nodes to be children of this node. If these nodes
 * already have parents they will first be removed from those parents.</text>
      <param>nodes a collection of nodes to be added to this node</param>
    </javadoc>
    <method type="void" name="addChildren" startLine="3266" endLine="3272">
      <declaration type="Iterator" name="i" />
      <scope startLine="3268" endLine="3271">
        <declaration type="PNode" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* Return true if this node is an ancestor of the parameter node.</text>
      <param>node a possible descendant node</param>
      <return>true if this node is an ancestor of the given node</return>
    </javadoc>
    <method type="boolean" name="isAncestorOf" startLine="3280" endLine="3289">
      <declaration type="PNode" name="p" />
      <scope startLine="3282" endLine="3287">
        <scope startLine="3283" endLine="3285" />
      </scope>
    </method>
    <javadoc>
      <text>* Return true if this node is a descendant of the parameter node.</text>
      <param>node a possible ancestor node</param>
      <return>true if this nodes descends from the given node</return>
    </javadoc>
    <method type="boolean" name="isDescendentOf" startLine="3297" endLine="3306">
      <declaration type="PNode" name="p" />
      <scope startLine="3299" endLine="3304">
        <scope startLine="3300" endLine="3302" />
      </scope>
    </method>
    <javadoc>
      <text>* Return true if this node descends from the root.</text>
      <return>whether this node descends from root node</return>
    </javadoc>
    <method type="boolean" name="isDescendentOfRoot" startLine="3313" endLine="3315" />
    <javadoc>
      <text>* Change the order of this node in its parent's children list so that it
 * will draw in back of all of its other sibling nodes.</text>
    </javadoc>
    <method type="void" name="moveToBack" startLine="3321" endLine="3327">
      <declaration type="PNode" name="p" />
      <scope startLine="3323" endLine="3326" />
    </method>
    <javadoc>
      <text>* Change the order of this node in its parent's children list so that it
 * will draw in back of the specified sibling node.</text>
      <param>sibling sibling to move in back of</param>
    </javadoc>
    <method type="void" name="moveInBackOf" startLine="3335" endLine="3342">
      <declaration type="PNode" name="p" />
      <scope startLine="3337" endLine="3341">
        <declaration type="int" name="index" />
      </scope>
    </method>
    <javadoc>
      <text>* Change the order of this node in its parent's children list so that it
 * will draw in front of all of its other sibling nodes.</text>
    </javadoc>
    <method type="void" name="moveToFront" startLine="3348" endLine="3354">
      <declaration type="PNode" name="p" />
      <scope startLine="3350" endLine="3353" />
    </method>
    <javadoc>
      <text>* Change the order of this node in its parent's children list so that it
 * will draw in front of the specified sibling node.</text>
      <param>sibling sibling to move in front of</param>
    </javadoc>
    <method type="void" name="moveInFrontOf" startLine="3362" endLine="3369">
      <declaration type="PNode" name="p" />
      <scope startLine="3364" endLine="3368">
        <declaration type="int" name="index" />
      </scope>
    </method>
    <javadoc>
      <text>* Return the parent of this node. This will be null if this node has not
 * been added to a parent yet.</text>
      <return>this nodes parent or null</return>
    </javadoc>
    <method type="PNode" name="getParent" startLine="3377" endLine="3379" />
    <javadoc>
      <text>* Set the parent of this node. Note this is set automatically when adding
 * and removing children.</text>
      <param>newParent the parent to which this node should be added</param>
    </javadoc>
    <method type="void" name="setParent" startLine="3387" endLine="3391">
      <declaration type="PNode" name="old" />
    </method>
    <javadoc>
      <text>* Return the index where the given child is stored.</text>
      <param>child child so search for</param>
      <return>index of child or -1 if not found</return>
    </javadoc>
    <method type="int" name="indexOfChild" startLine="3399" endLine="3404">
      <scope startLine="3400" endLine="3402" />
    </method>
    <javadoc>
      <text>* Remove the given child from this node's children list. Any subsequent
 * children are shifted to the left (one is subtracted from their indices).
 * The removed child's parent is set to null.</text>
      <param>child the child to remove</param>
      <return>the removed child</return>
    </javadoc>
    <method type="PNode" name="removeChild" startLine="3414" endLine="3420">
      <declaration type="int" name="index" />
      <scope startLine="3416" endLine="3418" />
    </method>
    <javadoc>
      <text>* Remove the child at the specified position of this group node's children.
 * Any subsequent children are shifted to the left (one is subtracted from
 * their indices). The removed child's parent is set to null.</text>
      <param>index the index of the child to remove</param>
      <return>the removed child</return>
    </javadoc>
    <method type="PNode" name="removeChild" startLine="3430" endLine="3447">
      <scope startLine="3431" endLine="3433" />
      <declaration type="PNode" name="child" />
      <scope startLine="3436" endLine="3438" />
    </method>
    <javadoc>
      <text>* Remove all the children in the given collection from this node's list of
 * children. All removed nodes will have their parent set to null.</text>
      <param>childrenNodes the collection of children to remove</param>
    </javadoc>
    <method type="void" name="removeChildren" startLine="3455" endLine="3461">
      <declaration type="Iterator" name="i" />
      <scope startLine="3457" endLine="3460">
        <declaration type="PNode" name="each" />
      </scope>
    </method>
    <javadoc>
      <text>* Remove all the children from this node. Node this method is more
 * efficient then removing each child individually.</text>
    </javadoc>
    <method type="void" name="removeAllChildren" startLine="3467" endLine="3480">
      <scope startLine="3468" endLine="3479">
        <declaration type="int" name="count" />
        <scope startLine="3470" endLine="3473">
          <declaration type="PNode" name="each" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Delete this node by removing it from its parent's list of children.</text>
    </javadoc>
    <method type="void" name="removeFromParent" startLine="3485" endLine="3489">
      <scope startLine="3486" endLine="3488" />
    </method>
    <javadoc>
      <text>* Set the parent of this node, and transform the node in such a way that it
 * doesn't move in global coordinates.</text>
      <param>newParent The new parent of this node.</param>
    </javadoc>
    <method type="void" name="reparent" startLine="3497" endLine="3506">
      <declaration type="AffineTransform" name="originalTransform" />
      <declaration type="AffineTransform" name="newTransform" />
    </method>
    <javadoc>
      <text>* Swaps this node out of the scene graph tree, and replaces it with the
 * specified replacement node. This node is left dangling, and it is up to
 * the caller to manage it. The replacement node will be added to this
 * node's parent in the same position as this was. That is, if this was the
 * 3rd child of its parent, then after calling replaceWith(), the
 * replacement node will also be the 3rd child of its parent. If this node
 * has no parent when replace is called, then nothing will be done at all.</text>
      <param>replacementNode the new node that replaces the current node in the
 * scene graph tree.</param>
    </javadoc>
    <method type="void" name="replaceWith" startLine="3520" endLine="3527">
      <scope startLine="3521" endLine="3526">
        <declaration type="PNode" name="p" />
        <declaration type="int" name="index" />
      </scope>
    </method>
    <javadoc>
      <text>* Sets the name of this null, may be null.</text>
      <since>1.3</since>
      <param>name new name for this node</param>
    </javadoc>
    <method type="void" name="setName" startLine="3535" endLine="3537" />
    <javadoc>
      <text>* Returns the name given to this node.</text>
      <since>1.3</since>
      <return>name given to this node, may be null</return>
    </javadoc>
    <method type="String" name="getName" startLine="3545" endLine="3547" />
    <javadoc>
      <text>* Return the number of children that this node has.</text>
      <return>the number of children</return>
    </javadoc>
    <method type="int" name="getChildrenCount" startLine="3554" endLine="3559">
      <scope startLine="3555" endLine="3557" />
    </method>
    <javadoc>
      <text>* Return the child node at the specified index.</text>
      <param>index a child index</param>
      <return>the child node at the specified index</return>
    </javadoc>
    <method type="PNode" name="getChild" startLine="3567" endLine="3569" />
    <javadoc>
      <text>* Return a reference to the list used to manage this node's children. This
 * list should not be modified.</text>
      <return>reference to the children list</return>
    </javadoc>
    <method type="List" name="getChildrenReference" startLine="3577" endLine="3582">
      <scope startLine="3578" endLine="3580" />
    </method>
    <javadoc>
      <text>* Return an iterator over this node's direct descendant children.</text>
      <return>iterator over this nodes children</return>
    </javadoc>
    <method type="ListIterator" name="getChildrenIterator" startLine="3589" endLine="3594">
      <scope startLine="3590" endLine="3592" />
    </method>
    <javadoc>
      <text>* Return the root node (instance of PRoot). If this node does not descend
 * from a PRoot then null will be returned.</text>
      <return>root element of this node, or null if this node does not descend
 * from a PRoot</return>
    </javadoc>
    <method type="PRoot" name="getRoot" startLine="3603" endLine="3608">
      <scope startLine="3604" endLine="3606" />
    </method>
    <javadoc>
      <text>* Return a collection containing this node and all of its descendant nodes.</text>
      <return>a new collection containing this node and all descendants</return>
    </javadoc>
    <method type="Collection" name="getAllNodes" startLine="3615" endLine="3617" />
    <javadoc>
      <text>* Return a collection containing the subset of this node and all of its
 * descendant nodes that are accepted by the given node filter. If the
 * filter is null then all nodes will be accepted. If the results parameter
 * is not null then it will be used to collect this subset instead of
 * creating a new collection.</text>
      <param>filter the filter used to determine the subset</param>
      <param>resultantNodes where matching nodes should be added</param>
      <return>a collection containing this node and all descendants</return>
    </javadoc>
    <method type="Collection" name="getAllNodes" startLine="3630" endLine="3652">
      <declaration type="Collection" name="results" />
      <scope startLine="3632" endLine="3634" />
      <scope startLine="3635" endLine="3637" />
      <scope startLine="3639" endLine="3641" />
      <scope startLine="3643" endLine="3649">
        <declaration type="int" name="count" />
        <scope startLine="3645" endLine="3648">
          <declaration type="PNode" name="each" />
        </scope>
      </scope>
    </method>
    <javadoc>
      <text>* Write this node and all of its descendant nodes to the given outputsteam.
 * This stream must be an instance of PObjectOutputStream or serialization
 * will fail. This nodes parent is written out conditionally, that is it
 * will only be written out if someone else writes it out unconditionally.</text>
      <param>out the output stream to write to, must be an instance of
 * PObjectOutputStream</param>
      <throws>IOException when an error occurs speaking to underlying
 * ObjectOutputStream</throws>
    </javadoc>
    <method type="void" name="writeObject" startLine="3672" endLine="3678">
      <scope startLine="3673" endLine="3675" />
    </method>
    <javadoc>
      <text>* Read this node and all of its descendants in from the given input stream.</text>
      <param>in the stream to read from</param>
      <throws>IOException when an error occurs speaking to underlying
 * ObjectOutputStream</throws>
      <throws>ClassNotFoundException when a class is deserialized that no
 * longer exists. This can happen if it's renamed or deleted.</throws>
    </javadoc>
    <method type="void" name="readObject" startLine="3690" endLine="3693" />
    <javadoc>
      <deprecated>see http://code.google.com/p/piccolo2d/issues/detail?id=99</deprecated>
      <return>a string representation of this node's state</return>
    </javadoc>
    <method type="String" name="paramString" startLine="3700" endLine="3702" />
    <javadoc>
      <text>* Returns an array of input event listeners that are attached to this node.</text>
      <since>1.3</since>
      <return>event listeners attached to this node</return>
    </javadoc>
    <method type="PInputEventListener[]" name="getInputEventListeners" startLine="3710" endLine="3722">
      <scope startLine="3711" endLine="3713" />
      <declaration type="EventListener[]" name="listeners" />
      <declaration type="PInputEventListener[]" name="result" />
      <scope startLine="3718" endLine="3720" />
    </method>
    <class name="ClientPropertyKeyIterator" startLine="3724">
      <implements name="Iterator" />
      <declaration type="Enumeration" name="enumeration" />
      <method type="constructor" name="ClientPropertyKeyIterator" startLine="3727" endLine="3729" />
      <method type="boolean" name="hasNext" startLine="3731" endLine="3733" />
      <method type="Object" name="next" startLine="3735" endLine="3737" />
      <method type="void" name="remove" startLine="3739" endLine="3741" />
      <interface name="PSceneGraphDelegate" startLine="3744">
        <javadoc>
          <text>* <b>PSceneGraphDelegate</b> is an interface to receive low level node
 * events. It together with PNode.SCENE_GRAPH_DELEGATE gives Piccolo2d users
 * an efficient way to learn about low level changes in Piccolo's scene
 * graph. Most users will not need to use this.</text>
        </javadoc>
        <method name="nodePaintInvalidated" type="void" startLine="3751" endLine="3756" />
        <javadoc>
          <text>* Called to notify delegate that the node needs repainting.</text>
          <param>node node needing repaint</param>
        </javadoc>
        <method name="nodeFullBoundsInvalidated" type="void" startLine="3758" endLine="3764" />
        <javadoc>
          <text>* Called to notify delegate that the node and all it's children need
 * repainting.</text>
          <param>node node needing repaint</param>
        </javadoc>
      </interface>
    </class>
    <comment>****************************************************************</comment>
    <comment>Animation - Methods to animate this node.</comment>
    <comment />
    <comment>Note that animation is implemented by activities (PActivity),</comment>
    <comment>so if you need more control over your animation look at the</comment>
    <comment>activities package. Each animate method creates an animation that</comment>
    <comment>will animate the node from its current state to the new state</comment>
    <comment>specified over the given duration. These methods will try to</comment>
    <comment>automatically schedule the new activity, but if the node does not</comment>
    <comment>descend from the root node when the method is called then the</comment>
    <comment>activity will not be scheduled and you must schedule it manually.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Client Properties - Methods for managing client properties for</comment>
    <comment>this node.</comment>
    <comment />
    <comment>Client properties provide a way for programmers to attach</comment>
    <comment>extra information to a node without having to subclass it and</comment>
    <comment>add new instance variables.</comment>
    <comment>****************************************************************</comment>
    <comment>convenience methods for attributes</comment>
    <comment>****************************************************************</comment>
    <comment>Copying - Methods for copying this node and its descendants.</comment>
    <comment>Copying is implemented in terms of serialization.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Coordinate System Conversions - Methods for converting</comment>
    <comment>geometry between this nodes local coordinates and the other</comment>
    <comment>major coordinate systems.</comment>
    <comment />
    <comment>Each nodes has an affine transform that it uses to define its</comment>
    <comment>own coordinate system. For example if you create a new node and</comment>
    <comment>add it to the canvas it will appear in the upper right corner. Its</comment>
    <comment>coordinate system matches the coordinate system of its parent</comment>
    <comment>(the root node) at this point. But if you move this node by calling</comment>
    <comment>node.translate() the nodes affine transform will be modified and the</comment>
    <comment>node will appear at a different location on the screen. The node</comment>
    <comment>coordinate system no longer matches the coordinate system of its</comment>
    <comment>parent.</comment>
    <comment />
    <comment>This is useful because it means that the node's methods for</comment>
    <comment>rendering and picking don't need to worry about the fact that</comment>
    <comment>the node has been moved to another position on the screen, they</comment>
    <comment>keep working just like they did when it was in the upper right</comment>
    <comment>hand corner of the screen.</comment>
    <comment />
    <comment>The problem is now that each node defines its own coordinate</comment>
    <comment>system it is difficult to compare the positions of two node with</comment>
    <comment>each other. These methods are all meant to help solve that problem.</comment>
    <comment />
    <comment>The terms used in the methods are as follows:</comment>
    <comment />
    <comment>local - The local or base coordinate system of a node.</comment>
    <comment>parent - The coordinate system of a node's parent</comment>
    <comment>global - The topmost coordinate system, above the root node.</comment>
    <comment />
    <comment>Normally when comparing the positions of two nodes you will</comment>
    <comment>convert the local position of each node to the global coordinate</comment>
    <comment>system, and then compare the positions in that common coordinate</comment>
    <comment>system.</comment>
    <comment>***************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Event Listeners - Methods for adding and removing event listeners</comment>
    <comment>from a node.</comment>
    <comment />
    <comment>Here methods are provided to add property change listeners and</comment>
    <comment>input event listeners. The property change listeners are notified</comment>
    <comment>when certain properties of this node change, and the input event</comment>
    <comment>listeners are notified when the nodes receives new key and mouse</comment>
    <comment>events.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Bounds Geometry - Methods for setting and querying the bounds</comment>
    <comment>of this node.</comment>
    <comment />
    <comment>The bounds of a node store the node's position and size in</comment>
    <comment>the nodes local coordinate system. Many node subclasses will need</comment>
    <comment>to override the setBounds method so that they can update their</comment>
    <comment>internal state appropriately. See PPath for an example.</comment>
    <comment />
    <comment>Since the bounds are stored in the local coordinate system</comment>
    <comment>they WILL NOT change if the node is scaled, translated, or rotated.</comment>
    <comment />
    <comment>The bounds may be accessed with either getBounds, or</comment>
    <comment>getBoundsReference. The former returns a copy of the bounds</comment>
    <comment>the latter returns a reference to the nodes bounds that should</comment>
    <comment>normally not be modified. If a node is marked as volatile then</comment>
    <comment>it may modify its bounds before returning them from getBoundsReference,</comment>
    <comment>otherwise it may not.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Full Bounds - Methods for computing and querying the</comment>
    <comment>full bounds of this node.</comment>
    <comment />
    <comment>The full bounds of a node store the nodes bounds</comment>
    <comment>together with the union of the bounds of all the</comment>
    <comment>node's descendants. The full bounds are stored in the parent</comment>
    <comment>coordinate system of this node, the full bounds DOES change</comment>
    <comment>when you translate, scale, or rotate this node.</comment>
    <comment />
    <comment>The full bounds may be accessed with either getFullBounds, or</comment>
    <comment>getFullBoundsReference. The former returns a copy of the full bounds</comment>
    <comment>the latter returns a reference to the node's full bounds that should</comment>
    <comment>not be modified.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Bounds Damage Management - Methods used to invalidate and validate</comment>
    <comment>the bounds of nodes.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Node Transform - Methods to manipulate the node's transform.</comment>
    <comment />
    <comment>Each node has a transform that is used to define the nodes</comment>
    <comment>local coordinate system. IE it is applied before picking and</comment>
    <comment>rendering the node.</comment>
    <comment />
    <comment>The usual way to move nodes about on the canvas is to manipulate</comment>
    <comment>this transform, as opposed to changing the bounds of the</comment>
    <comment>node.</comment>
    <comment />
    <comment>Since this transform defines the local coordinate system of this</comment>
    <comment>node the following methods with affect the global position both</comment>
    <comment>this node and all of its descendants.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Paint Damage Management - Methods used to invalidate the areas of</comment>
    <comment>the screen that this node appears in so that they will later get</comment>
    <comment>painted.</comment>
    <comment />
    <comment>Generally you will not need to call these invalidate methods</comment>
    <comment>when starting out with Piccolo2d because methods such as setPaint</comment>
    <comment>already automatically call them for you. You will need to call</comment>
    <comment>them when you start creating your own nodes.</comment>
    <comment />
    <comment>When you do create you own nodes the only method that you will</comment>
    <comment>normally need to call is invalidatePaint. This method marks the</comment>
    <comment>nodes as having invalid paint, the root node's UI cycle will then</comment>
    <comment>later discover this damage and report it to the Java repaint manager.</comment>
    <comment />
    <comment>Repainting is normally done with PNode.invalidatePaint() instead of</comment>
    <comment>directly calling PNode.repaint() because PNode.repaint() requires</comment>
    <comment>the nodes bounds to be computed right away. But with invalidatePaint</comment>
    <comment>the bounds computation can be delayed until the end of the root's UI</comment>
    <comment>cycle, and this can add up to a bit savings when modifying a</comment>
    <comment>large number of nodes all at once.</comment>
    <comment />
    <comment>The other methods here will rarely be called except internally</comment>
    <comment>from the framework.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Occluding - Methods to support occluding optimisation. Not yet</comment>
    <comment>complete.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Painting - Methods for painting this node and its children</comment>
    <comment />
    <comment>Painting is how a node defines its visual representation on the</comment>
    <comment>screen, and is done in the local coordinate system of the node.</comment>
    <comment />
    <comment>The default painting behavior is to first paint the node, and</comment>
    <comment>then paint the node's children on top of the node. If a node</comment>
    <comment>needs wants specialised painting behavior it can override:</comment>
    <comment />
    <comment>paint() - Painting here will happen before the children</comment>
    <comment>are painted, so the children will be painted on top of painting done</comment>
    <comment>here.</comment>
    <comment>paintAfterChildren() - Painting here will happen after the children</comment>
    <comment>are painted, so it will paint on top of them.</comment>
    <comment />
    <comment>Note that you should not normally need to override fullPaint().</comment>
    <comment />
    <comment>The visible flag can be used to make a node invisible so that</comment>
    <comment>it will never get painted.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Picking - Methods for picking this node and its children.</comment>
    <comment />
    <comment>Picking is used to determine the node that intersects a point or</comment>
    <comment>rectangle on the screen. It is most frequently used by the</comment>
    <comment>PInputManager to determine the node that the cursor is over.</comment>
    <comment />
    <comment>The intersects() method is used to determine if a node has</comment>
    <comment>been picked or not. The default implementation just test to see</comment>
    <comment>if the pick bounds intersects the bounds of the node. Subclasses</comment>
    <comment>whose geometry (a circle for example) does not match up exactly with</comment>
    <comment>the bounds should override the intersects() method.</comment>
    <comment />
    <comment>The default picking behavior is to first try to pick the nodes</comment>
    <comment>children, and then try to pick the nodes own bounds. If a node</comment>
    <comment>wants specialized picking behavior it can override:</comment>
    <comment />
    <comment>pick() - Pick nodes here that should be picked before the nodes</comment>
    <comment>children are picked.</comment>
    <comment>pickAfterChildren() - Pick nodes here that should be picked after the</comment>
    <comment>node's children are picked.</comment>
    <comment />
    <comment>Note that fullPick should not normally be overridden.</comment>
    <comment />
    <comment>The pickable and childrenPickable flags can be used to make a</comment>
    <comment>node or it children not pickable even if their geometry does</comment>
    <comment>intersect the pick bounds.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Structure - Methods for manipulating and traversing the</comment>
    <comment>parent child relationship</comment>
    <comment />
    <comment>Most of these methods won't need to be overridden by subclasses</comment>
    <comment>but you will use them frequently to build up your node structures.</comment>
    <comment>****************************************************************</comment>
    <comment>****************************************************************</comment>
    <comment>Serialization - Nodes conditionally serialize their parent.</comment>
    <comment>This means that only the parents that were unconditionally</comment>
    <comment>(using writeObject) serialized by someone else will be restored</comment>
    <comment>when the node is unserialized.</comment>
    <comment>****************************************************************</comment>
  </class>
</source>
