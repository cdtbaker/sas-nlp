<?xml version="1.0" encoding="UTF-8"?>
<source package="edu.umd.cs.piccolox.nodes">
  <import name="java.awt.Color" />
  <import name="java.awt.Font" />
  <import name="java.awt.FontMetrics" />
  <import name="java.awt.Graphics2D" />
  <import name="java.awt.Insets" />
  <import name="java.awt.font.FontRenderContext" />
  <import name="java.awt.font.LineBreakMeasurer" />
  <import name="java.awt.font.TextAttribute" />
  <import name="java.awt.font.TextLayout" />
  <import name="java.awt.geom.Line2D" />
  <import name="java.awt.geom.Rectangle2D" />
  <import name="java.text.AttributedCharacterIterator" />
  <import name="java.text.AttributedString" />
  <import name="java.util.ArrayList" />
  <import name="java.util.Iterator" />
  <import name="java.util.List" />
  <import name="java.util.StringTokenizer" />
  <import name="javax.swing.text.AttributeSet" />
  <import name="javax.swing.text.BadLocationException" />
  <import name="javax.swing.text.DefaultStyledDocument" />
  <import name="javax.swing.text.Document" />
  <import name="javax.swing.text.Element" />
  <import name="javax.swing.text.StyleConstants" />
  <import name="javax.swing.text.StyleContext" />
  <import name="edu.umd.cs.piccolo.PNode" />
  <import name="edu.umd.cs.piccolo.util.PPaintContext" />
  <class name="PStyledText" extends="PNode" startLine="60">
    <javadoc>
      <author>Lance Good</author>
    </javadoc>
    <declaration type="long" name="serialVersionUID" />
    <javadoc>
      <text>* Font rendering context used for all PStyledText instances.</text>
    </javadoc>
    <declaration type="FontRenderContext" name="SWING_FRC" />
    <javadoc>
      <text>* Used while painting underlines.</text>
    </javadoc>
    <declaration type="Line2D" name="paintLine" />
    <javadoc>
      <text>* Underlying document used to handle the complexities involved with
 * arbitrary text and formatting.</text>
    </javadoc>
    <declaration type="Document" name="document" />
    <javadoc>
      <text>* String contents of the document.</text>
    </javadoc>
    <declaration type="ArrayList" name="stringContents" />
    <javadoc>
      <text>* Tracks the information about line metrics within the document.</text>
    </javadoc>
    <declaration type="LineInfo[]" name="lines" />
    <javadoc>
      <text>* Whether this node is currently being edited.</text>
    </javadoc>
    <declaration type="boolean" name="editing" />
    <javadoc>
      <text>* Insets represent how far away from the bounding box text will be drawn.</text>
    </javadoc>
    <declaration type="Insets" name="insets" />
    <javadoc>
      <text>* Whether width will be forced to match containing text's height.</text>
    </javadoc>
    <declaration type="boolean" name="constrainHeightToTextHeight" />
    <javadoc>
      <text>* Whether width will be forced to match containing text's width.</text>
    </javadoc>
    <declaration type="boolean" name="constrainWidthToTextWidth" />
    <javadoc>
      <text>* Constructs an empty PStyledText element.</text>
    </javadoc>
    <method type="constructor" name="PStyledText" startLine="100" endLine="101" />
    <javadoc>
      <text>* Controls whether this node changes its width to fit the width of its
 * text. If flag is true it does; if flag is false it doesn't</text>
      <param>constrainWidthToTextWidth whether node's width should be
 * constrained to the width of its text</param>
    </javadoc>
    <method type="void" name="setConstrainWidthToTextWidth" startLine="110" endLine="113" />
    <javadoc>
      <text>* Controls whether this node changes its height to fit the height of its
 * text. If flag is true it does; if flag is false it doesn't</text>
      <param>constrainHeightToTextHeight whether node's height should be
 * constrained to the height of its text</param>
    </javadoc>
    <method type="void" name="setConstrainHeightToTextHeight" startLine="122" endLine="125" />
    <javadoc>
      <text>* Controls whether this node changes its width to fit the width of its
 * text. If flag is true it does; if flag is false it doesn't</text>
      <return>true if node is constrained to the width of its text</return>
    </javadoc>
    <method type="boolean" name="getConstrainWidthToTextWidth" startLine="133" endLine="135" />
    <javadoc>
      <text>* Controls whether this node changes its height to fit the height of its
 * text. If flag is true it does; if flag is false it doesn't</text>
      <return>true if node is constrained to the height of its text</return>
    </javadoc>
    <method type="boolean" name="getConstrainHeightToTextHeight" startLine="143" endLine="145" />
    <javadoc>
      <text>* Get the document for this PStyledText. Document is used as the node's
 * model.</text>
      <return>internal document used as a model of this PStyledText</return>
    </javadoc>
    <method type="Document" name="getDocument" startLine="153" endLine="155" />
    <javadoc>
      <text>* Set the document on this PStyledText. Document is used as the node's
 * model.</text>
      <param>document to be used as the model for this PStyledText</param>
    </javadoc>
    <method type="void" name="setDocument" startLine="163" endLine="168">
      <comment>Save the document</comment>
    </method>
    <javadoc>
      <text>* Enforce that the current display matches the styling of the underlying
 * document as closely as possible.</text>
    </javadoc>
    <method type="void" name="syncWithDocument" startLine="174" endLine="263">
      <declaration type="String" name="documentString" />
      <scope startLine="179" endLine="181" />
      <scope startLine="182" endLine="187">
        <comment>Since this the location we're providing comes from directly</comment>
        <comment>querying the document, this is impossible in a single threaded</comment>
        <comment>model</comment>
      </scope>
      <declaration type="ArrayList" name="pEnds" />
      <declaration type="StyleContext" name="styleContext" />
      <declaration type="int" name="pos" />
      <declaration type="RunInfo" name="paragraphRange" />
      <declaration type="AttributedString" name="attributedString" />
      <declaration type="Iterator" name="contentIterator" />
      <declaration type="Iterator" name="paragraphIterator" />
      <scope startLine="202" endLine="260">
        <declaration type="Element" name="curElement" />
        <declaration type="Element" name="rootElement" />
        <scope startLine="217" endLine="234">
          <declaration type="AttributeSet" name="attributes" />
          <declaration type="Color" name="foreground" />
          <declaration type="Font" name="font" />
        </scope>
        <scope startLine="235" endLine="259">
          <scope startLine="238" endLine="258">
            <declaration type="AttributeSet" name="attributes" />
            <declaration type="Color" name="foreground" />
            <declaration type="Font" name="font" />
          </scope>
        </scope>
        <comment>The current element will be used as a temp variable while</comment>
        <comment>searching for the leaf element at the current position</comment>
        <comment>Small assumption here that there is one root element - can fix</comment>
        <comment>for more general support later</comment>
        <comment>If the string is length 0 then we just need to add the attributes</comment>
        <comment>once</comment>
        <comment>These are the mandatory attributes</comment>
        <comment>OK, now we loop until we find all the leaf elements in the</comment>
        <comment>range</comment>
        <comment>These are the mandatory attributes</comment>
        <comment>And set the position to the end of the given attribute</comment>
      </scope>
      <comment>First get the actual text and stick it in an Attributed String</comment>
      <comment>The paragraph start and end indices</comment>
      <comment>The default style context - which will be reused</comment>
    </method>
    <javadoc>
      <text>* Returns the first leaf encountered by drilling into the document for the
 * given position.</text>
      <param>pos position under which we're trying to find a leaf</param>
      <param>rootElement top most element in the document tree</param>
      <return>Leaf element that corresponds to the position provided in the
 * document</return>
    </javadoc>
    <method type="Element" name="drillDownFromRoot" startLine="275" endLine="285">
      <declaration type="Element" name="curElement" />
      <scope startLine="280" endLine="282" />
      <comment>Before each pass, start at the root</comment>
      <comment>Now we descend the hierarchy until we get to a leaf</comment>
    </method>
    <method type="void" name="applyFontAttribute" startLine="288" endLine="294">
      <scope startLine="289" endLine="293" />
    </method>
    <method type="void" name="applyStrikeThroughAttribute" startLine="297" endLine="305">
      <declaration type="boolean" name="strikethrough" />
      <scope startLine="299" endLine="304" />
    </method>
    <method type="void" name="applyUnderlineAttribute" startLine="308" endLine="316">
      <declaration type="boolean" name="underline" />
      <scope startLine="310" endLine="315" />
    </method>
    <method type="void" name="applyBackgroundAttribute" startLine="319" endLine="326">
      <scope startLine="320" endLine="325">
        <declaration type="Color" name="background" />
      </scope>
    </method>
    <method type="Font" name="extractFont" startLine="329" endLine="344">
      <declaration type="Font" name="font" />
      <scope startLine="331" endLine="333" />
      <scope startLine="335" endLine="342">
        <scope startLine="336" endLine="338" />
        <scope startLine="339" endLine="341" />
      </scope>
    </method>
    <method type="Font" name="extractFontFromDefaultStyledDocument" startLine="347" endLine="356">
      <declaration type="Font" name="font" />
      <scope startLine="349" endLine="354">
        <scope startLine="351" endLine="353" />
      </scope>
    </method>
    <method type="ArrayList" name="extractParagraphRanges" startLine="358" endLine="416">
      <declaration type="ArrayList" name="paragraphRanges" />
      <declaration type="int" name="pos" />
      <declaration type="StringTokenizer" name="tokenizer" />
      <declaration type="boolean" name="lastNewLine" />
      <scope startLine="373" endLine="407">
        <declaration type="String" name="token" />
        <scope startLine="377" endLine="386">
          <scope startLine="378" endLine="381" />
        </scope>
        <scope startLine="391" endLine="396" />
        <scope startLine="398" endLine="406" />
        <comment>If the token</comment>
        <comment>If the token is empty - create an attributed string with a</comment>
        <comment>single space since LineBreakMeasurers don't work with an empty</comment>
        <comment>string</comment>
        <comment>- note that this case should only arise if the document is empty</comment>
        <comment>This is the normal case - where we have some text</comment>
        <comment>Increment the position</comment>
      </scope>
      <scope startLine="410" endLine="413" />
      <comment>The paragraph start and end indices</comment>
      <comment>The current position in the specified range</comment>
      <comment>lastNewLine is used to detect the case when two newlines follow</comment>
      <comment>in direct succession</comment>
      <comment>& lastNewLine should be true to start in case the first character</comment>
      <comment>is a newline</comment>
      <comment>Add one more newline if the last character was a newline</comment>
    </method>
    <javadoc>
      <text>* Compute the bounds of the text wrapped by this node. The text layout is
 * wrapped based on the bounds of this node. If the shrinkBoundsToFit
 * parameter is true then after the text has been laid out the bounds of
 * this node are shrunk to fit around those text bounds.</text>
    </javadoc>
    <method type="void" name="recomputeLayout" startLine="424" endLine="505">
      <scope startLine="425" endLine="427" />
      <declaration type="ArrayList" name="linesList" />
      <declaration type="double" name="textWidth" />
      <declaration type="double" name="textHeight" />
      <declaration type="Iterator" name="contentIterator" />
      <scope startLine="436" endLine="500">
        <declaration type="AttributedString" name="ats" />
        <declaration type="AttributedCharacterIterator" name="itr" />
        <declaration type="LineBreakMeasurer" name="measurer" />
        <declaration type="ArrayList" name="breakList" />
        <declaration type="LineInfo" name="lineInfo" />
        <declaration type="boolean" name="newLine" />
        <declaration type="double" name="lineWidth" />
        <scope startLine="454" endLine="495">
          <declaration type="TextLayout" name="aTextLayout" />
          <scope startLine="457" endLine="468">
            <declaration type="double" name="lineHeight" />
          </scope>
          <declaration type="int" name="lineEnd" />
          <scope startLine="471" endLine="474" />
          <declaration type="SegmentInfo" name="sInfo" />
          <declaration type="FontMetrics" name="metrics" />
        </scope>
        <declaration type="double" name="lineHeight" />
        <comment>Need to change the lineinfo data structure to know about multiple</comment>
        <comment>text layouts per line</comment>
        <comment>Now create a new line</comment>
      </scope>
    </method>
    <javadoc>
      <param>lineInfo</param>
      <return />
    </javadoc>
    <method type="double" name="calculateLineHeightFromLineInfo" startLine="511" endLine="520">
      <declaration type="double" name="lineHeight" />
      <scope startLine="513" endLine="515" />
      <scope startLine="516" endLine="518" />
    </method>
    <method type="void" name="constrainDimensionsIfNeeded" startLine="522" endLine="539">
      <scope startLine="523" endLine="525" />
      <declaration type="double" name="newWidth" />
      <declaration type="double" name="newHeight" />
      <scope startLine="530" endLine="532" />
      <scope startLine="534" endLine="536" />
    </method>
    <method type="ArrayList" name="extractLineBreaks" startLine="543" endLine="557">
      <declaration type="ArrayList" name="breakList" />
      <scope startLine="546" endLine="555">
        <scope startLine="547" endLine="549" />
        <scope startLine="550" endLine="552" />
      </scope>
    </method>
    <javadoc>
      <text>* Get the height of the font at the beginning of the document.</text>
      <return>height of font at the start of the document.</return>
    </javadoc>
    <method type="double" name="getInitialFontHeight" startLine="564" endLine="576">
      <declaration type="Element" name="rootElement" />
      <declaration type="Element" name="curElement" />
      <declaration type="StyleContext" name="context" />
      <declaration type="Font" name="font" />
      <declaration type="FontMetrics" name="curFM" />
      <comment>Small assumption here that there is one root element - can fix</comment>
      <comment>for more general support later</comment>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="paint" startLine="579" endLine="637">
      <scope startLine="580" endLine="582" />
      <declaration type="float" name="x" />
      <declaration type="float" name="y" />
      <declaration type="float" name="bottomY" />
      <declaration type="Graphics2D" name="g2" />
      <scope startLine="590" endLine="593" />
      <declaration type="float" name="curX" />
      <declaration type="LineInfo" name="lineInfo" />
      <scope startLine="597" endLine="636">
        <scope startLine="602" endLine="604" />
        <scope startLine="606" endLine="633">
          <declaration type="SegmentInfo" name="sInfo" />
          <declaration type="float" name="width" />
          <scope startLine="610" endLine="614" />
          <scope startLine="627" endLine="630" />
        </scope>
        <comment>Manually set the paint - this is specified in the</comment>
        <comment>AttributedString but seems to be</comment>
        <comment>ignored by the TextLayout. To handle multiple colors we</comment>
        <comment>should be breaking up the lines</comment>
        <comment>but that functionality can be added later as needed</comment>
        <comment>Draw the underline and the strikethrough after the text</comment>
      </scope>
    </method>
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="void" name="fullPaint" startLine="642" endLine="646">
      <scope startLine="643" endLine="645" />
    </method>
    <javadoc>
      <text>* Set whether this node is current in editing mode.</text>
      <param>editing value to set editing flag</param>
    </javadoc>
    <method type="void" name="setEditing" startLine="653" endLine="655" />
    <javadoc>
      <text>* Whether node is currently in editing state.</text>
      <return>true if node is currently editing</return>
    </javadoc>
    <method type="boolean" name="isEditing" startLine="662" endLine="664" />
    <javadoc>
      <text>* Set the insets of the text.</text>
      <param>insets desired insets</param>
    </javadoc>
    <method type="void" name="setInsets" startLine="671" endLine="680">
      <scope startLine="672" endLine="679" />
    </method>
    <javadoc>
      <text>* Get the insets of the text.</text>
      <return>current text insets</return>
    </javadoc>
    <method type="Insets" name="getInsets" startLine="687" endLine="689" />
    <javadoc>
      <text>* {@inheritDoc}</text>
    </javadoc>
    <method type="boolean" name="setBounds" startLine="692" endLine="699">
      <scope startLine="693" endLine="695" />
    </method>
    <class name="RunInfo" startLine="701">
      <javadoc>
        <text>* Simple class to represent an range within the document.</text>
      </javadoc>
      <declaration type="int" name="startIndex" />
      <declaration type="int" name="endIndex" />
      <javadoc>
        <text>* Constructs a RunInfo representing the range within the document from
 * runStart to runLimit.</text>
        <param>runStart starting index of the range</param>
        <param>runLimit ending index of the range</param>
      </javadoc>
      <method type="constructor" name="RunInfo" startLine="715" endLine="718" />
      <javadoc>
        <text>* Returns whether the run is empty.</text>
        <return>true is run is empty</return>
      </javadoc>
      <method type="boolean" name="isEmpty" startLine="725" endLine="727" />
      <javadoc>
        <text>* Returns the length of the run.</text>
        <return>length of run</return>
      </javadoc>
      <method type="int" name="length" startLine="734" endLine="736" />
      <class name="LineInfo" startLine="739">
        <javadoc>
          <text>* The info for rendering and computing the bounds of a line.</text>
        </javadoc>
        <javadoc>
          <text>* Segments which make up this line's formatting segments.</text>
        </javadoc>
        <declaration type="List" name="segments" />
        <javadoc>
          <text>* Maximum of the line segments' ascents.</text>
        </javadoc>
        <declaration type="double" name="maxAscent" />
        <javadoc>
          <text>* Maximum of the line segments' descents.</text>
        </javadoc>
        <declaration type="double" name="maxDescent" />
        <javadoc>
          <text>* Leading space at front of line segment.</text>
        </javadoc>
        <declaration type="double" name="leading" />
        <javadoc>
          <text>* Creates a LineInfo that contains no segments.</text>
        </javadoc>
        <method type="constructor" name="LineInfo" startLine="758" endLine="760" />
        <class name="SegmentInfo" startLine="763">
          <javadoc>
            <text>* Encapsulates information about a particular LineSegment.</text>
          </javadoc>
          <javadoc>
            <text>* Text Layout applied to the segment.</text>
          </javadoc>
          <declaration type="TextLayout" name="layout" />
          <javadoc>
            <text>* Font being used to render the segment.</text>
          </javadoc>
          <declaration type="Font" name="font" />
          <javadoc>
            <text>* Foreground (text) color of the segment.</text>
          </javadoc>
          <declaration type="Color" name="foreground" />
          <javadoc>
            <text>* Background color of the segment.</text>
          </javadoc>
          <declaration type="Color" name="background" />
          <javadoc>
            <text>* Whether the segment is underlined.</text>
          </javadoc>
          <declaration type="Boolean" name="underline" />
          <javadoc>
            <text>* Construct a segment with null properties.</text>
          </javadoc>
          <method type="constructor" name="SegmentInfo" startLine="783" endLine="784" />
          <javadoc>
            <text>* Applies this particular SegmentInfo's font to the graphics object
 * passed in.</text>
            <param>g2 will have the font of this segment applied</param>
          </javadoc>
          <method type="void" name="applyFont" startLine="792" endLine="796">
            <scope startLine="793" endLine="795" />
          </method>
        </class>
      </class>
    </class>
    <comment>Because swing doesn't use fractional font metrics by default, we use</comment>
    <comment>LineBreakMeasurer to find out where Swing is going to break them</comment>
  </class>
</source>
