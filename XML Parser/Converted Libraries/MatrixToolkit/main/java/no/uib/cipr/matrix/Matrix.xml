<?xml version="1.0" encoding="UTF-8"?>
<source package="no.uib.cipr.matrix">
  <interface name="Matrix" startLine="23">
    <implements name="Iterable<MatrixEntry>" />
    <javadoc>
      <text>* Basic matrix interface. It holds <code>double</code>s in a rectangular 2D
 * array, and it is used alongside <code>Vector</code> in numerical
 * computations. Implementing classes decides on the actual storage.
 * <h4>Basic operations</h4>
 * <p>
 * Use <code>numRows</code> and <code>numColumns</code> to get the basic
 * size of a matrix. <code>get(int,int)</code> gets an element, and there are
 * corresponding <code>set(int,int,double)</code> and
 * <code>add(int,int,double)</code> methods as well. Note that matrix indices
 * are zero-based (typical for Java and C). This means that the row-indices
 * range from 0 to <code>numRows-1</code>, likewise for the columns. It is
 * legal to have <code>numRows</code> or <code>numColumns</code> equal zero.
 * </p>
 * <p>
 * Other basic operations are <code>zero</code> which zeros all the entries of
 * the matrix, which can be cheaper than either zeroing the matrix manually, or
 * creating a new matrix, and the operation <code>copy</code> which creates a
 * deep copy of the matrix. This copy has separate storage, but starts with the
 * same contents as the current matrix.
 * </p>
 * <h4>Iterators</h4>
 * <p>
 * The matrix interface extends <code>Iterable</code>, and the iterator
 * returns a <code>MatrixEntry</code> which contains current index and entry
 * value. Note that the iterator may skip non-zero entries. Using an iterator,
 * many simple and efficient algorithms can be created. The iterator also
 * permits changing values in the matrix, however only non-zero entries can be
 * changed.
 * </p>
 * <h4>Basic linear algebra</h4>
 * <p>
 * A large selection of basic linear algebra operations are available. To ensure
 * high efficiency, little or no internal memory allocation is done, and the
 * user is required to supply the output arguments.
 * </p>
 * <p>
 * The operations available include:
 * </p>
 * <dl>
 * <dt><i>Additions </i></dt>
 * <dd>Matrices can be added to each other, even if their underlying matrix
 * structures are different.</dd>
 * <dt><i>Multiplications </i></dt>
 * <dd>A matrix can be multiplied with vectors and other matrices. For
 * increased efficiency, a multiplication can be combined with addition and
 * scaling, and transpose matrix multiplications are also available.</dd>
 * <dt><i>Rank-updates </i></dt>
 * <dd>A matrix can be efficiently updated using low-rank updates. The updates
 * can be contained in both matrices or vectors.</dd>
 * <dt><i>Transpositions </i></dt>
 * <dd>In-place transpositions of square matrices is supported, and the
 * transpose of a matrix can be stored in another matrix of compatible size
 * (possibly non-rectangular)</dd>
 * <dt><i>Solvers </i></dt>
 * <dd>Many dense and structured sparse matrices have fast, direct solvers, and
 * can be used to solve linear systems without creating a factorization. These
 * solvers are typically backed by subroutines in LAPACK</dd>
 * </dl></text>
    </javadoc>
    <method name="numRows" type="int" startLine="88" endLine="91" />
    <javadoc>
      <text>* Number of rows in the matrix</text>
    </javadoc>
    <method name="numColumns" type="int" startLine="93" endLine="96" />
    <javadoc>
      <text>* Number of columns in the matrix</text>
    </javadoc>
    <method name="isSquare" type="boolean" startLine="98" endLine="101" />
    <javadoc>
      <text>* Returns true if the matrix is square</text>
    </javadoc>
    <method name="set" type="void" startLine="103" endLine="106" />
    <javadoc>
      <text>* <code>A(row,column) = value</code></text>
    </javadoc>
    <method name="add" type="void" startLine="108" endLine="111" />
    <javadoc>
      <text>* <code>A(row,column) += value</code></text>
    </javadoc>
    <method name="get" type="double" startLine="113" endLine="116" />
    <javadoc>
      <text>* Returns <code>A(row,column)</code></text>
    </javadoc>
    <method name="copy" type="Matrix" startLine="118" endLine="123" />
    <javadoc>
      <text>* Creates a deep copy of the matrix</text>
      <return>A</return>
    </javadoc>
    <method name="zero" type="Matrix" startLine="125" endLine="131" />
    <javadoc>
      <text>* Zeros all the entries in the matrix, while preserving any underlying
 * structure. Useful for general, unstructured matrices.</text>
      <return>A</return>
    </javadoc>
    <method name="mult" type="Vector" startLine="133" endLine="142" />
    <javadoc>
      <text>* <code>y = A*x</code></text>
      <param>xVector of size <code>A.numColumns()</code></param>
      <param>yVector of size <code>A.numRows()</code></param>
      <return>y</return>
    </javadoc>
    <method name="mult" type="Vector" startLine="144" endLine="153" />
    <javadoc>
      <text>* <code>y = alpha*A*x</code></text>
      <param>xVector of size <code>A.numColumns()</code></param>
      <param>yVector of size <code>A.numRows()</code></param>
      <return>y</return>
    </javadoc>
    <method name="multAdd" type="Vector" startLine="155" endLine="164" />
    <javadoc>
      <text>* <code>y = A*x + y</code></text>
      <param>xVector of size <code>A.numColumns()</code></param>
      <param>yVector of size <code>A.numRows()</code></param>
      <return>y</return>
    </javadoc>
    <method name="multAdd" type="Vector" startLine="166" endLine="175" />
    <javadoc>
      <text>* <code>y = alpha*A*x + y</code></text>
      <param>xVector of size <code>A.numColumns()</code></param>
      <param>yVector of size <code>A.numRows()</code></param>
      <return>y</return>
    </javadoc>
    <method name="transMult" type="Vector" startLine="177" endLine="186" />
    <javadoc>
      <text>* <code>y = A<sup>T</sup>*x</code></text>
      <param>xVector of size <code>A.numRows()</code></param>
      <param>yVector of size <code>A.numColumns()</code></param>
      <return>y</return>
    </javadoc>
    <method name="transMult" type="Vector" startLine="188" endLine="197" />
    <javadoc>
      <text>* <code>y = alpha*A<sup>T</sup>*x</code></text>
      <param>xVector of size <code>A.numRows()</code></param>
      <param>yVector of size <code>A.numColumns()</code></param>
      <return>y</return>
    </javadoc>
    <method name="transMultAdd" type="Vector" startLine="199" endLine="208" />
    <javadoc>
      <text>* <code>y = A<sup>T</sup>*x + y</code></text>
      <param>xVector of size <code>A.numRows()</code></param>
      <param>yVector of size <code>A.numColumns()</code></param>
      <return>y</return>
    </javadoc>
    <method name="transMultAdd" type="Vector" startLine="210" endLine="219" />
    <javadoc>
      <text>* <code>y = alpha*A<sup>T</sup>*x + y</code></text>
      <param>xVector of size <code>A.numRows()</code></param>
      <param>yVector of size <code>A.numColumns()</code></param>
      <return>y</return>
    </javadoc>
    <method name="solve" type="Vector" startLine="221" endLine="239" />
    <javadoc>
      <text>* <code>x = A\b</code>. Not all matrices support this operation, those
 * that do not throw <code>UnsupportedOperationException</code>. Note
 * that it is often more efficient to use a matrix decomposition and its
 * associated solver</text>
      <param>bVector of size <code>A.numRows()</code></param>
      <param>xVector of size <code>A.numColumns()</code></param>
      <return>x</return>
      <throws>MatrixSingularExceptionIf the matrix is singular</throws>
      <throws>MatrixNotSPDExceptionIf the solver assumes that the matrix is symmetrical,
 * positive definite, but that that property does not hold</throws>
    </javadoc>
    <method name="transSolve" type="Vector" startLine="241" endLine="259" />
    <javadoc>
      <text>* <code>x = A<sup>T</sup>\b</code>. Not all matrices support this
 * operation, those that do not throw
 * <code>UnsupportedOperationException</code>. Note that it is often more
 * efficient to use a matrix decomposition and its associated solver</text>
      <param>bVector of size <code>A.numColumns()</code></param>
      <param>xVector of size <code>A.numRows()</code></param>
      <return>x</return>
      <throws>MatrixSingularExceptionIf the matrix is singular</throws>
      <throws>MatrixNotSPDExceptionIf the solver assumes that the matrix is symmetrical,
 * positive definite, but that that property does not hold</throws>
    </javadoc>
    <method name="rank1" type="Matrix" startLine="261" endLine="267" />
    <javadoc>
      <text>* <code>A = x*x<sup>T</sup> + A</code>. The matrix must be square, and
 * the vector of the same length</text>
      <return>A</return>
    </javadoc>
    <method name="rank1" type="Matrix" startLine="269" endLine="275" />
    <javadoc>
      <text>* <code>A = alpha*x*x<sup>T</sup> + A</code>. The matrix must be
 * square, and the vector of the same length</text>
      <return>A</return>
    </javadoc>
    <method name="rank1" type="Matrix" startLine="277" endLine="283" />
    <javadoc>
      <text>* <code>A = x*y<sup>T</sup> + A</code>. The matrix must be square, and
 * the vectors of the same length</text>
      <return>A</return>
    </javadoc>
    <method name="rank1" type="Matrix" startLine="285" endLine="291" />
    <javadoc>
      <text>* <code>A = alpha*x*y<sup>T</sup> + A</code>. The matrix must be
 * square, and the vectors of the same length</text>
      <return>A</return>
    </javadoc>
    <method name="rank2" type="Matrix" startLine="293" endLine="299" />
    <javadoc>
      <text>* <code>A = x*y<sup>T</sup> + y*x<sup>T</sup> + A</code>. The matrix
 * must be square, and the vectors of the same length</text>
      <return>A</return>
    </javadoc>
    <method name="rank2" type="Matrix" startLine="301" endLine="307" />
    <javadoc>
      <text>* <code>A = alpha*x*y<sup>T</sup> + alpha*y*x<sup>T</sup> + A</code>.
 * The matrix must be square, and the vectors of the same length</text>
      <return>A</return>
    </javadoc>
    <method name="mult" type="Matrix" startLine="309" endLine="320" />
    <javadoc>
      <text>* <code>C = A*B</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="mult" type="Matrix" startLine="322" endLine="333" />
    <javadoc>
      <text>* <code>C = alpha*A*B</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="multAdd" type="Matrix" startLine="335" endLine="346" />
    <javadoc>
      <text>* <code>C = A*B + C</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="multAdd" type="Matrix" startLine="348" endLine="359" />
    <javadoc>
      <text>* <code>C = alpha*A*B + C</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transAmult" type="Matrix" startLine="361" endLine="372" />
    <javadoc>
      <text>* <code>C = A<sup>T</sup>*B</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transAmult" type="Matrix" startLine="374" endLine="385" />
    <javadoc>
      <text>* <code>C = alpha*A<sup>T</sup>*B</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transAmultAdd" type="Matrix" startLine="387" endLine="398" />
    <javadoc>
      <text>* <code>C = A<sup>T</sup>*B + C</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transAmultAdd" type="Matrix" startLine="400" endLine="411" />
    <javadoc>
      <text>* <code>C = alpha*A<sup>T</sup>*B + C</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transBmult" type="Matrix" startLine="413" endLine="424" />
    <javadoc>
      <text>* <code>C = A*B<sup>T</sup></code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transBmult" type="Matrix" startLine="426" endLine="437" />
    <javadoc>
      <text>* <code>C = alpha*A*B<sup>T</sup></code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transBmultAdd" type="Matrix" startLine="439" endLine="450" />
    <javadoc>
      <text>* <code>C = A*B<sup>T</sup> + C</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transBmultAdd" type="Matrix" startLine="452" endLine="463" />
    <javadoc>
      <text>* <code>C = alpha*A*B<sup>T</sup> + C</code></text>
      <param>BMatrix such that <code>B.numRows() == A.numRows()</code> and
 * <code>B.numColumns() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numColumns() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transABmult" type="Matrix" startLine="465" endLine="476" />
    <javadoc>
      <text>* <code>C = A<sup>T</sup>*B<sup>T</sup></code></text>
      <param>BMatrix such that <code>B.numColumns() == A.numRows()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transABmult" type="Matrix" startLine="478" endLine="489" />
    <javadoc>
      <text>* <code>C = alpha*A<sup>T</sup>*B<sup>T</sup></code></text>
      <param>BMatrix such that <code>B.numColumns() == A.numRows()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transABmultAdd" type="Matrix" startLine="491" endLine="502" />
    <javadoc>
      <text>* <code>C = A<sup>T</sup>*B<sup>T</sup> + C</code></text>
      <param>BMatrix such that <code>B.numColumns() == A.numRows()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="transABmultAdd" type="Matrix" startLine="504" endLine="515" />
    <javadoc>
      <text>* <code>C = alpha*A<sup>T</sup>*B<sup>T</sup> + C</code></text>
      <param>BMatrix such that <code>B.numColumns() == A.numRows()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <param>CMatrix such that <code>C.numRows() == A.numColumns()</code>
 * and <code>B.numRows() == C.numColumns()</code></param>
      <return>C</return>
    </javadoc>
    <method name="solve" type="Matrix" startLine="517" endLine="537" />
    <javadoc>
      <text>* <code>X = A\B</code>. Not all matrices support this operation, those
 * that do not throw <code>UnsupportedOperationException</code>. Note
 * that it is often more efficient to use a matrix decomposition and its
 * associated solver</text>
      <param>BMatrix with the same number of rows as <code>A</code>, and
 * the same number of columns as <code>X</code></param>
      <param>XMatrix with a number of rows equal <code>A.numColumns()</code>,
 * and the same number of columns as <code>B</code></param>
      <return>X</return>
      <throws>MatrixSingularExceptionIf the matrix is singular</throws>
      <throws>MatrixNotSPDExceptionIf the solver assumes that the matrix is symmetrical,
 * positive definite, but that that property does not hold</throws>
    </javadoc>
    <method name="transSolve" type="Matrix" startLine="539" endLine="560" />
    <javadoc>
      <text>* <code>X = A<sup>T</sup>\B</code>. Not all matrices support this
 * operation, those that do not throw
 * <code>UnsupportedOperationException</code>. Note that it is often more
 * efficient to use a matrix decomposition and its associated transpose
 * solver</text>
      <param>BMatrix with a number of rows equal <code>A.numColumns()</code>,
 * and the same number of columns as <code>X</code></param>
      <param>XMatrix with the same number of rows as <code>A</code>, and
 * the same number of columns as <code>B</code></param>
      <return>X</return>
      <throws>MatrixSingularExceptionIf the matrix is singular</throws>
      <throws>MatrixNotSPDExceptionIf the solver assumes that the matrix is symmetrical,
 * positive definite, but that that property does not hold</throws>
    </javadoc>
    <method name="rank1" type="Matrix" startLine="562" endLine="568" />
    <javadoc>
      <text>* <code>A = C*C<sup>T</sup> + A</code>. The matrices must be square
 * and of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="rank1" type="Matrix" startLine="570" endLine="576" />
    <javadoc>
      <text>* <code>A = alpha*C*C<sup>T</sup> + A</code>. The matrices must be
 * square and of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="transRank1" type="Matrix" startLine="578" endLine="584" />
    <javadoc>
      <text>* <code>A = C<sup>T</sup>*C + A</code> The matrices must be square and
 * of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="transRank1" type="Matrix" startLine="586" endLine="592" />
    <javadoc>
      <text>* <code>A = alpha*C<sup>T</sup>*C + A</code> The matrices must be
 * square and of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="rank2" type="Matrix" startLine="594" endLine="606" />
    <javadoc>
      <text>* <code>A = B*C<sup>T</sup> + C*B<sup>T</sup> + A</code>. This
 * matrix must be square</text>
      <param>BMatrix with the same number of rows as <code>A</code> and
 * the same number of columns as <code>C</code></param>
      <param>CMatrix with the same number of rows as <code>A</code> and
 * the same number of columns as <code>B</code></param>
      <return>A</return>
    </javadoc>
    <method name="rank2" type="Matrix" startLine="608" endLine="620" />
    <javadoc>
      <text>* <code>A = alpha*B*C<sup>T</sup> + alpha*C*B<sup>T</sup> + A</code>.
 * This matrix must be square</text>
      <param>BMatrix with the same number of rows as <code>A</code> and
 * the same number of columns as <code>C</code></param>
      <param>CMatrix with the same number of rows as <code>A</code> and
 * the same number of columns as <code>B</code></param>
      <return>A</return>
    </javadoc>
    <method name="transRank2" type="Matrix" startLine="622" endLine="634" />
    <javadoc>
      <text>* <code>A = B<sup>T</sup>*C + C<sup>T</sup>*B + A</code>. This
 * matrix must be square</text>
      <param>BMatrix with the same number of rows as <code>C</code> and
 * the same number of columns as <code>A</code></param>
      <param>CMatrix with the same number of rows as <code>B</code> and
 * the same number of columns as <code>A</code></param>
      <return>A</return>
    </javadoc>
    <method name="transRank2" type="Matrix" startLine="636" endLine="648" />
    <javadoc>
      <text>* <code>A = alpha*B<sup>T</sup>*C + alpha*C<sup>T</sup>*B + A</code>.
 * This matrix must be square</text>
      <param>BMatrix with the same number of rows as <code>C</code> and
 * the same number of columns as <code>A</code></param>
      <param>CMatrix with the same number of rows as <code>B</code> and
 * the same number of columns as <code>A</code></param>
      <return>A</return>
    </javadoc>
    <method name="scale" type="Matrix" startLine="650" endLine="655" />
    <javadoc>
      <text>* <code>A = alpha*A</code></text>
      <return>A</return>
    </javadoc>
    <method name="set" type="Matrix" startLine="657" endLine="662" />
    <javadoc>
      <text>* <code>A=B</code>. The matrices must be of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="set" type="Matrix" startLine="664" endLine="669" />
    <javadoc>
      <text>* <code>A=alpha*B</code>. The matrices must be of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="add" type="Matrix" startLine="671" endLine="676" />
    <javadoc>
      <text>* <code>A = B + A</code>. The matrices must be of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="add" type="Matrix" startLine="678" endLine="683" />
    <javadoc>
      <text>* <code>A = alpha*B + A</code>. The matrices must be of the same size</text>
      <return>A</return>
    </javadoc>
    <method name="transpose" type="Matrix" startLine="685" endLine="691" />
    <javadoc>
      <text>* Transposes the matrix in-place. In most cases, the matrix must be square
 * for this to work.</text>
      <return>This matrix</return>
    </javadoc>
    <method name="transpose" type="Matrix" startLine="693" endLine="702" />
    <javadoc>
      <text>* Sets the tranpose of this matrix into <code>B</code>. Matrix
 * dimensions must be compatible</text>
      <param>BMatrix with as many rows as this matrix has columns, and as
 * many columns as this matrix has rows</param>
      <return>The matrix <code>B=A<sup>T</sup></code></return>
    </javadoc>
    <method name="norm" type="double" startLine="704" endLine="710" />
    <javadoc>
      <text>* Computes the given norm of the matrix</text>
      <param>typeThe type of norm to compute</param>
    </javadoc>
    <javadoc>
      <text>* Supported matrix-norms. Note that <code>Maxvalue</code> is not a proper
 * matrix norm</text>
    </javadoc>
    <javadoc>
      <text>* Maximum absolute row sum</text>
    </javadoc>
    <javadoc>
      <text>* The root of sum of the sum of squares</text>
    </javadoc>
    <javadoc>
      <text>* Maximum column sum</text>
    </javadoc>
    <javadoc>
      <text>* Largest entry in absolute value. Not a proper matrix norm</text>
    </javadoc>
    <javadoc>
      <return>the String as required by the netlib libraries to represent this norm.</return>
    </javadoc>
    <method type="String" name="netlib" startLine="741" endLine="751">
      <comment>TODO: this is a bit of a hack</comment>
      <comment>shouldn't need to know about the internals of netlib</comment>
    </method>
  </interface>
</source>
