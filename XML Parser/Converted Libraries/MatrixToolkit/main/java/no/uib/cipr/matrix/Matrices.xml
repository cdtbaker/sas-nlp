<?xml version="1.0" encoding="UTF-8"?>
<source package="no.uib.cipr.matrix">
  <import name="java.util.Arrays" />
  <class name="Matrices" startLine="25">
    <javadoc>
      <text>* Static utility methods for matrices and vectors</text>
    </javadoc>
    <method type="constructor" name="Matrices" startLine="30" endLine="32">
      <comment>No need to instantiate</comment>
    </method>
    <javadoc>
      <text>* <code>max(1, M)</code> provided as a convenience for 'leading dimension' calculations.</text>
      <param>n</param>
    </javadoc>
    <method type="int" name="ld" startLine="39" endLine="41" />
    <javadoc>
      <text>* <code>max(1, max(M, N))</code> provided as a convenience for 'leading dimension'
 * calculations.</text>
      <param>m</param>
      <param>n</param>
    </javadoc>
    <method type="int" name="ld" startLine="50" endLine="52" />
    <javadoc>
      <text>* Returns the number of non-zero entries in the given vector</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="57" endLine="63">
      <declaration type="int" name="nz" />
    </method>
    <javadoc>
      <text>* Returns the number of non-zero entries in the given matrix</text>
    </javadoc>
    <method type="int" name="cardinality" startLine="68" endLine="74">
      <declaration type="int" name="nz" />
    </method>
    <javadoc>
      <text>* Returns an array of arrays containing a copy of the given matrix. Each
 * array contains one row.</text>
    </javadoc>
    <method type="double[][]" name="getArray" startLine="80" endLine="85">
      <declaration type="double[][]" name="Ad" />
    </method>
    <javadoc>
      <text>* Returns a dense array containing a copy of the given vector</text>
    </javadoc>
    <method type="double[]" name="getArray" startLine="90" endLine="95">
      <declaration type="double[]" name="xd" />
    </method>
    <javadoc>
      <text>* Returns the identity matrix of the given size</text>
      <param>sizeNumber of rows/columns of the matrix</param>
      <return>Matrix of the given size, with ones on the main diagonal</return>
    </javadoc>
    <method type="DenseMatrix" name="identity" startLine="104" endLine="109">
      <declaration type="DenseMatrix" name="A" />
    </method>
    <javadoc>
      <text>* Creates a random vector. Numbers are drawn from a uniform distribution
 * between 0 and 1</text>
      <param>sizeSize of the vector</param>
    </javadoc>
    <method type="Vector" name="random" startLine="118" endLine="120" />
    <javadoc>
      <text>* Populates a vector with random numbers drawn from a uniform distribution
 * between 0 and 1</text>
      <param>xVector to populate</param>
    </javadoc>
    <method type="Vector" name="random" startLine="129" endLine="133" />
    <javadoc>
      <text>* Creates a random matrix. Numbers are drawn from a uniform distribution
 * between 0 and 1</text>
      <param>numRowsNumber of rows</param>
      <param>numColumnsNumber of columns</param>
    </javadoc>
    <method type="Matrix" name="random" startLine="144" endLine="146" />
    <javadoc>
      <text>* Populates a matrix with random numbers drawn from a uniform distribution
 * between 0 and 1</text>
      <param>AMatrix to populate</param>
    </javadoc>
    <method type="Matrix" name="random" startLine="155" endLine="160" />
    <javadoc>
      <text>* Returns a synchronized vector which wraps the given vector. Only the
 * <code>set(int, double)</code> and <code>add(int, double)</code>
 * methods and their blocked versions are synchronized.
 * <p>
 * <b>Note: </b> Do not use the wrapped vector for any operations besides
 * matrix assembly, as these operations may be very slow.</text>
      <param>xVector to be wrapped</param>
      <return>A thin wrapper around <code>x</code></return>
    </javadoc>
    <method type="Vector" name="synchronizedVector" startLine="174" endLine="176" />
    <javadoc>
      <text>* Returns a synchronized matrix which wraps the given matrix. Only the
 * <code>set(int, int, double)</code> and
 * <code>add(int, int, double)</code> methods and their blocked versions
 * are synchronized.
 * <p>
 * <b>Note: </b> Do not use the wrapped matrix for any operations besides
 * matrix assembly, as these operations may be very slow.</text>
      <param>AMatrix to be wrapped</param>
      <return>A thin wrapper around <code>A</code></return>
    </javadoc>
    <method type="Matrix" name="synchronizedMatrix" startLine="191" endLine="193" />
    <javadoc>
      <text>* Returns a synchronized matrix which wraps the given matrix. Only the
 * <code>set(int, int, double)</code> and
 * <code>add(int, int, double)</code> methods and their blocked versions
 * are synchronized.
 * <p>
 * The locking provided is finer than the locking of the whole matrix, as
 * different threads can access different rows simultaneous, while only one
 * thread can access a given row at a time. Use this for row-major matrices,
 * <i>not </i> for column-major matrices.
 * <p>
 * <b>Note: </b> Do not use the wrapped matrix for any operations besides
 * matrix assembly, as these operations may be very slow.</text>
      <param>AMatrix to be wrapped</param>
      <return>A thin wrapper around <code>A</code>. Individual rows are
 * locked</return>
    </javadoc>
    <method type="Matrix" name="synchronizedMatrixByRows" startLine="214" endLine="216" />
    <javadoc>
      <text>* Returns a synchronized matrix which wraps the given matrix. Only the
 * <code>set(int, int, double)</code> and
 * <code>add(int, int, double)</code> methods and their blocked versions
 * are synchronized.
 * <p>
 * The locking provided is finer than the locking of the whole matrix, as
 * different threads can access different columns simultaneous, while only
 * one thread can access a given column at a time. Use this for column-major
 * matrices, <i>not </i> for row-major matrices.
 * <p>
 * <b>Note: </b> Do not use the wrapped matrix for any operations besides
 * matrix assembly, as these operations may be very slow.</text>
      <param>AMatrix to be wrapped</param>
      <return>A thin wrapper around <code>A</code>. Individual columns are
 * locked</return>
    </javadoc>
    <method type="Matrix" name="synchronizedMatrixByColumns" startLine="237" endLine="239" />
    <javadoc>
      <text>* Returns a view into the given matrix. This view is only for easing some
 * matrix-assembly cases, not for general use. To extract a more
 * higher-performing and general matrix, create a copy of the submatrix. The
 * result is a {@link no.uib.cipr.matrix.DenseMatrix DenseMatrix}.</text>
      <param>AMatrix to create view on</param>
      <param>rowRows to access. Must be within the bounds of <code>A</code></param>
      <param>columnColumns to access. Must be within the bounds of <code>A</code></param>
      <return>Submatrix of <code>A</code>. Changing it will change the
 * backing matrix</return>
    </javadoc>
    <method type="Matrix" name="getSubMatrix" startLine="256" endLine="258" />
    <javadoc>
      <text>* Returns a view into the given vector. This view is only for easing some
 * vector-assembly cases, not for general use. To extract a more
 * higher-performing and general vector, create a copy of the subvector. The
 * result is a {@link no.uib.cipr.matrix.DenseVector DenseVector}.</text>
      <param>xVector to create view on</param>
      <param>indexIndices to access. Must be within the bounds of <code>x</code></param>
      <return>Submatrix of <code>x</code>. Changing it will change the
 * backing matrix</return>
    </javadoc>
    <method type="Vector" name="getSubVector" startLine="273" endLine="275" />
    <class name="RefMatrix" extends="AbstractMatrix" startLine="277">
      <javadoc>
        <text>* Matrix backed by another matrix. Used by <code>getSubMatrix</code></text>
      </javadoc>
      <declaration type="Matrix" name="A" />
      <declaration type="int[]" name="row" />
      <method type="constructor" name="RefMatrix" startLine="286" endLine="291" />
      <method type="void" name="add" startLine="294" endLine="296" />
      <method type="DenseMatrix" name="copy" startLine="299" endLine="301" />
      <method type="double" name="get" startLine="304" endLine="306" />
      <method type="void" name="set" startLine="309" endLine="311" />
      <class name="RefVector" extends="AbstractVector" startLine="315">
        <javadoc>
          <text>* Vector backed by another vector. Used by <code>getSubVector</code></text>
        </javadoc>
        <declaration type="Vector" name="x" />
        <declaration type="int[]" name="index" />
        <method type="constructor" name="RefVector" startLine="324" endLine="328" />
        <method type="void" name="add" startLine="331" endLine="333" />
        <method type="DenseVector" name="copy" startLine="336" endLine="338" />
        <method type="double" name="get" startLine="341" endLine="343" />
        <method type="void" name="set" startLine="346" endLine="348" />
        <class name="SynchronizedVector" extends="AbstractVector" startLine="352">
          <javadoc>
            <text>* Ensures correctness in the vector assembly. Since it extends the
 * AbstractVector class, algebraic operations will be slow. It is not
 * possible to implement Vector and delegate calls to the imbedded vector,
 * since casting to the imbedded vector is not possible</text>
          </javadoc>
          <declaration type="Vector" name="x" />
          <method type="constructor" name="SynchronizedVector" startLine="362" endLine="365" />
          <method type="void" name="add" startLine="368" endLine="370" />
          <method type="void" name="set" startLine="373" endLine="375" />
          <method type="double" name="get" startLine="378" endLine="380" />
          <method type="Vector" name="copy" startLine="383" endLine="385" />
          <class name="SynchronizedMatrix" extends="AbstractMatrix" startLine="389">
            <javadoc>
              <text>* Ensures correctness in the matrix assembly. Since it extends the
 * AbstractMatrix class, algebraic operations will be slow. It is not
 * possible to implement Matrix and delegate calls to the imbedded matrix,
 * since casting to the imbedded matrix is not possible</text>
            </javadoc>
            <declaration type="Matrix" name="A" />
            <method type="constructor" name="SynchronizedMatrix" startLine="399" endLine="402" />
            <method type="void" name="add" startLine="405" endLine="407" />
            <method type="void" name="set" startLine="410" endLine="412" />
            <method type="double" name="get" startLine="415" endLine="417" />
            <method type="Matrix" name="copy" startLine="420" endLine="422" />
            <class name="SynchronizedRowMatrix" extends="AbstractMatrix" startLine="426">
              <javadoc>
                <text>* Ensures correctness in the matrix assembly. Since it extends the
 * AbstractMatrix class, algebraic operations will be slow. It is not
 * possible to implement Matrix and delegate calls to the imbedded matrix,
 * since casting to the imbedded matrix is not possible
 * <p>
 * Locks individual rows instead of the whole matrix</text>
              </javadoc>
              <declaration type="Matrix" name="A" />
              <declaration type="Object[]" name="lock" />
              <method type="constructor" name="SynchronizedRowMatrix" startLine="440" endLine="446" />
              <method type="void" name="add" startLine="449" endLine="453">
                <scope startLine="450" endLine="452" />
              </method>
              <method type="void" name="set" startLine="456" endLine="460">
                <scope startLine="457" endLine="459" />
              </method>
              <method type="double" name="get" startLine="463" endLine="465" />
              <method type="Matrix" name="copy" startLine="468" endLine="470" />
              <class name="SynchronizedColumnMatrix" extends="AbstractMatrix" startLine="474">
                <javadoc>
                  <text>* Ensures correctness in the matrix assembly. Implements matrix instead of
 * subclassing the abstract matrix in order to correctly delegate every
 * method to possbly overridden method in the encapsulated matrix.
 * <p>
 * Locks individual columns instead of the whole matrix</text>
                </javadoc>
                <declaration type="Matrix" name="A" />
                <declaration type="Object[]" name="lock" />
                <method type="constructor" name="SynchronizedColumnMatrix" startLine="487" endLine="493" />
                <method type="void" name="add" startLine="496" endLine="500">
                  <scope startLine="497" endLine="499" />
                </method>
                <method type="void" name="set" startLine="503" endLine="507">
                  <scope startLine="504" endLine="506" />
                </method>
                <method type="double" name="get" startLine="510" endLine="512" />
                <method type="Matrix" name="copy" startLine="515" endLine="517" />
                <javadoc>
                  <text>* Creates a continuous linear index.</text>
                  <param>fromStart, inclusive</param>
                  <param>toStop, exclusive</param>
                </javadoc>
                <method type="int[]" name="index" startLine="529" endLine="539">
                  <declaration type="int" name="length" />
                  <declaration type="int[]" name="index" />
                </method>
                <javadoc>
                  <text>* Creates a strided linear index.</text>
                  <param>fromStart, inclusive</param>
                  <param>stride<code>stride=1</code> for continuous. Negative strides are
 * allowed</param>
                  <param>toStop, exclusive</param>
                </javadoc>
                <method type="int[]" name="index" startLine="552" endLine="574">
                  <declaration type="int" name="length" />
                  <declaration type="int[]" name="index" />
                </method>
                <javadoc>
                  <text>* Finds the number of non-zero entries on each row</text>
                </javadoc>
                <method type="int[]" name="rowBandwidth" startLine="579" endLine="586">
                  <declaration type="int[]" name="nz" />
                </method>
                <javadoc>
                  <text>* Finds the number of non-zero entries on each column</text>
                </javadoc>
                <method type="int[]" name="columnBandwidth" startLine="591" endLine="598">
                  <declaration type="int[]" name="nz" />
                </method>
                <javadoc>
                  <text>* Finds the number of diagonals below the main diagonal. Useful for
 * converting a general matrix into a banded matrix</text>
                </javadoc>
                <method type="int" name="getNumSubDiagonals" startLine="604" endLine="611">
                  <declaration type="int" name="kl" />
                </method>
                <javadoc>
                  <text>* Finds the number of diagonals above the main diagonal. Useful for
 * converting a general matrix into a banded matrix</text>
                </javadoc>
                <method type="int" name="getNumSuperDiagonals" startLine="617" endLine="624">
                  <declaration type="int" name="ku" />
                </method>
                <javadoc>
                  <text>* Sets the selected rows of <code>A</code> equal zero, and puts
 * <code>diagonal</code> on the diagonal of those rows. Useful for
 * enforcing boundary conditions</text>
                </javadoc>
                <method type="void" name="zeroRows" startLine="631" endLine="652">
                  <declaration type="int[]" name="rowS" />
                  <scope startLine="636" endLine="645">
                    <declaration type="int" name="j" />
                    <scope startLine="638" endLine="644" />
                    <comment>Found</comment>
                    <comment>Diagonal</comment>
                    <comment>Off diagonal</comment>
                  </scope>
                  <comment>Sort the rows</comment>
                  <comment>Ensure the diagonal is set. This is necessary in case of missing</comment>
                  <comment>rows</comment>
                </method>
                <javadoc>
                  <text>* Sets the selected columns of <code>A</code> equal zero, and puts
 * <code>diagonal</code> on the diagonal of those columns. Useful for
 * enforcing boundary conditions</text>
                </javadoc>
                <method type="void" name="zeroColumns" startLine="659" endLine="680">
                  <declaration type="int[]" name="columnS" />
                  <scope startLine="664" endLine="673">
                    <declaration type="int" name="j" />
                    <scope startLine="666" endLine="672" />
                    <comment>Found</comment>
                    <comment>Diagonal</comment>
                    <comment>Off diagonal</comment>
                  </scope>
                  <comment>Sort the columns</comment>
                  <comment>Ensure the diagonal is set. This is necessary in case of missing</comment>
                  <comment>columns</comment>
                </method>
                <method type="DenseVector" name="getColumn" startLine="682" endLine="688">
                  <declaration type="DenseVector" name="v" />
                  <scope startLine="684" endLine="686" />
                </method>
              </class>
            </class>
          </class>
        </class>
      </class>
    </class>
  </class>
</source>
