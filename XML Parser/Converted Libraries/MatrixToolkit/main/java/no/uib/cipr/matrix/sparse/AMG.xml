<?xml version="1.0" encoding="UTF-8"?>
<source package="no.uib.cipr.matrix.sparse">
  <import name="java.util.ArrayList" />
  <import name="java.util.Arrays" />
  <import name="java.util.HashMap" />
  <import name="java.util.HashSet" />
  <import name="java.util.LinkedList" />
  <import name="java.util.List" />
  <import name="java.util.Map" />
  <import name="java.util.Set" />
  <import name="no.uib.cipr.matrix.DenseLU" />
  <import name="no.uib.cipr.matrix.DenseMatrix" />
  <import name="no.uib.cipr.matrix.DenseVector" />
  <import name="no.uib.cipr.matrix.Matrix" />
  <import name="no.uib.cipr.matrix.Vector" />
  <class name="AMG" startLine="38">
    <implements name="Preconditioner" />
    <javadoc>
      <text>* Algebraic multigrid preconditioner. Uses the smoothed aggregation method
 * described by Vanek, Mandel, and Brezina (1996).</text>
    </javadoc>
    <javadoc>
      <text>* Relaxations at each level</text>
    </javadoc>
    <declaration type="SSOR[]" name="preM" />
    <javadoc>
      <text>* The number of levels</text>
    </javadoc>
    <declaration type="int" name="m" />
    <javadoc>
      <text>* System matrix at each level, except at the coarsest</text>
    </javadoc>
    <declaration type="CompRowMatrix[]" name="A" />
    <javadoc>
      <text>* LU factorization at the coarsest level</text>
    </javadoc>
    <declaration type="DenseLU" name="lu" />
    <javadoc>
      <text>* Solution, right-hand side, and residual vectors at each level</text>
    </javadoc>
    <declaration type="DenseVector[]" name="u" />
    <javadoc>
      <text>* Interpolation operators going to a finer mesh</text>
    </javadoc>
    <declaration type="CompColMatrix[]" name="I" />
    <javadoc>
      <text>* Smallest matrix size before terminating the AMG setup phase. Matrices
 * smaller than this will be solved by a direct solver</text>
    </javadoc>
    <declaration type="int" name="min" />
    <javadoc>
      <text>* Number of times to perform the pre- and post-smoothings</text>
    </javadoc>
    <declaration type="int" name="nu1" />
    <javadoc>
      <text>* Determines cycle type. gamma=1 is V, gamma=2 is W</text>
    </javadoc>
    <declaration type="int" name="gamma" />
    <javadoc>
      <text>* Overrelaxation parameters in the pre- and post-smoothings, and with the
 * possibility of distinct values in the forward and reverse sweeps</text>
    </javadoc>
    <declaration type="double" name="omegaPreF" />
    <javadoc>
      <text>* Perform a reverse (backwards) smoothing sweep</text>
    </javadoc>
    <declaration type="boolean" name="reverse" />
    <javadoc>
      <text>* Jacobi damping parameter, between zero and one. If it equals zero, the
 * method reduces to the standard aggregate multigrid method</text>
    </javadoc>
    <declaration type="double" name="omega" />
    <javadoc>
      <text>* Operating in transpose mode?</text>
    </javadoc>
    <declaration type="boolean" name="transpose" />
    <javadoc>
      <text>* Sets up the algebraic multigrid preconditioner</text>
      <param>omegaPreFOverrelaxation parameter in the forward sweep of the
 * pre-smoothing</param>
      <param>omegaPreROverrelaxation parameter in the backwards sweep of the
 * pre-smoothing</param>
      <param>omegaPostFOverrelaxation parameter in the forward sweep of the
 * post-smoothing</param>
      <param>omegaPostROverrelaxation parameter in the backwards sweep of the
 * post-smoothing</param>
      <param>nu1Number of pre-relaxations to perform</param>
      <param>nu2Number of post-relaxations to perform</param>
      <param>gammaNumber of times to go to a coarser level</param>
      <param>minSmallest matrix size before using a direct solver</param>
      <param>omegaJacobi damping parameter, between zero and one. If it equals
 * zero, the method reduces to the standard aggregate multigrid
 * method</param>
    </javadoc>
    <method type="constructor" name="AMG" startLine="142" endLine="156" />
    <javadoc>
      <text>* Sets up the algebraic multigrid preconditioner. Uses an SOR method,
 * without the backward sweep in SSOR</text>
      <param>omegaPreOverrelaxation parameter in the pre-smoothing</param>
      <param>omegaPostOverrelaxation parameter in the post-smoothing</param>
      <param>nu1Number of pre-relaxations to perform</param>
      <param>nu2Number of post-relaxations to perform</param>
      <param>gammaNumber of times to go to a coarser level</param>
      <param>minSmallest matrix size before using a direct solver</param>
      <param>omegaJacobi damping parameter, between zero and one. If it equals
 * zero, the method reduces to the standard aggregate multigrid
 * method</param>
    </javadoc>
    <method type="constructor" name="AMG" startLine="180" endLine="194" />
    <javadoc>
      <text>* Sets up the algebraic multigrid preconditioner using some default
 * parameters. In the presmoothing, <code>omegaF=1</code> and
 * <code>omegaR=1.85</code>, while in the postsmoothing,
 * <code>omegaF=1.85</code> and <code>omegaR=1</code>. Sets
 * <code>nu1=nu2=gamma=1</code>, has a smallest matrix size of 40, and
 * sets <code>omega=2/3</code>.</text>
    </javadoc>
    <method type="constructor" name="AMG" startLine="204" endLine="206" />
    <method type="Vector" name="apply" startLine="208" endLine="216" />
    <method type="Vector" name="transApply" startLine="218" endLine="226" />
    <method type="void" name="setMatrix" startLine="228" endLine="294">
      <declaration type="List<CompRowMatrix>" name="Al" />
      <declaration type="List<CompColMatrix>" name="Il" />
      <scope startLine="234" endLine="254">
        <declaration type="CompRowMatrix" name="Af" />
        <declaration type="double" name="eps" />
        <declaration type="Aggregator" name="aggregator" />
        <declaration type="Interpolator" name="sa" />
        <comment>Create the aggregates</comment>
        <comment>If no aggregates were created, no interpolation operator will be</comment>
        <comment>created, and the setup phase stops</comment>
        <comment>Create an interpolation operator using smoothing. This also</comment>
        <comment>creates the Galerkin operator</comment>
      </scope>
      <declaration type="DenseMatrix" name="Ac" />
      <scope startLine="277" endLine="282">
        <declaration type="int" name="n" />
      </scope>
      <scope startLine="287" endLine="293">
        <declaration type="CompRowMatrix" name="Ak" />
      </scope>
      <comment>Copy to array storage</comment>
      <comment>Create a LU decomposition of the smallest Galerkin matrix</comment>
      <comment>Allocate vectors at each level</comment>
      <comment>Set up the SSOR relaxation schemes</comment>
    </method>
    <javadoc>
      <text>* Performs a multigrid cycle</text>
      <param>kLevel to cycle at. Start by calling <code>cycle(0)</code></param>
    </javadoc>
    <method type="void" name="cycle" startLine="302" endLine="328">
      <scope startLine="305" endLine="327">
        <comment>Presmoothings</comment>
        <comment>Compute the residual</comment>
        <comment>Restrict to the next coarser level</comment>
        <comment>Recurse to next level</comment>
        <comment>Add residual correction by prolongation</comment>
        <comment>Postsmoothings</comment>
      </scope>
    </method>
    <javadoc>
      <text>* Solves directly at the coarsest level</text>
    </javadoc>
    <method type="void" name="directSolve" startLine="333" endLine="342">
      <declaration type="int" name="k" />
      <declaration type="DenseMatrix" name="U" />
    </method>
    <javadoc>
      <text>* Applies the relaxation scheme at the given level</text>
      <param>kMultigrid level</param>
    </javadoc>
    <method type="void" name="preRelax" startLine="350" endLine="356" />
    <javadoc>
      <text>* Applies the relaxation scheme at the given level</text>
      <param>kMultigrid level</param>
    </javadoc>
    <method type="void" name="postRelax" startLine="364" endLine="370" />
    <class name="Aggregator" startLine="372">
      <javadoc>
        <text>* Creates aggregates. These are disjoint sets, each of which represents one
 * node at a coarser mesh by aggregating together a set of fine nodes</text>
      </javadoc>
      <javadoc>
        <text>* The aggregates</text>
      </javadoc>
      <declaration type="List<Set<Integer>>" name="C" />
      <javadoc>
        <text>* Diagonal indices into the sparse matrix</text>
      </javadoc>
      <declaration type="int[]" name="diagind" />
      <javadoc>
        <text>* The strongly coupled node neighborhood of a given node</text>
      </javadoc>
      <declaration type="List<Set<Integer>>" name="N" />
      <javadoc>
        <text>* Creates the aggregates</text>
        <param>ASparse matrix</param>
        <param>epsTolerance for selecting the strongly coupled node
 * neighborhoods. Between zero and one.</param>
      </javadoc>
      <method type="constructor" name="Aggregator" startLine="402" endLine="433">
        <declaration type="boolean[]" name="R" />
        <comment>Initialization. Remove isolated nodes from the aggregates</comment>
        <comment>Startup aggregation. Use disjoint strongly coupled neighborhoods
 as the initial aggregate approximation</comment>
        <comment>Enlargment of the aggregates. Add nodes to each aggregate based
 on how strongly connected the nodes are to a given aggregate</comment>
        <comment>Handling of the remenants. Put all remaining unallocated nodes
 into new aggregates defined by the intersection of N and R</comment>
      </method>
      <javadoc>
        <text>* Gets the aggregates</text>
      </javadoc>
      <method type="List<Set<Integer>>" name="getAggregates" startLine="438" endLine="440" />
      <javadoc>
        <text>* Returns the matrix diagonal indices. This is a by-product of the
 * aggregation</text>
      </javadoc>
      <method type="int[]" name="getDiagonalIndices" startLine="446" endLine="448" />
      <javadoc>
        <text>* Returns the strongly coupled node neighborhoods of a given node. This
 * is a by-product of the aggregation</text>
      </javadoc>
      <method type="List<Set<Integer>>" name="getNodeNeighborhoods" startLine="454" endLine="456" />
      <javadoc>
        <text>* Finds the diagonal indices of the matrix</text>
      </javadoc>
      <method type="int[]" name="findDiagonalIndices" startLine="461" endLine="477">
        <declaration type="int[]" name="rowptr" />
        <declaration type="int[]" name="colind" />
        <declaration type="int[]" name="diagind" />
        <scope startLine="467" endLine="474" />
      </method>
      <javadoc>
        <text>* Finds the strongly coupled node neighborhoods</text>
      </javadoc>
      <method type="List<Set<Integer>>" name="findNodeNeighborhood" startLine="483" endLine="507">
        <declaration type="int[]" name="rowptr" />
        <declaration type="int[]" name="colind" />
        <declaration type="double[]" name="data" />
        <scope startLine="491" endLine="504">
          <declaration type="Set<Integer>" name="Ni" />
          <declaration type="double" name="aii" />
          <scope startLine="495" endLine="501">
            <declaration type="double" name="aij" />
            <declaration type="double" name="ajj" />
          </scope>
        </scope>
      </method>
      <javadoc>
        <text>* Creates the initial R-set by including only the connected nodes</text>
      </javadoc>
      <method type="boolean[]" name="createInitialR" startLine="512" endLine="532">
        <declaration type="boolean[]" name="R" />
        <declaration type="int[]" name="rowptr" />
        <declaration type="int[]" name="colind" />
        <declaration type="double[]" name="data" />
        <scope startLine="519" endLine="529">
          <declaration type="boolean" name="hasOffDiagonal" />
          <scope startLine="523" endLine="526" />
        </scope>
      </method>
      <javadoc>
        <text>* Creates the initial aggregates</text>
      </javadoc>
      <method type="List<Set<Integer>>" name="createInitialAggregates" startLine="538" endLine="562">
        <scope startLine="541" endLine="559">
          <declaration type="boolean" name="free" />
          <scope startLine="553" endLine="557" />
          <comment>Skip non-free nodes</comment>
          <comment>See if all nodes in the current N-set are free</comment>
          <comment>Create an aggregate out of N[i]</comment>
        </scope>
      </method>
      <javadoc>
        <text>* Enlarges the aggregates</text>
      </javadoc>
      <method type="List<Set<Integer>>" name="enlargeAggregates" startLine="568" endLine="614">
        <declaration type="List<List<Integer>>" name="belong" />
        <declaration type="int[]" name="intersect" />
        <scope startLine="584" endLine="611">
          <declaration type="int" name="largest" />
          <scope startLine="597" endLine="603">
            <scope startLine="599" endLine="602" />
          </scope>
          <scope startLine="607" endLine="610" />
          <comment>Skip non-free nodes</comment>
          <comment>Find the number of nodes intersecting Ni and every C, and</comment>
          <comment>keep a track on the largest overlap</comment>
          <comment>The k-index is to an aggregate coupled to node j</comment>
          <comment>Add the node to the proper C-set, and mark it as used</comment>
          <comment>Also, check if the node actually does couple to a set</comment>
        </scope>
        <comment>Contains the aggregates each node is coupled to</comment>
        <comment>Find which aggregate each node is coupled to. This is used for</comment>
        <comment>the intersection between Ni and Ck</comment>
        <comment>Number of nodes in the intersection between each C and Ni</comment>
      </method>
      <javadoc>
        <text>* Creates final aggregates from the remaining unallocated nodes</text>
      </javadoc>
      <method type="List<Set<Integer>>" name="createFinalAggregates" startLine="620" endLine="641">
        <scope startLine="622" endLine="638">
          <declaration type="Set<Integer>" name="Cn" />
          <scope startLine="631" endLine="634" />
          <comment>Skip non-free nodes</comment>
          <comment>Create new aggregate from the nodes in N[i] which are free</comment>
        </scope>
      </method>
      <class name="Interpolator" startLine="644">
        <javadoc>
          <text>* Creates interpolation (prolongation) operators using based on the
 * aggregates. Can optionally smooth the aggregates</text>
        </javadoc>
        <javadoc>
          <text>* The Galerkin coarse-space operator</text>
        </javadoc>
        <declaration type="CompRowMatrix" name="Ac" />
        <javadoc>
          <text>* The interpolation (prolongation) matrix</text>
        </javadoc>
        <declaration type="CompColMatrix" name="I" />
        <javadoc>
          <text>* Creates the interpolation (prolongation) and Galerkin operators</text>
          <param>aggregatorAggregates</param>
          <param>AMatrix</param>
          <param>omegaJacobi damping parameter between zero and one. If zero, no
 * smoothing is performed, and a faster algorithm for forming
 * the Galerkin operator will be used.</param>
        </javadoc>
        <method type="constructor" name="Interpolator" startLine="672" endLine="709">
          <declaration type="List<Set<Integer>>" name="C" />
          <declaration type="List<Set<Integer>>" name="N" />
          <declaration type="int[]" name="diagind" />
          <declaration type="int[]" name="pt" />
          <scope startLine="684" endLine="695">
            <declaration type="List<Map<Integer,Double>>" name="P" />
            <comment>Smooth the operator by a damped Jacobi method</comment>
            <comment>Form a compressed column storage for the operator</comment>
            <comment>Create the Galerkin operator using a slow method</comment>
          </scope>
          <scope startLine="701" endLine="708">
            <comment>Create the Galerkin operator using a fast method</comment>
            <comment>Form an explicit interpolation operator</comment>
          </scope>
          <comment>Create the tentative prolongation, in compressed form</comment>
          <comment>Apply Jacobi smoothing to the prolongator</comment>
          <comment>Use the aggregates as-is</comment>
        </method>
        <javadoc>
          <text>* Creates the tentative prolongation operator. Since the columns are
 * all disjoint, and its entries are binary, it is possible to store it
 * in a single array. Its length equals the number of fine nodes, and
 * the entries are the indices to the corresponding aggregate (C-set).</text>
        </javadoc>
        <method type="int[]" name="createTentativeProlongation" startLine="717" endLine="726">
          <declaration type="int[]" name="pt" />
        </method>
        <javadoc>
          <text>* Creates the Galerkin operator using the assumption of disjoint
 * (non-smoothed) aggregates</text>
        </javadoc>
        <method type="CompRowMatrix" name="createGalerkinFast" startLine="733" endLine="749">
          <declaration type="int" name="n" />
          <declaration type="FlexCompRowMatrix" name="Ac" />
          <declaration type="int[]" name="rowptr" />
          <declaration type="int[]" name="colind" />
          <declaration type="double[]" name="data" />
        </method>
        <javadoc>
          <text>* Creates the interpolation (prolongation) matrix based on the smoothed
 * aggregates</text>
        </javadoc>
        <method type="CompColMatrix" name="createInterpolationMatrix" startLine="756" endLine="783">
          <declaration type="int" name="c" />
          <declaration type="int[][][]" name="nz" />
          <scope startLine="761" endLine="769">
            <declaration type="Map<Integer,Double>" name="Pj" />
            <declaration type="int" name="l" />
          </scope>
          <scope startLine="774" endLine="780">
            <declaration type="Map<Integer,Double>" name="Pj" />
          </scope>
          <comment>Determine the sparsity pattern of I</comment>
          <comment>Populate it with numerical entries</comment>
        </method>
        <javadoc>
          <text>* Creates the interpolation (prolongation) matrix based on the
 * non-smoothed aggregates</text>
        </javadoc>
        <method type="CompColMatrix" name="createInterpolationMatrix" startLine="789" endLine="797">
          <declaration type="FlexCompColMatrix" name="If" />
        </method>
        <javadoc>
          <text>* Gets the interpolation (prolongation) operator</text>
        </javadoc>
        <method type="CompColMatrix" name="getInterpolationOperator" startLine="802" endLine="804" />
        <javadoc>
          <text>* Creates the smoothes interpolation (prolongation) operator by a
 * single sweep of the damped Jacobi method</text>
        </javadoc>
        <method type="List<Map<Integer,Double>>" name="createSmoothedProlongation" startLine="812" endLine="876">
          <declaration type="int" name="n" />
          <declaration type="List<Map<Integer,Double>>" name="P" />
          <declaration type="int[]" name="rowptr" />
          <declaration type="int[]" name="colind" />
          <declaration type="double[]" name="data" />
          <declaration type="double[]" name="dot" />
          <scope startLine="830" endLine="873">
            <declaration type="Set<Integer>" name="Ni" />
            <declaration type="double" name="weakAij" />
            <scope startLine="840" endLine="855">
              <declaration type="double" name="aij" />
              <scope startLine="849" endLine="852" />
            </scope>
            <declaration type="double" name="scale" />
            <comment>Calculate A*Pt, except for the diagonal</comment>
            <comment>Off-diagonal, include only strong couplings, and add the</comment>
            <comment>weak couplings to the diagonal</comment>
            <comment>Subtract the weak couplings from the diagonal part of A*Pt</comment>
            <comment>Scale by omega and the inverse of the diagonal (damping)</comment>
            <comment>Set to (I-omega*D^{-1}*A)*Pt</comment>
            <comment>This has formed a whole row of P=(I-omega*D^{-1}*A)*Pt</comment>
            <comment>Store the non-zeros into the sparse structure</comment>
          </scope>
          <comment>Allocate the interpolation (prolongation) operator</comment>
          <comment>It is stored by columns, so the maps take row-indices as keys</comment>
          <comment>Apply the damped Jacobi smoother</comment>
        </method>
        <javadoc>
          <text>* Creates the entries of the Galerkin operator
 * <code>Ac = I<sup>T</sup> A I</code>. This is a very
 * time-consuming operation</text>
        </javadoc>
        <method type="CompRowMatrix" name="createGalerkinSlow" startLine="884" endLine="919">
          <declaration type="int" name="n" />
          <declaration type="FlexCompRowMatrix" name="Ac" />
          <declaration type="double[]" name="aiCol" />
          <declaration type="double[]" name="iCol" />
          <declaration type="DenseVector" name="aiV" />
          <declaration type="DenseVector" name="iV" />
          <declaration type="double[]" name="itaiCol" />
          <declaration type="DenseVector" name="itaiV" />
          <declaration type="int[]" name="colptr" />
          <declaration type="int[]" name="rowind" />
          <declaration type="double[]" name="Idata" />
          <scope startLine="899" endLine="916">
            <comment>Expand column 'k' of I to dense storage</comment>
            <comment>Form column 'k' of A*I</comment>
            <comment>Form column 'k' of I'*A*I</comment>
            <comment>Store non-zeros into Ac</comment>
          </scope>
        </method>
        <javadoc>
          <text>* Gets the Galerkin operator</text>
        </javadoc>
        <method type="CompRowMatrix" name="getGalerkinOperator" startLine="924" endLine="926" />
      </class>
    </class>
  </class>
</source>
