<?xml version="1.0" encoding="UTF-8"?>
    <source package="no.uib.cipr.matrix.sparse">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="no.uib.cipr.matrix.DenseLU"/>
        <import package="no.uib.cipr.matrix.DenseMatrix"/>
        <import package="no.uib.cipr.matrix.DenseVector"/>
        <import package="no.uib.cipr.matrix.Matrix"/>
        <import package="no.uib.cipr.matrix.Vector"/>
        <class name="AMG" line="15">
            <implements interface="Preconditioner"/>
            <javadoc line="15">
                Algebraic multigrid preconditioner. Uses the smoothed aggregation method
                  described by Vanek, Mandel, and Brezina (1996).                
            </javadoc>
            <declaration name="preM" type="SSOR[]" line="20"/>
            <javadoc line="20">
                Relaxations at each level                
            </javadoc>
            <declaration name="m" type="int" line="24"/>
            <javadoc line="24">
                The number of levels                
            </javadoc>
            <declaration name="A" type="CompRowMatrix[]" line="28"/>
            <javadoc line="28">
                System matrix at each level, except at the coarsest                
            </javadoc>
            <declaration name="lu" type="DenseLU" line="32"/>
            <javadoc line="32">
                LU factorization at the coarsest level                
            </javadoc>
            <declaration name="u" type="DenseVector[]" line="36"/>
            <javadoc line="36">
                Solution, right-hand side, and residual vectors at each level                
            </javadoc>
            <declaration name="I" type="CompColMatrix[]" line="40"/>
            <javadoc line="40">
                Interpolation operators going to a finer mesh                
            </javadoc>
            <declaration name="min" type="int" line="44"/>
            <javadoc line="44">
                Smallest matrix size before terminating the AMG setup phase. Matrices
                  smaller than this will be solved by a direct solver                
            </javadoc>
            <declaration name="nu1" type="int" line="49"/>
            <javadoc line="49">
                Number of times to perform the pre- and post-smoothings                
            </javadoc>
            <declaration name="gamma" type="int" line="53"/>
            <javadoc line="53">
                Determines cycle type. gamma=1 is V, gamma=2 is W                
            </javadoc>
            <declaration name="omegaPreF" type="double" line="57"/>
            <javadoc line="57">
                Overrelaxation parameters in the pre- and post-smoothings, and with the
                  possibility of distinct values in the forward and reverse sweeps                
            </javadoc>
            <declaration name="reverse" type="boolean" line="62"/>
            <javadoc line="62">
                Perform a reverse (backwards) smoothing sweep                
            </javadoc>
            <declaration name="omega" type="double" line="66"/>
            <javadoc line="66">
                Jacobi damping parameter, between zero and one. If it equals zero, the
                  method reduces to the standard aggregate multigrid method                
            </javadoc>
            <declaration name="transpose" type="boolean" line="71"/>
            <javadoc line="71">
                Operating in transpose mode?                
            </javadoc>
            <javadoc line="75">
                Sets up the algebraic multigrid preconditioner                
                <param>
                    omegaPreFOverrelaxation parameter in the forward sweep of the
                      pre-smoothing                    
                </param>
                <param>
                    omegaPreROverrelaxation parameter in the backwards sweep of the
                      pre-smoothing                    
                </param>
                <param>
                    omegaPostFOverrelaxation parameter in the forward sweep of the
                      post-smoothing                    
                </param>
                <param>
                    omegaPostROverrelaxation parameter in the backwards sweep of the
                      post-smoothing                    
                </param>
                <param>
                    nu1Number of pre-relaxations to perform                    
                </param>
                <param>
                    nu2Number of post-relaxations to perform                    
                </param>
                <param>
                    gammaNumber of times to go to a coarser level                    
                </param>
                <param>
                    minSmallest matrix size before using a direct solver                    
                </param>
                <param>
                    omegaJacobi damping parameter, between zero and one. If it equals
                      zero, the method reduces to the standard aggregate multigrid
                      method                    
                </param>
            </javadoc>
            <method name="AMG" type="constructor" line="93">
                <params>
                    <param name="omegaPreF" type="double"/>
                    <param name="omegaPreR" type="double"/>
                    <param name="omegaPostF" type="double"/>
                    <param name="omegaPostR" type="double"/>
                    <param name="nu1" type="int"/>
                    <param name="nu2" type="int"/>
                    <param name="gamma" type="int"/>
                    <param name="min" type="int"/>
                    <param name="omega" type="double"/>
                </params>
            </method>
            <javadoc line="105">
                Sets up the algebraic multigrid preconditioner. Uses an SOR method,
                  without the backward sweep in SSOR                
                <param>
                    omegaPreOverrelaxation parameter in the pre-smoothing                    
                </param>
                <param>
                    omegaPostOverrelaxation parameter in the post-smoothing                    
                </param>
                <param>
                    nu1Number of pre-relaxations to perform                    
                </param>
                <param>
                    nu2Number of post-relaxations to perform                    
                </param>
                <param>
                    gammaNumber of times to go to a coarser level                    
                </param>
                <param>
                    minSmallest matrix size before using a direct solver                    
                </param>
                <param>
                    omegaJacobi damping parameter, between zero and one. If it equals
                      zero, the method reduces to the standard aggregate multigrid
                      method                    
                </param>
            </javadoc>
            <method name="AMG" type="constructor" line="118">
                <params>
                    <param name="omegaPre" type="double"/>
                    <param name="omegaPost" type="double"/>
                    <param name="nu1" type="int"/>
                    <param name="nu2" type="int"/>
                    <param name="gamma" type="int"/>
                    <param name="min" type="int"/>
                    <param name="omega" type="double"/>
                </params>
            </method>
            <javadoc line="130">
                Sets up the algebraic multigrid preconditioner using some default
                  parameters. In the presmoothing, &lt;code&gt;omegaF=1&lt;/code&gt; and
                  &lt;code&gt;omegaR=1.85&lt;/code&gt;, while in the postsmoothing,
                  &lt;code&gt;omegaF=1.85&lt;/code&gt; and &lt;code&gt;omegaR=1&lt;/code&gt;. Sets
                  &lt;code&gt;nu1=nu2=gamma=1&lt;/code&gt;, has a smallest matrix size of 40, and
                  sets &lt;code&gt;omega=2/3&lt;/code&gt;.                
            </javadoc>
            <method name="AMG" type="constructor" line="138"/>
            <method name="apply" type="Vector" line="141">
                <params>
                    <param name="b" type="Vector"/>
                    <param name="x" type="Vector"/>
                </params>
            </method>
            <method name="transApply" type="Vector" line="148">
                <params>
                    <param name="b" type="Vector"/>
                    <param name="x" type="Vector"/>
                </params>
            </method>
            <method name="setMatrix" type="void" line="155">
                <params>
                    <param name="A" type="Matrix"/>
                </params>
                <declaration name="Al" type="List&lt;CompRowMatrix&gt;" line="156"/>
                <declaration name="Il" type="List&lt;CompColMatrix&gt;" line="157"/>
                <scope line="159">
                    <declaration name="Af" type="CompRowMatrix" line="160"/>
                    <declaration name="eps" type="double" line="161"/>
                    <declaration name="aggregator" type="Aggregator" line="162"/>
                    <declaration name="sa" type="Interpolator" line="164"/>
                </scope>
                <declaration name="Ac" type="DenseMatrix" line="174"/>
                <scope line="180">
                    <declaration name="n" type="int" line="181"/>
                </scope>
                <scope line="188">
                    <declaration name="Ak" type="CompRowMatrix" line="189"/>
                </scope>
            </method>
            <javadoc line="196">
                Performs a multigrid cycle                
                <param>
                    kLevel to cycle at. Start by calling <code>cycle(0)</code>                    
                </param>
            </javadoc>
            <method name="cycle" type="void" line="200">
                <params>
                    <param name="k" type="int"/>
                </params>
                <scope line="202"/>
            </method>
            <javadoc line="212">
                Solves directly at the coarsest level                
            </javadoc>
            <method name="directSolve" type="void" line="215">
                <declaration name="k" type="int" line="216"/>
                <declaration name="U" type="DenseMatrix" line="218"/>
            </method>
            <javadoc line="222">
                Applies the relaxation scheme at the given level                
                <param>
                    kMultigrid level                    
                </param>
            </javadoc>
            <method name="preRelax" type="void" line="226">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="230">
                Applies the relaxation scheme at the given level                
                <param>
                    kMultigrid level                    
                </param>
            </javadoc>
            <method name="postRelax" type="void" line="234">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <class name="Aggregator" line="238">
                <javadoc line="238">
                    Creates aggregates. These are disjoint sets, each of which represents one
                      node at a coarser mesh by aggregating together a set of fine nodes                    
                </javadoc>
                <declaration name="C" type="List&lt;Set&lt;Integer&gt;&gt;" line="243"/>
                <javadoc line="243">
                    The aggregates                    
                </javadoc>
                <declaration name="diagind" type="int[]" line="247"/>
                <javadoc line="247">
                    Diagonal indices into the sparse matrix                    
                </javadoc>
                <declaration name="N" type="List&lt;Set&lt;Integer&gt;&gt;" line="251"/>
                <javadoc line="251">
                    The strongly coupled node neighborhood of a given node                    
                </javadoc>
                <javadoc line="255">
                    Creates the aggregates                    
                    <param>
                        ASparse matrix                        
                    </param>
                    <param>
                        epsTolerance for selecting the strongly coupled node
                          neighborhoods. Between zero and one.                        
                    </param>
                </javadoc>
                <method name="Aggregator" type="constructor" line="261">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="eps" type="double"/>
                    </params>
                    <declaration name="R" type="boolean[]" line="264"/>
                </method>
                <javadoc line="269">
                    Gets the aggregates                    
                </javadoc>
                <method name="getAggregates" type="List<Set<Integer>>" line="272"/>
                <javadoc line="275">
                    Returns the matrix diagonal indices. This is a by-product of the
                      aggregation                    
                </javadoc>
                <method name="getDiagonalIndices" type="int[]" line="279"/>
                <javadoc line="282">
                    Returns the strongly coupled node neighborhoods of a given node. This
                      is a by-product of the aggregation                    
                </javadoc>
                <method name="getNodeNeighborhoods" type="List<Set<Integer>>" line="286"/>
                <javadoc line="289">
                    Finds the diagonal indices of the matrix                    
                </javadoc>
                <method name="findDiagonalIndices" type="int[]" line="292">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                    </params>
                    <declaration name="rowptr" type="int[]" line="293"/>
                    <declaration name="colind" type="int[]" line="294"/>
                    <declaration name="diagind" type="int[]" line="295"/>
                    <scope line="296"/>
                </method>
                <javadoc line="302">
                    Finds the strongly coupled node neighborhoods                    
                </javadoc>
                <method name="findNodeNeighborhood" type="List<Set<Integer>>" line="305">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="diagind" type="int[]"/>
                        <param name="eps" type="double"/>
                    </params>
                    <declaration name="rowptr" type="int[]" line="307"/>
                    <declaration name="colind" type="int[]" line="308"/>
                    <declaration name="data" type="double[]" line="309"/>
                    <scope line="310">
                        <declaration name="Ni" type="Set&lt;Integer&gt;" line="311"/>
                        <declaration name="aii" type="double" line="312"/>
                        <scope line="313">
                            <declaration name="aij" type="double" line="314"/>
                            <declaration name="ajj" type="double" line="315"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="322">
                    Creates the initial R-set by including only the connected nodes                    
                </javadoc>
                <method name="createInitialR" type="boolean[]" line="325">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                    </params>
                    <declaration name="R" type="boolean[]" line="326"/>
                    <declaration name="rowptr" type="int[]" line="327"/>
                    <declaration name="colind" type="int[]" line="328"/>
                    <declaration name="data" type="double[]" line="329"/>
                    <scope line="330">
                        <declaration name="hasOffDiagonal" type="boolean" line="331"/>
                        <scope line="332"/>
                    </scope>
                </method>
                <javadoc line="340">
                    Creates the initial aggregates                    
                </javadoc>
                <method name="createInitialAggregates" type="List<Set<Integer>>" line="343">
                    <params>
                        <param name="N" type="List<Set<Integer>>"/>
                        <param name="R" type="boolean[]"/>
                    </params>
                    <scope line="345">
                        <declaration name="free" type="boolean" line="347"/>
                        <scope line="349"/>
                    </scope>
                </method>
                <javadoc line="356">
                    Enlarges the aggregates                    
                </javadoc>
                <method name="enlargeAggregates" type="List<Set<Integer>>" line="359">
                    <params>
                        <param name="C" type="List<Set<Integer>>"/>
                        <param name="N" type="List<Set<Integer>>"/>
                        <param name="R" type="boolean[]"/>
                    </params>
                    <declaration name="belong" type="List&lt;List&lt;Integer&gt;&gt;" line="360"/>
                    <declaration name="intersect" type="int[]" line="363"/>
                    <scope line="364">
                        <declaration name="largest" type="int" line="367"/>
                        <scope line="368">
                            <scope line="370"/>
                        </scope>
                        <scope line="375"/>
                    </scope>
                </method>
                <javadoc line="382">
                    Creates final aggregates from the remaining unallocated nodes                    
                </javadoc>
                <method name="createFinalAggregates" type="List<Set<Integer>>" line="385">
                    <params>
                        <param name="C" type="List<Set<Integer>>"/>
                        <param name="N" type="List<Set<Integer>>"/>
                        <param name="R" type="boolean[]"/>
                    </params>
                    <scope line="386">
                        <declaration name="Cn" type="Set&lt;Integer&gt;" line="388"/>
                        <scope line="389"/>
                    </scope>
                </method>
            </class>
            <class name="Interpolator" line="398">
                <javadoc line="398">
                    Creates interpolation (prolongation) operators using based on the
                      aggregates. Can optionally smooth the aggregates                    
                </javadoc>
                <declaration name="Ac" type="CompRowMatrix" line="403"/>
                <javadoc line="403">
                    The Galerkin coarse-space operator                    
                </javadoc>
                <declaration name="I" type="CompColMatrix" line="407"/>
                <javadoc line="407">
                    The interpolation (prolongation) matrix                    
                </javadoc>
                <javadoc line="411">
                    Creates the interpolation (prolongation) and Galerkin operators                    
                    <param>
                        aggregatorAggregates                        
                    </param>
                    <param>
                        AMatrix                        
                    </param>
                    <param>
                        omegaJacobi damping parameter between zero and one. If zero, no
                          smoothing is performed, and a faster algorithm for forming
                          the Galerkin operator will be used.                        
                    </param>
                </javadoc>
                <method name="Interpolator" type="constructor" line="419">
                    <params>
                        <param name="aggregator" type="Aggregator"/>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="omega" type="double"/>
                    </params>
                    <declaration name="C" type="List&lt;Set&lt;Integer&gt;&gt;" line="420"/>
                    <declaration name="N" type="List&lt;Set&lt;Integer&gt;&gt;" line="421"/>
                    <declaration name="diagind" type="int[]" line="422"/>
                    <declaration name="pt" type="int[]" line="423"/>
                    <scope line="424">
                        <declaration name="P" type="List&lt;Map&lt;Integer,Double&gt;&gt;" line="425"/>
                    </scope>
                    <scope line="429"/>
                </method>
                <javadoc line="434">
                    Creates the tentative prolongation operator. Since the columns are
                      all disjoint, and its entries are binary, it is possible to store it
                      in a single array. Its length equals the number of fine nodes, and
                      the entries are the indices to the corresponding aggregate (C-set).                    
                </javadoc>
                <method name="createTentativeProlongation" type="int[]" line="440">
                    <params>
                        <param name="C" type="List<Set<Integer>>"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="pt" type="int[]" line="441"/>
                </method>
                <javadoc line="446">
                    Creates the Galerkin operator using the assumption of disjoint
                      (non-smoothed) aggregates                    
                </javadoc>
                <method name="createGalerkinFast" type="CompRowMatrix" line="450">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="pt" type="int[]"/>
                        <param name="c" type="int"/>
                    </params>
                    <declaration name="n" type="int" line="451"/>
                    <declaration name="Ac" type="FlexCompRowMatrix" line="452"/>
                    <declaration name="rowptr" type="int[]" line="453"/>
                    <declaration name="colind" type="int[]" line="454"/>
                    <declaration name="data" type="double[]" line="455"/>
                </method>
                <javadoc line="459">
                    Creates the interpolation (prolongation) matrix based on the smoothed
                      aggregates                    
                </javadoc>
                <method name="createInterpolationMatrix" type="CompColMatrix" line="463">
                    <params>
                        <param name="P" type="List<Map<Integer,Double>>"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="c" type="int" line="464"/>
                    <declaration name="nz" type="int[][]" line="465"/>
                    <scope line="466">
                        <declaration name="Pj" type="Map&lt;Integer,Double&gt;" line="467"/>
                        <declaration name="l" type="int" line="469"/>
                    </scope>
                    <scope line="473">
                        <declaration name="Pj" type="Map&lt;Integer,Double&gt;" line="474"/>
                    </scope>
                </method>
                <javadoc line="479">
                    Creates the interpolation (prolongation) matrix based on the
                      non-smoothed aggregates                    
                </javadoc>
                <method name="createInterpolationMatrix" type="CompColMatrix" line="483">
                    <params>
                        <param name="pt" type="int[]"/>
                        <param name="c" type="int"/>
                    </params>
                    <declaration name="If" type="FlexCompColMatrix" line="484"/>
                </method>
                <javadoc line="488">
                    Gets the interpolation (prolongation) operator                    
                </javadoc>
                <method name="getInterpolationOperator" type="CompColMatrix" line="491"/>
                <javadoc line="494">
                    Creates the smoothes interpolation (prolongation) operator by a
                      single sweep of the damped Jacobi method                    
                </javadoc>
                <method name="createSmoothedProlongation" type="List<Map<Integer,Double>>" line="498">
                    <params>
                        <param name="C" type="List<Set<Integer>>"/>
                        <param name="N" type="List<Set<Integer>>"/>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="diagind" type="int[]"/>
                        <param name="omega" type="double"/>
                        <param name="pt" type="int[]"/>
                    </params>
                    <declaration name="n" type="int" line="499"/>
                    <declaration name="P" type="List&lt;Map&lt;Integer,Double&gt;&gt;" line="500"/>
                    <declaration name="rowptr" type="int[]" line="502"/>
                    <declaration name="colind" type="int[]" line="503"/>
                    <declaration name="data" type="double[]" line="504"/>
                    <declaration name="dot" type="double[]" line="505"/>
                    <scope line="506">
                        <declaration name="Ni" type="Set&lt;Integer&gt;" line="509"/>
                        <declaration name="weakAij" type="double" line="510"/>
                        <scope line="511">
                            <declaration name="aij" type="double" line="513"/>
                            <scope line="514"/>
                        </scope>
                        <declaration name="scale" type="double" line="521"/>
                    </scope>
                </method>
                <javadoc line="528">
                    Creates the entries of the Galerkin operator
                      &lt;code&gt;Ac = I&lt;sup&gt;T&lt;/sup&gt; A I&lt;/code&gt;. This is a very
                      time-consuming operation                    
                </javadoc>
                <method name="createGalerkinSlow" type="CompRowMatrix" line="533">
                    <params>
                        <param name="I" type="CompColMatrix"/>
                        <param name="A" type="CompRowMatrix"/>
                    </params>
                    <declaration name="n" type="int" line="534"/>
                    <declaration name="Ac" type="FlexCompRowMatrix" line="535"/>
                    <declaration name="aiCol" type="double[]" line="536"/>
                    <declaration name="iCol" type="double[]" line="537"/>
                    <declaration name="aiV" type="DenseVector" line="538"/>
                    <declaration name="iV" type="DenseVector" line="539"/>
                    <declaration name="itaiCol" type="double[]" line="540"/>
                    <declaration name="itaiV" type="DenseVector" line="541"/>
                    <declaration name="colptr" type="int[]" line="542"/>
                    <declaration name="rowind" type="int[]" line="543"/>
                    <declaration name="Idata" type="double[]" line="544"/>
                    <scope line="545"/>
                </method>
                <javadoc line="554">
                    Gets the Galerkin operator                    
                </javadoc>
                <method name="getGalerkinOperator" type="CompRowMatrix" line="557"/>
            </class>
        </class>
    </source>