package org.ejml.alg.dense.linsol.lu;
import org.ejml.alg.dense.decomposition.lu.LUDecompositionBase;
import org.ejml.alg.dense.linsol.LinearSolverAbstract;
import org.ejml.data.DenseMatrix64F;
/** 
 * @author Peter Abeles
 */
public abstract class LinearSolverLuBase extends LinearSolverAbstract {
  protected LUDecompositionBase decomp;
  public LinearSolverLuBase(  LUDecompositionBase decomp){
    this.decomp=decomp;
  }
  @Override public boolean setA(  DenseMatrix64F A){
    _setA(A);
    return decomp.decompose(A);
  }
  @Override public double quality(){
    return decomp.quality();
  }
  @Override public void invert(  DenseMatrix64F A_inv){
    double[] vv=decomp._getVV();
    DenseMatrix64F LU=decomp.getLU();
    if (A_inv.numCols != LU.numCols || A_inv.numRows != LU.numRows)     throw new IllegalArgumentException("Unexpected matrix dimension");
    int n=A.numCols;
    double dataInv[]=A_inv.data;
    for (int j=0; j < n; j++) {
      for (int i=0; i < n; i++)       vv[i]=i == j ? 1 : 0;
      decomp._solveVectorInternal(vv);
      int index=j;
      for (int i=0; i < n; i++, index+=n)       dataInv[index]=vv[i];
    }
  }
  /** 
 * This attempts to improve upon the solution generated by account
 * for numerical imprecisions.  See numerical recipes for more information.  It
 * is assumed that solve has already been run on 'b' and 'x' at least once.
 * @param b A matrix. Not modified.
 * @param x A matrix. Modified.
 */
  public void improveSol(  DenseMatrix64F b,  DenseMatrix64F x){
    if (b.numCols != x.numCols) {
      throw new IllegalArgumentException("bad shapes");
    }
    double dataA[]=A.data;
    double dataB[]=b.data;
    double dataX[]=x.data;
    final int nc=b.numCols;
    final int n=b.numCols;
    double[] vv=decomp._getVV();
    DenseMatrix64F LU=decomp.getLU();
    for (int k=0; k < nc; k++) {
      for (int i=0; i < n; i++) {
        double sdp=-dataB[i * nc + k];
        for (int j=0; j < n; j++) {
          sdp+=dataA[i * n + j] * dataX[j * nc + k];
        }
        vv[i]=sdp;
      }
      decomp._solveVectorInternal(vv);
      for (int i=0; i < n; i++) {
        dataX[i * nc + k]-=vv[i];
      }
    }
  }
  @Override public boolean modifiesA(){
    return false;
  }
  @Override public boolean modifiesB(){
    return false;
  }
}
