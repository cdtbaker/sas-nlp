<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.block.linsol.chol">
        <import package="org.ejml.alg.block.BlockMatrixOps"/>
        <import package="org.ejml.alg.block.BlockTriangularSolver"/>
        <import package="org.ejml.alg.block.decomposition.chol.BlockCholeskyOuterForm"/>
        <import package="org.ejml.data.BlockMatrix64F"/>
        <import package="org.ejml.data.D1Submatrix64F"/>
        <import package="org.ejml.factory.LinearSolver"/>
        <import package="org.ejml.ops.SpecializedOps"/>
        <class name="BlockCholeskyOuterSolver" line="9">
            <implements interface="LinearSolver">
                <type_params>
                    <type_param name="BlockMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="9">
                &lt;p&gt; Linear solver that uses a block cholesky decomposition. &lt;/p&gt;
                  &lt;p&gt;
                  Solver works by using the standard Cholesky solving strategy:&lt;br&gt;
                  A=LL&lt;sup&gt;T&lt;/sup&gt; &lt;br&gt;
                  Ax=b&lt;br&gt;
                  LL&lt;sup&gt;T&lt;/sup&gt;x = b &lt;br&gt;
                  Ly = b&lt;br&gt;
                  L&lt;sup&gt;T&lt;/sup&gt;x = y&lt;br&gt;
                  x = L&lt;sup&gt;-T&lt;/sup&gt;y
                  &lt;/p&gt;
                  &lt;p&gt;
                  It is also possible to use the upper triangular cholesky decomposition.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="chol" type="BlockCholeskyOuterForm" line="26"/>
            <declaration name="blockLength" type="int" line="27"/>
            <declaration name="temp" type="double" line="28"/>
            <javadoc line="29">
                Decomposes and overwrites the input matrix.                
                <param>
                    A Semi-Positive Definite (SPD) system matrix. Modified. Reference saved.                    
                </param>
                <return>
                    If the matrix can be decomposed.  Will always return false of not SPD.                    
                </return>
            </javadoc>
            <method name="setA" type="boolean" line="34">
                <params>
                    <param name="A" type="BlockMatrix64F"/>
                </params>
            </method>
            <method name="quality" type="double" line="39"/>
            <javadoc line="42">
                If X == null then the solution is written into B.  Otherwise the solution is copied
                  from B into X.                
            </javadoc>
            <method name="solve" type="void" line="46">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                    <param name="X" type="BlockMatrix64F"/>
                </params>
                <declaration name="L" type="D1Submatrix64F" line="48"/>
                <scope line="49"/>
                <scope line="56"/>
            </method>
            <method name="invert" type="void" line="60">
                <params>
                    <param name="A_inv" type="BlockMatrix64F"/>
                </params>
                <declaration name="T" type="BlockMatrix64F" line="61"/>
                <declaration name="L" type="D1Submatrix64F" line="65"/>
                <declaration name="B" type="D1Submatrix64F" line="66"/>
            </method>
            <method name="modifiesA" type="boolean" line="70"/>
            <method name="modifiesB" type="boolean" line="73"/>
        </class>
    </source>