<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.block.decomposition.qr">
        <import package="org.ejml.alg.block.BlockMatrixOps"/>
        <import package="org.ejml.alg.block.BlockMultiplication"/>
        <import package="org.ejml.data.BlockMatrix64F"/>
        <import package="org.ejml.data.D1Submatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <class name="BlockMatrix64HouseholderQR" line="7">
            <implements interface="QRDecomposition">
                <type_params>
                    <type_param name="BlockMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="7">
                &lt;p&gt;
                  QR decomposition for {@link BlockMatrix64F} using householder reflectors.  The decomposition is
                  performed by computing a QR decomposition for each block column as is normally done, see {@link org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholder}.
                  The reflectors are then combined and applied to the remainder of the matrix.  This process is repeated
                  until all the block columns have been processed
                  &lt;/p&gt;
                  &lt;p&gt;
                  The input matrix is modified and used to store the decomposition.  Reflectors are stored in the lower triangle
                  columns.  The first element of the reflector is implicitly assumed to be one.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each iteration can be sketched as follows:
                  &lt;pre&gt;
                  QR_Decomposition( A(:,i-r to i) )
                  W=computeW( A(:,i-r to i) )
                  A(:,i:n) = (I + WY&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A(:,i:n)
                  &lt;/pre&gt;
                  Where r is the block size, i is the submatrix being considered, A is the input matrix,
                  Y is a matrix containing the reflectors just computed,
                  and W is computed using {@link BlockHouseHolder#computeW_Column}.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Based upon &quot;Block Householder QR Factorization&quot; pg 255 in &quot;Matrix Computations&quot;
                  3rd Ed. 1996 by Gene H. Golub and Charles F. Van Loan.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="dataA" type="BlockMatrix64F" line="36"/>
            <declaration name="dataW" type="BlockMatrix64F" line="37"/>
            <declaration name="dataWTA" type="BlockMatrix64F" line="38"/>
            <declaration name="blockLength" type="int" line="39"/>
            <declaration name="A" type="D1Submatrix64F" line="40"/>
            <declaration name="Y" type="D1Submatrix64F" line="41"/>
            <declaration name="W" type="D1Submatrix64F" line="42"/>
            <declaration name="WTA" type="D1Submatrix64F" line="43"/>
            <declaration name="temp" type="double" line="44"/>
            <declaration name="gammas" type="double" line="45"/>
            <declaration name="saveW" type="boolean" line="46"/>
            <javadoc line="47">
                This is the input matrix after it has been overwritten with the decomposition.                
                <return>
                    Internal matrix used to store decomposition.                    
                </return>
            </javadoc>
            <method name="getQR" type="BlockMatrix64F" line="51"/>
            <javadoc line="54">
                &lt;p&gt;
                  Sets if it should internally save the W matrix before performing the decomposition.  Must
                  be set before decomposition the matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Saving W can result in about a 5% savings when solving systems around a height of 5k.  The
                  price is that it needs to save a matrix the size of the input matrix.
                  &lt;/p&gt;                
                <param>
                    saveW If the W matrix should be saved or not.                    
                </param>
            </javadoc>
            <method name="setSaveW" type="void" line="65">
                <params>
                    <param name="saveW" type="boolean"/>
                </params>
            </method>
            <javadoc line="68">
                @inheritDoc                
            </javadoc>
            <method name="getQ" type="BlockMatrix64F" line="71">
                <params>
                    <param name="Q" type="BlockMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
            </method>
            <javadoc line="76">
                Sanity checks the input or declares a new matrix.  Return matrix is an identity matrix.                
            </javadoc>
            <method name="initializeQ" type="BlockMatrix64F" line="79">
                <params>
                    <param name="Q" type="BlockMatrix64F"/>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                    <param name="blockLength" type="int"/>
                    <param name="compact" type="boolean"/>
                </params>
                <declaration name="minLength" type="int" line="80"/>
                <scope line="81">
                    <scope line="82"/>
                    <scope line="86">
                        <scope line="87"/>
                        <scope line="90"/>
                    </scope>
                </scope>
                <scope line="95">
                    <scope line="96"/>
                    <scope line="100">
                        <scope line="101"/>
                        <scope line="104"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="111">
                &lt;p&gt;
                  Multiplies the provided matrix by Q using householder reflectors.  This is more
                  efficient that computing Q then applying it to the matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  B = Q  B
                  &lt;/p&gt;                
                <param>
                    B Matrix which Q is applied to.  Modified.                    
                </param>
            </javadoc>
            <method name="applyQ" type="void" line="121">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                </params>
            </method>
            <javadoc line="124">
                Specialized version of applyQ() that allows the zeros in an identity matrix
                  to be taken advantage of depending on if isIdentity is true or not.                
                <param>
                    B                    
                </param>
                <param>
                    isIdentity If B is an identity matrix.                    
                </param>
            </javadoc>
            <method name="applyQ" type="void" line="130">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                    <param name="isIdentity" type="boolean"/>
                </params>
                <declaration name="minDimen" type="int" line="131"/>
                <declaration name="subB" type="D1Submatrix64F" line="132"/>
                <declaration name="start" type="int" line="136"/>
                <scope line="139"/>
            </method>
            <javadoc line="154">
                &lt;p&gt;
                  Multiplies the provided matrix by Q&lt;sup&gt;T&lt;/sup&gt; using householder reflectors.  This is more
                  efficient that computing Q then applying it to the matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Q = Q(I - &amp;gamma; WY^T)&lt;br&gt;
                  QR = A =&gt; R = Q^TA  = (Q3^T  (Q2^T  (Q1^t  A)))
                  &lt;/p&gt;                
                <param>
                    B Matrix which Q is applied to.  Modified.                    
                </param>
            </javadoc>
            <method name="applyQTran" type="void" line="165">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                </params>
                <declaration name="minDimen" type="int" line="166"/>
                <declaration name="subB" type="D1Submatrix64F" line="167"/>
                <scope line="171"/>
            </method>
            <javadoc line="187">
                @inheritDoc                
            </javadoc>
            <method name="getR" type="BlockMatrix64F" line="190">
                <params>
                    <param name="R" type="BlockMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <declaration name="min" type="int" line="191"/>
                <scope line="192">
                    <scope line="193"/>
                    <scope line="196"/>
                </scope>
                <scope line="200">
                    <scope line="201">
                        <scope line="202"/>
                    </scope>
                    <scope line="206"/>
                </scope>
            </method>
            <javadoc line="214">
                @inheritDoc                
            </javadoc>
            <method name="decompose" type="boolean" line="217">
                <params>
                    <param name="orig" type="BlockMatrix64F"/>
                </params>
                <declaration name="m" type="int" line="219"/>
                <scope line="220">
                    <scope line="224"/>
                </scope>
            </method>
            <javadoc line="231">
                Adjust submatrices and helper data structures for the input matrix.  Must be called
                  before the decomposition can be computed.                
                <param>
                    orig                    
                </param>
            </javadoc>
            <method name="setup" type="void" line="236">
                <params>
                    <param name="orig" type="BlockMatrix64F"/>
                </params>
                <declaration name="l" type="int" line="242"/>
                <scope line="249"/>
            </method>
            <javadoc line="253">
                &lt;p&gt;
                  A = (I + W Y&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A&lt;BR&gt;
                  A = A + Y (W&lt;sup&gt;T&lt;/sup&gt;A)&lt;BR&gt;
                  &lt;br&gt;
                  where A is a submatrix of the input matrix.
                  &lt;/p&gt;                
            </javadoc>
            <method name="updateA" type="void" line="261">
                <params>
                    <param name="A" type="D1Submatrix64F"/>
                </params>
                <scope line="272"/>
                <scope line="277"/>
            </method>
            <javadoc line="281">
                Sets the submatrix of W up give Y is already configured and if it is being cached or not.                
            </javadoc>
            <method name="setW" type="void" line="284">
                <scope line="285"/>
                <scope line="291"/>
            </method>
            <javadoc line="296">
                The input matrix is always modified.                
                <return>
                    Returns true since the input matrix is modified.                    
                </return>
            </javadoc>
            <method name="inputModified" type="boolean" line="300"/>
        </class>
    </source>