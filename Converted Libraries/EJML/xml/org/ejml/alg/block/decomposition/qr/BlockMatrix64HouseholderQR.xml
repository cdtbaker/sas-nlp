<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.block.decomposition.qr">
        <import package="org.ejml.alg.block.BlockMatrixOps"/>
        <import package="org.ejml.alg.block.BlockMultiplication"/>
        <import package="org.ejml.data.BlockMatrix64F"/>
        <import package="org.ejml.data.D1Submatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <class name="BlockMatrix64HouseholderQR" line="28">
            <comment line="64">
                the input matrix which is overwritten with the decomposition.                
            </comment>
            <comment line="65">
                Reflectors are stored in the lower triangular portion. The R matrix is stored                
            </comment>
            <comment line="66">
                in the upper triangle portion                
            </comment>
            <comment line="69">
                where the computed W matrix is stored                
            </comment>
            <comment line="71">
                Matrix used to store an intermediate calculation                
            </comment>
            <comment line="74">
                size of the inner matrix block.                
            </comment>
            <comment line="77">
                The submatrices which are being manipulated in each iteration                
            </comment>
            <comment line="83">
                stores the computed gammas                
            </comment>
            <comment line="86">
                save the W matrix the first time it is computed in the decomposition                
            </comment>
            <implements interface="QRDecomposition">
                <type_params>
                    <type_param name="BlockMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="28">
                &lt;p&gt;
                  QR decomposition for {@link BlockMatrix64F} using householder reflectors.  The decomposition is
                  performed by computing a QR decomposition for each block column as is normally done, see {@link org.ejml.alg.dense.decomposition.qr.QRDecompositionHouseholder}.
                  The reflectors are then combined and applied to the remainder of the matrix.  This process is repeated
                  until all the block columns have been processed
                  &lt;/p&gt;
                  &lt;p&gt;
                  The input matrix is modified and used to store the decomposition.  Reflectors are stored in the lower triangle
                  columns.  The first element of the reflector is implicitly assumed to be one.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each iteration can be sketched as follows:
                  &lt;pre&gt;
                  QR_Decomposition( A(:,i-r to i) )
                  W=computeW( A(:,i-r to i) )
                  A(:,i:n) = (I + WY&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A(:,i:n)
                  &lt;/pre&gt;
                  Where r is the block size, i is the submatrix being considered, A is the input matrix,
                  Y is a matrix containing the reflectors just computed,
                  and W is computed using {@link BlockHouseHolder#computeW_Column}.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Based upon &quot;Block Householder QR Factorization&quot; pg 255 in &quot;Matrix Computations&quot;
                  3rd Ed. 1996 by Gene H. Golub and Charles F. Van Loan.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="dataA" type="BlockMatrix64F" line="66"/>
            <declaration name="dataW" type="BlockMatrix64F" line="69"/>
            <declaration name="dataWTA" type="BlockMatrix64F" line="71"/>
            <declaration name="blockLength" type="int" line="74"/>
            <declaration name="A" type="D1Submatrix64F" line="77"/>
            <declaration name="Y" type="D1Submatrix64F" line="78"/>
            <declaration name="W" type="D1Submatrix64F" line="79"/>
            <declaration name="WTA" type="D1Submatrix64F" line="80"/>
            <declaration name="temp" type="double" line="81"/>
            <declaration name="gammas" type="double" line="83"/>
            <declaration name="saveW" type="boolean" line="86"/>
            <javadoc line="88">
                This is the input matrix after it has been overwritten with the decomposition.                
                <return>
                    Internal matrix used to store decomposition.                    
                </return>
            </javadoc>
            <method name="getQR" type="BlockMatrix64F" line="93"/>
            <javadoc line="97">
                &lt;p&gt;
                  Sets if it should internally save the W matrix before performing the decomposition.  Must
                  be set before decomposition the matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Saving W can result in about a 5% savings when solving systems around a height of 5k.  The
                  price is that it needs to save a matrix the size of the input matrix.
                  &lt;/p&gt;                
                <param>
                    saveW If the W matrix should be saved or not.                    
                </param>
            </javadoc>
            <method name="setSaveW" type="void" line="110">
                <params>
                    <param name="saveW" type="boolean"/>
                </params>
            </method>
            <javadoc line="114">
                @inheritDoc                
            </javadoc>
            <method name="getQ" type="BlockMatrix64F" line="118">
                <params>
                    <param name="Q" type="BlockMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
            </method>
            <javadoc line="126">
                Sanity checks the input or declares a new matrix.  Return matrix is an identity matrix.                
            </javadoc>
            <method name="initializeQ" type="BlockMatrix64F" line="131">
                <params>
                    <param name="Q" type="BlockMatrix64F"/>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                    <param name="blockLength" type="int"/>
                    <param name="compact" type="boolean"/>
                </params>
                <declaration name="minLength" type="int" line="132"/>
                <scope line="133">
                    <scope line="134"/>
                    <scope line="137">
                        <scope line="138"/>
                        <scope line="140"/>
                    </scope>
                </scope>
                <scope line="144">
                    <scope line="145"/>
                    <scope line="148">
                        <scope line="149"/>
                        <scope line="151"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="159">
                &lt;p&gt;
                  Multiplies the provided matrix by Q using householder reflectors.  This is more
                  efficient that computing Q then applying it to the matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  B = Q  B
                  &lt;/p&gt;                
                <param>
                    B Matrix which Q is applied to.  Modified.                    
                </param>
            </javadoc>
            <method name="applyQ" type="void" line="171">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                </params>
            </method>
            <javadoc line="175">
                Specialized version of applyQ() that allows the zeros in an identity matrix
                  to be taken advantage of depending on if isIdentity is true or not.                
                <param>
                    B                    
                </param>
                <param>
                    isIdentity If B is an identity matrix.                    
                </param>
            </javadoc>
            <method name="applyQ" type="void" line="182">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                    <param name="isIdentity" type="boolean"/>
                </params>
                <comment line="197">
                    (Q1^T * (Q2^T * (Q3^t * A)))                    
                </comment>
                <comment line="212">
                    Compute W matrix from reflectors stored in Y                    
                </comment>
                <comment line="216">
                    Apply the Qi to Q                    
                </comment>
                <declaration name="minDimen" type="int" line="183"/>
                <declaration name="subB" type="D1Submatrix64F" line="185"/>
                <declaration name="start" type="int" line="191"/>
                <scope line="198"/>
            </method>
            <javadoc line="222">
                &lt;p&gt;
                  Multiplies the provided matrix by Q&lt;sup&gt;T&lt;/sup&gt; using householder reflectors.  This is more
                  efficient that computing Q then applying it to the matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Q = Q(I - &amp;gamma; WY^T)&lt;br&gt;
                  QR = A =&gt; R = Q^TA  = (Q3^T  (Q2^T  (Q1^t  A)))
                  &lt;/p&gt;                
                <param>
                    B Matrix which Q is applied to.  Modified.                    
                </param>
            </javadoc>
            <method name="applyQTran" type="void" line="235">
                <params>
                    <param name="B" type="BlockMatrix64F"/>
                </params>
                <comment line="244">
                    (Q3^T * (Q2^T * (Q1^t * A)))                    
                </comment>
                <comment line="252">
                    subB.row1 = B.numRows;                    
                </comment>
                <comment line="253">
                    subB.col0 = 0;                    
                </comment>
                <comment line="254">
                    subB.col1 = B.numCols;                    
                </comment>
                <comment line="257">
                    W.original.reshape(W.row1,W.col1,false);                    
                </comment>
                <comment line="264">
                    Compute W matrix from reflectors stored in Y                    
                </comment>
                <comment line="268">
                    Apply the Qi to Q                    
                </comment>
                <declaration name="minDimen" type="int" line="236"/>
                <declaration name="subB" type="D1Submatrix64F" line="238"/>
                <scope line="245"/>
            </method>
            <javadoc line="274">
                @inheritDoc                
            </javadoc>
            <method name="getR" type="BlockMatrix64F" line="278">
                <params>
                    <param name="R" type="BlockMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <declaration name="min" type="int" line="279"/>
                <scope line="281">
                    <scope line="282"/>
                    <scope line="284"/>
                </scope>
                <scope line="287">
                    <scope line="288">
                        <scope line="289"/>
                    </scope>
                    <scope line="292"/>
                </scope>
            </method>
            <javadoc line="303">
                @inheritDoc                
            </javadoc>
            <method name="decompose" type="boolean" line="307">
                <params>
                    <param name="orig" type="BlockMatrix64F"/>
                </params>
                <comment line="312">
                    process the matrix one column block at a time and overwrite the input matrix                    
                </comment>
                <comment line="318">
                    compute the QR decomposition of the left most block column                    
                </comment>
                <comment line="319">
                    this overwrites the original input matrix                    
                </comment>
                <comment line="324">
                    Update the remainder of the matrix using the reflectors just computed                    
                </comment>
                <declaration name="m" type="int" line="310"/>
                <scope line="313">
                    <scope line="320"/>
                </scope>
            </method>
            <javadoc line="331">
                Adjust submatrices and helper data structures for the input matrix.  Must be called
                  before the decomposition can be computed.                
                <param>
                    orig                    
                </param>
            </javadoc>
            <method name="setup" type="void" line="337">
                <params>
                    <param name="orig" type="BlockMatrix64F"/>
                </params>
                <declaration name="l" type="int" line="345"/>
                <scope line="355"/>
            </method>
            <javadoc line="360">
                &lt;p&gt;
                  A = (I + W Y&lt;sup&gt;T&lt;/sup&gt;)&lt;sup&gt;T&lt;/sup&gt;A&lt;BR&gt;
                  A = A + Y (W&lt;sup&gt;T&lt;/sup&gt;A)&lt;BR&gt;
                  &lt;br&gt;
                  where A is a submatrix of the input matrix.
                  &lt;/p&gt;                
            </javadoc>
            <method name="updateA" type="void" line="369">
                <params>
                    <param name="A" type="D1Submatrix64F"/>
                </params>
                <scope line="383"/>
                <scope line="388"/>
            </method>
            <javadoc line="393">
                Sets the submatrix of W up give Y is already configured and if it is being cached or not.                
            </javadoc>
            <method name="setW" type="void" line="396">
                <scope line="397"/>
                <scope line="402"/>
            </method>
            <javadoc line="408">
                The input matrix is always modified.                
                <return>
                    Returns true since the input matrix is modified.                    
                </return>
            </javadoc>
            <method name="inputModified" type="boolean" line="414"/>
        </class>
    </source>