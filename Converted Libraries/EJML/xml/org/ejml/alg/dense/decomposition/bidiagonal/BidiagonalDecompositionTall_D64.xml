<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.bidiagonal">
        <import package="org.ejml.UtilEjml"/>
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.DecompositionFactory"/>
        <import package="org.ejml.interfaces.decomposition.BidiagonalDecomposition"/>
        <import package="org.ejml.interfaces.decomposition.QRPDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="BidiagonalDecompositionTall_D64" line="29">
            <comment line="59">
                TODO optimize this code                
            </comment>
            <comment line="63">
                todo this should be passed in                
            </comment>
            <comment line="68">
                number of rows                
            </comment>
            <comment line="70">
                number of column                
            </comment>
            <comment line="72">
                min(m,n)                
            </comment>
            <implements interface="BidiagonalDecomposition">
                <type_params>
                    <type_param name="DenseMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="29">
                &lt;p&gt;{@link org.ejml.interfaces.decomposition.BidiagonalDecomposition} specifically designed for tall matrices.
                  First step is to perform QR decomposition on the input matrix.  Then R is decomposed using
                  a bidiagonal decomposition.  By performing the bidiagonal decomposition on the smaller matrix
                  computations can be saved if m/n &gt; 5/3 and if U is NOT needed.
                  &lt;/p&gt;
                  &lt;p&gt;
                  A = [Q&lt;sub&gt;1&lt;/sub&gt; Q&lt;sub&gt;2&lt;/sub&gt;][U1 0; 0 I] [B1;0] V&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
                  U=[Q&lt;sub&gt;1&lt;/sub&gt;U1 Q&lt;sub&gt;2&lt;/sub&gt;]&lt;br&gt;
                  B=[B1;0]&lt;br&gt;
                  A = UBV&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  A QRP decomposition is used internally.  That decomposition relies an a fixed threshold for selecting singular
                  values and is known to be less stable than SVD.  There is the potential for a degregation of stability
                  by using BidiagonalDecompositionTall instead of BidiagonalDecomposition. A few simple tests have shown
                  that loss in stability to be insignificant.
                  &lt;/p&gt;
                  &lt;p&gt;
                  See page 404 in &quot;Fundamentals of Matrix Computations&quot;, 2nd by David S. Watkins.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="decompQRP" type="QRPDecomposition&amp;lt;DenseMatrix64F&amp;gt;" line="62"/>
            <declaration name="decompBi" type="BidiagonalDecomposition&amp;lt;DenseMatrix64F&amp;gt;" line="63"/>
            <declaration name="B" type="DenseMatrix64F" line="65"/>
            <declaration name="m" type="int" line="68"/>
            <declaration name="n" type="int" line="70"/>
            <declaration name="min" type="int" line="72"/>
            <method name="getDiagonal" type="void" line="75">
                <params>
                    <param name="diag" type="double[]"/>
                    <param name="off" type="double[]"/>
                </params>
                <scope line="77"/>
            </method>
            <method name="getB" type="DenseMatrix64F" line="84">
                <params>
                    <param name="B" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="88"/>
            </method>
            <method name="getU" type="DenseMatrix64F" line="99">
                <params>
                    <param name="U" type="DenseMatrix64F"/>
                    <param name="transpose" type="boolean"/>
                    <param name="compact" type="boolean"/>
                </params>
                <comment line="104">
                    U = Q*U1                    
                </comment>
                <comment line="109">
                    U = [Q1*U1 Q2]                    
                </comment>
                <scope line="102">
                    <declaration name="Q1" type="DenseMatrix64F" line="104"/>
                    <declaration name="U1" type="DenseMatrix64F" line="105"/>
                </scope>
                <scope line="107">
                    <declaration name="Q" type="DenseMatrix64F" line="109"/>
                    <declaration name="U1" type="DenseMatrix64F" line="110"/>
                    <declaration name="Q1" type="DenseMatrix64F" line="111"/>
                    <declaration name="tmp" type="DenseMatrix64F" line="112"/>
                </scope>
            </method>
            <method name="getV" type="DenseMatrix64F" line="124">
                <params>
                    <param name="V" type="DenseMatrix64F"/>
                    <param name="transpose" type="boolean"/>
                    <param name="compact" type="boolean"/>
                </params>
            </method>
            <method name="decompose" type="boolean" line="129">
                <params>
                    <param name="orig" type="DenseMatrix64F"/>
                </params>
                <comment line="144">
                    apply the column pivots.
                     TODO this is horribly inefficient                    
                </comment>
                <scope line="132"/>
                <declaration name="result" type="DenseMatrix64F" line="145"/>
                <declaration name="P" type="DenseMatrix64F" line="146"/>
            </method>
            <method name="inputModified" type="boolean" line="154"/>
        </class>
    </source>