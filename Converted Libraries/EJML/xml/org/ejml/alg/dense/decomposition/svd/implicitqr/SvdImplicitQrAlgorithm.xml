<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.svd.implicitqr">
        <import package="org.ejml.UtilEjml"/>
        <import package="org.ejml.alg.dense.decomposition.eig.EigenvalueSmall"/>
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.simple.SimpleMatrix"/>
        <import package="java.util.Random"/>
        <class name="SvdImplicitQrAlgorithm" line="7">
            <javadoc line="7">
                &lt;p&gt;
                  Computes the QR decomposition of a bidiagonal matrix.  Internally this matrix is stored as
                  two arrays.  Shifts can either be provided to it or it can generate the shifts on its own.
                  It optionally computes the U and V matrices.  This comparability allows it to be used to
                  compute singular values and associated matrices efficiently.&lt;br&gt;
                  &lt;br&gt;
                  A = USV&lt;sup&gt;T&lt;/sup&gt;&lt;br&gt;
                  where A is the original m by n matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Based off of the outline provided in:&lt;br&gt;
                  &lt;br&gt;
                  David S. Watkins, &quot;Fundamentals of Matrix Computations,&quot; Second Edition. Page 404-411
                  &lt;/p&gt;
                  &lt;p&gt;
                  Note: To watch it process the matrix step by step uncomment commented out code.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="rand" type="Random" line="28"/>
            <declaration name="Ut" type="DenseMatrix64F" line="29"/>
            <declaration name="Vt" type="DenseMatrix64F" line="30"/>
            <declaration name="totalSteps" type="int" line="31"/>
            <declaration name="maxValue" type="double" line="32"/>
            <declaration name="N" type="int" line="33"/>
            <declaration name="eigenSmall" type="EigenvalueSmall" line="34"/>
            <declaration name="numExceptional" type="int" line="35"/>
            <declaration name="nextExceptional" type="int" line="36"/>
            <declaration name="diag" type="double" line="37"/>
            <declaration name="off" type="double" line="38"/>
            <declaration name="bulge" type="double" line="39"/>
            <declaration name="x1" type="int" line="40"/>
            <declaration name="x2" type="int" line="41"/>
            <declaration name="steps" type="int" line="42"/>
            <declaration name="splits" type="int" line="43"/>
            <declaration name="numSplits" type="int" line="44"/>
            <declaration name="exceptionalThresh" type="int" line="45"/>
            <declaration name="maxIterations" type="int" line="46"/>
            <declaration name="followScript" type="boolean" line="47"/>
            <declaration name="giveUpOnKnown" type="int" line="48"/>
            <declaration name="values" type="double" line="49"/>
            <declaration name="fastValues" type="boolean" line="50"/>
            <declaration name="findingZeros" type="boolean" line="51"/>
            <declaration name="c" type="double" line="52"/>
            <method name="SvdImplicitQrAlgorithm" type="constructor" line="53">
                <params>
                    <param name="fastValues" type="boolean"/>
                </params>
            </method>
            <method name="SvdImplicitQrAlgorithm" type="constructor" line="56"/>
            <method name="getUt" type="DenseMatrix64F" line="58"/>
            <method name="setUt" type="void" line="61">
                <params>
                    <param name="ut" type="DenseMatrix64F"/>
                </params>
            </method>
            <method name="getVt" type="DenseMatrix64F" line="64"/>
            <method name="setVt" type="void" line="67">
                <params>
                    <param name="vt" type="DenseMatrix64F"/>
                </params>
            </method>
            <javadoc line="70">
                                
            </javadoc>
            <method name="setMatrix" type="void" line="72">
                <params>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                    <param name="diag" type="double"/>
                    <param name="off" type="double"/>
                </params>
                <scope line="77">
                    <declaration name="a" type="double" line="78"/>
                    <declaration name="b" type="double" line="79"/>
                    <scope line="80"/>
                    <scope line="83"/>
                </scope>
            </method>
            <method name="swapDiag" type="double[]" line="88">
                <params>
                    <param name="diag" type="double"/>
                </params>
                <declaration name="ret" type="double[]" line="89"/>
            </method>
            <method name="swapOff" type="double[]" line="93">
                <params>
                    <param name="off" type="double"/>
                </params>
                <declaration name="ret" type="double[]" line="94"/>
            </method>
            <method name="setMaxValue" type="void" line="98">
                <params>
                    <param name="maxValue" type="double"/>
                </params>
            </method>
            <method name="initParam" type="void" line="101">
                <params>
                    <param name="M" type="int"/>
                    <param name="N" type="int"/>
                </params>
                <scope line="104"/>
            </method>
            <method name="process" type="boolean" line="115"/>
            <javadoc line="120">
                Perform a sequence of steps based off of the singular values provided.                
                <param>
                    values                    
                </param>
                <return>
                                        
                </return>
            </javadoc>
            <method name="process" type="boolean" line="125">
                <params>
                    <param name="values" type="double"/>
                </params>
            </method>
            <method name="_process" type="boolean" line="131">
                <scope line="133">
                    <scope line="134"/>
                    <scope line="137"/>
                    <scope line="141"/>
                    <scope line="146"/>
                    <scope line="149">
                        <scope line="150">
                            <scope line="151"/>
                            <scope line="154"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="162">
                Here the lambda in the implicit step is determined dynamically.  At first
                  it selects zeros to quickly reveal singular values that are zero or close to zero.
                  Then it computes it using a Wilkinson shift.                
            </javadoc>
            <method name="performDynamicStep" type="void" line="167">
                <scope line="168">
                    <scope line="169"/>
                    <scope line="172">
                        <declaration name="scale" type="double" line="173"/>
                    </scope>
                </scope>
                <scope line="177">
                    <declaration name="scale" type="double" line="178"/>
                    <declaration name="lambda" type="double" line="179"/>
                </scope>
            </method>
            <javadoc line="183">
                Shifts are performed based upon singular values computed previously.  If it does not converge
                  using one of those singular values it uses a Wilkinson shift instead.                
            </javadoc>
            <method name="performScriptedStep" type="void" line="187">
                <declaration name="scale" type="double" line="188"/>
                <scope line="189"/>
                <scope line="192">
                    <declaration name="s" type="double" line="193"/>
                </scope>
            </method>
            <method name="incrementSteps" type="void" line="197"/>
            <method name="isOffZero" type="boolean" line="201">
                <params>
                    <param name="i" type="int"/>
                </params>
                <declaration name="bottom" type="double" line="202"/>
            </method>
            <method name="isDiagonalZero" type="boolean" line="205">
                <params>
                    <param name="i" type="int"/>
                </params>
                <declaration name="bottom" type="double" line="206"/>
            </method>
            <method name="resetSteps" type="void" line="209"/>
            <javadoc line="214">
                Tells it to process the submatrix at the next split.  Should be called after the
                  current submatrix has been processed.                
            </javadoc>
            <method name="nextSplit" type="boolean" line="218"/>
            <javadoc line="225">
                Given the lambda value perform an implicit QR step on the matrix.
                  B^TB-lambdaI                
                <param>
                    lambda Stepping factor.                    
                </param>
            </javadoc>
            <method name="performImplicitSingleStep" type="void" line="230">
                <params>
                    <param name="scale" type="double"/>
                    <param name="lambda" type="double"/>
                    <param name="byAngle" type="boolean"/>
                </params>
                <scope line="232"/>
            </method>
            <javadoc line="240">
                Multiplied a transpose orthogonal matrix Q by the specified rotator.  This is used
                  to update the U and V matrices.  Updating the transpose of the matrix is faster
                  since it only modifies the rows.                
                <param>
                    Q Orthogonal matrix                    
                </param>
                <param>
                    m Coordinate of rotator.                    
                </param>
                <param>
                    n Coordinate of rotator.                    
                </param>
                <param>
                    c cosine of rotator.                    
                </param>
                <param>
                    s sine of rotator.                    
                </param>
            </javadoc>
            <method name="updateRotator" type="void" line="250">
                <params>
                    <param name="Q" type="DenseMatrix64F"/>
                    <param name="m" type="int"/>
                    <param name="n" type="int"/>
                    <param name="c" type="double"/>
                    <param name="s" type="double"/>
                </params>
                <declaration name="rowA" type="int" line="251"/>
                <declaration name="rowB" type="int" line="252"/>
                <declaration name="endA" type="int" line="253"/>
                <scope line="254">
                    <declaration name="a" type="double" line="255"/>
                    <declaration name="b" type="double" line="256"/>
                </scope>
            </method>
            <method name="computeBulgeScale" type="double" line="261">
                <declaration name="b11" type="double" line="262"/>
                <declaration name="b12" type="double" line="263"/>
            </method>
            <javadoc line="266">
                Performs a similar transform on B&lt;sup&gt;T&lt;/sup&gt;B-pI                
            </javadoc>
            <method name="createBulge" type="void" line="269">
                <params>
                    <param name="x1" type="int"/>
                    <param name="p" type="double"/>
                    <param name="scale" type="double"/>
                    <param name="byAngle" type="boolean"/>
                </params>
                <declaration name="b11" type="double" line="270"/>
                <declaration name="b12" type="double" line="271"/>
                <declaration name="b22" type="double" line="272"/>
                <scope line="273"/>
                <scope line="277">
                    <declaration name="u1" type="double" line="278"/>
                    <declaration name="u2" type="double" line="279"/>
                    <declaration name="gamma" type="double" line="280"/>
                </scope>
                <scope line="288"/>
            </method>
            <javadoc line="292">
                Computes a rotator that will set run to zero (?)                
            </javadoc>
            <method name="computeRotator" type="void" line="295">
                <params>
                    <param name="rise" type="double"/>
                    <param name="run" type="double"/>
                </params>
                <scope line="296">
                    <declaration name="k" type="double" line="297"/>
                    <declaration name="bottom" type="double" line="298"/>
                </scope>
                <scope line="302">
                    <declaration name="t" type="double" line="303"/>
                    <declaration name="bottom" type="double" line="304"/>
                </scope>
            </method>
            <method name="removeBulgeLeft" type="void" line="309">
                <params>
                    <param name="x1" type="int"/>
                    <param name="notLast" type="boolean"/>
                </params>
                <declaration name="b11" type="double" line="310"/>
                <declaration name="b12" type="double" line="311"/>
                <declaration name="b22" type="double" line="312"/>
                <scope line="317">
                    <declaration name="b23" type="double" line="318"/>
                </scope>
                <scope line="322"/>
            </method>
            <method name="removeBulgeRight" type="void" line="326">
                <params>
                    <param name="x1" type="int"/>
                </params>
                <declaration name="b12" type="double" line="327"/>
                <declaration name="b22" type="double" line="328"/>
                <declaration name="b23" type="double" line="329"/>
                <declaration name="b33" type="double" line="334"/>
                <scope line="337"/>
            </method>
            <method name="setSubmatrix" type="void" line="341">
                <params>
                    <param name="x1" type="int"/>
                    <param name="x2" type="int"/>
                </params>
            </method>
            <javadoc line="345">
                Selects the Wilkinson&apos;s shift for B&lt;sup&gt;T&lt;/sup&gt;B.  See page 410.  It is guaranteed to converge
                  and converges fast in practice.                
                <param>
                    scale Scale factor used to help prevent overflow/underflow                    
                </param>
                <return>
                    Shifting factor lambda/(scalescale)                    
                </return>
            </javadoc>
            <method name="selectWilkinsonShift" type="double" line="351">
                <params>
                    <param name="scale" type="double"/>
                </params>
                <declaration name="a11" type="double" line="352"/>
                <scope line="353">
                    <declaration name="d1" type="double" line="354"/>
                    <declaration name="o1" type="double" line="355"/>
                    <declaration name="d2" type="double" line="356"/>
                    <declaration name="o2" type="double" line="357"/>
                </scope>
                <scope line="362">
                    <declaration name="a" type="double" line="363"/>
                    <declaration name="b" type="double" line="364"/>
                    <declaration name="c" type="double" line="365"/>
                </scope>
                <declaration name="diff0" type="double" line="370"/>
                <declaration name="diff1" type="double" line="371"/>
            </method>
            <javadoc line="374">
                Computes the eigenvalue of the 2 by 2 matrix B&lt;sup&gt;T&lt;/sup&gt;B                
            </javadoc>
            <method name="eigenBB_2x2" type="void" line="377">
                <params>
                    <param name="x1" type="int"/>
                </params>
                <declaration name="b11" type="double" line="378"/>
                <declaration name="b12" type="double" line="379"/>
                <declaration name="b22" type="double" line="380"/>
                <declaration name="absA" type="double" line="381"/>
                <declaration name="absB" type="double" line="382"/>
                <declaration name="absC" type="double" line="383"/>
                <declaration name="scale" type="double" line="384"/>
                <declaration name="sgn" type="double" line="393"/>
            </method>
            <javadoc line="396">
                Checks to see if either the diagonal element or off diagonal element is zero.  If one is
                  then it performs a split or pushes it off the matrix.                
                <return>
                    True if there was a zero.                    
                </return>
            </javadoc>
            <method name="checkForAndHandleZeros" type="boolean" line="401">
                <scope line="402">
                    <scope line="403"/>
                </scope>
                <scope line="410">
                    <scope line="411"/>
                </scope>
            </method>
            <javadoc line="421">
                If there is a zero on the diagonal element, the off diagonal element needs pushed
                  off so that all the algorithms assumptions are two and so that it can split the matrix.                
            </javadoc>
            <method name="pushRight" type="void" line="425">
                <params>
                    <param name="row" type="int"/>
                </params>
                <declaration name="end" type="int" line="428"/>
                <scope line="429"/>
            </method>
            <javadoc line="433">
                Start pushing the element off to the right.                
            </javadoc>
            <method name="rotatorPushRight" type="void" line="436">
                <params>
                    <param name="m" type="int"/>
                </params>
                <declaration name="b11" type="double" line="437"/>
                <declaration name="b21" type="double" line="438"/>
                <scope line="442">
                    <declaration name="b22" type="double" line="443"/>
                </scope>
                <scope line="447"/>
                <scope line="450"/>
            </method>
            <javadoc line="454">
                Used to finish up pushing the bulge off the matrix.                
            </javadoc>
            <method name="rotatorPushRight2" type="void" line="457">
                <params>
                    <param name="m" type="int"/>
                    <param name="offset" type="int"/>
                </params>
                <declaration name="b11" type="double" line="458"/>
                <declaration name="b12" type="double" line="459"/>
                <scope line="462">
                    <declaration name="b22" type="double" line="463"/>
                </scope>
                <scope line="467"/>
            </method>
            <javadoc line="471">
                It is possible for the QR algorithm to get stuck in a loop because of symmetries.  This happens
                  more often with larger matrices.  By taking a random step it can break the symmetry and finish.                
            </javadoc>
            <method name="exceptionShift" type="void" line="475">
                <declaration name="mag" type="double" line="477"/>
                <declaration name="angle" type="double" line="479"/>
            </method>
            <javadoc line="483">
                Creates a Q matrix for debugging purposes.                
            </javadoc>
            <method name="createQ" type="SimpleMatrix" line="486">
                <params>
                    <param name="x1" type="int"/>
                    <param name="c" type="double"/>
                    <param name="s" type="double"/>
                    <param name="transposed" type="boolean"/>
                </params>
            </method>
            <javadoc line="489">
                Creates a Q matrix for debugging purposes.                
            </javadoc>
            <method name="createQ" type="SimpleMatrix" line="492">
                <params>
                    <param name="x1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="c" type="double"/>
                    <param name="s" type="double"/>
                    <param name="transposed" type="boolean"/>
                </params>
                <declaration name="Q" type="SimpleMatrix" line="493"/>
                <scope line="495"/>
                <scope line="499"/>
            </method>
            <method name="createB" type="SimpleMatrix" line="506">
                <declaration name="B" type="SimpleMatrix" line="507"/>
                <scope line="508"/>
            </method>
            <method name="printMatrix" type="void" line="515">
                <scope line="517"/>
                <scope line="522"/>
            </method>
            <method name="getNumberOfSingularValues" type="int" line="527"/>
            <method name="getSingularValue" type="double" line="530">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="setFastValues" type="void" line="533">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="getSingularValues" type="double[]" line="536"/>
            <method name="getDiag" type="double[]" line="539"/>
            <method name="getOff" type="double[]" line="542"/>
            <method name="getMaxValue" type="double" line="545"/>
        </class>
    </source>