<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <class name="QrHelperFunctions" line="24">
            <javadoc line="24">
                &lt;p&gt;
                  Contains different functions that are useful for computing the QR decomposition of a matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Two different families of functions are provided for help in computing reflectors.  Internally
                  both of these functions switch between normalization by division or multiplication.  Multiplication
                  is most often significantly faster than division (2 or 3 times) but produces less accurate results
                  on very small numbers.  It checks to see if round off error is significant and decides which
                  one it should do.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Tests were done using the stability benchmark in jmatbench and there doesn&apos;t seem to be
                  any advantage to always dividing by the max instead of checking and deciding.  The most
                  noticeable difference between the two methods is with very small numbers.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <method name="findMax" type="double" line="47">
                <params>
                    <param name="u" type="double[]"/>
                    <param name="startU" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <declaration name="max" type="double" line="48"/>
                <declaration name="index" type="int" line="50"/>
                <declaration name="stopIndex" type="int" line="51"/>
                <scope line="52">
                    <declaration name="val" type="double" line="53"/>
                </scope>
            </method>
            <method name="divideElements" type="void" line="63">
                <params>
                    <param name="j" type="int"/>
                    <param name="numRows" type="int"/>
                    <param name="u" type="double[]"/>
                    <param name="u_0" type="double"/>
                </params>
                <comment line="65">
                    double div_u = 1.0/u_0;
                    
                            if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="71">
                    } else {
                                for( int i = j; i &lt; numRows; i++ ) {
                                    u[i] *= div_u;
                                }
                            }                    
                </comment>
                <scope line="67"/>
            </method>
            <method name="divideElements" type="void" line="77">
                <params>
                    <param name="j" type="int"/>
                    <param name="numRows" type="int"/>
                    <param name="u" type="double[]"/>
                    <param name="startU" type="int"/>
                    <param name="u_0" type="double"/>
                </params>
                <comment line="79">
                    double div_u = 1.0/u_0;
                    
                            if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="85">
                    } else {
                                for( int i = j; i &lt; numRows; i++ ) {
                                    u[i+startU] *= div_u;
                                }
                            }                    
                </comment>
                <scope line="81"/>
            </method>
            <method name="divideElements_Brow" type="void" line="93">
                <params>
                    <param name="j" type="int"/>
                    <param name="numRows" type="int"/>
                    <param name="u" type="double[]"/>
                    <param name="b" type="double"/>
                    <param name="startB" type="int"/>
                    <param name="u_0" type="double"/>
                </params>
                <comment line="95">
                    double div_u = 1.0/u_0;
                    
                            if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="101">
                    } else {
                                for( int i = j; i &lt; numRows; i++ ) {
                                    u[i] = b[i+startB] *= div_u;
                                }
                            }                    
                </comment>
                <scope line="97"/>
            </method>
            <method name="divideElements_Bcol" type="void" line="110">
                <params>
                    <param name="j" type="int"/>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                    <param name="u" type="double[]"/>
                    <param name="b" type="double"/>
                    <param name="startB" type="int"/>
                    <param name="u_0" type="double"/>
                </params>
                <comment line="112">
                    double div_u = 1.0/u_0;
                    
                            if( Double.isInfinite(div_u)) {                    
                </comment>
                <comment line="119">
                    } else {
                                int indexB = j*numCols+startB;
                                for( int i = j; i &lt; numRows; i++ , indexB += numCols ) {
                                    b[indexB] = u[i] *= div_u;
                                }
                            }                    
                </comment>
                <declaration name="indexB" type="int" line="114"/>
                <scope line="115"/>
            </method>
            <method name="computeTauAndDivide" type="double" line="126">
                <params>
                    <param name="j" type="int"/>
                    <param name="numRows" type="int"/>
                    <param name="u" type="double[]"/>
                    <param name="startU" type="int"/>
                    <param name="max" type="double"/>
                </params>
                <comment line="128">
                    compute the norm2 of the matrix, with each element
                     normalized by the max value to avoid overflow problems                    
                </comment>
                <comment line="131">
                    double div_max = 1.0/max;
                            if( Double.isInfinite(div_max)) {                    
                </comment>
                <comment line="133">
                    more accurate                    
                </comment>
                <comment line="138">
                    } else {
                                 faster
                                for( int i = j; i &lt; numRows; i++ ) {
                                    double d = u[startU+i] *= div_max;
                                    tau += d*d;
                                }
                            }                    
                </comment>
                <declaration name="tau" type="double" line="129"/>
                <scope line="133">
                    <declaration name="d" type="double" line="134"/>
                </scope>
            </method>
            <javadoc line="152">
                Normalizes elements in &apos;u&apos; by dividing by max and computes the norm2 of the normalized
                  array u.  Adjust the sign of the returned value depending on the size of the first
                  element in &apos;u&apos;. Normalization is done to avoid overflow.
                  &lt;pre&gt;
                  for i=j:numRows
                  u[i] = u[i] / max
                  tau = tau + u[i]u[i]
                  end
                  tau = sqrt(tau)
                  if( u[j] &lt; 0 )
                  tau = -tau;
                  &lt;/pre&gt;                
                <param>
                    j Element in 'u' that it starts at.                    
                </param>
                <param>
                    numRows Element in 'u' that it stops at.                    
                </param>
                <param>
                    u Array                    
                </param>
                <param>
                    max Max value in 'u' that is used to normalize it.                    
                </param>
                <return>
                    norm2 of 'u'                    
                </return>
            </javadoc>
            <method name="computeTauAndDivide" type="double" line="174">
                <params>
                    <param name="j" type="int"/>
                    <param name="numRows" type="int"/>
                    <param name="u" type="double[]"/>
                    <param name="max" type="double"/>
                </params>
                <comment line="177">
                    double div_max = 1.0/max;
                            if( Double.isInfinite(div_max)) {                    
                </comment>
                <comment line="183">
                    } else {
                                for( int i = j; i &lt; numRows; i++ ) {
                                    double d = u[i] *= div_max;
                                    tau += d*d;
                                }
                            }                    
                </comment>
                <declaration name="tau" type="double" line="175"/>
                <scope line="178">
                    <declaration name="d" type="double" line="179"/>
                </scope>
            </method>
            <javadoc line="196">
                &lt;p&gt;
                  Performs a rank-1 update operation on the submatrix specified by w with the multiply on the right.&lt;br&gt;
                  &lt;br&gt;
                  A = (I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;)A&lt;br&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  The order that matrix multiplies are performed has been carefully selected
                  to minimize the number of operations.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Before this can become a truly generic operation the submatrix specification needs
                  to be made more generic.
                  &lt;/p&gt;                
            </javadoc>
            <method name="rank1UpdateMultR" type="void" line="216">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                    <param name="u" type="double"/>
                    <param name="gamma" type="double"/>
                    <param name="colA0" type="int"/>
                    <param name="w0" type="int"/>
                    <param name="w1" type="int"/>
                    <param name="_temp" type="double"/>
                </params>
                <comment line="218">
                    for( int i = colA0; i &lt; A.numCols; i++ ) {
                                double val = 0;
                    
                                for( int k = w0; k &lt; w1; k++ ) {
                                    val += u[k]*A.data[k*A.numCols +i];
                                }
                                _temp[i] = gamma*val;
                            }                    
                </comment>
                <comment line="227">
                    reordered to reduce cpu cache issues                    
                </comment>
                <comment line="243">
                    end of reorder                    
                </comment>
                <scope line="227"/>
                <scope line="231">
                    <declaration name="indexA" type="int" line="232"/>
                    <declaration name="valU" type="double" line="233"/>
                    <scope line="234"/>
                </scope>
                <scope line="238"/>
                <scope line="244">
                    <declaration name="valU" type="double" line="245"/>
                    <declaration name="indexA" type="int" line="247"/>
                    <scope line="248"/>
                </scope>
            </method>
            <method name="rank1UpdateMultR" type="void" line="260">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                    <param name="u" type="double"/>
                    <param name="offsetU" type="int"/>
                    <param name="gamma" type="double"/>
                    <param name="colA0" type="int"/>
                    <param name="w0" type="int"/>
                    <param name="w1" type="int"/>
                    <param name="_temp" type="double"/>
                </params>
                <comment line="262">
                    for( int i = colA0; i &lt; A.numCols; i++ ) {
                                double val = 0;
                    
                                for( int k = w0; k &lt; w1; k++ ) {
                                    val += u[k+offsetU]*A.data[k*A.numCols +i];
                                }
                                _temp[i] = gamma*val;
                            }                    
                </comment>
                <comment line="271">
                    reordered to reduce cpu cache issues                    
                </comment>
                <comment line="287">
                    end of reorder                    
                </comment>
                <scope line="271"/>
                <scope line="275">
                    <declaration name="indexA" type="int" line="276"/>
                    <declaration name="valU" type="double" line="277"/>
                    <scope line="278"/>
                </scope>
                <scope line="282"/>
                <scope line="288">
                    <declaration name="valU" type="double" line="289"/>
                    <declaration name="indexA" type="int" line="291"/>
                    <scope line="292"/>
                </scope>
            </method>
            <javadoc line="298">
                &lt;p&gt;
                  Performs a rank-1 update operation on the submatrix specified by w with the multiply on the left.&lt;br&gt;
                  &lt;br&gt;
                  A = A(I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;)&lt;br&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  The order that matrix multiplies are performed has been carefully selected
                  to minimize the number of operations.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Before this can become a truly generic operation the submatrix specification needs
                  to be made more generic.
                  &lt;/p&gt;                
            </javadoc>
            <method name="rank1UpdateMultL" type="void" line="318">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                    <param name="u" type="double"/>
                    <param name="gamma" type="double"/>
                    <param name="colA0" type="int"/>
                    <param name="w0" type="int"/>
                    <param name="w1" type="int"/>
                </params>
                <scope line="319">
                    <declaration name="startIndex" type="int" line="320"/>
                    <declaration name="sum" type="double" line="321"/>
                    <declaration name="rowIndex" type="int" line="322"/>
                    <scope line="323"/>
                    <scope line="329"/>
                </scope>
            </method>
        </class>
    </source>