<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.interfaces.decomposition.QRPDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="QRColPivDecompositionHouseholderColumn_D64" line="25">
            <extends class="QRDecompositionHouseholderColumn_D64"/>
            <comment line="49">
                the ordering of each column, the current column i is the original column pivots[i]                
            </comment>
            <comment line="51">
                F-norm  squared for each column                
            </comment>
            <comment line="54">
                threshold used to determine when a column is considered to be singular
                 Threshold is relative to the maxAbs                
            </comment>
            <comment line="58">
                the matrix&apos;s rank                
            </comment>
            <implements interface="QRPDecomposition">
                <type_params>
                    <type_param name="DenseMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="25">
                &lt;p&gt;
                  Performs QR decomposition with column pivoting.  To prevent overflow/underflow the whole matrix
                  is normalized by the max value, but columns are not normalized individually any more. To enable
                  code reuse it extends {@link QRDecompositionHouseholderColumn_D64} and functions from that class
                  are used whenever possible.  Columns are transposed into single arrays, which allow for
                  fast pivots.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Decomposition: AP = QR
                  &lt;/p&gt;
                  &lt;p&gt;
                  Based off the description in &quot;Fundamentals of Matrix Computations&quot;, 2nd by David S. Watkins.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="pivots" type="int" line="49"/>
            <declaration name="normsCol" type="double" line="51"/>
            <declaration name="singularThreshold" type="double" line="55"/>
            <declaration name="rank" type="int" line="58"/>
            <javadoc line="60">
                Configure parameters.                
                <param>
                    singularThreshold The singular threshold.                    
                </param>
            </javadoc>
            <method name="QRColPivDecompositionHouseholderColumn_D64" type="constructor" line="65">
                <params>
                    <param name="singularThreshold" type="double"/>
                </params>
            </method>
            <method name="QRColPivDecompositionHouseholderColumn_D64" type="constructor" line="69"/>
            <method name="setSingularThreshold" type="void" line="73">
                <params>
                    <param name="threshold" type="double"/>
                </params>
            </method>
            <method name="setExpectedMaxSize" type="void" line="78">
                <params>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                </params>
                <scope line="81"/>
            </method>
            <javadoc line="87">
                Computes the Q matrix from the information stored in the QR matrix.  This
                  operation requires about 4(m&lt;sup&gt;2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.                
                <param>
                    Q The orthogonal Q matrix.                    
                </param>
            </javadoc>
            <method name="getQ" type="DenseMatrix64F" line="94">
                <params>
                    <param name="Q" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="95">
                    <scope line="96"/>
                    <scope line="98">
                        <scope line="99"/>
                        <scope line="101"/>
                    </scope>
                </scope>
                <scope line="105">
                    <scope line="106"/>
                    <scope line="108">
                        <scope line="109"/>
                        <scope line="111"/>
                    </scope>
                </scope>
                <scope line="117">
                    <declaration name="u" type="double" line="118"/>
                    <declaration name="vv" type="double" line="120"/>
                </scope>
            </method>
            <javadoc line="129">
                &lt;p&gt;
                  To decompose the matrix &apos;A&apos; it must have full rank.  &apos;A&apos; is a &apos;m&apos; by &apos;n&apos; matrix.
                  It requires about 2nm&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The matrix provided here can be of different
                  dimension than the one specified in the constructor.  It just has to be smaller than or equal
                  to it.
                  &lt;/p&gt;                
            </javadoc>
            <method name="decompose" type="boolean" line="142">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <comment line="148">
                    initialize pivot variables                    
                </comment>
                <comment line="151">
                    go through each column and perform the decomposition                    
                </comment>
                <comment line="156">
                    if its degenerate stop processing                    
                </comment>
                <scope line="151"/>
            </method>
            <javadoc line="165">
                Sets the initial pivot ordering and compute the F-norm squared for each column                
            </javadoc>
            <method name="setupPivotInfo" type="void" line="168">
                <scope line="169">
                    <declaration name="c" type="double" line="171"/>
                    <declaration name="norm" type="double" line="172"/>
                    <scope line="173">
                        <declaration name="element" type="double" line="174"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="182">
                Performs an efficient update of each columns&apos; norm                
            </javadoc>
            <method name="updateNorms" type="void" line="185">
                <params>
                    <param name="j" type="int"/>
                </params>
                <comment line="198">
                    if a negative sum has been found then clearly too much precision has been last
                     and it should recompute the column norms from scratch                    
                </comment>
                <declaration name="foundNegative" type="boolean" line="186"/>
                <scope line="187">
                    <declaration name="e" type="double" line="188"/>
                    <scope line="191"/>
                </scope>
                <scope line="199">
                    <scope line="200">
                        <declaration name="u" type="double" line="201"/>
                        <declaration name="actual" type="double" line="202"/>
                        <scope line="203">
                            <declaration name="v" type="double" line="204"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="212">
                Finds the column with the largest normal and makes that the first column                
                <param>
                    j Current column being inspected                    
                </param>
            </javadoc>
            <method name="swapColumns" type="void" line="217">
                <params>
                    <param name="j" type="int"/>
                </params>
                <comment line="220">
                    find the column with the largest norm                    
                </comment>
                <comment line="230">
                    swap the columns                    
                </comment>
                <declaration name="largestIndex" type="int" line="220"/>
                <declaration name="largestNorm" type="double" line="221"/>
                <scope line="222">
                    <declaration name="n" type="double" line="223"/>
                    <scope line="224"/>
                </scope>
                <declaration name="tempC" type="double[]" line="230"/>
                <declaration name="tempN" type="double" line="233"/>
                <declaration name="tempP" type="int" line="236"/>
            </method>
            <javadoc line="241">
                &lt;p&gt;
                  Computes the householder vector &quot;u&quot; for the first column of submatrix j. The already computed
                  norm is used and checks to see if the matrix is singular at this point.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  This function finds the values of &apos;u&apos; and &apos;&amp;gamma;&apos;.
                  &lt;/p&gt;                
                <param>
                    j Which submatrix to work off of.                    
                </param>
                <return>
                    false if it is degenerate                    
                </return>
            </javadoc>
            <method name="householderPivot" type="boolean" line="257">
                <params>
                    <param name="j" type="int"/>
                </params>
                <comment line="261">
                    find the largest value in this column
                     this is used to normalize the column and mitigate overflow/underflow                    
                </comment>
                <comment line="268">
                    computes tau and normalizes u by max                    
                </comment>
                <comment line="271">
                    divide u by u_0                    
                </comment>
                <declaration name="u" type="double" line="258"/>
                <declaration name="max" type="double" line="262"/>
                <scope line="264"/>
                <scope line="266">
                    <declaration name="u_0" type="double" line="271"/>
                    <scope line="279"/>
                </scope>
            </method>
            <method name="getRank" type="int" line="290"/>
            <method name="getPivots" type="int[]" line="295"/>
            <method name="getPivotMatrix" type="DenseMatrix64F" line="300">
                <params>
                    <param name="P" type="DenseMatrix64F"/>
                </params>
                <scope line="307"/>
                <scope line="311"/>
            </method>
        </class>
    </source>