<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="QRDecompositionHouseholder" line="5">
            <implements interface="QRDecomposition">
                <type_params>
                    <type_param name="DenseMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="5">
                &lt;p&gt;
                  This variation of QR decomposition uses reflections to compute the Q matrix.
                  Each reflection uses a householder operations, hence its name.  To provide a meaningful solution
                  the original matrix must have full rank.  This is intended for processing of small to medium matrices.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Both Q and R are stored in the same m by n matrix.  Q is not stored directly, instead the u from
                  Q&lt;sub&gt;k&lt;/sub&gt;=(I-&amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;) is stored.  Decomposition requires about 2nm&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                  &lt;/p&gt;
                  &lt;p&gt;
                  See the QR reflections algorithm described in:&lt;br&gt;
                  David S. Watkins, &quot;Fundamentals of Matrix Computations&quot; 2nd Edition, 2002
                  &lt;/p&gt;
                  &lt;p&gt;
                  For the most part this is a straight forward implementation.  To improve performance on large matrices a column is writen to an array and the order
                  of some of the loops has been changed.  This will degrade performance noticeably on small matrices.  Since
                  it is unlikely that the QR decomposition would be a bottle neck when small matrices are involved only
                  one implementation is provided.
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="QR" type="DenseMatrix64F" line="28"/>
            <javadoc line="28">
                Where the Q and R matrices are stored.  R is stored in the
                  upper triangular portion and Q on the lower bit.  Lower columns
                  are where u is stored.  Q_k = (I - gamma_ku_ku_k^T).                
            </javadoc>
            <declaration name="u" type="double" line="34"/>
            <declaration name="numCols" type="int" line="35"/>
            <declaration name="numRows" type="int" line="36"/>
            <declaration name="minLength" type="int" line="37"/>
            <declaration name="dataQR" type="double" line="38"/>
            <declaration name="gammas" type="double" line="39"/>
            <declaration name="gamma" type="double" line="40"/>
            <declaration name="tau" type="double" line="41"/>
            <declaration name="error" type="boolean" line="42"/>
            <method name="setExpectedMaxSize" type="void" line="43">
                <params>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                </params>
                <declaration name="maxLength" type="int" line="48"/>
                <scope line="49"/>
                <scope line="55"/>
                <scope line="59"/>
                <scope line="63"/>
            </method>
            <javadoc line="67">
                Returns a single matrix which contains the combined values of Q and R.  This
                  is possible since Q is symmetric and R is upper triangular.                
                <return>
                    The combined Q R matrix.                    
                </return>
            </javadoc>
            <method name="getQR" type="DenseMatrix64F" line="72"/>
            <javadoc line="75">
                Computes the Q matrix from the imformation stored in the QR matrix.  This
                  operation requires about 4(m&lt;sup&gt;2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.                
                <param>
                    Q The orthogonal Q matrix.                    
                </param>
            </javadoc>
            <method name="getQ" type="DenseMatrix64F" line="80">
                <params>
                    <param name="Q" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="81">
                    <scope line="82"/>
                    <scope line="85">
                        <scope line="86"/>
                        <scope line="89"/>
                    </scope>
                </scope>
                <scope line="94">
                    <scope line="95"/>
                    <scope line="98">
                        <scope line="99"/>
                        <scope line="102"/>
                    </scope>
                </scope>
                <scope line="107">
                    <scope line="109"/>
                </scope>
            </method>
            <javadoc line="116">
                Returns an upper triangular matrix which is the R in the QR decomposition.                
                <param>
                    R An upper triangular matrix.                    
                </param>
                <param>
                    compact                    
                </param>
            </javadoc>
            <method name="getR" type="DenseMatrix64F" line="121">
                <params>
                    <param name="R" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="122">
                    <scope line="123"/>
                </scope>
                <scope line="128">
                    <scope line="129"/>
                    <scope line="132"/>
                    <scope line="135">
                        <declaration name="min" type="int" line="136"/>
                        <scope line="137"/>
                    </scope>
                </scope>
                <scope line="142">
                    <scope line="143">
                        <declaration name="val" type="double" line="144"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="150">
                &lt;p&gt;
                  In order to decompose the matrix &apos;A&apos; it must have full rank.  &apos;A&apos; is a &apos;m&apos; by &apos;n&apos; matrix.
                  It requires about 2nm&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The matrix provided here can be of different
                  dimension than the one specified in the constructor.  It just has to be smaller than or equal
                  to it.
                  &lt;/p&gt;                
            </javadoc>
            <method name="decompose" type="boolean" line="161">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="163"/>
            </method>
            <method name="inputModified" type="boolean" line="169"/>
            <javadoc line="172">
                &lt;p&gt;
                  Computes the householder vector &quot;u&quot; for the first column of submatrix j.  Note this is
                  a specialized householder for this problem.  There is some protection against
                  overflow and underflow.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  This function finds the values of &apos;u&apos; and &apos;&amp;gamma;&apos;.
                  &lt;/p&gt;                
                <param>
                    j Which submatrix to work off of.                    
                </param>
            </javadoc>
            <method name="householder" type="void" line="186">
                <params>
                    <param name="j" type="int"/>
                </params>
                <declaration name="index" type="int" line="187"/>
                <declaration name="max" type="double" line="188"/>
                <scope line="189">
                    <declaration name="d" type="double" line="190"/>
                    <scope line="192"/>
                </scope>
                <scope line="197"/>
                <scope line="201">
                    <scope line="203">
                        <declaration name="d" type="double" line="205"/>
                    </scope>
                    <declaration name="u_0" type="double" line="210"/>
                    <scope line="212"/>
                </scope>
            </method>
            <javadoc line="220">
                &lt;p&gt;
                  Takes the results from the householder computation and updates the &apos;A&apos; matrix.&lt;br&gt;
                  &lt;br&gt;
                  A = (I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;)A
                  &lt;/p&gt;                
                <param>
                    w The submatrix.                    
                </param>
            </javadoc>
            <method name="updateA" type="void" line="228">
                <params>
                    <param name="w" type="int"/>
                </params>
                <scope line="229"/>
                <scope line="232">
                    <declaration name="indexQR" type="int" line="233"/>
                    <scope line="234"/>
                </scope>
                <scope line="238"/>
                <scope line="241">
                    <declaration name="valU" type="double" line="242"/>
                    <declaration name="indexQR" type="int" line="243"/>
                    <scope line="244"/>
                </scope>
                <scope line="248"/>
                <scope line="251"/>
            </method>
            <javadoc line="255">
                This function performs sanity check on the input for decompose and sets up the QR matrix.                
                <param>
                    A                    
                </param>
            </javadoc>
            <method name="commonSetup" type="void" line="259">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
            </method>
            <method name="getGammas" type="double[]" line="263"/>
        </class>
    </source>