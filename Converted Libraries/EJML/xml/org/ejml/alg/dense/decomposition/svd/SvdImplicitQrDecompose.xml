<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.svd">
        <import package="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecomposition"/>
        <import package="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecompositionRow"/>
        <import package="org.ejml.alg.dense.decomposition.bidiagonal.BidiagonalDecompositionTall"/>
        <import package="org.ejml.alg.dense.decomposition.svd.implicitqr.SvdImplicitQrAlgorithm"/>
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.SingularValueDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="SvdImplicitQrDecompose" line="9">
            <implements interface="SingularValueDecomposition">
                <type_params>
                    <type_param name="DenseMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="9">
                &lt;p&gt;
                  Computes the Singular value decomposition of a matrix using the implicit QR algorithm
                  for singular value decomposition.  It works by first by transforming the matrix
                  to a bidiagonal A=UBV&lt;sup&gt;T&lt;/sup&gt; form, then it implicitly computing the eigenvalues of the B&lt;sup&gt;T&lt;/sup&gt;B matrix,
                  which are the same as the singular values in the original A matrix.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Based off of the description provided in:&lt;br&gt;
                  &lt;br&gt;
                  David S. Watkins, &quot;Fundamentals of Matrix Computations,&quot; Second Edition. Page 404-411
                  &lt;/p&gt;                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="numRows" type="int" line="24"/>
            <declaration name="numCols" type="int" line="25"/>
            <declaration name="numRowsT" type="int" line="26"/>
            <declaration name="numColsT" type="int" line="27"/>
            <declaration name="canUseTallBidiagonal" type="boolean" line="28"/>
            <declaration name="bidiag" type="BidiagonalDecomposition&lt;DenseMatrix64F&gt;" line="29"/>
            <declaration name="qralg" type="SvdImplicitQrAlgorithm" line="30"/>
            <declaration name="diag" type="double" line="31"/>
            <declaration name="off" type="double" line="32"/>
            <declaration name="Ut" type="DenseMatrix64F" line="33"/>
            <declaration name="Vt" type="DenseMatrix64F" line="34"/>
            <declaration name="singularValues" type="double" line="35"/>
            <declaration name="numSingular" type="int" line="36"/>
            <declaration name="compact" type="boolean" line="37"/>
            <declaration name="computeU" type="boolean" line="38"/>
            <declaration name="computeV" type="boolean" line="39"/>
            <declaration name="prefComputeU" type="boolean" line="40"/>
            <declaration name="prefComputeV" type="boolean" line="41"/>
            <declaration name="transposed" type="boolean" line="42"/>
            <declaration name="A_mod" type="DenseMatrix64F" line="43"/>
            <javadoc line="44">
                Configures the class                
                <param>
                    compact Compute a compact SVD                    
                </param>
                <param>
                    computeU If true it will compute the U matrix                    
                </param>
                <param>
                    computeV If true it will compute the V matrix                    
                </param>
                <param>
                    canUseTallBidiagonal If true then it can choose to use a tall Bidiagonal decomposition to improve runtime performance.                    
                </param>
            </javadoc>
            <method name="SvdImplicitQrDecompose" type="constructor" line="51">
                <params>
                    <param name="compact" type="boolean"/>
                    <param name="computeU" type="boolean"/>
                    <param name="computeV" type="boolean"/>
                    <param name="canUseTallBidiagonal" type="boolean"/>
                </params>
            </method>
            <method name="getSingularValues" type="double[]" line="57"/>
            <method name="numberOfSingularValues" type="int" line="60"/>
            <method name="isCompact" type="boolean" line="63"/>
            <method name="getU" type="DenseMatrix64F" line="66">
                <params>
                    <param name="U" type="DenseMatrix64F"/>
                    <param name="transpose" type="boolean"/>
                </params>
                <scope line="68"/>
                <scope line="73"/>
            </method>
            <method name="getV" type="DenseMatrix64F" line="80">
                <params>
                    <param name="V" type="DenseMatrix64F"/>
                    <param name="transpose" type="boolean"/>
                </params>
                <scope line="82"/>
                <scope line="87"/>
            </method>
            <method name="getW" type="DenseMatrix64F" line="94">
                <params>
                    <param name="W" type="DenseMatrix64F"/>
                </params>
                <declaration name="m" type="int" line="95"/>
                <declaration name="n" type="int" line="96"/>
                <scope line="98"/>
                <scope line="102"/>
            </method>
            <method name="decompose" type="boolean" line="107">
                <params>
                    <param name="orig" type="DenseMatrix64F"/>
                </params>
            </method>
            <method name="inputModified" type="boolean" line="115"/>
            <method name="bidiagonalization" type="boolean" line="118">
                <params>
                    <param name="orig" type="DenseMatrix64F"/>
                </params>
                <scope line="119"/>
                <scope line="123"/>
            </method>
            <javadoc line="129">
                If the transpose was computed instead do some additional computations                
            </javadoc>
            <method name="undoTranspose" type="void" line="132">
                <scope line="133">
                    <declaration name="temp" type="DenseMatrix64F" line="134"/>
                </scope>
            </method>
            <javadoc line="139">
                Compute singular values and U and V at the same time                
            </javadoc>
            <method name="computeUWV" type="boolean" line="142">
                <declaration name="ret" type="boolean" line="152"/>
            </method>
            <method name="setup" type="void" line="155">
                <params>
                    <param name="orig" type="DenseMatrix64F"/>
                </params>
                <scope line="157"/>
                <scope line="163"/>
                <scope line="171"/>
                <scope line="175">
                    <scope line="176"/>
                </scope>
                <scope line="180"/>
            </method>
            <javadoc line="184">
                With the QR algorithm it is possible for the found singular values to be negative.  This
                  makes them all positive by multiplying it by a diagonal matrix that has                
            </javadoc>
            <method name="makeSingularPositive" type="void" line="188">
                <scope line="191">
                    <declaration name="val" type="double" line="192"/>
                    <scope line="193">
                        <scope line="195">
                            <declaration name="start" type="int" line="196"/>
                            <declaration name="stop" type="int" line="197"/>
                            <scope line="198"/>
                        </scope>
                    </scope>
                    <scope line="203"/>
                </scope>
            </method>
            <method name="numRows" type="int" line="208"/>
            <method name="numCols" type="int" line="211"/>
        </class>
    </source>