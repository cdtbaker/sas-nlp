<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.eig.symm">
        <import package="org.ejml.UtilEjml"/>
        <import package="org.ejml.alg.dense.decomposition.eig.EigenvalueSmall"/>
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="java.util.Random"/>
        <class name="SymmetricQREigenHelper" line="28">
            <comment line="37">
                used in exceptional shifts                
            </comment>
            <comment line="40">
                how many steps has it taken                
            </comment>
            <comment line="43">
                how many exception shifts has it performed                
            </comment>
            <comment line="45">
                the step number of the last exception shift                
            </comment>
            <comment line="48">
                used to compute eigenvalues directly                
            </comment>
            <comment line="51">
                orthogonal matrix used in similar transform.  optional                
            </comment>
            <comment line="54">
                size of the matrix being processed                
            </comment>
            <comment line="56">
                diagonal elements in the matrix                
            </comment>
            <comment line="58">
                the off diagonal elements                
            </comment>
            <comment line="61">
                which submatrix is being processed                
            </comment>
            <comment line="65">
                where splits are performed                
            </comment>
            <comment line="69">
                current value of the bulge                
            </comment>
            <comment line="72">
                local helper functions                
            </comment>
            <javadoc line="28">
                A helper class for the symmetric matrix implicit QR algorithm for eigenvalue decomposition.
                  Performs most of the basic operations needed to extract eigenvalues and eigenvectors.                
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="rand" type="Random" line="37"/>
            <declaration name="steps" type="int" line="40"/>
            <declaration name="numExceptional" type="int" line="43"/>
            <declaration name="lastExceptional" type="int" line="45"/>
            <declaration name="eigenSmall" type="EigenvalueSmall" line="48"/>
            <declaration name="Q" type="DenseMatrix64F" line="51"/>
            <declaration name="N" type="int" line="54"/>
            <declaration name="diag" type="double" line="56"/>
            <declaration name="off" type="double" line="58"/>
            <declaration name="x1" type="int" line="61"/>
            <declaration name="x2" type="int" line="62"/>
            <declaration name="splits" type="int" line="65"/>
            <declaration name="numSplits" type="int" line="66"/>
            <declaration name="bulge" type="double" line="69"/>
            <declaration name="c" type="double" line="72"/>
            <method name="SymmetricQREigenHelper" type="constructor" line="74"/>
            <method name="printMatrix" type="void" line="78">
                <scope line="80"/>
                <scope line="85"/>
            </method>
            <method name="setQ" type="void" line="91">
                <params>
                    <param name="q" type="DenseMatrix64F"/>
                </params>
            </method>
            <method name="incrementSteps" type="void" line="95"/>
            <javadoc line="99">
                Sets up and declares internal data structures.                
                <param>
                    diag Diagonal elements from tridiagonal matrix. Modified.                    
                </param>
                <param>
                    off Off diagonal elements from tridiagonal matrix. Modified.                    
                </param>
                <param>
                    numCols number of columns (and rows) in the matrix.                    
                </param>
            </javadoc>
            <method name="init" type="void" line="108">
                <params>
                    <param name="diag" type="double"/>
                    <param name="off" type="double"/>
                    <param name="numCols" type="int"/>
                </params>
            </method>
            <javadoc line="115">
                Exchanges the internal array of the diagonal elements for the provided one.                
            </javadoc>
            <method name="swapDiag" type="double[]" line="118">
                <params>
                    <param name="diag" type="double"/>
                </params>
                <declaration name="ret" type="double[]" line="119"/>
            </method>
            <javadoc line="125">
                Exchanges the internal array of the off diagonal elements for the provided one.                
            </javadoc>
            <method name="swapOff" type="double[]" line="128">
                <params>
                    <param name="off" type="double"/>
                </params>
                <declaration name="ret" type="double[]" line="129"/>
            </method>
            <javadoc line="135">
                Sets the size of the matrix being decomposed, declares new memory if needed,
                  and sets all helper functions to their initial value.                
            </javadoc>
            <method name="reset" type="void" line="139">
                <params>
                    <param name="N" type="int"/>
                </params>
                <scope line="145"/>
            </method>
            <method name="copyDiag" type="double[]" line="159">
                <params>
                    <param name="ret" type="double[]"/>
                </params>
                <scope line="160"/>
            </method>
            <method name="copyOff" type="double[]" line="169">
                <params>
                    <param name="ret" type="double[]"/>
                </params>
                <scope line="170"/>
            </method>
            <method name="copyEigenvalues" type="double[]" line="179">
                <params>
                    <param name="ret" type="double[]"/>
                </params>
                <scope line="180"/>
            </method>
            <javadoc line="189">
                Sets which submatrix is being processed.                
                <param>
                    x1 Lower bound, inclusive.                    
                </param>
                <param>
                    x2 Upper bound, inclusive.                    
                </param>
            </javadoc>
            <method name="setSubmatrix" type="void" line="194">
                <params>
                    <param name="x1" type="int"/>
                    <param name="x2" type="int"/>
                </params>
            </method>
            <javadoc line="199">
                Checks to see if the specified off diagonal element is zero using a relative metric.                
            </javadoc>
            <method name="isZero" type="boolean" line="202">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="bottom" type="double" line="203"/>
            </method>
            <method name="performImplicitSingleStep" type="void" line="209">
                <params>
                    <param name="lambda" type="double"/>
                    <param name="byAngle" type="boolean"/>
                </params>
                <scope line="210"/>
                <scope line="212">
                    <scope line="215"/>
                </scope>
            </method>
            <method name="updateQ" type="void" line="225">
                <params>
                    <param name="m" type="int"/>
                    <param name="n" type="int"/>
                    <param name="c" type="double"/>
                    <param name="s" type="double"/>
                </params>
                <comment line="229">
                    for( int i = 0; i &lt; N; i++ ) {                    
                </comment>
                <comment line="230">
                    double a = Q.data[rowA+i];                    
                </comment>
                <comment line="231">
                    double b = Q.data[rowB+i];                    
                </comment>
                <comment line="232">
                    Q.data[rowA+i] = c*a + s*b;                    
                </comment>
                <comment line="233">
                    Q.data[rowB+i] = -s*a + c*b;                    
                </comment>
                <comment line="234">
                    }                    
                </comment>
                <declaration name="rowA" type="int" line="226"/>
                <declaration name="rowB" type="int" line="227"/>
                <declaration name="endA" type="int" line="235"/>
                <scope line="236">
                    <declaration name="a" type="double" line="237"/>
                    <declaration name="b" type="double" line="238"/>
                </scope>
            </method>
            <javadoc line="244">
                Performs a similar transform on A-pI                
            </javadoc>
            <method name="createBulge" type="void" line="247">
                <params>
                    <param name="x1" type="int"/>
                    <param name="p" type="double"/>
                    <param name="byAngle" type="boolean"/>
                </params>
                <comment line="264">
                    multiply the rotator on the top left.                    
                </comment>
                <declaration name="a11" type="double" line="248"/>
                <declaration name="a22" type="double" line="249"/>
                <declaration name="a12" type="double" line="250"/>
                <declaration name="a23" type="double" line="251"/>
                <scope line="253"/>
                <scope line="260"/>
            </method>
            <method name="createBulge2by2" type="void" line="275">
                <params>
                    <param name="x1" type="int"/>
                    <param name="p" type="double"/>
                    <param name="byAngle" type="boolean"/>
                </params>
                <comment line="291">
                    multiply the rotator on the top left.                    
                </comment>
                <declaration name="a11" type="double" line="276"/>
                <declaration name="a22" type="double" line="277"/>
                <declaration name="a12" type="double" line="278"/>
                <scope line="280"/>
                <scope line="287"/>
            </method>
            <javadoc line="300">
                Computes the rotation and stores it in (c,s)                
            </javadoc>
            <method name="computeRotation" type="void" line="303">
                <params>
                    <param name="run" type="double"/>
                    <param name="rise" type="double"/>
                </params>
                <comment line="304">
                    double alpha = Math.sqrt(run*run + rise*rise);                    
                </comment>
                <comment line="305">
                    c = run/alpha;                    
                </comment>
                <comment line="306">
                    s = rise/alpha;                    
                </comment>
                <scope line="308">
                    <declaration name="k" type="double" line="309"/>
                    <declaration name="bottom" type="double" line="311"/>
                    <declaration name="bottom_sq" type="double" line="312"/>
                </scope>
                <scope line="319">
                    <declaration name="t" type="double" line="320"/>
                    <declaration name="bottom" type="double" line="322"/>
                    <declaration name="bottom_sq" type="double" line="323"/>
                </scope>
            </method>
            <method name="removeBulge" type="void" line="333">
                <params>
                    <param name="x1" type="int"/>
                </params>
                <comment line="342">
                    multiply the rotator on the top left.                    
                </comment>
                <declaration name="a22" type="double" line="334"/>
                <declaration name="a33" type="double" line="335"/>
                <declaration name="a12" type="double" line="336"/>
                <declaration name="a23" type="double" line="337"/>
                <declaration name="a34" type="double" line="338"/>
            </method>
            <javadoc line="354">
                Rotator to remove the bulge                
            </javadoc>
            <method name="removeBulgeEnd" type="void" line="357">
                <params>
                    <param name="x1" type="int"/>
                </params>
                <comment line="365">
                    multiply the rotator on the top left.                    
                </comment>
                <declaration name="a22" type="double" line="358"/>
                <declaration name="a12" type="double" line="359"/>
                <declaration name="a23" type="double" line="360"/>
                <declaration name="a33" type="double" line="361"/>
            </method>
            <javadoc line="375">
                Computes the eigenvalue of the 2 by 2 matrix.                
            </javadoc>
            <method name="eigenvalue2by2" type="void" line="378">
                <params>
                    <param name="x1" type="int"/>
                </params>
                <comment line="383">
                    normalize to reduce overflow                    
                </comment>
                <comment line="391">
                    see if it is a pathological case.  the diagonal must already be zero                    
                </comment>
                <comment line="392">
                    and the eigenvalues are all zero.  so just return                    
                </comment>
                <declaration name="a" type="double" line="379"/>
                <declaration name="b" type="double" line="380"/>
                <declaration name="c" type="double" line="381"/>
                <declaration name="absA" type="double" line="384"/>
                <declaration name="absB" type="double" line="385"/>
                <declaration name="absC" type="double" line="386"/>
                <declaration name="scale" type="double" line="388"/>
                <scope line="393"/>
            </method>
            <javadoc line="411">
                Perform a shift in a random direction that is of the same magnitude as the elements in the matrix.                
            </javadoc>
            <method name="exceptionalShift" type="void" line="414">
                <comment line="415">
                    rotating by a random angle handles at least one case using a random lambda                    
                </comment>
                <comment line="416">
                    does not handle well:                    
                </comment>
                <comment line="417">
                    - two identical eigenvalues are next to each other and a very small diagonal element                    
                </comment>
                <declaration name="mag" type="double" line="419"/>
                <declaration name="theta" type="double" line="422"/>
            </method>
            <javadoc line="428">
                Tells it to process the submatrix at the next split.  Should be called after the
                  current submatrix has been processed.                
            </javadoc>
            <method name="nextSplit" type="boolean" line="432"/>
            <method name="computeShift" type="double" line="444"/>
            <method name="computeWilkinsonShift" type="double" line="451">
                <comment line="456">
                    normalize to reduce overflow                    
                </comment>
                <comment line="472">
                    TODO see 385                    
                </comment>
                <comment line="476">
                    return the eigenvalue closest to c                    
                </comment>
                <declaration name="a" type="double" line="452"/>
                <declaration name="b" type="double" line="453"/>
                <declaration name="c" type="double" line="454"/>
                <declaration name="absA" type="double" line="457"/>
                <declaration name="absB" type="double" line="458"/>
                <declaration name="absC" type="double" line="459"/>
                <declaration name="scale" type="double" line="461"/>
                <scope line="464"/>
                <declaration name="diff0" type="double" line="477"/>
                <declaration name="diff1" type="double" line="478"/>
            </method>
            <method name="getMatrixSize" type="int" line="486"/>
            <method name="resetSteps" type="void" line="490"/>
        </class>
    </source>