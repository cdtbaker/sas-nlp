<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="QRDecompositionHouseholderTran" line="5">
            <implements interface="QRDecomposition">
                <type_params>
                    <type_param name="DenseMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="5">
                &lt;p&gt;
                  Householder QR decomposition is rich in operations along the columns of the matrix.  This can be
                  taken advantage of by solving for the Q matrix in a column major format to reduce the number
                  of CPU cache misses and the number of copies that are performed.
                  &lt;/p&gt;                
                <see>
                    QRDecompositionHouseholder                    
                </see>
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="QR" type="DenseMatrix64F" line="15"/>
            <javadoc line="15">
                Where the Q and R matrices are stored.  For speed reasons
                  this is transposed                
            </javadoc>
            <declaration name="v" type="double" line="20"/>
            <declaration name="numCols" type="int" line="21"/>
            <declaration name="numRows" type="int" line="22"/>
            <declaration name="minLength" type="int" line="23"/>
            <declaration name="gammas" type="double" line="24"/>
            <declaration name="gamma" type="double" line="25"/>
            <declaration name="tau" type="double" line="26"/>
            <declaration name="error" type="boolean" line="27"/>
            <method name="setExpectedMaxSize" type="void" line="28">
                <params>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                </params>
                <declaration name="maxLength" type="int" line="32"/>
                <scope line="33"/>
                <scope line="38"/>
                <scope line="41"/>
                <scope line="44"/>
            </method>
            <javadoc line="48">
                Inner matrix that stores the decomposition                
            </javadoc>
            <method name="getQR" type="DenseMatrix64F" line="51"/>
            <javadoc line="54">
                Computes the Q matrix from the information stored in the QR matrix.  This
                  operation requires about 4(m&lt;sup2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.                
                <param>
                    Q The orthogonal Q matrix.                    
                </param>
            </javadoc>
            <method name="getQ" type="DenseMatrix64F" line="59">
                <params>
                    <param name="Q" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="60">
                    <scope line="61"/>
                    <scope line="64">
                        <scope line="65"/>
                        <scope line="68"/>
                    </scope>
                </scope>
                <scope line="73">
                    <scope line="74"/>
                    <scope line="77">
                        <scope line="78"/>
                        <scope line="81"/>
                    </scope>
                </scope>
                <scope line="86">
                    <declaration name="diagIndex" type="int" line="87"/>
                    <declaration name="before" type="double" line="88"/>
                </scope>
            </method>
            <javadoc line="95">
                A = QA                
                <param>
                    A Matrix that is being multiplied by Q.  Is modified.                    
                </param>
            </javadoc>
            <method name="applyQ" type="void" line="99">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="101">
                    <declaration name="diagIndex" type="int" line="102"/>
                    <declaration name="before" type="double" line="103"/>
                </scope>
            </method>
            <javadoc line="109">
                A = Q&lt;sup&gt;T&lt;/sup&gt;A                
                <param>
                    A Matrix that is being multiplied by Q<sup>T</sup>.  Is modified.                    
                </param>
            </javadoc>
            <method name="applyTranQ" type="void" line="113">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="114">
                    <declaration name="diagIndex" type="int" line="115"/>
                    <declaration name="before" type="double" line="116"/>
                </scope>
            </method>
            <javadoc line="122">
                Returns an upper triangular matrix which is the R in the QR decomposition.                
                <param>
                    R An upper triangular matrix.                    
                </param>
                <param>
                    compact                    
                </param>
            </javadoc>
            <method name="getR" type="DenseMatrix64F" line="127">
                <params>
                    <param name="R" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="128">
                    <scope line="129"/>
                </scope>
                <scope line="134">
                    <scope line="135"/>
                    <scope line="138"/>
                    <scope line="141">
                        <declaration name="min" type="int" line="142"/>
                        <scope line="143"/>
                    </scope>
                </scope>
                <scope line="148">
                    <scope line="149"/>
                </scope>
            </method>
            <javadoc line="155">
                &lt;p&gt;
                  To decompose the matrix &apos;A&apos; it must have full rank.  &apos;A&apos; is a &apos;m&apos; by &apos;n&apos; matrix.
                  It requires about 2nm&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The matrix provided here can be of different
                  dimension than the one specified in the constructor.  It just has to be smaller than or equal
                  to it.
                  &lt;/p&gt;                
            </javadoc>
            <method name="decompose" type="boolean" line="166">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="170"/>
            </method>
            <method name="inputModified" type="boolean" line="176"/>
            <javadoc line="179">
                &lt;p&gt;
                  Computes the householder vector &quot;u&quot; for the first column of submatrix j.  Note this is
                  a specialized householder for this problem.  There is some protection against
                  overflow and underflow.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  This function finds the values of &apos;u&apos; and &apos;&amp;gamma;&apos;.
                  &lt;/p&gt;                
                <param>
                    j Which submatrix to work off of.                    
                </param>
            </javadoc>
            <method name="householder" type="void" line="193">
                <params>
                    <param name="j" type="int"/>
                </params>
                <declaration name="startQR" type="int" line="194"/>
                <declaration name="endQR" type="int" line="195"/>
                <declaration name="max" type="double" line="197"/>
                <scope line="198"/>
                <scope line="202">
                    <declaration name="u_0" type="double" line="204"/>
                </scope>
            </method>
            <javadoc line="212">
                &lt;p&gt;
                  Takes the results from the householder computation and updates the &apos;A&apos; matrix.&lt;br&gt;
                  &lt;br&gt;
                  A = (I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;)A
                  &lt;/p&gt;                
                <param>
                    w The submatrix.                    
                </param>
            </javadoc>
            <method name="updateA" type="void" line="220">
                <params>
                    <param name="w" type="int"/>
                </params>
                <declaration name="data" type="double" line="221"/>
                <declaration name="rowW" type="int" line="222"/>
                <declaration name="rowJ" type="int" line="223"/>
                <declaration name="rowJEnd" type="int" line="224"/>
                <declaration name="indexWEnd" type="int" line="225"/>
                <scope line="226">
                    <declaration name="val" type="double" line="227"/>
                    <declaration name="indexW" type="int" line="228"/>
                    <declaration name="indexJ" type="int" line="229"/>
                    <scope line="230"/>
                    <scope line="237"/>
                </scope>
            </method>
            <method name="getGammas" type="double[]" line="242"/>
        </class>
    </source>