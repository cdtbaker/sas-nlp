<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ejml.alg.dense.decomposition.qr">
        <import package="org.ejml.data.DenseMatrix64F"/>
        <import package="org.ejml.factory.QRDecomposition"/>
        <import package="org.ejml.ops.CommonOps"/>
        <class name="QRDecompositionHouseholderTran" line="26">
            <comment line="38">
                TODO remove QR Col and replace with this one?                
            </comment>
            <comment line="39">
                -- On small matrices col seems to be about 10% faster                
            </comment>
            <comment line="48">
                used internally to store temporary data                
            </comment>
            <comment line="51">
                dimension of the decomposed matrices                
            </comment>
            <comment line="52">
                this is &apos;n&apos;                
            </comment>
            <comment line="53">
                this is &apos;m&apos;                
            </comment>
            <comment line="56">
                the computed gamma for Q_k matrix                
            </comment>
            <comment line="58">
                local variables                
            </comment>
            <comment line="62">
                did it encounter an error?                
            </comment>
            <implements interface="QRDecomposition">
                <type_params>
                    <type_param name="DenseMatrix64F"/>
                </type_params>
            </implements>
            <javadoc line="26">
                &lt;p&gt;
                  Householder QR decomposition is rich in operations along the columns of the matrix.  This can be
                  taken advantage of by solving for the Q matrix in a column major format to reduce the number
                  of CPU cache misses and the number of copies that are performed.
                  &lt;/p&gt;                
                <see>
                    QRDecompositionHouseholder                    
                </see>
                <author>
                    Peter Abeles                    
                </author>
            </javadoc>
            <declaration name="QR" type="DenseMatrix64F" line="41"/>
            <javadoc line="41">
                Where the Q and R matrices are stored.  For speed reasons
                  this is transposed                
            </javadoc>
            <declaration name="v" type="double" line="48"/>
            <declaration name="numCols" type="int" line="51"/>
            <declaration name="numRows" type="int" line="52"/>
            <declaration name="minLength" type="int" line="53"/>
            <declaration name="gammas" type="double" line="56"/>
            <declaration name="gamma" type="double" line="58"/>
            <declaration name="tau" type="double" line="59"/>
            <declaration name="error" type="boolean" line="62"/>
            <method name="setExpectedMaxSize" type="void" line="64">
                <params>
                    <param name="numRows" type="int"/>
                    <param name="numCols" type="int"/>
                </params>
                <declaration name="maxLength" type="int" line="68"/>
                <scope line="70"/>
                <scope line="74"/>
                <scope line="78"/>
                <scope line="81"/>
            </method>
            <javadoc line="86">
                Inner matrix that stores the decomposition                
            </javadoc>
            <method name="getQR" type="DenseMatrix64F" line="89"/>
            <javadoc line="93">
                Computes the Q matrix from the information stored in the QR matrix.  This
                  operation requires about 4(m&lt;sup2&lt;/sup&gt;n-mn&lt;sup&gt;2&lt;/sup&gt;+n&lt;sup&gt;3&lt;/sup&gt;/3) flops.                
                <param>
                    Q The orthogonal Q matrix.                    
                </param>
            </javadoc>
            <method name="getQ" type="DenseMatrix64F" line="100">
                <params>
                    <param name="Q" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <comment line="123">
                    Unlike applyQ() this takes advantage of zeros in the identity matrix                    
                </comment>
                <comment line="124">
                    by not multiplying across all rows.                    
                </comment>
                <scope line="101">
                    <scope line="102"/>
                    <scope line="104">
                        <scope line="105"/>
                        <scope line="107"/>
                    </scope>
                </scope>
                <scope line="111">
                    <scope line="112"/>
                    <scope line="114">
                        <scope line="115"/>
                        <scope line="117"/>
                    </scope>
                </scope>
                <scope line="125">
                    <declaration name="diagIndex" type="int" line="126"/>
                    <declaration name="before" type="double" line="127"/>
                </scope>
            </method>
            <javadoc line="136">
                A = QA                
                <param>
                    A Matrix that is being multiplied by Q.  Is modified.                    
                </param>
            </javadoc>
            <method name="applyQ" type="void" line="141">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="145">
                    <declaration name="diagIndex" type="int" line="146"/>
                    <declaration name="before" type="double" line="147"/>
                </scope>
            </method>
            <javadoc line="154">
                A = Q&lt;sup&gt;T&lt;/sup&gt;A                
                <param>
                    A Matrix that is being multiplied by Q<sup>T</sup>.  Is modified.                    
                </param>
            </javadoc>
            <method name="applyTranQ" type="void" line="159">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="160">
                    <declaration name="diagIndex" type="int" line="161"/>
                    <declaration name="before" type="double" line="162"/>
                </scope>
            </method>
            <javadoc line="169">
                Returns an upper triangular matrix which is the R in the QR decomposition.                
                <param>
                    R An upper triangular matrix.                    
                </param>
                <param>
                    compact                    
                </param>
            </javadoc>
            <method name="getR" type="DenseMatrix64F" line="176">
                <params>
                    <param name="R" type="DenseMatrix64F"/>
                    <param name="compact" type="boolean"/>
                </params>
                <scope line="177">
                    <scope line="178"/>
                </scope>
                <scope line="182">
                    <scope line="183"/>
                    <scope line="186"/>
                    <scope line="191">
                        <declaration name="min" type="int" line="192"/>
                        <scope line="193"/>
                    </scope>
                </scope>
                <scope line="199">
                    <scope line="200"/>
                </scope>
            </method>
            <javadoc line="209">
                &lt;p&gt;
                  To decompose the matrix &apos;A&apos; it must have full rank.  &apos;A&apos; is a &apos;m&apos; by &apos;n&apos; matrix.
                  It requires about 2nm&lt;sup&gt;2&lt;/sup&gt;-2m&lt;sup&gt;2&lt;/sup&gt;/3 flops.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The matrix provided here can be of different
                  dimension than the one specified in the constructor.  It just has to be smaller than or equal
                  to it.
                  &lt;/p&gt;                
            </javadoc>
            <method name="decompose" type="boolean" line="222">
                <params>
                    <param name="A" type="DenseMatrix64F"/>
                </params>
                <scope line="229"/>
            </method>
            <method name="inputModified" type="boolean" line="238"/>
            <javadoc line="242">
                &lt;p&gt;
                  Computes the householder vector &quot;u&quot; for the first column of submatrix j.  Note this is
                  a specialized householder for this problem.  There is some protection against
                  overflow and underflow.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Q = I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;
                  &lt;/p&gt;
                  &lt;p&gt;
                  This function finds the values of &apos;u&apos; and &apos;&amp;gamma;&apos;.
                  &lt;/p&gt;                
                <param>
                    j Which submatrix to work off of.                    
                </param>
            </javadoc>
            <method name="householder" type="void" line="258">
                <params>
                    <param name="j" type="int"/>
                </params>
                <comment line="269">
                    computes tau and normalizes u by max                    
                </comment>
                <comment line="272">
                    divide u by u_0                    
                </comment>
                <declaration name="startQR" type="int" line="259"/>
                <declaration name="endQR" type="int" line="260"/>
                <declaration name="max" type="double" line="263"/>
                <scope line="265"/>
                <scope line="268">
                    <declaration name="u_0" type="double" line="273"/>
                </scope>
            </method>
            <javadoc line="285">
                &lt;p&gt;
                  Takes the results from the householder computation and updates the &apos;A&apos; matrix.&lt;br&gt;
                  &lt;br&gt;
                  A = (I - &amp;gamma;uu&lt;sup&gt;T&lt;/sup&gt;)A
                  &lt;/p&gt;                
                <param>
                    w The submatrix.                    
                </param>
            </javadoc>
            <method name="updateA" type="void" line="295">
                <params>
                    <param name="w" type="int"/>
                </params>
                <comment line="296">
                    int rowW = w*numRows;                    
                </comment>
                <comment line="297">
                    int rowJ = rowW + numRows;                    
                </comment>
                <comment line="298">
                                        
                </comment>
                <comment line="299">
                    for( int j = w+1; j &lt; numCols; j++ , rowJ += numRows) {                    
                </comment>
                <comment line="300">
                    double val = QR.data[rowJ + w];                    
                </comment>
                <comment line="301">
                                        
                </comment>
                <comment line="302">
                    // val = gamma*u^T * A                    
                </comment>
                <comment line="303">
                    for( int k = w+1; k &lt; numRows; k++ ) {                    
                </comment>
                <comment line="304">
                    val += QR.data[rowW + k]*QR.data[rowJ + k];                    
                </comment>
                <comment line="305">
                    }                    
                </comment>
                <comment line="306">
                    val *= gamma;                    
                </comment>
                <comment line="307">
                                        
                </comment>
                <comment line="308">
                    // A - val*u                    
                </comment>
                <comment line="309">
                    QR.data[rowJ + w] -= val;                    
                </comment>
                <comment line="310">
                    for( int i = w+1; i &lt; numRows; i++ ) {                    
                </comment>
                <comment line="311">
                    QR.data[rowJ + i] -= QR.data[rowW + i]*val;                    
                </comment>
                <comment line="312">
                    }                    
                </comment>
                <comment line="313">
                    }                    
                </comment>
                <comment line="322">
                    assume the first element in u is 1                    
                </comment>
                <declaration name="data" type="double" line="315"/>
                <declaration name="rowW" type="int" line="316"/>
                <declaration name="rowJ" type="int" line="317"/>
                <declaration name="rowJEnd" type="int" line="318"/>
                <declaration name="indexWEnd" type="int" line="319"/>
                <scope line="321">
                    <declaration name="val" type="double" line="323"/>
                    <declaration name="indexW" type="int" line="325"/>
                    <declaration name="indexJ" type="int" line="326"/>
                    <scope line="328"/>
                    <scope line="336"/>
                </scope>
            </method>
            <method name="getGammas" type="double[]" line="342"/>
        </class>
    </source>