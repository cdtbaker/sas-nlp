<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ojalgo.matrix.decomposition">
        <import package="java.util.Iterator"/>
        <import package="org.ojalgo.access.Access2D"/>
        <import package="org.ojalgo.access.Iterator1D"/>
        <import package="org.ojalgo.array.Array1D"/>
        <import package="org.ojalgo.array.Array2D"/>
        <import package="org.ojalgo.array.BasicArray"/>
        <import package="org.ojalgo.constant.PrimitiveMath"/>
        <import package="org.ojalgo.matrix.store.PhysicalStore"/>
        <import package="org.ojalgo.matrix.transformation.Householder"/>
        <import package="org.ojalgo.scalar.ComplexNumber"/>
        <interface name="DecompositionStore">
            <type_params>
                <type_param name="N"/>
            </type_params>
            <implements interface="PhysicalStore">
                <type_params>
                    <type_param name="N"/>
                </type_params>
            </implements>
            <javadoc line="36">
                &lt;p&gt;
                  Only classes that will act as a delegate to a {@linkplain MatrixDecomposition} implementation from this package
                  should implement this interface. The interface specifications are entirely dictated by the classes in this package.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Do not use it for anything else!
                  &lt;/p&gt;                
                <author>
                    apete                    
                </author>
            </javadoc>
            <class name="HouseholderReference" line="49">
                <type_params>
                    <type_param name="N"/>
                </type_params>
                <implements interface="Householder">
                    <type_params>
                        <type_param name="N"/>
                    </type_params>
                </implements>
                <declaration name="col" type="int" line="51"/>
                <declaration name="row" type="int" line="52"/>
                <declaration name="myBigWorker" type="Householder.Big" line="53"/>
                <declaration name="myColumn" type="boolean" line="54"/>
                <declaration name="myComplexWorker" type="Householder.Complex" line="55"/>
                <declaration name="myPrimitiveWorker" type="Householder.Primitive" line="56"/>
                <declaration name="myStore" type="DecompositionStore&amp;lt;N&amp;gt;" line="57"/>
                <method name="HouseholderReference" type="constructor" line="60"/>
                <method name="HouseholderReference" type="constructor" line="64">
                    <params>
                        <param name="aStore" type="DecompositionStore&lt;N&gt;"/>
                        <param name="aColumn" type="boolean"/>
                    </params>
                </method>
                <method name="count" type="long" line="72">
                    <scope line="73"/>
                    <scope line="75"/>
                </method>
                <method name="doubleValue" type="double" line="80">
                    <params>
                        <param name="index" type="long"/>
                    </params>
                    <scope line="81">
                        <scope line="82"/>
                        <scope line="84"/>
                        <scope line="86"/>
                    </scope>
                    <scope line="89">
                        <scope line="90"/>
                        <scope line="92"/>
                        <scope line="94"/>
                    </scope>
                </method>
                <method name="first" type="int" line="100"/>
                <method name="get" type="N" line="104">
                    <params>
                        <param name="index" type="long"/>
                    </params>
                    <scope line="105">
                        <scope line="106"/>
                        <scope line="108"/>
                        <scope line="110"/>
                    </scope>
                    <scope line="113">
                        <scope line="114"/>
                        <scope line="116"/>
                        <scope line="118"/>
                    </scope>
                </method>
                <method name="getBigWorker" type="Householder.Big" line="124">
                    <scope line="126">
                        <scope line="127"/>
                        <scope line="129"/>
                    </scope>
                </method>
                <method name="getComplexWorker" type="Householder.Complex" line="137">
                    <scope line="139">
                        <scope line="140"/>
                        <scope line="142"/>
                    </scope>
                </method>
                <method name="getPrimitiveWorker" type="Householder.Primitive" line="150">
                    <scope line="152">
                        <scope line="153"/>
                        <scope line="155"/>
                    </scope>
                </method>
                <method name="isZero" type="boolean" line="163">
                    <scope line="164"/>
                    <scope line="166"/>
                </method>
                <method name="iterator" type="Iterator&lt;N&gt;" line="171"/>
                <method name="toString" type="String" line="176">
                    <declaration name="retVal" type="StringBuilder" line="178"/>
                    <declaration name="tmpLastIndex" type="int" line="180"/>
                    <scope line="181"/>
                </method>
            </class>
            <method name="applyCholesky" type="void" line="194"/>
            <javadoc line="194">
                Cholesky transformations                
            </javadoc>
            <method name="applyLU" type="void" line="199"/>
            <javadoc line="199">
                LU transformations                
            </javadoc>
            <method name="asArray2D" type="Array2D&lt;N&gt;" line="204"/>
            <method name="computeInPlaceSchur" type="Array1D&lt;ComplexNumber&gt;" line="206"/>
            <method name="divideAndCopyColumn" type="void" line="208"/>
            <method name="generateApplyAndCopyHouseholderColumn" type="boolean" line="210"/>
            <method name="generateApplyAndCopyHouseholderRow" type="boolean" line="212"/>
            <method name="getIndexOfLargestInColumn" type="int" line="214"/>
            <method name="negateColumn" type="void" line="216"/>
            <method name="rotateRight" type="void" line="218"/>
            <method name="setToIdentity" type="void" line="220"/>
            <method name="substituteBackwards" type="void" line="222"/>
            <javadoc line="222">
                Will solve the equation system [A][X]=[B] where:
                  &lt;ul&gt;
                  &lt;li&gt;[aBody][this]=[this] is [A][X]=[B] (&quot;this&quot; is the right hand side, and it will be overwritten with the
                  solution).&lt;/li&gt;
                  &lt;li&gt;[A] is upper/right triangular&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    aBody The equation system body parameters [A]                    
                </param>
                <param>
                    conjugated true if the upper/right part of aBody is actually stored in the lower/left part of the matrix,
                      and the elements conjugated.                    
                </param>
            </javadoc>
            <method name="substituteForwards" type="void" line="236"/>
            <javadoc line="236">
                Will solve the equation system [A][X]=[B] where:
                  &lt;ul&gt;
                  &lt;li&gt;[aBody][this]=[this] is [A][X]=[B] (&quot;this&quot; is the right hand side, and it will be overwritten with the
                  solution).&lt;/li&gt;
                  &lt;li&gt;[A] is lower/left triangular&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    aBody The equation system body parameters [A]                    
                </param>
                <param>
                    onesOnDiagonal true if aBody as ones on the diagonal                    
                </param>
            </javadoc>
            <method name="transformSymmetric" type="void" line="249"/>
            <method name="tred2" type="void" line="251"/>
        </interface>
    </source>