<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ojalgo.optimisation">
        <import package="java.io.Serializable"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="org.ojalgo.RecoverableCondition"/>
        <import package="org.ojalgo.access.Access1D"/>
        <import package="org.ojalgo.access.Access2D"/>
        <import package="org.ojalgo.function.multiary.MultiaryFunction"/>
        <import package="org.ojalgo.matrix.store.MatrixStore"/>
        <import package="org.ojalgo.netio.BasicLogger"/>
        <class name="GenericSolver" line="34">
            <implements interface="Optimisation.Solver"/>
            <implements interface="Serializable"/>
            <declaration name="options" type="Optimisation.Options" line="36"/>
            <declaration name="myFunction" type="MultiaryFunction&lt;Double&gt;" line="38"/>
            <declaration name="myIterationsCount" type="AtomicInteger" line="39"/>
            <declaration name="myModel" type="ExpressionsBasedModel" line="40"/>
            <declaration name="myResetTime" type="long" line="41"/>
            <declaration name="myState" type="State" line="42"/>
            <method name="GenericSolver" type="constructor" line="45"/>
            <javadoc line="49">
                @param model                
            </javadoc>
            <method name="GenericSolver" type="constructor" line="52">
                <params>
                    <param name="model" type="ExpressionsBasedModel"/>
                    <param name="solverOptions" type="Optimisation.Options"/>
                </params>
                <scope line="56">
                    <scope line="59"/>
                    <scope line="61"/>
                </scope>
                <scope line="64">
                    <scope line="67"/>
                    <scope line="69"/>
                </scope>
            </method>
            <method name="solve" type="Optimisation.Result" line="75"/>
            <method name="buildResult" type="Optimisation.Result" line="79">
                <declaration name="tmpSolution" type="MatrixStore&lt;Double&gt;" line="81"/>
                <declaration name="tmpValue" type="double" line="82"/>
                <declaration name="tmpState" type="Optimisation.State" line="83"/>
            </method>
            <method name="countIterations" type="int" line="88"/>
            <method name="countTime" type="long" line="92"/>
            <method name="evaluateFunction" type="double" line="96">
                <params>
                    <param name="solution" type="Access1D<?>"/>
                </params>
                <scope line="97"/>
                <scope line="99"/>
            </method>
            <method name="extractSolution" type="MatrixStore<Double>" line="104"/>
            <javadoc line="104">
                Should be able to feed this to {@link #evaluateFunction(Access1D)}.                
            </javadoc>
            <method name="getGradient" type="MatrixStore<Double>" line="109">
                <params>
                    <param name="solution" type="Access1D<?>"/>
                </params>
            </method>
            <method name="getModel" type="ExpressionsBasedModel" line="113"/>
            <method name="getState" type="State" line="117"/>
            <javadoc line="121">
                Should be called after a completed iteration. The iterations count is not &quot;1&quot; untill the first iteration is
                  completed.                
            </javadoc>
            <method name="incrementIterationsCount" type="int" line="125">
                <declaration name="retVal" type="int" line="127"/>
                <scope line="129"/>
            </method>
            <method name="initialise" type="boolean" line="136"/>
            <method name="isDebug" type="boolean" line="138"/>
            <method name="isFunctionSet" type="boolean" line="142"/>
            <javadoc line="146">
                Should be called at the start of an iteration (before it actually starts) to check if you should abort instead.
                  Will return false if either the iterations count or the execution time has reached their respective limits.                
            </javadoc>
            <method name="isIterationAllowed" type="boolean" line="150">
                <comment line="158">
                    if (this.isDebug()) {                    
                </comment>
                <comment line="159">
                    this.logDebug(&quot;Iterations OK? {} {} &lt; {}&quot;, tmpIterationOk, tmpIterations, options.iterations_abort);                    
                </comment>
                <comment line="160">
                    this.logDebug(&quot;Time OK? {} {} &lt; {}&quot;, tmpTimeOk, tmpTime, options.time_abort);                    
                </comment>
                <comment line="161">
                    }                    
                </comment>
                <declaration name="tmpIterations" type="int" line="152"/>
                <declaration name="tmpTime" type="long" line="153"/>
                <declaration name="tmpIterationOk" type="boolean" line="155"/>
                <declaration name="tmpTimeOk" type="boolean" line="156"/>
            </method>
            <method name="isModelSet" type="boolean" line="166"/>
            <method name="logDebug" type="void" line="170">
                <params>
                    <param name="matrix" type="Access2D<?>"/>
                </params>
                <scope line="171"/>
            </method>
            <method name="logDebug" type="void" line="176">
                <params>
                    <param name="aMessagePattern" type="String"/>
                    <param name="someArgs" type="Object"/>
                </params>
                <scope line="177"/>
            </method>
            <method name="logDebug" type="void" line="182">
                <params>
                    <param name="aThrowable" type="Throwable"/>
                </params>
                <scope line="183"/>
            </method>
            <method name="logError" type="void" line="188">
                <params>
                    <param name="aMessagePattern" type="String"/>
                    <param name="someArgs" type="Object"/>
                </params>
            </method>
            <method name="needsAnotherIteration" type="boolean" line="192"/>
            <method name="resetIterationsCount" type="void" line="194"/>
            <method name="setState" type="void" line="199">
                <params>
                    <param name="aState" type="State"/>
                </params>
            </method>
            <method name="validate" type="boolean" line="203"/>
            <javadoc line="203">
                Should validate the solver data/input/structue. Even &quot;expensive&quot; validation can be performed as the method should
                  only be called if {@linkplain Optimisation.Options#validate} is set to true. In addition to returning true or
                  false the implementation should set the state to either {@linkplain Optimisation.State#VALID} or{@linkplain Optimisation.State#INVALID} (or possibly {@linkplain Optimisation.State#FAILED}). Typically the
                  method should be called at the very beginning of the solve-method.                
                <return>
                    Is the solver instance valid?                    
                </return>
            </javadoc>
        </class>
    </source>