<?xml version="1.0" encoding="UTF-8"?>
    <source package="edu.umd.cs.piccolo.examples">
        <import package="java.awt.Color"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Paint"/>
        <import package="java.util.ArrayList"/>
        <import package="edu.umd.cs.piccolo.PCamera"/>
        <import package="edu.umd.cs.piccolo.PCanvas"/>
        <import package="edu.umd.cs.piccolo.PNode"/>
        <import package="edu.umd.cs.piccolo.nodes.PPath"/>
        <import package="edu.umd.cs.piccolo.util.PBounds"/>
        <import package="edu.umd.cs.piccolo.util.PPaintContext"/>
        <import package="edu.umd.cs.piccolox.PFrame"/>
        <import package="edu.umd.cs.piccolox.event.PSelectionEventHandler"/>
        <class name="GroupExample" line="14">
            <extends class="PFrame"/>
            <javadoc line="14">
                An example of how to implement decorator groups. Decorator groups are nodes
                  that base their bounds and rendering on their children. This seems to be a
                  common type of visual node that requires some potentially non-obvious
                  subclassing to get right.
                  Both a volatile and a non-volatile implementation are shown. The volatile
                  implementation might be used in cases where you want to keep a
                  scale-independent pen width border around a group of objects. The
                  non-volatile implementation can be used in more standard cases where the
                  decorator&apos;s bounds are stable during zooming.                
                <author>
                    Lance Good                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="27"/>
            <javadoc line="27">
                                
            </javadoc>
            <method name="GroupExample" type="constructor" line="30"/>
            <method name="GroupExample" type="constructor" line="33">
                <params>
                    <param name="aCanvas" type="PCanvas"/>
                </params>
            </method>
            <method name="initialize" type="void" line="36">
                <declaration name="dg" type="DecoratorGroup" line="39"/>
                <declaration name="p1" type="PPath" line="41"/>
                <declaration name="p2" type="PPath" line="43"/>
                <declaration name="vdg" type="VolatileDecoratorGroup" line="48"/>
                <declaration name="p3" type="PPath" line="50"/>
                <declaration name="p4" type="PPath" line="52"/>
                <declaration name="selectableParents" type="ArrayList" line="57"/>
                <declaration name="ps" type="PSelectionEventHandler" line="60"/>
            </method>
            <method name="main" type="void" line="63">
                <params>
                    <param name="args" type="String[]"/>
                </params>
            </method>
        </class>
        <class name="DecoratorGroup" line="67">
            <extends class="PNode"/>
            <javadoc line="67">
                This is the non-volatile implementation of a decorator group that paints a
                  background rectangle based on the bounds of its children.                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="72"/>
            <javadoc line="72">
                                
            </javadoc>
            <declaration name="INDENT" type="int" line="75"/>
            <declaration name="cachedChildBounds" type="PBounds" line="76"/>
            <declaration name="comparisonBounds" type="PBounds" line="77"/>
            <method name="DecoratorGroup" type="constructor" line="78"/>
            <javadoc line="81">
                Change the default paint to fill an expanded bounding box based on its
                  children&apos;s bounds                
            </javadoc>
            <method name="paint" type="void" line="85">
                <params>
                    <param name="ppc" type="PPaintContext"/>
                </params>
                <declaration name="paint" type="Paint" line="86"/>
                <scope line="87">
                    <declaration name="g2" type="Graphics2D" line="88"/>
                    <declaration name="bounds" type="PBounds" line="90"/>
                </scope>
            </method>
            <javadoc line="95">
                Change the full bounds computation to take into account that we are
                  expanding the children&apos;s bounds Do this instead of overriding
                  getBoundsReference() since the node is not volatile                
            </javadoc>
            <method name="computeFullBounds" type="PBounds" line="100">
                <params>
                    <param name="dstBounds" type="PBounds"/>
                </params>
                <declaration name="result" type="PBounds" line="101"/>
            </method>
            <javadoc line="107">
                This is a crucial step. We have to override this method to invalidate the
                  paint each time the bounds are changed so we repaint the correct region                
            </javadoc>
            <method name="validateFullBounds" type="boolean" line="111">
                <scope line="113"/>
            </method>
        </class>
        <class name="VolatileDecoratorGroup" line="119">
            <extends class="PNode"/>
            <javadoc line="119">
                This is the volatile implementation of a decorator group that paints a
                  background rectangle based on the bounds of its children.                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="124"/>
            <javadoc line="124">
                                
            </javadoc>
            <declaration name="INDENT" type="int" line="127"/>
            <declaration name="cachedChildBounds" type="PBounds" line="128"/>
            <declaration name="comparisonBounds" type="PBounds" line="129"/>
            <declaration name="renderCamera" type="PCamera" line="130"/>
            <method name="VolatileDecoratorGroup" type="constructor" line="131">
                <params>
                    <param name="camera" type="PCamera"/>
                </params>
            </method>
            <javadoc line="135">
                Indicate that the bounds are volatile for this group                
            </javadoc>
            <method name="getBoundsVolatile" type="boolean" line="138"/>
            <javadoc line="141">
                Since our bounds are volatile, we can override this method to indicate
                  that we are expanding our bounds beyond our children                
            </javadoc>
            <method name="getBoundsReference" type="PBounds" line="145">
                <declaration name="bds" type="PBounds" line="146"/>
                <declaration name="scaledIndent" type="double" line="149"/>
            </method>
            <javadoc line="153">
                This is a crucial step. We have to override this method to invalidate the
                  paint each time the bounds are changed so we repaint the correct region                
            </javadoc>
            <method name="validateFullBounds" type="boolean" line="157">
                <scope line="159"/>
            </method>
        </class>
    </source>