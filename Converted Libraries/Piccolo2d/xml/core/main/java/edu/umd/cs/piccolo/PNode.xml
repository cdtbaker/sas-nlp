<?xml version="1.0" encoding="UTF-8"?>
    <source package="edu.umd.cs.piccolo">
        <import package="java.awt.Color"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Paint"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.Dimension2D"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.print.Book"/>
        <import package="java.awt.print.PageFormat"/>
        <import package="java.awt.print.Printable"/>
        <import package="java.awt.print.PrinterException"/>
        <import package="java.awt.print.PrinterJob"/>
        <import package="java.beans.PropertyChangeEvent"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.Serializable"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.EventListener"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.ListIterator"/>
        <import package="javax.swing.event.EventListenerList"/>
        <import package="javax.swing.event.SwingPropertyChangeSupport"/>
        <import package="javax.swing.text.MutableAttributeSet"/>
        <import package="javax.swing.text.SimpleAttributeSet"/>
        <import package="edu.umd.cs.piccolo.activities.PActivity"/>
        <import package="edu.umd.cs.piccolo.activities.PColorActivity"/>
        <import package="edu.umd.cs.piccolo.activities.PInterpolatingActivity"/>
        <import package="edu.umd.cs.piccolo.activities.PTransformActivity"/>
        <import package="edu.umd.cs.piccolo.event.PInputEventListener"/>
        <import package="edu.umd.cs.piccolo.util.PAffineTransform"/>
        <import package="edu.umd.cs.piccolo.util.PAffineTransformException"/>
        <import package="edu.umd.cs.piccolo.util.PBounds"/>
        <import package="edu.umd.cs.piccolo.util.PNodeFilter"/>
        <import package="edu.umd.cs.piccolo.util.PObjectOutputStream"/>
        <import package="edu.umd.cs.piccolo.util.PPaintContext"/>
        <import package="edu.umd.cs.piccolo.util.PPickPath"/>
        <import package="edu.umd.cs.piccolo.util.PUtil"/>
        <class name="PNode" line="85">
            <comment line="416">
                ****************************************************************
                 Animation - Methods to animate this node.
                
                 Note that animation is implemented by activities (PActivity),
                 so if you need more control over your animation look at the
                 activities package. Each animate method creates an animation that
                 will animate the node from its current state to the new state
                 specified over the given duration. These methods will try to
                 automatically schedule the new activity, but if the node does not
                 descend from the root node when the method is called then the
                 activity will not be scheduled and you must schedule it manually.
                 ****************************************************************                
            </comment>
            <comment line="667">
                ****************************************************************
                 Client Properties - Methods for managing client properties for
                 this node.
                
                 Client properties provide a way for programmers to attach
                 extra information to a node without having to subclass it and
                 add new instance variables.
                 ****************************************************************                
            </comment>
            <comment line="761">
                convenience methods for attributes                
            </comment>
            <comment line="866">
                ****************************************************************
                 Copying - Methods for copying this node and its descendants.
                 Copying is implemented in terms of serialization.
                 ****************************************************************                
            </comment>
            <comment line="891">
                ****************************************************************
                 Coordinate System Conversions - Methods for converting
                 geometry between this nodes local coordinates and the other
                 major coordinate systems.
                
                 Each nodes has an affine transform that it uses to define its
                 own coordinate system. For example if you create a new node and
                 add it to the canvas it will appear in the upper right corner. Its
                 coordinate system matches the coordinate system of its parent
                 (the root node) at this point. But if you move this node by calling
                 node.translate() the nodes affine transform will be modified and the
                 node will appear at a different location on the screen. The node
                 coordinate system no longer matches the coordinate system of its
                 parent.
                
                 This is useful because it means that the node&apos;s methods for
                 rendering and picking don&apos;t need to worry about the fact that
                 the node has been moved to another position on the screen, they
                 keep working just like they did when it was in the upper right
                 hand corner of the screen.
                
                 The problem is now that each node defines its own coordinate
                 system it is difficult to compare the positions of two node with
                 each other. These methods are all meant to help solve that problem.
                
                 The terms used in the methods are as follows:
                
                 local - The local or base coordinate system of a node.
                 parent - The coordinate system of a node&apos;s parent
                 global - The topmost coordinate system, above the root node.
                
                 Normally when comparing the positions of two nodes you will
                 convert the local position of each node to the global coordinate
                 system, and then compare the positions in that common coordinate
                 system.
                 ***************************************************************                
            </comment>
            <comment line="1178">
                ****************************************************************
                 Event Listeners - Methods for adding and removing event listeners
                 from a node.
                
                 Here methods are provided to add property change listeners and
                 input event listeners. The property change listeners are notified
                 when certain properties of this node change, and the input event
                 listeners are notified when the nodes receives new key and mouse
                 events.
                 ****************************************************************                
            </comment>
            <comment line="1358">
                ****************************************************************
                 Bounds Geometry - Methods for setting and querying the bounds
                 of this node.
                
                 The bounds of a node store the node&apos;s position and size in
                 the nodes local coordinate system. Many node subclasses will need
                 to override the setBounds method so that they can update their
                 internal state appropriately. See PPath for an example.
                
                 Since the bounds are stored in the local coordinate system
                 they WILL NOT change if the node is scaled, translated, or rotated.
                
                 The bounds may be accessed with either getBounds, or
                 getBoundsReference. The former returns a copy of the bounds
                 the latter returns a reference to the nodes bounds that should
                 normally not be modified. If a node is marked as volatile then
                 it may modify its bounds before returning them from getBoundsReference,
                 otherwise it may not.
                 ****************************************************************                
            </comment>
            <comment line="1627">
                ****************************************************************
                 Full Bounds - Methods for computing and querying the
                 full bounds of this node.
                
                 The full bounds of a node store the nodes bounds
                 together with the union of the bounds of all the
                 node&apos;s descendants. The full bounds are stored in the parent
                 coordinate system of this node, the full bounds DOES change
                 when you translate, scale, or rotate this node.
                
                 The full bounds may be accessed with either getFullBounds, or
                 getFullBoundsReference. The former returns a copy of the full bounds
                 the latter returns a reference to the node&apos;s full bounds that should
                 not be modified.
                 ****************************************************************                
            </comment>
            <comment line="1738">
                ****************************************************************
                 Bounds Damage Management - Methods used to invalidate and validate
                 the bounds of nodes.
                 ****************************************************************                
            </comment>
            <comment line="1992">
                ****************************************************************
                 Node Transform - Methods to manipulate the node&apos;s transform.
                
                 Each node has a transform that is used to define the nodes
                 local coordinate system. IE it is applied before picking and
                 rendering the node.
                
                 The usual way to move nodes about on the canvas is to manipulate
                 this transform, as opposed to changing the bounds of the
                 node.
                
                 Since this transform defines the local coordinate system of this
                 node the following methods with affect the global position both
                 this node and all of its descendants.
                 ****************************************************************                
            </comment>
            <comment line="2533">
                ****************************************************************
                 Paint Damage Management - Methods used to invalidate the areas of
                 the screen that this node appears in so that they will later get
                 painted.
                
                 Generally you will not need to call these invalidate methods
                 when starting out with Piccolo2d because methods such as setPaint
                 already automatically call them for you. You will need to call
                 them when you start creating your own nodes.
                
                 When you do create you own nodes the only method that you will
                 normally need to call is invalidatePaint. This method marks the
                 nodes as having invalid paint, the root node&apos;s UI cycle will then
                 later discover this damage and report it to the Java repaint manager.
                
                 Repainting is normally done with PNode.invalidatePaint() instead of
                 directly calling PNode.repaint() because PNode.repaint() requires
                 the nodes bounds to be computed right away. But with invalidatePaint
                 the bounds computation can be delayed until the end of the root&apos;s UI
                 cycle, and this can add up to a bit savings when modifying a
                 large number of nodes all at once.
                
                 The other methods here will rarely be called except internally
                 from the framework.
                 ****************************************************************                
            </comment>
            <comment line="2663">
                ****************************************************************
                 Occluding - Methods to support occluding optimisation. Not yet
                 complete.
                 ****************************************************************                
            </comment>
            <comment line="2697">
                ****************************************************************
                 Painting - Methods for painting this node and its children
                
                 Painting is how a node defines its visual representation on the
                 screen, and is done in the local coordinate system of the node.
                
                 The default painting behavior is to first paint the node, and
                 then paint the node&apos;s children on top of the node. If a node
                 needs wants specialised painting behavior it can override:
                
                 paint() - Painting here will happen before the children
                 are painted, so the children will be painted on top of painting done
                 here.
                 paintAfterChildren() - Painting here will happen after the children
                 are painted, so it will paint on top of them.
                
                 Note that you should not normally need to override fullPaint().
                
                 The visible flag can be used to make a node invisible so that
                 it will never get painted.
                 ****************************************************************                
            </comment>
            <comment line="3049">
                ****************************************************************
                 Picking - Methods for picking this node and its children.
                
                 Picking is used to determine the node that intersects a point or
                 rectangle on the screen. It is most frequently used by the
                 PInputManager to determine the node that the cursor is over.
                
                 The intersects() method is used to determine if a node has
                 been picked or not. The default implementation just test to see
                 if the pick bounds intersects the bounds of the node. Subclasses
                 whose geometry (a circle for example) does not match up exactly with
                 the bounds should override the intersects() method.
                
                 The default picking behavior is to first try to pick the nodes
                 children, and then try to pick the nodes own bounds. If a node
                 wants specialized picking behavior it can override:
                
                 pick() - Pick nodes here that should be picked before the nodes
                 children are picked.
                 pickAfterChildren() - Pick nodes here that should be picked after the
                 node&apos;s children are picked.
                
                 Note that fullPick should not normally be overridden.
                
                 The pickable and childrenPickable flags can be used to make a
                 node or it children not pickable even if their geometry does
                 intersect the pick bounds.
                 ****************************************************************                
            </comment>
            <comment line="3215">
                ****************************************************************
                 Structure - Methods for manipulating and traversing the
                 parent child relationship
                
                 Most of these methods won&apos;t need to be overridden by subclasses
                 but you will use them frequently to build up your node structures.
                 ****************************************************************                
            </comment>
            <comment line="3655">
                ****************************************************************
                 Serialization - Nodes conditionally serialize their parent.
                 This means that only the parents that were unconditionally
                 (using writeObject) serialized by someone else will be restored
                 when the node is unserialized.
                 ****************************************************************                
            </comment>
            <implements interface="Cloneable"/>
            <implements interface="Serializable"/>
            <implements interface="Printable"/>
            <javadoc line="85">
                &lt;b&gt;PNode&lt;/b&gt; is the central abstraction in Piccolo. All objects that are
                  visible on the screen are instances of the node class. All nodes may have
                  other &quot;child&quot; nodes added to them.
                  &lt;p&gt;
                  See edu.umd.piccolo.examples.NodeExample.java for demonstrations of how nodes
                  can be used and how new types of nodes can be created.
                  &lt;P&gt;                
                <version>
                    1.0                    
                </version>
                <author>
                    Jesse Grosjean                    
                </author>
            </javadoc>
            <declaration name="TRANSPARENCY_RESOLUTION" type="float" line="98"/>
            <javadoc line="98">
                The minimum difference in transparency required before the transparency
                  is allowed to change. Done for efficiency reasons. I doubt very much that
                  the human eye could tell the difference between 0.01 and 0.02
                  transparency.                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="106"/>
            <javadoc line="106">
                Allows for future serialization code to understand versioned binary
                  formats.                
            </javadoc>
            <declaration name="PROPERTY_CLIENT_PROPERTIES" type="String" line="112"/>
            <javadoc line="112">
                The property name that identifies a change in this node&apos;s client
                  propertie (see {@link #getClientProperty getClientProperty}). In an
                  property change event the new value will be a reference to the map of
                  client properties but old value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_CODE_CLIENT_PROPERTIES" type="int" line="120"/>
            <javadoc line="120">
                The property code that identifies a change in this node&apos;s client
                  propertie (see {@link #getClientProperty getClientProperty}). In an
                  property change event the new value will be a reference to the map of
                  client properties but old value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_BOUNDS" type="String" line="128"/>
            <javadoc line="128">
                The property name that identifies a change of this node&apos;s bounds (see{@link #getBounds getBounds}, {@link #getBoundsReferencegetBoundsReference}). In any property change event the new value will be
                  a reference to this node&apos;s bounds, but old value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_CODE_BOUNDS" type="int" line="136"/>
            <javadoc line="136">
                The property code that identifies a change of this node&apos;s bounds (see{@link #getBounds getBounds}, {@link #getBoundsReferencegetBoundsReference}). In any property change event the new value will be
                  a reference to this node&apos;s bounds, but old value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_FULL_BOUNDS" type="String" line="144"/>
            <javadoc line="144">
                The property name that identifies a change of this node&apos;s full bounds
                  (see {@link #getFullBounds getFullBounds},{@link #getFullBoundsReference getFullBoundsReference}). In any property
                  change event the new value will be a reference to this node&apos;s full bounds
                  cache, but old value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_CODE_FULL_BOUNDS" type="int" line="153"/>
            <javadoc line="153">
                The property code that identifies a change of this node&apos;s full bounds
                  (see {@link #getFullBounds getFullBounds},{@link #getFullBoundsReference getFullBoundsReference}). In any property
                  change event the new value will be a reference to this node&apos;s full bounds
                  cache, but old value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_TRANSFORM" type="String" line="162"/>
            <javadoc line="162">
                The property name that identifies a change of this node&apos;s transform (see{@link #getTransform getTransform}, {@link #getTransformReferencegetTransformReference}). In any property change event the new value will
                  be a reference to this node&apos;s transform, but old value will always be
                  null.                
            </javadoc>
            <declaration name="PROPERTY_CODE_TRANSFORM" type="int" line="171"/>
            <javadoc line="171">
                The property code that identifies a change of this node&apos;s transform (see{@link #getTransform getTransform}, {@link #getTransformReferencegetTransformReference}). In any property change event the new value will
                  be a reference to this node&apos;s transform, but old value will always be
                  null.                
            </javadoc>
            <declaration name="PROPERTY_VISIBLE" type="String" line="180"/>
            <javadoc line="180">
                The property name that identifies a change of this node&apos;s visibility (see{@link #getVisible getVisible}). Both old value and new value will be
                  null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CODE_VISIBLE" type="int" line="187"/>
            <javadoc line="187">
                The property code that identifies a change of this node&apos;s visibility (see{@link #getVisible getVisible}). Both old value and new value will be
                  null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_PAINT" type="String" line="194"/>
            <javadoc line="194">
                The property name that identifies a change of this node&apos;s paint (see{@link #getPaint getPaint}). Both old value and new value will be set
                  correctly in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CODE_PAINT" type="int" line="201"/>
            <javadoc line="201">
                The property code that identifies a change of this node&apos;s paint (see{@link #getPaint getPaint}). Both old value and new value will be set
                  correctly in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_TRANSPARENCY" type="String" line="208"/>
            <javadoc line="208">
                The property name that identifies a change of this node&apos;s transparency
                  (see {@link #getTransparency getTransparency}). Both old value and new
                  value will be null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CODE_TRANSPARENCY" type="int" line="215"/>
            <javadoc line="215">
                The property code that identifies a change of this node&apos;s transparency
                  (see {@link #getTransparency getTransparency}). Both old value and new
                  value will be null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_PICKABLE" type="String" line="222"/>
            <javadoc line="222">
                The property name that identifies a change of this node&apos;s pickable status
                  (see {@link #getPickable getPickable}). Both old value and new value will
                  be null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CODE_PICKABLE" type="int" line="228"/>
            <javadoc line="228">
                The property code that identifies a change of this node&apos;s pickable status
                  (see {@link #getPickable getPickable}). Both old value and new value will
                  be null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CHILDREN_PICKABLE" type="String" line="235"/>
            <javadoc line="235">
                The property name that identifies a change of this node&apos;s children
                  pickable status (see {@link #getChildrenPickable getChildrenPickable}).
                  Both old value and new value will be null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CODE_CHILDREN_PICKABLE" type="int" line="242"/>
            <javadoc line="242">
                The property code that identifies a change of this node&apos;s children
                  pickable status (see {@link #getChildrenPickable getChildrenPickable}).
                  Both old value and new value will be null in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CHILDREN" type="String" line="249"/>
            <javadoc line="249">
                The property name that identifies a change in the set of this node&apos;s
                  direct children (see {@link #getChildrenReference getChildrenReference},{@link #getChildrenIterator getChildrenIterator}). In any property change
                  event the new value will be a reference to this node&apos;s children, but old
                  value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_CODE_CHILDREN" type="int" line="258"/>
            <javadoc line="258">
                The property code that identifies a change in the set of this node&apos;s
                  direct children (see {@link #getChildrenReference getChildrenReference},{@link #getChildrenIterator getChildrenIterator}). In any property change
                  event the new value will be a reference to this node&apos;s children, but old
                  value will always be null.                
            </javadoc>
            <declaration name="PROPERTY_PARENT" type="String" line="267"/>
            <javadoc line="267">
                The property name that identifies a change of this node&apos;s parent (see{@link #getParent getParent}). Both old value and new value will be set
                  correctly in any property change event.                
            </javadoc>
            <declaration name="PROPERTY_CODE_PARENT" type="int" line="274"/>
            <javadoc line="274">
                The property code that identifies a change of this node&apos;s parent (see{@link #getParent getParent}). Both old value and new value will be set
                  correctly in any property change event.                
            </javadoc>
            <declaration name="TEMP_REPAINT_BOUNDS" type="PBounds" line="281"/>
            <javadoc line="281">
                Is an optimization for use during repaints.                
            </javadoc>
            <declaration name="SCENE_GRAPH_DELEGATE" type="PSceneGraphDelegate" line="284"/>
            <javadoc line="284">
                The single scene graph delegate that receives low level node events.                
            </javadoc>
            <declaration name="parent" type="PNode" line="287"/>
            <javadoc line="287">
                Tracks the parent of this node, may be null.                
            </javadoc>
            <declaration name="children" type="List" line="290"/>
            <javadoc line="290">
                Tracks all immediate child nodes.                
            </javadoc>
            <declaration name="bounds" type="PBounds" line="293"/>
            <javadoc line="293">
                Bounds of the PNode.                
            </javadoc>
            <declaration name="transform" type="PAffineTransform" line="296"/>
            <javadoc line="296">
                Transform that applies to this node in relation to its parent.                
            </javadoc>
            <declaration name="paint" type="Paint" line="299"/>
            <javadoc line="299">
                The paint to use for the background of this node.                
            </javadoc>
            <declaration name="transparency" type="float" line="302"/>
            <javadoc line="302">
                How Opaque this node should be 1f = fully opaque, 0f = completely
                  transparent.                
            </javadoc>
            <declaration name="clientProperties" type="MutableAttributeSet" line="308"/>
            <javadoc line="308">
                A modifiable set of client properties.                
            </javadoc>
            <declaration name="fullBoundsCache" type="PBounds" line="311"/>
            <javadoc line="311">
                An optimization that remembers the full bounds of a node rather than
                  computing it every time.                
            </javadoc>
            <declaration name="propertyChangeParentMask" type="int" line="317"/>
            <javadoc line="317">
                Mask used when deciding whether to bubble up property change events to
                  parents.                
            </javadoc>
            <declaration name="changeSupport" type="SwingPropertyChangeSupport" line="323"/>
            <javadoc line="323">
                Used to handle property change listeners.                
            </javadoc>
            <declaration name="listenerList" type="EventListenerList" line="326"/>
            <javadoc line="326">
                List of event listeners.                
            </javadoc>
            <declaration name="pickable" type="boolean" line="329"/>
            <javadoc line="329">
                Whether this node is pickable or not.                
            </javadoc>
            <declaration name="childrenPickable" type="boolean" line="332"/>
            <javadoc line="332">
                Whether to stop processing pick at this node and not bother drilling down
                  into children.                
            </javadoc>
            <declaration name="visible" type="boolean" line="338"/>
            <javadoc line="338">
                Whether this node will be rendered.                
            </javadoc>
            <declaration name="childBoundsVolatile" type="boolean" line="341"/>
            <declaration name="paintInvalid" type="boolean" line="343"/>
            <javadoc line="343">
                Whether this node needs to be repainted.                
            </javadoc>
            <declaration name="childPaintInvalid" type="boolean" line="346"/>
            <javadoc line="346">
                Whether children need to be repainted.                
            </javadoc>
            <declaration name="boundsChanged" type="boolean" line="349"/>
            <javadoc line="349">
                Whether this node&apos;s bounds have changed, and so needs to be relaid out.                
            </javadoc>
            <declaration name="fullBoundsInvalid" type="boolean" line="352"/>
            <javadoc line="352">
                Whether this node&apos;s full bounds need to be recomputed.                
            </javadoc>
            <declaration name="childBoundsInvalid" type="boolean" line="355"/>
            <javadoc line="355">
                Whether this node&apos;s child bounds need to be recomputed.                
            </javadoc>
            <declaration name="occluded" type="boolean" line="358"/>
            <declaration name="name" type="String" line="360"/>
            <javadoc line="360">
                Stores the name associated to this node.                
            </javadoc>
            <declaration name="FILL_STRATEGY_ASPECT_FIT" type="int" line="363"/>
            <javadoc line="363">
                toImage fill strategy that stretches the node be as large as possible
                  while still retaining its aspect ratio.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="FILL_STRATEGY_ASPECT_COVER" type="int" line="371"/>
            <javadoc line="371">
                toImage fill strategy that stretches the node be large enough to cover
                  the image, and centers it.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="FILL_STRATEGY_EXACT_FIT" type="int" line="379"/>
            <javadoc line="379">
                toImage fill strategy that stretches the node to be exactly the
                  dimensions of the image. Will result in distortion if the aspect ratios
                  are different.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <javadoc line="388">
                Creates a new PNode with the given name.                
                <since>
                    1.3                    
                </since>
                <param>
                    newName name to assign to node                    
                </param>
            </javadoc>
            <method name="PNode" type="constructor" line="394">
                <params>
                    <param name="newName" type="String"/>
                </params>
            </method>
            <javadoc line="399">
                Constructs a new PNode.
                  &lt;P&gt;
                  By default a node&apos;s paint is null, and bounds are empty. These values
                  must be set for the node to show up on the screen once it&apos;s added to a
                  scene graph.                
            </javadoc>
            <method name="PNode" type="constructor" line="406"/>
            <javadoc line="428">
                Animate this node&apos;s bounds from their current location when the activity
                  starts to the specified bounds. If this node descends from the root then
                  the activity will be scheduled, else the returned activity should be
                  scheduled manually. If two different transform activities are scheduled
                  for the same node at the same time, they will both be applied to the
                  node, but the last one scheduled will be applied last on each frame, so
                  it will appear to have replaced the original. Generally you will not want
                  to do that. Note this method animates the node&apos;s bounds, but does not
                  change the node&apos;s transform. Use animateTransformToBounds() to animate
                  the node&apos;s transform instead.                
                <param>
                    x left of target bounds                    
                </param>
                <param>
                    y top of target bounds                    
                </param>
                <param>
                    width width of target bounds                    
                </param>
                <param>
                    height height of target bounds                    
                </param>
                <param>
                    duration amount of time that the animation should take                    
                </param>
                <return>
                    the newly scheduled activity                    
                </return>
            </javadoc>
            <method name="animateToBounds" type="PInterpolatingActivity" line="448">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="width" type="double"/>
                    <param name="height" type="double"/>
                    <param name="duration" type="long"/>
                </params>
                <scope line="449"/>
                <declaration name="dst" type="PBounds" line="454"/>
                <anonymous_class line="457">
                    <declaration name="src" type="PBounds" line="458"/>
                    <method name="activityStarted" type="void" line="460"/>
                    <method name="setRelativeTargetValue" type="void" line="466">
                        <params>
                            <param name="zeroToOne" type="float"/>
                        </params>
                    </method>
                    <method name="activityFinished" type="void" line="472"/>
                </anonymous_class>
                <declaration name="interpolatingActivity" type="PInterpolatingActivity" line="456"/>
            </method>
            <javadoc line="482">
                Animate this node from it&apos;s current transform when the activity starts a
                  new transform that will fit the node into the given bounds. If this node
                  descends from the root then the activity will be scheduled, else the
                  returned activity should be scheduled manually. If two different
                  transform activities are scheduled for the same node at the same time,
                  they will both be applied to the node, but the last one scheduled will be
                  applied last on each frame, so it will appear to have replaced the
                  original. Generally you will not want to do that. Note this method
                  animates the node&apos;s transform, but does not directly change the node&apos;s
                  bounds rectangle. Use animateToBounds() to animate the node&apos;s bounds
                  rectangle instead.                
                <param>
                    x left of target bounds                    
                </param>
                <param>
                    y top of target bounds                    
                </param>
                <param>
                    width width of target bounds                    
                </param>
                <param>
                    height height of target bounds                    
                </param>
                <param>
                    duration amount of time that the animation should take                    
                </param>
                <return>
                    the newly scheduled activity                    
                </return>
            </javadoc>
            <method name="animateTransformToBounds" type="PTransformActivity" line="503">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="width" type="double"/>
                    <param name="height" type="double"/>
                    <param name="duration" type="long"/>
                </params>
                <declaration name="t" type="PAffineTransform" line="504"/>
                <declaration name="scale" type="double" line="506"/>
            </method>
            <javadoc line="511">
                Animate this node&apos;s transform from its current location when the activity
                  starts to the specified location, scale, and rotation. If this node
                  descends from the root then the activity will be scheduled, else the
                  returned activity should be scheduled manually. If two different
                  transform activities are scheduled for the same node at the same time,
                  they will both be applied to the node, but the last one scheduled will be
                  applied last on each frame, so it will appear to have replaced the
                  original. Generally you will not want to do that.                
                <param>
                    x the final target x position of node                    
                </param>
                <param>
                    y the final target y position of node                    
                </param>
                <param>
                    duration amount of time that the animation should take                    
                </param>
                <param>
                    scale the final scale for the duration                    
                </param>
                <param>
                    theta final theta value (in radians) for the animation                    
                </param>
                <return>
                    the newly scheduled activity                    
                </return>
            </javadoc>
            <method name="animateToPositionScaleRotation" type="PTransformActivity" line="529">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="scale" type="double"/>
                    <param name="theta" type="double"/>
                    <param name="duration" type="long"/>
                </params>
                <declaration name="t" type="PAffineTransform" line="530"/>
            </method>
            <javadoc line="537">
                Animate this node&apos;s transform from its current values when the activity
                  starts to the new values specified in the given transform. If this node
                  descends from the root then the activity will be scheduled, else the
                  returned activity should be scheduled manually. If two different
                  transform activities are scheduled for the same node at the same time,
                  they will both be applied to the node, but the last one scheduled will be
                  applied last on each frame, so it will appear to have replaced the
                  original. Generally you will not want to do that.                
                <param>
                    destTransform the final transform value                    
                </param>
                <param>
                    duration amount of time that the animation should take                    
                </param>
                <return>
                    the newly scheduled activity                    
                </return>
            </javadoc>
            <method name="animateToTransform" type="PTransformActivity" line="551">
                <params>
                    <param name="destTransform" type="AffineTransform"/>
                    <param name="duration" type="long"/>
                </params>
                <scope line="552"/>
                <scope line="556">
                    <anonymous_class line="557">
                        <method name="setTransform" type="void" line="558">
                            <params>
                                <param name="aTransform" type="AffineTransform"/>
                            </params>
                        </method>
                        <method name="getSourceMatrix" type="void" line="562">
                            <params>
                                <param name="aSource" type="double[]"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <declaration name="t" type="PTransformActivity.Target" line="557"/>
                    <declaration name="ta" type="PTransformActivity" line="567"/>
                </scope>
            </method>
            <javadoc line="574">
                Animate this node&apos;s color from its current value to the new value
                  specified. This meathod assumes that this nodes paint property is of type
                  color. If this node descends from the root then the activity will be
                  scheduled, else the returned activity should be scheduled manually. If
                  two different color activities are scheduled for the same node at the
                  same time, they will both be applied to the node, but the last one
                  scheduled will be applied last on each frame, so it will appear to have
                  replaced the original. Generally you will not want to do that.                
                <param>
                    destColor final color value.                    
                </param>
                <param>
                    duration amount of time that the animation should take                    
                </param>
                <return>
                    the newly scheduled activity                    
                </return>
            </javadoc>
            <method name="animateToColor" type="PInterpolatingActivity" line="588">
                <params>
                    <param name="destColor" type="Color"/>
                    <param name="duration" type="long"/>
                </params>
                <scope line="589"/>
                <scope line="593">
                    <anonymous_class line="594">
                        <method name="getColor" type="Color" line="595"/>
                        <method name="setColor" type="void" line="599">
                            <params>
                                <param name="color" type="Color"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <declaration name="t" type="PColorActivity.Target" line="594"/>
                    <declaration name="ca" type="PColorActivity" line="604"/>
                </scope>
            </method>
            <javadoc line="610">
                Animate this node&apos;s transparency from its current value to the new value
                  specified. Transparency values must range from zero to one. If this node
                  descends from the root then the activity will be scheduled, else the
                  returned activity should be scheduled manually. If two different
                  transparency activities are scheduled for the same node at the same time,
                  they will both be applied to the node, but the last one scheduled will be
                  applied last on each frame, so it will appear to have replaced the
                  original. Generally you will not want to do that.                
                <param>
                    zeroToOne final transparency value.                    
                </param>
                <param>
                    duration amount of time that the animation should take                    
                </param>
                <return>
                    the newly scheduled activity                    
                </return>
            </javadoc>
            <method name="animateToTransparency" type="PInterpolatingActivity" line="624">
                <params>
                    <param name="zeroToOne" type="float"/>
                    <param name="duration" type="long"/>
                </params>
                <scope line="625"/>
                <scope line="629">
                    <declaration name="dest" type="float" line="630"/>
                    <anonymous_class line="632">
                        <declaration name="source" type="float" line="633"/>
                        <method name="activityStarted" type="void" line="635"/>
                        <method name="setRelativeTargetValue" type="void" line="640">
                            <params>
                                <param name="zeroToOne" type="float"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <declaration name="ta" type="PInterpolatingActivity" line="632"/>
                </scope>
            </method>
            <javadoc line="650">
                Schedule the given activity with the root, note that only scheduled
                  activities will be stepped. If the activity is successfully added true is
                  returned, else false.                
                <param>
                    activity new activity to schedule                    
                </param>
                <return>
                    true if the activity is successfully scheduled.                    
                </return>
            </javadoc>
            <method name="addActivity" type="boolean" line="658">
                <params>
                    <param name="activity" type="PActivity"/>
                </params>
                <declaration name="r" type="PRoot" line="659"/>
                <scope line="660"/>
            </method>
            <javadoc line="675">
                Return mutable attributed set of client properties associated with this
                  node.                
                <return>
                    the client properties associated to this node                    
                </return>
            </javadoc>
            <method name="getClientProperties" type="MutableAttributeSet" line="681">
                <scope line="682"/>
            </method>
            <javadoc line="688">
                Returns the value of the client attribute with the specified key. Only
                  attributes added with &lt;code&gt;addAttribute&lt;/code&gt; will return a non-null
                  value.                
                <param>
                    key key to use while fetching client attribute                    
                </param>
                <return>
                    the value of this attribute or null                    
                </return>
            </javadoc>
            <method name="getAttribute" type="Object" line="697">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <scope line="698"/>
                <scope line="701"/>
            </method>
            <javadoc line="706">
                Add an arbitrary key/value to this node.
                  &lt;p&gt;
                  The &lt;code&gt;get/add attribute&lt;/code&gt; methods provide access to a small
                  per-instance attribute set. Callers can use get/add attribute to annotate
                  nodes that were created by another module.
                  &lt;p&gt;
                  If value is null this method will remove the attribute.                
                <param>
                    key to use when adding the attribute                    
                </param>
                <param>
                    value value to associate to the new attribute                    
                </param>
            </javadoc>
            <method name="addAttribute" type="void" line="718">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="719"/>
                <declaration name="oldValue" type="Object" line="723"/>
                <scope line="725">
                    <scope line="726"/>
                    <scope line="730"/>
                    <scope line="733"/>
                    <scope line="737"/>
                </scope>
            </method>
            <javadoc line="746">
                Returns an enumeration of all keys maped to attribute values values.                
                <return>
                    an Enumeration over attribute keys                    
                </return>
            </javadoc>
            <method name="getClientPropertyKeysEnumeration" type="Enumeration" line="751">
                <scope line="752"/>
                <scope line="755"/>
            </method>
            <javadoc line="762">
                Fetches the value of the requested attribute, returning defaultValue is
                  not found.                
                <param>
                    key attribute to search for                    
                </param>
                <param>
                    defaultValue value to return if attribute is not found                    
                </param>
                <return>
                    value of attribute or defaultValue if not found                    
                </return>
            </javadoc>
            <method name="getAttribute" type="Object" line="771">
                <params>
                    <param name="key" type="Object"/>
                    <param name="defaultValue" type="Object"/>
                </params>
                <declaration name="value" type="Object" line="772"/>
                <scope line="773"/>
            </method>
            <javadoc line="780">
                Fetches the boolean value of the requested attribute, returning
                  defaultValue is not found.                
                <param>
                    key attribute to search for                    
                </param>
                <param>
                    defaultValue value to return if attribute is not found                    
                </param>
                <return>
                    value of attribute or defaultValue if not found                    
                </return>
            </javadoc>
            <method name="getBooleanAttribute" type="boolean" line="789">
                <params>
                    <param name="key" type="Object"/>
                    <param name="defaultValue" type="boolean"/>
                </params>
                <declaration name="value" type="Boolean" line="790"/>
                <scope line="791"/>
            </method>
            <javadoc line="798">
                Fetches the integer value of the requested attribute, returning
                  defaultValue is not found.                
                <param>
                    key attribute to search for                    
                </param>
                <param>
                    defaultValue value to return if attribute is not found                    
                </param>
                <return>
                    value of attribute or defaultValue if not found                    
                </return>
            </javadoc>
            <method name="getIntegerAttribute" type="int" line="807">
                <params>
                    <param name="key" type="Object"/>
                    <param name="defaultValue" type="int"/>
                </params>
                <declaration name="value" type="Number" line="808"/>
                <scope line="809"/>
            </method>
            <javadoc line="816">
                Fetches the double value of the requested attribute, returning
                  defaultValue is not found.                
                <param>
                    key attribute to search for                    
                </param>
                <param>
                    defaultValue value to return if attribute is not found                    
                </param>
                <return>
                    value of attribute or defaultValue if not found                    
                </return>
            </javadoc>
            <method name="getDoubleAttribute" type="double" line="825">
                <params>
                    <param name="key" type="Object"/>
                    <param name="defaultValue" type="double"/>
                </params>
                <declaration name="value" type="Number" line="826"/>
                <scope line="827"/>
            </method>
            <javadoc line="834">
                @deprecated use getAttribute(Object key)instead.                
                <param>
                    key name of property to search for                    
                </param>
                <return>
                    value of matching client property                    
                </return>
            </javadoc>
            <method name="getClientProperty" type="Object" line="840">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="844">
                @deprecated use addAttribute(Object key, Object value)instead.                
                <param>
                    key name of property to add                    
                </param>
                <param>
                    value value or new attribute                    
                </param>
            </javadoc>
            <method name="addClientProperty" type="void" line="850">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="854">
                @deprecated use getClientPropertyKeysEnumerator() instead.                
                <return>
                    iterator for client property keys                    
                </return>
            </javadoc>
            <method name="getClientPropertyKeysIterator" type="Iterator" line="859">
                <declaration name="enumeration" type="Enumeration" line="860"/>
            </method>
            <javadoc line="870">
                The copy method copies this node and all of its descendants. Note that
                  copying is implemented in terms of java serialization. See the
                  serialization notes for more information.                
                <return>
                    new copy of this node or null if the node was not serializable                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="877">
                <scope line="878">
                    <declaration name="ser" type="byte[]" line="879"/>
                </scope>
                <scope line="882"/>
                <scope line="885"/>
            </method>
            <javadoc line="927">
                Transform the given point from this node&apos;s local coordinate system to its
                  parent&apos;s local coordinate system. Note that this will modify the point
                  parameter.                
                <param>
                    localPoint point in local coordinate system to be transformed.                    
                </param>
                <return>
                    point in parent's local coordinate system                    
                </return>
            </javadoc>
            <method name="localToParent" type="Point2D" line="935">
                <params>
                    <param name="localPoint" type="Point2D"/>
                </params>
                <scope line="936"/>
            </method>
            <javadoc line="942">
                Transform the given dimension from this node&apos;s local coordinate system to
                  its parent&apos;s local coordinate system. Note that this will modify the
                  dimension parameter.                
                <param>
                    localDimension dimension in local coordinate system to be
                      transformed.                    
                </param>
                <return>
                    dimension in parent's local coordinate system                    
                </return>
            </javadoc>
            <method name="localToParent" type="Dimension2D" line="951">
                <params>
                    <param name="localDimension" type="Dimension2D"/>
                </params>
                <scope line="952"/>
            </method>
            <javadoc line="958">
                Transform the given rectangle from this node&apos;s local coordinate system to
                  its parent&apos;s local coordinate system. Note that this will modify the
                  rectangle parameter.                
                <param>
                    localRectangle rectangle in local coordinate system to be
                      transformed.                    
                </param>
                <return>
                    rectangle in parent's local coordinate system                    
                </return>
            </javadoc>
            <method name="localToParent" type="Rectangle2D" line="967">
                <params>
                    <param name="localRectangle" type="Rectangle2D"/>
                </params>
                <scope line="968"/>
            </method>
            <javadoc line="974">
                Transform the given point from this node&apos;s parent&apos;s local coordinate
                  system to the local coordinate system of this node. Note that this will
                  modify the point parameter.                
                <param>
                    parentPoint point in parent's coordinate system to be transformed.                    
                </param>
                <return>
                    point in this node's local coordinate system                    
                </return>
            </javadoc>
            <method name="parentToLocal" type="Point2D" line="982">
                <params>
                    <param name="parentPoint" type="Point2D"/>
                </params>
                <scope line="983"/>
            </method>
            <javadoc line="990">
                Transform the given dimension from this node&apos;s parent&apos;s local coordinate
                  system to the local coordinate system of this node. Note that this will
                  modify the dimension parameter.                
                <param>
                    parentDimension dimension in parent's coordinate system to be
                      transformed.                    
                </param>
                <return>
                    dimension in this node's local coordinate system                    
                </return>
            </javadoc>
            <method name="parentToLocal" type="Dimension2D" line="999">
                <params>
                    <param name="parentDimension" type="Dimension2D"/>
                </params>
                <scope line="1000"/>
            </method>
            <javadoc line="1006">
                Transform the given rectangle from this node&apos;s parent&apos;s local coordinate
                  system to the local coordinate system of this node. Note that this will
                  modify the rectangle parameter.                
                <param>
                    parentRectangle rectangle in parent's coordinate system to be
                      transformed.                    
                </param>
                <return>
                    rectangle in this node's local coordinate system                    
                </return>
            </javadoc>
            <method name="parentToLocal" type="Rectangle2D" line="1015">
                <params>
                    <param name="parentRectangle" type="Rectangle2D"/>
                </params>
                <scope line="1016"/>
            </method>
            <javadoc line="1022">
                Transform the given point from this node&apos;s local coordinate system to the
                  global coordinate system. Note that this will modify the point parameter.                
                <param>
                    localPoint point in local coordinate system to be transformed.                    
                </param>
                <return>
                    point in global coordinates                    
                </return>
            </javadoc>
            <method name="localToGlobal" type="Point2D" line="1029">
                <params>
                    <param name="localPoint" type="Point2D"/>
                </params>
                <declaration name="n" type="PNode" line="1030"/>
                <scope line="1031"/>
            </method>
            <javadoc line="1038">
                Transform the given dimension from this node&apos;s local coordinate system to
                  the global coordinate system. Note that this will modify the dimension
                  parameter.                
                <param>
                    localDimension dimension in local coordinate system to be
                      transformed.                    
                </param>
                <return>
                    dimension in global coordinates                    
                </return>
            </javadoc>
            <method name="localToGlobal" type="Dimension2D" line="1047">
                <params>
                    <param name="localDimension" type="Dimension2D"/>
                </params>
                <declaration name="n" type="PNode" line="1048"/>
                <scope line="1049"/>
            </method>
            <javadoc line="1056">
                Transform the given rectangle from this node&apos;s local coordinate system to
                  the global coordinate system. Note that this will modify the rectangle
                  parameter.                
                <param>
                    localRectangle rectangle in local coordinate system to be
                      transformed.                    
                </param>
                <return>
                    rectangle in global coordinates                    
                </return>
            </javadoc>
            <method name="localToGlobal" type="Rectangle2D" line="1065">
                <params>
                    <param name="localRectangle" type="Rectangle2D"/>
                </params>
                <declaration name="n" type="PNode" line="1066"/>
                <scope line="1067"/>
            </method>
            <javadoc line="1074">
                Transform the given point from global coordinates to this node&apos;s local
                  coordinate system. Note that this will modify the point parameter.                
                <param>
                    globalPoint point in global coordinates to be transformed.                    
                </param>
                <return>
                    point in this node's local coordinate system.                    
                </return>
            </javadoc>
            <method name="globalToLocal" type="Point2D" line="1081">
                <params>
                    <param name="globalPoint" type="Point2D"/>
                </params>
                <declaration name="globalTransform" type="PAffineTransform" line="1082"/>
            </method>
            <method name="computeGlobalTransform" type="PAffineTransform" line="1086">
                <params>
                    <param name="node" type="PNode"/>
                </params>
                <scope line="1087"/>
                <declaration name="parentGlobalTransform" type="PAffineTransform" line="1091"/>
                <scope line="1092"/>
            </method>
            <javadoc line="1098">
                Transform the given dimension from global coordinates to this node&apos;s
                  local coordinate system. Note that this will modify the dimension
                  parameter.                
                <param>
                    globalDimension dimension in global coordinates to be transformed.                    
                </param>
                <return>
                    dimension in this node's local coordinate system.                    
                </return>
            </javadoc>
            <method name="globalToLocal" type="Dimension2D" line="1106">
                <params>
                    <param name="globalDimension" type="Dimension2D"/>
                </params>
                <scope line="1107"/>
            </method>
            <javadoc line="1113">
                Transform the given rectangle from global coordinates to this node&apos;s
                  local coordinate system. Note that this will modify the rectangle
                  parameter.                
                <param>
                    globalRectangle rectangle in global coordinates to be transformed.                    
                </param>
                <return>
                    rectangle in this node's local coordinate system.                    
                </return>
            </javadoc>
            <method name="globalToLocal" type="Rectangle2D" line="1121">
                <params>
                    <param name="globalRectangle" type="Rectangle2D"/>
                </params>
                <scope line="1122"/>
            </method>
            <javadoc line="1128">
                Return the transform that converts local coordinates at this node to the
                  global coordinate system.                
                <param>
                    dest PAffineTransform to transform to global coordinates                    
                </param>
                <return>
                    The concatenation of transforms from the top node down to this
                      node.                    
                </return>
            </javadoc>
            <method name="getLocalToGlobalTransform" type="PAffineTransform" line="1136">
                <params>
                    <param name="dest" type="PAffineTransform"/>
                </params>
                <declaration name="result" type="PAffineTransform" line="1137"/>
                <scope line="1138">
                    <scope line="1140"/>
                </scope>
                <scope line="1144"/>
                <scope line="1147"/>
                <scope line="1150"/>
            </method>
            <javadoc line="1157">
                Return the transform that converts global coordinates to local
                  coordinates of this node.                
                <param>
                    dest PAffineTransform to transform from global to local                    
                </param>
                <return>
                    The inverse of the concatenation of transforms from the root down
                      to this node.                    
                </return>
            </javadoc>
            <method name="getGlobalToLocalTransform" type="PAffineTransform" line="1166">
                <params>
                    <param name="dest" type="PAffineTransform"/>
                </params>
                <declaration name="result" type="PAffineTransform" line="1167"/>
                <scope line="1168"/>
                <scope line="1171"/>
            </method>
            <javadoc line="1188">
                Return the list of event listeners associated with this node.                
                <return>
                    event listener list or null                    
                </return>
            </javadoc>
            <method name="getListenerList" type="EventListenerList" line="1193"/>
            <javadoc line="1197">
                Adds the specified input event listener to receive input events from this
                  node.                
                <param>
                    listener the new input listener                    
                </param>
            </javadoc>
            <method name="addInputEventListener" type="void" line="1203">
                <params>
                    <param name="listener" type="PInputEventListener"/>
                </params>
                <scope line="1204"/>
            </method>
            <javadoc line="1210">
                Removes the specified input event listener so that it no longer receives
                  input events from this node.                
                <param>
                    listener the input listener to remove                    
                </param>
            </javadoc>
            <method name="removeInputEventListener" type="void" line="1216">
                <params>
                    <param name="listener" type="PInputEventListener"/>
                </params>
                <scope line="1217"/>
                <scope line="1221"/>
            </method>
            <javadoc line="1226">
                Add a PropertyChangeListener to the listener list. The listener is
                  registered for all properties. See the fields in PNode and subclasses
                  that start with PROPERTY_ to find out which properties exist.                
                <param>
                    listener The PropertyChangeListener to be added                    
                </param>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="1233">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1234"/>
            </method>
            <javadoc line="1240">
                Add a PropertyChangeListener for a specific property. The listener will
                  be invoked only when a call on firePropertyChange names that specific
                  property. See the fields in PNode and subclasses that start with
                  PROPERTY_ to find out which properties are supported.                
                <param>
                    propertyName The name of the property to listen on.                    
                </param>
                <param>
                    listener The PropertyChangeListener to be added                    
                </param>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="1249">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1250"/>
                <scope line="1253"/>
            </method>
            <javadoc line="1259">
                Remove a PropertyChangeListener from the listener list. This removes a
                  PropertyChangeListener that was registered for all properties.                
                <param>
                    listener The PropertyChangeListener to be removed                    
                </param>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="1265">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1266"/>
            </method>
            <javadoc line="1271">
                Remove a PropertyChangeListener for a specific property.                
                <param>
                    propertyName The name of the property that was listened on.                    
                </param>
                <param>
                    listener The PropertyChangeListener to be removed                    
                </param>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="1277">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1278"/>
                <scope line="1281"/>
            </method>
            <javadoc line="1287">
                Return the propertyChangeParentMask that determines which property change
                  events are forwared to this nodes parent so that its property change
                  listeners will also be notified.                
                <return>
                    mask used for deciding whether to bubble property changes up to
                      parent                    
                </return>
            </javadoc>
            <method name="getPropertyChangeParentMask" type="int" line="1295"/>
            <javadoc line="1299">
                Set the propertyChangeParentMask that determines which property change
                  events are forwared to this nodes parent so that its property change
                  listeners will also be notified.                
                <param>
                    propertyChangeParentMask new mask for property change bubble up                    
                </param>
            </javadoc>
            <method name="setPropertyChangeParentMask" type="void" line="1306">
                <params>
                    <param name="propertyChangeParentMask" type="int"/>
                </params>
            </method>
            <javadoc line="1310">
                Report a bound property update to any registered listeners. No event is
                  fired if old and new are equal and non-null. If the propertyCode exists
                  in this node&apos;s propertyChangeParentMask then a property change event will
                  also be fired on this nodes parent.                
                <param>
                    propertyCode The code of the property changed.                    
                </param>
                <param>
                    propertyName The name of the property that was changed.                    
                </param>
                <param>
                    oldValue The old value of the property.                    
                </param>
                <param>
                    newValue The new value of the property.                    
                </param>
            </javadoc>
            <method name="firePropertyChange" type="void" line="1322">
                <params>
                    <param name="propertyCode" type="int"/>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="Object"/>
                    <param name="newValue" type="Object"/>
                </params>
                <declaration name="event" type="PropertyChangeEvent" line="1323"/>
                <scope line="1325"/>
                <scope line="1329">
                    <scope line="1330"/>
                </scope>
            </method>
            <javadoc line="1337">
                Called by child node to forward property change events up the node tree
                  so that property change listeners registered with this node will be
                  notified of property changes of its children nodes. For performance
                  reason only propertyCodes listed in the propertyChangeParentMask are
                  forwarded.                
                <param>
                    event The property change event containing source node and changed
                      values.                    
                </param>
                <param>
                    propertyCode The code of the property changed.                    
                </param>
            </javadoc>
            <method name="fireChildPropertyChange" type="void" line="1348">
                <params>
                    <param name="event" type="PropertyChangeEvent"/>
                    <param name="propertyCode" type="int"/>
                </params>
                <scope line="1349"/>
                <scope line="1352"/>
            </method>
            <javadoc line="1377">
                Return a copy of this node&apos;s bounds. These bounds are stored in the local
                  coordinate system of this node and do not include the bounds of any of
                  this node&apos;s children.                
                <return>
                    copy of this node's local bounds                    
                </return>
            </javadoc>
            <method name="getBounds" type="PBounds" line="1384"/>
            <javadoc line="1388">
                Return a direct reference to this node&apos;s bounds. These bounds are stored
                  in the local coordinate system of this node and do not include the bounds
                  of any of this node&apos;s children. The value returned should not be
                  modified.                
                <return>
                    direct reference to local bounds                    
                </return>
            </javadoc>
            <method name="getBoundsReference" type="PBounds" line="1396"/>
            <javadoc line="1400">
                Notify this node that you will begin to repeatedly call &lt;code&gt;setBounds
                  &lt;/code&gt;. When you
                  are done call &lt;code&gt;endResizeBounds&lt;/code&gt; to let the node know that you
                  are done.                
            </javadoc>
            <method name="startResizeBounds" type="void" line="1406"/>
            <javadoc line="1409">
                Notify this node that you have finished a resize bounds sequence.                
            </javadoc>
            <method name="endResizeBounds" type="void" line="1412"/>
            <javadoc line="1415">
                Set&apos;s this node&apos;s bounds left position, leaving y, width, and height
                  unchanged.                
                <param>
                    x new x position of bounds                    
                </param>
                <return>
                    whether the change was successful                    
                </return>
            </javadoc>
            <method name="setX" type="boolean" line="1423">
                <params>
                    <param name="x" type="double"/>
                </params>
            </method>
            <javadoc line="1427">
                Set&apos;s this node&apos;s bounds top position, leaving x, width, and height
                  unchanged.                
                <param>
                    y new y position of bounds                    
                </param>
                <return>
                    whether the change was successful                    
                </return>
            </javadoc>
            <method name="setY" type="boolean" line="1435">
                <params>
                    <param name="y" type="double"/>
                </params>
            </method>
            <javadoc line="1439">
                Set&apos;s this node&apos;s bounds width, leaving x, y, and height unchanged.                
                <param>
                    width new width position of bounds                    
                </param>
                <return>
                    whether the change was successful                    
                </return>
            </javadoc>
            <method name="setWidth" type="boolean" line="1446">
                <params>
                    <param name="width" type="double"/>
                </params>
            </method>
            <javadoc line="1450">
                Set&apos;s this node&apos;s bounds height, leaving x, y, and width unchanged.                
                <param>
                    height new height position of bounds                    
                </param>
                <return>
                    whether the change was successful                    
                </return>
            </javadoc>
            <method name="setHeight" type="boolean" line="1457">
                <params>
                    <param name="height" type="double"/>
                </params>
            </method>
            <javadoc line="1461">
                Set the bounds of this node to the given value. These bounds are stored
                  in the local coordinate system of this node.                
                <param>
                    newBounds bounds to apply to this node                    
                </param>
                <return>
                    true if the bounds changed.                    
                </return>
            </javadoc>
            <method name="setBounds" type="boolean" line="1469">
                <params>
                    <param name="newBounds" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="1473">
                Set the bounds of this node to the given position and size. These bounds
                  are stored in the local coordinate system of this node.
                  If the width or height is less then or equal to zero then the bound&apos;s
                  empty bit will be set to true.
                  Subclasses must call the super.setBounds() method.                
                <param>
                    x x position of bounds                    
                </param>
                <param>
                    y y position of bounds                    
                </param>
                <param>
                    width width to apply to the bounds                    
                </param>
                <param>
                    height height to apply to the bounds                    
                </param>
                <return>
                    true if the bounds changed.                    
                </return>
            </javadoc>
            <method name="setBounds" type="boolean" line="1489">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="width" type="double"/>
                    <param name="height" type="double"/>
                </params>
                <comment line="1503">
                    Don&apos;t put any invalidating code here or else nodes with volatile
                     bounds will
                     create a soft infinite loop (calling Swing.invokeLater()) when they
                     validate
                     their bounds.                    
                </comment>
                <scope line="1490">
                    <scope line="1493"/>
                </scope>
            </method>
            <javadoc line="1510">
                Gives nodes a chance to update their internal structure before bounds
                  changed notifications are sent. When this message is recived the nodes
                  bounds field will contain the new value.
                  See PPath for an example that uses this method.                
                <param>
                    x x position of bounds                    
                </param>
                <param>
                    y y position of bounds                    
                </param>
                <param>
                    width width to apply to the bounds                    
                </param>
                <param>
                    height height to apply to the bounds                    
                </param>
            </javadoc>
            <method name="internalUpdateBounds" type="void" line="1522">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="width" type="double"/>
                    <param name="height" type="double"/>
                </params>
            </method>
            <javadoc line="1525">
                Set the empty bit of this bounds to true.                
            </javadoc>
            <method name="resetBounds" type="void" line="1528"/>
            <javadoc line="1532">
                Return the x position (in local coords) of this node&apos;s bounds.                
                <return>
                    local x position of bounds                    
                </return>
            </javadoc>
            <method name="getX" type="double" line="1537"/>
            <javadoc line="1541">
                Return the y position (in local coords) of this node&apos;s bounds.                
                <return>
                    local y position of bounds                    
                </return>
            </javadoc>
            <method name="getY" type="double" line="1546"/>
            <javadoc line="1550">
                Return the width (in local coords) of this node&apos;s bounds.                
                <return>
                    local width of bounds                    
                </return>
            </javadoc>
            <method name="getWidth" type="double" line="1555"/>
            <javadoc line="1559">
                Return the height (in local coords) of this node&apos;s bounds.                
                <return>
                    local width of bounds                    
                </return>
            </javadoc>
            <method name="getHeight" type="double" line="1564"/>
            <javadoc line="1568">
                Return a copy of the bounds of this node in the global coordinate system.                
                <return>
                    the bounds in global coordinate system.                    
                </return>
            </javadoc>
            <method name="getGlobalBounds" type="PBounds" line="1573"/>
            <javadoc line="1577">
                Center the bounds of this node so that they are centered on the given
                  point specified on the local coordinates of this node. Note that this
                  method will modify the nodes bounds, while centerFullBoundsOnPoint will
                  modify the nodes transform.                
                <param>
                    localX x position of point around which to center bounds                    
                </param>
                <param>
                    localY y position of point around which to center bounds                    
                </param>
                <return>
                    true if the bounds changed.                    
                </return>
            </javadoc>
            <method name="centerBoundsOnPoint" type="boolean" line="1588">
                <params>
                    <param name="localX" type="double"/>
                    <param name="localY" type="double"/>
                </params>
                <declaration name="dx" type="double" line="1589"/>
                <declaration name="dy" type="double" line="1590"/>
            </method>
            <javadoc line="1594">
                Center the full bounds of this node so that they are centered on the
                  given point specified on the local coordinates of this nodes parent. Note
                  that this method will modify the nodes transform, while
                  centerBoundsOnPoint will modify the nodes bounds.                
                <param>
                    parentX x position around which to center full bounds                    
                </param>
                <param>
                    parentY y position around which to center full bounds                    
                </param>
            </javadoc>
            <method name="centerFullBoundsOnPoint" type="void" line="1603">
                <params>
                    <param name="parentX" type="double"/>
                    <param name="parentY" type="double"/>
                </params>
                <declaration name="dx" type="double" line="1604"/>
                <declaration name="dy" type="double" line="1605"/>
            </method>
            <javadoc line="1609">
                Return true if this node intersects the given rectangle specified in
                  local bounds. If the geometry of this node is complex this method can
                  become expensive, it is therefore recommended that
                  &lt;code&gt;fullIntersects&lt;/code&gt; is used for quick rejects before calling this
                  method.                
                <param>
                    localBounds the bounds to test for intersection against                    
                </param>
                <return>
                    true if the given rectangle intersects this nodes geometry.                    
                </return>
            </javadoc>
            <method name="intersects" type="boolean" line="1619">
                <params>
                    <param name="localBounds" type="Rectangle2D"/>
                </params>
                <scope line="1620"/>
            </method>
            <javadoc line="1642">
                Return a copy of this node&apos;s full bounds. These bounds are stored in the
                  parent coordinate system of this node and they include the union of this
                  node&apos;s bounds and all the bounds of it&apos;s descendants.                
                <return>
                    a copy of this node's full bounds.                    
                </return>
            </javadoc>
            <method name="getFullBounds" type="PBounds" line="1649"/>
            <javadoc line="1653">
                Return a reference to this node&apos;s full bounds cache. These bounds are
                  stored in the parent coordinate system of this node and they include the
                  union of this node&apos;s bounds and all the bounds of it&apos;s descendants. The
                  bounds returned by this method should not be modified.                
                <return>
                    a reference to this node's full bounds cache.                    
                </return>
            </javadoc>
            <method name="getFullBoundsReference" type="PBounds" line="1661"/>
            <javadoc line="1666">
                Compute and return the full bounds of this node. If the dstBounds
                  parameter is not null then it will be used to return the results instead
                  of creating a new PBounds.                
                <param>
                    dstBounds if not null the new bounds will be stored here                    
                </param>
                <return>
                    the full bounds in the parent coordinate system of this node                    
                </return>
            </javadoc>
            <method name="computeFullBounds" type="PBounds" line="1674">
                <params>
                    <param name="dstBounds" type="PBounds"/>
                </params>
                <declaration name="result" type="PBounds" line="1675"/>
            </method>
            <javadoc line="1681">
                Compute and return the union of the full bounds of all the children of
                  this node. If the dstBounds parameter is not null then it will be used to
                  return the results instead of creating a new PBounds.                
                <param>
                    dstBounds if not null the new bounds will be stored here                    
                </param>
                <return>
                    union of children bounds                    
                </return>
            </javadoc>
            <method name="getUnionOfChildrenBounds" type="PBounds" line="1689">
                <params>
                    <param name="dstBounds" type="PBounds"/>
                </params>
                <declaration name="resultBounds" type="PBounds" line="1690"/>
                <scope line="1691"/>
                <scope line="1694"/>
                <declaration name="count" type="int" line="1699"/>
                <scope line="1700">
                    <declaration name="each" type="PNode" line="1701"/>
                </scope>
            </method>
            <javadoc line="1708">
                Return a copy of the full bounds of this node in the global coordinate
                  system.                
                <return>
                    the full bounds in global coordinate system.                    
                </return>
            </javadoc>
            <method name="getGlobalFullBounds" type="PBounds" line="1714">
                <declaration name="b" type="PBounds" line="1715"/>
                <scope line="1716"/>
            </method>
            <javadoc line="1722">
                Return true if the full bounds of this node intersects with the specified
                  bounds.                
                <param>
                    parentBounds the bounds to test for intersection against
                      (specified in parent's coordinate system)                    
                </param>
                <return>
                    true if this nodes full bounds intersect the given bounds.                    
                </return>
            </javadoc>
            <method name="fullIntersects" type="boolean" line="1730">
                <params>
                    <param name="parentBounds" type="Rectangle2D"/>
                </params>
                <scope line="1731"/>
            </method>
            <javadoc line="1742">
                Return true if this nodes bounds may change at any time. The default
                  behavior is to return false, subclasses that override this method to
                  return true should also override getBoundsReference() and compute their
                  volatile bounds there before returning the reference.                
                <return>
                    true if this node has volatile bounds                    
                </return>
            </javadoc>
            <method name="getBoundsVolatile" type="boolean" line="1750"/>
            <javadoc line="1754">
                Return true if this node has a child with volatile bounds.                
                <return>
                    true if this node has a child with volatile bounds                    
                </return>
            </javadoc>
            <method name="getChildBoundsVolatile" type="boolean" line="1759"/>
            <javadoc line="1763">
                Set if this node has a child with volatile bounds. This should normally
                  be managed automatically by the bounds validation process.                
                <param>
                    childBoundsVolatile true if this node has a descendant with
                      volatile bounds                    
                </param>
            </javadoc>
            <method name="setChildBoundsVolatile" type="void" line="1770">
                <params>
                    <param name="childBoundsVolatile" type="boolean"/>
                </params>
            </method>
            <javadoc line="1774">
                Return true if this node&apos;s bounds have recently changed. This flag will
                  be reset on the next call of validateFullBounds.                
                <return>
                    true if this node's bounds have changed.                    
                </return>
            </javadoc>
            <method name="getBoundsChanged" type="boolean" line="1780"/>
            <javadoc line="1784">
                Set the bounds chnaged flag. This flag will be reset on the next call of
                  validateFullBounds.                
                <param>
                    boundsChanged true if this nodes bounds have changed.                    
                </param>
            </javadoc>
            <method name="setBoundsChanged" type="void" line="1790">
                <params>
                    <param name="boundsChanged" type="boolean"/>
                </params>
            </method>
            <javadoc line="1794">
                Return true if the full bounds of this node are invalid. This means that
                  the full bounds of this node have changed and need to be recomputed.                
                <return>
                    true if the full bounds of this node are invalid                    
                </return>
            </javadoc>
            <method name="getFullBoundsInvalid" type="boolean" line="1800"/>
            <javadoc line="1804">
                Set the full bounds invalid flag. This flag is set when the full bounds
                  of this node need to be recomputed as is the case when this node is
                  transformed or when one of this node&apos;s children changes geometry.                
                <param>
                    fullBoundsInvalid true=invalid, false=valid                    
                </param>
            </javadoc>
            <method name="setFullBoundsInvalid" type="void" line="1811">
                <params>
                    <param name="fullBoundsInvalid" type="boolean"/>
                </params>
            </method>
            <javadoc line="1815">
                Return true if one of this node&apos;s descendants has invalid bounds.                
                <return>
                    whether child bounds are invalid                    
                </return>
            </javadoc>
            <method name="getChildBoundsInvalid" type="boolean" line="1820"/>
            <javadoc line="1824">
                Set the flag indicating that one of this node&apos;s descendants has invalid
                  bounds.                
                <param>
                    childBoundsInvalid true=invalid, false=valid                    
                </param>
            </javadoc>
            <method name="setChildBoundsInvalid" type="void" line="1830">
                <params>
                    <param name="childBoundsInvalid" type="boolean"/>
                </params>
            </method>
            <javadoc line="1834">
                This method should be called when the bounds of this node are changed. It
                  invalidates the full bounds of this node, and also notifies each of this
                  nodes children that their parent&apos;s bounds have changed. As a result of
                  this method getting called this nodes layoutChildren will be called.                
            </javadoc>
            <method name="signalBoundsChanged" type="void" line="1840">
                <declaration name="count" type="int" line="1845"/>
                <scope line="1846">
                    <declaration name="each" type="PNode" line="1847"/>
                </scope>
            </method>
            <javadoc line="1852">
                Invalidate this node&apos;s layout, so that later layoutChildren will get
                  called.                
            </javadoc>
            <method name="invalidateLayout" type="void" line="1856"/>
            <javadoc line="1860">
                A notification that the bounds of this node&apos;s parent have changed.                
            </javadoc>
            <method name="parentBoundsChanged" type="void" line="1863"/>
            <javadoc line="1866">
                Invalidates the full bounds of this node, and sets the child bounds
                  invalid flag on each of this node&apos;s ancestors.                
            </javadoc>
            <method name="invalidateFullBounds" type="void" line="1870">
                <declaration name="n" type="PNode" line="1873"/>
                <scope line="1874"/>
                <scope line="1879"/>
            </method>
            <javadoc line="1884">
                This method is called to validate the bounds of this node and all of its
                  descendants. It returns true if this nodes bounds or the bounds of any of
                  its descendants are marked as volatile.                
                <return>
                    true if this node or any of its descendants have volatile bounds                    
                </return>
            </javadoc>
            <method name="validateFullBounds" type="boolean" line="1891">
                <comment line="1895">
                    1. Only compute new bounds if invalid flags are set.                    
                </comment>
                <comment line="1898">
                    2. If my bounds are volatile and they have not been changed then
                     signal a change.
                    
                     For most cases this will do nothing, but if a nodes bounds depend
                     on its model, then
                     validate bounds has the responsibility of making the bounds match
                     the models value.
                     For example PPaths validateBounds method makes sure that the
                     bounds are equal to the
                     bounds of the GeneralPath model.                    
                </comment>
                <comment line="1912">
                    3. If the bounds of on of my decendents are invalidate then
                     validate the bounds of all of my children.                    
                </comment>
                <comment line="1923">
                    4. Now that my children&apos;s bounds are valid and my own bounds are
                     valid run any layout algorithm here. Note that if you try to
                     layout volatile
                     children piccolo will most likely start a &quot;soft&quot; infinite loop.
                     It won&apos;t freeze
                     your program, but it will make an infinite number of calls to
                     SwingUtilities
                     invoke later. You don&apos;t want to do that.                    
                </comment>
                <comment line="1933">
                    5. If the full bounds cache is invalid then recompute the full
                     bounds cache here after our own bounds and the children&apos;s bounds
                     have been computed above.                    
                </comment>
                <comment line="1943">
                    6. This will call getFullBoundsReference on all of the
                     children. So if the above
                     layoutChildren method changed the bounds of any of the
                     children they will be
                     validated again here.                    
                </comment>
                <comment line="1954">
                    7. If the new full bounds cache differs from the previous
                     cache then
                     tell our parent to invalidate their full bounds. This is how
                     bounds changes
                     deep in the tree percolate up.                    
                </comment>
                <comment line="1965">
                    8. If our paint was invalid make sure to repaint our old
                     full bounds. The
                     new bounds will be computed later in the validatePaint
                     pass.                    
                </comment>
                <comment line="1976">
                    9. Clear the invalid bounds flags.                    
                </comment>
                <declaration name="boundsVolatile" type="boolean" line="1892"/>
                <scope line="1895">
                    <scope line="1907"/>
                    <scope line="1913">
                        <declaration name="count" type="int" line="1915"/>
                        <scope line="1916">
                            <declaration name="each" type="PNode" line="1917"/>
                        </scope>
                    </scope>
                    <scope line="1935">
                        <declaration name="oldX" type="double" line="1936"/>
                        <declaration name="oldY" type="double" line="1937"/>
                        <declaration name="oldWidth" type="double" line="1938"/>
                        <declaration name="oldHeight" type="double" line="1939"/>
                        <declaration name="oldEmpty" type="boolean" line="1940"/>
                        <declaration name="fullBoundsChanged" type="boolean" line="1949"/>
                        <scope line="1958">
                            <scope line="1959"/>
                            <scope line="1968"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1984">
                Nodes that apply layout constraints to their children should override
                  this method and do the layout there.                
            </javadoc>
            <method name="layoutChildren" type="void" line="1988"/>
            <javadoc line="2007">
                Returns the rotation applied by this node&apos;s transform in radians. This
                  rotation affects this node and all its descendants. The value returned
                  will be between 0 and 2pi radians.                
                <return>
                    rotation in radians.                    
                </return>
            </javadoc>
            <method name="getRotation" type="double" line="2014">
                <scope line="2015"/>
            </method>
            <javadoc line="2021">
                Sets the rotation of this nodes transform in radians. This will affect
                  this node and all its descendents.                
                <param>
                    theta rotation in radians                    
                </param>
            </javadoc>
            <method name="setRotation" type="void" line="2027">
                <params>
                    <param name="theta" type="double"/>
                </params>
            </method>
            <javadoc line="2031">
                Rotates this node by theta (in radians) about the 0,0 point. This will
                  affect this node and all its descendants.                
                <param>
                    theta the amount to rotate by in radians                    
                </param>
            </javadoc>
            <method name="rotate" type="void" line="2037">
                <params>
                    <param name="theta" type="double"/>
                </params>
            </method>
            <javadoc line="2041">
                Rotates this node by theta (in radians), and then translates the node so
                  that the x, y position of its fullBounds stays constant.                
                <param>
                    theta the amount to rotate by in radians                    
                </param>
            </javadoc>
            <method name="rotateInPlace" type="void" line="2047">
                <params>
                    <param name="theta" type="double"/>
                </params>
                <declaration name="b" type="PBounds" line="2048"/>
                <declaration name="px" type="double" line="2049"/>
                <declaration name="py" type="double" line="2050"/>
            </method>
            <javadoc line="2056">
                Rotates this node by theta (in radians) about the given point. This will
                  affect this node and all its descendants.                
                <param>
                    theta the amount to rotate by in radians                    
                </param>
                <param>
                    point the point about which to rotate                    
                </param>
            </javadoc>
            <method name="rotateAboutPoint" type="void" line="2063">
                <params>
                    <param name="theta" type="double"/>
                    <param name="point" type="Point2D"/>
                </params>
            </method>
            <javadoc line="2067">
                Rotates this node by theta (in radians) about the given point. This will
                  affect this node and all its descendants.                
                <param>
                    theta the amount to rotate by in radians                    
                </param>
                <param>
                    x the x coordinate of the point around which to rotate                    
                </param>
                <param>
                    y the y coordinate of the point around which to rotate                    
                </param>
            </javadoc>
            <method name="rotateAboutPoint" type="void" line="2075">
                <params>
                    <param name="theta" type="double"/>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
            </method>
            <javadoc line="2082">
                Return the total amount of rotation applied to this node by its own
                  transform together with the transforms of all its ancestors. The value
                  returned will be between 0 and 2pi radians.                
                <return>
                    the total amount of rotation applied to this node in radians                    
                </return>
            </javadoc>
            <method name="getGlobalRotation" type="double" line="2089"/>
            <javadoc line="2093">
                Set the global rotation (in radians) of this node. This is implemented by
                  rotating this nodes transform the required amount so that the nodes
                  global rotation is as requested.                
                <param>
                    theta the amount to rotate by in radians relative to the global
                      coordinate system.                    
                </param>
            </javadoc>
            <method name="setGlobalRotation" type="void" line="2101">
                <params>
                    <param name="theta" type="double"/>
                </params>
                <scope line="2102"/>
                <scope line="2105"/>
            </method>
            <javadoc line="2110">
                Return the scale applied by this node&apos;s transform. The scale is effecting
                  this node and all its descendants.                
                <return>
                    scale applied by this nodes transform.                    
                </return>
            </javadoc>
            <method name="getScale" type="double" line="2116">
                <scope line="2117"/>
            </method>
            <javadoc line="2123">
                Set the scale of this node&apos;s transform. The scale will affect this node
                  and all its descendants.                
                <param>
                    scale the scale to set the transform to                    
                </param>
            </javadoc>
            <method name="setScale" type="void" line="2129">
                <params>
                    <param name="scale" type="double"/>
                </params>
                <scope line="2130"/>
            </method>
            <javadoc line="2136">
                Scale this nodes transform by the given amount. This will affect this
                  node and all of its descendants.                
                <param>
                    scale the amount to scale by                    
                </param>
            </javadoc>
            <method name="scale" type="void" line="2142">
                <params>
                    <param name="scale" type="double"/>
                </params>
            </method>
            <javadoc line="2146">
                Scale this nodes transform by the given amount about the specified point.
                  This will affect this node and all of its descendants.                
                <param>
                    scale the amount to scale by                    
                </param>
                <param>
                    point the point to scale about                    
                </param>
            </javadoc>
            <method name="scaleAboutPoint" type="void" line="2153">
                <params>
                    <param name="scale" type="double"/>
                    <param name="point" type="Point2D"/>
                </params>
            </method>
            <javadoc line="2157">
                Scale this nodes transform by the given amount about the specified point.
                  This will affect this node and all of its descendants.                
                <param>
                    scale the amount to scale by                    
                </param>
                <param>
                    x the x coordinate of the point around which to scale                    
                </param>
                <param>
                    y the y coordinate of the point around which to scale                    
                </param>
            </javadoc>
            <method name="scaleAboutPoint" type="void" line="2165">
                <params>
                    <param name="scale" type="double"/>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
            </method>
            <javadoc line="2172">
                Return the global scale that is being applied to this node by its
                  transform together with the transforms of all its ancestors.                
                <return>
                    global scale of this node                    
                </return>
            </javadoc>
            <method name="getGlobalScale" type="double" line="2178"/>
            <javadoc line="2182">
                Set the global scale of this node. This is implemented by scaling this
                  nodes transform the required amount so that the nodes global scale is as
                  requested.                
                <param>
                    scale the desired global scale                    
                </param>
            </javadoc>
            <method name="setGlobalScale" type="void" line="2189">
                <params>
                    <param name="scale" type="double"/>
                </params>
                <scope line="2190"/>
                <scope line="2193"/>
            </method>
            <javadoc line="2198">
                Returns the x offset of this node as applied by its transform.                
                <return>
                    x offset of this node as applied by its transform                    
                </return>
            </javadoc>
            <method name="getXOffset" type="double" line="2203">
                <scope line="2204"/>
            </method>
            <javadoc line="2210">
                Returns the y offset of this node as applied by its transform.                
                <return>
                    y offset of this node as applied by its transform                    
                </return>
            </javadoc>
            <method name="getYOffset" type="double" line="2215">
                <scope line="2216"/>
            </method>
            <javadoc line="2222">
                Return the offset that is being applied to this node by its transform.
                  This offset effects this node and all of its descendants and is specified
                  in the parent coordinate system. This returns the values that are in the
                  m02 and m12 positions in the affine transform.                
                <return>
                    a point representing the x and y offset                    
                </return>
            </javadoc>
            <method name="getOffset" type="Point2D" line="2230">
                <scope line="2231"/>
            </method>
            <javadoc line="2237">
                Set the offset that is being applied to this node by its transform. This
                  offset effects this node and all of its descendants and is specified in
                  the nodes parent coordinate system. This directly sets the values of the
                  m02 and m12 positions in the affine transform. Unlike &quot;PNode.translate()&quot;
                  it is not effected by the transforms scale.                
                <param>
                    point value of new offset                    
                </param>
            </javadoc>
            <method name="setOffset" type="void" line="2246">
                <params>
                    <param name="point" type="Point2D"/>
                </params>
            </method>
            <javadoc line="2250">
                Set the offset that is being applied to this node by its transform. This
                  offset effects this node and all of its descendants and is specified in
                  the nodes parent coordinate system. This directly sets the values of the
                  m02 and m12 positions in the affine transform. Unlike &quot;PNode.translate()&quot;
                  it is not effected by the transforms scale.                
                <param>
                    x amount of x offset                    
                </param>
                <param>
                    y amount of y offset                    
                </param>
            </javadoc>
            <method name="setOffset" type="void" line="2260">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
            </method>
            <javadoc line="2267">
                Offset this node relative to the parents coordinate system, and is NOT
                  effected by this nodes current scale or rotation. This is implemented by
                  directly adding dx to the m02 position and dy to the m12 position in the
                  affine transform.                
                <param>
                    dx amount to add to this nodes current x Offset                    
                </param>
                <param>
                    dy amount to add to this nodes current y Offset                    
                </param>
            </javadoc>
            <method name="offset" type="void" line="2276">
                <params>
                    <param name="dx" type="double"/>
                    <param name="dy" type="double"/>
                </params>
            </method>
            <javadoc line="2281">
                Translate this node&apos;s transform by the given amount, using the standard
                  affine transform translate method. This translation effects this node and
                  all of its descendants.                
                <param>
                    dx amount to add to this nodes current x translation                    
                </param>
                <param>
                    dy amount to add to this nodes current y translation                    
                </param>
            </javadoc>
            <method name="translate" type="void" line="2289">
                <params>
                    <param name="dx" type="double"/>
                    <param name="dy" type="double"/>
                </params>
            </method>
            <javadoc line="2296">
                Return the global translation that is being applied to this node by its
                  transform together with the transforms of all its ancestors.                
                <return>
                    the global translation applied to this node                    
                </return>
            </javadoc>
            <method name="getGlobalTranslation" type="Point2D" line="2302">
                <declaration name="p" type="Point2D" line="2303"/>
                <scope line="2304"/>
            </method>
            <javadoc line="2310">
                Set the global translation of this node. This is implemented by
                  translating this nodes transform the required amount so that the nodes
                  global scale is as requested.                
                <param>
                    globalPoint the desired global translation                    
                </param>
            </javadoc>
            <method name="setGlobalTranslation" type="void" line="2317">
                <params>
                    <param name="globalPoint" type="Point2D"/>
                </params>
                <scope line="2318"/>
            </method>
            <javadoc line="2324">
                Transform this nodes transform by the given transform.                
                <param>
                    aTransform the transform to apply.                    
                </param>
            </javadoc>
            <method name="transformBy" type="void" line="2329">
                <params>
                    <param name="aTransform" type="AffineTransform"/>
                </params>
            </method>
            <javadoc line="2336">
                Linearly interpolates between a and b, based on t. Specifically, it
                  computes lerp(a, b, t) = a + t(b - a). This produces a result that
                  changes from a (when t = 0) to b (when t = 1).                
                <param>
                    t variable 'time' parameter                    
                </param>
                <param>
                    a from point                    
                </param>
                <param>
                    b to Point                    
                </param>
                <return>
                    linear interpolation between and b at time interval t (given as #
                      between 0f and 1f)                    
                </return>
            </javadoc>
            <method name="lerp" type="double" line="2348">
                <params>
                    <param name="t" type="double"/>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
            </method>
            <javadoc line="2352">
                This will calculate the necessary transform in order to make this node
                  appear at a particular position relative to the specified bounding box.
                  The source point specifies a point in the unit square (0, 0) - (1, 1)
                  that represents an anchor point on the corresponding node to this
                  transform. The destination point specifies an anchor point on the
                  reference node. The position method then computes the transform that
                  results in transforming this node so that the source anchor point
                  coincides with the reference anchor point. This can be useful for layout
                  algorithms as it is straightforward to position one object relative to
                  another.
                  &lt;p&gt;
                  For example, If you have two nodes, A and B, and you call
                  &lt;PRE&gt;
                  Point2D srcPt = new Point2D.Double(1.0, 0.0);
                  Point2D destPt = new Point2D.Double(0.0, 0.0);
                  A.position(srcPt, destPt, B.getGlobalBounds(), 750, null);
                  &lt;/PRE&gt;
                  The result is that A will move so that its upper-right corner is at the
                  same place as the upper-left corner of B, and the transition will be
                  smoothly animated over a period of 750 milliseconds.                
                <since>
                    1.3                    
                </since>
                <param>
                    srcPt The anchor point on this transform's node (normalized to a
                      unit square)                    
                </param>
                <param>
                    destPt The anchor point on destination bounds (normalized to a
                      unit square)                    
                </param>
                <param>
                    destBounds The bounds (in global coordinates) used to calculate
                      this transform's node                    
                </param>
                <param>
                    millis Number of milliseconds over which to perform the animation                    
                </param>
                <return>
                    newly scheduled activity or node if activity could not be
                      scheduled                    
                </return>
            </javadoc>
            <method name="animateToRelativePosition" type="PActivity" line="2389">
                <params>
                    <param name="srcPt" type="Point2D"/>
                    <param name="destPt" type="Point2D"/>
                    <param name="destBounds" type="Rectangle2D"/>
                    <param name="millis" type="int"/>
                </params>
                <comment line="2400">
                    First compute translation amount in global coordinates                    
                </comment>
                <comment line="2407">
                    Convert vector to local coordinates                    
                </comment>
                <comment line="2415">
                    Finally, animate change                    
                </comment>
                <declaration name="srcx" type="double" line="2390"/>
                <declaration name="destx" type="double" line="2391"/>
                <declaration name="dx" type="double" line="2392"/>
                <declaration name="pt1" type="Point2D" line="2393"/>
                <scope line="2395"/>
                <scope line="2398">
                    <declaration name="srcBounds" type="Rectangle2D" line="2400"/>
                    <declaration name="at" type="PAffineTransform" line="2415"/>
                </scope>
            </method>
            <javadoc line="2421">
                @deprecated in favor of animateToRelativePosition
                  It will calculate the necessary transform in order to make
                  this node appear at a particular position relative to the
                  specified bounding box. The source point specifies a point in
                  the unit square (0, 0) - (1, 1) that represents an anchor
                  point on the corresponding node to this transform. The
                  destination point specifies an anchor point on the reference
                  node. The position method then computes the transform that
                  results in transforming this node so that the source anchor
                  point coincides with the reference anchor point. This can be
                  useful for layout algorithms as it is straightforward to
                  position one object relative to another.
                  &lt;p&gt;
                  For example, If you have two nodes, A and B, and you call
                  &lt;PRE&gt;
                  Point2D srcPt = new Point2D.Double(1.0, 0.0);
                  Point2D destPt = new Point2D.Double(0.0, 0.0);
                  A.position(srcPt, destPt, B.getGlobalBounds(), 750, null);
                  &lt;/PRE&gt;
                  The result is that A will move so that its upper-right corner
                  is at the same place as the upper-left corner of B, and the
                  transition will be smoothly animated over a period of 750
                  milliseconds.                
                <param>
                    srcPt The anchor point on this transform's node (normalized to a
                      unit square)                    
                </param>
                <param>
                    destPt The anchor point on destination bounds (normalized to a
                      unit square)                    
                </param>
                <param>
                    destBounds The bounds (in global coordinates) used to calculate
                      this transform's node                    
                </param>
                <param>
                    millis Number of milliseconds over which to perform the animation                    
                </param>
            </javadoc>
            <method name="position" type="void" line="2457">
                <params>
                    <param name="srcPt" type="Point2D"/>
                    <param name="destPt" type="Point2D"/>
                    <param name="destBounds" type="Rectangle2D"/>
                    <param name="millis" type="int"/>
                </params>
            </method>
            <javadoc line="2461">
                Return a copy of the transform associated with this node.                
                <return>
                    copy of this node's transform                    
                </return>
            </javadoc>
            <method name="getTransform" type="PAffineTransform" line="2466">
                <scope line="2467"/>
                <scope line="2470"/>
            </method>
            <javadoc line="2475">
                Return a reference to the transform associated with this node. This
                  returned transform should not be modified. PNode transforms are created
                  lazily when needed. If you access the transform reference before the
                  transform has been created it may return null. The
                  createNewTransformIfNull parameter is used to specify that the PNode
                  should create a new transform (and assign that transform to the nodes
                  local transform variable) instead of returning null.                
                <param>
                    createNewTransformIfNull if the transform has not been
                      initialised, should it be?                    
                </param>
                <return>
                    reference to this node's transform                    
                </return>
            </javadoc>
            <method name="getTransformReference" type="PAffineTransform" line="2489">
                <params>
                    <param name="createNewTransformIfNull" type="boolean"/>
                </params>
                <scope line="2490"/>
            </method>
            <javadoc line="2496">
                Return an inverted copy of the transform associated with this node.                
                <return>
                    inverted copy of this node's transform                    
                </return>
            </javadoc>
            <method name="getInverseTransform" type="PAffineTransform" line="2501">
                <scope line="2502"/>
                <scope line="2506"/>
                <scope line="2509"/>
            </method>
            <javadoc line="2514">
                Set the transform applied to this node.                
                <param>
                    transform the new transform value                    
                </param>
            </javadoc>
            <method name="setTransform" type="void" line="2519">
                <params>
                    <param name="transform" type="AffineTransform"/>
                </params>
                <scope line="2520"/>
                <scope line="2523"/>
            </method>
            <javadoc line="2558">
                Return true if this nodes paint is invalid, in which case the node needs
                  to be repainted.                
                <return>
                    true if this node needs to be repainted                    
                </return>
            </javadoc>
            <method name="getPaintInvalid" type="boolean" line="2564"/>
            <javadoc line="2568">
                Mark this node as having invalid paint. If this is set the node will
                  later be repainted. Node this method is most often used internally.                
                <param>
                    paintInvalid true if this node should be repainted                    
                </param>
            </javadoc>
            <method name="setPaintInvalid" type="void" line="2574">
                <params>
                    <param name="paintInvalid" type="boolean"/>
                </params>
            </method>
            <javadoc line="2578">
                Return true if this node has a child with invalid paint.                
                <return>
                    true if this node has a child with invalid paint                    
                </return>
            </javadoc>
            <method name="getChildPaintInvalid" type="boolean" line="2583"/>
            <javadoc line="2587">
                Mark this node as having a child with invalid paint.                
                <param>
                    childPaintInvalid true if this node has a child with invalid paint                    
                </param>
            </javadoc>
            <method name="setChildPaintInvalid" type="void" line="2592">
                <params>
                    <param name="childPaintInvalid" type="boolean"/>
                </params>
            </method>
            <javadoc line="2596">
                Invalidate this node&apos;s paint, and mark all of its ancestors as having a
                  node with invalid paint.                
            </javadoc>
            <method name="invalidatePaint" type="void" line="2600">
                <declaration name="n" type="PNode" line="2603"/>
                <scope line="2604"/>
                <scope line="2609"/>
            </method>
            <javadoc line="2614">
                Repaint this node and any of its descendants if they have invalid paint.                
            </javadoc>
            <method name="validateFullPaint" type="void" line="2617">
                <scope line="2618"/>
                <scope line="2623">
                    <declaration name="count" type="int" line="2624"/>
                    <scope line="2625">
                        <declaration name="each" type="PNode" line="2626"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2633">
                Mark the area on the screen represented by this nodes full bounds as
                  needing a repaint.                
            </javadoc>
            <method name="repaint" type="void" line="2637"/>
            <javadoc line="2642">
                Pass the given repaint request up the tree, so that any cameras can
                  invalidate that region on their associated canvas.                
                <param>
                    localBounds the bounds to repaint                    
                </param>
                <param>
                    childOrThis if childOrThis does not equal this then this nodes
                      transform will be applied to the localBounds param                    
                </param>
            </javadoc>
            <method name="repaintFrom" type="void" line="2650">
                <params>
                    <param name="localBounds" type="PBounds"/>
                    <param name="childOrThis" type="PNode"/>
                </params>
                <scope line="2651">
                    <scope line="2652"/>
                    <scope line="2655"/>
                </scope>
            </method>
            <javadoc line="2667">
                Returns whether this node is Opaque.                
                <param>
                    boundary boundary to check and see if this node covers completely.                    
                </param>
                <return>
                    true if opaque                    
                </return>
            </javadoc>
            <method name="isOpaque" type="boolean" line="2674">
                <params>
                    <param name="boundary" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="2678">
                Returns whether this node has been flagged as occluded.                
                <return>
                    true if occluded                    
                </return>
            </javadoc>
            <method name="getOccluded" type="boolean" line="2683"/>
            <javadoc line="2687">
                Flags this node as occluded.                
                <param>
                    occluded new value for occluded                    
                </param>
            </javadoc>
            <method name="setOccluded" type="void" line="2692">
                <params>
                    <param name="occluded" type="boolean"/>
                </params>
            </method>
            <javadoc line="2718">
                Return true if this node is visible, that is if it will paint itself and
                  descendants.                
                <return>
                    true if this node and its descendants are visible.                    
                </return>
            </javadoc>
            <method name="getVisible" type="boolean" line="2724"/>
            <javadoc line="2728">
                Set the visibility of this node and its descendants.                
                <param>
                    isVisible true if this node and its descendants are visible                    
                </param>
            </javadoc>
            <method name="setVisible" type="void" line="2733">
                <params>
                    <param name="isVisible" type="boolean"/>
                </params>
                <scope line="2734">
                    <scope line="2735"/>
                </scope>
            </method>
            <javadoc line="2744">
                Return the paint used while painting this node. This value may be null.                
                <return>
                    the paint used while painting this node.                    
                </return>
            </javadoc>
            <method name="getPaint" type="Paint" line="2749"/>
            <javadoc line="2753">
                Set the paint used to paint this node, which may be null.                
                <param>
                    newPaint paint that this node should use when painting itself.                    
                </param>
            </javadoc>
            <method name="setPaint" type="void" line="2758">
                <params>
                    <param name="newPaint" type="Paint"/>
                </params>
                <scope line="2759"/>
                <declaration name="oldPaint" type="Paint" line="2763"/>
            </method>
            <javadoc line="2769">
                Return the transparency used when painting this node. Note that this
                  transparency is also applied to all of the node&apos;s descendants.                
                <return>
                    how transparent this node is 0f = completely transparent, 1f =
                      completely opaque                    
                </return>
            </javadoc>
            <method name="getTransparency" type="float" line="2776"/>
            <javadoc line="2780">
                Set the transparency used to paint this node. Note that this transparency
                  applies to this node and all of its descendants.                
                <param>
                    newTransparency transparency value for this node. 0f = fully
                      transparent, 1f = fully opaque                    
                </param>
            </javadoc>
            <method name="setTransparency" type="void" line="2787">
                <params>
                    <param name="newTransparency" type="float"/>
                </params>
                <scope line="2788">
                    <declaration name="oldTransparency" type="float" line="2789"/>
                </scope>
            </method>
            <javadoc line="2797">
                Paint this node behind any of its children nodes. Subclasses that define
                  a different appearance should override this method and paint themselves
                  there.                
                <param>
                    paintContext the paint context to use for painting the node                    
                </param>
            </javadoc>
            <method name="paint" type="void" line="2804">
                <params>
                    <param name="paintContext" type="PPaintContext"/>
                </params>
                <scope line="2805">
                    <declaration name="g2" type="Graphics2D" line="2806"/>
                </scope>
            </method>
            <javadoc line="2812">
                Paint this node and all of its descendants. Most subclasses do not need
                  to override this method, they should override &lt;code&gt;paint&lt;/code&gt; or
                  &lt;code&gt;paintAfterChildren&lt;/code&gt; instead.                
                <param>
                    paintContext the paint context to use for painting this node and
                      its children                    
                </param>
            </javadoc>
            <method name="fullPaint" type="void" line="2820">
                <params>
                    <param name="paintContext" type="PPaintContext"/>
                </params>
                <scope line="2821">
                    <scope line="2825"/>
                    <declaration name="count" type="int" line="2829"/>
                    <scope line="2830">
                        <declaration name="each" type="PNode" line="2831"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2842">
                Subclasses that wish to do additional painting after their children are
                  painted should override this method and do that painting here.                
                <param>
                    paintContext the paint context to sue for painting after the
                      children are painted                    
                </param>
            </javadoc>
            <method name="paintAfterChildren" type="void" line="2849">
                <params>
                    <param name="paintContext" type="PPaintContext"/>
                </params>
            </method>
            <javadoc line="2852">
                Return a new Image representing this node and all of its children. The
                  image size will be equal to the size of this nodes full bounds.                
                <return>
                    a new image representing this node and its descendants                    
                </return>
            </javadoc>
            <method name="toImage" type="Image" line="2858">
                <declaration name="b" type="PBounds" line="2859"/>
            </method>
            <javadoc line="2863">
                Return a new Image of the requested size representing this node and all
                  of its children. If backGroundPaint is null the resulting image will have
                  transparent regions, otherwise those regions will be filled with the
                  backgroundPaint.                
                <param>
                    width pixel width of the resulting image                    
                </param>
                <param>
                    height pixel height of the resulting image                    
                </param>
                <param>
                    backgroundPaint paint to fill the image with before drawing this
                      node, may be null                    
                </param>
                <return>
                    a new image representing this node and its descendants                    
                </return>
            </javadoc>
            <method name="toImage" type="Image" line="2876">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="backgroundPaint" type="Paint"/>
                </params>
                <declaration name="result" type="BufferedImage" line="2877"/>
                <scope line="2879"/>
                <scope line="2882">
                    <declaration name="graphicsConfiguration" type="GraphicsConfiguration" line="2883"/>
                </scope>
            </method>
            <javadoc line="2891">
                Paint a representation of this node into the specified buffered image. If
                  background, paint is null, then the image will not be filled with a color
                  prior to rendering                
                <param>
                    image Image onto which this node will be painted                    
                </param>
                <param>
                    backGroundPaint will fill background of image with this. May be
                      null.                    
                </param>
                <return>
                    a rendering of this image and its descendants onto the specified
                      image                    
                </return>
            </javadoc>
            <method name="toImage" type="Image" line="2902">
                <params>
                    <param name="image" type="BufferedImage"/>
                    <param name="backGroundPaint" type="Paint"/>
                </params>
            </method>
            <javadoc line="2906">
                Paint a representation of this node into the specified buffered image. If
                  background, paint is null, then the image will not be filled with a color
                  prior to rendering                
                <since>
                    1.3                    
                </since>
                <param>
                    image Image onto which this node will be painted                    
                </param>
                <param>
                    backGroundPaint will fill background of image with this. May be
                      null.                    
                </param>
                <param>
                    fillStrategy strategy to use regarding how node will cover the
                      image                    
                </param>
                <return>
                    a rendering of this image and its descendants onto the specified
                      image                    
                </return>
            </javadoc>
            <method name="toImage" type="Image" line="2920">
                <params>
                    <param name="image" type="BufferedImage"/>
                    <param name="backGroundPaint" type="Paint"/>
                    <param name="fillStrategy" type="int"/>
                </params>
                <comment line="2943">
                    scale the graphics so node&apos;s full bounds fit in the imageable
                     bounds but aspect ration is retained                    
                </comment>
                <comment line="2956">
                    scale the graphics so node completely covers the imageable
                     area, but retains its aspect ratio.                    
                </comment>
                <comment line="2967">
                    scale the node so that it covers then entire image,
                     distorting it if necessary.                    
                </comment>
                <declaration name="imageWidth" type="int" line="2921"/>
                <declaration name="imageHeight" type="int" line="2922"/>
                <declaration name="g2" type="Graphics2D" line="2923"/>
                <scope line="2925"/>
                <declaration name="nodeBounds" type="PBounds" line="2931"/>
                <declaration name="nodeWidth" type="double" line="2934"/>
                <declaration name="nodeHeight" type="double" line="2935"/>
                <declaration name="imageRatio" type="double" line="2937"/>
                <declaration name="nodeRatio" type="double" line="2938"/>
                <declaration name="scale" type="double" line="2939"/>
                <scope line="2945"/>
                <scope line="2948"/>
                <scope line="2957"/>
                <scope line="2960"/>
                <declaration name="pc" type="PPaintContext" line="2975"/>
            </method>
            <javadoc line="2981">
                Constructs a new PrinterJob, allows the user to select which printer to
                  print to, And then prints the node.                
            </javadoc>
            <method name="print" type="void" line="2985">
                <declaration name="printJob" type="PrinterJob" line="2986"/>
                <declaration name="pageFormat" type="PageFormat" line="2987"/>
                <declaration name="book" type="Book" line="2988"/>
                <scope line="2992">
                    <scope line="2993"/>
                    <scope line="2996"/>
                </scope>
            </method>
            <javadoc line="3002">
                Prints the node into the given Graphics context using the specified
                  format. The zero based index of the requested page is specified by
                  pageIndex. If the requested page does not exist then this method returns
                  NO_SUCH_PAGE; otherwise PAGE_EXISTS is returned. If the printable object
                  aborts the print job then it throws a PrinterException.                
                <param>
                    graphics the context into which the node is drawn                    
                </param>
                <param>
                    pageFormat the size and orientation of the page                    
                </param>
                <param>
                    pageIndex the zero based index of the page to be drawn                    
                </param>
                <return>
                    Either NO_SUCH_PAGE or PAGE_EXISTS                    
                </return>
            </javadoc>
            <method name="print" type="int" line="3015">
                <params>
                    <param name="graphics" type="Graphics"/>
                    <param name="pageFormat" type="PageFormat"/>
                    <param name="pageIndex" type="int"/>
                </params>
                <comment line="3033">
                    scale the graphics so node&apos;s full bounds fit in the imageable bounds.                    
                </comment>
                <scope line="3016"/>
                <scope line="3020"/>
                <declaration name="g2" type="Graphics2D" line="3024"/>
                <declaration name="imageBounds" type="PBounds" line="3025"/>
                <declaration name="scale" type="double" line="3033"/>
                <scope line="3034"/>
                <declaration name="pc" type="PPaintContext" line="3041"/>
            </method>
            <javadoc line="3077">
                Return true if this node is pickable. Only pickable nodes can receive
                  input events. Nodes are pickable by default.                
                <return>
                    true if this node is pickable                    
                </return>
            </javadoc>
            <method name="getPickable" type="boolean" line="3083"/>
            <javadoc line="3087">
                Set the pickable flag for this node. Only pickable nodes can receive
                  input events. Nodes are pickable by default.                
                <param>
                    isPickable true if this node is pickable                    
                </param>
            </javadoc>
            <method name="setPickable" type="void" line="3093">
                <params>
                    <param name="isPickable" type="boolean"/>
                </params>
                <scope line="3094"/>
            </method>
            <javadoc line="3100">
                Return true if the children of this node should be picked. If this flag
                  is false then this node will not try to pick its children. Children are
                  pickable by default.                
                <return>
                    true if this node tries to pick its children                    
                </return>
            </javadoc>
            <method name="getChildrenPickable" type="boolean" line="3107"/>
            <javadoc line="3111">
                Set the children pickable flag. If this flag is false then this node will
                  not try to pick its children. Children are pickable by default.                
                <param>
                    areChildrenPickable true if this node tries to pick its children                    
                </param>
            </javadoc>
            <method name="setChildrenPickable" type="void" line="3117">
                <params>
                    <param name="areChildrenPickable" type="boolean"/>
                </params>
                <scope line="3118"/>
            </method>
            <javadoc line="3124">
                Try to pick this node before its children have had a chance to be picked.
                  Nodes that paint on top of their children may want to override this
                  method to if the pick path intersects that paint.                
                <param>
                    pickPath the pick path used for the pick operation                    
                </param>
                <return>
                    true if this node was picked                    
                </return>
            </javadoc>
            <method name="pick" type="boolean" line="3132">
                <params>
                    <param name="pickPath" type="PPickPath"/>
                </params>
            </method>
            <javadoc line="3136">
                Try to pick this node and all of its descendants. Most subclasses should
                  not need to override this method. Instead they should override
                  &lt;code&gt;pick&lt;/code&gt; or &lt;code&gt;pickAfterChildren&lt;/code&gt;.                
                <param>
                    pickPath the pick path to add the node to if its picked                    
                </param>
                <return>
                    true if this node or one of its descendants was picked.                    
                </return>
            </javadoc>
            <method name="fullPick" type="boolean" line="3144">
                <params>
                    <param name="pickPath" type="PPickPath"/>
                </params>
                <scope line="3145">
                    <declaration name="thisPickable" type="boolean" line="3149"/>
                    <scope line="3151"/>
                    <scope line="3155">
                        <declaration name="count" type="int" line="3156"/>
                        <scope line="3157">
                            <declaration name="each" type="PNode" line="3158"/>
                            <scope line="3159"/>
                        </scope>
                    </scope>
                    <scope line="3165"/>
                </scope>
            </method>
            <javadoc line="3176">
                Finds all descendants of this node that intersect with the given bounds
                  and adds them to the results array.                
                <param>
                    fullBounds bounds to compare against                    
                </param>
                <param>
                    results array into which to add matches                    
                </param>
            </javadoc>
            <method name="findIntersectingNodes" type="void" line="3183">
                <params>
                    <param name="fullBounds" type="Rectangle2D"/>
                    <param name="results" type="ArrayList"/>
                </params>
                <scope line="3184">
                    <declaration name="localBounds" type="Rectangle2D" line="3185"/>
                    <scope line="3187"/>
                    <declaration name="count" type="int" line="3191"/>
                    <scope line="3192">
                        <declaration name="each" type="PNode" line="3193"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3199">
                Try to pick this node after its children have had a chance to be picked.
                  Most subclasses the define a different geometry will need to override
                  this method.                
                <param>
                    pickPath the pick path used for the pick operation                    
                </param>
                <return>
                    true if this node was picked                    
                </return>
            </javadoc>
            <method name="pickAfterChildren" type="boolean" line="3207">
                <params>
                    <param name="pickPath" type="PPickPath"/>
                </params>
                <scope line="3208"/>
            </method>
            <javadoc line="3222">
                Add a node to be a new child of this node. The new node is added to the
                  end of the list of this node&apos;s children. If child was previously a child
                  of another node, it is removed from that first.                
                <param>
                    child the new child to add to this node                    
                </param>
            </javadoc>
            <method name="addChild" type="void" line="3229">
                <params>
                    <param name="child" type="PNode"/>
                </params>
                <declaration name="insertIndex" type="int" line="3230"/>
                <scope line="3231"/>
            </method>
            <javadoc line="3237">
                Add a node to be a new child of this node at the specified index. If
                  child was previously a child of another node, it is removed from that
                  node first.                
                <param>
                    index where in the children list to insert the child                    
                </param>
                <param>
                    child the new child to add to this node                    
                </param>
            </javadoc>
            <method name="addChild" type="void" line="3245">
                <params>
                    <param name="index" type="int"/>
                    <param name="child" type="PNode"/>
                </params>
                <declaration name="oldParent" type="PNode" line="3246"/>
                <scope line="3248"/>
            </method>
            <javadoc line="3260">
                Add a collection of nodes to be children of this node. If these nodes
                  already have parents they will first be removed from those parents.                
                <param>
                    nodes a collection of nodes to be added to this node                    
                </param>
            </javadoc>
            <method name="addChildren" type="void" line="3266">
                <params>
                    <param name="nodes" type="Collection"/>
                </params>
                <declaration name="i" type="Iterator" line="3267"/>
                <scope line="3268">
                    <declaration name="each" type="PNode" line="3269"/>
                </scope>
            </method>
            <javadoc line="3274">
                Return true if this node is an ancestor of the parameter node.                
                <param>
                    node a possible descendant node                    
                </param>
                <return>
                    true if this node is an ancestor of the given node                    
                </return>
            </javadoc>
            <method name="isAncestorOf" type="boolean" line="3280">
                <params>
                    <param name="node" type="PNode"/>
                </params>
                <declaration name="p" type="PNode" line="3281"/>
                <scope line="3282">
                    <scope line="3283"/>
                </scope>
            </method>
            <javadoc line="3291">
                Return true if this node is a descendant of the parameter node.                
                <param>
                    node a possible ancestor node                    
                </param>
                <return>
                    true if this nodes descends from the given node                    
                </return>
            </javadoc>
            <method name="isDescendentOf" type="boolean" line="3297">
                <params>
                    <param name="node" type="PNode"/>
                </params>
                <declaration name="p" type="PNode" line="3298"/>
                <scope line="3299">
                    <scope line="3300"/>
                </scope>
            </method>
            <javadoc line="3308">
                Return true if this node descends from the root.                
                <return>
                    whether this node descends from root node                    
                </return>
            </javadoc>
            <method name="isDescendentOfRoot" type="boolean" line="3313"/>
            <javadoc line="3317">
                Change the order of this node in its parent&apos;s children list so that it
                  will draw in back of all of its other sibling nodes.                
            </javadoc>
            <method name="moveToBack" type="void" line="3321">
                <declaration name="p" type="PNode" line="3322"/>
                <scope line="3323"/>
            </method>
            <javadoc line="3329">
                Change the order of this node in its parent&apos;s children list so that it
                  will draw in back of the specified sibling node.                
                <param>
                    sibling sibling to move in back of                    
                </param>
            </javadoc>
            <method name="moveInBackOf" type="void" line="3335">
                <params>
                    <param name="sibling" type="PNode"/>
                </params>
                <declaration name="p" type="PNode" line="3336"/>
                <scope line="3337">
                    <declaration name="index" type="int" line="3339"/>
                </scope>
            </method>
            <javadoc line="3344">
                Change the order of this node in its parent&apos;s children list so that it
                  will draw in front of all of its other sibling nodes.                
            </javadoc>
            <method name="moveToFront" type="void" line="3348">
                <declaration name="p" type="PNode" line="3349"/>
                <scope line="3350"/>
            </method>
            <javadoc line="3356">
                Change the order of this node in its parent&apos;s children list so that it
                  will draw in front of the specified sibling node.                
                <param>
                    sibling sibling to move in front of                    
                </param>
            </javadoc>
            <method name="moveInFrontOf" type="void" line="3362">
                <params>
                    <param name="sibling" type="PNode"/>
                </params>
                <declaration name="p" type="PNode" line="3363"/>
                <scope line="3364">
                    <declaration name="index" type="int" line="3366"/>
                </scope>
            </method>
            <javadoc line="3371">
                Return the parent of this node. This will be null if this node has not
                  been added to a parent yet.                
                <return>
                    this nodes parent or null                    
                </return>
            </javadoc>
            <method name="getParent" type="PNode" line="3377"/>
            <javadoc line="3381">
                Set the parent of this node. Note this is set automatically when adding
                  and removing children.                
                <param>
                    newParent the parent to which this node should be added                    
                </param>
            </javadoc>
            <method name="setParent" type="void" line="3387">
                <params>
                    <param name="newParent" type="PNode"/>
                </params>
                <declaration name="old" type="PNode" line="3388"/>
            </method>
            <javadoc line="3393">
                Return the index where the given child is stored.                
                <param>
                    child child so search for                    
                </param>
                <return>
                    index of child or -1 if not found                    
                </return>
            </javadoc>
            <method name="indexOfChild" type="int" line="3399">
                <params>
                    <param name="child" type="PNode"/>
                </params>
                <scope line="3400"/>
            </method>
            <javadoc line="3406">
                Remove the given child from this node&apos;s children list. Any subsequent
                  children are shifted to the left (one is subtracted from their indices).
                  The removed child&apos;s parent is set to null.                
                <param>
                    child the child to remove                    
                </param>
                <return>
                    the removed child                    
                </return>
            </javadoc>
            <method name="removeChild" type="PNode" line="3414">
                <params>
                    <param name="child" type="PNode"/>
                </params>
                <declaration name="index" type="int" line="3415"/>
                <scope line="3416"/>
            </method>
            <javadoc line="3422">
                Remove the child at the specified position of this group node&apos;s children.
                  Any subsequent children are shifted to the left (one is subtracted from
                  their indices). The removed child&apos;s parent is set to null.                
                <param>
                    index the index of the child to remove                    
                </param>
                <return>
                    the removed child                    
                </return>
            </javadoc>
            <method name="removeChild" type="PNode" line="3430">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="3431"/>
                <declaration name="child" type="PNode" line="3434"/>
                <scope line="3436"/>
            </method>
            <javadoc line="3449">
                Remove all the children in the given collection from this node&apos;s list of
                  children. All removed nodes will have their parent set to null.                
                <param>
                    childrenNodes the collection of children to remove                    
                </param>
            </javadoc>
            <method name="removeChildren" type="void" line="3455">
                <params>
                    <param name="childrenNodes" type="Collection"/>
                </params>
                <declaration name="i" type="Iterator" line="3456"/>
                <scope line="3457">
                    <declaration name="each" type="PNode" line="3458"/>
                </scope>
            </method>
            <javadoc line="3463">
                Remove all the children from this node. Node this method is more
                  efficient then removing each child individually.                
            </javadoc>
            <method name="removeAllChildren" type="void" line="3467">
                <scope line="3468">
                    <declaration name="count" type="int" line="3469"/>
                    <scope line="3470">
                        <declaration name="each" type="PNode" line="3471"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3482">
                Delete this node by removing it from its parent&apos;s list of children.                
            </javadoc>
            <method name="removeFromParent" type="void" line="3485">
                <scope line="3486"/>
            </method>
            <javadoc line="3491">
                Set the parent of this node, and transform the node in such a way that it
                  doesn&apos;t move in global coordinates.                
                <param>
                    newParent The new parent of this node.                    
                </param>
            </javadoc>
            <method name="reparent" type="void" line="3497">
                <params>
                    <param name="newParent" type="PNode"/>
                </params>
                <declaration name="originalTransform" type="AffineTransform" line="3498"/>
                <declaration name="newTransform" type="AffineTransform" line="3499"/>
            </method>
            <javadoc line="3508">
                Swaps this node out of the scene graph tree, and replaces it with the
                  specified replacement node. This node is left dangling, and it is up to
                  the caller to manage it. The replacement node will be added to this
                  node&apos;s parent in the same position as this was. That is, if this was the
                  3rd child of its parent, then after calling replaceWith(), the
                  replacement node will also be the 3rd child of its parent. If this node
                  has no parent when replace is called, then nothing will be done at all.                
                <param>
                    replacementNode the new node that replaces the current node in the
                      scene graph tree.                    
                </param>
            </javadoc>
            <method name="replaceWith" type="void" line="3520">
                <params>
                    <param name="replacementNode" type="PNode"/>
                </params>
                <scope line="3521">
                    <declaration name="p" type="PNode" line="3522"/>
                    <declaration name="index" type="int" line="3523"/>
                </scope>
            </method>
            <javadoc line="3529">
                Sets the name of this null, may be null.                
                <since>
                    1.3                    
                </since>
                <param>
                    name new name for this node                    
                </param>
            </javadoc>
            <method name="setName" type="void" line="3535">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="3539">
                Returns the name given to this node.                
                <since>
                    1.3                    
                </since>
                <return>
                    name given to this node, may be null                    
                </return>
            </javadoc>
            <method name="getName" type="String" line="3545"/>
            <javadoc line="3549">
                Return the number of children that this node has.                
                <return>
                    the number of children                    
                </return>
            </javadoc>
            <method name="getChildrenCount" type="int" line="3554">
                <scope line="3555"/>
            </method>
            <javadoc line="3561">
                Return the child node at the specified index.                
                <param>
                    index a child index                    
                </param>
                <return>
                    the child node at the specified index                    
                </return>
            </javadoc>
            <method name="getChild" type="PNode" line="3567">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="3571">
                Return a reference to the list used to manage this node&apos;s children. This
                  list should not be modified.                
                <return>
                    reference to the children list                    
                </return>
            </javadoc>
            <method name="getChildrenReference" type="List" line="3577">
                <scope line="3578"/>
            </method>
            <javadoc line="3584">
                Return an iterator over this node&apos;s direct descendant children.                
                <return>
                    iterator over this nodes children                    
                </return>
            </javadoc>
            <method name="getChildrenIterator" type="ListIterator" line="3589">
                <scope line="3590"/>
            </method>
            <javadoc line="3596">
                Return the root node (instance of PRoot). If this node does not descend
                  from a PRoot then null will be returned.                
                <return>
                    root element of this node, or null if this node does not descend
                      from a PRoot                    
                </return>
            </javadoc>
            <method name="getRoot" type="PRoot" line="3603">
                <scope line="3604"/>
            </method>
            <javadoc line="3610">
                Return a collection containing this node and all of its descendant nodes.                
                <return>
                    a new collection containing this node and all descendants                    
                </return>
            </javadoc>
            <method name="getAllNodes" type="Collection" line="3615"/>
            <javadoc line="3619">
                Return a collection containing the subset of this node and all of its
                  descendant nodes that are accepted by the given node filter. If the
                  filter is null then all nodes will be accepted. If the results parameter
                  is not null then it will be used to collect this subset instead of
                  creating a new collection.                
                <param>
                    filter the filter used to determine the subset                    
                </param>
                <param>
                    resultantNodes where matching nodes should be added                    
                </param>
                <return>
                    a collection containing this node and all descendants                    
                </return>
            </javadoc>
            <method name="getAllNodes" type="Collection" line="3630">
                <params>
                    <param name="filter" type="PNodeFilter"/>
                    <param name="resultantNodes" type="Collection"/>
                </params>
                <declaration name="results" type="Collection" line="3631"/>
                <scope line="3632"/>
                <scope line="3635"/>
                <scope line="3639"/>
                <scope line="3643">
                    <declaration name="count" type="int" line="3644"/>
                    <scope line="3645">
                        <declaration name="each" type="PNode" line="3646"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3661">
                Write this node and all of its descendant nodes to the given outputsteam.
                  This stream must be an instance of PObjectOutputStream or serialization
                  will fail. This nodes parent is written out conditionally, that is it
                  will only be written out if someone else writes it out unconditionally.                
                <param>
                    out the output stream to write to, must be an instance of
                      PObjectOutputStream                    
                </param>
                <throws>
                    IOException when an error occurs speaking to underlying
                      ObjectOutputStream                    
                </throws>
            </javadoc>
            <method name="writeObject" type="void" line="3672">
                <params>
                    <param name="out" type="ObjectOutputStream"/>
                </params>
                <scope line="3673"/>
            </method>
            <javadoc line="3680">
                Read this node and all of its descendants in from the given input stream.                
                <param>
                    in the stream to read from                    
                </param>
                <throws>
                    IOException when an error occurs speaking to underlying
                      ObjectOutputStream                    
                </throws>
                <throws>
                    ClassNotFoundException when a class is deserialized that no
                      longer exists. This can happen if it's renamed or deleted.                    
                </throws>
            </javadoc>
            <method name="readObject" type="void" line="3690">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
            </method>
            <javadoc line="3695">
                @deprecated see http://code.google.com/p/piccolo2d/issues/detail?id=99                
                <return>
                    a string representation of this node's state                    
                </return>
            </javadoc>
            <method name="paramString" type="String" line="3700"/>
            <javadoc line="3704">
                Returns an array of input event listeners that are attached to this node.                
                <since>
                    1.3                    
                </since>
                <return>
                    event listeners attached to this node                    
                </return>
            </javadoc>
            <method name="getInputEventListeners" type="PInputEventListener[]" line="3710">
                <scope line="3711"/>
                <declaration name="listeners" type="EventListener[]" line="3715"/>
                <declaration name="result" type="PInputEventListener[]" line="3717"/>
                <scope line="3718"/>
            </method>
            <class name="ClientPropertyKeyIterator" line="3724">
                <implements interface="Iterator"/>
                <declaration name="enumeration" type="Enumeration" line="3725"/>
                <method name="ClientPropertyKeyIterator" type="constructor" line="3727">
                    <params>
                        <param name="enumeration" type="Enumeration"/>
                    </params>
                </method>
                <method name="hasNext" type="boolean" line="3731"/>
                <method name="next" type="Object" line="3735"/>
                <method name="remove" type="void" line="3739"/>
            </class>
            <interface name="PSceneGraphDelegate">
                <javadoc line="3744">
                    &lt;b&gt;PSceneGraphDelegate&lt;/b&gt; is an interface to receive low level node
                      events. It together with PNode.SCENE_GRAPH_DELEGATE gives Piccolo2d users
                      an efficient way to learn about low level changes in Piccolo&apos;s scene
                      graph. Most users will not need to use this.                    
                </javadoc>
                <method name="nodePaintInvalidated" type="void" line="3751"/>
                <javadoc line="3751">
                    Called to notify delegate that the node needs repainting.                    
                    <param>
                        node node needing repaint                        
                    </param>
                </javadoc>
                <method name="nodeFullBoundsInvalidated" type="void" line="3758"/>
                <javadoc line="3758">
                    Called to notify delegate that the node and all it&apos;s children need
                      repainting.                    
                    <param>
                        node node needing repaint                        
                    </param>
                </javadoc>
            </interface>
        </class>
    </source>