<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.euclidean.twod">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.geometry.Point"/>
        <import package="org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D"/>
        <import package="org.apache.commons.math3.geometry.euclidean.oned.Interval"/>
        <import package="org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"/>
        <import package="org.apache.commons.math3.geometry.euclidean.oned.Vector1D"/>
        <import package="org.apache.commons.math3.geometry.partitioning.AbstractRegion"/>
        <import package="org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane"/>
        <import package="org.apache.commons.math3.geometry.partitioning.BSPTree"/>
        <import package="org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor"/>
        <import package="org.apache.commons.math3.geometry.partitioning.BoundaryAttribute"/>
        <import package="org.apache.commons.math3.geometry.partitioning.Side"/>
        <import package="org.apache.commons.math3.geometry.partitioning.SubHyperplane"/>
        <import package="org.apache.commons.math3.geometry.partitioning.utilities.AVLTree"/>
        <import package="org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="PolygonsSet" line="40">
            <extends class="AbstractRegion">
                <type_params>
                    <type_param name="Euclidean2D"/>
                    <type_param name="Euclidean1D"/>
                </type_params>
            </extends>
            <javadoc line="40">
                This class represents a 2D region: a set of polygons.                
                <version>
                    $Id: PolygonsSet.java 1590560 2014-04-28 06:39:01Z luc $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="DEFAULT_TOLERANCE" type="double" line="46"/>
            <javadoc line="46">
                Default value for tolerance.                
            </javadoc>
            <declaration name="vertices" type="Vector2D[][]" line="49"/>
            <javadoc line="49">
                Vertices organized as boundary loops.                
            </javadoc>
            <javadoc line="52">
                Build a polygons set representing the whole plane.                
                <param>
                    tolerance tolerance below which points are considered identical                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="56">
                <params>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="60">
                Build a polygons set from a BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
                  &lt;p&gt;
                  This constructor is aimed at expert use, as building the tree may
                  be a difficult task. It is not intended for general use and for
                  performances reasons does not check thoroughly its input, as this would
                  require walking the full tree each time. Failing to provide a tree with
                  the proper attributes, &lt;em&gt;will&lt;/em&gt; therefore generate problems like{@link NullPointerException} or {@link ClassCastException} only later on.
                  This limitation is known and explains why this constructor is for expert
                  use only. The caller does have the responsibility to provided correct arguments.
                  &lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the region                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="81">
                <params>
                    <param name="tree" type="BSPTree&lt;Euclidean2D&gt;"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="85">
                Build a polygons set from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoint polygons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements, as a
                      collection of {@link SubHyperplane SubHyperplane} objects                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="107">
                <params>
                    <param name="boundary" type="Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="111">
                Build a parallellepipedic box.                
                <param>
                    xMin low bound along the x direction                    
                </param>
                <param>
                    xMax high bound along the x direction                    
                </param>
                <param>
                    yMin low bound along the y direction                    
                </param>
                <param>
                    yMax high bound along the y direction                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="121">
                <params>
                    <param name="xMin" type="double"/>
                    <param name="xMax" type="double"/>
                    <param name="yMin" type="double"/>
                    <param name="yMax" type="double"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="125">
                Build a polygon from a simple list of vertices.
                  &lt;p&gt;The boundary is provided as a list of points considering to
                  represent the vertices of a simple loop. The interior part of the
                  region is on the left side of this path and the exterior is on its
                  right side.&lt;/p&gt;
                  &lt;p&gt;This constructor does not handle polygons with a boundary
                  forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
                  &lt;p&gt;For cases where this simple constructor applies, it is expected to
                  be numerically more robust than the {@link #PolygonsSet(Collection) general
                  constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
                  &lt;p&gt;If the list is empty, the region will represent the whole
                  space.&lt;/p&gt;
                  &lt;p&gt;
                  Polygons with thin pikes or dents are inherently difficult to handle because
                  they involve lines with almost opposite directions at some vertices. Polygons
                  whose vertices come from some physical measurement with noise are also
                  difficult because an edge that should be straight may be broken in lots of
                  different pieces with almost equal directions. In both cases, computing the
                  lines intersections is not numerically robust due to the almost 0 or almost
                  &amp;pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}parameter. A too small value would often lead to completely wrong polygons
                  with large area wrongly identified as inside or outside. Large values are
                  often much safer. As a rule of thumb, a value slightly below the size of the
                  most accurate detail needed is a good value for the {@code hyperplaneThickness}parameter.
                  &lt;/p&gt;                
                <param>
                    hyperplaneThickness tolerance below which points are considered to
                      belong to the hyperplane (which is therefore more a slab)                    
                </param>
                <param>
                    vertices vertices of the simple loop boundary                    
                </param>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="155">
                <params>
                    <param name="hyperplaneThickness" type="double"/>
                    <param name="vertices" type="Vector2D"/>
                </params>
            </method>
            <javadoc line="159">
                Build a polygons set representing the whole real line.                
                <deprecated>
                    as of 3.3, replaced with {@link #PolygonsSet(double)}                    
                </deprecated>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="163"/>
            <javadoc line="167">
                Build a polygons set from a BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the region                    
                </param>
                <deprecated>
                    as of 3.3, replaced with {@link #PolygonsSet(BSPTree,double)}                    
                </deprecated>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="178">
                <params>
                    <param name="tree" type="BSPTree&lt;Euclidean2D&gt;"/>
                </params>
            </method>
            <javadoc line="182">
                Build a polygons set from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoint polygons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements, as a
                      collection of {@link SubHyperplane SubHyperplane} objects                    
                </param>
                <deprecated>
                    as of 3.3, replaced with {@link #PolygonsSet(Collection,double)}                    
                </deprecated>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="204">
                <params>
                    <param name="boundary" type="Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;"/>
                </params>
            </method>
            <javadoc line="208">
                Build a parallellepipedic box.                
                <param>
                    xMin low bound along the x direction                    
                </param>
                <param>
                    xMax high bound along the x direction                    
                </param>
                <param>
                    yMin low bound along the y direction                    
                </param>
                <param>
                    yMax high bound along the y direction                    
                </param>
                <deprecated>
                    as of 3.3, replaced with {@link #PolygonsSet(double,double,double,double,double)}                    
                </deprecated>
            </javadoc>
            <method name="PolygonsSet" type="constructor" line="217">
                <params>
                    <param name="xMin" type="double"/>
                    <param name="xMax" type="double"/>
                    <param name="yMin" type="double"/>
                    <param name="yMax" type="double"/>
                </params>
            </method>
            <javadoc line="221">
                Create a list of hyperplanes representing the boundary of a box.                
                <param>
                    xMin low bound along the x direction                    
                </param>
                <param>
                    xMax high bound along the x direction                    
                </param>
                <param>
                    yMin low bound along the y direction                    
                </param>
                <param>
                    yMax high bound along the y direction                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical                    
                </param>
                <return>
                    boundary of the box                    
                </return>
            </javadoc>
            <method name="boxBoundary" type="Line[]" line="231">
                <params>
                    <param name="xMin" type="double"/>
                    <param name="xMax" type="double"/>
                    <param name="yMin" type="double"/>
                    <param name="yMax" type="double"/>
                    <param name="tolerance" type="double"/>
                </params>
                <comment line="234">
                    too thin box, build an empty polygons set                    
                </comment>
                <scope line="232"/>
                <declaration name="minMin" type="Vector2D" line="236"/>
                <declaration name="minMax" type="Vector2D" line="237"/>
                <declaration name="maxMin" type="Vector2D" line="238"/>
                <declaration name="maxMax" type="Vector2D" line="239"/>
            </method>
            <javadoc line="248">
                Build the BSP tree of a polygons set from a simple list of vertices.
                  &lt;p&gt;The boundary is provided as a list of points considering to
                  represent the vertices of a simple loop. The interior part of the
                  region is on the left side of this path and the exterior is on its
                  right side.&lt;/p&gt;
                  &lt;p&gt;This constructor does not handle polygons with a boundary
                  forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
                  &lt;p&gt;For cases where this simple constructor applies, it is expected to
                  be numerically more robust than the {@link #PolygonsSet(Collection) general
                  constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;                
                <param>
                    hyperplaneThickness tolerance below which points are consider to
                      belong to the hyperplane (which is therefore more a slab)                    
                </param>
                <param>
                    vertices vertices of the simple loop boundary                    
                </param>
                <return>
                    the BSP tree of the input vertices                    
                </return>
            </javadoc>
            <method name="verticesToTree" type="BSPTree&lt;Euclidean2D&gt;" line="264">
                <params>
                    <param name="hyperplaneThickness" type="double"/>
                    <param name="vertices" type="Vector2D"/>
                </params>
                <comment line="269">
                    the tree represents the whole space                    
                </comment>
                <comment line="273">
                    build the vertices                    
                </comment>
                <comment line="279">
                    build the edges                    
                </comment>
                <comment line="283">
                    get the endpoints of the edge                    
                </comment>
                <comment line="287">
                    get the line supporting the edge, taking care not to recreate it
                     if it was already created earlier due to another edge being aligned
                     with the current one                    
                </comment>
                <comment line="295">
                    create the edge and store it                    
                </comment>
                <comment line="298">
                    check if another vertex also happens to be on this line                    
                </comment>
                <comment line="308">
                    build the tree top-down                    
                </comment>
                <declaration name="n" type="int" line="266"/>
                <scope line="267"/>
                <declaration name="vArray" type="Vertex[]" line="273"/>
                <scope line="274"/>
                <declaration name="edges" type="List&amp;lt;Edge&amp;gt;" line="279"/>
                <scope line="280">
                    <declaration name="start" type="Vertex" line="283"/>
                    <declaration name="end" type="Vertex" line="284"/>
                    <declaration name="line" type="Line" line="289"/>
                    <scope line="290"/>
                    <scope line="298">
                        <scope line="300"/>
                    </scope>
                </scope>
                <declaration name="tree" type="BSPTree&amp;lt;Euclidean2D&amp;gt;" line="308"/>
            </method>
            <javadoc line="315">
                Recursively build a tree by inserting cut sub-hyperplanes.                
                <param>
                    hyperplaneThickness tolerance below which points are consider to
                      belong to the hyperplane (which is therefore more a slab)                    
                </param>
                <param>
                    node current tree node (it is a leaf node at the beginning
                      of the call)                    
                </param>
                <param>
                    edges list of edges to insert in the cell defined by this node
                      (excluding edges not belonging to the cell defined by this node)                    
                </param>
            </javadoc>
            <method name="insertEdges" type="void" line="325">
                <params>
                    <param name="hyperplaneThickness" type="double"/>
                    <param name="node" type="BSPTree&lt;Euclidean2D&gt;"/>
                    <param name="edges" type="List&lt;Edge&gt;"/>
                </params>
                <comment line="328">
                    find an edge with an hyperplane that can be inserted in the node                    
                </comment>
                <comment line="345">
                    no suitable edge was found, the node remains a leaf node
                     we need to set its inside/outside boolean indicator                    
                </comment>
                <comment line="356">
                    we have split the node by inserting an edge as a cut sub-hyperplane
                     distribute the remaining edges in the two sub-trees                    
                </comment>
                <comment line="371">
                    we need to insert a split point on the hyperplane                    
                </comment>
                <comment line="381">
                    we need to insert a split point on the hyperplane                    
                </comment>
                <comment line="400">
                    recurse through lower levels                    
                </comment>
                <declaration name="index" type="int" line="328"/>
                <declaration name="inserted" type="Edge" line="329"/>
                <scope line="330">
                    <scope line="332">
                        <scope line="333"/>
                        <scope line="335"/>
                    </scope>
                    <scope line="338"/>
                </scope>
                <scope line="343">
                    <declaration name="parent" type="BSPTree&amp;lt;Euclidean2D&amp;gt;" line="346"/>
                    <scope line="347"/>
                    <scope line="349"/>
                </scope>
                <declaration name="plusList" type="List&amp;lt;Edge&amp;gt;" line="357"/>
                <declaration name="minusList" type="List&amp;lt;Edge&amp;gt;" line="358"/>
                <scope line="359">
                    <scope line="360">
                        <declaration name="startOffset" type="double" line="361"/>
                        <declaration name="endOffset" type="double" line="362"/>
                        <declaration name="startSide" type="Side" line="363"/>
                        <declaration name="endSide" type="Side" line="365"/>
                        <scope line="369">
                            <declaration name="splitPoint" type="Vertex" line="371"/>
                        </scope>
                        <scope line="374"/>
                        <scope line="379">
                            <declaration name="splitPoint" type="Vertex" line="381"/>
                        </scope>
                        <scope line="384"/>
                        <scope line="389"/>
                        <scope line="391"/>
                    </scope>
                </scope>
                <scope line="400"/>
                <scope line="402"/>
                <scope line="405"/>
                <scope line="407"/>
            </method>
            <class name="Vertex" line="413">
                <javadoc line="413">
                    Internal class for holding vertices while they are processed to build a BSP tree.                    
                </javadoc>
                <declaration name="location" type="Vector2D" line="416"/>
                <javadoc line="416">
                    Vertex location.                    
                </javadoc>
                <declaration name="incoming" type="Edge" line="419"/>
                <javadoc line="419">
                    Incoming edge.                    
                </javadoc>
                <declaration name="outgoing" type="Edge" line="422"/>
                <javadoc line="422">
                    Outgoing edge.                    
                </javadoc>
                <declaration name="lines" type="List&amp;lt;Line&amp;gt;" line="425"/>
                <javadoc line="425">
                    Lines bound with this vertex.                    
                </javadoc>
                <javadoc line="428">
                    Build a non-processed vertex not owned by any node yet.                    
                    <param>
                        location vertex location                        
                    </param>
                </javadoc>
                <method name="Vertex" type="constructor" line="431">
                    <params>
                        <param name="location" type="Vector2D"/>
                    </params>
                </method>
                <javadoc line="438">
                    Get Vertex location.                    
                    <return>
                        vertex location                        
                    </return>
                </javadoc>
                <method name="getLocation" type="Vector2D" line="441"/>
                <javadoc line="445">
                    Bind a line considered to contain this vertex.                    
                    <param>
                        line line to bind with this vertex                        
                    </param>
                </javadoc>
                <method name="bindWith" type="void" line="448">
                    <params>
                        <param name="line" type="Line"/>
                    </params>
                </method>
                <javadoc line="452">
                    Get the common line bound with both the instance and another vertex, if any.
                      &lt;p&gt;
                      When two vertices are both bound to the same line, this means they are
                      already handled by node associated with this line, so there is no need
                      to create a cut hyperplane for them.
                      &lt;/p&gt;                    
                    <param>
                        vertex other vertex to check instance against                        
                    </param>
                    <return>
                        line bound with both the instance and another vertex, or null if the
                          two vertices do not share a line yet                        
                    </return>
                </javadoc>
                <method name="sharedLineWith" type="Line" line="462">
                    <params>
                        <param name="vertex" type="Vertex"/>
                    </params>
                    <scope line="463">
                        <scope line="464">
                            <scope line="465"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="473">
                    Set incoming edge.
                      &lt;p&gt;
                      The line supporting the incoming edge is automatically bound
                      with the instance.
                      &lt;/p&gt;                    
                    <param>
                        incoming incoming edge                        
                    </param>
                </javadoc>
                <method name="setIncoming" type="void" line="480">
                    <params>
                        <param name="incoming" type="Edge"/>
                    </params>
                </method>
                <javadoc line="485">
                    Get incoming edge.                    
                    <return>
                        incoming edge                        
                    </return>
                </javadoc>
                <method name="getIncoming" type="Edge" line="488"/>
                <javadoc line="492">
                    Set outgoing edge.
                      &lt;p&gt;
                      The line supporting the outgoing edge is automatically bound
                      with the instance.
                      &lt;/p&gt;                    
                    <param>
                        outgoing outgoing edge                        
                    </param>
                </javadoc>
                <method name="setOutgoing" type="void" line="499">
                    <params>
                        <param name="outgoing" type="Edge"/>
                    </params>
                </method>
                <javadoc line="504">
                    Get outgoing edge.                    
                    <return>
                        outgoing edge                        
                    </return>
                </javadoc>
                <method name="getOutgoing" type="Edge" line="507"/>
            </class>
            <class name="Edge" line="513">
                <javadoc line="513">
                    Internal class for holding edges while they are processed to build a BSP tree.                    
                </javadoc>
                <declaration name="start" type="Vertex" line="516"/>
                <javadoc line="516">
                    Start vertex.                    
                </javadoc>
                <declaration name="end" type="Vertex" line="519"/>
                <javadoc line="519">
                    End vertex.                    
                </javadoc>
                <declaration name="line" type="Line" line="522"/>
                <javadoc line="522">
                    Line supporting the edge.                    
                </javadoc>
                <declaration name="node" type="BSPTree&amp;lt;Euclidean2D&amp;gt;" line="525"/>
                <javadoc line="525">
                    Node whose cut hyperplane contains this edge.                    
                </javadoc>
                <javadoc line="528">
                    Build an edge not contained in any node yet.                    
                    <param>
                        start start vertex                        
                    </param>
                    <param>
                        end end vertex                        
                    </param>
                    <param>
                        line line supporting the edge                        
                    </param>
                </javadoc>
                <method name="Edge" type="constructor" line="533">
                    <params>
                        <param name="start" type="Vertex"/>
                        <param name="end" type="Vertex"/>
                        <param name="line" type="Line"/>
                    </params>
                    <comment line="541">
                        connect the vertices back to the edge                        
                    </comment>
                </method>
                <javadoc line="546">
                    Get start vertex.                    
                    <return>
                        start vertex                        
                    </return>
                </javadoc>
                <method name="getStart" type="Vertex" line="549"/>
                <javadoc line="553">
                    Get end vertex.                    
                    <return>
                        end vertex                        
                    </return>
                </javadoc>
                <method name="getEnd" type="Vertex" line="556"/>
                <javadoc line="560">
                    Get the line supporting this edge.                    
                    <return>
                        line supporting this edge                        
                    </return>
                </javadoc>
                <method name="getLine" type="Line" line="563"/>
                <javadoc line="567">
                    Set the node whose cut hyperplane contains this edge.                    
                    <param>
                        node node whose cut hyperplane contains this edge                        
                    </param>
                </javadoc>
                <method name="setNode" type="void" line="570">
                    <params>
                        <param name="node" type="BSPTree&lt;Euclidean2D&gt;"/>
                    </params>
                </method>
                <javadoc line="574">
                    Get the node whose cut hyperplane contains this edge.                    
                    <return>
                        node whose cut hyperplane contains this edge
                          (null if edge has not yet been inserted into the BSP tree)                        
                    </return>
                </javadoc>
                <method name="getNode" type="BSPTree&lt;Euclidean2D&gt;" line="578"/>
                <javadoc line="582">
                    Split the edge.
                      &lt;p&gt;
                      Once split, this edge is not referenced anymore by the vertices,
                      it is replaced by the two half-edges and an intermediate splitting
                      vertex is introduced to connect these two halves.
                      &lt;/p&gt;                    
                    <param>
                        splitLine line splitting the edge in two halves                        
                    </param>
                    <return>
                        split vertex (its incoming and outgoing edges are the two halves)                        
                    </return>
                </javadoc>
                <method name="split" type="Vertex" line="591">
                    <params>
                        <param name="splitLine" type="Line"/>
                    </params>
                    <declaration name="splitVertex" type="Vertex" line="592"/>
                    <declaration name="startHalf" type="Edge" line="594"/>
                    <declaration name="endHalf" type="Edge" line="595"/>
                </method>
            </class>
            <javadoc line="603">
                {@inheritDoc}                
            </javadoc>
            <method name="buildNew" type="PolygonsSet" line="605">
                <params>
                    <param name="tree" type="BSPTree&lt;Euclidean2D&gt;"/>
                </params>
            </method>
            <javadoc line="609">
                {@inheritDoc}                
            </javadoc>
            <method name="computeGeometricalProperties" type="void" line="611">
                <comment line="619">
                    the instance covers the whole space                    
                </comment>
                <comment line="627">
                    there is at least one open-loop: the polygon is infinite                    
                </comment>
                <comment line="631">
                    all loops are closed, we compute some integrals around the shape                    
                </comment>
                <comment line="653">
                    the polygon as a finite outside surrounded by an infinite inside                    
                </comment>
                <declaration name="v" type="Vector2D[][]" line="613"/>
                <scope line="615">
                    <declaration name="tree" type="BSPTree&amp;lt;Euclidean2D&amp;gt;" line="616"/>
                    <scope line="617"/>
                    <scope line="621"/>
                </scope>
                <scope line="625"/>
                <scope line="629">
                    <declaration name="sum" type="double" line="632"/>
                    <declaration name="sumX" type="double" line="633"/>
                    <declaration name="sumY" type="double" line="634"/>
                    <scope line="636">
                        <declaration name="x1" type="double" line="637"/>
                        <declaration name="y1" type="double" line="638"/>
                        <scope line="639">
                            <declaration name="x0" type="double" line="640"/>
                            <declaration name="y0" type="double" line="641"/>
                            <declaration name="factor" type="double" line="644"/>
                        </scope>
                    </scope>
                    <scope line="651"/>
                    <scope line="655"/>
                </scope>
            </method>
            <javadoc line="664">
                Get the vertices of the polygon.
                  &lt;p&gt;The polygon boundary can be represented as an array of loops,
                  each loop being itself an array of vertices.&lt;/p&gt;
                  &lt;p&gt;In order to identify open loops which start and end by
                  infinite edges, the open loops arrays start with a null point. In
                  this case, the first non null point and the last point of the
                  array do not represent real vertices, they are dummy points
                  intended only to get the direction of the first and last edge. An
                  open loop consisting of a single infinite line will therefore be
                  represented by a three elements array with one null point
                  followed by two dummy points. The open loops are always the first
                  ones in the loops array.&lt;/p&gt;
                  &lt;p&gt;If the polygon has no boundary at all, a zero length loop
                  array will be returned.&lt;/p&gt;
                  &lt;p&gt;All line segments in the various loops have the inside of the
                  region on their left side and the outside on their right side
                  when moving in the underlying line direction. This means that
                  closed loops surrounding finite areas obey the direct
                  trigonometric orientation.&lt;/p&gt;                
                <return>
                    vertices of the polygon, organized as oriented boundary
                      loops with the open loops first (the returned value is guaranteed
                      to be non-null)                    
                </return>
            </javadoc>
            <method name="getVertices" type="Vector2D[][]" line="687">
                <comment line="694">
                    sort the segments according to their start point                    
                </comment>
                <comment line="699">
                    identify the loops, starting from the open ones
                     (their start segments are naturally at the sorted set beginning)                    
                </comment>
                <comment line="710">
                    transform the loops in an array of arrays of points                    
                </comment>
                <comment line="716">
                    single infinite line                    
                </comment>
                <comment line="724">
                    open loop with at least one real point                    
                </comment>
                <comment line="730">
                    null point and first dummy point                    
                </comment>
                <comment line="738">
                    current point                    
                </comment>
                <comment line="743">
                    last dummy point                    
                </comment>
                <scope line="688">
                    <scope line="689"/>
                    <scope line="691">
                        <declaration name="visitor" type="SegmentsBuilder" line="694"/>
                        <declaration name="sorted" type="AVLTree&amp;lt;ComparableSegment&amp;gt;" line="696"/>
                        <declaration name="loops" type="ArrayList&amp;lt;List&amp;lt;ComparableSegment&amp;gt;&amp;gt;" line="700"/>
                        <scope line="701">
                            <declaration name="node" type="AVLTree&amp;lt;ComparableSegment&amp;gt;.Node" line="702"/>
                            <declaration name="loop" type="List&amp;lt;ComparableSegment&amp;gt;" line="703"/>
                            <scope line="704"/>
                        </scope>
                        <declaration name="i" type="int" line="711"/>
                        <scope line="713">
                            <scope line="714">
                                <declaration name="line" type="Line" line="716"/>
                            </scope>
                            <scope line="722">
                                <declaration name="array" type="Vector2D[]" line="724"/>
                                <declaration name="j" type="int" line="725"/>
                                <scope line="726">
                                    <scope line="728">
                                        <declaration name="x" type="double" line="730"/>
                                    </scope>
                                    <scope line="736"/>
                                    <scope line="741">
                                        <declaration name="x" type="double" line="743"/>
                                    </scope>
                                </scope>
                            </scope>
                            <scope line="750">
                                <declaration name="array" type="Vector2D[]" line="751"/>
                                <declaration name="j" type="int" line="752"/>
                                <scope line="753"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="767">
                Follow a boundary loop.                
                <param>
                    node node containing the segment starting the loop                    
                </param>
                <param>
                    sorted set of segments belonging to the boundary, sorted by
                      start points (contains {@code node})                    
                </param>
                <return>
                    a list of connected sub-hyperplanes starting at{@code node}                    
                </return>
            </javadoc>
            <method name="followLoop" type="List&lt;ComparableSegment&gt;" line="775">
                <params>
                    <param name="node" type="AVLTree&lt;ComparableSegment&gt;.Node"/>
                    <param name="sorted" type="AVLTree&lt;ComparableSegment&gt;"/>
                </params>
                <comment line="785">
                    is this an open or a closed loop ?                    
                </comment>
                <comment line="790">
                    search the sub-hyperplane starting where the previous one ended                    
                </comment>
                <comment line="809">
                    this is a degenerated loop, it probably comes from a very
                     tiny region with some segments smaller than the threshold, we
                     simply ignore it                    
                </comment>
                <comment line="822">
                    this is a degenerated infinitely thin loop, we simply ignore it                    
                </comment>
                <declaration name="loop" type="ArrayList&amp;lt;ComparableSegment&amp;gt;" line="777"/>
                <declaration name="segment" type="ComparableSegment" line="778"/>
                <declaration name="globalStart" type="Vector2D" line="780"/>
                <declaration name="end" type="Vector2D" line="781"/>
                <declaration name="open" type="boolean" line="785"/>
                <scope line="787">
                    <declaration name="selectedNode" type="AVLTree&amp;lt;ComparableSegment&amp;gt;.Node" line="790"/>
                    <declaration name="selectedSegment" type="ComparableSegment" line="791"/>
                    <declaration name="selectedDistance" type="double" line="792"/>
                    <declaration name="lowerLeft" type="ComparableSegment" line="793"/>
                    <declaration name="upperRight" type="ComparableSegment" line="794"/>
                    <scope line="797">
                        <declaration name="distance" type="double" line="799"/>
                        <scope line="800"/>
                    </scope>
                    <scope line="807"/>
                </scope>
                <scope line="820"/>
                <scope line="825"/>
            </method>
            <class name="ComparableSegment" line="833">
                <extends class="Segment"/>
                <implements interface="Comparable">
                    <type_params>
                        <type_param name="ComparableSegment"/>
                    </type_params>
                </implements>
                <javadoc line="833">
                    Private extension of Segment allowing comparison.                    
                </javadoc>
                <declaration name="sortingKey" type="OrderedTuple" line="836"/>
                <javadoc line="836">
                    Sorting key.                    
                </javadoc>
                <javadoc line="839">
                    Build a segment.                    
                    <param>
                        start start point of the segment                        
                    </param>
                    <param>
                        end end point of the segment                        
                    </param>
                    <param>
                        line line containing the segment                        
                    </param>
                </javadoc>
                <method name="ComparableSegment" type="constructor" line="844">
                    <params>
                        <param name="start" type="Vector2D"/>
                        <param name="end" type="Vector2D"/>
                        <param name="line" type="Line"/>
                    </params>
                </method>
                <javadoc line="851">
                    Build a dummy segment.
                      &lt;p&gt;
                      The object built is not a real segment, only the sorting key is used to
                      allow searching in the neighborhood of a point. This is an horrible hack ...
                      &lt;/p&gt;                    
                    <param>
                        start start point of the segment                        
                    </param>
                    <param>
                        dx abscissa offset from the start point                        
                    </param>
                    <param>
                        dy ordinate offset from the start point                        
                    </param>
                </javadoc>
                <method name="ComparableSegment" type="constructor" line="860">
                    <params>
                        <param name="start" type="Vector2D"/>
                        <param name="dx" type="double"/>
                        <param name="dy" type="double"/>
                    </params>
                </method>
                <javadoc line="865">
                    {@inheritDoc}                    
                </javadoc>
                <method name="compareTo" type="int" line="866">
                    <params>
                        <param name="o" type="ComparableSegment"/>
                    </params>
                </method>
                <javadoc line="870">
                    {@inheritDoc}                    
                </javadoc>
                <method name="equals" type="boolean" line="872">
                    <params>
                        <param name="other" type="Object"/>
                    </params>
                    <scope line="873"/>
                    <scope line="875"/>
                    <scope line="877"/>
                </method>
                <javadoc line="882">
                    {@inheritDoc}                    
                </javadoc>
                <method name="hashCode" type="int" line="884"/>
            </class>
            <class name="SegmentsBuilder" line="891">
                <implements interface="BSPTreeVisitor">
                    <type_params>
                        <type_param name="Euclidean2D"/>
                    </type_params>
                </implements>
                <javadoc line="891">
                    Visitor building segments.                    
                </javadoc>
                <declaration name="sorted" type="AVLTree&amp;lt;ComparableSegment&amp;gt;" line="894"/>
                <javadoc line="894">
                    Sorted segments.                    
                </javadoc>
                <javadoc line="897">
                    Simple constructor.                    
                </javadoc>
                <method name="SegmentsBuilder" type="constructor" line="898"/>
                <javadoc line="902">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitOrder" type="Order" line="903">
                    <params>
                        <param name="node" type="BSPTree&lt;Euclidean2D&gt;"/>
                    </params>
                </method>
                <javadoc line="907">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitInternalNode" type="void" line="908">
                    <params>
                        <param name="node" type="BSPTree&lt;Euclidean2D&gt;"/>
                    </params>
                    <declaration name="attribute" type="BoundaryAttribute&amp;lt;Euclidean2D&amp;gt;" line="909"/>
                    <scope line="911"/>
                    <scope line="914"/>
                </method>
                <javadoc line="919">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitLeafNode" type="void" line="920">
                    <params>
                        <param name="node" type="BSPTree&lt;Euclidean2D&gt;"/>
                    </params>
                </method>
                <javadoc line="923">
                    Add the contribution of a boundary facet.                    
                    <param>
                        sub boundary facet                        
                    </param>
                    <param>
                        reversed if true, the facet has the inside on its plus side                        
                    </param>
                </javadoc>
                <method name="addContribution" type="void" line="927">
                    <params>
                        <param name="sub" type="SubHyperplane&lt;Euclidean2D&gt;"/>
                        <param name="reversed" type="boolean"/>
                    </params>
                    <declaration name="absSub" type="AbstractSubHyperplane&amp;lt;Euclidean2D,Euclidean1D&amp;gt;" line="928"/>
                    <declaration name="line" type="Line" line="931"/>
                    <declaration name="intervals" type="List&amp;lt;Interval&amp;gt;" line="932"/>
                    <scope line="933">
                        <declaration name="start" type="Vector2D" line="934"/>
                        <declaration name="end" type="Vector2D" line="936"/>
                        <scope line="938"/>
                        <scope line="940"/>
                    </scope>
                </method>
                <javadoc line="946">
                    Get the sorted segments.                    
                    <return>
                        sorted segments                        
                    </return>
                </javadoc>
                <method name="getSorted" type="AVLTree&lt;ComparableSegment&gt;" line="949"/>
            </class>
        </class>
    </source>