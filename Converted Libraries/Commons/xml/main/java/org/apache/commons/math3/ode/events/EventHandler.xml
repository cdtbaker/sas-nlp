<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.ode.events">
        <interface name="EventHandler">
            <javadoc line="2">
                This interface represents a handler for discrete events triggered
                  during ODE integration.
                  &lt;p&gt;Some events can be triggered at discrete times as an ODE problem
                  is solved. This occurs for example when the integration process
                  should be stopped as some state is reached (G-stop facility) when the
                  precise date is unknown a priori, or when the derivatives have
                  discontinuities, or simply when the user wants to monitor some
                  states boundaries crossings.
                  &lt;/p&gt;
                  &lt;p&gt;These events are defined as occurring when a &lt;code&gt;g&lt;/code&gt;
                  switching function sign changes.&lt;/p&gt;
                  &lt;p&gt;Since events are only problem-dependent and are triggered by the
                  independent &lt;i&gt;time&lt;/i&gt; variable and the state vector, they can
                  occur at virtually any time, unknown in advance. The integrators will
                  take care to avoid sign changes inside the steps, they will reduce
                  the step size when such an event is detected in order to put this
                  event exactly at the end of the current step. This guarantees that
                  step interpolation (which always has a one step scope) is relevant
                  even in presence of discontinuities. This is independent from the
                  stepsize control provided by integrators that monitor the local
                  error (this event handling feature is available for all integrators,
                  including fixed step ones).&lt;/p&gt;                
                <version>
                    $Id: EventHandler.java 1451658 2013-03-01 17:36:46Z luc $                    
                </version>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="Action" type="enum" line="29"/>
            <javadoc line="29">
                Enumerate for actions to be performed when an event occurs.                
            </javadoc>
            <scope line="32"/>
            <method name="init" type="void" line="55"/>
            <javadoc line="55">
                Initialize event handler at the start of an ODE integration.
                  &lt;p&gt;
                  This method is called once at the start of the integration. It
                  may be used by the event handler to initialize some internal data
                  if needed.
                  &lt;/p&gt;                
                <param>
                    t0 start value of the independent <i>time</i> variable                    
                </param>
                <param>
                    y0 array containing the start value of the state vector                    
                </param>
                <param>
                    t target time for the integration                    
                </param>
            </javadoc>
            <method name="g" type="double" line="67"/>
            <javadoc line="67">
                Compute the value of the switching function.
                  &lt;p&gt;The discrete events are generated when the sign of this
                  switching function changes. The integrator will take care to change
                  the stepsize in such a way these events occur exactly at step boundaries.
                  The switching function must be continuous in its roots neighborhood
                  (but not necessarily smooth), as the integrator will need to find its
                  roots to locate precisely the events.&lt;/p&gt;
                  &lt;p&gt;Also note that the integrator expect that once an event has occurred,
                  the sign of the switching function at the start of the next step (i.e.
                  just after the event) is the opposite of the sign just before the event.
                  This consistency between the steps &lt;string&gt;must&lt;/strong&gt; be preserved,
                  otherwise {@link org.apache.commons.math3.exception.NoBracketingExceptionexceptions} related to root not being bracketed will occur.&lt;/p&gt;
                  &lt;p&gt;This need for consistency is sometimes tricky to achieve. A typical
                  example is using an event to model a ball bouncing on the floor. The first
                  idea to represent this would be to have {@code g(t) = h(t)} where h is the
                  height above the floor at time {@code t}. When {@code g(t)} reaches 0, the
                  ball is on the floor, so it should bounce and the typical way to do this is
                  to reverse its vertical velocity. However, this would mean that before the
                  event {@code g(t)} was decreasing from positive values to 0, and after the
                  event {@code g(t)} would be increasing from 0 to positive values again.
                  Consistency is broken here! The solution here is to have {@code g(t) = sign
                   h(t)}, where sign is a variable with initial value set to {@code +1}. Each
                  time {@link #eventOccurred(double,double[],boolean) eventOccurred} is called,{@code sign} is reset to {@code -sign}. This allows the {@code g(t)}function to remain continuous (and even smooth) even across events, despite{@code h(t)} is not. Basically, the event is used to &lt;em&gt;fold&lt;/em&gt; {@code h(t)}at bounce points, and {@code sign} is used to &lt;em&gt;unfold&lt;/em&gt; it back, so the
                  solvers sees a {@code g(t)} function which behaves smoothly even across events.&lt;/p&gt;                
                <param>
                    t current value of the independent <i>time</i> variable                    
                </param>
                <param>
                    y array containing the current value of the state vector                    
                </param>
                <return>
                    value of the g switching function                    
                </return>
            </javadoc>
            <method name="eventOccurred" type="Action" line="97"/>
            <javadoc line="97">
                Handle an event and choose what to do next.
                  &lt;p&gt;This method is called when the integrator has accepted a step
                  ending exactly on a sign change of the function, just &lt;em&gt;before&lt;/em&gt;
                  the step handler itself is called (see below for scheduling). It
                  allows the user to update his internal data to acknowledge the fact
                  the event has been handled (for example setting a flag in the {@link org.apache.commons.math3.ode.FirstOrderDifferentialEquationsdifferential equations} to switch the derivatives computation in
                  case of discontinuity), or to direct the integrator to either stop
                  or continue integration, possibly with a reset state or derivatives.&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;if {@link Action#STOP} is returned, the step handler will be called
                  with the &lt;code&gt;isLast&lt;/code&gt; flag of the {@link org.apache.commons.math3.ode.sampling.StepHandler#handleStep handleStep}method set to true and the integration will be stopped,&lt;/li&gt;
                  &lt;li&gt;if {@link Action#RESET_STATE} is returned, the {@link #resetStateresetState} method will be called once the step handler has
                  finished its task, and the integrator will also recompute the
                  derivatives,&lt;/li&gt;
                  &lt;li&gt;if {@link Action#RESET_DERIVATIVES} is returned, the integrator
                  will recompute the derivatives,
                  &lt;li&gt;if {@link Action#CONTINUE} is returned, no specific action will
                  be taken (apart from having called this method) and integration
                  will continue.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;The scheduling between this method and the {@link org.apache.commons.math3.ode.sampling.StepHandler StepHandler} method {@link org.apache.commons.math3.ode.sampling.StepHandler#handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator,boolean)handleStep(interpolator, isLast)} is to call this method first and
                  &lt;code&gt;handleStep&lt;/code&gt; afterwards. This scheduling allows the integrator to
                  pass &lt;code&gt;true&lt;/code&gt; as the &lt;code&gt;isLast&lt;/code&gt; parameter to the step
                  handler to make it aware the step will be the last one if this method
                  returns {@link Action#STOP}. As the interpolator may be used to navigate back
                  throughout the last step (as {@link org.apache.commons.math3.ode.sampling.StepNormalizer StepNormalizer}does for example), user code called by this method and user
                  code called by step handlers may experience apparently out of order values
                  of the independent time variable. As an example, if the same user object
                  implements both this {@link EventHandler EventHandler} interface and the{@link org.apache.commons.math3.ode.sampling.FixedStepHandler FixedStepHandler}interface, a &lt;em&gt;forward&lt;/em&gt; integration may call its
                  &lt;code&gt;eventOccurred&lt;/code&gt; method with t = 10 first and call its
                  &lt;code&gt;handleStep&lt;/code&gt; method with t = 9 afterwards. Such out of order
                  calls are limited to the size of the integration step for {@link org.apache.commons.math3.ode.sampling.StepHandler variable step handlers} and
                  to the size of the fixed step for {@link org.apache.commons.math3.ode.sampling.FixedStepHandler fixed step handlers}.&lt;/p&gt;                
                <param>
                    t current value of the independent <i>time</i> variable                    
                </param>
                <param>
                    y array containing the current value of the state vector                    
                </param>
                <param>
                    increasing if true, the value of the switching function increases
                      when times increases around event (note that increase is measured with respect
                      to physical time, not with respect to integration which may go backward in time)                    
                </param>
                <return>
                    indication of what the integrator should do next, this
                      value must be one of {@link Action#STOP}, {@link Action#RESET_STATE},{@link Action#RESET_DERIVATIVES} or {@link Action#CONTINUE}                    
                </return>
            </javadoc>
            <method name="resetState" type="void" line="140"/>
            <javadoc line="140">
                Reset the state prior to continue the integration.
                  &lt;p&gt;This method is called after the step handler has returned and
                  before the next step is started, but only when {@link #eventOccurred} has itself returned the {@link Action#RESET_STATE}indicator. It allows the user to reset the state vector for the
                  next step, without perturbing the step handler of the finishing
                  step. If the {@link #eventOccurred} never returns the {@link Action#RESET_STATE} indicator, this function will never be called, and it is
                  safe to leave its body empty.&lt;/p&gt;                
                <param>
                    t current value of the independent <i>time</i> variable                    
                </param>
                <param>
                    y array containing the current value of the state vector
                      the new state should be put in the same array                    
                </param>
            </javadoc>
        </interface>
    </source>