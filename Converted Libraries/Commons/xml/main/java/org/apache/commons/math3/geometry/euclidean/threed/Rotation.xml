<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.euclidean.threed">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.exception.MathArithmeticException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathArrays"/>
        <class name="Rotation" line="28">
            <implements interface="Serializable"/>
            <javadoc line="28">
                This class implements rotations in a three-dimensional space.
                  &lt;p&gt;Rotations can be represented by several different mathematical
                  entities (matrices, axe and angle, Cardan or Euler angles,
                  quaternions). This class presents an higher level abstraction, more
                  user-oriented and hiding this implementation details. Well, for the
                  curious, we use quaternions for the internal representation. The
                  user can build a rotation from any of these representations, and
                  any of these representations can be retrieved from a
                  &lt;code&gt;Rotation&lt;/code&gt; instance (see the various constructors and
                  getters). In addition, a rotation can also be built implicitly
                  from a set of vectors and their image.&lt;/p&gt;
                  &lt;p&gt;This implies that this class can be used to convert from one
                  representation to another one. For example, converting a rotation
                  matrix into a set of Cardan angles from can be done using the
                  following single line of code:&lt;/p&gt;
                  &lt;pre&gt;
                  double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);
                  &lt;/pre&gt;
                  &lt;p&gt;Focus is oriented on what a rotation &lt;em&gt;do&lt;/em&gt; rather than on its
                  underlying representation. Once it has been built, and regardless of its
                  internal representation, a rotation is an &lt;em&gt;operator&lt;/em&gt; which basically
                  transforms three dimensional {@link Vector3D vectors} into other three
                  dimensional {@link Vector3D vectors}. Depending on the application, the
                  meaning of these vectors may vary and the semantics of the rotation also.&lt;/p&gt;
                  &lt;p&gt;For example in an spacecraft attitude simulation tool, users will often
                  consider the vectors are fixed (say the Earth direction for example) and the
                  frames change. The rotation transforms the coordinates of the vector in inertial
                  frame into the coordinates of the same vector in satellite frame. In this
                  case, the rotation implicitly defines the relation between the two frames.&lt;/p&gt;
                  &lt;p&gt;Another example could be a telescope control application, where the rotation
                  would transform the sighting direction at rest into the desired observing
                  direction when the telescope is pointed towards an object of interest. In this
                  case the rotation transforms the direction at rest in a topocentric frame
                  into the sighting direction in the same topocentric frame. This implies in this
                  case the frame is fixed and the vector moves.&lt;/p&gt;
                  &lt;p&gt;In many case, both approaches will be combined. In our telescope example,
                  we will probably also need to transform the observing direction in the topocentric
                  frame into the observing direction in inertial frame taking into account the observatory
                  location and the Earth rotation, which would essentially be an application of the
                  first approach.&lt;/p&gt;
                  &lt;p&gt;These examples show that a rotation is what the user wants it to be. This
                  class does not push the user towards one specific definition and hence does not
                  provide methods like &lt;code&gt;projectVectorIntoDestinationFrame&lt;/code&gt; or
                  &lt;code&gt;computeTransformedDirection&lt;/code&gt;. It provides simpler and more generic
                  methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.&lt;/p&gt;
                  &lt;p&gt;Since a rotation is basically a vectorial operator, several rotations can be
                  composed together and the composite operation &lt;code&gt;r = r&lt;sub&gt;1&lt;/sub&gt; o
                  r&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; (which means that for each vector &lt;code&gt;u&lt;/code&gt;,
                  &lt;code&gt;r(u) = r&lt;sub&gt;1&lt;/sub&gt;(r&lt;sub&gt;2&lt;/sub&gt;(u))&lt;/code&gt;) is also a rotation. Hence
                  we can consider that in addition to vectors, a rotation can be applied to other
                  rotations as well (or to itself). With our previous notations, we would say we
                  can apply &lt;code&gt;r&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; to &lt;code&gt;r&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; and the result
                  we get is &lt;code&gt;r = r&lt;sub&gt;1&lt;/sub&gt; o r&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;. For this purpose, the
                  class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and{@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.&lt;/p&gt;
                  &lt;p&gt;Rotations are guaranteed to be immutable objects.&lt;/p&gt;                
                <version>
                    $Id: Rotation.java 1591835 2014-05-02 09:04:01Z tn $                    
                </version>
                <see>
                    Vector3D                    
                </see>
                <see>
                    RotationOrder                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="IDENTITY" type="Rotation" line="99"/>
            <javadoc line="99">
                Identity rotation.                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="102"/>
            <javadoc line="102">
                Serializable version identifier                
            </javadoc>
            <declaration name="q0" type="double" line="105"/>
            <javadoc line="105">
                Scalar coordinate of the quaternion.                
            </javadoc>
            <declaration name="q1" type="double" line="108"/>
            <javadoc line="108">
                First coordinate of the vectorial part of the quaternion.                
            </javadoc>
            <declaration name="q2" type="double" line="111"/>
            <javadoc line="111">
                Second coordinate of the vectorial part of the quaternion.                
            </javadoc>
            <declaration name="q3" type="double" line="114"/>
            <javadoc line="114">
                Third coordinate of the vectorial part of the quaternion.                
            </javadoc>
            <javadoc line="117">
                Build a rotation from the quaternion coordinates.
                  &lt;p&gt;A rotation can be built from a &lt;em&gt;normalized&lt;/em&gt; quaternion,
                  i.e. a quaternion for which q&lt;sub&gt;0&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
                  q&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; + q&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
                  q&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. If the quaternion is not normalized,
                  the constructor can normalize it in a preprocessing step.&lt;/p&gt;
                  &lt;p&gt;Note that some conventions put the scalar part of the quaternion
                  as the 4&lt;sup&gt;th&lt;/sup&gt; component and the vector part as the first three
                  components. This is &lt;em&gt;not&lt;/em&gt; our convention. We put the scalar part
                  as the first component.&lt;/p&gt;                
                <param>
                    q0 scalar part of the quaternion                    
                </param>
                <param>
                    q1 first coordinate of the vectorial part of the quaternion                    
                </param>
                <param>
                    q2 second coordinate of the vectorial part of the quaternion                    
                </param>
                <param>
                    q3 third coordinate of the vectorial part of the quaternion                    
                </param>
                <param>
                    needsNormalization if true, the coordinates are considered
                      not to be normalized, a normalization preprocessing step is performed
                      before using them                    
                </param>
            </javadoc>
            <method name="Rotation" type="constructor" line="136">
                <params>
                    <param name="q0" type="double"/>
                    <param name="q1" type="double"/>
                    <param name="q2" type="double"/>
                    <param name="q3" type="double"/>
                    <param name="needsNormalization" type="boolean"/>
                </params>
                <comment line="140">
                    normalization preprocessing                    
                </comment>
                <scope line="138">
                    <declaration name="inv" type="double" line="140"/>
                </scope>
            </method>
            <javadoc line="154">
                Build a rotation from an axis and an angle.
                  &lt;p&gt;We use the convention that angles are oriented according to
                  the effect of the rotation on vectors around the axis. That means
                  that if (i, j, k) is a direct frame and if we first provide +k as
                  the axis and &amp;pi;/2 as the angle to this constructor, and then{@link #applyTo(Vector3D) apply} the instance to +i, we will get
                  +j.&lt;/p&gt;
                  &lt;p&gt;Another way to represent our convention is to say that a rotation
                  of angle &amp;theta; about the unit vector (x, y, z) is the same as the
                  rotation build from quaternion components { cos(-&amp;theta;/2),
                  x  sin(-&amp;theta;/2), y  sin(-&amp;theta;/2), z  sin(-&amp;theta;/2) }.
                  Note the minus sign on the angle!&lt;/p&gt;
                  &lt;p&gt;On the one hand this convention is consistent with a vectorial
                  perspective (moving vectors in fixed frames), on the other hand it
                  is different from conventions with a frame perspective (fixed vectors
                  viewed from different frames) like the ones used for example in spacecraft
                  attitude community or in the graphics community.&lt;/p&gt;                
                <param>
                    axis axis around which to rotate                    
                </param>
                <param>
                    angle rotation angle.                    
                </param>
                <exception>
                    MathIllegalArgumentException if the axis norm is zero                    
                </exception>
            </javadoc>
            <method name="Rotation" type="constructor" line="175">
                <params>
                    <param name="axis" type="Vector3D"/>
                    <param name="angle" type="double"/>
                </params>
                <declaration name="norm" type="double" line="177"/>
                <scope line="178"/>
                <declaration name="halfAngle" type="double" line="182"/>
                <declaration name="coeff" type="double" line="183"/>
            </method>
            <javadoc line="192">
                Build a rotation from a 3X3 matrix.
                  &lt;p&gt;Rotation matrices are orthogonal matrices, i.e. unit matrices
                  (which are matrices for which m.m&lt;sup&gt;T&lt;/sup&gt; = I) with real
                  coefficients. The module of the determinant of unit matrices is
                  1, among the orthogonal 3X3 matrices, only the ones having a
                  positive determinant (+1) are rotation matrices.&lt;/p&gt;
                  &lt;p&gt;When a rotation is defined by a matrix with truncated values
                  (typically when it is extracted from a technical sheet where only
                  four to five significant digits are available), the matrix is not
                  orthogonal anymore. This constructor handles this case
                  transparently by using a copy of the given matrix and applying a
                  correction to the copy in order to perfect its orthogonality. If
                  the Frobenius norm of the correction needed is above the given
                  threshold, then the matrix is considered to be too far from a
                  true rotation matrix and an exception is thrown.&lt;p&gt;                
                <param>
                    m rotation matrix                    
                </param>
                <param>
                    threshold convergence threshold for the iterative
                      orthogonality correction (convergence is reached when the
                      difference between two steps of the Frobenius norm of the
                      correction is below this threshold)                    
                </param>
                <exception>
                    NotARotationMatrixException if the matrix is not a 3X3
                      matrix, or if it cannot be transformed into an orthogonal matrix
                      with the given threshold, or if the determinant of the resulting
                      orthogonal matrix is negative                    
                </exception>
            </javadoc>
            <method name="Rotation" type="constructor" line="223">
                <params>
                    <param name="m" type="double[][]"/>
                    <param name="threshold" type="double"/>
                </params>
                <comment line="226">
                    dimension check                    
                </comment>
                <comment line="234">
                    compute a &quot;close&quot; orthogonal matrix                    
                </comment>
                <comment line="237">
                    check the sign of the determinant                    
                </comment>
                <scope line="227"/>
                <declaration name="ort" type="double[][]" line="234"/>
                <declaration name="det" type="double" line="237"/>
                <scope line="240"/>
                <declaration name="quat" type="double[]" line="246"/>
            </method>
            <javadoc line="254">
                Build the rotation that transforms a pair of vector into another pair.
                  &lt;p&gt;Except for possible scale factors, if the instance were applied to
                  the pair (u&lt;sub&gt;1&lt;/sub&gt;, u&lt;sub&gt;2&lt;/sub&gt;) it will produce the pair
                  (v&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;).&lt;/p&gt;
                  &lt;p&gt;If the angular separation between u&lt;sub&gt;1&lt;/sub&gt; and u&lt;sub&gt;2&lt;/sub&gt; is
                  not the same as the angular separation between v&lt;sub&gt;1&lt;/sub&gt; and
                  v&lt;sub&gt;2&lt;/sub&gt;, then a corrected v&apos;&lt;sub&gt;2&lt;/sub&gt; will be used rather than
                  v&lt;sub&gt;2&lt;/sub&gt;, the corrected vector will be in the (v&lt;sub&gt;1&lt;/sub&gt;,
                  v&lt;sub&gt;2&lt;/sub&gt;) plane.&lt;/p&gt;                
                <param>
                    u1 first vector of the origin pair                    
                </param>
                <param>
                    u2 second vector of the origin pair                    
                </param>
                <param>
                    v1 desired image of u1 by the rotation                    
                </param>
                <param>
                    v2 desired image of u2 by the rotation                    
                </param>
                <exception>
                    MathArithmeticException if the norm of one of the vectors is zero,
                      or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)                    
                </exception>
            </javadoc>
            <method name="Rotation" type="constructor" line="274">
                <params>
                    <param name="u1" type="Vector3D"/>
                    <param name="u2" type="Vector3D"/>
                    <param name="v1" type="Vector3D"/>
                    <param name="v2" type="Vector3D"/>
                </params>
                <comment line="277">
                    build orthonormalized base from u1, u2
                     this fails when vectors are null or colinear, which is forbidden to define a rotation                    
                </comment>
                <comment line="283">
                    build an orthonormalized base from v1, v2
                     this fails when vectors are null or colinear, which is forbidden to define a rotation                    
                </comment>
                <comment line="289">
                    buid a matrix transforming the first base into the second one                    
                </comment>
                <declaration name="u3" type="Vector3D" line="278"/>
                <declaration name="v3" type="Vector3D" line="284"/>
                <declaration name="m" type="double[][]" line="289"/>
                <declaration name="quat" type="double[]" line="307"/>
            </method>
            <javadoc line="315">
                Build one of the rotations that transform one vector into another one.
                  &lt;p&gt;Except for a possible scale factor, if the instance were
                  applied to the vector u it will produce the vector v. There is an
                  infinite number of such rotations, this constructor choose the
                  one with the smallest associated angle (i.e. the one whose axis
                  is orthogonal to the (u, v) plane). If u and v are colinear, an
                  arbitrary rotation axis is chosen.&lt;/p&gt;                
                <param>
                    u origin vector                    
                </param>
                <param>
                    v desired image of u by the rotation                    
                </param>
                <exception>
                    MathArithmeticException if the norm of one of the vectors is zero                    
                </exception>
            </javadoc>
            <method name="Rotation" type="constructor" line="328">
                <params>
                    <param name="u" type="Vector3D"/>
                    <param name="v" type="Vector3D"/>
                </params>
                <comment line="339">
                    special case u = -v: we select a PI angle rotation around
                     an arbitrary vector orthogonal to u                    
                </comment>
                <comment line="347">
                    general case: (u, v) defines a plane, we select
                     the shortest possible rotation: axis orthogonal to this plane                    
                </comment>
                <declaration name="normProduct" type="double" line="330"/>
                <scope line="331"/>
                <declaration name="dot" type="double" line="335"/>
                <scope line="337">
                    <declaration name="w" type="Vector3D" line="340"/>
                </scope>
                <scope line="345">
                    <declaration name="coeff" type="double" line="349"/>
                    <declaration name="q" type="Vector3D" line="350"/>
                </scope>
            </method>
            <javadoc line="358">
                Build a rotation from three Cardan or Euler elementary rotations.
                  &lt;p&gt;Cardan rotations are three successive rotations around the
                  canonical axes X, Y and Z, each axis being used once. There are
                  6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
                  rotations are three successive rotations around the canonical
                  axes X, Y and Z, the first and last rotations being around the
                  same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
                  YZY, ZXZ and ZYZ), the most popular one being ZXZ.&lt;/p&gt;
                  &lt;p&gt;Beware that many people routinely use the term Euler angles even
                  for what really are Cardan angles (this confusion is especially
                  widespread in the aerospace business where Roll, Pitch and Yaw angles
                  are often wrongly tagged as Euler angles).&lt;/p&gt;                
                <param>
                    order order of rotations to use                    
                </param>
                <param>
                    alpha1 angle of the first elementary rotation                    
                </param>
                <param>
                    alpha2 angle of the second elementary rotation                    
                </param>
                <param>
                    alpha3 angle of the third elementary rotation                    
                </param>
            </javadoc>
            <method name="Rotation" type="constructor" line="378">
                <params>
                    <param name="order" type="RotationOrder"/>
                    <param name="alpha1" type="double"/>
                    <param name="alpha2" type="double"/>
                    <param name="alpha3" type="double"/>
                </params>
                <declaration name="r1" type="Rotation" line="379"/>
                <declaration name="r2" type="Rotation" line="380"/>
                <declaration name="r3" type="Rotation" line="381"/>
                <declaration name="composed" type="Rotation" line="382"/>
            </method>
            <javadoc line="389">
                Convert an orthogonal rotation matrix to a quaternion.                
                <param>
                    ort orthogonal rotation matrix                    
                </param>
                <return>
                    quaternion corresponding to the matrix                    
                </return>
            </javadoc>
            <method name="mat2quat" type="double[]" line="393">
                <params>
                    <param name="ort" type="double[][]"/>
                </params>
                <comment line="398">
                    There are different ways to compute the quaternions elements
                     from the matrix. They all involve computing one element from
                     the diagonal of the matrix, and computing the three other ones
                     using a formula involving a division by the first element,
                     which unfortunately can be zero. Since the norm of the
                     quaternion is 1, we know at least one element has an absolute
                     value greater or equal to 0.5, so it is always possible to
                     select the right formula and avoid division by zero and even
                     numerical inaccuracy. Checking the elements in turn and using
                     the first one greater than 0.45 is safe (this leads to a simple
                     test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)                    
                </comment>
                <comment line="411">
                    compute q0 and deduce q1, q2 and q3                    
                </comment>
                <comment line="420">
                    compute q1 and deduce q0, q2 and q3                    
                </comment>
                <comment line="429">
                    compute q2 and deduce q0, q1 and q3                    
                </comment>
                <comment line="436">
                    compute q3 and deduce q0, q1 and q2                    
                </comment>
                <declaration name="quat" type="double[]" line="395"/>
                <declaration name="s" type="double" line="408"/>
                <scope line="409">
                    <declaration name="inv" type="double" line="412"/>
                </scope>
                <scope line="416">
                    <scope line="418">
                        <declaration name="inv" type="double" line="421"/>
                    </scope>
                    <scope line="425">
                        <scope line="427">
                            <declaration name="inv" type="double" line="430"/>
                        </scope>
                        <scope line="434">
                            <declaration name="inv" type="double" line="438"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="450">
                Revert a rotation.
                  Build a rotation which reverse the effect of another
                  rotation. This means that if r(u) = v, then r.revert(v) = u. The
                  instance is not changed.                
                <return>
                    a new rotation whose effect is the reverse of the effect
                      of the instance                    
                </return>
            </javadoc>
            <method name="revert" type="Rotation" line="457"/>
            <javadoc line="461">
                Get the scalar coordinate of the quaternion.                
                <return>
                    scalar coordinate of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ0" type="double" line="464"/>
            <javadoc line="468">
                Get the first coordinate of the vectorial part of the quaternion.                
                <return>
                    first coordinate of the vectorial part of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ1" type="double" line="471"/>
            <javadoc line="475">
                Get the second coordinate of the vectorial part of the quaternion.                
                <return>
                    second coordinate of the vectorial part of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ2" type="double" line="478"/>
            <javadoc line="482">
                Get the third coordinate of the vectorial part of the quaternion.                
                <return>
                    third coordinate of the vectorial part of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ3" type="double" line="485"/>
            <javadoc line="489">
                Get the normalized axis of the rotation.                
                <return>
                    normalized axis of the rotation                    
                </return>
                <see>
                    #Rotation(Vector3D,double)                    
                </see>
            </javadoc>
            <method name="getAxis" type="Vector3D" line="493">
                <declaration name="squaredSine" type="double" line="494"/>
                <scope line="495"/>
                <scope line="497">
                    <declaration name="inverse" type="double" line="498"/>
                </scope>
                <declaration name="inverse" type="double" line="501"/>
            </method>
            <javadoc line="505">
                Get the angle of the rotation.                
                <return>
                    angle of the rotation (between 0 and &amp;pi;)                    
                </return>
                <see>
                    #Rotation(Vector3D,double)                    
                </see>
            </javadoc>
            <method name="getAngle" type="double" line="509">
                <scope line="510"/>
                <scope line="512"/>
            </method>
            <javadoc line="518">
                Get the Cardan or Euler angles corresponding to the instance.
                  &lt;p&gt;The equations show that each rotation can be defined by two
                  different values of the Cardan or Euler angles set. For example
                  if Cardan angles are used, the rotation defined by the angles
                  a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt; and a&lt;sub&gt;3&lt;/sub&gt; is the same as
                  the rotation defined by the angles &amp;pi; + a&lt;sub&gt;1&lt;/sub&gt;, &amp;pi;
                  - a&lt;sub&gt;2&lt;/sub&gt; and &amp;pi; + a&lt;sub&gt;3&lt;/sub&gt;. This method implements
                  the following arbitrary choices:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;for Cardan angles, the chosen set is the one for which the
                  second angle is between -&amp;pi;/2 and &amp;pi;/2 (i.e its cosine is
                  positive),&lt;/li&gt;
                  &lt;li&gt;for Euler angles, the chosen set is the one for which the
                  second angle is between 0 and &amp;pi; (i.e its sine is positive).&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Cardan and Euler angle have a very disappointing drawback: all
                  of them have singularities. This means that if the instance is
                  too close to the singularities corresponding to the given
                  rotation order, it will be impossible to retrieve the angles. For
                  Cardan angles, this is often called gimbal lock. There is
                  &lt;em&gt;nothing&lt;/em&gt; to do to prevent this, it is an intrinsic problem
                  with Cardan and Euler representation (but not a problem with the
                  rotation itself, which is perfectly well defined). For Cardan
                  angles, singularities occur when the second angle is close to
                  -&amp;pi;/2 or +&amp;pi;/2, for Euler angle singularities occur when the
                  second angle is close to 0 or &amp;pi;, this implies that the identity
                  rotation is always singular for Euler angles!&lt;/p&gt;                
                <param>
                    order rotation order to use                    
                </param>
                <return>
                    an array of three angles, in the order specified by the set                    
                </return>
                <exception>
                    CardanEulerSingularityException if the rotation is
                      singular with respect to the angles set specified                    
                </exception>
            </javadoc>
            <method name="getAngles" type="double[]" line="554">
                <params>
                    <param name="order" type="RotationOrder"/>
                </params>
                <comment line="559">
                    r (Vector3D.plusK) coordinates are :
                      sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
                     (-r) (Vector3D.plusI) coordinates are :
                     cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
                     and we can choose to have theta in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="577">
                    r (Vector3D.plusJ) coordinates are :
                     -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
                     (-r) (Vector3D.plusI) coordinates are :
                     cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
                     and we can choose to have psi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="595">
                    r (Vector3D.plusK) coordinates are :
                      cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
                     (-r) (Vector3D.plusJ) coordinates are :
                     sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
                     and we can choose to have phi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="613">
                    r (Vector3D.plusI) coordinates are :
                     cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
                     (-r) (Vector3D.plusJ) coordinates are :
                     sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
                     and we can choose to have psi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="631">
                    r (Vector3D.plusJ) coordinates are :
                     -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
                     (-r) (Vector3D.plusK) coordinates are :
                     -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
                     and we can choose to have phi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="649">
                    r (Vector3D.plusI) coordinates are :
                      cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
                     (-r) (Vector3D.plusK) coordinates are :
                     -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
                     and we can choose to have theta in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="667">
                    r (Vector3D.plusI) coordinates are :
                      cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
                     (-r) (Vector3D.plusI) coordinates are :
                     cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
                     and we can choose to have theta in the interval [0 ; PI]                    
                </comment>
                <comment line="685">
                    r (Vector3D.plusI) coordinates are :
                      cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
                     (-r) (Vector3D.plusI) coordinates are :
                     cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
                     and we can choose to have psi in the interval [0 ; PI]                    
                </comment>
                <comment line="703">
                    r (Vector3D.plusJ) coordinates are :
                      sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
                     (-r) (Vector3D.plusJ) coordinates are :
                     sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
                     and we can choose to have phi in the interval [0 ; PI]                    
                </comment>
                <comment line="721">
                    r (Vector3D.plusJ) coordinates are :
                      -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
                     (-r) (Vector3D.plusJ) coordinates are :
                     sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
                     and we can choose to have psi in the interval [0 ; PI]                    
                </comment>
                <comment line="739">
                    r (Vector3D.plusK) coordinates are :
                      sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
                     (-r) (Vector3D.plusK) coordinates are :
                     sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
                     and we can choose to have phi in the interval [0 ; PI]                    
                </comment>
                <comment line="755">
                    last possibility is ZYZ                    
                </comment>
                <comment line="757">
                    r (Vector3D.plusK) coordinates are :
                      cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
                     (-r) (Vector3D.plusK) coordinates are :
                     -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
                     and we can choose to have theta in the interval [0 ; PI]                    
                </comment>
                <scope line="556">
                    <declaration name="v1" type="Vector3D" line="563"/>
                    <declaration name="v2" type="Vector3D" line="564"/>
                    <scope line="565"/>
                </scope>
                <scope line="574">
                    <declaration name="v1" type="Vector3D" line="581"/>
                    <declaration name="v2" type="Vector3D" line="582"/>
                    <scope line="583"/>
                </scope>
                <scope line="592">
                    <declaration name="v1" type="Vector3D" line="599"/>
                    <declaration name="v2" type="Vector3D" line="600"/>
                    <scope line="601"/>
                </scope>
                <scope line="610">
                    <declaration name="v1" type="Vector3D" line="617"/>
                    <declaration name="v2" type="Vector3D" line="618"/>
                    <scope line="619"/>
                </scope>
                <scope line="628">
                    <declaration name="v1" type="Vector3D" line="635"/>
                    <declaration name="v2" type="Vector3D" line="636"/>
                    <scope line="637"/>
                </scope>
                <scope line="646">
                    <declaration name="v1" type="Vector3D" line="653"/>
                    <declaration name="v2" type="Vector3D" line="654"/>
                    <scope line="655"/>
                </scope>
                <scope line="664">
                    <declaration name="v1" type="Vector3D" line="671"/>
                    <declaration name="v2" type="Vector3D" line="672"/>
                    <scope line="673"/>
                </scope>
                <scope line="682">
                    <declaration name="v1" type="Vector3D" line="689"/>
                    <declaration name="v2" type="Vector3D" line="690"/>
                    <scope line="691"/>
                </scope>
                <scope line="700">
                    <declaration name="v1" type="Vector3D" line="707"/>
                    <declaration name="v2" type="Vector3D" line="708"/>
                    <scope line="709"/>
                </scope>
                <scope line="718">
                    <declaration name="v1" type="Vector3D" line="725"/>
                    <declaration name="v2" type="Vector3D" line="726"/>
                    <scope line="727"/>
                </scope>
                <scope line="736">
                    <declaration name="v1" type="Vector3D" line="743"/>
                    <declaration name="v2" type="Vector3D" line="744"/>
                    <scope line="745"/>
                </scope>
                <scope line="754">
                    <declaration name="v1" type="Vector3D" line="761"/>
                    <declaration name="v2" type="Vector3D" line="762"/>
                    <scope line="763"/>
                </scope>
            </method>
            <javadoc line="776">
                Get the 3X3 matrix corresponding to the instance                
                <return>
                    the matrix corresponding to the instance                    
                </return>
            </javadoc>
            <method name="getMatrix" type="double[][]" line="779">
                <comment line="782">
                    products                    
                </comment>
                <comment line="794">
                    create the matrix                    
                </comment>
                <declaration name="q0q0" type="double" line="782"/>
                <declaration name="q0q1" type="double" line="783"/>
                <declaration name="q0q2" type="double" line="784"/>
                <declaration name="q0q3" type="double" line="785"/>
                <declaration name="q1q1" type="double" line="786"/>
                <declaration name="q1q2" type="double" line="787"/>
                <declaration name="q1q3" type="double" line="788"/>
                <declaration name="q2q2" type="double" line="789"/>
                <declaration name="q2q3" type="double" line="790"/>
                <declaration name="q3q3" type="double" line="791"/>
                <declaration name="m" type="double[][]" line="794"/>
            </method>
            <javadoc line="815">
                Apply the rotation to a vector.                
                <param>
                    u vector to apply the rotation to                    
                </param>
                <return>
                    a new vector which is the image of u by the rotation                    
                </return>
            </javadoc>
            <method name="applyTo" type="Vector3D" line="819">
                <params>
                    <param name="u" type="Vector3D"/>
                </params>
                <declaration name="x" type="double" line="821"/>
                <declaration name="y" type="double" line="822"/>
                <declaration name="z" type="double" line="823"/>
                <declaration name="s" type="double" line="825"/>
            </method>
            <javadoc line="833">
                Apply the rotation to a vector stored in an array.                
                <param>
                    in an array with three items which stores vector to rotate                    
                </param>
                <param>
                    out an array with three items to put result to (it can be the same
                      array as in)                    
                </param>
            </javadoc>
            <method name="applyTo" type="void" line="838">
                <params>
                    <param name="in" type="double[]"/>
                    <param name="out" type="double[]"/>
                </params>
                <declaration name="x" type="double" line="840"/>
                <declaration name="y" type="double" line="841"/>
                <declaration name="z" type="double" line="842"/>
                <declaration name="s" type="double" line="844"/>
            </method>
            <javadoc line="852">
                Apply the inverse of the rotation to a vector.                
                <param>
                    u vector to apply the inverse of the rotation to                    
                </param>
                <return>
                    a new vector which such that u is its image by the rotation                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="Vector3D" line="856">
                <params>
                    <param name="u" type="Vector3D"/>
                </params>
                <declaration name="x" type="double" line="858"/>
                <declaration name="y" type="double" line="859"/>
                <declaration name="z" type="double" line="860"/>
                <declaration name="s" type="double" line="862"/>
                <declaration name="m0" type="double" line="863"/>
            </method>
            <javadoc line="871">
                Apply the inverse of the rotation to a vector stored in an array.                
                <param>
                    in an array with three items which stores vector to rotate                    
                </param>
                <param>
                    out an array with three items to put result to (it can be the same
                      array as in)                    
                </param>
            </javadoc>
            <method name="applyInverseTo" type="void" line="876">
                <params>
                    <param name="in" type="double[]"/>
                    <param name="out" type="double[]"/>
                </params>
                <declaration name="x" type="double" line="878"/>
                <declaration name="y" type="double" line="879"/>
                <declaration name="z" type="double" line="880"/>
                <declaration name="s" type="double" line="882"/>
                <declaration name="m0" type="double" line="883"/>
            </method>
            <javadoc line="891">
                Apply the instance to another rotation.
                  Applying the instance to a rotation is computing the composition
                  in an order compliant with the following rule : let u be any
                  vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
                  of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
                  where comp = applyTo(r).                
                <param>
                    r rotation to apply the rotation to                    
                </param>
                <return>
                    a new rotation which is the composition of r by the instance                    
                </return>
            </javadoc>
            <method name="applyTo" type="Rotation" line="900">
                <params>
                    <param name="r" type="Rotation"/>
                </params>
            </method>
            <javadoc line="908">
                Apply the inverse of the instance to another rotation.
                  Applying the inverse of the instance to a rotation is computing
                  the composition in an order compliant with the following rule :
                  let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
                  let w be the inverse image of v by the instance
                  (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
                  comp = applyInverseTo(r).                
                <param>
                    r rotation to apply the rotation to                    
                </param>
                <return>
                    a new rotation which is the composition of r by the inverse
                      of the instance                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="Rotation" line="919">
                <params>
                    <param name="r" type="Rotation"/>
                </params>
            </method>
            <javadoc line="927">
                Perfect orthogonality on a 3X3 matrix.                
                <param>
                    m initial matrix (not exactly orthogonal)                    
                </param>
                <param>
                    threshold convergence threshold for the iterative
                      orthogonality correction (convergence is reached when the
                      difference between two steps of the Frobenius norm of the
                      correction is below this threshold)                    
                </param>
                <return>
                    an orthogonal matrix close to m                    
                </return>
                <exception>
                    NotARotationMatrixException if the matrix cannot be
                      orthogonalized with the given threshold after 10 iterations                    
                </exception>
            </javadoc>
            <method name="orthogonalizeMatrix" type="double[][]" line="938">
                <params>
                    <param name="m" type="double[][]"/>
                    <param name="threshold" type="double"/>
                </params>
                <comment line="960">
                    iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)                    
                </comment>
                <comment line="964">
                    Mt.Xn                    
                </comment>
                <comment line="975">
                    Xn+1                    
                </comment>
                <comment line="986">
                    correction on each elements                    
                </comment>
                <comment line="997">
                    Frobenius norm of the correction                    
                </comment>
                <comment line="1002">
                    convergence test                    
                </comment>
                <comment line="1007">
                    prepare next iteration                    
                </comment>
                <comment line="1021">
                    the algorithm did not converge after 10 iterations                    
                </comment>
                <declaration name="m0" type="double[]" line="939"/>
                <declaration name="m1" type="double[]" line="940"/>
                <declaration name="m2" type="double[]" line="941"/>
                <declaration name="x00" type="double" line="942"/>
                <declaration name="x01" type="double" line="943"/>
                <declaration name="x02" type="double" line="944"/>
                <declaration name="x10" type="double" line="945"/>
                <declaration name="x11" type="double" line="946"/>
                <declaration name="x12" type="double" line="947"/>
                <declaration name="x20" type="double" line="948"/>
                <declaration name="x21" type="double" line="949"/>
                <declaration name="x22" type="double" line="950"/>
                <declaration name="fn" type="double" line="951"/>
                <declaration name="fn1" type="double" line="952"/>
                <declaration name="o" type="double[][]" line="954"/>
                <declaration name="o0" type="double[]" line="955"/>
                <declaration name="o1" type="double[]" line="956"/>
                <declaration name="o2" type="double[]" line="957"/>
                <declaration name="i" type="int" line="960"/>
                <scope line="961">
                    <declaration name="mx00" type="double" line="964"/>
                    <declaration name="mx10" type="double" line="965"/>
                    <declaration name="mx20" type="double" line="966"/>
                    <declaration name="mx01" type="double" line="967"/>
                    <declaration name="mx11" type="double" line="968"/>
                    <declaration name="mx21" type="double" line="969"/>
                    <declaration name="mx02" type="double" line="970"/>
                    <declaration name="mx12" type="double" line="971"/>
                    <declaration name="mx22" type="double" line="972"/>
                    <declaration name="corr00" type="double" line="986"/>
                    <declaration name="corr01" type="double" line="987"/>
                    <declaration name="corr02" type="double" line="988"/>
                    <declaration name="corr10" type="double" line="989"/>
                    <declaration name="corr11" type="double" line="990"/>
                    <declaration name="corr12" type="double" line="991"/>
                    <declaration name="corr20" type="double" line="992"/>
                    <declaration name="corr21" type="double" line="993"/>
                    <declaration name="corr22" type="double" line="994"/>
                    <scope line="1002"/>
                </scope>
            </method>
            <javadoc line="1026">
                Compute the &lt;i&gt;distance&lt;/i&gt; between two rotations.
                  &lt;p&gt;The &lt;i&gt;distance&lt;/i&gt; is intended here as a way to check if two
                  rotations are almost similar (i.e. they transform vectors the same way)
                  or very different. It is mathematically defined as the angle of
                  the rotation r that prepended to one of the rotations gives the other
                  one:&lt;/p&gt;
                  &lt;pre&gt;
                  r&lt;sub&gt;1&lt;/sub&gt;(r) = r&lt;sub&gt;2&lt;/sub&gt;
                  &lt;/pre&gt;
                  &lt;p&gt;This distance is an angle between 0 and &amp;pi;. Its value is the smallest
                  possible upper bound of the angle in radians between r&lt;sub&gt;1&lt;/sub&gt;(v)
                  and r&lt;sub&gt;2&lt;/sub&gt;(v) for all possible vectors v. This upper bound is
                  reached for some v. The distance is equal to 0 if and only if the two
                  rotations are identical.&lt;/p&gt;
                  &lt;p&gt;Comparing two rotations should always be done using this value rather
                  than for example comparing the components of the quaternions. It is much
                  more stable, and has a geometric meaning. Also comparing quaternions
                  components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
                  and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
                  their components are different (they are exact opposites).&lt;/p&gt;                
                <param>
                    r1 first rotation                    
                </param>
                <param>
                    r2 second rotation                    
                </param>
                <return>
                    &lt;i&gt;distance&lt;/i&gt; between r1 and r2                    
                </return>
            </javadoc>
            <method name="distance" type="double" line="1050">
                <params>
                    <param name="r1" type="Rotation"/>
                    <param name="r2" type="Rotation"/>
                </params>
            </method>
        </class>
    </source>