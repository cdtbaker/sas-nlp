<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.complex">
        <import package="java.io.Serializable"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.FieldElement"/>
        <import package="org.apache.commons.math3.exception.NotPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <class name="Complex" line="32">
            <comment line="62">
                CHECKSTYLE: stop ConstantName                
            </comment>
            <comment line="65">
                CHECKSTYLE: resume ConstantName                
            </comment>
            <implements interface="FieldElement">
                <type_params>
                    <type_param name="Complex"/>
                </type_params>
            </implements>
            <implements interface="Serializable"/>
            <javadoc line="32">
                Representation of a Complex number, i.e. a number which has both a
                  real and imaginary part.
                  &lt;br/&gt;
                  Implementations of arithmetic operations handle {@code NaN} and
                  infinite values according to the rules for {@link java.lang.Double}, i.e.{@link #equals} is an equivalence relation for all instances that have
                  a {@code NaN} in either real or imaginary part, e.g. the following are
                  considered equal:
                  &lt;ul&gt;
                  &lt;li&gt;{@code 1 + NaNi}&lt;/li&gt;
                  &lt;li&gt;{@code NaN + i}&lt;/li&gt;
                  &lt;li&gt;{@code NaN + NaNi}&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that this is in contradiction with the IEEE-754 standard for floating
                  point numbers (according to which the test {@code x == x} must fail if{@code x} is {@code NaN}). The method{@link org.apache.commons.math3.util.Precision#equals(double,double,int)equals for primitive double} in {@link org.apache.commons.math3.util.Precision}conforms with IEEE-754 while this class conforms with the standard behavior
                  for Java object types.
                  &lt;br/&gt;
                  Implements Serializable since 2.0                
                <version>
                    $Id: Complex.java 1591835 2014-05-02 09:04:01Z tn $                    
                </version>
            </javadoc>
            <declaration name="I" type="Complex" line="59"/>
            <javadoc line="59">
                The square root of -1. A number representing &quot;0.0 + 1.0i&quot;                
            </javadoc>
            <declaration name="NaN" type="Complex" line="62"/>
            <javadoc line="62">
                A complex number representing &quot;NaN + NaNi&quot;                
            </javadoc>
            <declaration name="INF" type="Complex" line="65"/>
            <javadoc line="65">
                A complex number representing &quot;+INF + INFi&quot;                
            </javadoc>
            <declaration name="ONE" type="Complex" line="67"/>
            <javadoc line="67">
                A complex number representing &quot;1.0 + 0.0i&quot;                
            </javadoc>
            <declaration name="ZERO" type="Complex" line="69"/>
            <javadoc line="69">
                A complex number representing &quot;0.0 + 0.0i&quot;                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="72"/>
            <javadoc line="72">
                Serializable version identifier                
            </javadoc>
            <declaration name="imaginary" type="double" line="75"/>
            <javadoc line="75">
                The imaginary part.                
            </javadoc>
            <declaration name="real" type="double" line="77"/>
            <javadoc line="77">
                The real part.                
            </javadoc>
            <declaration name="isNaN" type="boolean" line="79"/>
            <javadoc line="79">
                Record whether this complex number is equal to NaN.                
            </javadoc>
            <declaration name="isInfinite" type="boolean" line="81"/>
            <javadoc line="81">
                Record whether this complex number is infinite.                
            </javadoc>
            <javadoc line="84">
                Create a complex number given only the real part.                
                <param>
                    real Real part.                    
                </param>
            </javadoc>
            <method name="Complex" type="constructor" line="89">
                <params>
                    <param name="real" type="double"/>
                </params>
            </method>
            <javadoc line="93">
                Create a complex number given the real and imaginary parts.                
                <param>
                    real Real part.                    
                </param>
                <param>
                    imaginary Imaginary part.                    
                </param>
            </javadoc>
            <method name="Complex" type="constructor" line="99">
                <params>
                    <param name="real" type="double"/>
                    <param name="imaginary" type="double"/>
                </params>
            </method>
            <javadoc line="108">
                Return the absolute value of this complex number.
                  Returns {@code NaN} if either real or imaginary part is {@code NaN}and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
                  but at least one part is infinite.                
                <return>
                    the absolute value.                    
                </return>
            </javadoc>
            <method name="abs" type="double" line="116">
                <scope line="117"/>
                <scope line="120"/>
                <scope line="123">
                    <scope line="124"/>
                    <declaration name="q" type="double" line="127"/>
                </scope>
                <scope line="129">
                    <scope line="130"/>
                    <declaration name="q" type="double" line="133"/>
                </scope>
            </method>
            <javadoc line="138">
                Returns a {@code Complex} whose value is{@code (this + addend)}.
                  Uses the definitional formula
                  &lt;pre&gt;
                  &lt;code&gt;
                  (a + bi) + (c + di) = (a+c) + (b+d)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  &lt;br/&gt;
                  If either {@code this} or {@code addend} has a {@code NaN} value in
                  either part, {@link #NaN} is returned; otherwise {@code Infinite}and {@code NaN} values are returned in the parts of the result
                  according to the rules for {@link java.lang.Double} arithmetic.                
                <param>
                    addend Value to be added to this {@code Complex}.                    
                </param>
                <return>
                    {@code this + addend}.                    
                </return>
                <throws>
                    NullArgumentException if {@code addend} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="add" type="Complex" line="157">
                <params>
                    <param name="addend" type="Complex"/>
                </params>
                <scope line="159"/>
            </method>
            <javadoc line="167">
                Returns a {@code Complex} whose value is {@code (this + addend)},
                  with {@code addend} interpreted as a real number.                
                <param>
                    addend Value to be added to this {@code Complex}.                    
                </param>
                <return>
                    {@code this + addend}.                    
                </return>
                <see>
                    #add(Complex)                    
                </see>
            </javadoc>
            <method name="add" type="Complex" line="175">
                <params>
                    <param name="addend" type="double"/>
                </params>
                <scope line="176"/>
            </method>
            <javadoc line="183">
                Return the conjugate of this complex number.
                  The conjugate of {@code a + bi} is {@code a - bi}.
                  &lt;br/&gt;{@link #NaN} is returned if either the real or imaginary
                  part of this Complex number equals {@code Double.NaN}.
                  &lt;br/&gt;
                  If the imaginary part is infinite, and the real part is not{@code NaN}, the returned value has infinite imaginary part
                  of the opposite sign, e.g. the conjugate of{@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.                
                <return>
                    the conjugate of this Complex object.                    
                </return>
            </javadoc>
            <method name="conjugate" type="Complex" line="197">
                <scope line="198"/>
            </method>
            <javadoc line="205">
                Returns a {@code Complex} whose value is{@code (this / divisor)}.
                  Implements the definitional formula
                  &lt;pre&gt;
                  &lt;code&gt;
                  a + bi          ac + bd + (bc - ad)i
                  ----------- = -------------------------
                  c + di         c&lt;sup&gt;2&lt;/sup&gt; + d&lt;sup&gt;2&lt;/sup&gt;
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  but uses
                  &lt;a href=&quot;http://doi.acm.org/10.1145/1039813.1039814&quot;&gt;
                  prescaling of operands&lt;/a&gt; to limit the effects of overflows and
                  underflows in the computation.
                  &lt;br/&gt;{@code Infinite} and {@code NaN} values are handled according to the
                  following rules, applied in the order presented:
                  &lt;ul&gt;
                  &lt;li&gt;If either {@code this} or {@code divisor} has a {@code NaN} value
                  in either part, {@link #NaN} is returned.
                  &lt;/li&gt;
                  &lt;li&gt;If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
                  &lt;/li&gt;
                  &lt;li&gt;If {@code this} and {@code divisor} are both infinite,{@link #NaN} is returned.
                  &lt;/li&gt;
                  &lt;li&gt;If {@code this} is finite (i.e., has no {@code Infinite} or{@code NaN} parts) and {@code divisor} is infinite (one or both parts
                  infinite), {@link #ZERO} is returned.
                  &lt;/li&gt;
                  &lt;li&gt;If {@code this} is infinite and {@code divisor} is finite,{@code NaN} values are returned in the parts of the result if the{@link java.lang.Double} rules applied to the definitional formula
                  force {@code NaN} results.
                  &lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    divisor Value by which this {@code Complex} is to be divided.                    
                </param>
                <return>
                    {@code this / divisor}.                    
                </return>
                <throws>
                    NullArgumentException if {@code divisor} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="divide" type="Complex" line="248">
                <params>
                    <param name="divisor" type="Complex"/>
                </params>
                <scope line="250"/>
                <declaration name="c" type="double" line="254"/>
                <declaration name="d" type="double" line="255"/>
                <scope line="256"/>
                <scope line="260"/>
                <scope line="264">
                    <declaration name="q" type="double" line="265"/>
                    <declaration name="denominator" type="double" line="266"/>
                </scope>
                <scope line="269">
                    <declaration name="q" type="double" line="270"/>
                    <declaration name="denominator" type="double" line="271"/>
                </scope>
            </method>
            <javadoc line="277">
                Returns a {@code Complex} whose value is {@code (this / divisor)},
                  with {@code divisor} interpreted as a real number.                
                <param>
                    divisor Value by which this {@code Complex} is to be divided.                    
                </param>
                <return>
                    {@code this / divisor}.                    
                </return>
                <see>
                    #divide(Complex)                    
                </see>
            </javadoc>
            <method name="divide" type="Complex" line="285">
                <params>
                    <param name="divisor" type="double"/>
                </params>
                <scope line="286"/>
                <scope line="289"/>
                <scope line="292"/>
            </method>
            <javadoc line="299">
                {@inheritDoc}                
            </javadoc>
            <method name="reciprocal" type="Complex" line="300">
                <scope line="301"/>
                <scope line="305"/>
                <scope line="309"/>
                <scope line="313">
                    <declaration name="q" type="double" line="314"/>
                    <declaration name="scale" type="double" line="315"/>
                </scope>
                <scope line="317">
                    <declaration name="q" type="double" line="318"/>
                    <declaration name="scale" type="double" line="319"/>
                </scope>
            </method>
            <javadoc line="324">
                Test for equality with another object.
                  If both the real and imaginary parts of two complex numbers
                  are exactly the same, and neither is {@code Double.NaN}, the two
                  Complex objects are considered to be equal.
                  The behavior is the same as for JDK&apos;s {@link Double#equals(Object)Double}:
                  &lt;ul&gt;
                  &lt;li&gt;All {@code NaN} values are considered to be equal,
                  i.e, if either (or both) real and imaginary parts of the complex
                  number are equal to {@code Double.NaN}, the complex number is equal
                  to {@code NaN}.
                  &lt;/li&gt;
                  &lt;li&gt;
                  Instances constructed with different representations of zero (i.e.
                  either &quot;0&quot; or &quot;-0&quot;) are &lt;em&gt;not&lt;/em&gt; considered to be equal.
                  &lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    other Object to test for equality with this instance.                    
                </param>
                <return>
                    {@code true} if the objects are equal, {@code false} if object
                      is {@code null}, not an instance of {@code Complex}, or not equal to
                      this instance.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="349">
                <params>
                    <param name="other" type="Object"/>
                </params>
                <scope line="350"/>
                <scope line="353">
                    <declaration name="c" type="Complex" line="354"/>
                    <scope line="355"/>
                    <scope line="357"/>
                </scope>
            </method>
            <javadoc line="365">
                Test for the floating-point equality between Complex objects.
                  It returns {@code true} if both arguments are equal or within the
                  range of allowed error (inclusive).                
                <param>
                    x First value (cannot be {@code null}).                    
                </param>
                <param>
                    y Second value (cannot be {@code null}).                    
                </param>
                <param>
                    maxUlps {@code (maxUlps - 1)} is the number of floating point
                      values between the real (resp. imaginary) parts of {@code x} and{@code y}.                    
                </param>
                <return>
                    {@code true} if there are fewer than {@code maxUlps} floating
                      point values between the real (resp. imaginary) parts of {@code x}and {@code y}.                    
                </return>
                <see>
                    Precision#equals(double,double,int)                    
                </see>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="equals" type="boolean" line="382">
                <params>
                    <param name="x" type="Complex"/>
                    <param name="y" type="Complex"/>
                    <param name="maxUlps" type="int"/>
                </params>
            </method>
            <javadoc line="387">
                Returns {@code true} iff the values are equal as defined by{@link #equals(Complex,Complex,int) equals(x, y, 1)}.                
                <param>
                    x First value (cannot be {@code null}).                    
                </param>
                <param>
                    y Second value (cannot be {@code null}).                    
                </param>
                <return>
                    {@code true} if the values are equal.                    
                </return>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="equals" type="boolean" line="397">
                <params>
                    <param name="x" type="Complex"/>
                    <param name="y" type="Complex"/>
                </params>
            </method>
            <javadoc line="401">
                Returns {@code true} if, both for the real part and for the imaginary
                  part, there is no double value strictly between the arguments or the
                  difference between them is within the range of allowed error
                  (inclusive).                
                <param>
                    x First value (cannot be {@code null}).                    
                </param>
                <param>
                    y Second value (cannot be {@code null}).                    
                </param>
                <param>
                    eps Amount of allowed absolute error.                    
                </param>
                <return>
                    {@code true} if the values are two adjacent floating point
                      numbers or they are within range of each other.                    
                </return>
                <see>
                    Precision#equals(double,double,double)                    
                </see>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="equals" type="boolean" line="416">
                <params>
                    <param name="x" type="Complex"/>
                    <param name="y" type="Complex"/>
                    <param name="eps" type="double"/>
                </params>
            </method>
            <javadoc line="421">
                Returns {@code true} if, both for the real part and for the imaginary
                  part, there is no double value strictly between the arguments or the
                  relative difference between them is smaller or equal to the given
                  tolerance.                
                <param>
                    x First value (cannot be {@code null}).                    
                </param>
                <param>
                    y Second value (cannot be {@code null}).                    
                </param>
                <param>
                    eps Amount of allowed relative error.                    
                </param>
                <return>
                    {@code true} if the values are two adjacent floating point
                      numbers or they are within range of each other.                    
                </return>
                <see>
                    Precision#equalsWithRelativeTolerance(double,double,double)                    
                </see>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="equalsWithRelativeTolerance" type="boolean" line="437">
                <params>
                    <param name="x" type="Complex"/>
                    <param name="y" type="Complex"/>
                    <param name="eps" type="double"/>
                </params>
            </method>
            <javadoc line="442">
                Get a hashCode for the complex number.
                  Any {@code Double.NaN} value in real or imaginary part produces
                  the same hash code {@code 7}.                
                <return>
                    a hash code value for this object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="450">
                <scope line="451"/>
            </method>
            <javadoc line="458">
                Access the imaginary part.                
                <return>
                    the imaginary part.                    
                </return>
            </javadoc>
            <method name="getImaginary" type="double" line="463"/>
            <javadoc line="467">
                Access the real part.                
                <return>
                    the real part.                    
                </return>
            </javadoc>
            <method name="getReal" type="double" line="472"/>
            <javadoc line="476">
                Checks whether either or both parts of this complex number is{@code NaN}.                
                <return>
                    true if either or both parts of this complex number is{@code NaN}; false otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="483"/>
            <javadoc line="487">
                Checks whether either the real or imaginary part of this complex number
                  takes an infinite value (either {@code Double.POSITIVE_INFINITY} or{@code Double.NEGATIVE_INFINITY}) and neither part
                  is {@code NaN}.                
                <return>
                    true if one or both parts of this complex number are infinite
                      and neither part is {@code NaN}.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="496"/>
            <javadoc line="500">
                Returns a {@code Complex} whose value is {@code this  factor}.
                  Implements preliminary checks for {@code NaN} and infinity followed by
                  the definitional formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  (a + bi)(c + di) = (ac - bd) + (ad + bc)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  Returns {@link #NaN} if either {@code this} or {@code factor} has one or
                  more {@code NaN} parts.
                  &lt;br/&gt;
                  Returns {@link #INF} if neither {@code this} nor {@code factor} has one
                  or more {@code NaN} parts and if either {@code this} or {@code factor}has one or more infinite parts (same result is returned regardless of
                  the sign of the components).
                  &lt;br/&gt;
                  Returns finite values in components of the result per the definitional
                  formula in all remaining cases.                
                <param>
                    factor value to be multiplied by this {@code Complex}.                    
                </param>
                <return>
                    {@code this  factor}.                    
                </return>
                <throws>
                    NullArgumentException if {@code factor} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="multiply" type="Complex" line="525">
                <params>
                    <param name="factor" type="Complex"/>
                </params>
                <comment line="535">
                    we don&apos;t use isInfinite() to avoid testing for NaN again                    
                </comment>
                <scope line="527"/>
                <scope line="533"/>
            </method>
            <javadoc line="541">
                Returns a {@code Complex} whose value is {@code this  factor}, with {@code factor}interpreted as a integer number.                
                <param>
                    factor value to be multiplied by this {@code Complex}.                    
                </param>
                <return>
                    {@code this  factor}.                    
                </return>
                <see>
                    #multiply(Complex)                    
                </see>
            </javadoc>
            <method name="multiply" type="Complex" line="549">
                <params>
                    <param name="factor" type="int"/>
                </params>
                <scope line="550"/>
                <scope line="554"/>
            </method>
            <javadoc line="560">
                Returns a {@code Complex} whose value is {@code this  factor}, with {@code factor}interpreted as a real number.                
                <param>
                    factor value to be multiplied by this {@code Complex}.                    
                </param>
                <return>
                    {@code this  factor}.                    
                </return>
                <see>
                    #multiply(Complex)                    
                </see>
            </javadoc>
            <method name="multiply" type="Complex" line="568">
                <params>
                    <param name="factor" type="double"/>
                </params>
                <comment line="576">
                    we don&apos;t use isInfinite() to avoid testing for NaN again                    
                </comment>
                <scope line="569"/>
                <scope line="574"/>
            </method>
            <javadoc line="581">
                Returns a {@code Complex} whose value is {@code (-this)}.
                  Returns {@code NaN} if either real or imaginary
                  part of this Complex number equals {@code Double.NaN}.                
                <return>
                    {@code -this}.                    
                </return>
            </javadoc>
            <method name="negate" type="Complex" line="588">
                <scope line="589"/>
            </method>
            <javadoc line="596">
                Returns a {@code Complex} whose value is{@code (this - subtrahend)}.
                  Uses the definitional formula
                  &lt;pre&gt;
                  &lt;code&gt;
                  (a + bi) - (c + di) = (a-c) + (b-d)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,{@link #NaN} is returned; otherwise infinite and {@code NaN} values are
                  returned in the parts of the result according to the rules for{@link java.lang.Double} arithmetic.                
                <param>
                    subtrahend value to be subtracted from this {@code Complex}.                    
                </param>
                <return>
                    {@code this - subtrahend}.                    
                </return>
                <throws>
                    NullArgumentException if {@code subtrahend} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="subtract" type="Complex" line="615">
                <params>
                    <param name="subtrahend" type="Complex"/>
                </params>
                <scope line="617"/>
            </method>
            <javadoc line="625">
                Returns a {@code Complex} whose value is{@code (this - subtrahend)}.                
                <param>
                    subtrahend value to be subtracted from this {@code Complex}.                    
                </param>
                <return>
                    {@code this - subtrahend}.                    
                </return>
                <see>
                    #subtract(Complex)                    
                </see>
            </javadoc>
            <method name="subtract" type="Complex" line="633">
                <params>
                    <param name="subtrahend" type="double"/>
                </params>
                <scope line="634"/>
            </method>
            <javadoc line="640">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/InverseCosine.html&quot; TARGET=&quot;_top&quot;&gt;
                  inverse cosine&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  acos(z) = -i (log(z + i (sqrt(1 - z&lt;sup&gt;2&lt;/sup&gt;))))
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN} or infinite.                
                <return>
                    the inverse cosine of this complex number.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="acos" type="Complex" line="656">
                <scope line="657"/>
            </method>
            <javadoc line="664">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/InverseSine.html&quot; TARGET=&quot;_top&quot;&gt;
                  inverse sine&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  asin(z) = -i (log(sqrt(1 - z&lt;sup&gt;2&lt;/sup&gt;) + iz))
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN} or infinite.                
                <return>
                    the inverse sine of this complex number.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="asin" type="Complex" line="680">
                <scope line="681"/>
            </method>
            <javadoc line="688">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/InverseTangent.html&quot; TARGET=&quot;_top&quot;&gt;
                  inverse tangent&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  atan(z) = (i/2) log((i + z)/(i - z))
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN} or infinite.                
                <return>
                    the inverse tangent of this complex number                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="atan" type="Complex" line="704">
                <scope line="705"/>
            </method>
            <javadoc line="713">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/Cosine.html&quot; TARGET=&quot;_top&quot;&gt;
                  cosine&lt;/a&gt;
                  of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  cos(1 &amp;plusmn; INFINITY i) = 1 &amp;#x2213; INFINITY i
                  cos(&amp;plusmn;INFINITY + i) = NaN + NaN i
                  cos(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the cosine of this complex number.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="cos" type="Complex" line="745">
                <scope line="746"/>
            </method>
            <javadoc line="754">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicCosine.html&quot; TARGET=&quot;_top&quot;&gt;
                  hyperbolic cosine&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  cosh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
                  cosh(&amp;plusmn;INFINITY + i) = INFINITY &amp;plusmn; INFINITY i
                  cosh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the hyperbolic cosine of this complex number.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="cosh" type="Complex" line="785">
                <scope line="786"/>
            </method>
            <javadoc line="794">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/ExponentialFunction.html&quot; TARGET=&quot;_top&quot;&gt;
                  exponential function&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#exp}, {@link FastMath#cos}, and{@link FastMath#sin}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  exp(1 &amp;plusmn; INFINITY i) = NaN + NaN i
                  exp(INFINITY + i) = INFINITY + INFINITY i
                  exp(-INFINITY + i) = 0 + 0i
                  exp(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;this&lt;/sup&gt;&lt;/code&gt;.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="exp" type="Complex" line="826">
                <scope line="827"/>
                <declaration name="expReal" type="double" line="831"/>
            </method>
            <javadoc line="836">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/NaturalLogarithm.html&quot; TARGET=&quot;_top&quot;&gt;
                  natural logarithm&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  log(a + bi) = ln(|a + bi|) + arg(a + bi)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where ln on the right hand side is {@link FastMath#log},{@code |a + bi|} is the modulus, {@link Complex#abs},  and{@code arg(a + bi) = }{@link FastMath#atan2}(b, a).
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite (or critical) values in real or imaginary parts of the input may
                  result in infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  log(1 &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (&amp;pi;/2)i
                  log(INFINITY + i) = INFINITY + 0i
                  log(-INFINITY + i) = INFINITY + &amp;pi;i
                  log(INFINITY &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (&amp;pi;/4)i
                  log(-INFINITY &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (3&amp;pi;/4)i
                  log(0 + 0i) = -INFINITY + 0i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the value &lt;code&gt;ln &amp;nbsp; this&lt;/code&gt;, the natural logarithm
                      of {@code this}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="log" type="Complex" line="871">
                <scope line="872"/>
            </method>
            <javadoc line="880">
                Returns of value of this complex number raised to the power of {@code x}.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  y&lt;sup&gt;x&lt;/sup&gt; = exp(x&amp;middot;log(y))
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where {@code exp} and {@code log} are {@link #exp} and{@link #log}, respectively.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN} or infinite, or if {@code y}equals {@link Complex#ZERO}.                
                <param>
                    x exponent to which this {@code Complex} is to be raised.                    
                </param>
                <return>
                    &lt;code&gt; this&lt;sup&gt;{@code x}&lt;/sup&gt;&lt;/code&gt;.                    
                </return>
                <throws>
                    NullArgumentException if x is {@code null}.                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="pow" type="Complex" line="901">
                <params>
                    <param name="x" type="Complex"/>
                </params>
            </method>
            <javadoc line="906">
                Returns of value of this complex number raised to the power of {@code x}.                
                <param>
                    x exponent to which this {@code Complex} is to be raised.                    
                </param>
                <return>
                    &lt;code&gt;this&lt;sup&gt;x&lt;/sup&gt;&lt;/code&gt;.                    
                </return>
                <see>
                    #pow(Complex)                    
                </see>
            </javadoc>
            <method name="pow" type="Complex" line="913">
                <params>
                    <param name="x" type="double"/>
                </params>
            </method>
            <javadoc line="917">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/Sine.html&quot; TARGET=&quot;_top&quot;&gt;
                  sine&lt;/a&gt;
                  of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or {@code NaN} values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  sin(1 &amp;plusmn; INFINITY i) = 1 &amp;plusmn; INFINITY i
                  sin(&amp;plusmn;INFINITY + i) = NaN + NaN i
                  sin(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the sine of this complex number.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="sin" type="Complex" line="949">
                <scope line="950"/>
            </method>
            <javadoc line="958">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicSine.html&quot; TARGET=&quot;_top&quot;&gt;
                  hyperbolic sine&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos},{@link FastMath#cosh} and {@link FastMath#sinh}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  sinh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
                  sinh(&amp;plusmn;INFINITY + i) = &amp;plusmn; INFINITY + INFINITY i
                  sinh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the hyperbolic sine of {@code this}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="sinh" type="Complex" line="989">
                <scope line="990"/>
            </method>
            <javadoc line="998">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/SquareRoot.html&quot; TARGET=&quot;_top&quot;&gt;
                  square root&lt;/a&gt; of this complex number.
                  Implements the following algorithm to compute {@code sqrt(a + bi)}:
                  &lt;ol&gt;&lt;li&gt;Let {@code t = sqrt((|a| + |a + bi|) / 2)}&lt;/li&gt;
                  &lt;li&gt;&lt;pre&gt;if {@code  a &amp;#8805; 0} return {@code t + (b/2t)i}else return {@code |b|/2t + sign(b)t i }&lt;/pre&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  where &lt;ul&gt;
                  &lt;li&gt;{@code |a| = }{@link FastMath#abs}(a)&lt;/li&gt;
                  &lt;li&gt;{@code |a + bi| = }{@link Complex#abs}(a + bi)&lt;/li&gt;
                  &lt;li&gt;{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}&lt;/ul&gt;
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  sqrt(1 &amp;plusmn; INFINITY i) = INFINITY + NaN i
                  sqrt(INFINITY + i) = INFINITY + 0i
                  sqrt(-INFINITY + i) = 0 + INFINITY i
                  sqrt(INFINITY &amp;plusmn; INFINITY i) = INFINITY + NaN i
                  sqrt(-INFINITY &amp;plusmn; INFINITY i) = NaN &amp;plusmn; INFINITY i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the square root of {@code this}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="sqrt" type="Complex" line="1032">
                <scope line="1033"/>
                <scope line="1037"/>
                <declaration name="t" type="double" line="1041"/>
                <scope line="1042"/>
                <scope line="1044"/>
            </method>
            <javadoc line="1050">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/SquareRoot.html&quot; TARGET=&quot;_top&quot;&gt;
                  square root&lt;/a&gt; of &lt;code&gt;1 - this&lt;sup&gt;2&lt;/sup&gt;&lt;/code&gt; for this complex
                  number.
                  Computes the result directly as{@code sqrt(ONE.subtract(z.multiply(z)))}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.                
                <return>
                    the square root of &lt;code&gt;1 - this&lt;sup&gt;2&lt;/sup&gt;&lt;/code&gt;.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="sqrt1z" type="Complex" line="1067"/>
            <javadoc line="1071">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/Tangent.html&quot; TARGET=&quot;_top&quot;&gt;
                  tangent&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and{@link FastMath#sinh}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite (or critical) values in real or imaginary parts of the input may
                  result in infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  tan(a &amp;plusmn; INFINITY i) = 0 &amp;plusmn; i
                  tan(&amp;plusmn;INFINITY + bi) = NaN + NaN i
                  tan(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  tan(&amp;plusmn;&amp;pi;/2 + 0 i) = &amp;plusmn;INFINITY + NaN i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the tangent of {@code this}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="tan" type="Complex" line="1103">
                <scope line="1104"/>
                <scope line="1107"/>
                <scope line="1110"/>
                <declaration name="real2" type="double" line="1114"/>
                <declaration name="imaginary2" type="double" line="1115"/>
                <declaration name="d" type="double" line="1116"/>
            </method>
            <javadoc line="1122">
                Compute the
                  &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicTangent.html&quot; TARGET=&quot;_top&quot;&gt;
                  hyperbolic tangent&lt;/a&gt; of this complex number.
                  Implements the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  where the (real) functions on the right-hand side are{@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and{@link FastMath#sinh}.
                  &lt;br/&gt;
                  Returns {@link Complex#NaN} if either real or imaginary part of the
                  input argument is {@code NaN}.
                  &lt;br/&gt;
                  Infinite values in real or imaginary parts of the input may result in
                  infinite or NaN values returned in parts of the result.
                  &lt;pre&gt;
                  Examples:
                  &lt;code&gt;
                  tanh(a &amp;plusmn; INFINITY i) = NaN + NaN i
                  tanh(&amp;plusmn;INFINITY + bi) = &amp;plusmn;1 + 0 i
                  tanh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
                  tanh(0 + (&amp;pi;/2)i) = NaN + INFINITY i
                  &lt;/code&gt;
                  &lt;/pre&gt;                
                <return>
                    the hyperbolic tangent of {@code this}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="tanh" type="Complex" line="1154">
                <scope line="1155"/>
                <scope line="1158"/>
                <scope line="1161"/>
                <declaration name="real2" type="double" line="1164"/>
                <declaration name="imaginary2" type="double" line="1165"/>
                <declaration name="d" type="double" line="1166"/>
            </method>
            <javadoc line="1174">
                Compute the argument of this complex number.
                  The argument is the angle phi between the positive real axis and
                  the point representing this number in the complex plane.
                  The value returned is between -PI (not inclusive)
                  and PI (inclusive), with negative values returned for numbers with
                  negative imaginary parts.
                  &lt;br/&gt;
                  If either real or imaginary part (or both) is NaN, NaN is returned.
                  Infinite parts are handled as {@code Math.atan2} handles them,
                  essentially treating finite parts as zero in the presence of an
                  infinite coordinate and returning a multiple of pi/4 depending on
                  the signs of the infinite parts.
                  See the javadoc for {@code Math.atan2} for full details.                
                <return>
                    the argument of {@code this}.                    
                </return>
            </javadoc>
            <method name="getArgument" type="double" line="1191"/>
            <javadoc line="1195">
                Computes the n-th roots of this complex number.
                  The nth roots are defined by the formula:
                  &lt;pre&gt;
                  &lt;code&gt;
                  z&lt;sub&gt;k&lt;/sub&gt; = abs&lt;sup&gt;1/n&lt;/sup&gt; (cos(phi + 2&amp;pi;k/n) + i (sin(phi + 2&amp;pi;k/n))
                  &lt;/code&gt;
                  &lt;/pre&gt;
                  for &lt;i&gt;{@code k=0, 1, ..., n-1}&lt;/i&gt;, where {@code abs} and {@code phi}are respectively the {@link #abs() modulus} and{@link #getArgument() argument} of this complex number.
                  &lt;br/&gt;
                  If one or both parts of this complex number is NaN, a list with just
                  one element, {@link #NaN} is returned.
                  if neither part is NaN, but at least one part is infinite, the result
                  is a one-element list containing {@link #INF}.                
                <param>
                    n Degree of root.                    
                </param>
                <return>
                    a List&lt;Complex&gt; of all {@code n}-th roots of {@code this}.                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt;= 0}.                    
                </throws>
                <since>
                    2.0                    
                </since>
            </javadoc>
            <method name="nthRoot" type="List&lt;Complex&gt;" line="1217">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="1236">
                    nth root of abs -- faster / more accurate to use a solver here?                    
                </comment>
                <comment line="1239">
                    Compute nth roots of complex number with k = 0, 1, ... n-1                    
                </comment>
                <comment line="1244">
                    inner part                    
                </comment>
                <scope line="1219"/>
                <declaration name="result" type="List&amp;lt;Complex&amp;gt;" line="1224"/>
                <scope line="1226"/>
                <scope line="1230"/>
                <declaration name="nthRootOfAbs" type="double" line="1236"/>
                <declaration name="nthPhi" type="double" line="1239"/>
                <declaration name="slice" type="double" line="1240"/>
                <declaration name="innerPart" type="double" line="1241"/>
                <scope line="1242">
                    <declaration name="realPart" type="double" line="1244"/>
                    <declaration name="imaginaryPart" type="double" line="1245"/>
                </scope>
            </method>
            <javadoc line="1253">
                Create a complex number given the real and imaginary parts.                
                <param>
                    realPart Real part.                    
                </param>
                <param>
                    imaginaryPart Imaginary part.                    
                </param>
                <return>
                    a new complex number instance.                    
                </return>
                <since>
                    1.2                    
                </since>
                <see>
                    #valueOf(double,double)                    
                </see>
            </javadoc>
            <method name="createComplex" type="Complex" line="1263">
                <params>
                    <param name="realPart" type="double"/>
                    <param name="imaginaryPart" type="double"/>
                </params>
            </method>
            <javadoc line="1267">
                Create a complex number given the real and imaginary parts.                
                <param>
                    realPart Real part.                    
                </param>
                <param>
                    imaginaryPart Imaginary part.                    
                </param>
                <return>
                    a Complex instance.                    
                </return>
            </javadoc>
            <method name="valueOf" type="Complex" line="1275">
                <params>
                    <param name="realPart" type="double"/>
                    <param name="imaginaryPart" type="double"/>
                </params>
                <scope line="1277"/>
            </method>
            <javadoc line="1283">
                Create a complex number given only the real part.                
                <param>
                    realPart Real part.                    
                </param>
                <return>
                    a Complex instance.                    
                </return>
            </javadoc>
            <method name="valueOf" type="Complex" line="1289">
                <params>
                    <param name="realPart" type="double"/>
                </params>
                <scope line="1290"/>
            </method>
            <javadoc line="1296">
                Resolve the transient fields in a deserialized Complex Object.
                  Subclasses will need to override {@link #createComplex} to
                  deserialize properly.                
                <return>
                    A Complex instance with all fields resolved.                    
                </return>
                <since>
                    2.0                    
                </since>
            </javadoc>
            <method name="readResolve" type="Object" line="1304"/>
            <javadoc line="1308">
                {@inheritDoc}                
            </javadoc>
            <method name="getField" type="ComplexField" line="1309"/>
            <javadoc line="1313">
                {@inheritDoc}                
            </javadoc>
            <method name="toString" type="String" line="1315"/>
        </class>
    </source>