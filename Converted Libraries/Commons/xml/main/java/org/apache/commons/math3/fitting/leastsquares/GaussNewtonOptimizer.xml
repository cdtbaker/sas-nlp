<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.fitting.leastsquares">
        <import package="org.apache.commons.math3.exception.ConvergenceException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem.Evaluation"/>
        <import package="org.apache.commons.math3.linear.ArrayRealVector"/>
        <import package="org.apache.commons.math3.linear.CholeskyDecomposition"/>
        <import package="org.apache.commons.math3.linear.LUDecomposition"/>
        <import package="org.apache.commons.math3.linear.MatrixUtils"/>
        <import package="org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException"/>
        <import package="org.apache.commons.math3.linear.QRDecomposition"/>
        <import package="org.apache.commons.math3.linear.RealMatrix"/>
        <import package="org.apache.commons.math3.linear.RealVector"/>
        <import package="org.apache.commons.math3.linear.SingularMatrixException"/>
        <import package="org.apache.commons.math3.linear.SingularValueDecomposition"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.util.Incrementor"/>
        <import package="org.apache.commons.math3.util.Pair"/>
        <class name="GaussNewtonOptimizer" line="37">
            <implements interface="LeastSquaresOptimizer"/>
            <javadoc line="37">
                Gauss-Newton least-squares solver.
                  &lt;p&gt; This class solve a least-square problem by
                  solving the normal equations of the linearized problem at each iteration. Either LU
                  decomposition or Cholesky decomposition can be used to solve the normal equations,
                  or QR decomposition or SVD decomposition can be used to solve the linear system. LU
                  decomposition is faster but QR decomposition is more robust for difficult problems,
                  and SVD can compute a solution for rank-deficient problems.
                  &lt;/p&gt;                
                <version>
                    $Id: GaussNewtonOptimizer.java 1573351 2014-03-02 19:54:43Z luc $                    
                </version>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <declaration name="Decomposition" type="enum" line="52"/>
            <javadoc line="52">
                The decomposition algorithm to use to solve the normal equations.                
            </javadoc>
            <scope line="54"/>
            <javadoc line="55">
                Solve by forming the normal equations (J&lt;sup&gt;T&lt;/sup&gt;Jx=J&lt;sup&gt;T&lt;/sup&gt;r) and
                  using the {@link LUDecomposition}.
                  &lt;p&gt; Theoretically this method takes mn&lt;sup&gt;2&lt;/sup&gt;/2 operations to compute the
                  normal matrix and n&lt;sup&gt;3&lt;/sup&gt;/3 operations (m &gt; n) to solve the system using
                  the LU decomposition. &lt;/p&gt;                
            </javadoc>
            <method name="solve" type="RealVector" line="66">
                <params>
                    <param name="jacobian" type="RealMatrix"/>
                    <param name="residuals" type="RealVector"/>
                </params>
                <scope line="67">
                    <declaration name="normalEquation" type="Pair&amp;lt;RealMatrix,RealVector&amp;gt;" line="68"/>
                    <declaration name="normal" type="RealMatrix" line="70"/>
                    <declaration name="jTr" type="RealVector" line="71"/>
                </scope>
                <scope line="75"/>
            </method>
            <scope line="-1"/>
            <javadoc line="80">
                Solve the linear least squares problem (Jx=r) using the {@link QRDecomposition}.
                  &lt;p&gt; Theoretically this method takes mn&lt;sup&gt;2&lt;/sup&gt; - n&lt;sup&gt;3&lt;/sup&gt;/3 operations
                  (m &gt; n) and has better numerical accuracy than any method that forms the normal
                  equations. &lt;/p&gt;                
            </javadoc>
            <method name="solve" type="RealVector" line="91">
                <params>
                    <param name="jacobian" type="RealMatrix"/>
                    <param name="residuals" type="RealVector"/>
                </params>
                <scope line="92"/>
                <scope line="96"/>
            </method>
            <scope line="-1"/>
            <javadoc line="101">
                Solve by forming the normal equations (J&lt;sup&gt;T&lt;/sup&gt;Jx=J&lt;sup&gt;T&lt;/sup&gt;r) and
                  using the {@link CholeskyDecomposition}.
                  &lt;p&gt; Theoretically this method takes mn&lt;sup&gt;2&lt;/sup&gt;/2 operations to compute the
                  normal matrix and n&lt;sup&gt;3&lt;/sup&gt;/6 operations (m &gt; n) to solve the system using
                  the Cholesky decomposition. &lt;/p&gt;                
            </javadoc>
            <method name="solve" type="RealVector" line="112">
                <params>
                    <param name="jacobian" type="RealMatrix"/>
                    <param name="residuals" type="RealVector"/>
                </params>
                <scope line="113">
                    <declaration name="normalEquation" type="Pair&amp;lt;RealMatrix,RealVector&amp;gt;" line="114"/>
                    <declaration name="normal" type="RealMatrix" line="116"/>
                    <declaration name="jTr" type="RealVector" line="117"/>
                </scope>
                <scope line="122"/>
            </method>
            <scope line="-1"/>
            <javadoc line="127">
                Solve the linear least squares problem using the {@link SingularValueDecomposition}.
                  &lt;p&gt; This method is slower, but can provide a solution for rank deficient and
                  nearly singular systems.                
            </javadoc>
            <method name="solve" type="RealVector" line="137">
                <params>
                    <param name="jacobian" type="RealMatrix"/>
                    <param name="residuals" type="RealVector"/>
                </params>
            </method>
            <scope line="-1"/>
            <method name="solve" type="RealVector" line="144"/>
            <javadoc line="144">
                Solve the linear least squares problem Jx=r.                
                <param>
                    jacobian  the Jacobian matrix, J. the number of rows &gt;= the number or
                      columns.                    
                </param>
                <param>
                    residuals the computed residuals, r.                    
                </param>
                <return>
                    the solution x, to the linear least squares problem Jx=r.                    
                </return>
                <throws>
                    ConvergenceException if the matrix properties (e.g. singular) do not
                      permit a solution.                    
                </throws>
            </javadoc>
            <declaration name="SINGULARITY_THRESHOLD" type="double" line="158"/>
            <javadoc line="158">
                The singularity threshold for matrix decompositions. Determines when a {@link ConvergenceException} is thrown. The current value was the default value for {@link LUDecomposition}.                
            </javadoc>
            <declaration name="decomposition" type="Decomposition" line="165"/>
            <javadoc line="165">
                Indicator for using LU decomposition.                
            </javadoc>
            <javadoc line="168">
                Creates a Gauss Newton optimizer.
                  &lt;p/&gt;
                  The default for the algorithm is to solve the normal equations using QR
                  decomposition.                
            </javadoc>
            <method name="GaussNewtonOptimizer" type="constructor" line="174"/>
            <javadoc line="178">
                Create a Gauss Newton optimizer that uses the given decomposition algorithm to
                  solve the normal equations.                
                <param>
                    decomposition the {@link Decomposition} algorithm.                    
                </param>
            </javadoc>
            <method name="GaussNewtonOptimizer" type="constructor" line="184">
                <params>
                    <param name="decomposition" type="Decomposition"/>
                </params>
            </method>
            <javadoc line="188">
                Get the matrix decomposition algorithm used to solve the normal equations.                
                <return>
                    the matrix {@link Decomposition} algoritm.                    
                </return>
            </javadoc>
            <method name="getDecomposition" type="Decomposition" line="193"/>
            <javadoc line="197">
                Configure the decomposition algorithm.                
                <param>
                    newDecomposition the {@link Decomposition} algorithm to use.                    
                </param>
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withDecomposition" type="GaussNewtonOptimizer" line="203">
                <params>
                    <param name="newDecomposition" type="Decomposition"/>
                </params>
            </method>
            <javadoc line="207">
                {@inheritDoc}                
            </javadoc>
            <method name="optimize" type="Optimum" line="208">
                <params>
                    <param name="lsp" type="LeastSquaresProblem"/>
                </params>
                <comment line="210">
                    create local evaluation and iteration counts                    
                </comment>
                <comment line="216">
                    Computation will be useless without a checker (see &quot;for-loop&quot;).                    
                </comment>
                <comment line="223">
                    iterate until convergence is reached                    
                </comment>
                <comment line="228">
                    evaluate the objective function and its jacobian                    
                </comment>
                <comment line="230">
                    Value of the objective function at &quot;currentPoint&quot;.                    
                </comment>
                <comment line="236">
                    Check convergence.                    
                </comment>
                <comment line="246">
                    solve the linearized least squares problem                    
                </comment>
                <comment line="248">
                    update the estimated parameters                    
                </comment>
                <declaration name="evaluationCounter" type="Incrementor" line="210"/>
                <declaration name="iterationCounter" type="Incrementor" line="211"/>
                <declaration name="checker" type="ConvergenceChecker&amp;lt;Evaluation&amp;gt;" line="212"/>
                <scope line="216"/>
                <declaration name="currentPoint" type="RealVector" line="220"/>
                <declaration name="current" type="Evaluation" line="223"/>
                <scope line="224">
                    <declaration name="previous" type="Evaluation" line="228"/>
                    <declaration name="currentResiduals" type="RealVector" line="232"/>
                    <declaration name="weightedJacobian" type="RealMatrix" line="233"/>
                    <scope line="236">
                        <scope line="237"/>
                    </scope>
                    <declaration name="dX" type="RealVector" line="246"/>
                </scope>
            </method>
            <method name="toString" type="String" line="253"/>
            <javadoc line="259">
                Compute the normal matrix, J&lt;sup&gt;T&lt;/sup&gt;J.                
                <param>
                    jacobian  the m by n jacobian matrix, J. Input.                    
                </param>
                <param>
                    residuals the m by 1 residual vector, r. Input.                    
                </param>
                <return>
                    the n by n normal matrix and  the n by 1 J&lt;sup&gt;Tr vector.                    
                </return>
            </javadoc>
            <method name="computeNormalMatrix" type="Pair&lt;RealMatrix,RealVector&gt;" line="267">
                <params>
                    <param name="jacobian" type="RealMatrix"/>
                    <param name="residuals" type="RealVector"/>
                </params>
                <comment line="269">
                    since the normal matrix is symmetric, we only need to compute half of it.                    
                </comment>
                <comment line="272">
                    allocate space for return values                    
                </comment>
                <comment line="275">
                    for each measurement                    
                </comment>
                <comment line="277">
                    compute JTr for measurement i                    
                </comment>
                <comment line="283">
                    add the the contribution to the normal matrix for measurement i                    
                </comment>
                <comment line="285">
                    only compute the upper triangular part                    
                </comment>
                <comment line="292">
                    copy the upper triangular part to the lower triangular part.                    
                </comment>
                <declaration name="nR" type="int" line="269"/>
                <declaration name="nC" type="int" line="270"/>
                <declaration name="normal" type="RealMatrix" line="272"/>
                <declaration name="jTr" type="RealVector" line="273"/>
                <scope line="275">
                    <scope line="277"/>
                    <scope line="283">
                        <scope line="285"/>
                    </scope>
                </scope>
                <scope line="292">
                    <scope line="293"/>
                </scope>
            </method>
        </class>
    </source>