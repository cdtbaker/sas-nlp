<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optimization.direct">
        <import package="java.util.Comparator"/>
        <import package="org.apache.commons.math3.analysis.MultivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.optimization.GoalType"/>
        <import package="org.apache.commons.math3.optimization.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optimization.PointValuePair"/>
        <import package="org.apache.commons.math3.optimization.SimpleValueChecker"/>
        <import package="org.apache.commons.math3.optimization.MultivariateOptimizer"/>
        <import package="org.apache.commons.math3.optimization.OptimizationData"/>
        <class name="SimplexOptimizer" line="31">
            <extends class="BaseAbstractMultivariateOptimizer">
                <type_params>
                    <type_param name="MultivariateFunction"/>
                </type_params>
            </extends>
            <comment line="89">
                deprecated anyway                
            </comment>
            <implements interface="MultivariateOptimizer"/>
            <javadoc line="31">
                This class implements simplex-based direct search optimization.
                  &lt;p&gt;
                  Direct search methods only use objective function values, they do
                  not need derivatives and don&apos;t either try to compute approximation
                  of the derivatives. According to a 1996 paper by Margaret H. Wright
                  (&lt;a href=&quot;http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz&quot;&gt;Direct
                  Search Methods: Once Scorned, Now Respectable&lt;/a&gt;), they are used
                  when either the computation of the derivative is impossible (noisy
                  functions, unpredictable discontinuities) or difficult (complexity,
                  computation cost). In the first cases, rather than an optimum, a
                  &lt;em&gt;not too bad&lt;/em&gt; point is desired. In the latter cases, an
                  optimum is desired but cannot be reasonably found. In all cases
                  direct search methods can be useful.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Simplex-based direct search methods are based on comparison of
                  the objective function values at the vertices of a simplex (which is a
                  set of n+1 points in dimension n) that is updated by the algorithms
                  steps.
                  &lt;p&gt;
                  &lt;p&gt;
                  The {@link #setSimplex(AbstractSimplex) setSimplex} method &lt;em&gt;must&lt;/em&gt;
                  be called prior to calling the {@code optimize} method.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each call to {@link #optimize(int,MultivariateFunction,GoalType,double[])optimize} will re-use the start configuration of the current simplex and
                  move it such that its first vertex is at the provided start point of the
                  optimization. If the {@code optimize} method is called to solve a different
                  problem and the number of parameters change, the simplex must be
                  re-initialized to one with the appropriate dimensions.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Convergence is checked by providing the &lt;em&gt;worst&lt;/em&gt; points of
                  previous and current simplex to the convergence checker, not the best
                  ones.
                  &lt;/p&gt;
                  &lt;p&gt;
                  This simplex optimizer implementation does not directly support constrained
                  optimization with simple bounds, so for such optimizations, either a more
                  dedicated method must be used like {@link CMAESOptimizer} or {@link BOBYQAOptimizer}, or the optimized method must be wrapped in an adapter like{@link MultivariateFunctionMappingAdapter} or {@link MultivariateFunctionPenaltyAdapter}.
                  &lt;/p&gt;                
                <see>
                    AbstractSimplex                    
                </see>
                <see>
                    MultivariateFunctionMappingAdapter                    
                </see>
                <see>
                    MultivariateFunctionPenaltyAdapter                    
                </see>
                <see>
                    CMAESOptimizer                    
                </see>
                <see>
                    BOBYQAOptimizer                    
                </see>
                <version>
                    $Id: SimplexOptimizer.java 1504724 2013-07-18 23:41:20Z sebb $                    
                </version>
                <deprecated>
                    As of 3.1 (to be removed in 4.0).                    
                </deprecated>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="simplex" type="AbstractSimplex" line="93"/>
            <javadoc line="93">
                Simplex.                
            </javadoc>
            <javadoc line="96">
                Constructor using a default {@link SimpleValueChecker convergence
                  checker}.                
                <deprecated>
                    See {@link SimpleValueChecker#SimpleValueChecker()}                    
                </deprecated>
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="102"/>
            <javadoc line="106">
                @param checker Convergence checker.                
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="109">
                <params>
                    <param name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;"/>
                </params>
            </method>
            <javadoc line="113">
                @param rel Relative threshold.                
                <param>
                    abs Absolute threshold.                    
                </param>
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="117">
                <params>
                    <param name="rel" type="double"/>
                    <param name="abs" type="double"/>
                </params>
            </method>
            <javadoc line="121">
                Set the simplex algorithm.                
                <param>
                    simplex Simplex.                    
                </param>
                <deprecated>
                    As of 3.1. The initial simplex can now be passed as an
                      argument of the {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])}method.                    
                </deprecated>
            </javadoc>
            <method name="setSimplex" type="void" line="130">
                <params>
                    <param name="simplex" type="AbstractSimplex"/>
                </params>
            </method>
            <javadoc line="134">
                Optimize an objective function.                
                <param>
                    maxEval Allowed number of evaluations of the objective function.                    
                </param>
                <param>
                    f Objective function.                    
                </param>
                <param>
                    goalType Optimization type.                    
                </param>
                <param>
                    optData Optimization data. The following data will be looked for:
                      &lt;ul&gt;
                      &lt;li&gt;{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}&lt;/li&gt;
                      &lt;li&gt;{@link AbstractSimplex}&lt;/li&gt;
                      &lt;/ul&gt;                    
                </param>
                <return>
                    the point/value pair giving the optimal value for objective
                      function.                    
                </return>
            </javadoc>
            <method name="optimizeInternal" type="PointValuePair" line="151">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="MultivariateFunction"/>
                    <param name="goalType" type="GoalType"/>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="153">
                    Scan &quot;optData&quot; for the input specific to this optimizer.                    
                </comment>
                <comment line="156">
                    The parent&apos;s method will retrieve the common parameters from
                     &quot;optData&quot; and call &quot;doOptimize&quot;.                    
                </comment>
            </method>
            <javadoc line="160">
                Scans the list of (required and optional) optimization data that
                  characterize the problem.                
                <param>
                    optData Optimization data. The following data will be looked for:
                      &lt;ul&gt;
                      &lt;li&gt;{@link AbstractSimplex}&lt;/li&gt;
                      &lt;/ul&gt;                    
                </param>
            </javadoc>
            <method name="parseOptimizationData" type="void" line="169">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="171">
                    The existing values (as set by the previous call) are reused if
                     not provided in the argument list.                    
                </comment>
                <scope line="172">
                    <scope line="173"/>
                </scope>
            </method>
            <javadoc line="180">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="182">
                <comment line="188">
                    Indirect call to &quot;computeObjectiveValue&quot; in order to update the
                     evaluations counter.                    
                </comment>
                <comment line="208">
                    Initialize search.                    
                </comment>
                <comment line="224">
                    We have found an optimum.                    
                </comment>
                <comment line="229">
                    We still need to search.                    
                </comment>
                <scope line="183"/>
                <anonymous_class line="190">
                    <method name="value" type="double" line="191">
                        <params>
                            <param name="point" type="double[]"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="evalFunc" type="MultivariateFunction" line="189"/>
                <declaration name="isMinim" type="boolean" line="196"/>
                <anonymous_class line="198">
                    <method name="compare" type="int" line="200">
                        <params>
                            <param name="o1" type="PointValuePair"/>
                            <param name="o2" type="PointValuePair"/>
                        </params>
                        <declaration name="v1" type="double" line="201"/>
                        <declaration name="v2" type="double" line="202"/>
                    </method>
                </anonymous_class>
                <declaration name="comparator" type="Comparator&amp;lt;PointValuePair&amp;gt;" line="197"/>
                <declaration name="previous" type="PointValuePair[]" line="211"/>
                <declaration name="iteration" type="int" line="212"/>
                <declaration name="checker" type="ConvergenceChecker&amp;lt;PointValuePair&amp;gt;" line="213"/>
                <scope line="214">
                    <scope line="215">
                        <declaration name="converged" type="boolean" line="216"/>
                        <scope line="217">
                            <declaration name="prev" type="PointValuePair" line="218"/>
                        </scope>
                        <scope line="222"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>