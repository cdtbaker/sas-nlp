<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.dfp">
        <import package="org.apache.commons.math3.Field"/>
        <import package="org.apache.commons.math3.FieldElement"/>
        <class name="DfpField" line="23">
            <comment line="79">
                Note: the static strings are set up (once) by the ctor and @GuardedBy(&quot;DfpField.class&quot;)                
            </comment>
            <implements interface="Field">
                <type_params>
                    <type_param name="Dfp"/>
                </type_params>
            </implements>
            <javadoc line="23">
                Field for Decimal floating point instances.                
                <version>
                    $Id: DfpField.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <javadoc line="29">
                Enumerate for rounding modes.                
            </javadoc>
            <javadoc line="32">
                Rounds toward zero (truncation).                
            </javadoc>
            <javadoc line="35">
                Rounds away from zero if discarded digit is non-zero.                
            </javadoc>
            <javadoc line="38">
                Rounds towards nearest unless both are equidistant in which case it rounds away from zero.                
            </javadoc>
            <javadoc line="41">
                Rounds towards nearest unless both are equidistant in which case it rounds toward zero.                
            </javadoc>
            <javadoc line="44">
                Rounds towards nearest unless both are equidistant in which case it rounds toward the even neighbor.
                  This is the default as  specified by IEEE 854-1987                
            </javadoc>
            <javadoc line="49">
                Rounds towards nearest unless both are equidistant in which case it rounds toward the odd neighbor.                
            </javadoc>
            <javadoc line="52">
                Rounds towards positive infinity.                
            </javadoc>
            <javadoc line="55">
                Rounds towards negative infinity.                
            </javadoc>
            <declaration name="FLAG_INVALID" type="int" line="60"/>
            <javadoc line="60">
                IEEE 854-1987 flag for invalid operation.                
            </javadoc>
            <declaration name="FLAG_DIV_ZERO" type="int" line="63"/>
            <javadoc line="63">
                IEEE 854-1987 flag for division by zero.                
            </javadoc>
            <declaration name="FLAG_OVERFLOW" type="int" line="66"/>
            <javadoc line="66">
                IEEE 854-1987 flag for overflow.                
            </javadoc>
            <declaration name="FLAG_UNDERFLOW" type="int" line="69"/>
            <javadoc line="69">
                IEEE 854-1987 flag for underflow.                
            </javadoc>
            <declaration name="FLAG_INEXACT" type="int" line="72"/>
            <javadoc line="72">
                IEEE 854-1987 flag for inexact result.                
            </javadoc>
            <declaration name="sqr2String" type="String" line="75"/>
            <javadoc line="75">
                High precision string representation of &amp;radic;2.                
            </javadoc>
            <declaration name="sqr2ReciprocalString" type="String" line="80"/>
            <javadoc line="80">
                High precision string representation of &amp;radic;2 / 2.                
            </javadoc>
            <declaration name="sqr3String" type="String" line="83"/>
            <javadoc line="83">
                High precision string representation of &amp;radic;3.                
            </javadoc>
            <declaration name="sqr3ReciprocalString" type="String" line="86"/>
            <javadoc line="86">
                High precision string representation of &amp;radic;3 / 3.                
            </javadoc>
            <declaration name="piString" type="String" line="89"/>
            <javadoc line="89">
                High precision string representation of &amp;pi;.                
            </javadoc>
            <declaration name="eString" type="String" line="92"/>
            <javadoc line="92">
                High precision string representation of e.                
            </javadoc>
            <declaration name="ln2String" type="String" line="95"/>
            <javadoc line="95">
                High precision string representation of ln(2).                
            </javadoc>
            <declaration name="ln5String" type="String" line="98"/>
            <javadoc line="98">
                High precision string representation of ln(5).                
            </javadoc>
            <declaration name="ln10String" type="String" line="101"/>
            <javadoc line="101">
                High precision string representation of ln(10).                
            </javadoc>
            <declaration name="radixDigits" type="int" line="104"/>
            <javadoc line="104">
                The number of radix digits.
                  Note these depend on the radix which is 10000 digits,
                  so each one is equivalent to 4 decimal digits.                
            </javadoc>
            <declaration name="zero" type="Dfp" line="110"/>
            <javadoc line="110">
                A {@link Dfp} with value 0.                
            </javadoc>
            <declaration name="one" type="Dfp" line="113"/>
            <javadoc line="113">
                A {@link Dfp} with value 1.                
            </javadoc>
            <declaration name="two" type="Dfp" line="116"/>
            <javadoc line="116">
                A {@link Dfp} with value 2.                
            </javadoc>
            <declaration name="sqr2" type="Dfp" line="119"/>
            <javadoc line="119">
                A {@link Dfp} with value &amp;radic;2.                
            </javadoc>
            <declaration name="sqr2Split" type="Dfp[]" line="122"/>
            <javadoc line="122">
                A two elements {@link Dfp} array with value &amp;radic;2 split in two pieces.                
            </javadoc>
            <declaration name="sqr2Reciprocal" type="Dfp" line="125"/>
            <javadoc line="125">
                A {@link Dfp} with value &amp;radic;2 / 2.                
            </javadoc>
            <declaration name="sqr3" type="Dfp" line="128"/>
            <javadoc line="128">
                A {@link Dfp} with value &amp;radic;3.                
            </javadoc>
            <declaration name="sqr3Reciprocal" type="Dfp" line="131"/>
            <javadoc line="131">
                A {@link Dfp} with value &amp;radic;3 / 3.                
            </javadoc>
            <declaration name="pi" type="Dfp" line="134"/>
            <javadoc line="134">
                A {@link Dfp} with value &amp;pi;.                
            </javadoc>
            <declaration name="piSplit" type="Dfp[]" line="137"/>
            <javadoc line="137">
                A two elements {@link Dfp} array with value &amp;pi; split in two pieces.                
            </javadoc>
            <declaration name="e" type="Dfp" line="140"/>
            <javadoc line="140">
                A {@link Dfp} with value e.                
            </javadoc>
            <declaration name="eSplit" type="Dfp[]" line="143"/>
            <javadoc line="143">
                A two elements {@link Dfp} array with value e split in two pieces.                
            </javadoc>
            <declaration name="ln2" type="Dfp" line="146"/>
            <javadoc line="146">
                A {@link Dfp} with value ln(2).                
            </javadoc>
            <declaration name="ln2Split" type="Dfp[]" line="149"/>
            <javadoc line="149">
                A two elements {@link Dfp} array with value ln(2) split in two pieces.                
            </javadoc>
            <declaration name="ln5" type="Dfp" line="152"/>
            <javadoc line="152">
                A {@link Dfp} with value ln(5).                
            </javadoc>
            <declaration name="ln5Split" type="Dfp[]" line="155"/>
            <javadoc line="155">
                A two elements {@link Dfp} array with value ln(5) split in two pieces.                
            </javadoc>
            <declaration name="ln10" type="Dfp" line="158"/>
            <javadoc line="158">
                A {@link Dfp} with value ln(10).                
            </javadoc>
            <declaration name="rMode" type="RoundingMode" line="161"/>
            <javadoc line="161">
                Current rounding mode.                
            </javadoc>
            <declaration name="ieeeFlags" type="int" line="164"/>
            <javadoc line="164">
                IEEE 854-1987 signals.                
            </javadoc>
            <javadoc line="167">
                Create a factory for the specified number of radix digits.
                  &lt;p&gt;
                  Note that since the {@link Dfp} class uses 10000 as its radix, each radix
                  digit is equivalent to 4 decimal digits. This implies that asking for
                  13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
                  all cases.
                  &lt;/p&gt;                
                <param>
                    decimalDigits minimal number of decimal digits.                    
                </param>
            </javadoc>
            <method name="DfpField" type="constructor" line="176">
                <params>
                    <param name="decimalDigits" type="int"/>
                </params>
            </method>
            <javadoc line="180">
                Create a factory for the specified number of radix digits.
                  &lt;p&gt;
                  Note that since the {@link Dfp} class uses 10000 as its radix, each radix
                  digit is equivalent to 4 decimal digits. This implies that asking for
                  13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in
                  all cases.
                  &lt;/p&gt;                
                <param>
                    decimalDigits minimal number of decimal digits                    
                </param>
                <param>
                    computeConstants if true, the transcendental constants for the given precision
                      must be computed (setting this flag to false is RESERVED for the internal recursive call)                    
                </param>
            </javadoc>
            <method name="DfpField" type="constructor" line="191">
                <params>
                    <param name="decimalDigits" type="int"/>
                    <param name="computeConstants" type="boolean"/>
                </params>
                <comment line="202">
                    set up transcendental constants                    
                </comment>
                <comment line="205">
                    as a heuristic to circumvent Table-Maker&apos;s Dilemma, we set the string
                     representation of the constants to be at least 3 times larger than the
                     number of decimal digits, also as an attempt to really compute these
                     constants only once, we set a minimum number of digits                    
                </comment>
                <comment line="211">
                    set up the constants at current field accuracy                    
                </comment>
                <comment line="229">
                    dummy settings for unused constants                    
                </comment>
                <scope line="200">
                    <scope line="202"/>
                </scope>
                <scope line="227"/>
            </method>
            <javadoc line="247">
                Get the number of radix digits of the {@link Dfp} instances built by this factory.                
                <return>
                    number of radix digits                    
                </return>
            </javadoc>
            <method name="getRadixDigits" type="int" line="250"/>
            <javadoc line="254">
                Set the rounding mode.
                  If not set, the default value is {@link RoundingMode#ROUND_HALF_EVEN}.                
                <param>
                    mode desired rounding mode
                      Note that the rounding mode is common to all {@link Dfp} instances
                      belonging to the current {@link DfpField} in the system and will
                      affect all future calculations.                    
                </param>
            </javadoc>
            <method name="setRoundingMode" type="void" line="261">
                <params>
                    <param name="mode" type="RoundingMode"/>
                </params>
            </method>
            <javadoc line="265">
                Get the current rounding mode.                
                <return>
                    current rounding mode                    
                </return>
            </javadoc>
            <method name="getRoundingMode" type="RoundingMode" line="268"/>
            <javadoc line="272">
                Get the IEEE 854 status flags.                
                <return>
                    IEEE 854 status flags                    
                </return>
                <see>
                    #clearIEEEFlags()                    
                </see>
                <see>
                    #setIEEEFlags(int)                    
                </see>
                <see>
                    #setIEEEFlagsBits(int)                    
                </see>
                <see>
                    #FLAG_INVALID                    
                </see>
                <see>
                    #FLAG_DIV_ZERO                    
                </see>
                <see>
                    #FLAG_OVERFLOW                    
                </see>
                <see>
                    #FLAG_UNDERFLOW                    
                </see>
                <see>
                    #FLAG_INEXACT                    
                </see>
            </javadoc>
            <method name="getIEEEFlags" type="int" line="283"/>
            <javadoc line="287">
                Clears the IEEE 854 status flags.                
                <see>
                    #getIEEEFlags()                    
                </see>
                <see>
                    #setIEEEFlags(int)                    
                </see>
                <see>
                    #setIEEEFlagsBits(int)                    
                </see>
                <see>
                    #FLAG_INVALID                    
                </see>
                <see>
                    #FLAG_DIV_ZERO                    
                </see>
                <see>
                    #FLAG_OVERFLOW                    
                </see>
                <see>
                    #FLAG_UNDERFLOW                    
                </see>
                <see>
                    #FLAG_INEXACT                    
                </see>
            </javadoc>
            <method name="clearIEEEFlags" type="void" line="297"/>
            <javadoc line="301">
                Sets the IEEE 854 status flags.                
                <param>
                    flags desired value for the flags                    
                </param>
                <see>
                    #getIEEEFlags()                    
                </see>
                <see>
                    #clearIEEEFlags()                    
                </see>
                <see>
                    #setIEEEFlagsBits(int)                    
                </see>
                <see>
                    #FLAG_INVALID                    
                </see>
                <see>
                    #FLAG_DIV_ZERO                    
                </see>
                <see>
                    #FLAG_OVERFLOW                    
                </see>
                <see>
                    #FLAG_UNDERFLOW                    
                </see>
                <see>
                    #FLAG_INEXACT                    
                </see>
            </javadoc>
            <method name="setIEEEFlags" type="void" line="312">
                <params>
                    <param name="flags" type="int"/>
                </params>
            </method>
            <javadoc line="316">
                Sets some bits in the IEEE 854 status flags, without changing the already set bits.
                  &lt;p&gt;
                  Calling this method is equivalent to call {@code setIEEEFlags(getIEEEFlags() | bits)}&lt;/p&gt;                
                <param>
                    bits bits to set                    
                </param>
                <see>
                    #getIEEEFlags()                    
                </see>
                <see>
                    #clearIEEEFlags()                    
                </see>
                <see>
                    #setIEEEFlags(int)                    
                </see>
                <see>
                    #FLAG_INVALID                    
                </see>
                <see>
                    #FLAG_DIV_ZERO                    
                </see>
                <see>
                    #FLAG_OVERFLOW                    
                </see>
                <see>
                    #FLAG_UNDERFLOW                    
                </see>
                <see>
                    #FLAG_INEXACT                    
                </see>
            </javadoc>
            <method name="setIEEEFlagsBits" type="void" line="330">
                <params>
                    <param name="bits" type="int"/>
                </params>
            </method>
            <javadoc line="334">
                Makes a {@link Dfp} with a value of 0.                
                <return>
                    a new {@link Dfp} with a value of 0                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="337"/>
            <javadoc line="341">
                Create an instance from a byte value.                
                <param>
                    x value to convert to an instance                    
                </param>
                <return>
                    a new {@link Dfp} with the same value as x                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="345">
                <params>
                    <param name="x" type="byte"/>
                </params>
            </method>
            <javadoc line="349">
                Create an instance from an int value.                
                <param>
                    x value to convert to an instance                    
                </param>
                <return>
                    a new {@link Dfp} with the same value as x                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="353">
                <params>
                    <param name="x" type="int"/>
                </params>
            </method>
            <javadoc line="357">
                Create an instance from a long value.                
                <param>
                    x value to convert to an instance                    
                </param>
                <return>
                    a new {@link Dfp} with the same value as x                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="361">
                <params>
                    <param name="x" type="long"/>
                </params>
            </method>
            <javadoc line="365">
                Create an instance from a double value.                
                <param>
                    x value to convert to an instance                    
                </param>
                <return>
                    a new {@link Dfp} with the same value as x                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="369">
                <params>
                    <param name="x" type="double"/>
                </params>
            </method>
            <javadoc line="373">
                Copy constructor.                
                <param>
                    d instance to copy                    
                </param>
                <return>
                    a new {@link Dfp} with the same value as d                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="377">
                <params>
                    <param name="d" type="Dfp"/>
                </params>
            </method>
            <javadoc line="381">
                Create a {@link Dfp} given a String representation.                
                <param>
                    s string representation of the instance                    
                </param>
                <return>
                    a new {@link Dfp} parsed from specified string                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="385">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="389">
                Creates a {@link Dfp} with a non-finite value.                
                <param>
                    sign sign of the Dfp to create                    
                </param>
                <param>
                    nans code of the value, must be one of {@link Dfp#INFINITE},{@link Dfp#SNAN},  {@link Dfp#QNAN}                    
                </param>
                <return>
                    a new {@link Dfp} with a non-finite value                    
                </return>
            </javadoc>
            <method name="newDfp" type="Dfp" line="395">
                <params>
                    <param name="sign" type="byte"/>
                    <param name="nans" type="byte"/>
                </params>
            </method>
            <javadoc line="399">
                Get the constant 0.                
                <return>
                    a {@link Dfp} with value 0                    
                </return>
            </javadoc>
            <method name="getZero" type="Dfp" line="402"/>
            <javadoc line="406">
                Get the constant 1.                
                <return>
                    a {@link Dfp} with value 1                    
                </return>
            </javadoc>
            <method name="getOne" type="Dfp" line="409"/>
            <javadoc line="413">
                {@inheritDoc}                
            </javadoc>
            <method name="getRuntimeClass" type="Class<? extends FieldElement<Dfp>>" line="414"/>
            <javadoc line="418">
                Get the constant 2.                
                <return>
                    a {@link Dfp} with value 2                    
                </return>
            </javadoc>
            <method name="getTwo" type="Dfp" line="421"/>
            <javadoc line="425">
                Get the constant &amp;radic;2.                
                <return>
                    a {@link Dfp} with value &amp;radic;2                    
                </return>
            </javadoc>
            <method name="getSqr2" type="Dfp" line="428"/>
            <javadoc line="432">
                Get the constant &amp;radic;2 split in two pieces.                
                <return>
                    a {@link Dfp} with value &amp;radic;2 split in two pieces                    
                </return>
            </javadoc>
            <method name="getSqr2Split" type="Dfp[]" line="435"/>
            <javadoc line="439">
                Get the constant &amp;radic;2 / 2.                
                <return>
                    a {@link Dfp} with value &amp;radic;2 / 2                    
                </return>
            </javadoc>
            <method name="getSqr2Reciprocal" type="Dfp" line="442"/>
            <javadoc line="446">
                Get the constant &amp;radic;3.                
                <return>
                    a {@link Dfp} with value &amp;radic;3                    
                </return>
            </javadoc>
            <method name="getSqr3" type="Dfp" line="449"/>
            <javadoc line="453">
                Get the constant &amp;radic;3 / 3.                
                <return>
                    a {@link Dfp} with value &amp;radic;3 / 3                    
                </return>
            </javadoc>
            <method name="getSqr3Reciprocal" type="Dfp" line="456"/>
            <javadoc line="460">
                Get the constant &amp;pi;.                
                <return>
                    a {@link Dfp} with value &amp;pi;                    
                </return>
            </javadoc>
            <method name="getPi" type="Dfp" line="463"/>
            <javadoc line="467">
                Get the constant &amp;pi; split in two pieces.                
                <return>
                    a {@link Dfp} with value &amp;pi; split in two pieces                    
                </return>
            </javadoc>
            <method name="getPiSplit" type="Dfp[]" line="470"/>
            <javadoc line="474">
                Get the constant e.                
                <return>
                    a {@link Dfp} with value e                    
                </return>
            </javadoc>
            <method name="getE" type="Dfp" line="477"/>
            <javadoc line="481">
                Get the constant e split in two pieces.                
                <return>
                    a {@link Dfp} with value e split in two pieces                    
                </return>
            </javadoc>
            <method name="getESplit" type="Dfp[]" line="484"/>
            <javadoc line="488">
                Get the constant ln(2).                
                <return>
                    a {@link Dfp} with value ln(2)                    
                </return>
            </javadoc>
            <method name="getLn2" type="Dfp" line="491"/>
            <javadoc line="495">
                Get the constant ln(2) split in two pieces.                
                <return>
                    a {@link Dfp} with value ln(2) split in two pieces                    
                </return>
            </javadoc>
            <method name="getLn2Split" type="Dfp[]" line="498"/>
            <javadoc line="502">
                Get the constant ln(5).                
                <return>
                    a {@link Dfp} with value ln(5)                    
                </return>
            </javadoc>
            <method name="getLn5" type="Dfp" line="505"/>
            <javadoc line="509">
                Get the constant ln(5) split in two pieces.                
                <return>
                    a {@link Dfp} with value ln(5) split in two pieces                    
                </return>
            </javadoc>
            <method name="getLn5Split" type="Dfp[]" line="512"/>
            <javadoc line="516">
                Get the constant ln(10).                
                <return>
                    a {@link Dfp} with value ln(10)                    
                </return>
            </javadoc>
            <method name="getLn10" type="Dfp" line="519"/>
            <javadoc line="523">
                Breaks a string representation up into two {@link Dfp}&apos;s.
                  The split is such that the sum of them is equivalent to the input string,
                  but has higher precision than using a single Dfp.                
                <param>
                    a string representation of the number to split                    
                </param>
                <return>
                    an array of two {@link Dfp Dfp} instances which sum equals a                    
                </return>
            </javadoc>
            <method name="split" type="Dfp[]" line="529">
                <params>
                    <param name="a" type="String"/>
                </params>
                <declaration name="result" type="Dfp" line="530"/>
                <declaration name="leading" type="boolean" line="531"/>
                <declaration name="sp" type="int" line="532"/>
                <declaration name="sig" type="int" line="533"/>
                <declaration name="buf" type="char[]" line="535"/>
                <scope line="537">
                    <scope line="540"/>
                    <scope line="544"/>
                    <scope line="549"/>
                    <scope line="554"/>
                </scope>
                <scope line="561">
                    <scope line="563"/>
                </scope>
            </method>
            <javadoc line="574">
                Recompute the high precision string constants.                
                <param>
                    highPrecisionDecimalDigits precision at which the string constants mus be computed                    
                </param>
            </javadoc>
            <method name="computeStringConstants" type="void" line="577">
                <params>
                    <param name="highPrecisionDecimalDigits" type="int"/>
                </params>
                <comment line="581">
                    recompute the string representation of the transcendental constants                    
                </comment>
                <scope line="578">
                    <declaration name="highPrecisionField" type="DfpField" line="581"/>
                    <declaration name="highPrecisionOne" type="Dfp" line="582"/>
                    <declaration name="highPrecisionTwo" type="Dfp" line="583"/>
                    <declaration name="highPrecisionThree" type="Dfp" line="584"/>
                    <declaration name="highPrecisionSqr2" type="Dfp" line="586"/>
                    <declaration name="highPrecisionSqr3" type="Dfp" line="590"/>
                </scope>
            </method>
            <javadoc line="603">
                Compute &amp;pi; using Jonathan and Peter Borwein quartic formula.                
                <param>
                    one constant with value 1 at desired precision                    
                </param>
                <param>
                    two constant with value 2 at desired precision                    
                </param>
                <param>
                    three constant with value 3 at desired precision                    
                </param>
                <return>
                    &amp;pi;                    
                </return>
            </javadoc>
            <method name="computePi" type="Dfp" line="609">
                <params>
                    <param name="one" type="Dfp"/>
                    <param name="two" type="Dfp"/>
                    <param name="three" type="Dfp"/>
                </params>
                <comment line="618">
                    The formula converges quartically. This means the number of correct
                     digits is multiplied by 4 at each iteration! Five iterations are
                     sufficient for about 160 digits, eight iterations give about
                     10000 digits (this has been checked) and 20 iterations more than
                     160 billions of digits (this has NOT been checked).
                     So the limit here is considered sufficient for most purposes ...                    
                </comment>
                <declaration name="sqrt2" type="Dfp" line="611"/>
                <declaration name="yk" type="Dfp" line="612"/>
                <declaration name="four" type="Dfp" line="613"/>
                <declaration name="two2kp3" type="Dfp" line="614"/>
                <declaration name="ak" type="Dfp" line="615"/>
                <scope line="623">
                    <declaration name="ykM1" type="Dfp" line="624"/>
                    <declaration name="y2" type="Dfp" line="626"/>
                    <declaration name="oneMinusY4" type="Dfp" line="627"/>
                    <declaration name="s" type="Dfp" line="628"/>
                    <declaration name="p" type="Dfp" line="633"/>
                    <declaration name="p2" type="Dfp" line="634"/>
                    <scope line="637"/>
                </scope>
            </method>
            <javadoc line="646">
                Compute exp(a).                
                <param>
                    a number for which we want the exponential                    
                </param>
                <param>
                    one constant with value 1 at desired precision                    
                </param>
                <return>
                    exp(a)                    
                </return>
            </javadoc>
            <method name="computeExp" type="Dfp" line="651">
                <params>
                    <param name="a" type="Dfp"/>
                    <param name="one" type="Dfp"/>
                </params>
                <declaration name="y" type="Dfp" line="653"/>
                <declaration name="py" type="Dfp" line="654"/>
                <declaration name="f" type="Dfp" line="655"/>
                <declaration name="fi" type="Dfp" line="656"/>
                <declaration name="x" type="Dfp" line="657"/>
                <scope line="659">
                    <scope line="664"/>
                </scope>
            </method>
            <javadoc line="675">
                Compute ln(a).
                  Let f(x) = ln(x),
                  We know that f&apos;(x) = 1/x, thus from Taylor&apos;s theorem we have:
                  -----          n+1         n
                  f(x) =   \           (-1)    (x - 1)
                  /          ----------------    for 1 &lt;= n &lt;= infinity
                  -----             n
                  or
                  2        3       4
                  (x-1)   (x-1)    (x-1)
                  ln(x) =  (x-1) - ----- + ------ - ------ + ...
                  2       3        4
                  alternatively,
                  2    3   4
                  x    x   x
                  ln(x+1) =  x - -  + - - - + ...
                  2    3   4
                  This series can be used to compute ln(x), but it converges too slowly.
                  If we substitute -x for x above, we get
                  2    3    4
                  x    x    x
                  ln(1-x) =  -x - -  - -  - - + ...
                  2    3    4
                  Note that all terms are now negative.  Because the even powered ones
                  absorbed the sign.  Now, subtract the series above from the previous
                  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
                  only the odd ones
                  3     5      7
                  2x    2x     2x
                  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
                  3     5      7
                  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
                  3        5        7
                  x+1           /          x        x        x          \
                  ln ----- =   2   |  x  +   ----  +  ----  +  ---- + ...  |
                  x-1           \          3        5        7          /
                  But now we want to find ln(a), so we need to find the value of x
                  such that a = (x+1)/(x-1).   This is easily solved to find that
                  x = (a-1)/(a+1).                
                <param>
                    a number for which we want the exponential                    
                </param>
                <param>
                    one constant with value 1 at desired precision                    
                </param>
                <param>
                    two constant with value 2 at desired precision                    
                </param>
                <return>
                    ln(a)                    
                </return>
            </javadoc>
            <method name="computeLn" type="Dfp" line="734">
                <params>
                    <param name="a" type="Dfp"/>
                    <param name="one" type="Dfp"/>
                    <param name="two" type="Dfp"/>
                </params>
                <declaration name="den" type="int" line="736"/>
                <declaration name="x" type="Dfp" line="737"/>
                <declaration name="y" type="Dfp" line="739"/>
                <declaration name="num" type="Dfp" line="740"/>
                <declaration name="py" type="Dfp" line="741"/>
                <scope line="742">
                    <declaration name="t" type="Dfp" line="746"/>
                    <scope line="748"/>
                </scope>
            </method>
        </class>
    </source>