<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning.utilities">
        <import package="java.util.Arrays"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="OrderedTuple" line="23">
            <implements interface="Comparable">
                <type_params>
                    <type_param name="OrderedTuple"/>
                </type_params>
            </implements>
            <javadoc line="23">
                This class implements an ordering operation for T-uples.
                  &lt;p&gt;Ordering is done by encoding all components of the T-uple into a
                  single scalar value and using this value as the sorting
                  key. Encoding is performed using the method invented by Georg
                  Cantor in 1877 when he proved it was possible to establish a
                  bijection between a line and a plane. The binary representations of
                  the components of the T-uple are mixed together to form a single
                  scalar. This means that the 2&lt;sup&gt;k&lt;/sup&gt; bit of component 0 is
                  followed by the 2&lt;sup&gt;k&lt;/sup&gt; bit of component 1, then by the
                  2&lt;sup&gt;k&lt;/sup&gt; bit of component 2 up to the 2&lt;sup&gt;k&lt;/sup&gt; bit of
                  component {@code t}, which is followed by the 2&lt;sup&gt;k-1&lt;/sup&gt;
                  bit of component 0, followed by the 2&lt;sup&gt;k-1&lt;/sup&gt; bit of
                  component 1 ... The binary representations are extended as needed
                  to handle numbers with different scales and a suitable
                  2&lt;sup&gt;p&lt;/sup&gt; offset is added to the components in order to avoid
                  negative numbers (this offset is adjusted as needed during the
                  comparison operations).&lt;/p&gt;
                  &lt;p&gt;The more interesting property of the encoding method for our
                  purpose is that it allows to select all the points that are in a
                  given range. This is depicted in dimension 2 by the following
                  picture:&lt;/p&gt;
                  &lt;img src=&quot;doc-files/OrderedTuple.png&quot; /&gt;
                  &lt;p&gt;This picture shows a set of 100000 random 2-D pairs having their
                  first component between -50 and +150 and their second component
                  between -350 and +50. We wanted to extract all pairs having their
                  first component between +30 and +70 and their second component
                  between -120 and -30. We built the lower left point at coordinates
                  (30, -120) and the upper right point at coordinates (70, -30). All
                  points smaller than the lower left point are drawn in red and all
                  points larger than the upper right point are drawn in blue. The
                  green points are between the two limits. This picture shows that
                  all the desired points are selected, along with spurious points. In
                  this case, we get 15790 points, 4420 of which really belonging to
                  the desired rectangle. It is possible to extract very small
                  subsets. As an example extracting from the same 100000 points set
                  the points having their first component between +30 and +31 and
                  their second component between -91 and -90, we get a subset of 11
                  points, 2 of which really belonging to the desired rectangle.&lt;/p&gt;
                  &lt;p&gt;the previous selection technique can be applied in all
                  dimensions, still using two points to define the interval. The
                  first point will have all its components set to their lower bounds
                  while the second point will have all its components set to their
                  upper bounds.&lt;/p&gt;
                  &lt;p&gt;T-uples with negative infinite or positive infinite components
                  are sorted logically.&lt;/p&gt;
                  &lt;p&gt;Since the specification of the {@code Comparator} interface
                  allows only {@code ClassCastException} errors, some arbitrary
                  choices have been made to handle specific cases. The rationale for
                  these choices is to keep &lt;em&gt;regular&lt;/em&gt; and consistent T-uples
                  together.&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;instances with different dimensions are sorted according to
                  their dimension regardless of their components values&lt;/li&gt;
                  &lt;li&gt;instances with {@code Double.NaN} components are sorted
                  after all other ones (even after instances with positive infinite
                  components&lt;/li&gt;
                  &lt;li&gt;instances with both positive and negative infinite components
                  are considered as if they had {@code Double.NaN}components&lt;/li&gt;
                  &lt;/ul&gt;                
                <version>
                    $Id: OrderedTuple.java 1591835 2014-05-02 09:04:01Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="SIGN_MASK" type="long" line="96"/>
            <javadoc line="96">
                Sign bit mask.                
            </javadoc>
            <declaration name="EXPONENT_MASK" type="long" line="99"/>
            <javadoc line="99">
                Exponent bits mask.                
            </javadoc>
            <declaration name="MANTISSA_MASK" type="long" line="102"/>
            <javadoc line="102">
                Mantissa bits mask.                
            </javadoc>
            <declaration name="IMPLICIT_ONE" type="long" line="105"/>
            <javadoc line="105">
                Implicit MSB for normalized numbers.                
            </javadoc>
            <declaration name="components" type="double[]" line="108"/>
            <javadoc line="108">
                Double components of the T-uple.                
            </javadoc>
            <declaration name="offset" type="int" line="111"/>
            <javadoc line="111">
                Offset scale.                
            </javadoc>
            <declaration name="lsb" type="int" line="114"/>
            <javadoc line="114">
                Least Significant Bit scale.                
            </javadoc>
            <declaration name="encoding" type="long[]" line="117"/>
            <javadoc line="117">
                Ordering encoding of the double components.                
            </javadoc>
            <declaration name="posInf" type="boolean" line="120"/>
            <javadoc line="120">
                Positive infinity marker.                
            </javadoc>
            <declaration name="negInf" type="boolean" line="123"/>
            <javadoc line="123">
                Negative infinity marker.                
            </javadoc>
            <declaration name="nan" type="boolean" line="126"/>
            <javadoc line="126">
                Not A Number marker.                
            </javadoc>
            <javadoc line="129">
                Build an ordered T-uple from its components.                
                <param>
                    components double components of the T-uple                    
                </param>
            </javadoc>
            <method name="OrderedTuple" type="constructor" line="132">
                <params>
                    <param name="components" type="double"/>
                </params>
                <comment line="161">
                    instance cannot be sorted logically                    
                </comment>
                <comment line="168">
                    encode the T-upple with the specified offset                    
                </comment>
                <declaration name="msb" type="int" line="134"/>
                <scope line="139">
                    <scope line="140">
                        <scope line="141"/>
                        <scope line="143"/>
                    </scope>
                    <scope line="146"/>
                    <scope line="148">
                        <declaration name="b" type="long" line="149"/>
                        <declaration name="m" type="long" line="150"/>
                        <scope line="151">
                            <declaration name="e" type="int" line="152"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="159"/>
                <scope line="166"/>
                <scope line="169"/>
            </method>
            <javadoc line="177">
                Encode the T-uple with a given offset.                
                <param>
                    minOffset minimal scale of the offset to add to all
                      components (must be greater than the MSBs of all components)                    
                </param>
            </javadoc>
            <method name="encode" type="void" line="181">
                <params>
                    <param name="minOffset" type="int"/>
                </params>
                <comment line="184">
                    choose an offset with some margins                    
                </comment>
                <comment line="189">
                    the components are all zeroes                    
                </comment>
                <comment line="193">
                    allocate an integer array to encode the components (we use only
                     63 bits per element because there is no unsigned long in Java)                    
                </comment>
                <comment line="199">
                    mix the bits from all components                    
                </comment>
                <scope line="187"/>
                <declaration name="neededBits" type="int" line="194"/>
                <declaration name="neededLongs" type="int" line="195"/>
                <declaration name="eIndex" type="int" line="199"/>
                <declaration name="shift" type="int" line="200"/>
                <declaration name="word" type="long" line="201"/>
                <scope line="202">
                    <scope line="203">
                        <scope line="204"/>
                        <scope line="207"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="217">
                Compares this ordered T-uple with the specified object.
                  &lt;p&gt;The ordering method is detailed in the general description of
                  the class. Its main property is to be consistent with distance:
                  geometrically close T-uples stay close to each other when stored
                  in a sorted collection using this comparison method.&lt;/p&gt;
                  &lt;p&gt;T-uples with negative infinite, positive infinite are sorted
                  logically.&lt;/p&gt;
                  &lt;p&gt;Some arbitrary choices have been made to handle specific
                  cases. The rationale for these choices is to keep
                  &lt;em&gt;normal&lt;/em&gt; and consistent T-uples together.&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;instances with different dimensions are sorted according to
                  their dimension regardless of their components values&lt;/li&gt;
                  &lt;li&gt;instances with {@code Double.NaN} components are sorted
                  after all other ones (evan after instances with positive infinite
                  components&lt;/li&gt;
                  &lt;li&gt;instances with both positive and negative infinite components
                  are considered as if they had {@code Double.NaN}components&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    ot T-uple to compare instance with                    
                </param>
                <return>
                    a negative integer if the instance is less than the
                      object, zero if they are equal, or a positive integer if the
                      instance is greater than the object                    
                </return>
            </javadoc>
            <method name="compareTo" type="int" line="247">
                <params>
                    <param name="ot" type="OrderedTuple"/>
                </params>
                <scope line="248">
                    <scope line="249"/>
                    <scope line="251"/>
                    <scope line="253"/>
                    <scope line="255"/>
                    <scope line="257">
                        <scope line="259"/>
                        <scope line="261"/>
                        <declaration name="limit" type="int" line="265"/>
                        <scope line="266">
                            <scope line="267"/>
                            <scope line="269"/>
                        </scope>
                        <scope line="274"/>
                        <scope line="276"/>
                        <scope line="278"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="289">
                {@inheritDoc}                
            </javadoc>
            <method name="equals" type="boolean" line="291">
                <params>
                    <param name="other" type="Object"/>
                </params>
                <scope line="292"/>
                <scope line="294"/>
                <scope line="296"/>
            </method>
            <javadoc line="301">
                {@inheritDoc}                
            </javadoc>
            <method name="hashCode" type="int" line="303">
                <comment line="305">
                    the following constants are arbitrary small primes                    
                </comment>
                <comment line="310">
                    hash fields and combine them
                     (we rely on the multiplier to have different combined weights
                      for all int fields and all boolean fields)                    
                </comment>
                <declaration name="multiplier" type="int" line="305"/>
                <declaration name="trueHash" type="int" line="306"/>
                <declaration name="falseHash" type="int" line="307"/>
                <declaration name="hash" type="int" line="312"/>
            </method>
            <javadoc line="323">
                Get the components array.                
                <return>
                    array containing the T-uple components                    
                </return>
            </javadoc>
            <method name="getComponents" type="double[]" line="326"/>
            <javadoc line="330">
                Extract the sign from the bits of a double.                
                <param>
                    bits binary representation of the double                    
                </param>
                <return>
                    sign bit (zero if positive, non zero if negative)                    
                </return>
            </javadoc>
            <method name="sign" type="long" line="334">
                <params>
                    <param name="bits" type="long"/>
                </params>
            </method>
            <javadoc line="338">
                Extract the exponent from the bits of a double.                
                <param>
                    bits binary representation of the double                    
                </param>
                <return>
                    exponent                    
                </return>
            </javadoc>
            <method name="exponent" type="int" line="342">
                <params>
                    <param name="bits" type="long"/>
                </params>
            </method>
            <javadoc line="346">
                Extract the mantissa from the bits of a double.                
                <param>
                    bits binary representation of the double                    
                </param>
                <return>
                    mantissa                    
                </return>
            </javadoc>
            <method name="mantissa" type="long" line="350">
                <params>
                    <param name="bits" type="long"/>
                </params>
                <comment line="353">
                    subnormal number                    
                </comment>
                <comment line="354">
                    normal number                    
                </comment>
            </method>
            <javadoc line="356">
                Compute the most significant bit of a long.                
                <param>
                    l long from which the most significant bit is requested                    
                </param>
                <return>
                    scale of the most significant bit of {@code l},
                      or 0 if {@code l} is zero                    
                </return>
                <see>
                    #computeLSB                    
                </see>
            </javadoc>
            <method name="computeMSB" type="int" line="362">
                <params>
                    <param name="l" type="long"/>
                </params>
                <declaration name="ll" type="long" line="364"/>
                <declaration name="mask" type="long" line="365"/>
                <declaration name="scale" type="int" line="366"/>
                <declaration name="msb" type="int" line="367"/>
                <scope line="369">
                    <scope line="370"/>
                </scope>
            </method>
            <javadoc line="382">
                Compute the least significant bit of a long.                
                <param>
                    l long from which the least significant bit is requested                    
                </param>
                <return>
                    scale of the least significant bit of {@code l},
                      or 63 if {@code l} is zero                    
                </return>
                <see>
                    #computeMSB                    
                </see>
            </javadoc>
            <method name="computeLSB" type="int" line="388">
                <params>
                    <param name="l" type="long"/>
                </params>
                <declaration name="ll" type="long" line="390"/>
                <declaration name="mask" type="long" line="391"/>
                <declaration name="scale" type="int" line="392"/>
                <declaration name="lsb" type="int" line="393"/>
                <scope line="395">
                    <scope line="396"/>
                </scope>
            </method>
            <javadoc line="408">
                Get a bit from the mantissa of a double.                
                <param>
                    i index of the component                    
                </param>
                <param>
                    k scale of the requested bit                    
                </param>
                <return>
                    the specified bit (either 0 or 1), after the offset has
                      been added to the double                    
                </return>
            </javadoc>
            <method name="getBit" type="int" line="414">
                <params>
                    <param name="i" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <declaration name="bits" type="long" line="415"/>
                <declaration name="e" type="int" line="416"/>
                <scope line="417"/>
                <scope line="419"/>
                <scope line="421"/>
                <scope line="423">
                    <declaration name="m" type="long" line="424"/>
                </scope>
            </method>
        </class>
    </source>