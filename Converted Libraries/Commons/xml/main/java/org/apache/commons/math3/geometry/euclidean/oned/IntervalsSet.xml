<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.euclidean.oned">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.geometry.partitioning.AbstractRegion"/>
        <import package="org.apache.commons.math3.geometry.partitioning.BSPTree"/>
        <import package="org.apache.commons.math3.geometry.partitioning.SubHyperplane"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <class name="IntervalsSet" line="28">
            <extends class="AbstractRegion">
                <type_params>
                    <type_param name="Euclidean1D"/>
                    <type_param name="Euclidean1D"/>
                </type_params>
            </extends>
            <javadoc line="28">
                This class represents a 1D region: a set of intervals.                
                <version>
                    $Id: IntervalsSet.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <javadoc line="34">
                Build an intervals set representing the whole real line.                
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="36"/>
            <javadoc line="40">
                Build an intervals set corresponding to a single interval.                
                <param>
                    lower lower bound of the interval, must be lesser or equal
                      to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})                    
                </param>
                <param>
                    upper upper bound of the interval, must be greater or equal
                      to {@code lower} (may be {@code Double.POSITIVE_INFINITY})                    
                </param>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="46">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
            </method>
            <javadoc line="50">
                Build an intervals set from an inside/outside BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the intervals set                    
                </param>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="59">
                <params>
                    <param name="tree" type="BSPTree<Euclidean1D>"/>
                </params>
            </method>
            <javadoc line="63">
                Build an intervals set from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoints polyhedrons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements                    
                </param>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="82">
                <params>
                    <param name="boundary" type="Collection<SubHyperplane<Euclidean1D>>"/>
                </params>
            </method>
            <javadoc line="86">
                Build an inside/outside tree representing a single interval.                
                <param>
                    lower lower bound of the interval, must be lesser or equal
                      to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})                    
                </param>
                <param>
                    upper upper bound of the interval, must be greater or equal
                      to {@code lower} (may be {@code Double.POSITIVE_INFINITY})                    
                </param>
                <return>
                    the built tree                    
                </return>
            </javadoc>
            <method name="buildTree" type="BSPTree<Euclidean1D>" line="93">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <comment line="96">
                    the tree must cover the whole real line                    
                </comment>
                <comment line="99">
                    the tree must be open on the negative infinity side                    
                </comment>
                <comment line="110">
                    the tree must be open on the positive infinity side                    
                </comment>
                <comment line="117">
                    the tree must be bounded on the two sides                    
                </comment>
                <scope line="94">
                    <scope line="95"/>
                    <declaration name="upperCut" type="SubHyperplane&lt;Euclidean1D&gt;" line="100"/>
                </scope>
                <declaration name="lowerCut" type="SubHyperplane&lt;Euclidean1D&gt;" line="107"/>
                <scope line="109"/>
                <declaration name="upperCut" type="SubHyperplane&lt;Euclidean1D&gt;" line="118"/>
            </method>
            <javadoc line="130">
                {@inheritDoc}                
            </javadoc>
            <method name="buildNew" type="IntervalsSet" line="132">
                <params>
                    <param name="tree" type="BSPTree<Euclidean1D>"/>
                </params>
            </method>
            <javadoc line="136">
                {@inheritDoc}                
            </javadoc>
            <method name="computeGeometricalProperties" type="void" line="138">
                <scope line="139"/>
                <scope line="142">
                    <declaration name="size" type="double" line="143"/>
                    <declaration name="sum" type="double" line="144"/>
                    <scope line="145"/>
                    <scope line="150"/>
                    <scope line="152"/>
                    <scope line="154"/>
                </scope>
            </method>
            <javadoc line="160">
                Get the lowest value belonging to the instance.                
                <return>
                    lowest value belonging to the instance
                      ({@code Double.NEGATIVE_INFINITY} if the instance doesn't
                      have any low bound, {@code Double.POSITIVE_INFINITY} if the
                      instance is empty)                    
                </return>
            </javadoc>
            <method name="getInf" type="double" line="166">
                <declaration name="node" type="BSPTree&lt;Euclidean1D&gt;" line="167"/>
                <declaration name="inf" type="double" line="168"/>
                <scope line="169">
                    <declaration name="op" type="OrientedPoint" line="170"/>
                </scope>
            </method>
            <javadoc line="177">
                Get the highest value belonging to the instance.                
                <return>
                    highest value belonging to the instance
                      ({@code Double.POSITIVE_INFINITY} if the instance doesn't
                      have any high bound, {@code Double.NEGATIVE_INFINITY} if the
                      instance is empty)                    
                </return>
            </javadoc>
            <method name="getSup" type="double" line="183">
                <declaration name="node" type="BSPTree&lt;Euclidean1D&gt;" line="184"/>
                <declaration name="sup" type="double" line="185"/>
                <scope line="186">
                    <declaration name="op" type="OrientedPoint" line="187"/>
                </scope>
            </method>
            <javadoc line="194">
                Build an ordered list of intervals representing the instance.
                  &lt;p&gt;This method builds this intervals set as an ordered list of{@link Interval Interval} elements. If the intervals set has no
                  lower limit, the first interval will have its low bound equal to{@code Double.NEGATIVE_INFINITY}. If the intervals set has
                  no upper limit, the last interval will have its upper bound equal
                  to {@code Double.POSITIVE_INFINITY}. An empty tree will
                  build an empty list while a tree representing the whole real line
                  will build a one element list with both bounds beeing
                  infinite.&lt;/p&gt;                
                <return>
                    a new ordered list containing {@link Interval Interval}elements                    
                </return>
            </javadoc>
            <method name="asList" type="List<Interval>" line="207">
                <declaration name="list" type="List&lt;Interval&gt;" line="208"/>
            </method>
            <javadoc line="214">
                Update an intervals list.                
                <param>
                    node current node                    
                </param>
                <param>
                    list list to update                    
                </param>
                <param>
                    lower lower bound of the current convex cell                    
                </param>
                <param>
                    upper upper bound of the current convex cell                    
                </param>
            </javadoc>
            <method name="recurseList" type="void" line="222">
                <params>
                    <param name="node" type="BSPTree<Euclidean1D>"/>
                    <param name="list" type="List<Interval>"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <comment line="226">
                    this leaf cell is an inside cell: an interval                    
                </comment>
                <comment line="234">
                    make sure we explore the tree in increasing order                    
                </comment>
                <comment line="243">
                    merge the last interval added and the first one of the high sub-tree                    
                </comment>
                <scope line="224">
                    <scope line="225"/>
                </scope>
                <scope line="229">
                    <declaration name="op" type="OrientedPoint" line="230"/>
                    <declaration name="loc" type="Vector1D" line="231"/>
                    <declaration name="x" type="double" line="232"/>
                    <declaration name="low" type="BSPTree&lt;Euclidean1D&gt;" line="235"/>
                    <declaration name="high" type="BSPTree&lt;Euclidean1D&gt;" line="237"/>
                    <scope line="242"/>
                </scope>
            </method>
        </class>
    </source>