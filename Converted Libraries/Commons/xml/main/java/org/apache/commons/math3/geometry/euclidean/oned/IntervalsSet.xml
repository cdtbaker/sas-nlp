<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.euclidean.oned">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="org.apache.commons.math3.geometry.Point"/>
        <import package="org.apache.commons.math3.geometry.partitioning.AbstractRegion"/>
        <import package="org.apache.commons.math3.geometry.partitioning.BSPTree"/>
        <import package="org.apache.commons.math3.geometry.partitioning.BoundaryProjection"/>
        <import package="org.apache.commons.math3.geometry.partitioning.SubHyperplane"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <class name="IntervalsSet" line="32">
            <extends class="AbstractRegion">
                <type_params>
                    <type_param name="Euclidean1D"/>
                    <type_param name="Euclidean1D"/>
                </type_params>
            </extends>
            <implements interface="Iterable">
                <type_params>
                    <type_param name="double[]"/>
                </type_params>
            </implements>
            <javadoc line="32">
                This class represents a 1D region: a set of intervals.                
                <version>
                    $Id: IntervalsSet.java 1563714 2014-02-02 20:55:14Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="DEFAULT_TOLERANCE" type="double" line="38"/>
            <javadoc line="38">
                Default value for tolerance.                
            </javadoc>
            <javadoc line="41">
                Build an intervals set representing the whole real line.                
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="45">
                <params>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="49">
                Build an intervals set corresponding to a single interval.                
                <param>
                    lower lower bound of the interval, must be lesser or equal
                      to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})                    
                </param>
                <param>
                    upper upper bound of the interval, must be greater or equal
                      to {@code lower} (may be {@code Double.POSITIVE_INFINITY})                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="57">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="61">
                Build an intervals set from an inside/outside BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the intervals set                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="72">
                <params>
                    <param name="tree" type="BSPTree&lt;Euclidean1D&gt;"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="76">
                Build an intervals set from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoints polyhedrons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="98">
                <params>
                    <param name="boundary" type="Collection&lt;SubHyperplane&lt;Euclidean1D&gt;&gt;"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="102">
                Build an intervals set representing the whole real line.                
                <deprecated>
                    as of 3.1 replaced with {@link #IntervalsSet(double)}                    
                </deprecated>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="106"/>
            <javadoc line="110">
                Build an intervals set corresponding to a single interval.                
                <param>
                    lower lower bound of the interval, must be lesser or equal
                      to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})                    
                </param>
                <param>
                    upper upper bound of the interval, must be greater or equal
                      to {@code lower} (may be {@code Double.POSITIVE_INFINITY})                    
                </param>
                <deprecated>
                    as of 3.3 replaced with {@link #IntervalsSet(double,double,double)}                    
                </deprecated>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="118">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
            </method>
            <javadoc line="122">
                Build an intervals set from an inside/outside BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the intervals set                    
                </param>
                <deprecated>
                    as of 3.3, replaced with {@link #IntervalsSet(BSPTree,double)}                    
                </deprecated>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="133">
                <params>
                    <param name="tree" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
            </method>
            <javadoc line="137">
                Build an intervals set from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoints polyhedrons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)checkPoint} method will not be meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements                    
                </param>
                <deprecated>
                    as of 3.3, replaced with {@link #IntervalsSet(Collection,double)}                    
                </deprecated>
            </javadoc>
            <method name="IntervalsSet" type="constructor" line="158">
                <params>
                    <param name="boundary" type="Collection&lt;SubHyperplane&lt;Euclidean1D&gt;&gt;"/>
                </params>
            </method>
            <javadoc line="162">
                Build an inside/outside tree representing a single interval.                
                <param>
                    lower lower bound of the interval, must be lesser or equal
                      to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})                    
                </param>
                <param>
                    upper upper bound of the interval, must be greater or equal
                      to {@code lower} (may be {@code Double.POSITIVE_INFINITY})                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
                <return>
                    the built tree                    
                </return>
            </javadoc>
            <method name="buildTree" type="BSPTree&lt;Euclidean1D&gt;" line="171">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                    <param name="tolerance" type="double"/>
                </params>
                <comment line="175">
                    the tree must cover the whole real line                    
                </comment>
                <comment line="178">
                    the tree must be open on the negative infinity side                    
                </comment>
                <comment line="189">
                    the tree must be open on the positive infinity side                    
                </comment>
                <comment line="196">
                    the tree must be bounded on the two sides                    
                </comment>
                <scope line="172">
                    <scope line="173"/>
                    <declaration name="upperCut" type="SubHyperplane&amp;lt;Euclidean1D&amp;gt;" line="178"/>
                </scope>
                <declaration name="lowerCut" type="SubHyperplane&amp;lt;Euclidean1D&amp;gt;" line="185"/>
                <scope line="187"/>
                <declaration name="upperCut" type="SubHyperplane&amp;lt;Euclidean1D&amp;gt;" line="196"/>
            </method>
            <javadoc line="208">
                {@inheritDoc}                
            </javadoc>
            <method name="buildNew" type="IntervalsSet" line="210">
                <params>
                    <param name="tree" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
            </method>
            <javadoc line="214">
                {@inheritDoc}                
            </javadoc>
            <method name="computeGeometricalProperties" type="void" line="216">
                <scope line="217"/>
                <scope line="220">
                    <declaration name="size" type="double" line="221"/>
                    <declaration name="sum" type="double" line="222"/>
                    <scope line="223"/>
                    <scope line="228"/>
                    <scope line="230"/>
                    <scope line="232"/>
                </scope>
            </method>
            <javadoc line="238">
                Get the lowest value belonging to the instance.                
                <return>
                    lowest value belonging to the instance
                      ({@code Double.NEGATIVE_INFINITY} if the instance doesn&apos;t
                      have any low bound, {@code Double.POSITIVE_INFINITY} if the
                      instance is empty)                    
                </return>
            </javadoc>
            <method name="getInf" type="double" line="244">
                <declaration name="node" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="245"/>
                <declaration name="inf" type="double" line="246"/>
                <scope line="247">
                    <declaration name="op" type="OrientedPoint" line="248"/>
                </scope>
            </method>
            <javadoc line="255">
                Get the highest value belonging to the instance.                
                <return>
                    highest value belonging to the instance
                      ({@code Double.POSITIVE_INFINITY} if the instance doesn&apos;t
                      have any high bound, {@code Double.NEGATIVE_INFINITY} if the
                      instance is empty)                    
                </return>
            </javadoc>
            <method name="getSup" type="double" line="261">
                <declaration name="node" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="262"/>
                <declaration name="sup" type="double" line="263"/>
                <scope line="264">
                    <declaration name="op" type="OrientedPoint" line="265"/>
                </scope>
            </method>
            <javadoc line="272">
                {@inheritDoc}                
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="projectToBoundary" type="BoundaryProjection&lt;Euclidean1D&gt;" line="276">
                <params>
                    <param name="point" type="Point&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="279">
                    get position of test point                    
                </comment>
                <comment line="285">
                    the test point lies between the previous and the current intervals
                     offset will be positive                    
                </comment>
                <comment line="295">
                    the test point lies within the current interval
                     offset will be negative                    
                </comment>
                <comment line="308">
                    the test point if past the last sub-interval                    
                </comment>
                <declaration name="x" type="double" line="279"/>
                <declaration name="previous" type="double" line="281"/>
                <scope line="282">
                    <scope line="283">
                        <declaration name="previousOffset" type="double" line="286"/>
                        <declaration name="currentOffset" type="double" line="287"/>
                        <scope line="288"/>
                        <scope line="290"/>
                    </scope>
                    <scope line="293">
                        <declaration name="offset0" type="double" line="296"/>
                        <declaration name="offset1" type="double" line="297"/>
                        <scope line="298"/>
                        <scope line="300"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="312">
                Build a finite point.                
                <param>
                    x abscissa of the point                    
                </param>
                <return>
                    a new point for finite abscissa, null otherwise                    
                </return>
            </javadoc>
            <method name="finiteOrNullPoint" type="Vector1D" line="316">
                <params>
                    <param name="x" type="double"/>
                </params>
            </method>
            <javadoc line="320">
                Build an ordered list of intervals representing the instance.
                  &lt;p&gt;This method builds this intervals set as an ordered list of{@link Interval Interval} elements. If the intervals set has no
                  lower limit, the first interval will have its low bound equal to{@code Double.NEGATIVE_INFINITY}. If the intervals set has
                  no upper limit, the last interval will have its upper bound equal
                  to {@code Double.POSITIVE_INFINITY}. An empty tree will
                  build an empty list while a tree representing the whole real line
                  will build a one element list with both bounds being
                  infinite.&lt;/p&gt;                
                <return>
                    a new ordered list containing {@link Interval Interval}elements                    
                </return>
            </javadoc>
            <method name="asList" type="List&lt;Interval&gt;" line="333">
                <declaration name="list" type="List&amp;lt;Interval&amp;gt;" line="334"/>
                <scope line="335"/>
            </method>
            <javadoc line="341">
                Get the first leaf node of a tree.                
                <param>
                    root tree root                    
                </param>
                <return>
                    first leaf node                    
                </return>
            </javadoc>
            <method name="getFirstLeaf" type="BSPTree&lt;Euclidean1D&gt;" line="345">
                <params>
                    <param name="root" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="352">
                    find the smallest internal node                    
                </comment>
                <scope line="347"/>
                <declaration name="smallest" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="352"/>
                <scope line="353"/>
            </method>
            <javadoc line="361">
                Get the node corresponding to the first interval boundary.                
                <return>
                    smallest internal node,
                      or null if there are no internal nodes (i.e. the set is either empty or covers the real line)                    
                </return>
            </javadoc>
            <method name="getFirstIntervalBoundary" type="BSPTree&lt;Euclidean1D&gt;" line="365">
                <comment line="368">
                    start search at the tree root                    
                </comment>
                <comment line="374">
                    walk tree until we find the smallest internal node                    
                </comment>
                <comment line="377">
                    walk tree until we find an interval boundary                    
                </comment>
                <declaration name="node" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="368"/>
                <scope line="369"/>
                <scope line="377"/>
            </method>
            <javadoc line="385">
                Check if an internal node corresponds to the start abscissa of an interval.                
                <param>
                    node internal node to check                    
                </param>
                <return>
                    true if the node corresponds to the start abscissa of an interval                    
                </return>
            </javadoc>
            <method name="isIntervalStart" type="boolean" line="389">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="393">
                    it has an inside cell before it, it may end an interval but not start it                    
                </comment>
                <comment line="398">
                    it has an outside cell after it, it is a dummy cut away from real intervals                    
                </comment>
                <comment line="402">
                    the cell has an outside before and an inside after it
                     it is the start of an interval                    
                </comment>
                <scope line="391"/>
                <scope line="396"/>
            </method>
            <javadoc line="407">
                Check if an internal node corresponds to the end abscissa of an interval.                
                <param>
                    node internal node to check                    
                </param>
                <return>
                    true if the node corresponds to the end abscissa of an interval                    
                </return>
            </javadoc>
            <method name="isIntervalEnd" type="boolean" line="411">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="415">
                    it has an outside cell before it, it may start an interval but not end it                    
                </comment>
                <comment line="420">
                    it has an inside cell after it, it is a dummy cut in the middle of an interval                    
                </comment>
                <comment line="424">
                    the cell has an inside before and an outside after it
                     it is the end of an interval                    
                </comment>
                <scope line="413"/>
                <scope line="418"/>
            </method>
            <javadoc line="429">
                Get the next internal node.                
                <param>
                    node current internal node                    
                </param>
                <return>
                    next internal node in ascending order, or null
                      if this is the last internal node                    
                </return>
            </javadoc>
            <method name="nextInternalNode" type="BSPTree&lt;Euclidean1D&gt;" line="434">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="438">
                    the next node is in the sub-tree                    
                </comment>
                <comment line="442">
                    there is nothing left deeper in the tree, we backtrack                    
                </comment>
                <scope line="436"/>
                <scope line="442"/>
            </method>
            <javadoc line="449">
                Get the previous internal node.                
                <param>
                    node current internal node                    
                </param>
                <return>
                    previous internal node in ascending order, or null
                      if this is the first internal node                    
                </return>
            </javadoc>
            <method name="previousInternalNode" type="BSPTree&lt;Euclidean1D&gt;" line="454">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="458">
                    the next node is in the sub-tree                    
                </comment>
                <comment line="462">
                    there is nothing left deeper in the tree, we backtrack                    
                </comment>
                <scope line="456"/>
                <scope line="462"/>
            </method>
            <javadoc line="469">
                Find the leaf node just before an internal node.                
                <param>
                    node internal node at which the sub-tree starts                    
                </param>
                <return>
                    leaf node just before the internal node                    
                </return>
            </javadoc>
            <method name="leafBefore" type="BSPTree&lt;Euclidean1D&gt;" line="473">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <scope line="476"/>
            </method>
            <javadoc line="484">
                Find the leaf node just after an internal node.                
                <param>
                    node internal node at which the sub-tree starts                    
                </param>
                <return>
                    leaf node just after the internal node                    
                </return>
            </javadoc>
            <method name="leafAfter" type="BSPTree&lt;Euclidean1D&gt;" line="488">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <scope line="491"/>
            </method>
            <javadoc line="499">
                Check if a node is the child before its parent in ascending order.                
                <param>
                    node child node considered                    
                </param>
                <return>
                    true is the node has a parent end is before it in ascending order                    
                </return>
            </javadoc>
            <method name="isBeforeParent" type="boolean" line="503">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <declaration name="parent" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="504"/>
                <scope line="505"/>
                <scope line="507"/>
            </method>
            <javadoc line="512">
                Check if a node is the child after its parent in ascending order.                
                <param>
                    node child node considered                    
                </param>
                <return>
                    true is the node has a parent end is after it in ascending order                    
                </return>
            </javadoc>
            <method name="isAfterParent" type="boolean" line="516">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <declaration name="parent" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="517"/>
                <scope line="518"/>
                <scope line="520"/>
            </method>
            <javadoc line="525">
                Find the child node just before an internal node.                
                <param>
                    node internal node at which the sub-tree starts                    
                </param>
                <return>
                    child node just before the internal node                    
                </return>
            </javadoc>
            <method name="childBefore" type="BSPTree&lt;Euclidean1D&gt;" line="529">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="532">
                    smaller abscissas are on minus side, larger abscissas are on plus side                    
                </comment>
                <comment line="535">
                    smaller abscissas are on plus side, larger abscissas are on minus side                    
                </comment>
                <scope line="530"/>
                <scope line="533"/>
            </method>
            <javadoc line="539">
                Find the child node just after an internal node.                
                <param>
                    node internal node at which the sub-tree starts                    
                </param>
                <return>
                    child node just after the internal node                    
                </return>
            </javadoc>
            <method name="childAfter" type="BSPTree&lt;Euclidean1D&gt;" line="543">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
                <comment line="546">
                    smaller abscissas are on minus side, larger abscissas are on plus side                    
                </comment>
                <comment line="549">
                    smaller abscissas are on plus side, larger abscissas are on minus side                    
                </comment>
                <scope line="544"/>
                <scope line="547"/>
            </method>
            <javadoc line="553">
                Check if an internal node has a direct oriented point.                
                <param>
                    node internal node to check                    
                </param>
                <return>
                    true if the oriented point is direct                    
                </return>
            </javadoc>
            <method name="isDirect" type="boolean" line="557">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
            </method>
            <javadoc line="561">
                Get the abscissa of an internal node.                
                <param>
                    node internal node to check                    
                </param>
                <return>
                    abscissa                    
                </return>
            </javadoc>
            <method name="getAngle" type="double" line="565">
                <params>
                    <param name="node" type="BSPTree&lt;Euclidean1D&gt;"/>
                </params>
            </method>
            <javadoc line="569">
                {@inheritDoc}&lt;p&gt;
                  The iterator returns the limit values of sub-intervals in ascending order.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The iterator does &lt;em&gt;not&lt;/em&gt; support the optional {@code remove} operation.
                  &lt;/p&gt;                
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="iterator" type="Iterator&lt;double[]&gt;" line="578"/>
            <class name="SubIntervalsIterator" line="582">
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="double[]"/>
                    </type_params>
                </implements>
                <javadoc line="582">
                    Local iterator for sub-intervals.                    
                </javadoc>
                <declaration name="current" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="585"/>
                <javadoc line="585">
                    Current node.                    
                </javadoc>
                <declaration name="pending" type="double[]" line="588"/>
                <javadoc line="588">
                    Sub-interval no yet returned.                    
                </javadoc>
                <javadoc line="591">
                    Simple constructor.                    
                </javadoc>
                <method name="SubIntervalsIterator" type="constructor" line="593">
                    <comment line="599">
                        all the leaf tree nodes share the same inside/outside status                        
                    </comment>
                    <comment line="601">
                        it is an inside node, it represents the full real line                        
                    </comment>
                    <comment line="609">
                        the first boundary is an interval end,
                         so the first interval starts at infinity                        
                    </comment>
                    <scope line="597">
                        <scope line="599"/>
                        <scope line="604"/>
                    </scope>
                    <scope line="607"/>
                    <scope line="613"/>
                </method>
                <javadoc line="618">
                    Walk the tree to select the pending sub-interval.                    
                </javadoc>
                <method name="selectPending" type="void" line="620">
                    <comment line="623">
                        look for the start of the interval                        
                    </comment>
                    <comment line="630">
                        we have exhausted the iterator                        
                    </comment>
                    <comment line="636">
                        look for the end of the interval                        
                    </comment>
                    <comment line="644">
                        we have identified the interval                        
                    </comment>
                    <comment line="649">
                        prepare search for next interval                        
                    </comment>
                    <comment line="654">
                        the final interval is open toward infinity                        
                    </comment>
                    <comment line="659">
                        there won&apos;t be any other intervals                        
                    </comment>
                    <declaration name="start" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="623"/>
                    <scope line="624"/>
                    <scope line="628"/>
                    <declaration name="end" type="BSPTree&amp;lt;Euclidean1D&amp;gt;" line="636"/>
                    <scope line="637"/>
                    <scope line="641"/>
                    <scope line="651"/>
                </method>
                <javadoc line="665">
                    {@inheritDoc}                    
                </javadoc>
                <method name="hasNext" type="boolean" line="666"/>
                <javadoc line="670">
                    {@inheritDoc}                    
                </javadoc>
                <method name="next" type="double[]" line="671">
                    <scope line="672"/>
                    <declaration name="next" type="double[]" line="675"/>
                </method>
                <javadoc line="680">
                    {@inheritDoc}                    
                </javadoc>
                <method name="remove" type="void" line="681"/>
            </class>
        </class>
    </source>