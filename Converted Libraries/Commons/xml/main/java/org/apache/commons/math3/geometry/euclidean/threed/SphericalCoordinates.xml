<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.euclidean.threed">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="SphericalCoordinates" line="24">
            <implements interface="Serializable"/>
            <javadoc line="24">
                This class provides conversions related to &lt;a
                  href=&quot;http://mathworld.wolfram.com/SphericalCoordinates.html&quot;&gt;spherical coordinates&lt;/a&gt;.
                  &lt;p&gt;
                  The conventions used here are the mathematical ones, i.e. spherical coordinates are
                  related to Cartesian coordinates as follows:
                  &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;x = r cos(&amp;theta;) sin(&amp;Phi;)&lt;/li&gt;
                  &lt;li&gt;y = r sin(&amp;theta;) sin(&amp;Phi;)&lt;/li&gt;
                  &lt;li&gt;z = r cos(&amp;Phi;)&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;ul&gt;
                  &lt;li&gt;r       = &amp;radic;(x&lt;sup&gt;2&lt;/sup&gt;+y&lt;sup&gt;2&lt;/sup&gt;+z&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
                  &lt;li&gt;&amp;theta; = atan2(y, x)&lt;/li&gt;
                  &lt;li&gt;&amp;Phi;   = acos(z/r)&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;
                  r is the radius, &amp;theta; is the azimuthal angle in the x-y plane and &amp;Phi; is the polar
                  (co-latitude) angle. These conventions are &lt;em&gt;different&lt;/em&gt; from the conventions used
                  in physics (and in particular in spherical harmonics) where the meanings of &amp;theta; and
                  &amp;Phi; are reversed.
                  &lt;/p&gt;
                  &lt;p&gt;
                  This class provides conversion of coordinates and also of gradient and Hessian
                  between spherical and Cartesian coordinates.
                  &lt;/p&gt;                
                <since>
                    3.2                    
                </since>
                <version>
                    $Id: SphericalCoordinates.java 1443364 2013-02-07 09:28:04Z luc $                    
                </version>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="55"/>
            <javadoc line="55">
                Serializable UID.                
            </javadoc>
            <declaration name="v" type="Vector3D" line="58"/>
            <javadoc line="58">
                Cartesian coordinates.                
            </javadoc>
            <declaration name="r" type="double" line="61"/>
            <javadoc line="61">
                Radius.                
            </javadoc>
            <declaration name="theta" type="double" line="64"/>
            <javadoc line="64">
                Azimuthal angle in the x-y plane &amp;theta;.                
            </javadoc>
            <declaration name="phi" type="double" line="67"/>
            <javadoc line="67">
                Polar angle (co-latitude) &amp;Phi;.                
            </javadoc>
            <declaration name="jacobian" type="double[][]" line="70"/>
            <javadoc line="70">
                Jacobian of (r, &amp;theta; &amp;Phi).                
            </javadoc>
            <declaration name="rHessian" type="double[][]" line="73"/>
            <javadoc line="73">
                Hessian of radius.                
            </javadoc>
            <declaration name="thetaHessian" type="double[][]" line="76"/>
            <javadoc line="76">
                Hessian of azimuthal angle in the x-y plane &amp;theta;.                
            </javadoc>
            <declaration name="phiHessian" type="double[][]" line="79"/>
            <javadoc line="79">
                Hessian of polar (co-latitude) angle &amp;Phi;.                
            </javadoc>
            <javadoc line="82">
                Build a spherical coordinates transformer from Cartesian coordinates.                
                <param>
                    v Cartesian coordinates                    
                </param>
            </javadoc>
            <method name="SphericalCoordinates" type="constructor" line="85">
                <params>
                    <param name="v" type="Vector3D"/>
                </params>
                <comment line="87">
                    Cartesian coordinates                    
                </comment>
                <comment line="90">
                    remaining spherical coordinates                    
                </comment>
            </method>
            <javadoc line="97">
                Build a spherical coordinates transformer from spherical coordinates.                
                <param>
                    r radius                    
                </param>
                <param>
                    theta azimuthal angle in x-y plane                    
                </param>
                <param>
                    phi polar (co-latitude) angle                    
                </param>
            </javadoc>
            <method name="SphericalCoordinates" type="constructor" line="102">
                <params>
                    <param name="r" type="double"/>
                    <param name="theta" type="double"/>
                    <param name="phi" type="double"/>
                </params>
                <comment line="109">
                    spherical coordinates                    
                </comment>
                <comment line="114">
                    Cartesian coordinates                    
                </comment>
                <declaration name="cosTheta" type="double" line="104"/>
                <declaration name="sinTheta" type="double" line="105"/>
                <declaration name="cosPhi" type="double" line="106"/>
                <declaration name="sinPhi" type="double" line="107"/>
            </method>
            <javadoc line="121">
                Get the Cartesian coordinates.                
                <return>
                    Cartesian coordinates                    
                </return>
            </javadoc>
            <method name="getCartesian" type="Vector3D" line="124"/>
            <javadoc line="128">
                Get the radius.                
                <return>
                    radius r                    
                </return>
                <see>
                    #getTheta()                    
                </see>
                <see>
                    #getPhi()                    
                </see>
            </javadoc>
            <method name="getR" type="double" line="133"/>
            <javadoc line="137">
                Get the azimuthal angle in x-y plane.                
                <return>
                    azimuthal angle in x-y plane &theta;                    
                </return>
                <see>
                    #getR()                    
                </see>
                <see>
                    #getPhi()                    
                </see>
            </javadoc>
            <method name="getTheta" type="double" line="142"/>
            <javadoc line="146">
                Get the polar (co-latitude) angle.                
                <return>
                    polar (co-latitude) angle &Phi;                    
                </return>
                <see>
                    #getR()                    
                </see>
                <see>
                    #getTheta()                    
                </see>
            </javadoc>
            <method name="getPhi" type="double" line="151"/>
            <javadoc line="155">
                Convert a gradient with respect to spherical coordinates into a gradient
                  with respect to Cartesian coordinates.                
                <param>
                    sGradient gradient with respect to spherical coordinates
                      {df/dr, df/d&theta;, df/d&Phi;}                    
                </param>
                <return>
                    gradient with respect to Cartesian coordinates
                      {df/dx, df/dy, df/dz}                    
                </return>
            </javadoc>
            <method name="toCartesianGradient" type="double[]" line="162">
                <params>
                    <param name="sGradient" type="double[]"/>
                </params>
                <comment line="164">
                    lazy evaluation of Jacobian                    
                </comment>
                <comment line="167">
                    compose derivatives as gradient^T . J                    
                </comment>
                <comment line="168">
                    the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0                    
                </comment>
            </method>
            <javadoc line="177">
                Convert a Hessian with respect to spherical coordinates into a Hessian
                  with respect to Cartesian coordinates.
                  &lt;p&gt;
                  As Hessian are always symmetric, we use only the lower left part of the provided
                  spherical Hessian, so the upper part may not be initialized. However, we still
                  do fill up the complete array we create, with guaranteed symmetry.
                  &lt;/p&gt;                
                <param>
                    sHessian Hessian with respect to spherical coordinates
                      {{d<sup>2</sup>f/dr<sup>2</sup>, d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/drd&Phi;},
                      {d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/d&theta;<sup>2</sup>, d<sup>2</sup>f/d&theta;d&Phi;},
                      {d<sup>2</sup>f/drd&Phi;, d<sup>2</sup>f/d&theta;d&Phi;, d<sup>2</sup>f/d&Phi;<sup>2</sup>}                    
                </param>
                <param>
                    sGradient gradient with respect to spherical coordinates
                      {df/dr, df/d&theta;, df/d&Phi;}                    
                </param>
                <return>
                    Hessian with respect to Cartesian coordinates
                      {{d<sup>2</sup>f/dx<sup>2</sup>, d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dxdz},
                      {d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dy<sup>2</sup>, d<sup>2</sup>f/dydz},
                      {d<sup>2</sup>f/dxdz, d<sup>2</sup>f/dydz, d<sup>2</sup>f/dz<sup>2</sup>}}                    
                </return>
            </javadoc>
            <method name="toCartesianHessian" type="double[][]" line="195">
                <params>
                    <param name="sHessian" type="double[][]"/>
                    <param name="sGradient" type="double[]"/>
                </params>
                <comment line="200">
                    compose derivative as J^T . H_f . J + df/dr H_r + df/dtheta H_theta + df/dphi H_phi                    
                </comment>
                <comment line="201">
                    the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0                    
                </comment>
                <comment line="202">
                    and H_theta is only a 2x2 matrix as it does not depend on z                    
                </comment>
                <comment line="206">
                    compute H_f . J                    
                </comment>
                <comment line="207">
                    beware we use ONLY the lower-left part of sHessian                    
                </comment>
                <comment line="213">
                    don&apos;t compute hj[1][2] as it is not used below                    
                </comment>
                <comment line="218">
                    compute lower-left part of J^T . H_f . J                    
                </comment>
                <comment line="226">
                    add gradient contribution                    
                </comment>
                <comment line="234">
                    ensure symmetry                    
                </comment>
                <declaration name="hj" type="double[][]" line="203"/>
                <declaration name="cHessian" type="double[][]" line="204"/>
            </method>
            <javadoc line="243">
                Lazy evaluation of (r, &amp;theta;, &amp;phi;) Jacobian.                
            </javadoc>
            <method name="computeJacobian" type="void" line="245">
                <comment line="248">
                    intermediate variables                    
                </comment>
                <comment line="258">
                    row representing the gradient of r                    
                </comment>
                <comment line="263">
                    row representing the gradient of theta                    
                </comment>
                <comment line="266">
                    jacobian[1][2] is already set to 0 at allocation time                    
                </comment>
                <comment line="268">
                    row representing the gradient of phi                    
                </comment>
                <scope line="246">
                    <declaration name="x" type="double" line="249"/>
                    <declaration name="y" type="double" line="250"/>
                    <declaration name="z" type="double" line="251"/>
                    <declaration name="rho2" type="double" line="252"/>
                    <declaration name="rho" type="double" line="253"/>
                    <declaration name="r2" type="double" line="254"/>
                </scope>
            </method>
            <javadoc line="276">
                Lazy evaluation of Hessians.                
            </javadoc>
            <method name="computeHessians" type="void" line="278">
                <comment line="282">
                    intermediate variables                    
                </comment>
                <comment line="301">
                    lower-left part of Hessian of r                    
                </comment>
                <comment line="310">
                    upper-right part is symmetric                    
                </comment>
                <comment line="315">
                    lower-left part of Hessian of azimuthal angle theta                    
                </comment>
                <comment line="321">
                    upper-right part is symmetric                    
                </comment>
                <comment line="324">
                    lower-left part of Hessian of polar (co-latitude) angle phi                    
                </comment>
                <comment line="338">
                    upper-right part is symmetric                    
                </comment>
                <scope line="280">
                    <declaration name="x" type="double" line="283"/>
                    <declaration name="y" type="double" line="284"/>
                    <declaration name="z" type="double" line="285"/>
                    <declaration name="x2" type="double" line="286"/>
                    <declaration name="y2" type="double" line="287"/>
                    <declaration name="z2" type="double" line="288"/>
                    <declaration name="rho2" type="double" line="289"/>
                    <declaration name="rho" type="double" line="290"/>
                    <declaration name="r2" type="double" line="291"/>
                    <declaration name="xOr" type="double" line="292"/>
                    <declaration name="yOr" type="double" line="293"/>
                    <declaration name="zOr" type="double" line="294"/>
                    <declaration name="xOrho2" type="double" line="295"/>
                    <declaration name="yOrho2" type="double" line="296"/>
                    <declaration name="xOr3" type="double" line="297"/>
                    <declaration name="yOr3" type="double" line="298"/>
                    <declaration name="zOr3" type="double" line="299"/>
                    <declaration name="rhor2" type="double" line="325"/>
                    <declaration name="rho2r2" type="double" line="326"/>
                    <declaration name="rhor4" type="double" line="327"/>
                    <declaration name="rho3r4" type="double" line="328"/>
                    <declaration name="r2P2rho2" type="double" line="329"/>
                </scope>
            </method>
            <javadoc line="347">
                Replace the instance with a data transfer object for serialization.                
                <return>
                    data transfer object that will be serialized                    
                </return>
            </javadoc>
            <method name="writeReplace" type="Object" line="351"/>
            <class name="DataTransferObject" line="355">
                <implements interface="Serializable"/>
                <javadoc line="355">
                    Internal class used only for serialization.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="358"/>
                <javadoc line="358">
                    Serializable UID.                    
                </javadoc>
                <declaration name="x" type="double" line="361"/>
                <javadoc line="361">
                    Abscissa.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <declaration name="y" type="double" line="366"/>
                <javadoc line="366">
                    Ordinate.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <declaration name="z" type="double" line="371"/>
                <javadoc line="371">
                    Height.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <javadoc line="376">
                    Simple constructor.                    
                    <param>
                        x abscissa                        
                    </param>
                    <param>
                        y ordinate                        
                    </param>
                    <param>
                        z height                        
                    </param>
                </javadoc>
                <method name="DataTransferObject" type="constructor" line="381">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                        <param name="z" type="double"/>
                    </params>
                </method>
                <javadoc line="387">
                    Replace the deserialized data transfer object with a {@link SphericalCoordinates}.                    
                    <return>
                        replacement {@link SphericalCoordinates}                        
                    </return>
                </javadoc>
                <method name="readResolve" type="Object" line="390"/>
            </class>
        </class>
    </source>