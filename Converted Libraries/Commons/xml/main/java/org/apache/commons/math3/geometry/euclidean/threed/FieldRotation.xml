<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.euclidean.threed">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.RealFieldElement"/>
        <import package="org.apache.commons.math3.Field"/>
        <import package="org.apache.commons.math3.exception.MathArithmeticException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathArrays"/>
        <class name="FieldRotation" line="30">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <implements interface="Serializable"/>
            <javadoc line="30">
                This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.
                  &lt;p&gt;Instance of this class are guaranteed to be immutable.&lt;/p&gt;                
                <param>
                    <T>
                       the type of the field elements                    
                </param>
                <version>
                    $Id: FieldRotation.java 1454903 2013-03-10 19:44:31Z luc $                    
                </version>
                <see>
                    FieldVector3D                    
                </see>
                <see>
                    RotationOrder                    
                </see>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="43"/>
            <javadoc line="43">
                Serializable version identifier                
            </javadoc>
            <declaration name="q0" type="T" line="46"/>
            <javadoc line="46">
                Scalar coordinate of the quaternion.                
            </javadoc>
            <declaration name="q1" type="T" line="49"/>
            <javadoc line="49">
                First coordinate of the vectorial part of the quaternion.                
            </javadoc>
            <declaration name="q2" type="T" line="52"/>
            <javadoc line="52">
                Second coordinate of the vectorial part of the quaternion.                
            </javadoc>
            <declaration name="q3" type="T" line="55"/>
            <javadoc line="55">
                Third coordinate of the vectorial part of the quaternion.                
            </javadoc>
            <javadoc line="58">
                Build a rotation from the quaternion coordinates.
                  &lt;p&gt;A rotation can be built from a &lt;em&gt;normalized&lt;/em&gt; quaternion,
                  i.e. a quaternion for which q&lt;sub&gt;0&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
                  q&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; + q&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; +
                  q&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. If the quaternion is not normalized,
                  the constructor can normalize it in a preprocessing step.&lt;/p&gt;
                  &lt;p&gt;Note that some conventions put the scalar part of the quaternion
                  as the 4&lt;sup&gt;th&lt;/sup&gt; component and the vector part as the first three
                  components. This is &lt;em&gt;not&lt;/em&gt; our convention. We put the scalar part
                  as the first component.&lt;/p&gt;                
                <param>
                    q0 scalar part of the quaternion                    
                </param>
                <param>
                    q1 first coordinate of the vectorial part of the quaternion                    
                </param>
                <param>
                    q2 second coordinate of the vectorial part of the quaternion                    
                </param>
                <param>
                    q3 third coordinate of the vectorial part of the quaternion                    
                </param>
                <param>
                    needsNormalization if true, the coordinates are considered
                      not to be normalized, a normalization preprocessing step is performed
                      before using them                    
                </param>
            </javadoc>
            <method name="FieldRotation" type="constructor" line="76">
                <params>
                    <param name="q0" type="T"/>
                    <param name="q1" type="T"/>
                    <param name="q2" type="T"/>
                    <param name="q3" type="T"/>
                    <param name="needsNormalization" type="boolean"/>
                </params>
                <comment line="79">
                    normalization preprocessing                    
                </comment>
                <scope line="78">
                    <declaration name="inv" type="T" line="80"/>
                </scope>
                <scope line="86"/>
            </method>
            <javadoc line="95">
                Build a rotation from an axis and an angle.
                  &lt;p&gt;We use the convention that angles are oriented according to
                  the effect of the rotation on vectors around the axis. That means
                  that if (i, j, k) is a direct frame and if we first provide +k as
                  the axis and &amp;pi;/2 as the angle to this constructor, and then{@link #applyTo(FieldVector3D) apply} the instance to +i, we will get
                  +j.&lt;/p&gt;
                  &lt;p&gt;Another way to represent our convention is to say that a rotation
                  of angle &amp;theta; about the unit vector (x, y, z) is the same as the
                  rotation build from quaternion components { cos(-&amp;theta;/2),
                  x  sin(-&amp;theta;/2), y  sin(-&amp;theta;/2), z  sin(-&amp;theta;/2) }.
                  Note the minus sign on the angle!&lt;/p&gt;
                  &lt;p&gt;On the one hand this convention is consistent with a vectorial
                  perspective (moving vectors in fixed frames), on the other hand it
                  is different from conventions with a frame perspective (fixed vectors
                  viewed from different frames) like the ones used for example in spacecraft
                  attitude community or in the graphics community.&lt;/p&gt;                
                <param>
                    axis axis around which to rotate                    
                </param>
                <param>
                    angle rotation angle.                    
                </param>
                <exception>
                    MathIllegalArgumentException if the axis norm is zero                    
                </exception>
            </javadoc>
            <method name="FieldRotation" type="constructor" line="117">
                <params>
                    <param name="axis" type="FieldVector3D<T>"/>
                    <param name="angle" type="T"/>
                </params>
                <declaration name="norm" type="T" line="119"/>
                <scope line="120"/>
                <declaration name="halfAngle" type="T" line="124"/>
                <declaration name="coeff" type="T" line="125"/>
            </method>
            <javadoc line="134">
                Build a rotation from a 3X3 matrix.
                  &lt;p&gt;Rotation matrices are orthogonal matrices, i.e. unit matrices
                  (which are matrices for which m.m&lt;sup&gt;T&lt;/sup&gt; = I) with real
                  coefficients. The module of the determinant of unit matrices is
                  1, among the orthogonal 3X3 matrices, only the ones having a
                  positive determinant (+1) are rotation matrices.&lt;/p&gt;
                  &lt;p&gt;When a rotation is defined by a matrix with truncated values
                  (typically when it is extracted from a technical sheet where only
                  four to five significant digits are available), the matrix is not
                  orthogonal anymore. This constructor handles this case
                  transparently by using a copy of the given matrix and applying a
                  correction to the copy in order to perfect its orthogonality. If
                  the Frobenius norm of the correction needed is above the given
                  threshold, then the matrix is considered to be too far from a
                  true rotation matrix and an exception is thrown.&lt;p&gt;                
                <param>
                    m rotation matrix                    
                </param>
                <param>
                    threshold convergence threshold for the iterative
                      orthogonality correction (convergence is reached when the
                      difference between two steps of the Frobenius norm of the
                      correction is below this threshold)                    
                </param>
                <exception>
                    NotARotationMatrixException if the matrix is not a 3X3
                      matrix, or if it cannot be transformed into an orthogonal matrix
                      with the given threshold, or if the determinant of the resulting
                      orthogonal matrix is negative                    
                </exception>
            </javadoc>
            <method name="FieldRotation" type="constructor" line="165">
                <params>
                    <param name="m" type="T[][]"/>
                    <param name="threshold" type="double"/>
                </params>
                <comment line="167">
                    dimension check                    
                </comment>
                <comment line="175">
                    compute a &quot;close&quot; orthogonal matrix                    
                </comment>
                <comment line="178">
                    check the sign of the determinant                    
                </comment>
                <scope line="169"/>
                <declaration name="ort" type="T[][]" line="176"/>
                <declaration name="d0" type="T" line="179"/>
                <declaration name="d1" type="T" line="180"/>
                <declaration name="d2" type="T" line="181"/>
                <declaration name="det" type="T" line="182"/>
                <scope line="184"/>
                <declaration name="quat" type="T[]" line="190"/>
            </method>
            <javadoc line="198">
                Build the rotation that transforms a pair of vector into another pair.
                  &lt;p&gt;Except for possible scale factors, if the instance were applied to
                  the pair (u&lt;sub&gt;1&lt;/sub&gt;, u&lt;sub&gt;2&lt;/sub&gt;) it will produce the pair
                  (v&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;).&lt;/p&gt;
                  &lt;p&gt;If the angular separation between u&lt;sub&gt;1&lt;/sub&gt; and u&lt;sub&gt;2&lt;/sub&gt; is
                  not the same as the angular separation between v&lt;sub&gt;1&lt;/sub&gt; and
                  v&lt;sub&gt;2&lt;/sub&gt;, then a corrected v&apos;&lt;sub&gt;2&lt;/sub&gt; will be used rather than
                  v&lt;sub&gt;2&lt;/sub&gt;, the corrected vector will be in the (v&lt;sub&gt;1&lt;/sub&gt;,
                  v&lt;sub&gt;2&lt;/sub&gt;) plane.&lt;/p&gt;                
                <param>
                    u1 first vector of the origin pair                    
                </param>
                <param>
                    u2 second vector of the origin pair                    
                </param>
                <param>
                    v1 desired image of u1 by the rotation                    
                </param>
                <param>
                    v2 desired image of u2 by the rotation                    
                </param>
                <exception>
                    MathArithmeticException if the norm of one of the vectors is zero,
                      or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)                    
                </exception>
            </javadoc>
            <method name="FieldRotation" type="constructor" line="218">
                <params>
                    <param name="u1" type="FieldVector3D<T>"/>
                    <param name="u2" type="FieldVector3D<T>"/>
                    <param name="v1" type="FieldVector3D<T>"/>
                    <param name="v2" type="FieldVector3D<T>"/>
                </params>
                <comment line="220">
                    build orthonormalized base from u1, u2                    
                </comment>
                <comment line="221">
                    this fails when vectors are null or colinear, which is forbidden to define a rotation                    
                </comment>
                <comment line="226">
                    build an orthonormalized base from v1, v2                    
                </comment>
                <comment line="227">
                    this fails when vectors are null or colinear, which is forbidden to define a rotation                    
                </comment>
                <comment line="232">
                    buid a matrix transforming the first base into the second one                    
                </comment>
                <declaration name="u3" type="FieldVector3D&lt;T&gt;" line="222"/>
                <declaration name="v3" type="FieldVector3D&lt;T&gt;" line="228"/>
                <declaration name="array" type="T[][]" line="233"/>
                <declaration name="quat" type="T[]" line="244"/>
            </method>
            <javadoc line="252">
                Build one of the rotations that transform one vector into another one.
                  &lt;p&gt;Except for a possible scale factor, if the instance were
                  applied to the vector u it will produce the vector v. There is an
                  infinite number of such rotations, this constructor choose the
                  one with the smallest associated angle (i.e. the one whose axis
                  is orthogonal to the (u, v) plane). If u and v are colinear, an
                  arbitrary rotation axis is chosen.&lt;/p&gt;                
                <param>
                    u origin vector                    
                </param>
                <param>
                    v desired image of u by the rotation                    
                </param>
                <exception>
                    MathArithmeticException if the norm of one of the vectors is zero                    
                </exception>
            </javadoc>
            <method name="FieldRotation" type="constructor" line="265">
                <params>
                    <param name="u" type="FieldVector3D<T>"/>
                    <param name="v" type="FieldVector3D<T>"/>
                </params>
                <comment line="275">
                    special case u = -v: we select a PI angle rotation around                    
                </comment>
                <comment line="276">
                    an arbitrary vector orthogonal to u                    
                </comment>
                <comment line="283">
                    general case: (u, v) defines a plane, we select                    
                </comment>
                <comment line="284">
                    the shortest possible rotation: axis orthogonal to this plane                    
                </comment>
                <declaration name="normProduct" type="T" line="267"/>
                <scope line="268"/>
                <declaration name="dot" type="T" line="272"/>
                <scope line="274">
                    <declaration name="w" type="FieldVector3D&lt;T&gt;" line="277"/>
                </scope>
                <scope line="282">
                    <declaration name="coeff" type="T" line="286"/>
                    <declaration name="q" type="FieldVector3D&lt;T&gt;" line="287"/>
                </scope>
            </method>
            <javadoc line="295">
                Build a rotation from three Cardan or Euler elementary rotations.
                  &lt;p&gt;Cardan rotations are three successive rotations around the
                  canonical axes X, Y and Z, each axis being used once. There are
                  6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler
                  rotations are three successive rotations around the canonical
                  axes X, Y and Z, the first and last rotations being around the
                  same axis. There are 6 such sets of rotations (XYX, XZX, YXY,
                  YZY, ZXZ and ZYZ), the most popular one being ZXZ.&lt;/p&gt;
                  &lt;p&gt;Beware that many people routinely use the term Euler angles even
                  for what really are Cardan angles (this confusion is especially
                  widespread in the aerospace business where Roll, Pitch and Yaw angles
                  are often wrongly tagged as Euler angles).&lt;/p&gt;                
                <param>
                    order order of rotations to use                    
                </param>
                <param>
                    alpha1 angle of the first elementary rotation                    
                </param>
                <param>
                    alpha2 angle of the second elementary rotation                    
                </param>
                <param>
                    alpha3 angle of the third elementary rotation                    
                </param>
            </javadoc>
            <method name="FieldRotation" type="constructor" line="314">
                <params>
                    <param name="order" type="RotationOrder"/>
                    <param name="alpha1" type="T"/>
                    <param name="alpha2" type="T"/>
                    <param name="alpha3" type="T"/>
                </params>
                <declaration name="one" type="T" line="315"/>
                <declaration name="r1" type="FieldRotation&lt;T&gt;" line="316"/>
                <declaration name="r2" type="FieldRotation&lt;T&gt;" line="317"/>
                <declaration name="r3" type="FieldRotation&lt;T&gt;" line="318"/>
                <declaration name="composed" type="FieldRotation&lt;T&gt;" line="319"/>
            </method>
            <javadoc line="326">
                Convert an orthogonal rotation matrix to a quaternion.                
                <param>
                    ort orthogonal rotation matrix                    
                </param>
                <return>
                    quaternion corresponding to the matrix                    
                </return>
            </javadoc>
            <method name="mat2quat" type="T[]" line="330">
                <params>
                    <param name="ort" type="T[][]"/>
                </params>
                <comment line="334">
                    There are different ways to compute the quaternions elements                    
                </comment>
                <comment line="335">
                    from the matrix. They all involve computing one element from                    
                </comment>
                <comment line="336">
                    the diagonal of the matrix, and computing the three other ones                    
                </comment>
                <comment line="337">
                    using a formula involving a division by the first element,                    
                </comment>
                <comment line="338">
                    which unfortunately can be zero. Since the norm of the                    
                </comment>
                <comment line="339">
                    quaternion is 1, we know at least one element has an absolute                    
                </comment>
                <comment line="340">
                    value greater or equal to 0.5, so it is always possible to                    
                </comment>
                <comment line="341">
                    select the right formula and avoid division by zero and even                    
                </comment>
                <comment line="342">
                    numerical inaccuracy. Checking the elements in turn and using                    
                </comment>
                <comment line="343">
                    the first one greater than 0.45 is safe (this leads to a simple                    
                </comment>
                <comment line="344">
                    test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)                    
                </comment>
                <comment line="347">
                    compute q0 and deduce q1, q2 and q3                    
                </comment>
                <comment line="356">
                    compute q1 and deduce q0, q2 and q3                    
                </comment>
                <comment line="365">
                    compute q2 and deduce q0, q1 and q3                    
                </comment>
                <comment line="372">
                    compute q3 and deduce q0, q1 and q2                    
                </comment>
                <declaration name="quat" type="T[]" line="332"/>
                <declaration name="s" type="T" line="345"/>
                <scope line="346">
                    <declaration name="inv" type="T" line="349"/>
                </scope>
                <scope line="353">
                    <scope line="355">
                        <declaration name="inv" type="T" line="358"/>
                    </scope>
                    <scope line="362">
                        <scope line="364">
                            <declaration name="inv" type="T" line="367"/>
                        </scope>
                        <scope line="371">
                            <declaration name="inv" type="T" line="375"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="387">
                Revert a rotation.
                  Build a rotation which reverse the effect of another
                  rotation. This means that if r(u) = v, then r.revert(v) = u. The
                  instance is not changed.                
                <return>
                    a new rotation whose effect is the reverse of the effect
                      of the instance                    
                </return>
            </javadoc>
            <method name="revert" type="FieldRotation<T>" line="394"/>
            <javadoc line="398">
                Get the scalar coordinate of the quaternion.                
                <return>
                    scalar coordinate of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ0" type="T" line="401"/>
            <javadoc line="405">
                Get the first coordinate of the vectorial part of the quaternion.                
                <return>
                    first coordinate of the vectorial part of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ1" type="T" line="408"/>
            <javadoc line="412">
                Get the second coordinate of the vectorial part of the quaternion.                
                <return>
                    second coordinate of the vectorial part of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ2" type="T" line="415"/>
            <javadoc line="419">
                Get the third coordinate of the vectorial part of the quaternion.                
                <return>
                    third coordinate of the vectorial part of the quaternion                    
                </return>
            </javadoc>
            <method name="getQ3" type="T" line="422"/>
            <javadoc line="426">
                Get the normalized axis of the rotation.                
                <return>
                    normalized axis of the rotation                    
                </return>
                <see>
                    #FieldRotation(FieldVector3D,RealFieldElement)                    
                </see>
            </javadoc>
            <method name="getAxis" type="FieldVector3D<T>" line="430">
                <declaration name="squaredSine" type="T" line="431"/>
                <scope line="432">
                    <declaration name="field" type="Field&lt;T&gt;" line="433"/>
                </scope>
                <scope line="435">
                    <declaration name="inverse" type="T" line="436"/>
                </scope>
                <declaration name="inverse" type="T" line="439"/>
            </method>
            <javadoc line="443">
                Get the angle of the rotation.                
                <return>
                    angle of the rotation (between 0 and &pi;)                    
                </return>
                <see>
                    #FieldRotation(FieldVector3D,RealFieldElement)                    
                </see>
            </javadoc>
            <method name="getAngle" type="T" line="447">
                <scope line="448"/>
                <scope line="450"/>
            </method>
            <javadoc line="456">
                Get the Cardan or Euler angles corresponding to the instance.
                  &lt;p&gt;The equations show that each rotation can be defined by two
                  different values of the Cardan or Euler angles set. For example
                  if Cardan angles are used, the rotation defined by the angles
                  a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt; and a&lt;sub&gt;3&lt;/sub&gt; is the same as
                  the rotation defined by the angles &amp;pi; + a&lt;sub&gt;1&lt;/sub&gt;, &amp;pi;
                  - a&lt;sub&gt;2&lt;/sub&gt; and &amp;pi; + a&lt;sub&gt;3&lt;/sub&gt;. This method implements
                  the following arbitrary choices:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;for Cardan angles, the chosen set is the one for which the
                  second angle is between -&amp;pi;/2 and &amp;pi;/2 (i.e its cosine is
                  positive),&lt;/li&gt;
                  &lt;li&gt;for Euler angles, the chosen set is the one for which the
                  second angle is between 0 and &amp;pi; (i.e its sine is positive).&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Cardan and Euler angle have a very disappointing drawback: all
                  of them have singularities. This means that if the instance is
                  too close to the singularities corresponding to the given
                  rotation order, it will be impossible to retrieve the angles. For
                  Cardan angles, this is often called gimbal lock. There is
                  &lt;em&gt;nothing&lt;/em&gt; to do to prevent this, it is an intrinsic problem
                  with Cardan and Euler representation (but not a problem with the
                  rotation itself, which is perfectly well defined). For Cardan
                  angles, singularities occur when the second angle is close to
                  -&amp;pi;/2 or +&amp;pi;/2, for Euler angle singularities occur when the
                  second angle is close to 0 or &amp;pi;, this implies that the identity
                  rotation is always singular for Euler angles!&lt;/p&gt;                
                <param>
                    order rotation order to use                    
                </param>
                <return>
                    an array of three angles, in the order specified by the set                    
                </return>
                <exception>
                    CardanEulerSingularityException if the rotation is
                      singular with respect to the angles set specified                    
                </exception>
            </javadoc>
            <method name="getAngles" type="T[]" line="492">
                <params>
                    <param name="order" type="RotationOrder"/>
                </params>
                <comment line="496">
                    r (+K) coordinates are :                    
                </comment>
                <comment line="497">
                    sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)                    
                </comment>
                <comment line="498">
                    (-r) (+I) coordinates are :                    
                </comment>
                <comment line="499">
                    cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)                    
                </comment>
                <comment line="500">
                    and we can choose to have theta in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="512">
                    r (+J) coordinates are :                    
                </comment>
                <comment line="513">
                    -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)                    
                </comment>
                <comment line="514">
                    (-r) (+I) coordinates are :                    
                </comment>
                <comment line="515">
                    cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)                    
                </comment>
                <comment line="516">
                    and we can choose to have psi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="528">
                    r (+K) coordinates are :                    
                </comment>
                <comment line="529">
                    cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)                    
                </comment>
                <comment line="530">
                    (-r) (+J) coordinates are :                    
                </comment>
                <comment line="531">
                    sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)                    
                </comment>
                <comment line="532">
                    and we can choose to have phi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="544">
                    r (+I) coordinates are :                    
                </comment>
                <comment line="545">
                    cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)                    
                </comment>
                <comment line="546">
                    (-r) (+J) coordinates are :                    
                </comment>
                <comment line="547">
                    sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)                    
                </comment>
                <comment line="548">
                    and we can choose to have psi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="560">
                    r (+J) coordinates are :                    
                </comment>
                <comment line="561">
                    -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)                    
                </comment>
                <comment line="562">
                    (-r) (+K) coordinates are :                    
                </comment>
                <comment line="563">
                    -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)                    
                </comment>
                <comment line="564">
                    and we can choose to have phi in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="576">
                    r (+I) coordinates are :                    
                </comment>
                <comment line="577">
                    cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)                    
                </comment>
                <comment line="578">
                    (-r) (+K) coordinates are :                    
                </comment>
                <comment line="579">
                    -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)                    
                </comment>
                <comment line="580">
                    and we can choose to have theta in the interval [-PI/2 ; +PI/2]                    
                </comment>
                <comment line="592">
                    r (+I) coordinates are :                    
                </comment>
                <comment line="593">
                    cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)                    
                </comment>
                <comment line="594">
                    (-r) (+I) coordinates are :                    
                </comment>
                <comment line="595">
                    cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)                    
                </comment>
                <comment line="596">
                    and we can choose to have theta in the interval [0 ; PI]                    
                </comment>
                <comment line="608">
                    r (+I) coordinates are :                    
                </comment>
                <comment line="609">
                    cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)                    
                </comment>
                <comment line="610">
                    (-r) (+I) coordinates are :                    
                </comment>
                <comment line="611">
                    cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)                    
                </comment>
                <comment line="612">
                    and we can choose to have psi in the interval [0 ; PI]                    
                </comment>
                <comment line="624">
                    r (+J) coordinates are :                    
                </comment>
                <comment line="625">
                    sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)                    
                </comment>
                <comment line="626">
                    (-r) (+J) coordinates are :                    
                </comment>
                <comment line="627">
                    sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)                    
                </comment>
                <comment line="628">
                    and we can choose to have phi in the interval [0 ; PI]                    
                </comment>
                <comment line="640">
                    r (+J) coordinates are :                    
                </comment>
                <comment line="641">
                    -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)                    
                </comment>
                <comment line="642">
                    (-r) (+J) coordinates are :                    
                </comment>
                <comment line="643">
                    sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)                    
                </comment>
                <comment line="644">
                    and we can choose to have psi in the interval [0 ; PI]                    
                </comment>
                <comment line="656">
                    r (+K) coordinates are :                    
                </comment>
                <comment line="657">
                    sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)                    
                </comment>
                <comment line="658">
                    (-r) (+K) coordinates are :                    
                </comment>
                <comment line="659">
                    sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)                    
                </comment>
                <comment line="660">
                    and we can choose to have phi in the interval [0 ; PI]                    
                </comment>
                <comment line="670">
                    last possibility is ZYZ                    
                </comment>
                <comment line="672">
                    r (+K) coordinates are :                    
                </comment>
                <comment line="673">
                    cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)                    
                </comment>
                <comment line="674">
                    (-r) (+K) coordinates are :                    
                </comment>
                <comment line="675">
                    -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)                    
                </comment>
                <comment line="676">
                    and we can choose to have theta in the interval [0 ; PI]                    
                </comment>
                <scope line="494">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="500"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="502"/>
                    <scope line="503"/>
                </scope>
                <scope line="510">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="517"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="518"/>
                    <scope line="519"/>
                </scope>
                <scope line="526">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="533"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="534"/>
                    <scope line="535"/>
                </scope>
                <scope line="542">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="549"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="550"/>
                    <scope line="551"/>
                </scope>
                <scope line="558">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="565"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="566"/>
                    <scope line="567"/>
                </scope>
                <scope line="574">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="581"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="582"/>
                    <scope line="583"/>
                </scope>
                <scope line="590">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="597"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="598"/>
                    <scope line="599"/>
                </scope>
                <scope line="606">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="613"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="614"/>
                    <scope line="615"/>
                </scope>
                <scope line="622">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="629"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="630"/>
                    <scope line="631"/>
                </scope>
                <scope line="638">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="645"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="646"/>
                    <scope line="647"/>
                </scope>
                <scope line="654">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="661"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="662"/>
                    <scope line="663"/>
                </scope>
                <scope line="670">
                    <declaration name="v1" type="FieldVector3D&lt;T&gt;" line="677"/>
                    <declaration name="v2" type="FieldVector3D&lt;T&gt;" line="678"/>
                    <scope line="679"/>
                </scope>
            </method>
            <javadoc line="690">
                Create a dimension 3 array.                
                <param>
                    a0 first array element                    
                </param>
                <param>
                    a1 second array element                    
                </param>
                <param>
                    a2 third array element                    
                </param>
                <return>
                    new array                    
                </return>
            </javadoc>
            <method name="buildArray" type="T[]" line="696">
                <params>
                    <param name="a0" type="T"/>
                    <param name="a1" type="T"/>
                    <param name="a2" type="T"/>
                </params>
                <declaration name="array" type="T[]" line="697"/>
            </method>
            <javadoc line="704">
                Create a constant vector.                
                <param>
                    x abscissa                    
                </param>
                <param>
                    y ordinate                    
                </param>
                <param>
                    z height                    
                </param>
                <return>
                    a constant vector                    
                </return>
            </javadoc>
            <method name="vector" type="FieldVector3D<T>" line="710">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="z" type="double"/>
                </params>
                <declaration name="zero" type="T" line="711"/>
            </method>
            <javadoc line="715">
                Get the 3X3 matrix corresponding to the instance                
                <return>
                    the matrix corresponding to the instance                    
                </return>
            </javadoc>
            <method name="getMatrix" type="T[][]" line="718">
                <comment line="720">
                    products                    
                </comment>
                <comment line="732">
                    create the matrix                    
                </comment>
                <declaration name="q0q0" type="T" line="721"/>
                <declaration name="q0q1" type="T" line="722"/>
                <declaration name="q0q2" type="T" line="723"/>
                <declaration name="q0q3" type="T" line="724"/>
                <declaration name="q1q1" type="T" line="725"/>
                <declaration name="q1q2" type="T" line="726"/>
                <declaration name="q1q3" type="T" line="727"/>
                <declaration name="q2q2" type="T" line="728"/>
                <declaration name="q2q3" type="T" line="729"/>
                <declaration name="q3q3" type="T" line="730"/>
                <declaration name="m" type="T[][]" line="733"/>
            </method>
            <javadoc line="751">
                Convert to a constant vector without derivatives.                
                <return>
                    a constant vector                    
                </return>
            </javadoc>
            <method name="toRotation" type="Rotation" line="754"/>
            <javadoc line="758">
                Apply the rotation to a vector.                
                <param>
                    u vector to apply the rotation to                    
                </param>
                <return>
                    a new vector which is the image of u by the rotation                    
                </return>
            </javadoc>
            <method name="applyTo" type="FieldVector3D<T>" line="762">
                <params>
                    <param name="u" type="FieldVector3D<T>"/>
                </params>
                <declaration name="x" type="T" line="764"/>
                <declaration name="y" type="T" line="765"/>
                <declaration name="z" type="T" line="766"/>
                <declaration name="s" type="T" line="768"/>
            </method>
            <javadoc line="776">
                Apply the rotation to a vector.                
                <param>
                    u vector to apply the rotation to                    
                </param>
                <return>
                    a new vector which is the image of u by the rotation                    
                </return>
            </javadoc>
            <method name="applyTo" type="FieldVector3D<T>" line="780">
                <params>
                    <param name="u" type="Vector3D"/>
                </params>
                <declaration name="x" type="double" line="782"/>
                <declaration name="y" type="double" line="783"/>
                <declaration name="z" type="double" line="784"/>
                <declaration name="s" type="T" line="786"/>
            </method>
            <javadoc line="794">
                Apply the rotation to a vector stored in an array.                
                <param>
                    in an array with three items which stores vector to rotate                    
                </param>
                <param>
                    out an array with three items to put result to (it can be the same
                      array as in)                    
                </param>
            </javadoc>
            <method name="applyTo" type="void" line="799">
                <params>
                    <param name="in" type="T[]"/>
                    <param name="out" type="T[]"/>
                </params>
                <declaration name="x" type="T" line="801"/>
                <declaration name="y" type="T" line="802"/>
                <declaration name="z" type="T" line="803"/>
                <declaration name="s" type="T" line="805"/>
            </method>
            <javadoc line="813">
                Apply the rotation to a vector stored in an array.                
                <param>
                    in an array with three items which stores vector to rotate                    
                </param>
                <param>
                    out an array with three items to put result to                    
                </param>
            </javadoc>
            <method name="applyTo" type="void" line="817">
                <params>
                    <param name="in" type="double[]"/>
                    <param name="out" type="T[]"/>
                </params>
                <declaration name="x" type="double" line="819"/>
                <declaration name="y" type="double" line="820"/>
                <declaration name="z" type="double" line="821"/>
                <declaration name="s" type="T" line="823"/>
            </method>
            <javadoc line="831">
                Apply a rotation to a vector.                
                <param>
                    r rotation to apply                    
                </param>
                <param>
                    u vector to apply the rotation to                    
                </param>
                <param>
                    <T>
                       the type of the field elements                    
                </param>
                <return>
                    a new vector which is the image of u by the rotation                    
                </return>
            </javadoc>
            <method name="applyTo" type="FieldVector3D<T>" line="837">
                <params>
                    <param name="r" type="Rotation"/>
                    <param name="u" type="FieldVector3D<T>"/>
                </params>
                <declaration name="x" type="T" line="839"/>
                <declaration name="y" type="T" line="840"/>
                <declaration name="z" type="T" line="841"/>
                <declaration name="s" type="T" line="843"/>
            </method>
            <javadoc line="851">
                Apply the inverse of the rotation to a vector.                
                <param>
                    u vector to apply the inverse of the rotation to                    
                </param>
                <return>
                    a new vector which such that u is its image by the rotation                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="FieldVector3D<T>" line="855">
                <params>
                    <param name="u" type="FieldVector3D<T>"/>
                </params>
                <declaration name="x" type="T" line="857"/>
                <declaration name="y" type="T" line="858"/>
                <declaration name="z" type="T" line="859"/>
                <declaration name="s" type="T" line="861"/>
                <declaration name="m0" type="T" line="862"/>
            </method>
            <javadoc line="870">
                Apply the inverse of the rotation to a vector.                
                <param>
                    u vector to apply the inverse of the rotation to                    
                </param>
                <return>
                    a new vector which such that u is its image by the rotation                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="FieldVector3D<T>" line="874">
                <params>
                    <param name="u" type="Vector3D"/>
                </params>
                <declaration name="x" type="double" line="876"/>
                <declaration name="y" type="double" line="877"/>
                <declaration name="z" type="double" line="878"/>
                <declaration name="s" type="T" line="880"/>
                <declaration name="m0" type="T" line="881"/>
            </method>
            <javadoc line="889">
                Apply the inverse of the rotation to a vector stored in an array.                
                <param>
                    in an array with three items which stores vector to rotate                    
                </param>
                <param>
                    out an array with three items to put result to (it can be the same
                      array as in)                    
                </param>
            </javadoc>
            <method name="applyInverseTo" type="void" line="894">
                <params>
                    <param name="in" type="T[]"/>
                    <param name="out" type="T[]"/>
                </params>
                <declaration name="x" type="T" line="896"/>
                <declaration name="y" type="T" line="897"/>
                <declaration name="z" type="T" line="898"/>
                <declaration name="s" type="T" line="900"/>
                <declaration name="m0" type="T" line="901"/>
            </method>
            <javadoc line="909">
                Apply the inverse of the rotation to a vector stored in an array.                
                <param>
                    in an array with three items which stores vector to rotate                    
                </param>
                <param>
                    out an array with three items to put result to                    
                </param>
            </javadoc>
            <method name="applyInverseTo" type="void" line="913">
                <params>
                    <param name="in" type="double[]"/>
                    <param name="out" type="T[]"/>
                </params>
                <declaration name="x" type="double" line="915"/>
                <declaration name="y" type="double" line="916"/>
                <declaration name="z" type="double" line="917"/>
                <declaration name="s" type="T" line="919"/>
                <declaration name="m0" type="T" line="920"/>
            </method>
            <javadoc line="928">
                Apply the inverse of a rotation to a vector.                
                <param>
                    r rotation to apply                    
                </param>
                <param>
                    u vector to apply the inverse of the rotation to                    
                </param>
                <param>
                    <T>
                       the type of the field elements                    
                </param>
                <return>
                    a new vector which such that u is its image by the rotation                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="FieldVector3D<T>" line="934">
                <params>
                    <param name="r" type="Rotation"/>
                    <param name="u" type="FieldVector3D<T>"/>
                </params>
                <declaration name="x" type="T" line="936"/>
                <declaration name="y" type="T" line="937"/>
                <declaration name="z" type="T" line="938"/>
                <declaration name="s" type="T" line="940"/>
                <declaration name="m0" type="double" line="941"/>
            </method>
            <javadoc line="949">
                Apply the instance to another rotation.
                  Applying the instance to a rotation is computing the composition
                  in an order compliant with the following rule : let u be any
                  vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
                  of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
                  where comp = applyTo(r).                
                <param>
                    r rotation to apply the rotation to                    
                </param>
                <return>
                    a new rotation which is the composition of r by the instance                    
                </return>
            </javadoc>
            <method name="applyTo" type="FieldRotation<T>" line="958">
                <params>
                    <param name="r" type="FieldRotation<T>"/>
                </params>
            </method>
            <javadoc line="966">
                Apply the instance to another rotation.
                  Applying the instance to a rotation is computing the composition
                  in an order compliant with the following rule : let u be any
                  vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image
                  of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),
                  where comp = applyTo(r).                
                <param>
                    r rotation to apply the rotation to                    
                </param>
                <return>
                    a new rotation which is the composition of r by the instance                    
                </return>
            </javadoc>
            <method name="applyTo" type="FieldRotation<T>" line="975">
                <params>
                    <param name="r" type="Rotation"/>
                </params>
            </method>
            <javadoc line="983">
                Apply a rotation to another rotation.
                  Applying a rotation to another rotation is computing the composition
                  in an order compliant with the following rule : let u be any
                  vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image
                  of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),
                  where comp = applyTo(rOuter, rInner).                
                <param>
                    r1 rotation to apply                    
                </param>
                <param>
                    rInner rotation to apply the rotation to                    
                </param>
                <param>
                    <T>
                       the type of the field elements                    
                </param>
                <return>
                    a new rotation which is the composition of r by the instance                    
                </return>
            </javadoc>
            <method name="applyTo" type="FieldRotation<T>" line="994">
                <params>
                    <param name="r1" type="Rotation"/>
                    <param name="rInner" type="FieldRotation<T>"/>
                </params>
            </method>
            <javadoc line="1002">
                Apply the inverse of the instance to another rotation.
                  Applying the inverse of the instance to a rotation is computing
                  the composition in an order compliant with the following rule :
                  let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
                  let w be the inverse image of v by the instance
                  (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
                  comp = applyInverseTo(r).                
                <param>
                    r rotation to apply the rotation to                    
                </param>
                <return>
                    a new rotation which is the composition of r by the inverse
                      of the instance                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="FieldRotation<T>" line="1013">
                <params>
                    <param name="r" type="FieldRotation<T>"/>
                </params>
            </method>
            <javadoc line="1021">
                Apply the inverse of the instance to another rotation.
                  Applying the inverse of the instance to a rotation is computing
                  the composition in an order compliant with the following rule :
                  let u be any vector and v its image by r (i.e. r.applyTo(u) = v),
                  let w be the inverse image of v by the instance
                  (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where
                  comp = applyInverseTo(r).                
                <param>
                    r rotation to apply the rotation to                    
                </param>
                <return>
                    a new rotation which is the composition of r by the inverse
                      of the instance                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="FieldRotation<T>" line="1032">
                <params>
                    <param name="r" type="Rotation"/>
                </params>
            </method>
            <javadoc line="1040">
                Apply the inverse of a rotation to another rotation.
                  Applying the inverse of a rotation to another rotation is computing
                  the composition in an order compliant with the following rule :
                  let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),
                  let w be the inverse image of v by rOuter
                  (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where
                  comp = applyInverseTo(rOuter, rInner).                
                <param>
                    rOuter rotation to apply the rotation to                    
                </param>
                <param>
                    rInner rotation to apply the rotation to                    
                </param>
                <param>
                    <T>
                       the type of the field elements                    
                </param>
                <return>
                    a new rotation which is the composition of r by the inverse
                      of the instance                    
                </return>
            </javadoc>
            <method name="applyInverseTo" type="FieldRotation<T>" line="1053">
                <params>
                    <param name="rOuter" type="Rotation"/>
                    <param name="rInner" type="FieldRotation<T>"/>
                </params>
            </method>
            <javadoc line="1061">
                Perfect orthogonality on a 3X3 matrix.                
                <param>
                    m initial matrix (not exactly orthogonal)                    
                </param>
                <param>
                    threshold convergence threshold for the iterative
                      orthogonality correction (convergence is reached when the
                      difference between two steps of the Frobenius norm of the
                      correction is below this threshold)                    
                </param>
                <return>
                    an orthogonal matrix close to m                    
                </return>
                <exception>
                    NotARotationMatrixException if the matrix cannot be
                      orthogonalized with the given threshold after 10 iterations                    
                </exception>
            </javadoc>
            <method name="orthogonalizeMatrix" type="T[][]" line="1072">
                <params>
                    <param name="m" type="T[][]"/>
                    <param name="threshold" type="double"/>
                </params>
                <comment line="1088">
                    iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)                    
                </comment>
                <comment line="1092">
                    Mt.Xn                    
                </comment>
                <comment line="1103">
                    Xn+1                    
                </comment>
                <comment line="1114">
                    correction on each elements                    
                </comment>
                <comment line="1125">
                    Frobenius norm of the correction                    
                </comment>
                <comment line="1130">
                    convergence test                    
                </comment>
                <comment line="1135">
                    prepare next iteration                    
                </comment>
                <comment line="1149">
                    the algorithm did not converge after 10 iterations                    
                </comment>
                <declaration name="x00" type="T" line="1074"/>
                <declaration name="x01" type="T" line="1075"/>
                <declaration name="x02" type="T" line="1076"/>
                <declaration name="x10" type="T" line="1077"/>
                <declaration name="x11" type="T" line="1078"/>
                <declaration name="x12" type="T" line="1079"/>
                <declaration name="x20" type="T" line="1080"/>
                <declaration name="x21" type="T" line="1081"/>
                <declaration name="x22" type="T" line="1082"/>
                <declaration name="fn" type="double" line="1083"/>
                <declaration name="fn1" type="double" line="1084"/>
                <declaration name="o" type="T[][]" line="1086"/>
                <declaration name="i" type="int" line="1089"/>
                <scope line="1090">
                    <declaration name="mx00" type="T" line="1093"/>
                    <declaration name="mx10" type="T" line="1094"/>
                    <declaration name="mx20" type="T" line="1095"/>
                    <declaration name="mx01" type="T" line="1096"/>
                    <declaration name="mx11" type="T" line="1097"/>
                    <declaration name="mx21" type="T" line="1098"/>
                    <declaration name="mx02" type="T" line="1099"/>
                    <declaration name="mx12" type="T" line="1100"/>
                    <declaration name="mx22" type="T" line="1101"/>
                    <declaration name="corr00" type="double" line="1115"/>
                    <declaration name="corr01" type="double" line="1116"/>
                    <declaration name="corr02" type="double" line="1117"/>
                    <declaration name="corr10" type="double" line="1118"/>
                    <declaration name="corr11" type="double" line="1119"/>
                    <declaration name="corr12" type="double" line="1120"/>
                    <declaration name="corr20" type="double" line="1121"/>
                    <declaration name="corr21" type="double" line="1122"/>
                    <declaration name="corr22" type="double" line="1123"/>
                    <scope line="1131"/>
                </scope>
            </method>
            <javadoc line="1155">
                Compute the &lt;i&gt;distance&lt;/i&gt; between two rotations.
                  &lt;p&gt;The &lt;i&gt;distance&lt;/i&gt; is intended here as a way to check if two
                  rotations are almost similar (i.e. they transform vectors the same way)
                  or very different. It is mathematically defined as the angle of
                  the rotation r that prepended to one of the rotations gives the other
                  one:&lt;/p&gt;
                  &lt;pre&gt;
                  r&lt;sub&gt;1&lt;/sub&gt;(r) = r&lt;sub&gt;2&lt;/sub&gt;
                  &lt;/pre&gt;
                  &lt;p&gt;This distance is an angle between 0 and &amp;pi;. Its value is the smallest
                  possible upper bound of the angle in radians between r&lt;sub&gt;1&lt;/sub&gt;(v)
                  and r&lt;sub&gt;2&lt;/sub&gt;(v) for all possible vectors v. This upper bound is
                  reached for some v. The distance is equal to 0 if and only if the two
                  rotations are identical.&lt;/p&gt;
                  &lt;p&gt;Comparing two rotations should always be done using this value rather
                  than for example comparing the components of the quaternions. It is much
                  more stable, and has a geometric meaning. Also comparing quaternions
                  components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)
                  and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite
                  their components are different (they are exact opposites).&lt;/p&gt;                
                <param>
                    r1 first rotation                    
                </param>
                <param>
                    r2 second rotation                    
                </param>
                <param>
                    <T>
                       the type of the field elements                    
                </param>
                <return>
                    <i>distance</i> between r1 and r2                    
                </return>
            </javadoc>
            <method name="distance" type="T" line="1180">
                <params>
                    <param name="r1" type="FieldRotation<T>"/>
                    <param name="r2" type="FieldRotation<T>"/>
                </params>
            </method>
        </class>
    </source>