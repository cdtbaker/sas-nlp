<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.complex">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.OutOfRangeException"/>
        <import package="org.apache.commons.math3.exception.ZeroException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="RootsOfUnity" line="9">
            <implements interface="Serializable"/>
            <javadoc line="9">
                A helper class for the computation and caching of the {@code n}-th roots of
                  unity.                
                <version>
                    $Id: RootsOfUnity.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="16"/>
            <javadoc line="16">
                Serializable version id.                
            </javadoc>
            <declaration name="omegaCount" type="int" line="20"/>
            <javadoc line="20">
                Number of roots of unity.                
            </javadoc>
            <declaration name="omegaReal" type="double[]" line="24"/>
            <javadoc line="24">
                Real part of the roots.                
            </javadoc>
            <declaration name="omegaImaginaryCounterClockwise" type="double[]" line="28"/>
            <javadoc line="28">
                Imaginary part of the {@code n}-th roots of unity, for positive values
                  of {@code n}. In this array, the roots are stored in counter-clockwise
                  order.                
            </javadoc>
            <declaration name="omegaImaginaryClockwise" type="double[]" line="34"/>
            <javadoc line="34">
                Imaginary part of the {@code n}-th roots of unity, for negative values
                  of {@code n}. In this array, the roots are stored in clockwise order.                
            </javadoc>
            <declaration name="isCounterClockWise" type="boolean" line="39"/>
            <javadoc line="39">
                {@code true} if {@link #computeRoots(int)} was called with a positive
                  value of its argument {@code n}. In this case, counter-clockwise ordering
                  of the roots of unity should be used.                
            </javadoc>
            <javadoc line="45">
                Build an engine for computing the {@code n}-th roots of unity.                
            </javadoc>
            <method name="RootsOfUnity" type="constructor" line="48"/>
            <javadoc line="55">
                Returns {@code true} if {@link #computeRoots(int)} was called with a
                  positive value of its argument {@code n}. If {@code true}, then
                  counter-clockwise ordering of the roots of unity should be used.                
                <return>
                    {@code true} if the roots of unity are stored in
                      counter-clockwise order                    
                </return>
                <throws>
                    MathIllegalStateException if no roots of unity have been computed
                      yet                    
                </throws>
            </javadoc>
            <method name="isCounterClockWise" type="boolean" line="64">
                <scope line="65"/>
            </method>
            <javadoc line="70">
                &lt;p&gt;
                  Computes the {@code n}-th roots of unity. The roots are stored in{@code omega[]}, such that {@code omega[k] = w ^ k}, where{@code k = 0, ..., n - 1}, {@code w = exp(2  pi  i / n)} and{@code i = sqrt(-1)}.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Note that {@code n} can be positive of negative
                  &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;{@code abs(n)} is always the number of roots of unity.&lt;/li&gt;
                  &lt;li&gt;If {@code n &gt; 0}, then the roots are stored in counter-clockwise order.&lt;/li&gt;
                  &lt;li&gt;If {@code n &lt; 0}, then the roots are stored in clockwise order.&lt;/p&gt;
                  &lt;/ul&gt;                
                <param>
                    n the (signed) number of roots of unity to be computed                    
                </param>
                <throws>
                    ZeroException if {@code n = 0}                    
                </throws>
            </javadoc>
            <method name="computeRoots" type="void" line="85">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="86"/>
                <declaration name="absN" type="int" line="90"/>
                <scope line="91"/>
                <declaration name="t" type="double" line="94"/>
                <declaration name="cosT" type="double" line="95"/>
                <declaration name="sinT" type="double" line="96"/>
                <scope line="103"/>
            </method>
            <javadoc line="110">
                Get the real part of the {@code k}-th {@code n}-th root of unity.                
                <param>
                    k index of the {@code n}-th root of unity                    
                </param>
                <return>
                    real part of the {@code k}-th {@code n}-th root of unity                    
                </return>
                <throws>
                    MathIllegalStateException if no roots of unity have been
                      computed yet                    
                </throws>
                <throws>
                    MathIllegalArgumentException if {@code k} is out of range                    
                </throws>
            </javadoc>
            <method name="getReal" type="double" line="118">
                <params>
                    <param name="k" type="int"/>
                </params>
                <scope line="119"/>
                <scope line="122"/>
            </method>
            <javadoc line="127">
                Get the imaginary part of the {@code k}-th {@code n}-th root of unity.                
                <param>
                    k index of the {@code n}-th root of unity                    
                </param>
                <return>
                    imaginary part of the {@code k}-th {@code n}-th root of unity                    
                </return>
                <throws>
                    MathIllegalStateException if no roots of unity have been
                      computed yet                    
                </throws>
                <throws>
                    OutOfRangeException if {@code k} is out of range                    
                </throws>
            </javadoc>
            <method name="getImaginary" type="double" line="135">
                <params>
                    <param name="k" type="int"/>
                </params>
                <scope line="136"/>
                <scope line="139"/>
            </method>
            <javadoc line="144">
                Returns the number of roots of unity currently stored. If{@link #computeRoots(int)} was called with {@code n}, then this method
                  returns {@code abs(n)}. If no roots of unity have been computed yet, this
                  method returns 0.                
                <return>
                    the number of roots of unity currently stored                    
                </return>
            </javadoc>
            <method name="getNumberOfRoots" type="int" line="150"/>
        </class>
    </source>