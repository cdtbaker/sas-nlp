<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optimization.general">
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.analysis.solvers.BrentSolver"/>
        <import package="org.apache.commons.math3.analysis.solvers.UnivariateSolver"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optimization.GoalType"/>
        <import package="org.apache.commons.math3.optimization.PointValuePair"/>
        <import package="org.apache.commons.math3.optimization.SimpleValueChecker"/>
        <import package="org.apache.commons.math3.optimization.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="NonLinearConjugateGradientOptimizer" line="31">
            <extends class="AbstractScalarDifferentiableOptimizer"/>
            <javadoc line="31">
                Non-linear conjugate gradient optimizer.
                  &lt;p&gt;
                  This class supports both the Fletcher-Reeves and the Polak-Ribi&amp;egrave;re
                  update formulas for the conjugate search directions. It also supports
                  optional preconditioning.
                  &lt;/p&gt;                
                <version>
                    $Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $                    
                </version>
                <deprecated>
                    As of 3.1 (to be removed in 4.0).                    
                </deprecated>
                <since>
                    2.0                    
                </since>
            </javadoc>
            <declaration name="updateFormula" type="ConjugateGradientFormula" line="47"/>
            <javadoc line="47">
                Update formula for the beta parameter.                
            </javadoc>
            <declaration name="preconditioner" type="Preconditioner" line="49"/>
            <javadoc line="49">
                Preconditioner (may be null).                
            </javadoc>
            <declaration name="solver" type="UnivariateSolver" line="51"/>
            <javadoc line="51">
                solver to use in the line search (may be null).                
            </javadoc>
            <declaration name="initialStep" type="double" line="53"/>
            <javadoc line="53">
                Initial step used to bracket the optimum in line search.                
            </javadoc>
            <declaration name="point" type="double[]" line="55"/>
            <javadoc line="55">
                Current point.                
            </javadoc>
            <javadoc line="58">
                Constructor with default {@link SimpleValueChecker checker},{@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &beta; parameter,
                      must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.                    
                </param>
                <deprecated>
                    See {@link SimpleValueChecker#SimpleValueChecker()}                    
                </deprecated>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="69">
                <params>
                    <param name="updateFormula" type="ConjugateGradientFormula"/>
                </params>
            </method>
            <javadoc line="74">
                Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &beta; parameter,
                      must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="84">
                <params>
                    <param name="updateFormula" type="ConjugateGradientFormula"/>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                </params>
            </method>
            <javadoc line="92">
                Constructor with default {@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &beta; parameter,
                      must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    lineSearchSolver Solver to use during line search.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="103">
                <params>
                    <param name="updateFormula" type="ConjugateGradientFormula"/>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                    <param name="lineSearchSolver" type="UnivariateSolver"/>
                </params>
            </method>
            <javadoc line="110">
                @param updateFormula formula to use for updating the &amp;beta; parameter,
                  must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link ConjugateGradientFormula#POLAK_RIBIERE}.                
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    lineSearchSolver Solver to use during line search.                    
                </param>
                <param>
                    preconditioner Preconditioner.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="121">
                <params>
                    <param name="updateFormula" type="ConjugateGradientFormula"/>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                    <param name="lineSearchSolver" type="UnivariateSolver"/>
                    <param name="preconditioner" type="Preconditioner"/>
                </params>
            </method>
            <javadoc line="130">
                Set the initial step used to bracket the optimum in line search.
                  &lt;p&gt;
                  The initial step is a factor with respect to the search direction,
                  which itself is roughly related to the gradient of the function
                  &lt;/p&gt;                
                <param>
                    initialStep initial step used to bracket the optimum in line search,
                      if a non-positive value is used, the initial step is reset to its
                      default value of 1.0                    
                </param>
            </javadoc>
            <method name="setInitialStep" type="void" line="140">
                <params>
                    <param name="initialStep" type="double"/>
                </params>
                <scope line="141"/>
                <scope line="143"/>
            </method>
            <javadoc line="148">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="150">
                <comment line="163">
                    Initial search direction.                    
                </comment>
                <comment line="182">
                    We have found an optimum.                    
                </comment>
                <comment line="186">
                    Find the optimal step in the search direction.                    
                </comment>
                <comment line="189">
                    XXX Last parameters is set to a value close to zero in order to
                     work around the divergence problem in the &quot;testCircleFitting&quot;
                     unit test (see MATH-439).                    
                </comment>
                <comment line="193">
                    Subtract used up evaluations.                    
                </comment>
                <comment line="195">
                    Validate new point.                    
                </comment>
                <comment line="207">
                    Compute beta.                    
                </comment>
                <comment line="227">
                    Compute conjugate search direction.                    
                </comment>
                <comment line="230">
                    Break conjugation: reset search direction.                    
                </comment>
                <comment line="233">
                    Compute new conjugate search direction.                    
                </comment>
                <declaration name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;" line="151"/>
                <declaration name="goal" type="GoalType" line="153"/>
                <declaration name="n" type="int" line="154"/>
                <declaration name="r" type="double[]" line="155"/>
                <scope line="156">
                    <scope line="157"/>
                </scope>
                <declaration name="steepestDescent" type="double[]" line="163"/>
                <declaration name="searchDirection" type="double[]" line="164"/>
                <declaration name="delta" type="double" line="166"/>
                <scope line="167"/>
                <declaration name="current" type="PointValuePair" line="171"/>
                <declaration name="iter" type="int" line="172"/>
                <declaration name="maxEval" type="int" line="173"/>
                <scope line="174">
                    <declaration name="objective" type="double" line="177"/>
                    <declaration name="previous" type="PointValuePair" line="178"/>
                    <scope line="180"/>
                    <declaration name="lsf" type="UnivariateFunction" line="186"/>
                    <declaration name="uB" type="double" line="187"/>
                    <declaration name="step" type="double" line="191"/>
                    <scope line="195"/>
                    <scope line="200">
                        <scope line="201"/>
                    </scope>
                    <declaration name="deltaOld" type="double" line="207"/>
                    <declaration name="newSteepestDescent" type="double[]" line="208"/>
                    <scope line="210"/>
                    <declaration name="beta" type="double" line="214"/>
                    <scope line="215"/>
                    <scope line="217">
                        <declaration name="deltaMid" type="double" line="218"/>
                        <scope line="219"/>
                    </scope>
                    <scope line="228"/>
                    <scope line="231">
                        <scope line="233"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="240">
                Find the upper bound b ensuring bracketing of a root between a and b.                
                <param>
                    f function whose root must be bracketed.                    
                </param>
                <param>
                    a lower bound of the interval.                    
                </param>
                <param>
                    h initial step to try.                    
                </param>
                <return>
                    b such that f(a) and f(b) have opposite signs.                    
                </return>
                <throws>
                    MathIllegalStateException if no bracket can be found.                    
                </throws>
            </javadoc>
            <method name="findUpperBound" type="double" line="250">
                <params>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="a" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <declaration name="yA" type="double" line="251"/>
                <declaration name="yB" type="double" line="252"/>
                <scope line="253">
                    <declaration name="b" type="double" line="254"/>
                    <scope line="256"/>
                </scope>
            </method>
            <class name="IdentityPreconditioner" line="263">
                <implements interface="Preconditioner"/>
                <javadoc line="263">
                    Default identity preconditioner.                    
                </javadoc>
                <javadoc line="266">
                    {@inheritDoc}                    
                </javadoc>
                <method name="precondition" type="double[]" line="267">
                    <params>
                        <param name="variables" type="double[]"/>
                        <param name="r" type="double[]"/>
                    </params>
                </method>
            </class>
            <class name="LineSearchFunction" line="272">
                <implements interface="UnivariateFunction"/>
                <javadoc line="272">
                    Internal class for line search.
                      &lt;p&gt;
                      The function represented by this class is the dot product of
                      the objective function gradient and the search direction. Its
                      value is zero when the gradient is orthogonal to the search
                      direction, i.e. when the objective function value is a local
                      extremum along the search direction.
                      &lt;/p&gt;                    
                </javadoc>
                <declaration name="searchDirection" type="double[]" line="282"/>
                <javadoc line="282">
                    Search direction.                    
                </javadoc>
                <javadoc line="285">
                    Simple constructor.                    
                    <param>
                        searchDirection search direction                        
                    </param>
                </javadoc>
                <method name="LineSearchFunction" type="constructor" line="288">
                    <params>
                        <param name="searchDirection" type="double[]"/>
                    </params>
                </method>
                <javadoc line="292">
                    {@inheritDoc}                    
                </javadoc>
                <method name="value" type="double" line="293">
                    <params>
                        <param name="x" type="double"/>
                    </params>
                    <comment line="295">
                        current point in the search direction                        
                    </comment>
                    <comment line="301">
                        gradient of the objective function                        
                    </comment>
                    <comment line="304">
                        dot product with the search direction                        
                    </comment>
                    <declaration name="shiftedPoint" type="double[]" line="295"/>
                    <scope line="296"/>
                    <declaration name="gradient" type="double[]" line="301"/>
                    <declaration name="dotProduct" type="double" line="304"/>
                    <scope line="305"/>
                </method>
            </class>
        </class>
    </source>