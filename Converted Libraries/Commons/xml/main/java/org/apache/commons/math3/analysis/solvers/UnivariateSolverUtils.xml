<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.solvers">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="UnivariateSolverUtils" line="27">
            <javadoc line="27">
                Utility routines for {@link UnivariateSolver} objects.                
                <version>
                    $Id: UnivariateSolverUtils.java 1579346 2014-03-19 18:43:39Z erans $                    
                </version>
            </javadoc>
            <javadoc line="33">
                Class contains only static methods.                
            </javadoc>
            <method name="UnivariateSolverUtils" type="constructor" line="36"/>
            <javadoc line="38">
                Convenience method to find a zero of a univariate real function.  A default
                  solver is used.                
                <param>
                    function Function.                    
                </param>
                <param>
                    x0 Lower bound for the interval.                    
                </param>
                <param>
                    x1 Upper bound for the interval.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="solve" type="double" line="52">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="x0" type="double"/>
                    <param name="x1" type="double"/>
                </params>
                <scope line="53"/>
                <declaration name="solver" type="UnivariateSolver" line="56"/>
            </method>
            <javadoc line="60">
                Convenience method to find a zero of a univariate real function.  A default
                  solver is used.                
                <param>
                    function Function.                    
                </param>
                <param>
                    x0 Lower bound for the interval.                    
                </param>
                <param>
                    x1 Upper bound for the interval.                    
                </param>
                <param>
                    absoluteAccuracy Accuracy to be used by the solver.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="solve" type="double" line="77">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="x0" type="double"/>
                    <param name="x1" type="double"/>
                    <param name="absoluteAccuracy" type="double"/>
                </params>
                <scope line="78"/>
                <declaration name="solver" type="UnivariateSolver" line="81"/>
            </method>
            <javadoc line="85">
                Force a root found by a non-bracketing solver to lie on a specified side,
                  as if the solver was a bracketing one.                
                <param>
                    maxEval maximal number of new evaluations of the function
                      (evaluations already done for finding the root should have already been subtracted
                      from this number)                    
                </param>
                <param>
                    f function to solve                    
                </param>
                <param>
                    bracketing bracketing solver to use for shifting the root                    
                </param>
                <param>
                    baseRoot original root found by a previous non-bracketing solver                    
                </param>
                <param>
                    min minimal bound of the search interval                    
                </param>
                <param>
                    max maximal bound of the search interval                    
                </param>
                <param>
                    allowedSolution the kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a root approximation, on the specified side of the exact root                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
            </javadoc>
            <method name="forceSide" type="double" line="105">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="bracketing" type="BracketedUnivariateSolver&lt;UnivariateFunction&gt;"/>
                    <param name="baseRoot" type="double"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
                <comment line="109">
                    no further bracketing required                    
                </comment>
                <comment line="113">
                    find a very small interval bracketing the root                    
                </comment>
                <comment line="124">
                    compute the root on the selected side                    
                </comment>
                <comment line="128">
                    try increasing the interval                    
                </comment>
                <comment line="132">
                    increasing function                    
                </comment>
                <comment line="139">
                    decreasing function                    
                </comment>
                <comment line="146">
                    unknown variation                    
                </comment>
                <comment line="151">
                    update the lower bound                    
                </comment>
                <comment line="158">
                    update the higher bound                    
                </comment>
                <scope line="107"/>
                <declaration name="step" type="double" line="113"/>
                <declaration name="xLo" type="double" line="115"/>
                <declaration name="fLo" type="double" line="116"/>
                <declaration name="xHi" type="double" line="117"/>
                <declaration name="fHi" type="double" line="118"/>
                <declaration name="remainingEval" type="int" line="119"/>
                <scope line="120">
                    <scope line="122"/>
                    <declaration name="changeLo" type="boolean" line="128"/>
                    <declaration name="changeHi" type="boolean" line="129"/>
                    <scope line="130">
                        <scope line="132"/>
                        <scope line="134"/>
                    </scope>
                    <scope line="137">
                        <scope line="139"/>
                        <scope line="141"/>
                    </scope>
                    <scope line="144"/>
                    <scope line="151"/>
                    <scope line="158"/>
                </scope>
            </method>
            <javadoc line="173">
                This method simply calls {@link #bracket(UnivariateFunction,double,double,double,double,double,int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}with {@code q} and {@code r} set to 1.0 and {@code maximumIterations} set to {@code Integer.MAX_VALUE}.
                  &lt;strong&gt;Note: &lt;/strong&gt; this method can take
                  &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; iterations to throw a
                  &lt;code&gt;ConvergenceException.&lt;/code&gt;  Unless you are confident that there
                  is a root between &lt;code&gt;lowerBound&lt;/code&gt; and &lt;code&gt;upperBound&lt;/code&gt;
                  near &lt;code&gt;initial,&lt;/code&gt; it is better to use{@link #bracket(UnivariateFunction,double,double,double,double,double,int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)},
                  explicitly specifying the maximum number of iterations.&lt;/p&gt;                
                <param>
                    function Function.                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value)                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <return>
                    a two-element array holding a and b.                    
                </return>
                <throws>
                    NoBracketingException if a root cannot be bracketted.                    
                </throws>
                <throws>
                    NotStrictlyPositiveException if {@code maximumIterations &lt;= 0}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="bracket" type="double[]" line="202">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                </params>
            </method>
            <javadoc line="206">
                This method simply calls {@link #bracket(UnivariateFunction,double,double,double,double,double,int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}with {@code q} and {@code r} set to 1.0.                
                <param>
                    function Function.                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value).                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <param>
                    maximumIterations Maximum number of iterations to perform                    
                </param>
                <return>
                    a two element array holding a and b.                    
                </return>
                <throws>
                    NoBracketingException if the algorithm fails to find a and b
                      satisfying the desired conditions.                    
                </throws>
                <throws>
                    NotStrictlyPositiveException if {@code maximumIterations &lt;= 0}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="bracket" type="double[]" line="229">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                    <param name="maximumIterations" type="int"/>
                </params>
            </method>
            <javadoc line="233">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                  &lt;li&gt; {@code lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound} &lt;/li&gt;
                  &lt;li&gt; {@code f(a)  f(b) &lt;= 0} &lt;/li&gt;
                  &lt;/ul&gt;
                  If {@code f} is continuous on {@code [a,b]}, this means that {@code a}and {@code b} bracket a root of {@code f}.
                  &lt;p&gt;
                  The algorithm checks the sign of \( f(l_k) \) and \( f(u_k) \) for increasing
                  values of k, where \( l_k = max(lower, initial - \delta_k) \),
                  \( u_k = min(upper, initial + \delta_k) \), using recurrence
                  \( \delta_{k+1} = r \delta_k + q, \delta_0 = 0\) and starting search with \( k=1 \).
                  The algorithm stops when one of the following happens: &lt;ul&gt;
                  &lt;li&gt; at least one positive and one negative value have been found --  success!&lt;/li&gt;
                  &lt;li&gt; both endpoints have reached their respective limites -- NoBracketingException &lt;/li&gt;
                  &lt;li&gt; {@code maximumIterations} iterations elapse -- NoBracketingException &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
                  &lt;p&gt;
                  If different signs are found at first iteration ({@code k=1}), then the returned
                  interval will be \( [a, b] = [l_1, u_1] \). If different signs are found at a later
                  iteration ({code k&gt;1}, then the returned interval will be either
                  \( [a, b] = [l_{k+1}, l_{k}] \) or ( [a, b] = [u_{k}, u_{k+1}] \). A root solver called
                  with these parameters will therefore start with the smallest bracketing interval known
                  at this step.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Interval expansion rate is tuned by changing the recurrence parameters {@code r} and{@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a
                  simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}is larger than 1, the sequence has an asymtotically exponential rate. Note than the
                  additive parameter {@code q} should never be set to zero, otherwise the interval would
                  degenerate to the single initial point for all values of {@code k}.
                  &lt;/p&gt;
                  &lt;p&gt;
                  As a rule of thumb, when the location of the root is expected to be approximately known
                  within some error margin, {@code r} should be set to 1 and {@code q} should be set to the
                  order of magnitude of the error margin. When the location of the root is really a wild guess,
                  then {@code r} should be set to a value larger than 1 (typically 2 to double the interval
                  length at each iteration) and {@code q} should be set according to half the initial
                  search interval length.
                  &lt;/p&gt;
                  &lt;p&gt;
                  As an example, if we consider the trivial function {@code f(x) = 1 - x} and use{@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute{@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then{@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will
                  return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.
                  As shown by this example, the initial value (here {@code 4}) may lie outside of the returned
                  bracketing interval.
                  &lt;/p&gt;                
                <param>
                    function function to check                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value).                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <param>
                    q additive offset used to compute bounds sequence (must be strictly positive)                    
                </param>
                <param>
                    r multiplicative factor used to compute bounds sequence                    
                </param>
                <param>
                    maximumIterations Maximum number of iterations to perform                    
                </param>
                <return>
                    a two element array holding the bracketing values.                    
                </return>
                <exception>
                    NoBracketingException if function cannot be bracketed in the search interval                    
                </exception>
            </javadoc>
            <method name="bracket" type="double[]" line="297">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                    <param name="q" type="double"/>
                    <param name="r" type="double"/>
                    <param name="maximumIterations" type="int"/>
                </params>
                <comment line="311">
                    initialize the recurrence                    
                </comment>
                <comment line="334">
                    at first iteration, we don&apos;t have a previous interval
                     we simply compare both sides of the initial interval                    
                </comment>
                <comment line="337">
                    the first interval already brackets a root                    
                </comment>
                <comment line="341">
                    we have a previous interval with constant sign and expand it,
                     we expect sign changes to occur at boundaries                    
                </comment>
                <comment line="344">
                    sign change detected at near lower bound                    
                </comment>
                <comment line="347">
                    sign change detected at near upper bound                    
                </comment>
                <comment line="354">
                    no bracketing found                    
                </comment>
                <scope line="299"/>
                <scope line="302"/>
                <scope line="305"/>
                <declaration name="a" type="double" line="311"/>
                <declaration name="b" type="double" line="312"/>
                <declaration name="fa" type="double" line="313"/>
                <declaration name="fb" type="double" line="314"/>
                <declaration name="delta" type="double" line="315"/>
                <scope line="319">
                    <declaration name="previousA" type="double" line="321"/>
                    <declaration name="previousFa" type="double" line="322"/>
                    <declaration name="previousB" type="double" line="323"/>
                    <declaration name="previousFb" type="double" line="324"/>
                    <scope line="332">
                        <scope line="335"/>
                    </scope>
                    <scope line="339">
                        <scope line="342"/>
                        <scope line="345"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="358">
                Compute the midpoint of two values.                
                <param>
                    a first value.                    
                </param>
                <param>
                    b second value.                    
                </param>
                <return>
                    the midpoint.                    
                </return>
            </javadoc>
            <method name="midpoint" type="double" line="365">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
            </method>
            <javadoc line="369">
                Check whether the interval bounds bracket a root. That is, if the
                  values at the endpoints are not equal to zero, then the function takes
                  opposite signs at the endpoints.                
                <param>
                    function Function.                    
                </param>
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <return>
                    {@code true} if the function values have opposite signs at the
                      given points.                    
                </return>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="isBracketing" type="boolean" line="384">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="385"/>
                <declaration name="fLo" type="double" line="388"/>
                <declaration name="fHi" type="double" line="389"/>
            </method>
            <javadoc line="393">
                Check whether the arguments form a (strictly) increasing sequence.                
                <param>
                    start First number.                    
                </param>
                <param>
                    mid Second number.                    
                </param>
                <param>
                    end Third number.                    
                </param>
                <return>
                    {@code true} if the arguments form an increasing sequence.                    
                </return>
            </javadoc>
            <method name="isSequence" type="boolean" line="403">
                <params>
                    <param name="start" type="double"/>
                    <param name="mid" type="double"/>
                    <param name="end" type="double"/>
                </params>
            </method>
            <javadoc line="407">
                Check that the endpoints specify an interval.                
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NumberIsTooLargeException if {@code lower &gt;= upper}.                    
                </throws>
            </javadoc>
            <method name="verifyInterval" type="void" line="416">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="417"/>
            </method>
            <javadoc line="423">
                Check that {@code lower &lt; initial &lt; upper}.                
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    initial Initial value.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NumberIsTooLargeException if {@code lower &gt;= initial} or{@code initial &gt;= upper}.                    
                </throws>
            </javadoc>
            <method name="verifySequence" type="void" line="435">
                <params>
                    <param name="lower" type="double"/>
                    <param name="initial" type="double"/>
                    <param name="upper" type="double"/>
                </params>
            </method>
            <javadoc line="440">
                Check that the endpoints specify an interval and the end points
                  bracket a root.                
                <param>
                    function Function.                    
                </param>
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="verifyBracketing" type="void" line="455">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="456"/>
                <scope line="460"/>
            </method>
        </class>
    </source>