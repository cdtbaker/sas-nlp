<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.solvers">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="UnivariateSolverUtils" line="9">
            <javadoc line="9">
                Utility routines for {@link UnivariateSolver} objects.                
                <version>
                    $Id: UnivariateSolverUtils.java 1400850 2012-10-22 11:57:17Z erans $                    
                </version>
            </javadoc>
            <javadoc line="14">
                Class contains only static methods.                
            </javadoc>
            <method name="UnivariateSolverUtils" type="constructor" line="17"/>
            <javadoc line="19">
                Convenience method to find a zero of a univariate real function.  A default
                  solver is used.                
                <param>
                    function Function.                    
                </param>
                <param>
                    x0 Lower bound for the interval.                    
                </param>
                <param>
                    x1 Upper bound for the interval.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="solve" type="double" line="30">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="x0" type="double"/>
                    <param name="x1" type="double"/>
                </params>
                <scope line="31"/>
                <declaration name="solver" type="UnivariateSolver" line="34"/>
            </method>
            <javadoc line="37">
                Convenience method to find a zero of a univariate real function.  A default
                  solver is used.                
                <param>
                    function Function.                    
                </param>
                <param>
                    x0 Lower bound for the interval.                    
                </param>
                <param>
                    x1 Upper bound for the interval.                    
                </param>
                <param>
                    absoluteAccuracy Accuracy to be used by the solver.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="solve" type="double" line="49">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="x0" type="double"/>
                    <param name="x1" type="double"/>
                    <param name="absoluteAccuracy" type="double"/>
                </params>
                <scope line="50"/>
                <declaration name="solver" type="UnivariateSolver" line="53"/>
            </method>
            <javadoc line="56">
                Force a root found by a non-bracketing solver to lie on a specified side,
                  as if the solver was a bracketing one.                
                <param>
                    maxEval maximal number of new evaluations of the function
                      (evaluations already done for finding the root should have already been subtracted
                      from this number)                    
                </param>
                <param>
                    f function to solve                    
                </param>
                <param>
                    bracketing bracketing solver to use for shifting the root                    
                </param>
                <param>
                    baseRoot original root found by a previous non-bracketing solver                    
                </param>
                <param>
                    min minimal bound of the search interval                    
                </param>
                <param>
                    max maximal bound of the search interval                    
                </param>
                <param>
                    allowedSolution the kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a root approximation, on the specified side of the exact root                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
            </javadoc>
            <method name="forceSide" type="double" line="73">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="bracketing" type="BracketedUnivariateSolver<UnivariateFunction>"/>
                    <param name="baseRoot" type="double"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
                <scope line="74"/>
                <declaration name="step" type="double" line="77"/>
                <declaration name="xLo" type="double" line="78"/>
                <declaration name="fLo" type="double" line="79"/>
                <declaration name="xHi" type="double" line="80"/>
                <declaration name="fHi" type="double" line="81"/>
                <declaration name="remainingEval" type="int" line="82"/>
                <scope line="83">
                    <scope line="84"/>
                    <declaration name="changeLo" type="boolean" line="87"/>
                    <declaration name="changeHi" type="boolean" line="88"/>
                    <scope line="89">
                        <scope line="90"/>
                        <scope line="93"/>
                    </scope>
                    <scope line="97">
                        <scope line="98"/>
                        <scope line="101"/>
                    </scope>
                    <scope line="105"/>
                    <scope line="109"/>
                    <scope line="114"/>
                </scope>
            </method>
            <javadoc line="122">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt; 0 &lt;/code&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
                  and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
                  &lt;p&gt;
                  The algorithm starts by setting
                  &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
                  function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
                  the endpoints out by one unit each time through a loop that terminates
                  when one of the following happens: &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt; 0 &lt;/code&gt; --  success!&lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
                  -- NoBracketingException &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; Integer.MAX_VALUE&lt;/code&gt; iterations elapse
                  -- NoBracketingException &lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;
                  &lt;p&gt;
                  &lt;strong&gt;Note: &lt;/strong&gt; this method can take
                  &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; iterations to throw a
                  &lt;code&gt;ConvergenceException.&lt;/code&gt;  Unless you are confident that there
                  is a root between &lt;code&gt;lowerBound&lt;/code&gt; and &lt;code&gt;upperBound&lt;/code&gt;
                  near &lt;code&gt;initial,&lt;/code&gt; it is better to use{@link #bracket(UnivariateFunction,double,double,double,int)},
                  explicitly specifying the maximum number of iterations.&lt;/p&gt;                
                <param>
                    function Function.                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value)                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <return>
                    a two-element array holding a and b.                    
                </return>
                <throws>
                    NoBracketingException if a root cannot be bracketted.                    
                </throws>
                <throws>
                    NotStrictlyPositiveException if {@code maximumIterations <= 0}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="bracket" type="double[]" line="159">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                </params>
            </method>
            <javadoc line="162">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt;= 0 &lt;/code&gt; &lt;/li&gt;
                  &lt;/ul&gt;
                  If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
                  and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
                  &lt;p&gt;
                  The algorithm starts by setting
                  &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
                  function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
                  the endpoints out by one unit each time through a loop that terminates
                  when one of the following happens: &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt;= 0 &lt;/code&gt; --  success!&lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
                  -- NoBracketingException &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; maximumIterations&lt;/code&gt; iterations elapse
                  -- NoBracketingException &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;                
                <param>
                    function Function.                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value).                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <param>
                    maximumIterations Maximum number of iterations to perform                    
                </param>
                <return>
                    a two element array holding a and b.                    
                </return>
                <throws>
                    NoBracketingException if the algorithm fails to find a and b
                      satisfying the desired conditions.                    
                </throws>
                <throws>
                    NotStrictlyPositiveException if {@code maximumIterations <= 0}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="bracket" type="double[]" line="193">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                    <param name="maximumIterations" type="int"/>
                </params>
                <scope line="194"/>
                <scope line="197"/>
                <declaration name="a" type="double" line="201"/>
                <declaration name="b" type="double" line="202"/>
                <declaration name="fa" type="double" line="203"/>
                <declaration name="fb" type="double" line="204"/>
                <declaration name="numIterations" type="int" line="205"/>
                <scope line="206"/>
                <scope line="214"/>
            </method>
            <javadoc line="219">
                Compute the midpoint of two values.                
                <param>
                    a first value.                    
                </param>
                <param>
                    b second value.                    
                </param>
                <return>
                    the midpoint.                    
                </return>
            </javadoc>
            <method name="midpoint" type="double" line="225">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
            </method>
            <javadoc line="228">
                Check whether the interval bounds bracket a root. That is, if the
                  values at the endpoints are not equal to zero, then the function takes
                  opposite signs at the endpoints.                
                <param>
                    function Function.                    
                </param>
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <return>
                    {@code true} if the function values have opposite signs at the
                      given points.                    
                </return>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="isBracketing" type="boolean" line="239">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="240"/>
                <declaration name="fLo" type="double" line="243"/>
                <declaration name="fHi" type="double" line="244"/>
            </method>
            <javadoc line="247">
                Check whether the arguments form a (strictly) increasing sequence.                
                <param>
                    start First number.                    
                </param>
                <param>
                    mid Second number.                    
                </param>
                <param>
                    end Third number.                    
                </param>
                <return>
                    {@code true} if the arguments form an increasing sequence.                    
                </return>
            </javadoc>
            <method name="isSequence" type="boolean" line="254">
                <params>
                    <param name="start" type="double"/>
                    <param name="mid" type="double"/>
                    <param name="end" type="double"/>
                </params>
            </method>
            <javadoc line="257">
                Check that the endpoints specify an interval.                
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NumberIsTooLargeException if {@code lower >= upper}.                    
                </throws>
            </javadoc>
            <method name="verifyInterval" type="void" line="263">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="264"/>
            </method>
            <javadoc line="268">
                Check that {@code lower &lt; initial &lt; upper}.                
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    initial Initial value.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NumberIsTooLargeException if {@code lower >= initial} or{@code initial >= upper}.                    
                </throws>
            </javadoc>
            <method name="verifySequence" type="void" line="275">
                <params>
                    <param name="lower" type="double"/>
                    <param name="initial" type="double"/>
                    <param name="upper" type="double"/>
                </params>
            </method>
            <javadoc line="279">
                Check that the endpoints specify an interval and the end points
                  bracket a root.                
                <param>
                    function Function.                    
                </param>
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="verifyBracketing" type="void" line="289">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="290"/>
                <scope line="294"/>
            </method>
        </class>
    </source>