<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.solvers">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="UnivariateSolverUtils" line="27">
            <javadoc line="27">
                Utility routines for {@link UnivariateSolver} objects.                
                <version>
                    $Id: UnivariateSolverUtils.java 1400850 2012-10-22 11:57:17Z erans $                    
                </version>
            </javadoc>
            <javadoc line="33">
                Class contains only static methods.                
            </javadoc>
            <method name="UnivariateSolverUtils" type="constructor" line="36"/>
            <javadoc line="38">
                Convenience method to find a zero of a univariate real function.  A default
                  solver is used.                
                <param>
                    function Function.                    
                </param>
                <param>
                    x0 Lower bound for the interval.                    
                </param>
                <param>
                    x1 Upper bound for the interval.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="solve" type="double" line="52">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="x0" type="double"/>
                    <param name="x1" type="double"/>
                </params>
                <scope line="53"/>
                <declaration name="solver" type="UnivariateSolver" line="56"/>
            </method>
            <javadoc line="60">
                Convenience method to find a zero of a univariate real function.  A default
                  solver is used.                
                <param>
                    function Function.                    
                </param>
                <param>
                    x0 Lower bound for the interval.                    
                </param>
                <param>
                    x1 Upper bound for the interval.                    
                </param>
                <param>
                    absoluteAccuracy Accuracy to be used by the solver.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="solve" type="double" line="77">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="x0" type="double"/>
                    <param name="x1" type="double"/>
                    <param name="absoluteAccuracy" type="double"/>
                </params>
                <scope line="78"/>
                <declaration name="solver" type="UnivariateSolver" line="81"/>
            </method>
            <javadoc line="85">
                Force a root found by a non-bracketing solver to lie on a specified side,
                  as if the solver was a bracketing one.                
                <param>
                    maxEval maximal number of new evaluations of the function
                      (evaluations already done for finding the root should have already been subtracted
                      from this number)                    
                </param>
                <param>
                    f function to solve                    
                </param>
                <param>
                    bracketing bracketing solver to use for shifting the root                    
                </param>
                <param>
                    baseRoot original root found by a previous non-bracketing solver                    
                </param>
                <param>
                    min minimal bound of the search interval                    
                </param>
                <param>
                    max maximal bound of the search interval                    
                </param>
                <param>
                    allowedSolution the kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a root approximation, on the specified side of the exact root                    
                </return>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
            </javadoc>
            <method name="forceSide" type="double" line="105">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="bracketing" type="BracketedUnivariateSolver<UnivariateFunction>"/>
                    <param name="baseRoot" type="double"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
                <comment line="109">
                    no further bracketing required                    
                </comment>
                <comment line="113">
                    find a very small interval bracketing the root                    
                </comment>
                <comment line="124">
                    compute the root on the selected side                    
                </comment>
                <comment line="128">
                    try increasing the interval                    
                </comment>
                <comment line="132">
                    increasing function                    
                </comment>
                <comment line="139">
                    decreasing function                    
                </comment>
                <comment line="146">
                    unknown variation                    
                </comment>
                <comment line="151">
                    update the lower bound                    
                </comment>
                <comment line="158">
                    update the higher bound                    
                </comment>
                <scope line="107"/>
                <declaration name="step" type="double" line="113"/>
                <declaration name="xLo" type="double" line="115"/>
                <declaration name="fLo" type="double" line="116"/>
                <declaration name="xHi" type="double" line="117"/>
                <declaration name="fHi" type="double" line="118"/>
                <declaration name="remainingEval" type="int" line="119"/>
                <scope line="120">
                    <scope line="122"/>
                    <declaration name="changeLo" type="boolean" line="128"/>
                    <declaration name="changeHi" type="boolean" line="129"/>
                    <scope line="130">
                        <scope line="132"/>
                        <scope line="134"/>
                    </scope>
                    <scope line="137">
                        <scope line="139"/>
                        <scope line="141"/>
                    </scope>
                    <scope line="144"/>
                    <scope line="151"/>
                    <scope line="158"/>
                </scope>
            </method>
            <javadoc line="173">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt; 0 &lt;/code&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
                  and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
                  &lt;p&gt;
                  The algorithm starts by setting
                  &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
                  function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
                  the endpoints out by one unit each time through a loop that terminates
                  when one of the following happens: &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt; 0 &lt;/code&gt; --  success!&lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
                  -- NoBracketingException &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; Integer.MAX_VALUE&lt;/code&gt; iterations elapse
                  -- NoBracketingException &lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;
                  &lt;p&gt;
                  &lt;strong&gt;Note: &lt;/strong&gt; this method can take
                  &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; iterations to throw a
                  &lt;code&gt;ConvergenceException.&lt;/code&gt;  Unless you are confident that there
                  is a root between &lt;code&gt;lowerBound&lt;/code&gt; and &lt;code&gt;upperBound&lt;/code&gt;
                  near &lt;code&gt;initial,&lt;/code&gt; it is better to use{@link #bracket(UnivariateFunction,double,double,double,int)},
                  explicitly specifying the maximum number of iterations.&lt;/p&gt;                
                <param>
                    function Function.                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value)                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <return>
                    a two-element array holding a and b.                    
                </return>
                <throws>
                    NoBracketingException if a root cannot be bracketted.                    
                </throws>
                <throws>
                    NotStrictlyPositiveException if {@code maximumIterations <= 0}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="bracket" type="double[]" line="217">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                </params>
            </method>
            <javadoc line="221">
                This method attempts to find two values a and b satisfying &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; lowerBound &lt;= a &lt; initial &lt; b &lt;= upperBound&lt;/code&gt; &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt;= 0 &lt;/code&gt; &lt;/li&gt;
                  &lt;/ul&gt;
                  If f is continuous on &lt;code&gt;[a,b],&lt;/code&gt; this means that &lt;code&gt;a&lt;/code&gt;
                  and &lt;code&gt;b&lt;/code&gt; bracket a root of f.
                  &lt;p&gt;
                  The algorithm starts by setting
                  &lt;code&gt;a := initial -1; b := initial +1,&lt;/code&gt; examines the value of the
                  function at &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and keeps moving
                  the endpoints out by one unit each time through a loop that terminates
                  when one of the following happens: &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt; f(a)  f(b) &lt;= 0 &lt;/code&gt; --  success!&lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; a = lower &lt;/code&gt; and &lt;code&gt; b = upper&lt;/code&gt;
                  -- NoBracketingException &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt; maximumIterations&lt;/code&gt; iterations elapse
                  -- NoBracketingException &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;                
                <param>
                    function Function.                    
                </param>
                <param>
                    initial Initial midpoint of interval being expanded to
                      bracket a root.                    
                </param>
                <param>
                    lowerBound Lower bound (a is never lower than this value).                    
                </param>
                <param>
                    upperBound Upper bound (b never is greater than this
                      value).                    
                </param>
                <param>
                    maximumIterations Maximum number of iterations to perform                    
                </param>
                <return>
                    a two element array holding a and b.                    
                </return>
                <throws>
                    NoBracketingException if the algorithm fails to find a and b
                      satisfying the desired conditions.                    
                </throws>
                <throws>
                    NotStrictlyPositiveException if {@code maximumIterations <= 0}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="bracket" type="double[]" line="259">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="initial" type="double"/>
                    <param name="lowerBound" type="double"/>
                    <param name="upperBound" type="double"/>
                    <param name="maximumIterations" type="int"/>
                </params>
                <scope line="260"/>
                <scope line="263"/>
                <declaration name="a" type="double" line="268"/>
                <declaration name="b" type="double" line="269"/>
                <declaration name="fa" type="double" line="270"/>
                <declaration name="fb" type="double" line="271"/>
                <declaration name="numIterations" type="int" line="272"/>
                <scope line="274"/>
                <scope line="284"/>
            </method>
            <javadoc line="294">
                Compute the midpoint of two values.                
                <param>
                    a first value.                    
                </param>
                <param>
                    b second value.                    
                </param>
                <return>
                    the midpoint.                    
                </return>
            </javadoc>
            <method name="midpoint" type="double" line="301">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
            </method>
            <javadoc line="305">
                Check whether the interval bounds bracket a root. That is, if the
                  values at the endpoints are not equal to zero, then the function takes
                  opposite signs at the endpoints.                
                <param>
                    function Function.                    
                </param>
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <return>
                    {@code true} if the function values have opposite signs at the
                      given points.                    
                </return>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="isBracketing" type="boolean" line="320">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="321"/>
                <declaration name="fLo" type="double" line="324"/>
                <declaration name="fHi" type="double" line="325"/>
            </method>
            <javadoc line="329">
                Check whether the arguments form a (strictly) increasing sequence.                
                <param>
                    start First number.                    
                </param>
                <param>
                    mid Second number.                    
                </param>
                <param>
                    end Third number.                    
                </param>
                <return>
                    {@code true} if the arguments form an increasing sequence.                    
                </return>
            </javadoc>
            <method name="isSequence" type="boolean" line="339">
                <params>
                    <param name="start" type="double"/>
                    <param name="mid" type="double"/>
                    <param name="end" type="double"/>
                </params>
            </method>
            <javadoc line="343">
                Check that the endpoints specify an interval.                
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NumberIsTooLargeException if {@code lower >= upper}.                    
                </throws>
            </javadoc>
            <method name="verifyInterval" type="void" line="352">
                <params>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="353"/>
            </method>
            <javadoc line="359">
                Check that {@code lower &lt; initial &lt; upper}.                
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    initial Initial value.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NumberIsTooLargeException if {@code lower >= initial} or{@code initial >= upper}.                    
                </throws>
            </javadoc>
            <method name="verifySequence" type="void" line="371">
                <params>
                    <param name="lower" type="double"/>
                    <param name="initial" type="double"/>
                    <param name="upper" type="double"/>
                </params>
            </method>
            <javadoc line="376">
                Check that the endpoints specify an interval and the end points
                  bracket a root.                
                <param>
                    function Function.                    
                </param>
                <param>
                    lower Lower endpoint.                    
                </param>
                <param>
                    upper Upper endpoint.                    
                </param>
                <throws>
                    NoBracketingException if the function has the same sign at the
                      endpoints.                    
                </throws>
                <throws>
                    NullArgumentException if {@code function} is {@code null}.                    
                </throws>
            </javadoc>
            <method name="verifyBracketing" type="void" line="391">
                <params>
                    <param name="function" type="UnivariateFunction"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <scope line="392"/>
                <scope line="396"/>
            </method>
        </class>
    </source>