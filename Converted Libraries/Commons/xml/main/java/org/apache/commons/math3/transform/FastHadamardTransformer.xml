<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.transform">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.analysis.FunctionUtils"/>
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.ArithmeticUtils"/>
        <class name="FastHadamardTransformer" line="27">
            <implements interface="RealTransformer"/>
            <implements interface="Serializable"/>
            <javadoc line="27">
                Implements the &lt;a href=&quot;http://www.archive.chipcenter.com/dsp/DSP000517F1.html&quot;&gt;Fast Hadamard Transform&lt;/a&gt; (FHT).
                  Transformation of an input vector x to the output vector y.
                  &lt;p&gt;
                  In addition to transformation of real vectors, the Hadamard transform can
                  transform integer vectors into integer vectors. However, this integer transform
                  cannot be inverted directly. Due to a scaling factor it may lead to rational results.
                  As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational
                  vector (1/2, -1/2, 0, 0).                
                <version>
                    $Id: FastHadamardTransformer.java 1385310 2012-09-16 16:32:10Z tn $                    
                </version>
                <since>
                    2.0                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="42"/>
            <javadoc line="42">
                Serializable version identifier.                
            </javadoc>
            <javadoc line="45">
                {@inheritDoc}                
                <throws>
                    MathIllegalArgumentException if the length of the data array is
                      not a power of two                    
                </throws>
            </javadoc>
            <method name="transform" type="double[]" line="51">
                <params>
                    <param name="f" type="double[]"/>
                    <param name="type" type="TransformType"/>
                </params>
                <scope line="52"/>
            </method>
            <javadoc line="58">
                {@inheritDoc}                
                <throws>
                    org.apache.commons.math3.exception.NonMonotonicSequenceExceptionif the lower bound is greater than, or equal to the upper bound                    
                </throws>
                <throws>
                    org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points is negative                    
                </throws>
                <throws>
                    MathIllegalArgumentException if the number of sample points is not a power of two                    
                </throws>
            </javadoc>
            <method name="transform" type="double[]" line="69">
                <params>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="n" type="int"/>
                    <param name="type" type="TransformType"/>
                </params>
            </method>
            <javadoc line="74">
                Returns the forward transform of the specified integer data set.The
                  integer transform cannot be inverted directly, due to a scaling factor
                  which may lead to double results.                
                <param>
                    f the integer data array to be transformed (signal)                    
                </param>
                <return>
                    the integer transformed array (spectrum)                    
                </return>
                <throws>
                    MathIllegalArgumentException if the length of the data array is not a power of two                    
                </throws>
            </javadoc>
            <method name="transform" type="int[]" line="83">
                <params>
                    <param name="f" type="int[]"/>
                </params>
            </method>
            <javadoc line="87">
                The FHT (Fast Hadamard Transformation) which uses only subtraction and
                  addition. Requires {@code N  log2(N) = n  2^n} additions.
                  &lt;h3&gt;Short Table of manual calculation for N=8&lt;/h3&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;b&gt;x&lt;/b&gt; is the input vector to be transformed,&lt;/li&gt;
                  &lt;li&gt;&lt;b&gt;y&lt;/b&gt; is the output vector (Fast Hadamard transform of &lt;b&gt;x&lt;/b&gt;),&lt;/li&gt;
                  &lt;li&gt;a and b are helper rows.&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;table align=&quot;center&quot; border=&quot;1&quot; cellpadding=&quot;3&quot;&gt;
                  &lt;tbody align=&quot;center&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;/th&gt;
                  &lt;th&gt;a&lt;/th&gt;
                  &lt;th&gt;b&lt;/th&gt;
                  &lt;th&gt;y&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;0&lt;/sub&gt; = x&lt;sub&gt;0&lt;/sub&gt; + x&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;0&lt;/sub&gt; + a&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;0&lt;/sub &gt;+ b&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;1&lt;/sub&gt; = x&lt;sub&gt;2&lt;/sub&gt; + x&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;2&lt;/sub&gt; + b&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;2&lt;/sub&gt; = x&lt;sub&gt;4&lt;/sub&gt; + x&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;4&lt;/sub&gt; + a&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;4&lt;/sub&gt; + b&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;3&lt;/sub&gt; = x&lt;sub&gt;6&lt;/sub&gt; + x&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;6&lt;/sub&gt; + a&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;6&lt;/sub&gt; + b&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;4&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;0&lt;/sub&gt; = x&lt;sub&gt;0&lt;/sub&gt; - x&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;0&lt;/sub&gt; - a&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;0&lt;/sub&gt; - b&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;5&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;1&lt;/sub&gt; = x&lt;sub&gt;2&lt;/sub&gt; - x&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;2&lt;/sub&gt; - a&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;2&lt;/sub&gt; - b&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;6&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;2&lt;/sub&gt; = x&lt;sub&gt;4&lt;/sub&gt; - x&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;4&lt;/sub&gt; - a&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;4&lt;/sub&gt; - b&lt;sub&gt;5&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;x&lt;sub&gt;7&lt;/sub&gt;&lt;/th&gt;
                  &lt;td&gt;a&lt;sub&gt;3&lt;/sub&gt; = x&lt;sub&gt;6&lt;/sub&gt; - x&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;b&lt;sub&gt;0&lt;/sub&gt; = a&lt;sub&gt;6&lt;/sub&gt; - a&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
                  &lt;td&gt;y&lt;sub&gt;0&lt;/sub&gt; = b&lt;sub&gt;6&lt;/sub&gt; - b&lt;sub&gt;7&lt;/sub&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/tbody&gt;
                  &lt;/table&gt;
                  &lt;h3&gt;How it works&lt;/h3&gt;
                  &lt;ol&gt;
                  &lt;li&gt;Construct a matrix with {@code N} rows and {@code n + 1} columns,{@code hadm[n+1][N]}.&lt;br/&gt;
                  &lt;em&gt;(If I use [x][y] it always means [row-offset][column-offset] of a
                  Matrix with n rows and m columns. Its entries go from M[0][0]
                  to M[n][N])&lt;/em&gt;&lt;/li&gt;
                  &lt;li&gt;Place the input vector {@code x[N]} in the first column of the
                  matrix {@code hadm}.&lt;/li&gt;
                  &lt;li&gt;The entries of the submatrix {@code D_top} are calculated as follows
                  &lt;ul&gt;
                  &lt;li&gt;{@code D_top} goes from entry {@code [0][1]} to{@code [N / 2 - 1][n + 1]},&lt;/li&gt;
                  &lt;li&gt;the columns of {@code D_top} are the pairwise mutually
                  exclusive sums of the previous column.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;The entries of the submatrix {@code D_bottom} are calculated as
                  follows
                  &lt;ul&gt;
                  &lt;li&gt;{@code D_bottom} goes from entry {@code [N / 2][1]} to{@code [N][n + 1]},&lt;/li&gt;
                  &lt;li&gt;the columns of {@code D_bottom} are the pairwise differences
                  of the previous column.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;The consputation of {@code D_top} and {@code D_bottom} are best
                  understood with the above example (for {@code N = 8}).
                  &lt;li&gt;The output vector {@code y} is now in the last column of{@code hadm}.&lt;/li&gt;
                  &lt;li&gt;&lt;em&gt;Algorithm from &lt;a href=&quot;http://www.archive.chipcenter.com/dsp/DSP000517F1.html&quot;&gt;chipcenter&lt;/a&gt;.&lt;/em&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;h3&gt;Visually&lt;/h3&gt;
                  &lt;table border=&quot;1&quot; align=&quot;center&quot; cellpadding=&quot;3&quot;&gt;
                  &lt;tbody align=&quot;center&quot;&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;/td&gt;&lt;th&gt;0&lt;/th&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;th&gt;3&lt;/th&gt;
                  &lt;th&gt;&amp;hellip;&lt;/th&gt;
                  &lt;th&gt;n + 1&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;0&lt;/th&gt;
                  &lt;td&gt;x&lt;sub&gt;0&lt;/sub&gt;&lt;/td&gt;
                  &lt;td colspan=&quot;5&quot; rowspan=&quot;5&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;
                  &amp;uarr;&lt;br/&gt;
                  &amp;larr; D&lt;sub&gt;top&lt;/sub&gt; &amp;rarr;&lt;br/&gt;
                  &amp;darr;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;2&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;hellip;&lt;/th&gt;&lt;td&gt;&amp;hellip;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;N / 2 - 1&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N/2-1&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;th&gt;N / 2&lt;/th&gt;
                  &lt;td&gt;x&lt;sub&gt;N/2&lt;/sub&gt;&lt;/td&gt;
                  &lt;td colspan=&quot;5&quot; rowspan=&quot;5&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;
                  &amp;uarr;&lt;br/&gt;
                  &amp;larr; D&lt;sub&gt;bottom&lt;/sub&gt; &amp;rarr;&lt;br/&gt;
                  &amp;darr;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;N / 2 + 1&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N/2+1&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;N / 2 + 2&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N/2+2&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;hellip;&lt;/th&gt;&lt;td&gt;&amp;hellip;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;N&lt;/th&gt;&lt;td&gt;x&lt;sub&gt;N&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/tbody&gt;
                  &lt;/table&gt;                
                <param>
                    x the real data array to be transformed                    
                </param>
                <return>
                    the real transformed array, {@code y}                    
                </return>
                <throws>
                    MathIllegalArgumentException if the length of the data array is not a power of two                    
                </throws>
            </javadoc>
            <method name="fht" type="double[]" line="229">
                <params>
                    <param name="x" type="double[]"/>
                </params>
                <comment line="241">
                    Instead of creating a matrix with p+1 columns and n rows, we use two
                     one dimension arrays which we are used in an alternating way.                    
                </comment>
                <comment line="248">
                    iterate from left to right (column)                    
                </comment>
                <comment line="251">
                    switch columns                    
                </comment>
                <comment line="256">
                    iterate from top to bottom (row)                    
                </comment>
                <comment line="258">
                    Dtop: the top part works with addition                    
                </comment>
                <comment line="263">
                    Dbottom: the bottom part works with subtraction                    
                </comment>
                <declaration name="n" type="int" line="231"/>
                <declaration name="halfN" type="int" line="232"/>
                <scope line="234"/>
                <declaration name="yPrevious" type="double[]" line="244"/>
                <declaration name="yCurrent" type="double[]" line="245"/>
                <scope line="248">
                    <declaration name="yTmp" type="double[]" line="251"/>
                    <scope line="256">
                        <declaration name="twoI" type="int" line="258"/>
                    </scope>
                    <scope line="261">
                        <declaration name="twoI" type="int" line="263"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="272">
                Returns the forward transform of the specified integer data set. The FHT
                  (Fast Hadamard Transform) uses only subtraction and addition.                
                <param>
                    x the integer data array to be transformed                    
                </param>
                <return>
                    the integer transformed array, {@code y}                    
                </return>
                <throws>
                    MathIllegalArgumentException if the length of the data array is not a power of two                    
                </throws>
            </javadoc>
            <method name="fht" type="int[]" line="280">
                <params>
                    <param name="x" type="int[]"/>
                </params>
                <comment line="292">
                    Instead of creating a matrix with p+1 columns and n rows, we use two
                     one dimension arrays which we are used in an alternating way.                    
                </comment>
                <comment line="299">
                    iterate from left to right (column)                    
                </comment>
                <comment line="302">
                    switch columns                    
                </comment>
                <comment line="307">
                    iterate from top to bottom (row)                    
                </comment>
                <comment line="309">
                    Dtop: the top part works with addition                    
                </comment>
                <comment line="314">
                    Dbottom: the bottom part works with subtraction                    
                </comment>
                <comment line="320">
                    return the last computed output vector y                    
                </comment>
                <declaration name="n" type="int" line="282"/>
                <declaration name="halfN" type="int" line="283"/>
                <scope line="285"/>
                <declaration name="yPrevious" type="int[]" line="295"/>
                <declaration name="yCurrent" type="int[]" line="296"/>
                <scope line="299">
                    <declaration name="yTmp" type="int[]" line="302"/>
                    <scope line="307">
                        <declaration name="twoI" type="int" line="309"/>
                    </scope>
                    <scope line="312">
                        <declaration name="twoI" type="int" line="314"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>