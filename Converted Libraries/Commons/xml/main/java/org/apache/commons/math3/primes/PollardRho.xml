<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.primes">
        <import package="java.util.ArrayList"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="PollardRho" line="5">
            <javadoc line="5">
                Implementation of the Pollard&apos;s rho factorization algorithm.                
                <version>
                    $Id: PollardRho.java 1462702 2013-03-30 04:45:52Z psteitz $                    
                </version>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <javadoc line="11">
                Hide utility class.                
            </javadoc>
            <method name="PollardRho" type="constructor" line="14"/>
            <javadoc line="16">
                Factorization using Pollard&apos;s rho algorithm.                
                <param>
                    n number to factors, must be &gt; 0                    
                </param>
                <return>
                    the list of prime factors of n.                    
                </return>
            </javadoc>
            <method name="primeFactors" type="List<Integer>" line="21">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="factors" type="List&lt;Integer&gt;" line="22"/>
                <scope line="24"/>
                <scope line="27"/>
                <declaration name="divisor" type="int" line="31"/>
            </method>
            <javadoc line="36">
                Implementation of the Pollard&apos;s rho factorization algorithm.
                  &lt;p&gt;
                  This implementation follows the paper &quot;An improved Monte Carlo factorization algorithm&quot;
                  by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard&apos;s
                  rho implementations. It also batches several gcd computation into 1.
                  &lt;p&gt;
                  The backtracking is not implemented as we deal only with semi-primes.                
                <param>
                    n number to factor, must be semi-prime.                    
                </param>
                <return>
                    a prime factor of n.                    
                </return>
            </javadoc>
            <method name="rhoBrent" type="int" line="47">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="x0" type="int" line="48"/>
                <declaration name="m" type="int" line="49"/>
                <declaration name="cst" type="int" line="50"/>
                <declaration name="y" type="int" line="51"/>
                <declaration name="r" type="int" line="52"/>
                <scope line="53">
                    <declaration name="x" type="int" line="54"/>
                    <scope line="55">
                        <declaration name="y2" type="long" line="56"/>
                    </scope>
                    <declaration name="k" type="int" line="59"/>
                    <scope line="60">
                        <declaration name="bound" type="int" line="61"/>
                        <declaration name="q" type="int" line="62"/>
                        <scope line="63">
                            <declaration name="y2" type="long" line="64"/>
                            <declaration name="divisor" type="long" line="66"/>
                            <scope line="67"/>
                            <declaration name="prod" type="long" line="74"/>
                            <scope line="76"/>
                        </scope>
                        <declaration name="out" type="int" line="80"/>
                        <scope line="81"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="91">
                Gcd between two positive numbers.
                  &lt;p&gt;
                  Gets the greatest common divisor of two numbers, using the &quot;binary gcd&quot; method,
                  which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.
                  This algorithm is due to Josef Stein (1961).
                  &lt;/p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.&lt;/li&gt;
                  &lt;li&gt;The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    a first number, must be &ge; 0                    
                </param>
                <param>
                    b second number, must be &ge; 0                    
                </param>
                <return>
                    gcd(a,b)                    
                </return>
            </javadoc>
            <method name="gcdPositive" type="int" line="107">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <scope line="108"/>
                <scope line="111"/>
                <declaration name="aTwos" type="int" line="114"/>
                <declaration name="bTwos" type="int" line="116"/>
                <declaration name="shift" type="int" line="118"/>
                <scope line="119">
                    <declaration name="delta" type="int" line="120"/>
                </scope>
            </method>
        </class>
    </source>