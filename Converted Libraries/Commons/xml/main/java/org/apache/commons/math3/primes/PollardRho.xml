<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.primes">
        <import package="java.util.ArrayList"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="PollardRho" line="24">
            <javadoc line="24">
                Implementation of the Pollard&apos;s rho factorization algorithm.                
                <version>
                    $Id: PollardRho.java 1462702 2013-03-30 04:45:52Z psteitz $                    
                </version>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <javadoc line="31">
                Hide utility class.                
            </javadoc>
            <method name="PollardRho" type="constructor" line="34"/>
            <javadoc line="37">
                Factorization using Pollard&apos;s rho algorithm.                
                <param>
                    n number to factors, must be &gt; 0                    
                </param>
                <return>
                    the list of prime factors of n.                    
                </return>
            </javadoc>
            <method name="primeFactors" type="List<Integer>" line="42">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="factors" type="List&lt;Integer&gt;" line="43"/>
                <scope line="46"/>
                <scope line="50"/>
                <declaration name="divisor" type="int" line="55"/>
            </method>
            <javadoc line="61">
                Implementation of the Pollard&apos;s rho factorization algorithm.
                  &lt;p&gt;
                  This implementation follows the paper &quot;An improved Monte Carlo factorization algorithm&quot;
                  by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard&apos;s
                  rho implementations. It also batches several gcd computation into 1.
                  &lt;p&gt;
                  The backtracking is not implemented as we deal only with semi-primes.                
                <param>
                    n number to factor, must be semi-prime.                    
                </param>
                <return>
                    a prime factor of n.                    
                </return>
            </javadoc>
            <method name="rhoBrent" type="int" line="73">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="89">
                    start at -3 to ensure we enter this loop at least 3 times                    
                </comment>
                <declaration name="x0" type="int" line="74"/>
                <declaration name="m" type="int" line="75"/>
                <declaration name="cst" type="int" line="76"/>
                <declaration name="y" type="int" line="77"/>
                <declaration name="r" type="int" line="78"/>
                <scope line="79">
                    <declaration name="x" type="int" line="80"/>
                    <scope line="81">
                        <declaration name="y2" type="long" line="82"/>
                    </scope>
                    <declaration name="k" type="int" line="85"/>
                    <scope line="86">
                        <declaration name="bound" type="int" line="87"/>
                        <declaration name="q" type="int" line="88"/>
                        <scope line="89">
                            <declaration name="y2" type="long" line="90"/>
                            <declaration name="divisor" type="long" line="92"/>
                            <scope line="93"/>
                            <declaration name="prod" type="long" line="100"/>
                            <scope line="102"/>
                        </scope>
                        <declaration name="out" type="int" line="106"/>
                        <scope line="107"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="116">
                Gcd between two positive numbers.
                  &lt;p&gt;
                  Gets the greatest common divisor of two numbers, using the &quot;binary gcd&quot; method,
                  which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.
                  This algorithm is due to Josef Stein (1961).
                  &lt;/p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt;The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.&lt;/li&gt;
                  &lt;li&gt;The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    a first number, must be &ge; 0                    
                </param>
                <param>
                    b second number, must be &ge; 0                    
                </param>
                <return>
                    gcd(a,b)                    
                </return>
            </javadoc>
            <method name="gcdPositive" type="int" line="133">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <comment line="134">
                    both a and b must be positive, it is not checked here                    
                </comment>
                <comment line="135">
                    gdc(a,0) = a                    
                </comment>
                <comment line="142">
                    make a and b odd, keep in mind the common power of twos                    
                </comment>
                <comment line="149">
                    a and b &gt;0                    
                </comment>
                <comment line="150">
                    if a &gt; b then gdc(a,b) = gcd(a-b,b)                    
                </comment>
                <comment line="151">
                    if a &lt; b then gcd(a,b) = gcd(b-a,a)                    
                </comment>
                <comment line="152">
                    so next a is the absolute difference and next b is the minimum of current values                    
                </comment>
                <comment line="157">
                    for speed optimization:                    
                </comment>
                <comment line="158">
                    remove any power of two in a as b is guaranteed to be odd throughout all iterations                    
                </comment>
                <comment line="162">
                    gcd(a,a) = a, just &quot;add&quot; the common power of twos                    
                </comment>
                <scope line="136"/>
                <scope line="138"/>
                <declaration name="aTwos" type="int" line="143"/>
                <declaration name="bTwos" type="int" line="145"/>
                <declaration name="shift" type="int" line="147"/>
                <scope line="153">
                    <declaration name="delta" type="int" line="154"/>
                </scope>
            </method>
        </class>
    </source>