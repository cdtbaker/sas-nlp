<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar.gradient">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.analysis.solvers.BrentSolver"/>
        <import package="org.apache.commons.math3.analysis.solvers.UnivariateSolver"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.TooManyEvaluationsException"/>
        <import package="org.apache.commons.math3.exception.MathUnsupportedOperationException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optim.OptimizationData"/>
        <import package="org.apache.commons.math3.optim.PointValuePair"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="NonLinearConjugateGradientOptimizer" line="16">
            <extends class="GradientMultivariateOptimizer"/>
            <javadoc line="16">
                Non-linear conjugate gradient optimizer.
                  &lt;br/&gt;
                  This class supports both the Fletcher-Reeves and the Polak-Ribière
                  update formulas for the conjugate search directions.
                  It also supports optional preconditioning.
                  &lt;br/&gt;
                  Constraints are not supported: the call to{@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.                
                <version>
                    $Id: NonLinearConjugateGradientOptimizer.java 1462503 2013-03-29 15:48:27Z luc $                    
                </version>
                <since>
                    2.0                    
                </since>
            </javadoc>
            <declaration name="updateFormula" type="Formula" line="28"/>
            <javadoc line="28">
                Update formula for the beta parameter.                
            </javadoc>
            <declaration name="preconditioner" type="Preconditioner" line="32"/>
            <javadoc line="32">
                Preconditioner (may be null).                
            </javadoc>
            <declaration name="solver" type="UnivariateSolver" line="36"/>
            <javadoc line="36">
                solver to use in the line search (may be null).                
            </javadoc>
            <declaration name="initialStep" type="double" line="40"/>
            <javadoc line="40">
                Initial step used to bracket the optimum in line search.                
            </javadoc>
            <javadoc line="44">
                Constructor with default {@link BrentSolver line search solver} and{@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &beta; parameter,
                      must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="50">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                </params>
            </method>
            <declaration name="Formula" type="enum" line="53"/>
            <javadoc line="53">
                Available choices of update formulas for the updating the parameter
                  that is used to compute the successive conjugate search directions.
                  For non-linear conjugate gradients, there are
                  two formulas:
                  &lt;ul&gt;
                  &lt;li&gt;Fletcher-Reeves formula&lt;/li&gt;
                  &lt;li&gt;Polak-Ribière formula&lt;/li&gt;
                  &lt;/ul&gt;
                  On the one hand, the Fletcher-Reeves formula is guaranteed to converge
                  if the start point is close enough of the optimum whether the
                  Polak-Ribière formula may not converge in rare cases. On the
                  other hand, the Polak-Ribière formula is often faster when it
                  does converge. Polak-Ribière is often used.                
                <since>
                    2.0                    
                </since>
            </javadoc>
            <scope line="69"/>
            <class name="BracketingStep" line="76">
                <implements interface="OptimizationData"/>
                <javadoc line="76">
                    The initial step is a factor with respect to the search direction
                      (which itself is roughly related to the gradient of the function).
                      &lt;br/&gt;
                      It is used to find an interval that brackets the optimum in line
                      search.                    
                    <since>
                        3.1                        
                    </since>
                </javadoc>
                <declaration name="initialStep" type="double" line="85"/>
                <javadoc line="85">
                    Initial step.                    
                </javadoc>
                <javadoc line="89">
                    @param step Initial step for the bracket search.                    
                </javadoc>
                <method name="BracketingStep" type="constructor" line="92">
                    <params>
                        <param name="step" type="double"/>
                    </params>
                </method>
                <javadoc line="95">
                    Gets the initial step.                    
                    <return>
                        the initial step.                        
                    </return>
                </javadoc>
                <method name="getBracketingStep" type="double" line="99"/>
            </class>
            <javadoc line="103">
                Constructor with default {@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &beta; parameter,
                      must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    lineSearchSolver Solver to use during line search.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="110">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                    <param name="lineSearchSolver" type="UnivariateSolver"/>
                </params>
            </method>
            <javadoc line="113">
                @param updateFormula formula to use for updating the &amp;beta; parameter,
                  must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    lineSearchSolver Solver to use during line search.                    
                </param>
                <param>
                    preconditioner Preconditioner.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="120">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                    <param name="lineSearchSolver" type="UnivariateSolver"/>
                    <param name="preconditioner" type="Preconditioner"/>
                </params>
            </method>
            <javadoc line="127">
                {@inheritDoc}                
                <param>
                    optData Optimization data. In addition to those documented in{@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])GradientMultivariateOptimizer}, this method will register the following data:
                      <ul>
                      <li>{@link BracketingStep}</li>
                      </ul>                    
                </param>
                <return>
                    {@inheritDoc}                    
                </return>
                <throws>
                    TooManyEvaluationsException if the maximal number of
                      evaluations (of the objective function) is exceeded.                    
                </throws>
            </javadoc>
            <method name="optimize" type="PointValuePair" line="137">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
            </method>
            <javadoc line="140">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="143">
                <declaration name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;" line="144"/>
                <declaration name="point" type="double[]" line="145"/>
                <declaration name="goal" type="GoalType" line="146"/>
                <declaration name="n" type="int" line="147"/>
                <declaration name="r" type="double[]" line="148"/>
                <scope line="149">
                    <scope line="150"/>
                </scope>
                <declaration name="steepestDescent" type="double[]" line="154"/>
                <declaration name="searchDirection" type="double[]" line="155"/>
                <declaration name="delta" type="double" line="156"/>
                <scope line="157"/>
                <declaration name="current" type="PointValuePair" line="160"/>
                <declaration name="maxEval" type="int" line="161"/>
                <scope line="162">
                    <declaration name="objective" type="double" line="164"/>
                    <declaration name="previous" type="PointValuePair" line="165"/>
                    <scope line="167"/>
                    <declaration name="lsf" type="UnivariateFunction" line="170"/>
                    <declaration name="uB" type="double" line="171"/>
                    <declaration name="step" type="double" line="172"/>
                    <scope line="174"/>
                    <scope line="178">
                        <scope line="179"/>
                    </scope>
                    <declaration name="deltaOld" type="double" line="183"/>
                    <declaration name="newSteepestDescent" type="double[]" line="184"/>
                    <scope line="186"/>
                    <declaration name="beta" type="double" line="189"/>
                    <declaration name="deltaMid" type="double" line="195"/>
                    <scope line="196"/>
                    <scope line="205"/>
                    <scope line="208">
                        <scope line="209"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="215">
                Scans the list of (required and optional) optimization data that
                  characterize the problem.                
                <param>
                    optData Optimization data.
                      The following data will be looked for:
                      <ul>
                      <li>{@link BracketingStep}</li>
                      </ul>                    
                </param>
            </javadoc>
            <method name="parseOptimizationData" type="void" line="224">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <scope line="226">
                    <scope line="227"/>
                </scope>
            </method>
            <javadoc line="234">
                Finds the upper bound b ensuring bracketing of a root between a and b.                
                <param>
                    f function whose root must be bracketed.                    
                </param>
                <param>
                    a lower bound of the interval.                    
                </param>
                <param>
                    h initial step to try.                    
                </param>
                <return>
                    b such that f(a) and f(b) have opposite signs.                    
                </return>
                <throws>
                    MathIllegalStateException if no bracket can be found.                    
                </throws>
            </javadoc>
            <method name="findUpperBound" type="double" line="242">
                <params>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="a" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <declaration name="yA" type="double" line="243"/>
                <declaration name="yB" type="double" line="244"/>
                <scope line="245">
                    <declaration name="b" type="double" line="246"/>
                    <scope line="248"/>
                </scope>
            </method>
            <class name="IdentityPreconditioner" line="254">
                <implements interface="Preconditioner"/>
                <javadoc line="254">
                    Default identity preconditioner.                    
                </javadoc>
                <javadoc line="258">
                    {@inheritDoc}                    
                </javadoc>
                <method name="precondition" type="double[]" line="261">
                    <params>
                        <param name="variables" type="double[]"/>
                        <param name="r" type="double[]"/>
                    </params>
                </method>
            </class>
            <class name="LineSearchFunction" line="265">
                <implements interface="UnivariateFunction"/>
                <javadoc line="265">
                    Internal class for line search.
                      &lt;p&gt;
                      The function represented by this class is the dot product of
                      the objective function gradient and the search direction. Its
                      value is zero when the gradient is orthogonal to the search
                      direction, i.e. when the objective function value is a local
                      extremum along the search direction.
                      &lt;/p&gt;                    
                </javadoc>
                <declaration name="currentPoint" type="double[]" line="276"/>
                <javadoc line="276">
                    Current point.                    
                </javadoc>
                <declaration name="searchDirection" type="double[]" line="280"/>
                <javadoc line="280">
                    Search direction.                    
                </javadoc>
                <javadoc line="284">
                    @param point Current point.                    
                    <param>
                        direction Search direction.                        
                    </param>
                </javadoc>
                <method name="LineSearchFunction" type="constructor" line="288">
                    <params>
                        <param name="point" type="double[]"/>
                        <param name="direction" type="double[]"/>
                    </params>
                </method>
                <javadoc line="292">
                    {@inheritDoc}                    
                </javadoc>
                <method name="value" type="double" line="295">
                    <params>
                        <param name="x" type="double"/>
                    </params>
                    <declaration name="shiftedPoint" type="double[]" line="296"/>
                    <scope line="297"/>
                    <declaration name="gradient" type="double[]" line="300"/>
                    <declaration name="dotProduct" type="double" line="301"/>
                    <scope line="302"/>
                </method>
            </class>
            <javadoc line="308">
                @throws MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.                
            </javadoc>
            <method name="checkParameters" type="void" line="311">
                <scope line="312"/>
            </method>
        </class>
    </source>