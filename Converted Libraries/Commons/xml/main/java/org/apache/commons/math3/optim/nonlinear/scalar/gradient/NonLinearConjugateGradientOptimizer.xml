<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar.gradient">
        <import package="org.apache.commons.math3.analysis.solvers.UnivariateSolver"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.TooManyEvaluationsException"/>
        <import package="org.apache.commons.math3.exception.MathUnsupportedOperationException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optim.OptimizationData"/>
        <import package="org.apache.commons.math3.optim.PointValuePair"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.LineSearch"/>
        <class name="NonLinearConjugateGradientOptimizer" line="33">
            <extends class="GradientMultivariateOptimizer"/>
            <comment line="357">
                Class is not used anymore (cf. MATH-1092). However, it might
                 be interesting to create a class similar to &quot;LineSearch&quot;, but
                 that will take advantage that the model&apos;s gradient is available.                
            </comment>
            <comment line="360">
                /**
                      * Internal class for line search.
                      * &lt;p&gt;
                      * The function represented by this class is the dot product of
                      * the objective function gradient and the search direction. Its
                      * value is zero when the gradient is orthogonal to the search
                      * direction, i.e. when the objective function value is a local
                      * extremum along the search direction.
                      * &lt;/p&gt;
                      */
                     private class LineSearchFunction implements UnivariateFunction {
                         /** Current point. */
                         private final double[] currentPoint;
                         /** Search direction. */
                         private final double[] searchDirection;                
            </comment>
            <comment line="376">
                /**
                          * @param point Current point.
                          * @param direction Search direction.
                          */
                         public LineSearchFunction(double[] point,
                                                   double[] direction) {
                             currentPoint = point.clone();
                             searchDirection = direction.clone();
                         }                
            </comment>
            <comment line="386">
                /** {@inheritDoc} */
                         public double value(double x) {
                              current point in the search direction
                             final double[] shiftedPoint = currentPoint.clone();
                             for (int i = 0; i &lt; shiftedPoint.length; ++i) {
                                 shiftedPoint[i] += x * searchDirection[i];
                             }                
            </comment>
            <comment line="394">
                // gradient of the objective function
                             final double[] gradient = computeObjectiveGradient(shiftedPoint);                
            </comment>
            <comment line="397">
                // dot product with the search direction
                             double dotProduct = 0;
                             for (int i = 0; i &lt; gradient.length; ++i) {
                                 dotProduct += gradient[i] * searchDirection[i];
                             }                
            </comment>
            <comment line="403">
                return dotProduct;
                         }
                     }                
            </comment>
            <javadoc line="33">
                Non-linear conjugate gradient optimizer.
                  &lt;br/&gt;
                  This class supports both the Fletcher-Reeves and the Polak-Ribière
                  update formulas for the conjugate search directions.
                  It also supports optional preconditioning.
                  &lt;br/&gt;
                  Constraints are not supported: the call to{@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.                
                <version>
                    $Id: NonLinearConjugateGradientOptimizer.java 1573316 2014-03-02 14:54:37Z erans $                    
                </version>
                <since>
                    2.0                    
                </since>
            </javadoc>
            <declaration name="updateFormula" type="Formula" line="49"/>
            <javadoc line="49">
                Update formula for the beta parameter.                
            </javadoc>
            <declaration name="preconditioner" type="Preconditioner" line="51"/>
            <javadoc line="51">
                Preconditioner (may be null).                
            </javadoc>
            <declaration name="line" type="LineSearch" line="53"/>
            <javadoc line="53">
                Line search algorithm.                
            </javadoc>
            <declaration name="Formula" type="enum" line="56"/>
            <javadoc line="56">
                Available choices of update formulas for the updating the parameter
                  that is used to compute the successive conjugate search directions.
                  For non-linear conjugate gradients, there are
                  two formulas:
                  &lt;ul&gt;
                  &lt;li&gt;Fletcher-Reeves formula&lt;/li&gt;
                  &lt;li&gt;Polak-Ribière formula&lt;/li&gt;
                  &lt;/ul&gt;
                  On the one hand, the Fletcher-Reeves formula is guaranteed to converge
                  if the start point is close enough of the optimum whether the
                  Polak-Ribière formula may not converge in rare cases. On the
                  other hand, the Polak-Ribière formula is often faster when it
                  does converge. Polak-Ribière is often used.                
                <since>
                    2.0                    
                </since>
            </javadoc>
            <scope line="74"/>
            <class name="BracketingStep" line="81">
                <implements interface="OptimizationData"/>
                <javadoc line="81">
                    The initial step is a factor with respect to the search direction
                      (which itself is roughly related to the gradient of the function).
                      &lt;br/&gt;
                      It is used to find an interval that brackets the optimum in line
                      search.                    
                    <since>
                        3.1                        
                    </since>
                    <deprecated>
                        As of v3.3, this class is not used anymore.
                          This setting is replaced by the {@code initialBracketingRange}argument to the new constructors.                        
                    </deprecated>
                </javadoc>
                <declaration name="initialStep" type="double" line="95"/>
                <javadoc line="95">
                    Initial step.                    
                </javadoc>
                <javadoc line="98">
                    @param step Initial step for the bracket search.                    
                </javadoc>
                <method name="BracketingStep" type="constructor" line="101">
                    <params>
                        <param name="step" type="double"/>
                    </params>
                </method>
                <javadoc line="105">
                    Gets the initial step.                    
                    <return>
                        the initial step.                        
                    </return>
                </javadoc>
                <method name="getBracketingStep" type="double" line="110"/>
            </class>
            <javadoc line="115">
                Constructor with default tolerances for the line search (1e-8) and{@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &amp;beta; parameter,
                      must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="125">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;"/>
                </params>
            </method>
            <javadoc line="134">
                Constructor with default {@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &amp;beta; parameter,
                      must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    lineSearchSolver Solver to use during line search.                    
                </param>
                <deprecated>
                    as of 3.3. Please use{@link #NonLinearConjugateGradientOptimizer(Formula,ConvergenceChecker,double,double,double)} instead.                    
                </deprecated>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="148">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;"/>
                    <param name="lineSearchSolver" type="UnivariateSolver"/>
                </params>
            </method>
            <javadoc line="155">
                Constructor with default {@link IdentityPreconditioner preconditioner}.                
                <param>
                    updateFormula formula to use for updating the &amp;beta; parameter,
                      must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                    
                </param>
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    relativeTolerance Relative threshold for line search.                    
                </param>
                <param>
                    absoluteTolerance Absolute threshold for line search.                    
                </param>
                <param>
                    initialBracketingRange Extent of the initial interval used to
                      find an interval that brackets the optimum in order to perform the
                      line search.                    
                </param>
                <see>
                    LineSearch#LineSearch(MultivariateOptimizer,double,double,double)                    
                </see>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="175">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;"/>
                    <param name="relativeTolerance" type="double"/>
                    <param name="absoluteTolerance" type="double"/>
                    <param name="initialBracketingRange" type="double"/>
                </params>
            </method>
            <javadoc line="184">
                @param updateFormula formula to use for updating the &amp;beta; parameter,
                  must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    lineSearchSolver Solver to use during line search.                    
                </param>
                <param>
                    preconditioner Preconditioner.                    
                </param>
                <deprecated>
                    as of 3.3. Please use{@link #NonLinearConjugateGradientOptimizer(Formula,ConvergenceChecker,double,double,double,Preconditioner)} instead.                    
                </deprecated>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="198">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;"/>
                    <param name="lineSearchSolver" type="UnivariateSolver"/>
                    <param name="preconditioner" type="Preconditioner"/>
                </params>
            </method>
            <javadoc line="207">
                @param updateFormula formula to use for updating the &amp;beta; parameter,
                  must be one of {@link Formula#FLETCHER_REEVES} or{@link Formula#POLAK_RIBIERE}.                
                <param>
                    checker Convergence checker.                    
                </param>
                <param>
                    preconditioner Preconditioner.                    
                </param>
                <param>
                    relativeTolerance Relative threshold for line search.                    
                </param>
                <param>
                    absoluteTolerance Absolute threshold for line search.                    
                </param>
                <param>
                    initialBracketingRange Extent of the initial interval used to
                      find an interval that brackets the optimum in order to perform the
                      line search.                    
                </param>
                <see>
                    LineSearch#LineSearch(MultivariateOptimizer,double,double,double)                    
                </see>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="NonLinearConjugateGradientOptimizer" type="constructor" line="227">
                <params>
                    <param name="updateFormula" type="Formula"/>
                    <param name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;"/>
                    <param name="relativeTolerance" type="double"/>
                    <param name="absoluteTolerance" type="double"/>
                    <param name="initialBracketingRange" type="double"/>
                    <param name="preconditioner" type="Preconditioner"/>
                </params>
            </method>
            <javadoc line="238">
                {@inheritDoc}                
            </javadoc>
            <method name="optimize" type="PointValuePair" line="243">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="245">
                    Set up base class and perform computation.                    
                </comment>
            </method>
            <javadoc line="248">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="250">
                <comment line="263">
                    Initial search direction.                    
                </comment>
                <comment line="280">
                    We have found an optimum.                    
                </comment>
                <comment line="286">
                    Validate new point.                    
                </comment>
                <comment line="298">
                    Compute beta.                    
                </comment>
                <comment line="319">
                    Should never happen.                    
                </comment>
                <comment line="324">
                    Compute conjugate search direction.                    
                </comment>
                <comment line="327">
                    Break conjugation: reset search direction.                    
                </comment>
                <comment line="330">
                    Compute new conjugate search direction.                    
                </comment>
                <declaration name="checker" type="ConvergenceChecker&amp;lt;PointValuePair&amp;gt;" line="251"/>
                <declaration name="point" type="double[]" line="252"/>
                <declaration name="goal" type="GoalType" line="253"/>
                <declaration name="n" type="int" line="254"/>
                <declaration name="r" type="double[]" line="255"/>
                <scope line="256">
                    <scope line="257"/>
                </scope>
                <declaration name="steepestDescent" type="double[]" line="263"/>
                <declaration name="searchDirection" type="double[]" line="264"/>
                <declaration name="delta" type="double" line="266"/>
                <scope line="267"/>
                <declaration name="current" type="PointValuePair" line="271"/>
                <scope line="272">
                    <declaration name="objective" type="double" line="275"/>
                    <declaration name="previous" type="PointValuePair" line="276"/>
                    <scope line="278"/>
                    <declaration name="step" type="double" line="283"/>
                    <scope line="286"/>
                    <scope line="291">
                        <scope line="292"/>
                    </scope>
                    <declaration name="deltaOld" type="double" line="298"/>
                    <declaration name="newSteepestDescent" type="double[]" line="299"/>
                    <scope line="301"/>
                    <declaration name="beta" type="double" line="305"/>
                    <declaration name="deltaMid" type="double" line="311"/>
                    <scope line="312"/>
                    <scope line="325"/>
                    <scope line="328">
                        <scope line="330"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="337">
                {@inheritDoc}                
            </javadoc>
            <method name="parseOptimizationData" type="void" line="341">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="343">
                    Allow base class to register its own data.                    
                </comment>
            </method>
            <class name="IdentityPreconditioner" line="348">
                <implements interface="Preconditioner"/>
                <javadoc line="348">
                    Default identity preconditioner.                    
                </javadoc>
                <javadoc line="350">
                    {@inheritDoc}                    
                </javadoc>
                <method name="precondition" type="double[]" line="351">
                    <params>
                        <param name="variables" type="double[]"/>
                        <param name="r" type="double[]"/>
                    </params>
                </method>
            </class>
            <javadoc line="406">
                @throws MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.                
            </javadoc>
            <method name="checkParameters" type="void" line="410">
                <scope line="412"/>
            </method>
        </class>
    </source>