<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.linear">
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MaxCountExceededException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.util.ExceptionContext"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.IterationManager"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="SymmLQ" line="9">
            <extends class="PreconditionedIterativeLinearSolver"/>
            <javadoc line="9">
                &lt;p&gt;
                  Implementation of the SYMMLQ iterative linear solver proposed by &lt;a
                  href=&quot;#PAIG1975&quot;&gt;Paige and Saunders (1975)&lt;/a&gt;. This implementation is
                  largely based on the FORTRAN code by Pr. Michael A. Saunders, available &lt;a
                  href=&quot;http://www.stanford.edu/group/SOL/software/symmlq/f77/&quot;&gt;here&lt;/a&gt;.
                  &lt;/p&gt;
                  &lt;p&gt;
                  SYMMLQ is designed to solve the system of linear equations A &amp;middot; x = b
                  where A is an n &amp;times; n self-adjoint linear operator (defined as a{@link RealLinearOperator}), and b is a given vector. The operator A is not
                  required to be positive definite. If A is known to be definite, the method of
                  conjugate gradients might be preferred, since it will require about the same
                  number of iterations as SYMMLQ but slightly less work per iteration.
                  &lt;/p&gt;
                  &lt;p&gt;
                  SYMMLQ is designed to solve the system (A - shift &amp;middot; I) &amp;middot; x = b,
                  where shift is a specified scalar value. If shift and b are suitably chosen,
                  the computed vector x may approximate an (unnormalized) eigenvector of A, as
                  in the methods of inverse iteration and/or Rayleigh-quotient iteration.
                  Again, the linear operator (A - shift &amp;middot; I) need not be positive
                  definite (but &lt;em&gt;must&lt;/em&gt; be self-adjoint). The work per iteration is very
                  slightly less if shift = 0.
                  &lt;/p&gt;
                  &lt;h3&gt;Preconditioning&lt;/h3&gt;
                  &lt;p&gt;
                  Preconditioning may reduce the number of iterations required. The solver may
                  be provided with a positive definite preconditioner
                  M = P&lt;sup&gt;T&lt;/sup&gt; &amp;middot; P
                  that is known to approximate
                  (A - shift &amp;middot; I)&lt;sup&gt;-1&lt;/sup&gt; in some sense, where matrix-vector
                  products of the form M &amp;middot; y = x can be computed efficiently. Then
                  SYMMLQ will implicitly solve the system of equations
                  P &amp;middot; (A - shift &amp;middot; I) &amp;middot; P&lt;sup&gt;T&lt;/sup&gt; &amp;middot;
                  x&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; b, i.e.
                  A&lt;sub&gt;hat&lt;/sub&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt; = b&lt;sub&gt;hat&lt;/sub&gt;,
                  where
                  A&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; (A - shift &amp;middot; I) &amp;middot; P&lt;sup&gt;T&lt;/sup&gt;,
                  b&lt;sub&gt;hat&lt;/sub&gt; = P &amp;middot; b,
                  and return the solution
                  x = P&lt;sup&gt;T&lt;/sup&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt;.
                  The associated residual is
                  r&lt;sub&gt;hat&lt;/sub&gt; = b&lt;sub&gt;hat&lt;/sub&gt; - A&lt;sub&gt;hat&lt;/sub&gt; &amp;middot; x&lt;sub&gt;hat&lt;/sub&gt;
                  = P &amp;middot; [b - (A - shift &amp;middot; I) &amp;middot; x]
                  = P &amp;middot; r.
                  &lt;/p&gt;
                  &lt;p&gt;
                  In the case of preconditioning, the {@link IterativeLinearSolverEvent}s that
                  this solver fires are such that{@link IterativeLinearSolverEvent#getNormOfResidual()} returns the norm of
                  the &lt;em&gt;preconditioned&lt;/em&gt;, updated residual, ||P &amp;middot; r||, not the norm
                  of the &lt;em&gt;true&lt;/em&gt; residual ||r||.
                  &lt;/p&gt;
                  &lt;h3&gt;&lt;a id=&quot;stopcrit&quot;&gt;Default stopping criterion&lt;/a&gt;&lt;/h3&gt;
                  &lt;p&gt;
                  A default stopping criterion is implemented. The iterations stop when || rhat
                  || &amp;le; &amp;delta; || Ahat || || xhat ||, where xhat is the current estimate of
                  the solution of the transformed system, rhat the current estimate of the
                  corresponding residual, and &amp;delta; a user-specified tolerance.
                  &lt;/p&gt;
                  &lt;h3&gt;Iteration count&lt;/h3&gt;
                  &lt;p&gt;
                  In the present context, an iteration should be understood as one evaluation
                  of the matrix-vector product A &amp;middot; x. The initialization phase therefore
                  counts as one iteration. If the user requires checks on the symmetry of A,
                  this entails one further matrix-vector product in the initial phase. This
                  further product is &lt;em&gt;not&lt;/em&gt; accounted for in the iteration count. In
                  other words, the number of iterations required to reach convergence will be
                  identical, whether checks have been required or not.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The present definition of the iteration count differs from that adopted in
                  the original FOTRAN code, where the initialization phase was &lt;em&gt;not&lt;/em&gt;
                  taken into account.
                  &lt;/p&gt;
                  &lt;h3&gt;&lt;a id=&quot;initguess&quot;&gt;Initial guess of the solution&lt;/a&gt;&lt;/h3&gt;
                  &lt;p&gt;
                  The {@code x} parameter in
                  &lt;ul&gt;
                  &lt;li&gt;{@link #solve(RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
                  &lt;li&gt;{@link #solve(RealLinearOperator,RealLinearOperator,RealVector,RealVector)}},&lt;/li&gt;
                  &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
                  &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealLinearOperator,RealVector,RealVector)},&lt;/li&gt;
                  &lt;li&gt;{@link #solveInPlace(RealLinearOperator,RealLinearOperator,RealVector,RealVector,boolean,double)},&lt;/li&gt;
                  &lt;/ul&gt;
                  should not be considered as an initial guess, as it is set to zero in the
                  initial phase. If x&lt;sub&gt;0&lt;/sub&gt; is known to be a good approximation to x, one
                  should compute r&lt;sub&gt;0&lt;/sub&gt; = b - A &amp;middot; x, solve A &amp;middot; dx = r0,
                  and set x = x&lt;sub&gt;0&lt;/sub&gt; + dx.
                  &lt;/p&gt;
                  &lt;h3&gt;&lt;a id=&quot;context&quot;&gt;Exception context&lt;/a&gt;&lt;/h3&gt;
                  &lt;p&gt;
                  Besides standard {@link DimensionMismatchException}, this class might throw{@link NonSelfAdjointOperatorException} if the linear operator or the
                  preconditioner are not symmetric. In this case, the {@link ExceptionContext}provides more information
                  &lt;ul&gt;
                  &lt;li&gt;key {@code &quot;operator&quot;} points to the offending linear operator, say L,&lt;/li&gt;
                  &lt;li&gt;key {@code &quot;vector1&quot;} points to the first offending vector, say x,
                  &lt;li&gt;key {@code &quot;vector2&quot;} points to the second offending vector, say y, such
                  that x&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L &amp;middot; y &amp;ne; y&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L
                  &amp;middot; x (within a certain accuracy).&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/p&gt;
                  &lt;p&gt;{@link NonPositiveDefiniteOperatorException} might also be thrown in case the
                  preconditioner is not positive definite. The relevant keys to the{@link ExceptionContext} are
                  &lt;ul&gt;
                  &lt;li&gt;key {@code &quot;operator&quot;}, which points to the offending linear operator,
                  say L,&lt;/li&gt;
                  &lt;li&gt;key {@code &quot;vector&quot;}, which points to the offending vector, say x, such
                  that x&lt;sup&gt;T&lt;/sup&gt; &amp;middot; L &amp;middot; x &lt; 0.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/p&gt;
                  &lt;h3&gt;References&lt;/h3&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;a id=&quot;PAIG1975&quot;&gt;Paige and Saunders (1975)&lt;/a&gt;&lt;/dt&gt;
                  &lt;dd&gt;C. C. Paige and M. A. Saunders, &lt;a
                  href=&quot;http://www.stanford.edu/group/SOL/software/symmlq/PS75.pdf&quot;&gt;&lt;em&gt;
                  Solution of Sparse Indefinite Systems of Linear Equations&lt;/em&gt;&lt;/a&gt;, SIAM
                  Journal on Numerical Analysis 12(4): 617-629, 1975&lt;/dd&gt;
                  &lt;/dl&gt;                
                <version>
                    $Id: SymmLQ.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <class name="State" line="130">
                <javadoc line="130">
                    &lt;p&gt;
                      A simple container holding the non-final variables used in the
                      iterations. Making the current state of the solver visible from the
                      outside is necessary, because during the iterations, {@code x} does not
                      &lt;em&gt;exactly&lt;/em&gt; hold the current estimate of the solution. Indeed,{@code x} needs in general to be moved from the LQ point to the CG point.
                      Besides, additional upudates must be carried out in case {@code goodb} is
                      set to {@code true}.
                      &lt;/p&gt;
                      &lt;p&gt;
                      In all subsequent comments, the description of the state variables refer
                      to their value after a call to {@link #update()}. In these comments, k is
                      the current number of evaluations of matrix-vector products.
                      &lt;/p&gt;                    
                </javadoc>
                <declaration name="CBRT_MACH_PREC" type="double" line="146"/>
                <javadoc line="146">
                    The cubic root of {@link #MACH_PREC}.                    
                </javadoc>
                <declaration name="MACH_PREC" type="double" line="150"/>
                <javadoc line="150">
                    The machine precision.                    
                </javadoc>
                <declaration name="a" type="RealLinearOperator" line="154"/>
                <javadoc line="154">
                    Reference to the linear operator.                    
                </javadoc>
                <declaration name="b" type="RealVector" line="158"/>
                <javadoc line="158">
                    Reference to the right-hand side vector.                    
                </javadoc>
                <declaration name="check" type="boolean" line="162"/>
                <javadoc line="162">
                    {@code true} if symmetry of matrix and conditioner must be checked.                    
                </javadoc>
                <declaration name="delta" type="double" line="166"/>
                <javadoc line="166">
                    The value of the custom tolerance &amp;delta; for the default stopping
                      criterion.                    
                </javadoc>
                <declaration name="beta" type="double" line="171"/>
                <javadoc line="171">
                    The value of beta[k+1].                    
                </javadoc>
                <declaration name="beta1" type="double" line="175"/>
                <javadoc line="175">
                    The value of beta[1].                    
                </javadoc>
                <declaration name="bstep" type="double" line="179"/>
                <javadoc line="179">
                    The value of bstep[k-1].                    
                </javadoc>
                <declaration name="cgnorm" type="double" line="183"/>
                <javadoc line="183">
                    The estimate of the norm of P  rC[k].                    
                </javadoc>
                <declaration name="dbar" type="double" line="187"/>
                <javadoc line="187">
                    The value of dbar[k+1] = -beta[k+1]  c[k-1].                    
                </javadoc>
                <declaration name="gammaZeta" type="double" line="191"/>
                <javadoc line="191">
                    The value of gamma[k]  zeta[k]. Was called {@code rhs1} in the
                      initial code.                    
                </javadoc>
                <declaration name="gbar" type="double" line="196"/>
                <javadoc line="196">
                    The value of gbar[k].                    
                </javadoc>
                <declaration name="gmax" type="double" line="200"/>
                <javadoc line="200">
                    The value of max(|alpha[1]|, gamma[1], ..., gamma[k-1]).                    
                </javadoc>
                <declaration name="gmin" type="double" line="204"/>
                <javadoc line="204">
                    The value of min(|alpha[1]|, gamma[1], ..., gamma[k-1]).                    
                </javadoc>
                <declaration name="goodb" type="boolean" line="208"/>
                <javadoc line="208">
                    Copy of the {@code goodb} parameter.                    
                </javadoc>
                <declaration name="hasConverged" type="boolean" line="212"/>
                <javadoc line="212">
                    {@code true} if the default convergence criterion is verified.                    
                </javadoc>
                <declaration name="lqnorm" type="double" line="216"/>
                <javadoc line="216">
                    The estimate of the norm of P  rL[k-1].                    
                </javadoc>
                <declaration name="m" type="RealLinearOperator" line="220"/>
                <javadoc line="220">
                    Reference to the preconditioner, M.                    
                </javadoc>
                <declaration name="minusEpsZeta" type="double" line="224"/>
                <javadoc line="224">
                    The value of (-eps[k+1]  zeta[k-1]). Was called {@code rhs2} in the
                      initial code.                    
                </javadoc>
                <declaration name="mb" type="RealVector" line="229"/>
                <javadoc line="229">
                    The value of M  b.                    
                </javadoc>
                <declaration name="oldb" type="double" line="233"/>
                <javadoc line="233">
                    The value of beta[k].                    
                </javadoc>
                <declaration name="r1" type="RealVector" line="237"/>
                <javadoc line="237">
                    The value of beta[k]  M^(-1)  P&apos;  v[k].                    
                </javadoc>
                <declaration name="r2" type="RealVector" line="241"/>
                <javadoc line="241">
                    The value of beta[k+1]  M^(-1)  P&apos;  v[k+1].                    
                </javadoc>
                <declaration name="rnorm" type="double" line="245"/>
                <javadoc line="245">
                    The value of the updated, preconditioned residual P  r. This value is
                      given by {@code min(}{@link #cgnorm}{@code , }{@link #lqnorm}{@code )}.                    
                </javadoc>
                <declaration name="shift" type="double" line="250"/>
                <javadoc line="250">
                    Copy of the {@code shift} parameter.                    
                </javadoc>
                <declaration name="snprod" type="double" line="254"/>
                <javadoc line="254">
                    The value of s[1]  ...  s[k-1].                    
                </javadoc>
                <declaration name="tnorm" type="double" line="258"/>
                <javadoc line="258">
                    An estimate of the square of the norm of A  V[k], based on Paige and
                      Saunders (1975), equation (3.3).                    
                </javadoc>
                <declaration name="wbar" type="RealVector" line="263"/>
                <javadoc line="263">
                    The value of P&apos;  wbar[k] or P&apos;  (wbar[k] - s[1]  ...  s[k-1] 
                      v[1]) if {@code goodb} is {@code true}. Was called {@code w} in the
                      initial code.                    
                </javadoc>
                <declaration name="xL" type="RealVector" line="269"/>
                <javadoc line="269">
                    A reference to the vector to be updated with the solution. Contains
                      the value of xL[k-1] if {@code goodb} is {@code false}, (xL[k-1] -
                      bstep[k-1]  v[1]) otherwise.                    
                </javadoc>
                <declaration name="y" type="RealVector" line="275"/>
                <javadoc line="275">
                    The value of beta[k+1]  P&apos;  v[k+1].                    
                </javadoc>
                <declaration name="ynorm2" type="double" line="279"/>
                <javadoc line="279">
                    The value of zeta[1]^2 + ... + zeta[k-1]^2.                    
                </javadoc>
                <declaration name="bIsNull" type="boolean" line="283"/>
                <javadoc line="283">
                    The value of {@code b == 0} (exact floating-point equality).                    
                </javadoc>
                <scope line="287"/>
                <javadoc line="291">
                    Creates and inits to k = 1 a new instance of this class.                    
                    <param>
                        a the linear operator A of the system                        
                    </param>
                    <param>
                        m the preconditioner, M (can be {@code null})                        
                    </param>
                    <param>
                        b the right-hand side vector                        
                    </param>
                    <param>
                        goodb usually {@code false}, except if {@code x} is expected
                          to contain a large multiple of {@code b}                        
                    </param>
                    <param>
                        shift the amount to be subtracted to all diagonal elements of
                          A                        
                    </param>
                    <param>
                        delta the &delta; parameter for the default stopping criterion                        
                    </param>
                    <param>
                        check {@code true} if self-adjointedness of both matrix and
                          preconditioner should be checked                        
                    </param>
                </javadoc>
                <method name="State" type="constructor" line="304">
                    <params>
                        <param name="a" type="RealLinearOperator"/>
                        <param name="m" type="RealLinearOperator"/>
                        <param name="b" type="RealVector"/>
                        <param name="goodb" type="boolean"/>
                        <param name="shift" type="double"/>
                        <param name="delta" type="double"/>
                        <param name="check" type="boolean"/>
                    </params>
                </method>
                <javadoc line="316">
                    Performs a symmetry check on the specified linear operator, and throws an
                      exception in case this check fails. Given a linear operator L, and a
                      vector x, this method checks that
                      x&apos; &amp;middot; L &amp;middot; y = y&apos; &amp;middot; L &amp;middot; x
                      (within a given accuracy), where y = L &amp;middot; x.                    
                    <param>
                        l the linear operator L                        
                    </param>
                    <param>
                        x the candidate vector x                        
                    </param>
                    <param>
                        y the candidate vector y = L &middot; x                        
                    </param>
                    <param>
                        z the vector z = L &middot; y                        
                    </param>
                    <throws>
                        NonSelfAdjointOperatorException when the test fails                        
                    </throws>
                </javadoc>
                <method name="checkSymmetry" type="void" line="328">
                    <params>
                        <param name="l" type="RealLinearOperator"/>
                        <param name="x" type="RealVector"/>
                        <param name="y" type="RealVector"/>
                        <param name="z" type="RealVector"/>
                    </params>
                    <declaration name="s" type="double" line="329"/>
                    <declaration name="t" type="double" line="330"/>
                    <declaration name="epsa" type="double" line="331"/>
                    <scope line="332">
                        <declaration name="e" type="NonSelfAdjointOperatorException" line="333"/>
                        <declaration name="context" type="ExceptionContext" line="335"/>
                    </scope>
                </method>
                <javadoc line="343">
                    Throws a new {@link NonPositiveDefiniteOperatorException} with
                      appropriate context.                    
                    <param>
                        l the offending linear operator                        
                    </param>
                    <param>
                        v the offending vector                        
                    </param>
                    <throws>
                        NonPositiveDefiniteOperatorException in any circumstances                        
                    </throws>
                </javadoc>
                <method name="throwNPDLOException" type="void" line="350">
                    <params>
                        <param name="l" type="RealLinearOperator"/>
                        <param name="v" type="RealVector"/>
                    </params>
                    <declaration name="e" type="NonPositiveDefiniteOperatorException" line="351"/>
                    <declaration name="context" type="ExceptionContext" line="353"/>
                </method>
                <javadoc line="358">
                    A clone of the BLAS {@code DAXPY} function, which carries out the
                      operation y &amp;larr; a &amp;middot; x + y. This is for internal use only: no
                      dimension checks are provided.                    
                    <param>
                        a the scalar by which {@code x} is to be multiplied                        
                    </param>
                    <param>
                        x the vector to be added to {@code y}                        
                    </param>
                    <param>
                        y the vector to be incremented                        
                    </param>
                </javadoc>
                <method name="daxpy" type="void" line="366">
                    <params>
                        <param name="a" type="double"/>
                        <param name="x" type="RealVector"/>
                        <param name="y" type="RealVector"/>
                    </params>
                    <declaration name="n" type="int" line="367"/>
                    <scope line="368"/>
                </method>
                <javadoc line="372">
                    A BLAS-like function, for the operation z &amp;larr; a &amp;middot; x + b
                      &amp;middot; y + z. This is for internal use only: no dimension checks are
                      provided.                    
                    <param>
                        a the scalar by which {@code x} is to be multiplied                        
                    </param>
                    <param>
                        x the first vector to be added to {@code z}                        
                    </param>
                    <param>
                        b the scalar by which {@code y} is to be multiplied                        
                    </param>
                    <param>
                        y the second vector to be added to {@code z}                        
                    </param>
                    <param>
                        z the vector to be incremented                        
                    </param>
                </javadoc>
                <method name="daxpbypz" type="void" line="382">
                    <params>
                        <param name="a" type="double"/>
                        <param name="x" type="RealVector"/>
                        <param name="b" type="double"/>
                        <param name="y" type="RealVector"/>
                        <param name="z" type="RealVector"/>
                    </params>
                    <declaration name="n" type="int" line="383"/>
                    <scope line="384">
                        <declaration name="zi" type="double" line="385"/>
                    </scope>
                </method>
                <javadoc line="390">
                    &lt;p&gt;
                      Move to the CG point if it seems better. In this version of SYMMLQ,
                      the convergence tests involve only cgnorm, so we&apos;re unlikely to stop
                      at an LQ point, except if the iteration limit interferes.
                      &lt;/p&gt;
                      &lt;p&gt;
                      Additional upudates are also carried out in case {@code goodb} is set
                      to {@code true}.
                      &lt;/p&gt;                    
                    <param>
                        x the vector to be updated with the refined value of xL                        
                    </param>
                </javadoc>
                <method name="refineSolution" type="void" line="402">
                    <params>
                        <param name="x" type="RealVector"/>
                    </params>
                    <declaration name="n" type="int" line="403"/>
                    <scope line="404">
                        <scope line="405"/>
                        <scope line="408">
                            <declaration name="step" type="double" line="409"/>
                            <scope line="410">
                                <declaration name="bi" type="double" line="411"/>
                                <declaration name="xi" type="double" line="412"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="417">
                        <declaration name="anorm" type="double" line="418"/>
                        <declaration name="diag" type="double" line="419"/>
                        <declaration name="zbar" type="double" line="420"/>
                        <declaration name="step" type="double" line="421"/>
                        <scope line="422">
                            <scope line="423">
                                <declaration name="xi" type="double" line="424"/>
                                <declaration name="wi" type="double" line="425"/>
                            </scope>
                        </scope>
                        <scope line="429">
                            <scope line="430">
                                <declaration name="xi" type="double" line="431"/>
                                <declaration name="wi" type="double" line="432"/>
                                <declaration name="bi" type="double" line="433"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="439">
                    Performs the initial phase of the SYMMLQ algorithm. On return, the
                      value of the state variables of {@code this} object correspond to k =
                      1.                    
                </javadoc>
                <method name="init" type="void" line="444">
                    <scope line="448"/>
                    <scope line="452"/>
                    <scope line="455"/>
                    <declaration name="v" type="RealVector" line="461"/>
                    <scope line="463"/>
                    <declaration name="alpha" type="double" line="467"/>
                    <declaration name="vty" type="double" line="469"/>
                    <declaration name="vtv" type="double" line="470"/>
                    <scope line="473"/>
                    <scope line="478"/>
                    <scope line="493"/>
                    <scope line="497"/>
                </method>
                <javadoc line="502">
                    Performs the next iteration of the algorithm. The iteration count
                      should be incremented prior to calling this method. On return, the
                      value of the state variables of {@code this} object correspond to the
                      current iteration count {@code k}.                    
                </javadoc>
                <method name="update" type="void" line="508">
                    <declaration name="v" type="RealVector" line="509"/>
                    <declaration name="alpha" type="double" line="512"/>
                    <scope line="516"/>
                    <scope line="521"/>
                    <declaration name="gamma" type="double" line="526"/>
                    <declaration name="c" type="double" line="527"/>
                    <declaration name="s" type="double" line="528"/>
                    <declaration name="deltak" type="double" line="529"/>
                    <declaration name="eps" type="double" line="531"/>
                    <declaration name="zeta" type="double" line="533"/>
                    <declaration name="zetaC" type="double" line="534"/>
                    <declaration name="zetaS" type="double" line="535"/>
                    <declaration name="n" type="int" line="536"/>
                    <scope line="537">
                        <declaration name="xi" type="double" line="538"/>
                        <declaration name="vi" type="double" line="539"/>
                        <declaration name="wi" type="double" line="540"/>
                    </scope>
                </method>
                <javadoc line="553">
                    Computes the norms of the residuals, and checks for convergence.
                      Updates {@link #lqnorm} and {@link #cgnorm}.                    
                </javadoc>
                <method name="updateNorms" type="void" line="557">
                    <declaration name="anorm" type="double" line="558"/>
                    <declaration name="ynorm" type="double" line="559"/>
                    <declaration name="epsa" type="double" line="560"/>
                    <declaration name="epsx" type="double" line="561"/>
                    <declaration name="epsr" type="double" line="562"/>
                    <declaration name="diag" type="double" line="563"/>
                    <declaration name="qrnorm" type="double" line="565"/>
                    <declaration name="acond" type="double" line="567"/>
                    <scope line="568"/>
                    <scope line="571"/>
                    <scope line="574"/>
                    <scope line="577"/>
                </method>
                <javadoc line="583">
                    Returns {@code true} if the default stopping criterion is fulfilled.                    
                    <return>
                        {@code true} if convergence of the iterations has occured                        
                    </return>
                </javadoc>
                <method name="hasConverged" type="boolean" line="587"/>
                <javadoc line="590">
                    Returns {@code true} if the right-hand side vector is zero exactly.                    
                    <return>
                        the boolean value of {@code b == 0}                        
                    </return>
                </javadoc>
                <method name="bEqualsNullVector" type="boolean" line="594"/>
                <javadoc line="597">
                    Returns {@code true} if {@code beta} is essentially zero. This method
                      is used to check for early stop of the iterations.                    
                    <return>
                        {@code true} if {@code beta < }{@link #MACH_PREC}                        
                    </return>
                </javadoc>
                <method name="betaEqualsZero" type="boolean" line="602"/>
                <javadoc line="605">
                    Returns the norm of the updated, preconditioned residual.                    
                    <return>
                        the norm of the residual, ||P  r||                        
                    </return>
                </javadoc>
                <method name="getNormOfResidual" type="double" line="609"/>
            </class>
            <declaration name="OPERATOR" type="String" line="613"/>
            <javadoc line="613">
                Key for the exception context.                
            </javadoc>
            <declaration name="THRESHOLD" type="String" line="617"/>
            <javadoc line="617">
                Key for the exception context.                
            </javadoc>
            <declaration name="VECTOR" type="String" line="621"/>
            <javadoc line="621">
                Key for the exception context.                
            </javadoc>
            <declaration name="VECTOR1" type="String" line="625"/>
            <javadoc line="625">
                Key for the exception context.                
            </javadoc>
            <declaration name="VECTOR2" type="String" line="629"/>
            <javadoc line="629">
                Key for the exception context.                
            </javadoc>
            <declaration name="check" type="boolean" line="633"/>
            <javadoc line="633">
                {@code true} if symmetry of matrix and conditioner must be checked.                
            </javadoc>
            <declaration name="delta" type="double" line="637"/>
            <javadoc line="637">
                The value of the custom tolerance &amp;delta; for the default stopping
                  criterion.                
            </javadoc>
            <javadoc line="642">
                Creates a new instance of this class, with &lt;a href=&quot;#stopcrit&quot;&gt;default
                  stopping criterion&lt;/a&gt;. Note that setting {@code check} to {@code true}entails an extra matrix-vector product in the initial phase.                
                <param>
                    maxIterations the maximum number of iterations                    
                </param>
                <param>
                    delta the &delta; parameter for the default stopping criterion                    
                </param>
                <param>
                    check {@code true} if self-adjointedness of both matrix and
                      preconditioner should be checked                    
                </param>
            </javadoc>
            <method name="SymmLQ" type="constructor" line="650">
                <params>
                    <param name="maxIterations" type="int"/>
                    <param name="delta" type="double"/>
                    <param name="check" type="boolean"/>
                </params>
            </method>
            <javadoc line="655">
                Creates a new instance of this class, with &lt;a href=&quot;#stopcrit&quot;&gt;default
                  stopping criterion&lt;/a&gt; and custom iteration manager. Note that setting{@code check} to {@code true} entails an extra matrix-vector product in
                  the initial phase.                
                <param>
                    manager the custom iteration manager                    
                </param>
                <param>
                    delta the &delta; parameter for the default stopping criterion                    
                </param>
                <param>
                    check {@code true} if self-adjointedness of both matrix and
                      preconditioner should be checked                    
                </param>
            </javadoc>
            <method name="SymmLQ" type="constructor" line="664">
                <params>
                    <param name="manager" type="IterationManager"/>
                    <param name="delta" type="double"/>
                    <param name="check" type="boolean"/>
                </params>
            </method>
            <javadoc line="669">
                Returns {@code true} if symmetry of the matrix, and symmetry as well as
                  positive definiteness of the preconditioner should be checked.                
                <return>
                    {@code true} if the tests are to be performed                    
                </return>
            </javadoc>
            <method name="getCheck" type="boolean" line="674"/>
            <javadoc line="677">
                {@inheritDoc}                
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </throws>
                <throws>
                    NonPositiveDefiniteOperatorException if {@code m} is not
                      positive definite                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solve" type="RealVector" line="684">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="m" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                </params>
                <declaration name="x" type="RealVector" line="686"/>
            </method>
            <javadoc line="689">
                Returns an estimate of the solution to the linear system (A - shift
                  &amp;middot; I) &amp;middot; x = b.
                  &lt;p&gt;
                  If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
                  achieved with {@code goodb} set to {@code true}; this however requires an
                  extra call to the preconditioner.
                  &lt;/p&gt;
                  &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
                  solved. Otherwise, it could be an approximation to an eigenvalue of A,
                  such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
                  (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
                  sufficiently like an eigenvector corresponding to an eigenvalue near
                  shift, then the computed x may have very large components. When
                  normalized, x may be closer to an eigenvector than b.
                  &lt;/p&gt;                
                <param>
                    a the linear operator A of the system                    
                </param>
                <param>
                    m the preconditioner, M (can be {@code null})                    
                </param>
                <param>
                    b the right-hand side vector                    
                </param>
                <param>
                    goodb usually {@code false}, except if {@code x} is expected to
                      contain a large multiple of {@code b}                    
                </param>
                <param>
                    shift the amount to be subtracted to all diagonal elements of A                    
                </param>
                <return>
                    a reference to {@code x} (shallow copy)                    
                </return>
                <throws>
                    NullArgumentException if one of the parameters is {@code null}                    
                </throws>
                <throws>
                    NonSquareOperatorException if {@code a} or {@code m} is not square                    
                </throws>
                <throws>
                    DimensionMismatchException if {@code m} or {@code b} have dimensions
                      inconsistent with {@code a}                    
                </throws>
                <throws>
                    MaxCountExceededException at exhaustion of the iteration count,
                      unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}                    
                </throws>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </throws>
                <throws>
                    NonPositiveDefiniteOperatorException if {@code m} is not
                      positive definite                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solve" type="RealVector" line="723">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="m" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="goodb" type="boolean"/>
                    <param name="shift" type="double"/>
                </params>
                <declaration name="x" type="RealVector" line="725"/>
            </method>
            <javadoc line="728">
                {@inheritDoc}                
                <param>
                    x not meaningful in this implementation; should not be considered
                      as an initial guess (<a href="#initguess">more</a>)                    
                </param>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </throws>
                <throws>
                    NonPositiveDefiniteOperatorException if {@code m} is not positive
                      definite                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solve" type="RealVector" line="737">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="m" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="x" type="RealVector"/>
                </params>
            </method>
            <javadoc line="741">
                {@inheritDoc}                
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solve" type="RealVector" line="746">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                </params>
                <declaration name="x" type="RealVector" line="748"/>
            </method>
            <javadoc line="752">
                Returns the solution to the system (A - shift &amp;middot; I) &amp;middot; x = b.
                  &lt;p&gt;
                  If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
                  achieved with {@code goodb} set to {@code true}.
                  &lt;/p&gt;
                  &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
                  solved. Otherwise, it could be an approximation to an eigenvalue of A,
                  such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
                  (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
                  sufficiently like an eigenvector corresponding to an eigenvalue near
                  shift, then the computed x may have very large components. When
                  normalized, x may be closer to an eigenvector than b.
                  &lt;/p&gt;                
                <param>
                    a the linear operator A of the system                    
                </param>
                <param>
                    b the right-hand side vector                    
                </param>
                <param>
                    goodb usually {@code false}, except if {@code x} is expected to
                      contain a large multiple of {@code b}                    
                </param>
                <param>
                    shift the amount to be subtracted to all diagonal elements of A                    
                </param>
                <return>
                    a reference to {@code x}                    
                </return>
                <throws>
                    NullArgumentException if one of the parameters is {@code null}                    
                </throws>
                <throws>
                    NonSquareOperatorException if {@code a} is not square                    
                </throws>
                <throws>
                    DimensionMismatchException if {@code b} has dimensions
                      inconsistent with {@code a}                    
                </throws>
                <throws>
                    MaxCountExceededException at exhaustion of the iteration count,
                      unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}                    
                </throws>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solve" type="RealVector" line="781">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="goodb" type="boolean"/>
                    <param name="shift" type="double"/>
                </params>
                <declaration name="x" type="RealVector" line="783"/>
            </method>
            <javadoc line="786">
                {@inheritDoc}                
                <param>
                    x not meaningful in this implementation; should not be considered
                      as an initial guess (<a href="#initguess">more</a>)                    
                </param>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solve" type="RealVector" line="793">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="x" type="RealVector"/>
                </params>
            </method>
            <javadoc line="797">
                {@inheritDoc}                
                <param>
                    x the vector to be updated with the solution; {@code x} should
                      not be considered as an initial guess (<a href="#initguess">more</a>)                    
                </param>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </throws>
                <throws>
                    NonPositiveDefiniteOperatorException if {@code m} is not
                      positive definite                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solveInPlace" type="RealVector" line="806">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="m" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="x" type="RealVector"/>
                </params>
            </method>
            <javadoc line="809">
                Returns an estimate of the solution to the linear system (A - shift
                  &amp;middot; I) &amp;middot; x = b. The solution is computed in-place.
                  &lt;p&gt;
                  If the solution x is expected to contain a large multiple of {@code b}(as in Rayleigh-quotient iteration), then better precision may be
                  achieved with {@code goodb} set to {@code true}; this however requires an
                  extra call to the preconditioner.
                  &lt;/p&gt;
                  &lt;p&gt;{@code shift} should be zero if the system A &amp;middot; x = b is to be
                  solved. Otherwise, it could be an approximation to an eigenvalue of A,
                  such as the Rayleigh quotient b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; A &amp;middot; b /
                  (b&lt;sup&gt;T&lt;/sup&gt; &amp;middot; b) corresponding to the vector b. If b is
                  sufficiently like an eigenvector corresponding to an eigenvalue near
                  shift, then the computed x may have very large components. When
                  normalized, x may be closer to an eigenvector than b.
                  &lt;/p&gt;                
                <param>
                    a the linear operator A of the system                    
                </param>
                <param>
                    m the preconditioner, M (can be {@code null})                    
                </param>
                <param>
                    b the right-hand side vector                    
                </param>
                <param>
                    x the vector to be updated with the solution; {@code x} should
                      not be considered as an initial guess (<a href="#initguess">more</a>)                    
                </param>
                <param>
                    goodb usually {@code false}, except if {@code x} is expected to
                      contain a large multiple of {@code b}                    
                </param>
                <param>
                    shift the amount to be subtracted to all diagonal elements of A                    
                </param>
                <return>
                    a reference to {@code x} (shallow copy).                    
                </return>
                <throws>
                    NullArgumentException if one of the parameters is {@code null}                    
                </throws>
                <throws>
                    NonSquareOperatorException if {@code a} or {@code m} is not square                    
                </throws>
                <throws>
                    DimensionMismatchException if {@code m}, {@code b} or {@code x}have dimensions inconsistent with {@code a}.                    
                </throws>
                <throws>
                    MaxCountExceededException at exhaustion of the iteration count,
                      unless a custom{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}has been set at construction of the {@link IterationManager}                    
                </throws>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} or {@code m} is not self-adjoint                    
                </throws>
                <throws>
                    NonPositiveDefiniteOperatorException if {@code m} is not positive
                      definite                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solveInPlace" type="RealVector" line="844">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="m" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="x" type="RealVector"/>
                    <param name="goodb" type="boolean"/>
                    <param name="shift" type="double"/>
                </params>
                <declaration name="manager" type="IterationManager" line="846"/>
                <declaration name="state" type="State" line="849"/>
                <declaration name="event" type="IterativeLinearSolverEvent" line="853"/>
                <scope line="855"/>
                <declaration name="earlyStop" type="boolean" line="859"/>
                <scope line="862">
                    <scope line="863"/>
                </scope>
            </method>
            <javadoc line="878">
                {@inheritDoc}                
                <param>
                    x the vector to be updated with the solution; {@code x} should
                      not be considered as an initial guess (<a href="#initguess">more</a>)                    
                </param>
                <throws>
                    NonSelfAdjointOperatorException if {@link #getCheck()} is{@code true}, and {@code a} is not self-adjoint                    
                </throws>
                <throws>
                    IllConditionedOperatorException if {@code a} is ill-conditioned                    
                </throws>
            </javadoc>
            <method name="solveInPlace" type="RealVector" line="885">
                <params>
                    <param name="a" type="RealLinearOperator"/>
                    <param name="b" type="RealVector"/>
                    <param name="x" type="RealVector"/>
                </params>
            </method>
        </class>
    </source>