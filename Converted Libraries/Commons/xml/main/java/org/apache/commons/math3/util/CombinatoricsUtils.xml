<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.util">
        <import package="java.util.Iterator"/>
        <import package="java.util.concurrent.atomic.AtomicReference"/>
        <import package="org.apache.commons.math3.exception.MathArithmeticException"/>
        <import package="org.apache.commons.math3.exception.NotPositiveException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <class name="CombinatoricsUtils" line="27">
            <javadoc line="27">
                Combinatorial utilities.                
                <version>
                    $Id$                    
                </version>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <declaration name="FACTORIALS" type="long[]" line="35"/>
            <javadoc line="35">
                All long-representable factorials                
            </javadoc>
            <declaration name="STIRLING_S2" type="AtomicReference&amp;lt;long[][]&amp;gt;" line="45"/>
            <javadoc line="45">
                Stirling numbers of the second kind.                
            </javadoc>
            <javadoc line="48">
                Private constructor.                
            </javadoc>
            <method name="CombinatoricsUtils" type="constructor" line="49"/>
            <javadoc line="54">
                Returns an exact representation of the &lt;a
                  href=&quot;http://mathworld.wolfram.com/BinomialCoefficient.html&quot;&gt; Binomial
                  Coefficient&lt;/a&gt;, &quot;{@code n choose k}&quot;, the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
                  &lt;p&gt;
                  &lt;Strong&gt;Preconditions&lt;/strong&gt;:
                  &lt;ul&gt;
                  &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise{@code MathIllegalArgumentException} is thrown)&lt;/li&gt;
                  &lt;li&gt; The result is small enough to fit into a {@code long}. The
                  largest value of {@code n} for which all coefficients are{@code  &lt; Long.MAX_VALUE} is 66. If the computed value exceeds{@code Long.MAX_VALUE} an {@code ArithMeticException} is
                  thrown.&lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    n the size of the set                    
                </param>
                <param>
                    k the size of the subsets to be counted                    
                </param>
                <return>
                    {@code n choose k}                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
                <throws>
                    NumberIsTooLargeException if {@code k &gt; n}.                    
                </throws>
                <throws>
                    MathArithmeticException if the result is too large to be
                      represented by a long integer.                    
                </throws>
            </javadoc>
            <method name="binomialCoefficient" type="long" line="81">
                <params>
                    <param name="n" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <comment line="90">
                    Use symmetry for large k                    
                </comment>
                <comment line="95">
                    We use the formula
                     (n choose k) = n! / (n-k)! / k!
                     (n choose k) == ((n-k+1)*...*n) / (1*...*k)
                     which could be written
                     (n choose k) == (n-1 choose k-1) * n / k                    
                </comment>
                <comment line="102">
                    For n &lt;= 61, the naive implementation cannot overflow.                    
                </comment>
                <comment line="109">
                    For n &gt; 61 but n &lt;= 66, the result cannot overflow,
                     but we must take care not to overflow intermediate values.                    
                </comment>
                <comment line="113">
                    We know that (result * i) is divisible by j,
                     but (result * i) may overflow, so we split j:
                     Filter out the gcd, d, so j/d and i/d are integer.
                     result is divisible by (j/d) because (j/d)
                     is relative prime to (i/d) and is a divisor of
                     result * (i/d).                    
                </comment>
                <comment line="124">
                    For n &gt; 66, a result overflow might occur, so we check
                     the multiplication, taking care to not overflow
                     unnecessary.                    
                </comment>
                <scope line="83"/>
                <scope line="86"/>
                <scope line="90"/>
                <declaration name="result" type="long" line="99"/>
                <scope line="100">
                    <declaration name="i" type="int" line="102"/>
                    <scope line="103"/>
                </scope>
                <scope line="107">
                    <declaration name="i" type="int" line="110"/>
                    <scope line="111">
                        <declaration name="d" type="long" line="118"/>
                    </scope>
                </scope>
                <scope line="122">
                    <declaration name="i" type="int" line="126"/>
                    <scope line="127">
                        <declaration name="d" type="long" line="128"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="136">
                Returns a {@code double} representation of the &lt;a
                  href=&quot;http://mathworld.wolfram.com/BinomialCoefficient.html&quot;&gt; Binomial
                  Coefficient&lt;/a&gt;, &quot;{@code n choose k}&quot;, the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
                  &lt;p&gt;
                  &lt;Strong&gt;Preconditions&lt;/strong&gt;:
                  &lt;ul&gt;
                  &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
                  &lt;li&gt; The result is small enough to fit into a {@code double}. The
                  largest value of {@code n} for which all coefficients are &lt;
                  Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
                  Double.POSITIVE_INFINITY is returned&lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    n the size of the set                    
                </param>
                <param>
                    k the size of the subsets to be counted                    
                </param>
                <return>
                    {@code n choose k}                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
                <throws>
                    NumberIsTooLargeException if {@code k &gt; n}.                    
                </throws>
                <throws>
                    MathArithmeticException if the result is too large to be
                      represented by a long integer.                    
                </throws>
            </javadoc>
            <method name="binomialCoefficientDouble" type="double" line="162">
                <params>
                    <param name="n" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <scope line="164"/>
                <scope line="167"/>
                <scope line="170"/>
                <scope line="173"/>
                <declaration name="result" type="double" line="177"/>
                <scope line="178"/>
            </method>
            <javadoc line="185">
                Returns the natural {@code log} of the &lt;a
                  href=&quot;http://mathworld.wolfram.com/BinomialCoefficient.html&quot;&gt; Binomial
                  Coefficient&lt;/a&gt;, &quot;{@code n choose k}&quot;, the number of{@code k}-element subsets that can be selected from an{@code n}-element set.
                  &lt;p&gt;
                  &lt;Strong&gt;Preconditions&lt;/strong&gt;:
                  &lt;ul&gt;
                  &lt;li&gt; {@code 0 &lt;= k &lt;= n } (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    n the size of the set                    
                </param>
                <param>
                    k the size of the subsets to be counted                    
                </param>
                <return>
                    {@code n choose k}                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
                <throws>
                    NumberIsTooLargeException if {@code k &gt; n}.                    
                </throws>
                <throws>
                    MathArithmeticException if the result is too large to be
                      represented by a long integer.                    
                </throws>
            </javadoc>
            <method name="binomialCoefficientLog" type="double" line="207">
                <params>
                    <param name="n" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <comment line="217">
                    For values small enough to do exact integer computation,
                     return the log of the exact value                    
                </comment>
                <comment line="225">
                    Return the log of binomialCoefficientDouble for values that will not
                     overflow binomialCoefficientDouble                    
                </comment>
                <comment line="237">
                    Sum logs for values that could overflow                    
                </comment>
                <comment line="242">
                    n!/(n-k)!                    
                </comment>
                <comment line="247">
                    divide by k!                    
                </comment>
                <scope line="209"/>
                <scope line="212"/>
                <scope line="220"/>
                <scope line="228"/>
                <scope line="232"/>
                <declaration name="logSum" type="double" line="239"/>
                <scope line="242"/>
                <scope line="247"/>
            </method>
            <javadoc line="254">
                Returns n!. Shorthand for {@code n} &lt;a
                  href=&quot;http://mathworld.wolfram.com/Factorial.html&quot;&gt; Factorial&lt;/a&gt;, the
                  product of the numbers {@code 1,...,n}.
                  &lt;p&gt;
                  &lt;Strong&gt;Preconditions&lt;/strong&gt;:
                  &lt;ul&gt;
                  &lt;li&gt; {@code n &gt;= 0} (otherwise{@code IllegalArgumentException} is thrown)&lt;/li&gt;
                  &lt;li&gt; The result is small enough to fit into a {@code long}. The
                  largest value of {@code n} for which {@code n!} &lt;
                  Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}an {@code ArithMeticException } is thrown.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/p&gt;                
                <param>
                    n argument                    
                </param>
                <return>
                    {@code n!}                    
                </return>
                <throws>
                    MathArithmeticException if the result is too large to be represented
                      by a {@code long}.                    
                </throws>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
                <throws>
                    MathArithmeticException if {@code n &gt; 20}: The factorial value is too
                      large to fit in a {@code long}.                    
                </throws>
            </javadoc>
            <method name="factorial" type="long" line="278">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="279"/>
                <scope line="283"/>
            </method>
            <javadoc line="289">
                Compute n!, the&lt;a href=&quot;http://mathworld.wolfram.com/Factorial.html&quot;&gt;
                  factorial&lt;/a&gt; of {@code n} (the product of the numbers 1 to n), as a{@code double}.
                  The result should be small enough to fit into a {@code double}: The
                  largest {@code n} for which {@code n! &lt; Double.MAX_VALUE} is 170.
                  If the computed value exceeds {@code Double.MAX_VALUE},{@code Double.POSITIVE_INFINITY} is returned.                
                <param>
                    n Argument.                    
                </param>
                <return>
                    {@code n!}                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
            </javadoc>
            <method name="factorialDouble" type="double" line="302">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="303"/>
                <scope line="307"/>
            </method>
            <javadoc line="313">
                Compute the natural logarithm of the factorial of {@code n}.                
                <param>
                    n Argument.                    
                </param>
                <return>
                    {@code n!}                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
            </javadoc>
            <method name="factorialLog" type="double" line="320">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="321"/>
                <scope line="325"/>
                <declaration name="logSum" type="double" line="328"/>
                <scope line="329"/>
            </method>
            <javadoc line="335">
                Returns the &lt;a
                  href=&quot;http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html&quot;&gt;
                  Stirling number of the second kind&lt;/a&gt;, &quot;{@code S(n,k)}&quot;, the number of
                  ways of partitioning an {@code n}-element set into {@code k} non-empty
                  subsets.
                  &lt;p&gt;
                  The preconditions are {@code 0 &lt;= k &lt;= n } (otherwise{@code NotPositiveException} is thrown)
                  &lt;/p&gt;                
                <param>
                    n the size of the set                    
                </param>
                <param>
                    k the number of non-empty subsets                    
                </param>
                <return>
                    {@code S(n,k)}                    
                </return>
                <throws>
                    NotPositiveException if {@code k &lt; 0}.                    
                </throws>
                <throws>
                    NumberIsTooLargeException if {@code k &gt; n}.                    
                </throws>
                <throws>
                    MathArithmeticException if some overflow happens, typically for n exceeding 25 and
                      k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="stirlingS2" type="long" line="355">
                <params>
                    <param name="n" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <comment line="367">
                    the cache has never been initialized, compute the first numbers
                     by direct recurrence relation                    
                </comment>
                <comment line="370">
                    as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE
                     we must stop computation at row 26                    
                </comment>
                <comment line="385">
                    atomically save the cache                    
                </comment>
                <comment line="391">
                    the number is in the small cache                    
                </comment>
                <comment line="394">
                    use explicit formula to compute the number without caching it                    
                </comment>
                <comment line="404">
                    definition formula: note that this may trigger some overflow                    
                </comment>
                <comment line="411">
                    there was an overflow somewhere                    
                </comment>
                <scope line="356"/>
                <scope line="359"/>
                <declaration name="stirlingS2" type="long[][]" line="363"/>
                <scope line="365">
                    <declaration name="maxIndex" type="int" line="371"/>
                    <scope line="374">
                        <scope line="379"/>
                    </scope>
                </scope>
                <scope line="389"/>
                <scope line="392">
                    <scope line="394"/>
                    <scope line="396"/>
                    <scope line="398"/>
                    <scope line="400"/>
                    <scope line="402">
                        <declaration name="sum" type="long" line="404"/>
                        <declaration name="sign" type="long" line="405"/>
                        <scope line="406">
                            <scope line="409"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="421">
                Returns an iterator whose range is the k-element subsets of {0, ..., n - 1}
                  represented as {@code int[]} arrays.
                  &lt;p&gt;
                  The arrays returned by the iterator are sorted in descending order and
                  they are visited in lexicographic order with significance from right to
                  left. For example, combinationsIterator(4, 2) returns an Iterator that
                  will generate the following sequence of arrays on successive calls to{@code next()}:&lt;br/&gt;{@code [0, 1], [0, 2], [1, 2], [0, 3], [1, 3], [2, 3]}&lt;/p&gt;
                  If {@code k == 0} an Iterator containing an empty array is returned and
                  if {@code k == n} an Iterator containing [0, ..., n -1] is returned.                
                <param>
                    n Size of the set from which subsets are selected.                    
                </param>
                <param>
                    k Size of the subsets to be enumerated.                    
                </param>
                <return>
                    an {@link Iterator iterator} over the k-sets in n.                    
                </return>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
                <throws>
                    NumberIsTooLargeException if {@code k &gt; n}.                    
                </throws>
            </javadoc>
            <method name="combinationsIterator" type="Iterator&lt;int[]&gt;" line="441">
                <params>
                    <param name="n" type="int"/>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="445">
                Check binomial preconditions.                
                <param>
                    n Size of the set.                    
                </param>
                <param>
                    k Size of the subsets to be counted.                    
                </param>
                <throws>
                    NotPositiveException if {@code n &lt; 0}.                    
                </throws>
                <throws>
                    NumberIsTooLargeException if {@code k &gt; n}.                    
                </throws>
            </javadoc>
            <method name="checkBinomial" type="void" line="456">
                <params>
                    <param name="n" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <scope line="457"/>
                <scope line="461"/>
            </method>
        </class>
    </source>