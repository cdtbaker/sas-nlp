<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning">
        <import package="java.lang.reflect.Array"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.TreeSet"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.geometry.Space"/>
        <import package="org.apache.commons.math3.geometry.Vector"/>
        <class name="AbstractRegion" line="11">
            <type_params>
                <type_param name="S"/>
                <type_param name="T"/>
            </type_params>
            <implements interface="Region">
                <type_params>
                    <type_param name="S"/>
                </type_params>
            </implements>
            <javadoc line="11">
                Abstract class for all regions, independently of geometry type or dimension.                
                <param>
                    <S>
                      Type of the space.                    
                </param>
                <param>
                    <T>
                      Type of the sub-space.                    
                </param>
                <version>
                    $Id: AbstractRegion.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="tree" type="BSPTree&lt;S&gt;" line="21"/>
            <javadoc line="21">
                Inside/Outside BSP tree.                
            </javadoc>
            <declaration name="size" type="double" line="25"/>
            <javadoc line="25">
                Size of the instance.                
            </javadoc>
            <declaration name="barycenter" type="Vector&lt;S&gt;" line="29"/>
            <javadoc line="29">
                Barycenter.                
            </javadoc>
            <javadoc line="33">
                Build a region representing the whole space.                
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="36"/>
            <javadoc line="39">
                Build a region from an inside/outside BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
                  tree also &lt;em&gt;must&lt;/em&gt; have either null internal nodes or
                  internal nodes representing the boundary as specified in the{@link #getTree getTree} method).&lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the region                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="49">
                <params>
                    <param name="tree" type="BSPTree<S>"/>
                </params>
            </method>
            <javadoc line="52">
                Build a Region from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoints polyhedrons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link #checkPoint(Vector) checkPoint} method will not be
                  meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements, as a
                      collection of {@link SubHyperplane SubHyperplane} objects                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="71">
                <params>
                    <param name="boundary" type="Collection<SubHyperplane<S>>"/>
                </params>
                <scope line="72"/>
                <scope line="75">
                    <anonymous_class line="76">
                        <method name="compare" type="int" line="77">
                            <params>
                                <param name="o1" type="SubHyperplane<S>"/>
                                <param name="o2" type="SubHyperplane<S>"/>
                            </params>
                            <declaration name="size1" type="double" line="78"/>
                            <declaration name="size2" type="double" line="79"/>
                        </method>
                    </anonymous_class>
                    <declaration name="ordered" type="TreeSet&lt;SubHyperplane&lt;S&gt;&gt;" line="76"/>
                    <anonymous_class line="87">
                        <javadoc line="88">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitOrder" type="Order" line="91">
                            <params>
                                <param name="node" type="BSPTree<S>"/>
                            </params>
                        </method>
                        <javadoc line="94">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitInternalNode" type="void" line="97">
                            <params>
                                <param name="node" type="BSPTree<S>"/>
                            </params>
                        </method>
                        <javadoc line="99">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitLeafNode" type="void" line="102">
                            <params>
                                <param name="node" type="BSPTree<S>"/>
                            </params>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <javadoc line="109">
                Build a convex region from an array of bounding hyperplanes.                
                <param>
                    hyperplanes array of bounding hyperplanes (if null, an
                      empty region will be built)                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="114">
                <params>
                    <param name="hyperplanes" type="Hyperplane<S>[]"/>
                </params>
                <scope line="115"/>
                <scope line="118">
                    <declaration name="node" type="BSPTree&lt;S&gt;" line="120"/>
                    <scope line="122">
                        <scope line="123"/>
                    </scope>
                </scope>
            </method>
            <method name="buildNew" type="AbstractRegion<S,T>" line="132"/>
            <javadoc line="132">
                {@inheritDoc}                
            </javadoc>
            <javadoc line="136">
                Recursively build a tree by inserting cut sub-hyperplanes.                
                <param>
                    node current tree node (it is a leaf node at the beginning
                      of the call)                    
                </param>
                <param>
                    boundary collection of edges belonging to the cell defined
                      by the node                    
                </param>
            </javadoc>
            <method name="insertCuts" type="void" line="143">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                    <param name="boundary" type="Collection<SubHyperplane<S>>"/>
                </params>
                <declaration name="iterator" type="Iterator&lt;SubHyperplane&lt;S&gt;&gt;" line="144"/>
                <declaration name="inserted" type="Hyperplane&lt;S&gt;" line="145"/>
                <scope line="146">
                    <scope line="148"/>
                </scope>
                <scope line="152"/>
                <declaration name="plusList" type="ArrayList&lt;SubHyperplane&lt;S&gt;&gt;" line="155"/>
                <declaration name="minusList" type="ArrayList&lt;SubHyperplane&lt;S&gt;&gt;" line="156"/>
                <scope line="157">
                    <declaration name="other" type="SubHyperplane&lt;S&gt;" line="158"/>
                    <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="167"/>
                </scope>
            </method>
            <javadoc line="177">
                {@inheritDoc}                
            </javadoc>
            <method name="copySelf" type="AbstractRegion<S,T>" line="180"/>
            <javadoc line="183">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="186"/>
            <javadoc line="189">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="192">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                </params>
                <scope line="193"/>
            </method>
            <javadoc line="198">
                {@inheritDoc}                
            </javadoc>
            <method name="contains" type="boolean" line="201">
                <params>
                    <param name="region" type="Region<S>"/>
                </params>
            </method>
            <javadoc line="204">
                {@inheritDoc}                
            </javadoc>
            <method name="checkPoint" type="Location" line="207">
                <params>
                    <param name="point" type="Vector<S>"/>
                </params>
            </method>
            <javadoc line="210">
                Check a point with respect to the region starting at a given node.                
                <param>
                    node root node of the region                    
                </param>
                <param>
                    point point to check                    
                </param>
                <return>
                    a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDEOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}                    
                </return>
            </javadoc>
            <method name="checkPoint" type="Location" line="216">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                    <param name="point" type="Vector<S>"/>
                </params>
                <declaration name="cell" type="BSPTree&lt;S&gt;" line="217"/>
                <scope line="218"/>
                <declaration name="minusCode" type="Location" line="221"/>
                <declaration name="plusCode" type="Location" line="222"/>
            </method>
            <javadoc line="225">
                {@inheritDoc}                
            </javadoc>
            <method name="getTree" type="BSPTree<S>" line="228">
                <params>
                    <param name="includeBoundaryAttributes" type="boolean"/>
                </params>
                <scope line="229"/>
            </method>
            <class name="BoundaryBuilder" line="234">
                <type_params>
                    <type_param name="S"/>
                </type_params>
                <implements interface="BSPTreeVisitor">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="234">
                    Visitor building boundary shell tree.
                      &lt;p&gt;
                      The boundary shell is represented as {@link BoundaryAttribute boundary attributes}at each internal node.
                      &lt;/p&gt;                    
                </javadoc>
                <javadoc line="241">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitOrder" type="Order" line="244">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                    </params>
                </method>
                <javadoc line="247">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitInternalNode" type="void" line="250">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                    </params>
                    <declaration name="plusOutside" type="SubHyperplane&lt;S&gt;" line="251"/>
                    <declaration name="plusInside" type="SubHyperplane&lt;S&gt;" line="252"/>
                    <declaration name="plusChar" type="SubHyperplane&lt;S&gt;[]" line="253"/>
                    <scope line="255">
                        <declaration name="minusChar" type="SubHyperplane&lt;S&gt;[]" line="256"/>
                        <scope line="258"/>
                    </scope>
                    <scope line="262">
                        <declaration name="minusChar" type="SubHyperplane&lt;S&gt;[]" line="263"/>
                        <scope line="265"/>
                    </scope>
                </method>
                <javadoc line="271">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitLeafNode" type="void" line="274">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                    </params>
                </method>
                <javadoc line="276">
                    Filter the parts of an hyperplane belonging to the boundary.
                      &lt;p&gt;The filtering consist in splitting the specified
                      sub-hyperplane into several parts lying in inside and outside
                      cells of the tree. The principle is to call this method twice for
                      each cut sub-hyperplane in the tree, once one the plus node and
                      once on the minus node. The parts that have the same flag
                      (inside/inside or outside/outside) do not belong to the boundary
                      while parts that have different flags (inside/outside or
                      outside/inside) do belong to the boundary.&lt;/p&gt;                    
                    <param>
                        node current BSP tree node                        
                    </param>
                    <param>
                        sub sub-hyperplane to characterize                        
                    </param>
                    <param>
                        characterization placeholder where to put the characterized parts                        
                    </param>
                </javadoc>
                <method name="characterize" type="void" line="290">
                    <params>
                        <param name="node" type="BSPTree<S>"/>
                        <param name="sub" type="SubHyperplane<S>"/>
                        <param name="characterization" type="SubHyperplane<S>[]"/>
                    </params>
                    <scope line="291">
                        <declaration name="inside" type="boolean" line="292"/>
                        <scope line="293">
                            <scope line="294"/>
                            <scope line="297"/>
                        </scope>
                        <scope line="301">
                            <scope line="302"/>
                            <scope line="305"/>
                        </scope>
                    </scope>
                    <scope line="310">
                        <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="311"/>
                        <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="320"/>
                    </scope>
                </method>
            </class>
            <javadoc line="330">
                {@inheritDoc}                
            </javadoc>
            <method name="getBoundarySize" type="double" line="333">
                <declaration name="visitor" type="BoundarySizeVisitor&lt;S&gt;" line="334"/>
            </method>
            <javadoc line="338">
                {@inheritDoc}                
            </javadoc>
            <method name="getSize" type="double" line="341">
                <scope line="342"/>
            </method>
            <javadoc line="347">
                Set the size of the instance.                
                <param>
                    size size of the instance                    
                </param>
            </javadoc>
            <method name="setSize" type="void" line="351">
                <params>
                    <param name="size" type="double"/>
                </params>
            </method>
            <javadoc line="354">
                {@inheritDoc}                
            </javadoc>
            <method name="getBarycenter" type="Vector<S>" line="357">
                <scope line="358"/>
            </method>
            <javadoc line="363">
                Set the barycenter of the instance.                
                <param>
                    barycenter barycenter of the instance                    
                </param>
            </javadoc>
            <method name="setBarycenter" type="void" line="367">
                <params>
                    <param name="barycenter" type="Vector<S>"/>
                </params>
            </method>
            <method name="computeGeometricalProperties" type="void" line="370"/>
            <javadoc line="370">
                Compute some geometrical properties.
                  &lt;p&gt;The properties to compute are the barycenter and the size.&lt;/p&gt;                
            </javadoc>
            <javadoc line="375">
                {@inheritDoc}                
            </javadoc>
            <method name="side" type="Side" line="378">
                <params>
                    <param name="hyperplane" type="Hyperplane<S>"/>
                </params>
                <declaration name="sides" type="Sides" line="379"/>
            </method>
            <javadoc line="383">
                Search recursively for inside leaf nodes on each side of the given hyperplane.
                  &lt;p&gt;The algorithm used here is directly derived from the one
                  described in section III (&lt;i&gt;Binary Partitioning of a BSP
                  Tree&lt;/i&gt;) of the Bruce Naylor, John Amanatides and William
                  Thibault paper &lt;a
                  href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
                  BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph
                  &apos;90, Computer Graphics 24(4), August 1990, pp 115-124, published
                  by the Association for Computing Machinery (ACM)..&lt;/p&gt;                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    sub sub-hyperplane                    
                </param>
                <param>
                    sides object holding the sides found                    
                </param>
            </javadoc>
            <method name="recurseSides" type="void" line="397">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                    <param name="sub" type="SubHyperplane<S>"/>
                    <param name="sides" type="Sides"/>
                </params>
                <scope line="398">
                    <scope line="399"/>
                </scope>
                <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="405"/>
                <scope line="408">
                    <scope line="409"/>
                </scope>
                <scope line="413">
                    <scope line="414"/>
                </scope>
                <scope line="418"/>
                <scope line="423">
                    <scope line="424"/>
                </scope>
                <scope line="428">
                    <scope line="429"/>
                </scope>
                <scope line="433"/>
                <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="438"/>
                <scope line="440"/>
                <scope line="445">
                    <scope line="446"/>
                    <scope line="449"/>
                </scope>
                <scope line="453">
                    <scope line="454"/>
                    <scope line="457"/>
                </scope>
            </method>
            <class name="Sides" line="463">
                <javadoc line="463">
                    Utility class holding the already found sides.                    
                </javadoc>
                <declaration name="plusFound" type="boolean" line="467"/>
                <javadoc line="467">
                    Indicator of inside leaf nodes found on the plus side.                    
                </javadoc>
                <declaration name="minusFound" type="boolean" line="471"/>
                <javadoc line="471">
                    Indicator of inside leaf nodes found on the plus side.                    
                </javadoc>
                <javadoc line="475">
                    Simple constructor.                    
                </javadoc>
                <method name="Sides" type="constructor" line="478"/>
                <javadoc line="482">
                    Remember the fact that inside leaf nodes have been found on the plus side.                    
                </javadoc>
                <method name="rememberPlusFound" type="void" line="485"/>
                <javadoc line="488">
                    Check if inside leaf nodes have been found on the plus side.                    
                    <return>
                        true if inside leaf nodes have been found on the plus side                        
                    </return>
                </javadoc>
                <method name="plusFound" type="boolean" line="492"/>
                <javadoc line="495">
                    Remember the fact that inside leaf nodes have been found on the minus side.                    
                </javadoc>
                <method name="rememberMinusFound" type="void" line="498"/>
                <javadoc line="501">
                    Check if inside leaf nodes have been found on the minus side.                    
                    <return>
                        true if inside leaf nodes have been found on the minus side                        
                    </return>
                </javadoc>
                <method name="minusFound" type="boolean" line="505"/>
            </class>
            <javadoc line="509">
                {@inheritDoc}                
            </javadoc>
            <method name="intersection" type="SubHyperplane<S>" line="512">
                <params>
                    <param name="sub" type="SubHyperplane<S>"/>
                </params>
            </method>
            <javadoc line="515">
                Recursively compute the parts of a sub-hyperplane that are
                  contained in the region.                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    sub sub-hyperplane traversing the region                    
                </param>
                <return>
                    filtered sub-hyperplane                    
                </return>
            </javadoc>
            <method name="recurseIntersection" type="SubHyperplane<S>" line="522">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                    <param name="sub" type="SubHyperplane<S>"/>
                </params>
                <scope line="523"/>
                <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="526"/>
                <declaration name="split" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="533"/>
                <declaration name="plus" type="SubHyperplane&lt;S&gt;" line="534"/>
                <declaration name="minus" type="SubHyperplane&lt;S&gt;" line="535"/>
                <scope line="536"/>
                <scope line="539"/>
                <scope line="542"/>
            </method>
            <javadoc line="549">
                Transform a region.
                  &lt;p&gt;Applying a transform to a region consist in applying the
                  transform to all the hyperplanes of the underlying BSP tree and
                  of the boundary (and also to the sub-hyperplanes embedded in
                  these hyperplanes) and to the barycenter. The instance is not
                  modified, a new instance is built.&lt;/p&gt;                
                <param>
                    transform transform to apply                    
                </param>
                <return>
                    a new region, resulting from the application of the
                      transform to the instance                    
                </return>
            </javadoc>
            <method name="applyTransform" type="AbstractRegion<S,T>" line="560">
                <params>
                    <param name="transform" type="Transform<S,T>"/>
                </params>
            </method>
            <javadoc line="563">
                Recursively transform an inside/outside BSP-tree.                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    transform transform to apply                    
                </param>
                <return>
                    a new tree                    
                </return>
            </javadoc>
            <method name="recurseTransform" type="BSPTree<S>" line="569">
                <params>
                    <param name="node" type="BSPTree<S>"/>
                    <param name="transform" type="Transform<S,T>"/>
                </params>
                <scope line="570"/>
                <declaration name="sub" type="SubHyperplane&lt;S&gt;" line="573"/>
                <declaration name="tSub" type="SubHyperplane&lt;S&gt;" line="574"/>
                <declaration name="attribute" type="BoundaryAttribute&lt;S&gt;" line="575"/>
                <scope line="576">
                    <declaration name="tPO" type="SubHyperplane&lt;S&gt;" line="577"/>
                    <declaration name="tPI" type="SubHyperplane&lt;S&gt;" line="578"/>
                </scope>
            </method>
        </class>
    </source>