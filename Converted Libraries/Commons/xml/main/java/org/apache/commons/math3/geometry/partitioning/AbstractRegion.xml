<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning">
        <import package="java.lang.reflect.Array"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.TreeSet"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.geometry.Space"/>
        <import package="org.apache.commons.math3.geometry.Point"/>
        <import package="org.apache.commons.math3.geometry.Vector"/>
        <import package="org.apache.commons.math3.geometry.partitioning.Region.Location"/>
        <class name="AbstractRegion" line="32">
            <type_params>
                <type_param name="S"/>
                <type_param name="T"/>
            </type_params>
            <implements interface="Region">
                <type_params>
                    <type_param name="S"/>
                </type_params>
            </implements>
            <javadoc line="32">
                Abstract class for all regions, independently of geometry type or dimension.                
                <param>
                    &lt;S&gt;
                       Type of the space.                    
                </param>
                <param>
                    &lt;T&gt;
                       Type of the sub-space.                    
                </param>
                <version>
                    $Id: AbstractRegion.java 1566358 2014-02-09 19:17:55Z luc $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="tree" type="BSPTree&amp;lt;S&amp;gt;" line="42"/>
            <javadoc line="42">
                Inside/Outside BSP tree.                
            </javadoc>
            <declaration name="tolerance" type="double" line="45"/>
            <javadoc line="45">
                Tolerance below which points are considered to belong to hyperplanes.                
            </javadoc>
            <declaration name="size" type="double" line="48"/>
            <javadoc line="48">
                Size of the instance.                
            </javadoc>
            <declaration name="barycenter" type="Point&amp;lt;S&amp;gt;" line="51"/>
            <javadoc line="51">
                Barycenter.                
            </javadoc>
            <javadoc line="54">
                Build a region representing the whole space.                
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="57">
                <params>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="62">
                Build a region from an inside/outside BSP tree.
                  &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a{@code Boolean} attribute representing the inside status of
                  the corresponding cell (true for inside cells, false for outside
                  cells). In order to avoid building too many small objects, it is
                  recommended to use the predefined constants{@code Boolean.TRUE} and {@code Boolean.FALSE}. The
                  tree also &lt;em&gt;must&lt;/em&gt; have either null internal nodes or
                  internal nodes representing the boundary as specified in the{@link #getTree getTree} method).&lt;/p&gt;                
                <param>
                    tree inside/outside BSP tree representing the region                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="75">
                <params>
                    <param name="tree" type="BSPTree&lt;S&gt;"/>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="80">
                Build a Region from a Boundary REPresentation (B-rep).
                  &lt;p&gt;The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
                  interior part of the region on its minus side and the exterior on
                  its plus side.&lt;/p&gt;
                  &lt;p&gt;The boundary elements can be in any order, and can form
                  several non-connected sets (like for example polygons with holes
                  or a set of disjoints polyhedrons considered as a whole). In
                  fact, the elements do not even need to be connected together
                  (their topological connections are not used here). However, if the
                  boundary does not really separate an inside open from an outside
                  open (open having here its topological meaning), then subsequent
                  calls to the {@link #checkPoint(Point) checkPoint} method will not be
                  meaningful anymore.&lt;/p&gt;
                  &lt;p&gt;If the boundary is empty, the region will represent the whole
                  space.&lt;/p&gt;                
                <param>
                    boundary collection of boundary elements, as a
                      collection of {@link SubHyperplane SubHyperplane} objects                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="100">
                <params>
                    <param name="boundary" type="Collection&lt;SubHyperplane&lt;S&gt;&gt;"/>
                    <param name="tolerance" type="double"/>
                </params>
                <comment line="107">
                    the tree represents the whole space                    
                </comment>
                <comment line="112">
                    sort the boundary elements in decreasing size order
                     (we don&apos;t want equal size elements to be removed, so
                     we use a trick to fool the TreeSet)                    
                </comment>
                <comment line="124">
                    build the tree top-down                    
                </comment>
                <comment line="128">
                    set up the inside/outside flags                    
                </comment>
                <scope line="104"/>
                <scope line="109">
                    <anonymous_class line="114">
                        <method name="compare" type="int" line="115">
                            <params>
                                <param name="o1" type="SubHyperplane&lt;S&gt;"/>
                                <param name="o2" type="SubHyperplane&lt;S&gt;"/>
                            </params>
                            <declaration name="size1" type="double" line="116"/>
                            <declaration name="size2" type="double" line="117"/>
                        </method>
                    </anonymous_class>
                    <declaration name="ordered" type="TreeSet&amp;lt;SubHyperplane&amp;lt;S&amp;gt;&amp;gt;" line="114"/>
                    <anonymous_class line="128">
                        <javadoc line="130">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitOrder" type="Order" line="131">
                            <params>
                                <param name="node" type="BSPTree&lt;S&gt;"/>
                            </params>
                        </method>
                        <javadoc line="135">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitInternalNode" type="void" line="136">
                            <params>
                                <param name="node" type="BSPTree&lt;S&gt;"/>
                            </params>
                        </method>
                        <javadoc line="139">
                            {@inheritDoc}                            
                        </javadoc>
                        <method name="visitLeafNode" type="void" line="140">
                            <params>
                                <param name="node" type="BSPTree&lt;S&gt;"/>
                            </params>
                            <scope line="141"/>
                            <scope line="143"/>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <javadoc line="153">
                Build a convex region from an array of bounding hyperplanes.                
                <param>
                    hyperplanes array of bounding hyperplanes (if null, an
                      empty region will be built)                    
                </param>
                <param>
                    tolerance tolerance below which points are considered identical.                    
                </param>
            </javadoc>
            <method name="AbstractRegion" type="constructor" line="158">
                <params>
                    <param name="hyperplanes" type="Hyperplane&lt;S&gt;[]"/>
                    <param name="tolerance" type="double"/>
                </params>
                <comment line="165">
                    use the first hyperplane to build the right class                    
                </comment>
                <comment line="168">
                    chop off parts of the space                    
                </comment>
                <scope line="160"/>
                <scope line="162">
                    <declaration name="node" type="BSPTree&amp;lt;S&amp;gt;" line="168"/>
                    <scope line="170">
                        <scope line="171"/>
                    </scope>
                </scope>
            </method>
            <method name="buildNew" type="AbstractRegion&lt;S,T&gt;" line="183"/>
            <javadoc line="183">
                {@inheritDoc}                
            </javadoc>
            <javadoc line="186">
                Get the tolerance below which points are considered to belong to hyperplanes.                
                <return>
                    tolerance below which points are considered to belong to hyperplanes                    
                </return>
            </javadoc>
            <method name="getTolerance" type="double" line="189"/>
            <javadoc line="193">
                Recursively build a tree by inserting cut sub-hyperplanes.                
                <param>
                    node current tree node (it is a leaf node at the beginning
                      of the call)                    
                </param>
                <param>
                    boundary collection of edges belonging to the cell defined
                      by the node                    
                </param>
            </javadoc>
            <method name="insertCuts" type="void" line="199">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                    <param name="boundary" type="Collection&lt;SubHyperplane&lt;S&gt;&gt;"/>
                </params>
                <comment line="204">
                    build the current level                    
                </comment>
                <comment line="217">
                    distribute the remaining edges in the two sub-trees                    
                </comment>
                <comment line="235">
                    ignore the sub-hyperplanes belonging to the cut hyperplane                    
                </comment>
                <comment line="239">
                    recurse through lower levels                    
                </comment>
                <declaration name="iterator" type="Iterator&amp;lt;SubHyperplane&amp;lt;S&amp;gt;&amp;gt;" line="201"/>
                <declaration name="inserted" type="Hyperplane&amp;lt;S&amp;gt;" line="204"/>
                <scope line="205">
                    <scope line="207"/>
                </scope>
                <scope line="212"/>
                <declaration name="plusList" type="ArrayList&amp;lt;SubHyperplane&amp;lt;S&amp;gt;&amp;gt;" line="217"/>
                <declaration name="minusList" type="ArrayList&amp;lt;SubHyperplane&amp;lt;S&amp;gt;&amp;gt;" line="218"/>
                <scope line="219">
                    <declaration name="other" type="SubHyperplane&amp;lt;S&amp;gt;" line="220"/>
                    <declaration name="split" type="SubHyperplane.SplitSubHyperplane&amp;lt;S&amp;gt;" line="229"/>
                </scope>
            </method>
            <javadoc line="244">
                {@inheritDoc}                
            </javadoc>
            <method name="copySelf" type="AbstractRegion&lt;S,T&gt;" line="245"/>
            <javadoc line="249">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="250"/>
            <javadoc line="254">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="255">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                </params>
                <comment line="258">
                    we use a recursive function rather than the BSPTreeVisitor
                     interface because we can stop visiting the tree as soon as we
                     have found an inside cell                    
                </comment>
                <comment line="263">
                    if we find an inside node, the region is not empty                    
                </comment>
                <comment line="267">
                    check both sides of the sub-tree                    
                </comment>
                <scope line="261"/>
            </method>
            <javadoc line="271">
                {@inheritDoc}                
            </javadoc>
            <method name="isFull" type="boolean" line="272"/>
            <javadoc line="276">
                {@inheritDoc}                
            </javadoc>
            <method name="isFull" type="boolean" line="277">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                </params>
                <comment line="280">
                    we use a recursive function rather than the BSPTreeVisitor
                     interface because we can stop visiting the tree as soon as we
                     have found an outside cell                    
                </comment>
                <comment line="285">
                    if we find an outside node, the region does not cover full space                    
                </comment>
                <comment line="289">
                    check both sides of the sub-tree                    
                </comment>
                <scope line="283"/>
            </method>
            <javadoc line="293">
                {@inheritDoc}                
            </javadoc>
            <method name="contains" type="boolean" line="294">
                <params>
                    <param name="region" type="Region&lt;S&gt;"/>
                </params>
            </method>
            <javadoc line="298">
                {@inheritDoc}                
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="projectToBoundary" type="BoundaryProjection&lt;S&gt;" line="301">
                <params>
                    <param name="point" type="Point&lt;S&gt;"/>
                </params>
                <declaration name="projector" type="BoundaryProjector&amp;lt;S,T&amp;gt;" line="302"/>
            </method>
            <javadoc line="307">
                Check a point with respect to the region.                
                <param>
                    point point to check                    
                </param>
                <return>
                    a code representing the point status: either {@link Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}                    
                </return>
            </javadoc>
            <method name="checkPoint" type="Location" line="312">
                <params>
                    <param name="point" type="Vector&lt;S&gt;"/>
                </params>
            </method>
            <javadoc line="316">
                {@inheritDoc}                
            </javadoc>
            <method name="checkPoint" type="Location" line="317">
                <params>
                    <param name="point" type="Point&lt;S&gt;"/>
                </params>
            </method>
            <javadoc line="321">
                Check a point with respect to the region starting at a given node.                
                <param>
                    node root node of the region                    
                </param>
                <param>
                    point point to check                    
                </param>
                <return>
                    a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDEOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}                    
                </return>
            </javadoc>
            <method name="checkPoint" type="Location" line="328">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                    <param name="point" type="Vector&lt;S&gt;"/>
                </params>
            </method>
            <javadoc line="332">
                Check a point with respect to the region starting at a given node.                
                <param>
                    node root node of the region                    
                </param>
                <param>
                    point point to check                    
                </param>
                <return>
                    a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDEOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}                    
                </return>
            </javadoc>
            <method name="checkPoint" type="Location" line="339">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                    <param name="point" type="Point&lt;S&gt;"/>
                </params>
                <comment line="343">
                    the point is in the interior of a cell, just check the attribute                    
                </comment>
                <comment line="347">
                    the point is on a cut-sub-hyperplane, is it on a boundary ?                    
                </comment>
                <declaration name="cell" type="BSPTree&amp;lt;S&amp;gt;" line="340"/>
                <scope line="341"/>
                <declaration name="minusCode" type="Location" line="347"/>
                <declaration name="plusCode" type="Location" line="348"/>
            </method>
            <javadoc line="353">
                {@inheritDoc}                
            </javadoc>
            <method name="getTree" type="BSPTree&lt;S&gt;" line="354">
                <params>
                    <param name="includeBoundaryAttributes" type="boolean"/>
                </params>
                <comment line="357">
                    we need to compute the boundary attributes                    
                </comment>
                <scope line="355"/>
            </method>
            <class name="BoundaryBuilder" line="362">
                <type_params>
                    <type_param name="S"/>
                </type_params>
                <implements interface="BSPTreeVisitor">
                    <type_params>
                        <type_param name="S"/>
                    </type_params>
                </implements>
                <javadoc line="362">
                    Visitor building boundary shell tree.
                      &lt;p&gt;
                      The boundary shell is represented as {@link BoundaryAttribute boundary attributes}at each internal node.
                      &lt;/p&gt;                    
                </javadoc>
                <javadoc line="370">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitOrder" type="Order" line="371">
                    <params>
                        <param name="node" type="BSPTree&lt;S&gt;"/>
                    </params>
                </method>
                <javadoc line="375">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitInternalNode" type="void" line="376">
                    <params>
                        <param name="node" type="BSPTree&lt;S&gt;"/>
                    </params>
                    <comment line="382">
                        characterize the cut sub-hyperplane,
                         first with respect to the plus sub-tree                        
                    </comment>
                    <comment line="389">
                        plusChar[0] corresponds to a subset of the cut sub-hyperplane known to have
                         outside cells on its plus side, we want to check if parts of this subset
                         do have inside cells on their minus side                        
                    </comment>
                    <comment line="396">
                        this part belongs to the boundary,
                         it has the outside on its plus side and the inside on its minus side                        
                    </comment>
                    <comment line="403">
                        plusChar[1] corresponds to a subset of the cut sub-hyperplane known to have
                         inside cells on its plus side, we want to check if parts of this subset
                         do have outside cells on their minus side                        
                    </comment>
                    <comment line="410">
                        this part belongs to the boundary,
                         it has the inside on its plus side and the outside on its minus side                        
                    </comment>
                    <comment line="416">
                        set the boundary attribute at non-leaf nodes                        
                    </comment>
                    <declaration name="plusOutside" type="SubHyperplane&amp;lt;S&amp;gt;" line="378"/>
                    <declaration name="plusInside" type="SubHyperplane&amp;lt;S&amp;gt;" line="379"/>
                    <declaration name="plusChar" type="SubHyperplane&amp;lt;S&amp;gt;[]" line="383"/>
                    <scope line="387">
                        <declaration name="minusChar" type="SubHyperplane&amp;lt;S&amp;gt;[]" line="391"/>
                        <scope line="394"/>
                    </scope>
                    <scope line="401">
                        <declaration name="minusChar" type="SubHyperplane&amp;lt;S&amp;gt;[]" line="405"/>
                        <scope line="408"/>
                    </scope>
                </method>
                <javadoc line="420">
                    {@inheritDoc}                    
                </javadoc>
                <method name="visitLeafNode" type="void" line="421">
                    <params>
                        <param name="node" type="BSPTree&lt;S&gt;"/>
                    </params>
                </method>
                <javadoc line="424">
                    Filter the parts of an hyperplane belonging to the boundary.
                      &lt;p&gt;The filtering consist in splitting the specified
                      sub-hyperplane into several parts lying in inside and outside
                      cells of the tree. The principle is to call this method twice for
                      each cut sub-hyperplane in the tree, once on the plus node and
                      once on the minus node. The parts that have the same flag
                      (inside/inside or outside/outside) do not belong to the boundary
                      while parts that have different flags (inside/outside or
                      outside/inside) do belong to the boundary.&lt;/p&gt;                    
                    <param>
                        node current BSP tree node                        
                    </param>
                    <param>
                        sub sub-hyperplane to characterize                        
                    </param>
                    <param>
                        characterization placeholder where to put the characterized parts                        
                    </param>
                </javadoc>
                <method name="characterize" type="void" line="438">
                    <params>
                        <param name="node" type="BSPTree&lt;S&gt;"/>
                        <param name="sub" type="SubHyperplane&lt;S&gt;"/>
                        <param name="characterization" type="SubHyperplane&lt;S&gt;[]"/>
                    </params>
                    <comment line="441">
                        we have reached a leaf node                        
                    </comment>
                    <comment line="471">
                        this should not happen                        
                    </comment>
                    <scope line="439">
                        <declaration name="inside" type="boolean" line="441"/>
                        <scope line="442">
                            <scope line="443"/>
                            <scope line="445"/>
                        </scope>
                        <scope line="448">
                            <scope line="449"/>
                            <scope line="451"/>
                        </scope>
                    </scope>
                    <scope line="455">
                        <declaration name="hyperplane" type="Hyperplane&amp;lt;S&amp;gt;" line="456"/>
                        <declaration name="split" type="SubHyperplane.SplitSubHyperplane&amp;lt;S&amp;gt;" line="465"/>
                    </scope>
                </method>
            </class>
            <javadoc line="478">
                {@inheritDoc}                
            </javadoc>
            <method name="getBoundarySize" type="double" line="479">
                <declaration name="visitor" type="BoundarySizeVisitor&amp;lt;S&amp;gt;" line="480"/>
            </method>
            <javadoc line="485">
                {@inheritDoc}                
            </javadoc>
            <method name="getSize" type="double" line="486">
                <scope line="487"/>
            </method>
            <javadoc line="493">
                Set the size of the instance.                
                <param>
                    size size of the instance                    
                </param>
            </javadoc>
            <method name="setSize" type="void" line="496">
                <params>
                    <param name="size" type="double"/>
                </params>
            </method>
            <javadoc line="500">
                {@inheritDoc}                
            </javadoc>
            <method name="getBarycenter" type="Point&lt;S&gt;" line="501">
                <scope line="502"/>
            </method>
            <javadoc line="508">
                Set the barycenter of the instance.                
                <param>
                    barycenter barycenter of the instance                    
                </param>
            </javadoc>
            <method name="setBarycenter" type="void" line="511">
                <params>
                    <param name="barycenter" type="Vector&lt;S&gt;"/>
                </params>
            </method>
            <javadoc line="515">
                Set the barycenter of the instance.                
                <param>
                    barycenter barycenter of the instance                    
                </param>
            </javadoc>
            <method name="setBarycenter" type="void" line="518">
                <params>
                    <param name="barycenter" type="Point&lt;S&gt;"/>
                </params>
            </method>
            <method name="computeGeometricalProperties" type="void" line="522"/>
            <javadoc line="522">
                Compute some geometrical properties.
                  &lt;p&gt;The properties to compute are the barycenter and the size.&lt;/p&gt;                
            </javadoc>
            <javadoc line="527">
                {@inheritDoc}                
            </javadoc>
            <method name="side" type="Side" line="528">
                <params>
                    <param name="hyperplane" type="Hyperplane&lt;S&gt;"/>
                </params>
                <declaration name="sides" type="Sides" line="529"/>
            </method>
            <javadoc line="536">
                Search recursively for inside leaf nodes on each side of the given hyperplane.
                  &lt;p&gt;The algorithm used here is directly derived from the one
                  described in section III (&lt;i&gt;Binary Partitioning of a BSP
                  Tree&lt;/i&gt;) of the Bruce Naylor, John Amanatides and William
                  Thibault paper &lt;a
                  href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
                  BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph
                  &apos;90, Computer Graphics 24(4), August 1990, pp 115-124, published
                  by the Association for Computing Machinery (ACM)..&lt;/p&gt;                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    sub sub-hyperplane                    
                </param>
                <param>
                    sides object holding the sides found                    
                </param>
            </javadoc>
            <method name="recurseSides" type="void" line="551">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                    <param name="sub" type="SubHyperplane&lt;S&gt;"/>
                    <param name="sides" type="Sides"/>
                </params>
                <comment line="556">
                    this is an inside cell expanding across the hyperplane                    
                </comment>
                <comment line="566">
                    the sub-hyperplane is entirely in the plus sub-tree                    
                </comment>
                <comment line="581">
                    the sub-hyperplane is entirely in the minus sub-tree                    
                </comment>
                <comment line="596">
                    the sub-hyperplane extends in both sub-trees                    
                </comment>
                <comment line="599">
                    explore first the plus sub-tree                    
                </comment>
                <comment line="602">
                    if needed, explore the minus sub-tree                    
                </comment>
                <comment line="608">
                    the sub-hyperplane and the cut sub-hyperplane share the same hyperplane                    
                </comment>
                <scope line="553">
                    <scope line="554"/>
                </scope>
                <declaration name="hyperplane" type="Hyperplane&amp;lt;S&amp;gt;" line="562"/>
                <scope line="566">
                    <scope line="567"/>
                </scope>
                <scope line="570">
                    <scope line="571"/>
                </scope>
                <scope line="575"/>
                <scope line="581">
                    <scope line="582"/>
                </scope>
                <scope line="585">
                    <scope line="586"/>
                </scope>
                <scope line="590"/>
                <declaration name="split" type="SubHyperplane.SplitSubHyperplane&amp;lt;S&amp;gt;" line="596"/>
                <scope line="602"/>
                <scope line="608">
                    <scope line="609"/>
                    <scope line="612"/>
                </scope>
                <scope line="615">
                    <scope line="616"/>
                    <scope line="619"/>
                </scope>
            </method>
            <class name="Sides" line="627">
                <javadoc line="627">
                    Utility class holding the already found sides.                    
                </javadoc>
                <declaration name="plusFound" type="boolean" line="630"/>
                <javadoc line="630">
                    Indicator of inside leaf nodes found on the plus side.                    
                </javadoc>
                <declaration name="minusFound" type="boolean" line="633"/>
                <javadoc line="633">
                    Indicator of inside leaf nodes found on the plus side.                    
                </javadoc>
                <javadoc line="636">
                    Simple constructor.                    
                </javadoc>
                <method name="Sides" type="constructor" line="638"/>
                <javadoc line="643">
                    Remember the fact that inside leaf nodes have been found on the plus side.                    
                </javadoc>
                <method name="rememberPlusFound" type="void" line="645"/>
                <javadoc line="649">
                    Check if inside leaf nodes have been found on the plus side.                    
                    <return>
                        true if inside leaf nodes have been found on the plus side                        
                    </return>
                </javadoc>
                <method name="plusFound" type="boolean" line="652"/>
                <javadoc line="656">
                    Remember the fact that inside leaf nodes have been found on the minus side.                    
                </javadoc>
                <method name="rememberMinusFound" type="void" line="658"/>
                <javadoc line="662">
                    Check if inside leaf nodes have been found on the minus side.                    
                    <return>
                        true if inside leaf nodes have been found on the minus side                        
                    </return>
                </javadoc>
                <method name="minusFound" type="boolean" line="665"/>
            </class>
            <javadoc line="671">
                {@inheritDoc}                
            </javadoc>
            <method name="intersection" type="SubHyperplane&lt;S&gt;" line="672">
                <params>
                    <param name="sub" type="SubHyperplane&lt;S&gt;"/>
                </params>
            </method>
            <javadoc line="676">
                Recursively compute the parts of a sub-hyperplane that are
                  contained in the region.                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    sub sub-hyperplane traversing the region                    
                </param>
                <return>
                    filtered sub-hyperplane                    
                </return>
            </javadoc>
            <method name="recurseIntersection" type="SubHyperplane&lt;S&gt;" line="682">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                    <param name="sub" type="SubHyperplane&lt;S&gt;"/>
                </params>
                <scope line="684"/>
                <declaration name="hyperplane" type="Hyperplane&amp;lt;S&amp;gt;" line="688"/>
                <declaration name="split" type="SubHyperplane.SplitSubHyperplane&amp;lt;S&amp;gt;" line="695"/>
                <declaration name="plus" type="SubHyperplane&amp;lt;S&amp;gt;" line="696"/>
                <declaration name="minus" type="SubHyperplane&amp;lt;S&amp;gt;" line="697"/>
                <scope line="698"/>
                <scope line="700"/>
                <scope line="702"/>
            </method>
            <javadoc line="712">
                Transform a region.
                  &lt;p&gt;Applying a transform to a region consist in applying the
                  transform to all the hyperplanes of the underlying BSP tree and
                  of the boundary (and also to the sub-hyperplanes embedded in
                  these hyperplanes) and to the barycenter. The instance is not
                  modified, a new instance is built.&lt;/p&gt;                
                <param>
                    transform transform to apply                    
                </param>
                <return>
                    a new region, resulting from the application of the
                      transform to the instance                    
                </return>
            </javadoc>
            <method name="applyTransform" type="AbstractRegion&lt;S,T&gt;" line="722">
                <params>
                    <param name="transform" type="Transform&lt;S,T&gt;"/>
                </params>
            </method>
            <javadoc line="726">
                Recursively transform an inside/outside BSP-tree.                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    transform transform to apply                    
                </param>
                <return>
                    a new tree                    
                </return>
            </javadoc>
            <method name="recurseTransform" type="BSPTree&lt;S&gt;" line="732">
                <params>
                    <param name="node" type="BSPTree&lt;S&gt;"/>
                    <param name="transform" type="Transform&lt;S,T&gt;"/>
                </params>
                <scope line="734"/>
                <declaration name="sub" type="SubHyperplane&amp;lt;S&amp;gt;" line="738"/>
                <declaration name="tSub" type="SubHyperplane&amp;lt;S&amp;gt;" line="739"/>
                <declaration name="attribute" type="BoundaryAttribute&amp;lt;S&amp;gt;" line="740"/>
                <scope line="741">
                    <declaration name="tPO" type="SubHyperplane&amp;lt;S&amp;gt;" line="742"/>
                    <declaration name="tPI" type="SubHyperplane&amp;lt;S&amp;gt;" line="744"/>
                </scope>
            </method>
        </class>
    </source>