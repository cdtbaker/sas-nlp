<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning">
        <import package="org.apache.commons.math3.geometry.Space"/>
        <class name="AbstractSubHyperplane" line="3">
            <type_params>
                <type_param name="S"/>
                <type_param name="T"/>
            </type_params>
            <implements interface="SubHyperplane">
                <type_params>
                    <type_param name="S"/>
                </type_params>
            </implements>
            <javadoc line="3">
                This class implements the dimension-independent parts of {@link SubHyperplane}.
                  &lt;p&gt;sub-hyperplanes are obtained when parts of an {@link Hyperplane hyperplane} are chopped off by other hyperplanes that
                  intersect it. The remaining part is a convex region. Such objects
                  appear in {@link BSPTree BSP trees} as the intersection of a cut
                  hyperplane with the convex region which it splits, the chopping
                  hyperplanes are the cut hyperplanes closer to the tree root.&lt;/p&gt;                
                <param>
                    <S>
                      Type of the embedding space.                    
                </param>
                <param>
                    <T>
                      Type of the embedded sub-space.                    
                </param>
                <version>
                    $Id: AbstractSubHyperplane.java 1421448 2012-12-13 19:45:57Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="18"/>
            <javadoc line="18">
                Underlying hyperplane.                
            </javadoc>
            <declaration name="remainingRegion" type="Region&lt;T&gt;" line="22"/>
            <javadoc line="22">
                Remaining region of the hyperplane.                
            </javadoc>
            <javadoc line="26">
                Build a sub-hyperplane from an hyperplane and a region.                
                <param>
                    hyperplane underlying hyperplane                    
                </param>
                <param>
                    remainingRegion remaining region of the hyperplane                    
                </param>
            </javadoc>
            <method name="AbstractSubHyperplane" type="constructor" line="31">
                <params>
                    <param name="hyperplane" type="Hyperplane<S>"/>
                    <param name="remainingRegion" type="Region<T>"/>
                </params>
            </method>
            <method name="buildNew" type="AbstractSubHyperplane<S,T>" line="35"/>
            <javadoc line="35">
                Build a sub-hyperplane from an hyperplane and a region.                
                <param>
                    hyper underlying hyperplane                    
                </param>
                <param>
                    remaining remaining region of the hyperplane                    
                </param>
                <return>
                    a new sub-hyperplane                    
                </return>
            </javadoc>
            <javadoc line="42">
                {@inheritDoc}                
            </javadoc>
            <method name="copySelf" type="AbstractSubHyperplane<S,T>" line="45"/>
            <javadoc line="48">
                Get the underlying hyperplane.                
                <return>
                    underlying hyperplane                    
                </return>
            </javadoc>
            <method name="getHyperplane" type="Hyperplane<S>" line="52"/>
            <javadoc line="55">
                Get the remaining region of the hyperplane.
                  &lt;p&gt;The returned region is expressed in the canonical hyperplane
                  frame and has the hyperplane dimension. For example a chopped
                  hyperplane in the 3D euclidean is a 2D plane and the
                  corresponding region is a convex 2D polygon.&lt;/p&gt;                
                <return>
                    remaining region of the hyperplane                    
                </return>
            </javadoc>
            <method name="getRemainingRegion" type="Region<T>" line="63"/>
            <javadoc line="66">
                {@inheritDoc}                
            </javadoc>
            <method name="getSize" type="double" line="69"/>
            <javadoc line="72">
                {@inheritDoc}                
            </javadoc>
            <method name="reunite" type="AbstractSubHyperplane<S,T>" line="75">
                <params>
                    <param name="other" type="SubHyperplane<S>"/>
                </params>
                <declaration name="o" type="AbstractSubHyperplane&lt;S,T&gt;" line="76"/>
            </method>
            <javadoc line="79">
                Apply a transform to the instance.
                  &lt;p&gt;The instance must be a (D-1)-dimension sub-hyperplane with
                  respect to the transform &lt;em&gt;not&lt;/em&gt; a (D-2)-dimension
                  sub-hyperplane the transform knows how to transform by
                  itself. The transform will consist in transforming first the
                  hyperplane and then the all region using the various methods
                  provided by the transform.&lt;/p&gt;                
                <param>
                    transform D-dimension transform to apply                    
                </param>
                <return>
                    the transformed instance                    
                </return>
            </javadoc>
            <method name="applyTransform" type="AbstractSubHyperplane<S,T>" line="90">
                <params>
                    <param name="transform" type="Transform<S,T>"/>
                </params>
                <declaration name="tHyperplane" type="Hyperplane&lt;S&gt;" line="91"/>
                <declaration name="tTree" type="BSPTree&lt;T&gt;" line="92"/>
            </method>
            <javadoc line="95">
                Recursively transform a BSP-tree from a sub-hyperplane.                
                <param>
                    node current BSP tree node                    
                </param>
                <param>
                    transformed image of the instance hyperplane by the transform                    
                </param>
                <param>
                    transform transform to apply                    
                </param>
                <return>
                    a new tree                    
                </return>
            </javadoc>
            <method name="recurseTransform" type="BSPTree<T>" line="102">
                <params>
                    <param name="node" type="BSPTree<T>"/>
                    <param name="transformed" type="Hyperplane<S>"/>
                    <param name="transform" type="Transform<S,T>"/>
                </params>
                <scope line="103"/>
                <declaration name="attribute" type="BoundaryAttribute&lt;T&gt;" line="106"/>
                <scope line="107">
                    <declaration name="tPO" type="SubHyperplane&lt;T&gt;" line="108"/>
                    <declaration name="tPI" type="SubHyperplane&lt;T&gt;" line="109"/>
                </scope>
            </method>
            <method name="side" type="Side" line="114"/>
            <javadoc line="114">
                {@inheritDoc}                
            </javadoc>
            <method name="split" type="SplitSubHyperplane<S>" line="118"/>
            <javadoc line="118">
                {@inheritDoc}                
            </javadoc>
            <javadoc line="122">
                {@inheritDoc}                
            </javadoc>
            <method name="isEmpty" type="boolean" line="125"/>
        </class>
    </source>