<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.transform">
        <import package="java.io.Serializable"/>
        <import package="java.lang.reflect.Array"/>
        <import package="org.apache.commons.math3.analysis.FunctionUtils"/>
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.complex.Complex"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.util.ArithmeticUtils"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathArrays"/>
        <class name="FastFourierTransformer" line="33">
            <implements interface="Serializable"/>
            <javadoc line="33">
                Implements the Fast Fourier Transform for transformation of one-dimensional
                  real or complex data sets. For reference, see &lt;em&gt;Applied Numerical Linear
                  Algebra&lt;/em&gt;, ISBN 0898713897, chapter 6.
                  &lt;p&gt;
                  There are several variants of the discrete Fourier transform, with various
                  normalization conventions, which are specified by the parameter{@link DftNormalization}.
                  &lt;p&gt;
                  The current implementation of the discrete Fourier transform as a fast
                  Fourier transform requires the length of the data set to be a power of 2.
                  This greatly simplifies and speeds up the code. Users can pad the data with
                  zeros to meet this requirement. There are other flavors of FFT, for
                  reference, see S. Winograd,
                  &lt;i&gt;On computing the discrete Fourier transform&lt;/i&gt;, Mathematics of
                  Computation, 32 (1978), 175 - 199.                
                <see>
                    DftNormalization                    
                </see>
                <version>
                    $Id: FastFourierTransformer.java 1385310 2012-09-16 16:32:10Z tn $                    
                </version>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="56"/>
            <javadoc line="56">
                Serializable version identifier.                
            </javadoc>
            <declaration name="W_SUB_N_R" type="double[]" line="59"/>
            <javadoc line="59">
                {@code W_SUB_N_R[i]} is the real part of{@code exp(- 2  i  pi / n)}:{@code W_SUB_N_R[i] = cos(2  pi/ n)}, where {@code n = 2^i}.                
            </javadoc>
            <declaration name="W_SUB_N_I" type="double[]" line="82"/>
            <javadoc line="82">
                {@code W_SUB_N_I[i]} is the imaginary part of{@code exp(- 2  i  pi / n)}:{@code W_SUB_N_I[i] = -sin(2  pi/ n)}, where {@code n = 2^i}.                
            </javadoc>
            <declaration name="normalization" type="DftNormalization" line="105"/>
            <javadoc line="105">
                The type of DFT to be performed.                
            </javadoc>
            <javadoc line="108">
                Creates a new instance of this class, with various normalization
                  conventions.                
                <param>
                    normalization the type of normalization to be applied to the
                      transformed data                    
                </param>
            </javadoc>
            <method name="FastFourierTransformer" type="constructor" line="115">
                <params>
                    <param name="normalization" type="DftNormalization"/>
                </params>
            </method>
            <javadoc line="119">
                Performs identical index bit reversal shuffles on two arrays of identical
                  size. Each element in the array is swapped with another element based on
                  the bit-reversal of the index. For example, in an array with length 16,
                  item at binary index 0011 (decimal 3) would be swapped with the item at
                  binary index 1100 (decimal 12).                
                <param>
                    a the first array to be shuffled                    
                </param>
                <param>
                    b the second array to be shuffled                    
                </param>
            </javadoc>
            <method name="bitReversalShuffle2" type="void" line="129">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="b" type="double[]"/>
                </params>
                <comment line="137">
                    swap indices i &amp; j                    
                </comment>
                <declaration name="n" type="int" line="130"/>
                <declaration name="halfOfN" type="int" line="132"/>
                <declaration name="j" type="int" line="134"/>
                <scope line="135">
                    <scope line="136">
                        <declaration name="temp" type="double" line="138"/>
                    </scope>
                    <declaration name="k" type="int" line="147"/>
                    <scope line="148"/>
                </scope>
            </method>
            <javadoc line="156">
                Applies the proper normalization to the specified transformed data.                
                <param>
                    dataRI the unscaled transformed data                    
                </param>
                <param>
                    normalization the normalization to be applied                    
                </param>
                <param>
                    type the type of transform (forward, inverse) which resulted in the specified data                    
                </param>
            </javadoc>
            <method name="normalizeTransformedData" type="void" line="164">
                <params>
                    <param name="dataRI" type="double[][]"/>
                    <param name="normalization" type="DftNormalization"/>
                    <param name="type" type="TransformType"/>
                </params>
                <comment line="189">
                    This should never occur in normal conditions. However this
                     clause has been added as a safeguard if other types of
                     normalizations are ever implemented, and the corresponding
                     test is forgotten in the present switch.                    
                </comment>
                <declaration name="dataR" type="double[]" line="166"/>
                <declaration name="dataI" type="double[]" line="167"/>
                <declaration name="n" type="int" line="168"/>
                <scope line="173">
                    <declaration name="scaleFactor" type="double" line="174"/>
                    <scope line="175"/>
                </scope>
                <declaration name="scaleFactor" type="double" line="182"/>
                <scope line="183"/>
            </method>
            <javadoc line="199">
                Computes the standard transform of the specified complex data. The
                  computation is done in place. The input data is laid out as follows
                  &lt;ul&gt;
                  &lt;li&gt;{@code dataRI[0][i]} is the real part of the {@code i}-th data point,&lt;/li&gt;
                  &lt;li&gt;{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data point.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    dataRI the two dimensional array of real and imaginary parts of the data                    
                </param>
                <param>
                    normalization the normalization to be applied to the transformed data                    
                </param>
                <param>
                    type the type of transform (forward, inverse) to be performed                    
                </param>
                <throws>
                    DimensionMismatchException if the number of rows of the specified
                      array is not two, or the array is not rectangular                    
                </throws>
                <throws>
                    MathIllegalArgumentException if the number of data points is not
                      a power of two                    
                </throws>
            </javadoc>
            <method name="transformInPlace" type="void" line="216">
                <params>
                    <param name="dataRI" type="double[][]"/>
                    <param name="normalization" type="DftNormalization"/>
                    <param name="type" type="TransformType"/>
                </params>
                <comment line="242">
                    X_0 = x_0 + x_1                    
                </comment>
                <comment line="245">
                    X_1 = x_0 - x_1                    
                </comment>
                <comment line="255">
                    Do 4-term DFT.                    
                </comment>
                <comment line="271">
                    4-term DFT                    
                </comment>
                <comment line="272">
                    X_0 = x_0 + x_1 + x_2 + x_3                    
                </comment>
                <comment line="275">
                    X_1 = x_0 - x_2 + j * (x_3 - x_1)                    
                </comment>
                <comment line="278">
                    X_2 = x_0 - x_1 + x_2 - x_3                    
                </comment>
                <comment line="281">
                    X_3 = x_0 - x_2 + j * (x_1 - x_3)                    
                </comment>
                <comment line="300">
                    4-term DFT                    
                </comment>
                <comment line="301">
                    X_0 = x_0 + x_1 + x_2 + x_3                    
                </comment>
                <comment line="304">
                    X_1 = x_0 - x_2 + j * (x_3 - x_1)                    
                </comment>
                <comment line="307">
                    X_2 = x_0 - x_1 + x_2 - x_3                    
                </comment>
                <comment line="310">
                    X_3 = x_0 - x_2 + j * (x_1 - x_3)                    
                </comment>
                <comment line="327">
                    Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).                    
                </comment>
                <comment line="340">
                    dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr                    
                </comment>
                <comment line="343">
                    dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr                    
                </comment>
                <comment line="347">
                    WsubN0ToR *= WsubN0R                    
                </comment>
                <scope line="218"/>
                <declaration name="dataR" type="double[]" line="221"/>
                <declaration name="dataI" type="double[]" line="222"/>
                <scope line="223"/>
                <declaration name="n" type="int" line="227"/>
                <scope line="228"/>
                <scope line="234"/>
                <scope line="236">
                    <declaration name="srcR0" type="double" line="237"/>
                    <declaration name="srcI0" type="double" line="238"/>
                    <declaration name="srcR1" type="double" line="239"/>
                    <declaration name="srcI1" type="double" line="240"/>
                </scope>
                <scope line="256">
                    <scope line="257">
                        <declaration name="i1" type="int" line="258"/>
                        <declaration name="i2" type="int" line="259"/>
                        <declaration name="i3" type="int" line="260"/>
                        <declaration name="srcR0" type="double" line="262"/>
                        <declaration name="srcI0" type="double" line="263"/>
                        <declaration name="srcR1" type="double" line="264"/>
                        <declaration name="srcI1" type="double" line="265"/>
                        <declaration name="srcR2" type="double" line="266"/>
                        <declaration name="srcI2" type="double" line="267"/>
                        <declaration name="srcR3" type="double" line="268"/>
                        <declaration name="srcI3" type="double" line="269"/>
                    </scope>
                </scope>
                <scope line="285">
                    <scope line="286">
                        <declaration name="i1" type="int" line="287"/>
                        <declaration name="i2" type="int" line="288"/>
                        <declaration name="i3" type="int" line="289"/>
                        <declaration name="srcR0" type="double" line="291"/>
                        <declaration name="srcI0" type="double" line="292"/>
                        <declaration name="srcR1" type="double" line="293"/>
                        <declaration name="srcI1" type="double" line="294"/>
                        <declaration name="srcR2" type="double" line="295"/>
                        <declaration name="srcI2" type="double" line="296"/>
                        <declaration name="srcR3" type="double" line="297"/>
                        <declaration name="srcI3" type="double" line="298"/>
                    </scope>
                </scope>
                <declaration name="lastN0" type="int" line="316"/>
                <declaration name="lastLogN0" type="int" line="317"/>
                <scope line="318">
                    <declaration name="n0" type="int" line="319"/>
                    <declaration name="logN0" type="int" line="320"/>
                    <declaration name="wSubN0R" type="double" line="321"/>
                    <declaration name="wSubN0I" type="double" line="322"/>
                    <scope line="323"/>
                    <scope line="328">
                        <declaration name="destOddStartIndex" type="int" line="329"/>
                        <declaration name="wSubN0ToRR" type="double" line="331"/>
                        <declaration name="wSubN0ToRI" type="double" line="332"/>
                        <scope line="334">
                            <declaration name="grR" type="double" line="335"/>
                            <declaration name="grI" type="double" line="336"/>
                            <declaration name="hrR" type="double" line="337"/>
                            <declaration name="hrI" type="double" line="338"/>
                            <declaration name="nextWsubN0ToRR" type="double" line="348"/>
                            <declaration name="nextWsubN0ToRI" type="double" line="349"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="362">
                Returns the (forward, inverse) transform of the specified real data set.                
                <param>
                    f the real data array to be transformed                    
                </param>
                <param>
                    type the type of transform (forward, inverse) to be performed                    
                </param>
                <return>
                    the complex transformed array                    
                </return>
                <throws>
                    MathIllegalArgumentException if the length of the data array is not a power of two                    
                </throws>
            </javadoc>
            <method name="transform" type="Complex[]" line="370">
                <params>
                    <param name="f" type="double[]"/>
                    <param name="type" type="TransformType"/>
                </params>
                <declaration name="dataRI" type="double[][]" line="371"/>
            </method>
            <javadoc line="380">
                Returns the (forward, inverse) transform of the specified real function,
                  sampled on the specified interval.                
                <param>
                    f the function to be sampled and transformed                    
                </param>
                <param>
                    min the (inclusive) lower bound for the interval                    
                </param>
                <param>
                    max the (exclusive) upper bound for the interval                    
                </param>
                <param>
                    n the number of sample points                    
                </param>
                <param>
                    type the type of transform (forward, inverse) to be performed                    
                </param>
                <return>
                    the complex transformed array                    
                </return>
                <throws>
                    org.apache.commons.math3.exception.NumberIsTooLargeExceptionif the lower bound is greater than, or equal to the upper bound                    
                </throws>
                <throws>
                    org.apache.commons.math3.exception.NotStrictlyPositiveExceptionif the number of sample points {@code n} is negative                    
                </throws>
                <throws>
                    MathIllegalArgumentException if the number of sample points{@code n} is not a power of two                    
                </throws>
            </javadoc>
            <method name="transform" type="Complex[]" line="399">
                <params>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="n" type="int"/>
                    <param name="type" type="TransformType"/>
                </params>
                <declaration name="data" type="double[]" line="401"/>
            </method>
            <javadoc line="405">
                Returns the (forward, inverse) transform of the specified complex data set.                
                <param>
                    f the complex data array to be transformed                    
                </param>
                <param>
                    type the type of transform (forward, inverse) to be performed                    
                </param>
                <return>
                    the complex transformed array                    
                </return>
                <throws>
                    MathIllegalArgumentException if the length of the data array is not a power of two                    
                </throws>
            </javadoc>
            <method name="transform" type="Complex[]" line="413">
                <params>
                    <param name="f" type="Complex[]"/>
                    <param name="type" type="TransformType"/>
                </params>
                <declaration name="dataRI" type="double[][]" line="414"/>
            </method>
            <javadoc line="421">
                Performs a multi-dimensional Fourier transform on a given array. Use{@link #transform(Complex[],TransformType)} in a row-column
                  implementation in any number of dimensions with
                  O(N&amp;times;log(N)) complexity with
                  N = n&lt;sub&gt;1&lt;/sub&gt; &amp;times; n&lt;sub&gt;2&lt;/sub&gt; &amp;times;n&lt;sub&gt;3&lt;/sub&gt; &amp;times; ...
                  &amp;times; n&lt;sub&gt;d&lt;/sub&gt;, where n&lt;sub&gt;k&lt;/sub&gt; is the number of elements in
                  dimension k, and d is the total number of dimensions.                
                <param>
                    mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}                    
                </param>
                <param>
                    type the type of transform (forward, inverse) to be performed                    
                </param>
                <return>
                    transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}                    
                </return>
                <throws>
                    IllegalArgumentException if any dimension is not a power of two                    
                </throws>
                <deprecated>
                    see MATH-736                    
                </deprecated>
            </javadoc>
            <method name="mdfft" type="Object" line="437">
                <params>
                    <param name="mdca" type="Object"/>
                    <param name="type" type="TransformType"/>
                </params>
                <comment line="441">
                    cycle through each dimension                    
                </comment>
                <declaration name="mdcm" type="MultiDimensionalComplexMatrix" line="438"/>
                <declaration name="dimensionSize" type="int[]" line="440"/>
                <scope line="442"/>
            </method>
            <javadoc line="448">
                Performs one dimension of a multi-dimensional Fourier transform.                
                <param>
                    mdcm input matrix                    
                </param>
                <param>
                    type the type of transform (forward, inverse) to be performed                    
                </param>
                <param>
                    d index of the dimension to process                    
                </param>
                <param>
                    subVector recursion subvector                    
                </param>
                <throws>
                    IllegalArgumentException if any dimension is not a power of two                    
                </throws>
                <deprecated>
                    see MATH-736                    
                </deprecated>
            </javadoc>
            <method name="mdfft" type="void" line="460">
                <params>
                    <param name="mdcm" type="MultiDimensionalComplexMatrix"/>
                    <param name="type" type="TransformType"/>
                    <param name="d" type="int"/>
                    <param name="subVector" type="int[]"/>
                </params>
                <comment line="463">
                    if done                    
                </comment>
                <comment line="467">
                    fft along dimension d                    
                </comment>
                <comment line="482">
                    value is not important once the recursion is done.                    
                </comment>
                <comment line="483">
                    then an fft will be applied along the dimension d.                    
                </comment>
                <comment line="489">
                    further split along the next dimension                    
                </comment>
                <declaration name="dimensionSize" type="int[]" line="462"/>
                <scope line="464">
                    <declaration name="temp" type="Complex[]" line="465"/>
                    <scope line="466"/>
                    <scope line="474"/>
                </scope>
                <scope line="478">
                    <declaration name="vector" type="int[]" line="479"/>
                    <scope line="481"/>
                    <scope line="486">
                        <scope line="487"/>
                    </scope>
                </scope>
            </method>
            <class name="MultiDimensionalComplexMatrix" line="496">
                <implements interface="Cloneable"/>
                <javadoc line="496">
                    Complex matrix implementation. Not designed for synchronized access may
                      eventually be replaced by jsr-83 of the java community process
                      http://jcp.org/en/jsr/detail?id=83
                      may require additional exception throws for other basic requirements.                    
                    <deprecated>
                        see MATH-736                        
                    </deprecated>
                </javadoc>
                <declaration name="dimensionSize" type="int[]" line="508"/>
                <javadoc line="508">
                    Size in all dimensions.                    
                </javadoc>
                <declaration name="multiDimensionalComplexArray" type="Object" line="511"/>
                <javadoc line="511">
                    Storage array.                    
                </javadoc>
                <javadoc line="514">
                    Simple constructor.                    
                    <param>
                        multiDimensionalComplexArray array containing the matrix
                          elements                        
                    </param>
                </javadoc>
                <method name="MultiDimensionalComplexMatrix" type="constructor" line="521">
                    <params>
                        <param name="multiDimensionalComplexArray" type="Object"/>
                    </params>
                    <comment line="525">
                        count dimensions                        
                    </comment>
                    <comment line="534">
                        allocate array with exact count                        
                    </comment>
                    <comment line="537">
                        fill array                        
                    </comment>
                    <declaration name="numOfDimensions" type="int" line="526"/>
                    <scope line="528">
                        <declaration name="array" type="Object[]" line="529"/>
                    </scope>
                    <scope line="540">
                        <declaration name="array" type="Object[]" line="541"/>
                    </scope>
                </method>
                <javadoc line="548">
                    Get a matrix element.                    
                    <param>
                        vector indices of the element                        
                    </param>
                    <return>
                        matrix element                        
                    </return>
                    <exception>
                        DimensionMismatchException if dimensions do not match                        
                    </exception>
                </javadoc>
                <method name="get" type="Complex" line="556">
                    <params>
                        <param name="vector" type="int"/>
                    </params>
                    <scope line="558">
                        <scope line="559"/>
                    </scope>
                    <scope line="566"/>
                    <declaration name="lastDimension" type="Object" line="572"/>
                    <scope line="574"/>
                </method>
                <javadoc line="580">
                    Set a matrix element.                    
                    <param>
                        magnitude magnitude of the element                        
                    </param>
                    <param>
                        vector indices of the element                        
                    </param>
                    <return>
                        the previous value                        
                    </return>
                    <exception>
                        DimensionMismatchException if dimensions do not match                        
                    </exception>
                </javadoc>
                <method name="set" type="Complex" line="589">
                    <params>
                        <param name="magnitude" type="Complex"/>
                        <param name="vector" type="int"/>
                    </params>
                    <scope line="591">
                        <scope line="592"/>
                    </scope>
                    <scope line="599"/>
                    <declaration name="lastDimension" type="Object[]" line="605"/>
                    <scope line="606"/>
                    <declaration name="lastValue" type="Complex" line="610"/>
                </method>
                <javadoc line="616">
                    Get the size in all dimensions.                    
                    <return>
                        size in all dimensions                        
                    </return>
                </javadoc>
                <method name="getDimensionSizes" type="int[]" line="621"/>
                <javadoc line="625">
                    Get the underlying storage array.                    
                    <return>
                        underlying storage array                        
                    </return>
                </javadoc>
                <method name="getArray" type="Object" line="630"/>
                <javadoc line="634">
                    {@inheritDoc}                    
                </javadoc>
                <method name="clone" type="Object" line="636">
                    <declaration name="mdcm" type="MultiDimensionalComplexMatrix" line="637"/>
                </method>
                <javadoc line="644">
                    Copy contents of current array into mdcm.                    
                    <param>
                        mdcm array where to copy data                        
                    </param>
                </javadoc>
                <method name="clone" type="void" line="649">
                    <params>
                        <param name="mdcm" type="MultiDimensionalComplexMatrix"/>
                    </params>
                    <declaration name="vector" type="int[]" line="651"/>
                    <declaration name="size" type="int" line="652"/>
                    <scope line="653"/>
                    <declaration name="vectorList" type="int[][]" line="656"/>
                    <scope line="657">
                        <scope line="660">
                            <scope line="662"/>
                            <scope line="664"/>
                        </scope>
                    </scope>
                    <scope line="670"/>
                </method>
            </class>
        </class>
    </source>