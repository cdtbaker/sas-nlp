<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.ode.events">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.analysis.solvers.AllowedSolution"/>
        <import package="org.apache.commons.math3.analysis.solvers.BracketedUnivariateSolver"/>
        <import package="org.apache.commons.math3.analysis.solvers.PegasusSolver"/>
        <import package="org.apache.commons.math3.analysis.solvers.UnivariateSolver"/>
        <import package="org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils"/>
        <import package="org.apache.commons.math3.exception.MaxCountExceededException"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.ode.EquationsMapper"/>
        <import package="org.apache.commons.math3.ode.ExpandableStatefulODE"/>
        <import package="org.apache.commons.math3.ode.sampling.StepInterpolator"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="EventState" line="33">
            <javadoc line="33">
                This class handles the state for one {@link EventHandlerevent handler} during integration steps.
                  &lt;p&gt;Each time the integrator proposes a step, the event handler
                  switching function should be checked. This class handles the state
                  of one handler during one integration step, with references to the
                  state at the end of the preceding step. This information is used to
                  decide if the handler should trigger an event or not during the
                  proposed step.&lt;/p&gt;                
                <version>
                    $Id: EventState.java 1558462 2014-01-15 16:48:25Z luc $                    
                </version>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="handler" type="EventHandler" line="48"/>
            <javadoc line="48">
                Event handler.                
            </javadoc>
            <declaration name="maxCheckInterval" type="double" line="51"/>
            <javadoc line="51">
                Maximal time interval between events handler checks.                
            </javadoc>
            <declaration name="convergence" type="double" line="54"/>
            <javadoc line="54">
                Convergence threshold for event localization.                
            </javadoc>
            <declaration name="maxIterationCount" type="int" line="57"/>
            <javadoc line="57">
                Upper limit in the iteration count for event localization.                
            </javadoc>
            <declaration name="expandable" type="ExpandableStatefulODE" line="60"/>
            <javadoc line="60">
                Equation being integrated.                
            </javadoc>
            <declaration name="t0" type="double" line="63"/>
            <javadoc line="63">
                Time at the beginning of the step.                
            </javadoc>
            <declaration name="g0" type="double" line="66"/>
            <javadoc line="66">
                Value of the events handler at the beginning of the step.                
            </javadoc>
            <declaration name="g0Positive" type="boolean" line="69"/>
            <javadoc line="69">
                Simulated sign of g0 (we cheat when crossing events).                
            </javadoc>
            <declaration name="pendingEvent" type="boolean" line="72"/>
            <javadoc line="72">
                Indicator of event expected during the step.                
            </javadoc>
            <declaration name="pendingEventTime" type="double" line="75"/>
            <javadoc line="75">
                Occurrence time of the pending event.                
            </javadoc>
            <declaration name="previousEventTime" type="double" line="78"/>
            <javadoc line="78">
                Occurrence time of the previous event.                
            </javadoc>
            <declaration name="forward" type="boolean" line="81"/>
            <javadoc line="81">
                Integration direction.                
            </javadoc>
            <declaration name="increasing" type="boolean" line="84"/>
            <javadoc line="84">
                Variation direction around pending event.
                  (this is considered with respect to the integration direction)                
            </javadoc>
            <declaration name="nextAction" type="EventHandler.Action" line="89"/>
            <javadoc line="89">
                Next action indicator.                
            </javadoc>
            <declaration name="solver" type="UnivariateSolver" line="92"/>
            <javadoc line="92">
                Root-finding algorithm to use to detect state events.                
            </javadoc>
            <javadoc line="95">
                Simple constructor.                
                <param>
                    handler event handler                    
                </param>
                <param>
                    maxCheckInterval maximal time interval between switching
                      function checks (this interval prevents missing sign changes in
                      case the integration steps becomes very large)                    
                </param>
                <param>
                    convergence convergence threshold in the event time search                    
                </param>
                <param>
                    maxIterationCount upper limit of the iteration count in
                      the event time search                    
                </param>
                <param>
                    solver Root-finding algorithm to use to detect state events                    
                </param>
            </javadoc>
            <method name="EventState" type="constructor" line="107">
                <params>
                    <param name="handler" type="EventHandler"/>
                    <param name="maxCheckInterval" type="double"/>
                    <param name="convergence" type="double"/>
                    <param name="maxIterationCount" type="int"/>
                    <param name="solver" type="UnivariateSolver"/>
                </params>
                <comment line="115">
                    some dummy values ...                    
                </comment>
            </method>
            <javadoc line="127">
                Get the underlying event handler.                
                <return>
                    underlying event handler                    
                </return>
            </javadoc>
            <method name="getEventHandler" type="EventHandler" line="130"/>
            <javadoc line="134">
                Set the equation.                
                <param>
                    expandable equation being integrated                    
                </param>
            </javadoc>
            <method name="setExpandable" type="void" line="137">
                <params>
                    <param name="expandable" type="ExpandableStatefulODE"/>
                </params>
            </method>
            <javadoc line="141">
                Get the maximal time interval between events handler checks.                
                <return>
                    maximal time interval between events handler checks                    
                </return>
            </javadoc>
            <method name="getMaxCheckInterval" type="double" line="144"/>
            <javadoc line="148">
                Get the convergence threshold for event localization.                
                <return>
                    convergence threshold for event localization                    
                </return>
            </javadoc>
            <method name="getConvergence" type="double" line="151"/>
            <javadoc line="155">
                Get the upper limit in the iteration count for event localization.                
                <return>
                    upper limit in the iteration count for event localization                    
                </return>
            </javadoc>
            <method name="getMaxIterationCount" type="int" line="158"/>
            <javadoc line="162">
                Reinitialize the beginning of the step.                
                <param>
                    interpolator valid for the current step                    
                </param>
                <exception>
                    MaxCountExceededException if the interpolator throws one because
                      the number of functions evaluations is exceeded                    
                </exception>
            </javadoc>
            <method name="reinitializeBegin" type="void" line="168">
                <params>
                    <param name="interpolator" type="StepInterpolator"/>
                </params>
                <comment line="175">
                    excerpt from MATH-421 issue:
                     If an ODE solver is setup with an EventHandler that return STOP
                     when the even is triggered, the integrator stops (which is exactly
                     the expected behavior). If however the user wants to restart the
                     solver from the final state reached at the event with the same
                     configuration (expecting the event to be triggered again at a
                     later time), then the integrator may fail to start. It can get stuck
                     at the previous event. The use case for the bug MATH-421 is fairly
                     general, so events occurring exactly at start in the first step should
                     be ignored.                    
                </comment>
                <comment line="186">
                    extremely rare case: there is a zero EXACTLY at interval start
                     we will use the sign slightly after step beginning to force ignoring this zero                    
                </comment>
                <scope line="173">
                    <declaration name="epsilon" type="double" line="187"/>
                    <declaration name="tStart" type="double" line="189"/>
                </scope>
            </method>
            <javadoc line="197">
                Get the complete state (primary and secondary).                
                <param>
                    interpolator interpolator to use                    
                </param>
                <return>
                    complete state                    
                </return>
            </javadoc>
            <method name="getCompleteState" type="double[]" line="201">
                <params>
                    <param name="interpolator" type="StepInterpolator"/>
                </params>
                <declaration name="complete" type="double[]" line="203"/>
                <declaration name="index" type="int" line="207"/>
                <scope line="208"/>
            </method>
            <javadoc line="217">
                Evaluate the impact of the proposed step on the event handler.                
                <param>
                    interpolator step interpolator for the proposed step                    
                </param>
                <return>
                    true if the event handler triggers an event before
                      the end of the proposed step                    
                </return>
                <exception>
                    MaxCountExceededException if the interpolator throws one because
                      the number of functions evaluations is exceeded                    
                </exception>
                <exception>
                    NoBracketingException if the event cannot be bracketed                    
                </exception>
            </javadoc>
            <method name="evaluateStep" type="boolean" line="226">
                <params>
                    <param name="interpolator" type="StepInterpolator"/>
                </params>
                <comment line="234">
                    we cannot do anything on such a small step, don&apos;t trigger any events                    
                </comment>
                <comment line="255">
                    evaluate handler value at the end of the substep                    
                </comment>
                <comment line="260">
                    check events occurrence                    
                </comment>
                <comment line="262">
                    there is a sign change: an event is expected during this step                    
                </comment>
                <comment line="264">
                    variation direction, with respect to the integration direction                    
                </comment>
                <comment line="267">
                    find the event time making sure we select a solution just at or past the exact root                    
                </comment>
                <comment line="293">
                    we have either found nothing or found (again ?) a past event,
                     retry the substep excluding this value, and taking care to have the
                     required sign in case the g function is noisy around its zero and
                     crosses the axis several times                    
                </comment>
                <comment line="308">
                    no sign change: there is no event for now                    
                </comment>
                <comment line="314">
                    no sign change: there is no event for now                    
                </comment>
                <comment line="321">
                    no event during the whole step                    
                </comment>
                <scope line="228">
                    <declaration name="t1" type="double" line="230"/>
                    <declaration name="dt" type="double" line="231"/>
                    <scope line="232"/>
                    <declaration name="n" type="int" line="236"/>
                    <declaration name="h" type="double" line="237"/>
                    <anonymous_class line="239">
                        <method name="value" type="double" line="240">
                            <params>
                                <param name="t" type="double"/>
                            </params>
                            <scope line="241"/>
                            <scope line="244"/>
                        </method>
                    </anonymous_class>
                    <declaration name="f" type="UnivariateFunction" line="239"/>
                    <declaration name="ta" type="double" line="250"/>
                    <declaration name="ga" type="double" line="251"/>
                    <scope line="252">
                        <declaration name="tb" type="double" line="255"/>
                        <declaration name="gb" type="double" line="257"/>
                        <scope line="260">
                            <declaration name="root" type="double" line="267"/>
                            <scope line="268">
                                <declaration name="bracketing" type="BracketedUnivariateSolver&amp;lt;UnivariateFunction&amp;gt;" line="269"/>
                            </scope>
                            <scope line="275">
                                <declaration name="baseRoot" type="double" line="276"/>
                                <declaration name="remainingEval" type="int" line="279"/>
                                <declaration name="bracketing" type="BracketedUnivariateSolver&amp;lt;UnivariateFunction&amp;gt;" line="280"/>
                            </scope>
                            <scope line="291">
                                <scope line="296"/>
                            </scope>
                            <scope line="302"/>
                            <scope line="306"/>
                        </scope>
                        <scope line="312"/>
                    </scope>
                </scope>
                <scope line="325"/>
            </method>
            <javadoc line="331">
                Get the occurrence time of the event triggered in the current step.                
                <return>
                    occurrence time of the event triggered in the current
                      step or infinity if no events are triggered                    
                </return>
            </javadoc>
            <method name="getEventTime" type="double" line="335"/>
            <javadoc line="341">
                Acknowledge the fact the step has been accepted by the integrator.                
                <param>
                    t value of the independent &lt;i&gt;time&lt;/i&gt; variable at the
                      end of the step                    
                </param>
                <param>
                    y array containing the current value of the state vector
                      at the end of the step                    
                </param>
            </javadoc>
            <method name="stepAccepted" type="void" line="347">
                <params>
                    <param name="t" type="double"/>
                    <param name="y" type="double[]"/>
                </params>
                <comment line="354">
                    force the sign to its value &quot;just after the event&quot;                    
                </comment>
                <scope line="352"/>
                <scope line="357"/>
            </method>
            <javadoc line="363">
                Check if the integration should be stopped at the end of the
                  current step.                
                <return>
                    true if the integration should be stopped                    
                </return>
            </javadoc>
            <method name="stop" type="boolean" line="367"/>
            <javadoc line="371">
                Let the event handler reset the state if it wants.                
                <param>
                    t value of the independent &lt;i&gt;time&lt;/i&gt; variable at the
                      beginning of the next step                    
                </param>
                <param>
                    y array were to put the desired state vector at the beginning
                      of the next step                    
                </param>
                <return>
                    true if the integrator should reset the derivatives too                    
                </return>
            </javadoc>
            <method name="reset" type="boolean" line="378">
                <params>
                    <param name="t" type="double"/>
                    <param name="y" type="double[]"/>
                </params>
                <scope line="380"/>
                <scope line="384"/>
            </method>
            <class name="LocalMaxCountExceededException" line="395">
                <extends class="RuntimeException"/>
                <javadoc line="395">
                    Local wrapper to propagate exceptions.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="398"/>
                <javadoc line="398">
                    Serializable UID.                    
                </javadoc>
                <declaration name="wrapped" type="MaxCountExceededException" line="401"/>
                <javadoc line="401">
                    Wrapped exception.                    
                </javadoc>
                <javadoc line="404">
                    Simple constructor.                    
                    <param>
                        exception exception to wrap                        
                    </param>
                </javadoc>
                <method name="LocalMaxCountExceededException" type="constructor" line="407">
                    <params>
                        <param name="exception" type="MaxCountExceededException"/>
                    </params>
                </method>
                <javadoc line="411">
                    Get the wrapped exception.                    
                    <return>
                        wrapped exception                        
                    </return>
                </javadoc>
                <method name="getException" type="MaxCountExceededException" line="414"/>
            </class>
        </class>
    </source>