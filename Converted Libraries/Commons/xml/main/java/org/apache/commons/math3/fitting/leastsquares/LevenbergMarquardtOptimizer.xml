<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.fitting.leastsquares">
        <import package="java.util.Arrays"/>
        <import package="org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem.Evaluation"/>
        <import package="org.apache.commons.math3.linear.ArrayRealVector"/>
        <import package="org.apache.commons.math3.linear.RealMatrix"/>
        <import package="org.apache.commons.math3.exception.ConvergenceException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.util.Incrementor"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="LevenbergMarquardtOptimizer" line="32">
            <comment line="117">
                                
            </comment>
            <implements interface="LeastSquaresOptimizer"/>
            <javadoc line="32">
                This class solves a least-squares problem using the Levenberg-Marquardt
                  algorithm.
                  &lt;p&gt;This implementation &lt;em&gt;should&lt;/em&gt; work even for over-determined systems
                  (i.e. systems having more point than equations). Over-determined systems
                  are solved by ignoring the point which have the smallest impact according
                  to their jacobian column norm. Only the rank of the matrix and some loop bounds
                  are changed to implement this.&lt;/p&gt;
                  &lt;p&gt;The resolution engine is a simple translation of the MINPACK &lt;a
                  href=&quot;http://www.netlib.org/minpack/lmder.f&quot;&gt;lmder&lt;/a&gt; routine with minor
                  changes. The changes include the over-determined resolution, the use of
                  inherited convergence checker and the Q.R. decomposition which has been
                  rewritten following the algorithm described in the
                  P. Lascaux and R. Theodor book &lt;i&gt;Analyse num&amp;eacute;rique matricielle
                  appliqu&amp;eacute;e &amp;agrave; l&apos;art de l&apos;ing&amp;eacute;nieur&lt;/i&gt;, Masson 1986.&lt;/p&gt;
                  &lt;p&gt;The authors of the original fortran version are:
                  &lt;ul&gt;
                  &lt;li&gt;Argonne National Laboratory. MINPACK project. March 1980&lt;/li&gt;
                  &lt;li&gt;Burton S. Garbow&lt;/li&gt;
                  &lt;li&gt;Kenneth E. Hillstrom&lt;/li&gt;
                  &lt;li&gt;Jorge J. More&lt;/li&gt;
                  &lt;/ul&gt;
                  The redistribution policy for MINPACK is available &lt;a
                  href=&quot;http://www.netlib.org/minpack/disclaimer&quot;&gt;here&lt;/a&gt;, for convenience, it
                  is reproduced below.&lt;/p&gt;
                  &lt;table border=&quot;0&quot; width=&quot;80%&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;#E0E0E0&quot;&gt;
                  &lt;tr&gt;&lt;td&gt;
                  Minpack Copyright Notice (1999) University of Chicago.
                  All rights reserved
                  &lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;
                  Redistribution and use in source and binary forms, with or without
                  modification, are permitted provided that the following conditions
                  are met:
                  &lt;ol&gt;
                  &lt;li&gt;Redistributions of source code must retain the above copyright
                  notice, this list of conditions and the following disclaimer.&lt;/li&gt;
                  &lt;li&gt;Redistributions in binary form must reproduce the above
                  copyright notice, this list of conditions and the following
                  disclaimer in the documentation and/or other materials provided
                  with the distribution.&lt;/li&gt;
                  &lt;li&gt;The end-user documentation included with the redistribution, if any,
                  must include the following acknowledgment:
                  &lt;code&gt;This product includes software developed by the University of
                  Chicago, as Operator of Argonne National Laboratory.&lt;/code&gt;
                  Alternately, this acknowledgment may appear in the software itself,
                  if and wherever such third-party acknowledgments normally appear.&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED &quot;AS IS&quot;
                  WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
                  UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
                  THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
                  IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
                  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
                  OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
                  OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
                  USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
                  THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
                  DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
                  UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
                  BE CORRECTED.&lt;/strong&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
                  HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
                  ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
                  INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
                  ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
                  PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
                  SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
                  (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
                  EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
                  POSSIBILITY OF SUCH LOSS OR DAMAGES.&lt;/strong&gt;&lt;/li&gt;
                  &lt;ol&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;                
                <version>
                    $Id: LevenbergMarquardtOptimizer.java 1573308 2014-03-02 14:02:50Z luc $                    
                </version>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <declaration name="TWO_EPS" type="double" line="113"/>
            <javadoc line="113">
                Twice the &quot;epsilon machine&quot;.                
            </javadoc>
            <declaration name="initialStepBoundFactor" type="double" line="117"/>
            <javadoc line="117">
                Positive input variable used in determining the initial step bound.                
            </javadoc>
            <declaration name="costRelativeTolerance" type="double" line="119"/>
            <javadoc line="119">
                Desired relative error in the sum of squares.                
            </javadoc>
            <declaration name="parRelativeTolerance" type="double" line="121"/>
            <javadoc line="121">
                Desired relative error in the approximate solution parameters.                
            </javadoc>
            <declaration name="orthoTolerance" type="double" line="123"/>
            <javadoc line="123">
                Desired max cosine on the orthogonality between the function vector
                  and the columns of the jacobian.                
            </javadoc>
            <declaration name="qrRankingThreshold" type="double" line="126"/>
            <javadoc line="126">
                Threshold for QR ranking.                
            </javadoc>
            <javadoc line="129">
                Default constructor.
                  &lt;p&gt;
                  The default values for the algorithm settings are:
                  &lt;ul&gt;
                  &lt;li&gt;Initial step bound factor: 100&lt;/li&gt;
                  &lt;li&gt;Cost relative tolerance: 1e-10&lt;/li&gt;
                  &lt;li&gt;Parameters relative tolerance: 1e-10&lt;/li&gt;
                  &lt;li&gt;Orthogonality tolerance: 1e-10&lt;/li&gt;
                  &lt;li&gt;QR ranking threshold: {@link Precision#SAFE_MIN}&lt;/li&gt;
                  &lt;/ul&gt;                
            </javadoc>
            <method name="LevenbergMarquardtOptimizer" type="constructor" line="140"/>
            <javadoc line="144">
                Construct an instance with all parameters specified.                
                <param>
                    initialStepBoundFactor initial step bound factor                    
                </param>
                <param>
                    costRelativeTolerance  cost relative tolerance                    
                </param>
                <param>
                    parRelativeTolerance   parameters relative tolerance                    
                </param>
                <param>
                    orthoTolerance         orthogonality tolerance                    
                </param>
                <param>
                    qrRankingThreshold     threshold in the QR decomposition. Columns with a 2
                      norm less than this threshold are considered to be
                      all 0s.                    
                </param>
            </javadoc>
            <method name="LevenbergMarquardtOptimizer" type="constructor" line="160">
                <params>
                    <param name="initialStepBoundFactor" type="double"/>
                    <param name="costRelativeTolerance" type="double"/>
                    <param name="parRelativeTolerance" type="double"/>
                    <param name="orthoTolerance" type="double"/>
                    <param name="qrRankingThreshold" type="double"/>
                </params>
            </method>
            <javadoc line="168">
                @param newInitialStepBoundFactor Positive input variable used in
                  determining the initial step bound. This bound is set to the
                  product of initialStepBoundFactor and the euclidean norm of{@code diag  x} if non-zero, or else to {@code newInitialStepBoundFactor}itself. In most cases factor should lie in the interval{@code (0.1, 100.0)}. {@code 100} is a generally recommended value.
                  of the matrix is reduced.                
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withInitialStepBoundFactor" type="LevenbergMarquardtOptimizer" line="178">
                <params>
                    <param name="newInitialStepBoundFactor" type="double"/>
                </params>
            </method>
            <javadoc line="187">
                @param newCostRelativeTolerance Desired relative error in the sum of squares.                
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withCostRelativeTolerance" type="LevenbergMarquardtOptimizer" line="191">
                <params>
                    <param name="newCostRelativeTolerance" type="double"/>
                </params>
            </method>
            <javadoc line="200">
                @param newParRelativeTolerance Desired relative error in the approximate solution
                  parameters.                
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withParameterRelativeTolerance" type="LevenbergMarquardtOptimizer" line="205">
                <params>
                    <param name="newParRelativeTolerance" type="double"/>
                </params>
            </method>
            <javadoc line="214">
                Modifies the given parameter.                
                <param>
                    newOrthoTolerance Desired max cosine on the orthogonality between
                      the function vector and the columns of the Jacobian.                    
                </param>
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withOrthoTolerance" type="LevenbergMarquardtOptimizer" line="221">
                <params>
                    <param name="newOrthoTolerance" type="double"/>
                </params>
            </method>
            <javadoc line="230">
                @param newQRRankingThreshold Desired threshold for QR ranking.
                  If the squared norm of a column vector is smaller or equal to this
                  threshold during QR decomposition, it is considered to be a zero vector
                  and hence the rank of the matrix is reduced.                
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withRankingThreshold" type="LevenbergMarquardtOptimizer" line="237">
                <params>
                    <param name="newQRRankingThreshold" type="double"/>
                </params>
            </method>
            <javadoc line="246">
                Gets the value of a tuning parameter.                
                <see>
                    #withInitialStepBoundFactor(double)                    
                </see>
                <return>
                    the parameter&apos;s value.                    
                </return>
            </javadoc>
            <method name="getInitialStepBoundFactor" type="double" line="252"/>
            <javadoc line="256">
                Gets the value of a tuning parameter.                
                <see>
                    #withCostRelativeTolerance(double)                    
                </see>
                <return>
                    the parameter&apos;s value.                    
                </return>
            </javadoc>
            <method name="getCostRelativeTolerance" type="double" line="262"/>
            <javadoc line="266">
                Gets the value of a tuning parameter.                
                <see>
                    #withParameterRelativeTolerance(double)                    
                </see>
                <return>
                    the parameter&apos;s value.                    
                </return>
            </javadoc>
            <method name="getParameterRelativeTolerance" type="double" line="272"/>
            <javadoc line="276">
                Gets the value of a tuning parameter.                
                <see>
                    #withOrthoTolerance(double)                    
                </see>
                <return>
                    the parameter&apos;s value.                    
                </return>
            </javadoc>
            <method name="getOrthoTolerance" type="double" line="282"/>
            <javadoc line="286">
                Gets the value of a tuning parameter.                
                <see>
                    #withRankingThreshold(double)                    
                </see>
                <return>
                    the parameter&apos;s value.                    
                </return>
            </javadoc>
            <method name="getRankingThreshold" type="double" line="292"/>
            <javadoc line="296">
                {@inheritDoc}                
            </javadoc>
            <method name="optimize" type="Optimum" line="297">
                <params>
                    <param name="problem" type="LeastSquaresProblem"/>
                </params>
                <comment line="299">
                    pull in relevant data from the problem as locals                    
                </comment>
                <comment line="300">
                    Number of observed data.                    
                </comment>
                <comment line="301">
                    Number of parameters.                    
                </comment>
                <comment line="303">
                    counters                    
                </comment>
                <comment line="306">
                    convergence criterion                    
                </comment>
                <comment line="310">
                    arrays shared with the other private methods                    
                </comment>
                <comment line="312">
                                        
                </comment>
                <comment line="314">
                                        
                </comment>
                <comment line="317">
                    local point                    
                </comment>
                <comment line="329">
                    Evaluate the function at the starting point and calculate its norm.                    
                </comment>
                <comment line="331">
                    value will be reassigned in the loop                    
                </comment>
                <comment line="336">
                    Outer loop.                    
                </comment>
                <comment line="343">
                    QR decomposition of the jacobian matrix                    
                </comment>
                <comment line="351">
                    residuals already have weights applied                    
                </comment>
                <comment line="357">
                    compute Qt.res                    
                </comment>
                <comment line="360">
                    now we don&apos;t need Q anymore,
                     so let jacobian contain the R matrix with its diagonal elements                    
                </comment>
                <comment line="368">
                    scale the point according to the norms of the columns
                     of the initial jacobian                    
                </comment>
                <comment line="382">
                    initialize the step bound delta                    
                </comment>
                <comment line="386">
                    check orthogonality between function vector and jacobian columns                    
                </comment>
                <comment line="402">
                    Convergence has been reached.                    
                </comment>
                <comment line="409">
                    rescale if necessary                    
                </comment>
                <comment line="414">
                    Inner loop.                    
                </comment>
                <comment line="417">
                    save the state                    
                </comment>
                <comment line="427">
                    determine the Levenberg-Marquardt parameter                    
                </comment>
                <comment line="432">
                    compute the new point and the norm of the evolution direction                    
                </comment>
                <comment line="442">
                    on the first iteration, adjust the initial step bound.                    
                </comment>
                <comment line="447">
                    Evaluate the function at x + p and calculate its norm.                    
                </comment>
                <comment line="453">
                    compute the scaled actual reduction                    
                </comment>
                <comment line="460">
                    compute the scaled predicted reduction
                     and the scaled directional derivative                    
                </comment>
                <comment line="480">
                    ratio of the actual to the predicted reduction                    
                </comment>
                <comment line="483">
                    update the step bound                    
                </comment>
                <comment line="497">
                    test for successful iteration.                    
                </comment>
                <comment line="499">
                    successful iteration, update the norm                    
                </comment>
                <comment line="508">
                    tests for convergence.                    
                </comment>
                <comment line="513">
                    failed iteration, reset the previous values                    
                </comment>
                <comment line="522">
                    Reset &quot;current&quot; to previous values.                    
                </comment>
                <comment line="526">
                    Default convergence criteria.                    
                </comment>
                <comment line="534">
                    tests for termination and stringent tolerances                    
                </comment>
                <declaration name="nR" type="int" line="299"/>
                <declaration name="nC" type="int" line="300"/>
                <declaration name="currentPoint" type="double[]" line="301"/>
                <declaration name="iterationCounter" type="Incrementor" line="303"/>
                <declaration name="evaluationCounter" type="Incrementor" line="304"/>
                <declaration name="checker" type="ConvergenceChecker&amp;lt;Evaluation&amp;gt;" line="306"/>
                <declaration name="solvedCols" type="int" line="310"/>
                <declaration name="lmDir" type="double[]" line="312"/>
                <declaration name="lmPar" type="double" line="314"/>
                <declaration name="delta" type="double" line="317"/>
                <declaration name="xNorm" type="double" line="318"/>
                <declaration name="diag" type="double[]" line="319"/>
                <declaration name="oldX" type="double[]" line="320"/>
                <declaration name="oldRes" type="double[]" line="321"/>
                <declaration name="qtf" type="double[]" line="322"/>
                <declaration name="work1" type="double[]" line="323"/>
                <declaration name="work2" type="double[]" line="324"/>
                <declaration name="work3" type="double[]" line="325"/>
                <declaration name="current" type="Evaluation" line="331"/>
                <declaration name="currentResiduals" type="double[]" line="332"/>
                <declaration name="currentCost" type="double" line="333"/>
                <declaration name="firstIteration" type="boolean" line="336"/>
                <scope line="337">
                    <declaration name="previous" type="Evaluation" line="340"/>
                    <declaration name="internalData" type="InternalData" line="343"/>
                    <declaration name="weightedJacobian" type="double[][]" line="345"/>
                    <declaration name="permutation" type="int[]" line="346"/>
                    <declaration name="diagR" type="double[]" line="347"/>
                    <declaration name="jacNorm" type="double[]" line="348"/>
                    <declaration name="weightedResidual" type="double[]" line="351"/>
                    <scope line="352"/>
                    <scope line="361">
                        <declaration name="pk" type="int" line="362"/>
                    </scope>
                    <scope line="366">
                        <scope line="370">
                            <declaration name="dk" type="double" line="371"/>
                            <scope line="372"/>
                            <declaration name="xk" type="double" line="375"/>
                        </scope>
                    </scope>
                    <declaration name="maxCosine" type="double" line="386"/>
                    <scope line="387">
                        <scope line="388">
                            <declaration name="pj" type="int" line="389"/>
                            <declaration name="s" type="double" line="390"/>
                            <scope line="391">
                                <declaration name="sum" type="double" line="392"/>
                                <scope line="393"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="400"/>
                    <scope line="409"/>
                    <scope line="414">
                        <scope line="417">
                            <declaration name="pj" type="int" line="418"/>
                        </scope>
                        <declaration name="previousCost" type="double" line="421"/>
                        <declaration name="tmpVec" type="double[]" line="422"/>
                        <declaration name="lmNorm" type="double" line="432"/>
                        <scope line="433">
                            <declaration name="pj" type="int" line="434"/>
                            <declaration name="s" type="double" line="437"/>
                        </scope>
                        <scope line="442"/>
                        <declaration name="actRed" type="double" line="453"/>
                        <scope line="454">
                            <declaration name="r" type="double" line="455"/>
                        </scope>
                        <scope line="461">
                            <declaration name="pj" type="int" line="462"/>
                            <declaration name="dirJ" type="double" line="463"/>
                            <scope line="465"/>
                        </scope>
                        <declaration name="coeff1" type="double" line="469"/>
                        <scope line="470"/>
                        <declaration name="pc2" type="double" line="473"/>
                        <declaration name="coeff2" type="double" line="475"/>
                        <declaration name="preRed" type="double" line="476"/>
                        <declaration name="dirDer" type="double" line="477"/>
                        <scope line="483">
                            <declaration name="tmp" type="double" line="484"/>
                            <scope line="486"/>
                        </scope>
                        <scope line="491"/>
                        <scope line="497">
                            <scope line="501">
                                <declaration name="xK" type="double" line="502"/>
                            </scope>
                            <scope line="508"/>
                        </scope>
                        <scope line="511">
                            <scope line="514">
                                <declaration name="pj" type="int" line="515"/>
                            </scope>
                        </scope>
                        <scope line="529"/>
                        <scope line="536"/>
                        <scope line="539"/>
                        <scope line="542"/>
                    </scope>
                </scope>
            </method>
            <class name="InternalData" line="550">
                <javadoc line="550">
                    Holds internal data.
                      This structure was created so that all optimizer fields can be &quot;final&quot;.
                      Code should be further refactored in order to not pass around arguments
                      that will modified in-place (cf. &quot;work&quot; arrays).                    
                </javadoc>
                <declaration name="weightedJacobian" type="double[][]" line="557"/>
                <javadoc line="557">
                    Weighted Jacobian.                    
                </javadoc>
                <declaration name="permutation" type="int[]" line="559"/>
                <javadoc line="559">
                    Columns permutation array.                    
                </javadoc>
                <declaration name="rank" type="int" line="561"/>
                <javadoc line="561">
                    Rank of the Jacobian matrix.                    
                </javadoc>
                <declaration name="diagR" type="double[]" line="563"/>
                <javadoc line="563">
                    Diagonal elements of the R matrix in the QR decomposition.                    
                </javadoc>
                <declaration name="jacNorm" type="double[]" line="565"/>
                <javadoc line="565">
                    Norms of the columns of the jacobian matrix.                    
                </javadoc>
                <declaration name="beta" type="double[]" line="567"/>
                <javadoc line="567">
                    Coefficients of the Householder transforms vectors.                    
                </javadoc>
                <javadoc line="570">
                    @param weightedJacobian Weighted Jacobian.                    
                    <param>
                        permutation Columns permutation array.                        
                    </param>
                    <param>
                        rank Rank of the Jacobian matrix.                        
                    </param>
                    <param>
                        diagR Diagonal elements of the R matrix in the QR decomposition.                        
                    </param>
                    <param>
                        jacNorm Norms of the columns of the jacobian matrix.                        
                    </param>
                    <param>
                        beta Coefficients of the Householder transforms vectors.                        
                    </param>
                </javadoc>
                <method name="InternalData" type="constructor" line="583">
                    <params>
                        <param name="weightedJacobian" type="double[][]"/>
                        <param name="permutation" type="int[]"/>
                        <param name="rank" type="int"/>
                        <param name="diagR" type="double[]"/>
                        <param name="jacNorm" type="double[]"/>
                        <param name="beta" type="double[]"/>
                    </params>
                </method>
            </class>
            <javadoc line="593">
                Determines the Levenberg-Marquardt parameter.
                  &lt;p&gt;This implementation is a translation in Java of the MINPACK
                  &lt;a href=&quot;http://www.netlib.org/minpack/lmpar.f&quot;&gt;lmpar&lt;/a&gt;
                  routine.&lt;/p&gt;
                  &lt;p&gt;This method sets the lmPar and lmDir attributes.&lt;/p&gt;
                  &lt;p&gt;The authors of the original fortran function are:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;Argonne National Laboratory. MINPACK project. March 1980&lt;/li&gt;
                  &lt;li&gt;Burton  S. Garbow&lt;/li&gt;
                  &lt;li&gt;Kenneth E. Hillstrom&lt;/li&gt;
                  &lt;li&gt;Jorge   J. More&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Luc Maisonobe did the Java translation.&lt;/p&gt;                
                <param>
                    qy Array containing qTy.                    
                </param>
                <param>
                    delta Upper bound on the euclidean norm of diagR  lmDir.                    
                </param>
                <param>
                    diag Diagonal matrix.                    
                </param>
                <param>
                    internalData Data (modified in-place in this method).                    
                </param>
                <param>
                    solvedCols Number of solved point.                    
                </param>
                <param>
                    work1 work array                    
                </param>
                <param>
                    work2 work array                    
                </param>
                <param>
                    work3 work array                    
                </param>
                <param>
                    lmDir the &quot;returned&quot; LM direction will be stored in this array.                    
                </param>
                <param>
                    lmPar the value of the LM parameter from the previous iteration.                    
                </param>
                <return>
                    the new LM parameter                    
                </return>
            </javadoc>
            <method name="determineLMParameter" type="double" line="624">
                <params>
                    <param name="qy" type="double[]"/>
                    <param name="delta" type="double"/>
                    <param name="diag" type="double[]"/>
                    <param name="internalData" type="InternalData"/>
                    <param name="solvedCols" type="int"/>
                    <param name="work1" type="double[]"/>
                    <param name="work2" type="double[]"/>
                    <param name="work3" type="double[]"/>
                    <param name="lmDir" type="double[]"/>
                    <param name="lmPar" type="double"/>
                </params>
                <comment line="633">
                    compute and store in x the gauss-newton direction, if the
                     jacobian is rank-deficient, obtain a least squares solution                    
                </comment>
                <comment line="650">
                    evaluate the function at the origin, and test
                     for acceptance of the Gauss-Newton direction                    
                </comment>
                <comment line="666">
                    if the jacobian is not rank deficient, the Newton step provides
                     a lower bound, parl, for the zero of the function,
                     otherwise set this bound to zero                    
                </comment>
                <comment line="690">
                    calculate an upper bound, paru, for the zero of the function                    
                </comment>
                <comment line="707">
                    if the input par lies outside of the interval (parl,paru),
                     set par to the closer endpoint                    
                </comment>
                <comment line="716">
                    evaluate the function at the current value of lmPar                    
                </comment>
                <comment line="738">
                    if the function is small enough, accept the current value
                     of lmPar, also test for the exceptional cases where parl is zero                    
                </comment>
                <comment line="747">
                    compute the Newton correction                    
                </comment>
                <comment line="767">
                    depending on the sign of the function, update parl or paru.                    
                </comment>
                <comment line="774">
                    compute an improved estimate for lmPar                    
                </comment>
                <declaration name="weightedJacobian" type="double[][]" line="625"/>
                <declaration name="permutation" type="int[]" line="626"/>
                <declaration name="rank" type="int" line="627"/>
                <declaration name="diagR" type="double[]" line="628"/>
                <declaration name="nC" type="int" line="630"/>
                <scope line="634"/>
                <scope line="637"/>
                <scope line="640">
                    <declaration name="pk" type="int" line="641"/>
                    <declaration name="ypk" type="double" line="642"/>
                    <scope line="643"/>
                </scope>
                <declaration name="dxNorm" type="double" line="651"/>
                <scope line="652">
                    <declaration name="pj" type="int" line="653"/>
                    <declaration name="s" type="double" line="654"/>
                </scope>
                <declaration name="fp" type="double" line="659"/>
                <scope line="660"/>
                <declaration name="sum2" type="double" line="668"/>
                <declaration name="parl" type="double" line="669"/>
                <scope line="670">
                    <scope line="671">
                        <declaration name="pj" type="int" line="672"/>
                    </scope>
                    <scope line="676">
                        <declaration name="pj" type="int" line="677"/>
                        <declaration name="sum" type="double" line="678"/>
                        <scope line="679"/>
                        <declaration name="s" type="double" line="682"/>
                    </scope>
                </scope>
                <scope line="691">
                    <declaration name="pj" type="int" line="692"/>
                    <declaration name="sum" type="double" line="693"/>
                    <scope line="694"/>
                </scope>
                <declaration name="gNorm" type="double" line="700"/>
                <declaration name="paru" type="double" line="701"/>
                <scope line="702"/>
                <scope line="709"/>
                <scope line="713">
                    <scope line="716"/>
                    <declaration name="sPar" type="double" line="719"/>
                    <scope line="720">
                        <declaration name="pj" type="int" line="721"/>
                    </scope>
                    <scope line="727">
                        <declaration name="pj" type="int" line="728"/>
                        <declaration name="s" type="double" line="729"/>
                    </scope>
                    <declaration name="previousFP" type="double" line="734"/>
                    <scope line="742"/>
                    <scope line="747">
                        <declaration name="pj" type="int" line="748"/>
                    </scope>
                    <scope line="751">
                        <declaration name="pj" type="int" line="752"/>
                        <declaration name="tmp" type="double" line="754"/>
                        <scope line="755"/>
                    </scope>
                    <scope line="760">
                        <declaration name="s" type="double" line="761"/>
                    </scope>
                    <declaration name="correction" type="double" line="764"/>
                    <scope line="767"/>
                    <scope line="769"/>
                </scope>
            </method>
            <javadoc line="780">
                Solve ax = b and dx = 0 in the least squares sense.
                  &lt;p&gt;This implementation is a translation in Java of the MINPACK
                  &lt;a href=&quot;http://www.netlib.org/minpack/qrsolv.f&quot;&gt;qrsolv&lt;/a&gt;
                  routine.&lt;/p&gt;
                  &lt;p&gt;This method sets the lmDir and lmDiag attributes.&lt;/p&gt;
                  &lt;p&gt;The authors of the original fortran function are:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;Argonne National Laboratory. MINPACK project. March 1980&lt;/li&gt;
                  &lt;li&gt;Burton  S. Garbow&lt;/li&gt;
                  &lt;li&gt;Kenneth E. Hillstrom&lt;/li&gt;
                  &lt;li&gt;Jorge   J. More&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Luc Maisonobe did the Java translation.&lt;/p&gt;                
                <param>
                    qy array containing qTy                    
                </param>
                <param>
                    diag diagonal matrix                    
                </param>
                <param>
                    lmDiag diagonal elements associated with lmDir                    
                </param>
                <param>
                    internalData Data (modified in-place in this method).                    
                </param>
                <param>
                    solvedCols Number of sloved point.                    
                </param>
                <param>
                    work work array                    
                </param>
                <param>
                    lmDir the &quot;returned&quot; LM direction is stored in this array                    
                </param>
            </javadoc>
            <method name="determineLMDirection" type="void" line="808">
                <params>
                    <param name="qy" type="double[]"/>
                    <param name="diag" type="double[]"/>
                    <param name="lmDiag" type="double[]"/>
                    <param name="internalData" type="InternalData"/>
                    <param name="solvedCols" type="int"/>
                    <param name="work" type="double[]"/>
                    <param name="lmDir" type="double[]"/>
                </params>
                <comment line="814">
                    copy R and Qty to preserve input and initialize s
                      in particular, save the diagonal elements of R in lmDir                    
                </comment>
                <comment line="825">
                    eliminate the diagonal matrix d using a Givens rotation                    
                </comment>
                <comment line="828">
                    prepare the row of d to be eliminated, locating the
                     diagonal element using p from the Q.R. factorization                    
                </comment>
                <comment line="837">
                    the transformations to eliminate the row of d
                     modify only a single element of Qty
                     beyond the first n, which is initially zero.                    
                </comment>
                <comment line="844">
                    determine a Givens rotation which eliminates the
                     appropriate element in the current row of d                    
                </comment>
                <comment line="861">
                    compute the modified diagonal element of R and
                     the modified element of (Qty,0)                    
                </comment>
                <comment line="868">
                    accumulate the tranformation in the row of s                    
                </comment>
                <comment line="878">
                    store the diagonal element of s and restore
                     the corresponding diagonal element of R                    
                </comment>
                <comment line="884">
                    solve the triangular system for z, if the system is
                     singular, then obtain a least squares solution                    
                </comment>
                <comment line="906">
                    permute the components of z back to components of lmDir                    
                </comment>
                <declaration name="permutation" type="int[]" line="809"/>
                <declaration name="weightedJacobian" type="double[][]" line="810"/>
                <declaration name="diagR" type="double[]" line="811"/>
                <scope line="815">
                    <declaration name="pj" type="int" line="816"/>
                    <scope line="817"/>
                </scope>
                <scope line="825">
                    <declaration name="pj" type="int" line="829"/>
                    <declaration name="dpj" type="double" line="830"/>
                    <scope line="831"/>
                    <declaration name="qtbpj" type="double" line="839"/>
                    <scope line="840">
                        <declaration name="pk" type="int" line="841"/>
                        <scope line="845">
                            <declaration name="sin" type="double" line="847"/>
                            <declaration name="cos" type="double" line="848"/>
                            <declaration name="rkk" type="double" line="849"/>
                            <scope line="850">
                                <declaration name="cotan" type="double" line="851"/>
                            </scope>
                            <scope line="854">
                                <declaration name="tan" type="double" line="855"/>
                            </scope>
                            <declaration name="temp" type="double" line="863"/>
                            <scope line="868">
                                <declaration name="rik" type="double" line="869"/>
                                <declaration name="temp2" type="double" line="870"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <declaration name="nSing" type="int" line="885"/>
                <scope line="886">
                    <scope line="887"/>
                    <scope line="890"/>
                </scope>
                <scope line="894">
                    <scope line="895">
                        <declaration name="pj" type="int" line="896"/>
                        <declaration name="sum" type="double" line="897"/>
                        <scope line="898"/>
                    </scope>
                </scope>
                <scope line="906"/>
            </method>
            <javadoc line="911">
                Decompose a matrix A as A.P = Q.R using Householder transforms.
                  &lt;p&gt;As suggested in the P. Lascaux and R. Theodor book
                  &lt;i&gt;Analyse num&amp;eacute;rique matricielle appliqu&amp;eacute;e &amp;agrave;
                  l&apos;art de l&apos;ing&amp;eacute;nieur&lt;/i&gt; (Masson, 1986), instead of representing
                  the Householder transforms with u&lt;sub&gt;k&lt;/sub&gt; unit vectors such that:
                  &lt;pre&gt;
                  H&lt;sub&gt;k&lt;/sub&gt; = I - 2u&lt;sub&gt;k&lt;/sub&gt;.u&lt;sub&gt;k&lt;/sub&gt;&lt;sup&gt;t&lt;/sup&gt;
                  &lt;/pre&gt;
                  we use &lt;sub&gt;k&lt;/sub&gt; non-unit vectors such that:
                  &lt;pre&gt;
                  H&lt;sub&gt;k&lt;/sub&gt; = I - beta&lt;sub&gt;k&lt;/sub&gt;v&lt;sub&gt;k&lt;/sub&gt;.v&lt;sub&gt;k&lt;/sub&gt;&lt;sup&gt;t&lt;/sup&gt;
                  &lt;/pre&gt;
                  where v&lt;sub&gt;k&lt;/sub&gt; = a&lt;sub&gt;k&lt;/sub&gt; - alpha&lt;sub&gt;k&lt;/sub&gt; e&lt;sub&gt;k&lt;/sub&gt;.
                  The beta&lt;sub&gt;k&lt;/sub&gt; coefficients are provided upon exit as recomputing
                  them from the v&lt;sub&gt;k&lt;/sub&gt; vectors would be costly.&lt;/p&gt;
                  &lt;p&gt;This decomposition handles rank deficient cases since the tranformations
                  are performed in non-increasing columns norms order thanks to columns
                  pivoting. The diagonal elements of the R matrix are therefore also in
                  non-increasing absolute values order.&lt;/p&gt;                
                <param>
                    jacobian Weighted Jacobian matrix at the current point.                    
                </param>
                <param>
                    solvedCols Number of solved point.                    
                </param>
                <return>
                    data used in other methods of this class.                    
                </return>
                <throws>
                    ConvergenceException if the decomposition cannot be performed.                    
                </throws>
            </javadoc>
            <method name="qrDecomposition" type="InternalData" line="938">
                <params>
                    <param name="jacobian" type="RealMatrix"/>
                    <param name="solvedCols" type="int"/>
                </params>
                <comment line="940">
                    Code in this class assumes that the weighted Jacobian is -(W^(1/2) J),
                     hence the multiplication by -1.                    
                </comment>
                <comment line="952">
                    initializations                    
                </comment>
                <comment line="963">
                    transform the matrix column after column                    
                </comment>
                <comment line="966">
                    select the column with the greatest norm on active components                    
                </comment>
                <comment line="991">
                    choose alpha such that Hk.u = alpha ek                    
                </comment>
                <comment line="997">
                    transform the current column                    
                </comment>
                <comment line="1001">
                    transform the remaining columns                    
                </comment>
                <declaration name="weightedJacobian" type="double[][]" line="941"/>
                <declaration name="nR" type="int" line="943"/>
                <declaration name="nC" type="int" line="944"/>
                <declaration name="permutation" type="int[]" line="946"/>
                <declaration name="diagR" type="double[]" line="947"/>
                <declaration name="jacNorm" type="double[]" line="948"/>
                <declaration name="beta" type="double[]" line="949"/>
                <scope line="952">
                    <declaration name="norm2" type="double" line="954"/>
                    <scope line="955">
                        <declaration name="akk" type="double" line="956"/>
                    </scope>
                </scope>
                <scope line="963">
                    <declaration name="nextColumn" type="int" line="966"/>
                    <declaration name="ak2" type="double" line="967"/>
                    <scope line="968">
                        <declaration name="norm2" type="double" line="969"/>
                        <scope line="970">
                            <declaration name="aki" type="double" line="971"/>
                        </scope>
                        <scope line="974"/>
                        <scope line="978"/>
                    </scope>
                    <scope line="983"/>
                    <declaration name="pk" type="int" line="986"/>
                    <declaration name="akk" type="double" line="991"/>
                    <declaration name="alpha" type="double" line="992"/>
                    <declaration name="betak" type="double" line="993"/>
                    <scope line="1001">
                        <declaration name="gamma" type="double" line="1002"/>
                        <scope line="1003"/>
                        <scope line="1007"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1016">
                Compute the product Qt.y for some Q.R. decomposition.                
                <param>
                    y vector to multiply (will be overwritten with the result)                    
                </param>
                <param>
                    internalData Data.                    
                </param>
            </javadoc>
            <method name="qTy" type="void" line="1023">
                <params>
                    <param name="y" type="double[]"/>
                    <param name="internalData" type="InternalData"/>
                </params>
                <declaration name="weightedJacobian" type="double[][]" line="1024"/>
                <declaration name="permutation" type="int[]" line="1025"/>
                <declaration name="beta" type="double[]" line="1026"/>
                <declaration name="nR" type="int" line="1028"/>
                <declaration name="nC" type="int" line="1029"/>
                <scope line="1031">
                    <declaration name="pk" type="int" line="1032"/>
                    <declaration name="gamma" type="double" line="1033"/>
                    <scope line="1034"/>
                    <scope line="1038"/>
                </scope>
            </method>
        </class>
    </source>