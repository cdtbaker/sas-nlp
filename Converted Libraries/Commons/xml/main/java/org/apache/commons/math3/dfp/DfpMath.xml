<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.dfp">
        <class name="DfpMath" line="2">
            <javadoc line="2">
                Mathematical routines for use with {@link Dfp}.
                  The constants are defined in {@link DfpField}                
                <version>
                    $Id: DfpMath.java 1462503 2013-03-29 15:48:27Z luc $                    
                </version>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <declaration name="POW_TRAP" type="String" line="9"/>
            <javadoc line="9">
                Name for traps triggered by pow.                
            </javadoc>
            <javadoc line="13">
                Private Constructor.                
            </javadoc>
            <method name="DfpMath" type="constructor" line="16"/>
            <javadoc line="18">
                Breaks a string representation up into two dfp&apos;s.
                  &lt;p&gt;The two dfp are such that the sum of them is equivalent
                  to the input string, but has higher precision than using a
                  single dfp. This is useful for improving accuracy of
                  exponentiation and critical multiplies.                
                <param>
                    field field to which the Dfp must belong                    
                </param>
                <param>
                    a string representation to split                    
                </param>
                <return>
                    an array of two {@link Dfp} which sum is a                    
                </return>
            </javadoc>
            <method name="split" type="Dfp[]" line="28">
                <params>
                    <param name="field" type="DfpField"/>
                    <param name="a" type="String"/>
                </params>
                <declaration name="result" type="Dfp" line="29"/>
                <declaration name="buf" type="char[]" line="30"/>
                <declaration name="leading" type="boolean" line="31"/>
                <declaration name="sp" type="int" line="32"/>
                <declaration name="sig" type="int" line="33"/>
                <scope line="35">
                    <scope line="37"/>
                    <scope line="40"/>
                    <scope line="44"/>
                    <scope line="48"/>
                </scope>
                <scope line="53">
                    <scope line="55"/>
                </scope>
            </method>
            <javadoc line="62">
                Splits a {@link Dfp} into 2 {@link Dfp}&apos;s such that their sum is equal to the input {@link Dfp}.                
                <param>
                    a number to split                    
                </param>
                <return>
                    two elements array containing the split number                    
                </return>
            </javadoc>
            <method name="split" type="Dfp[]" line="67">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="result" type="Dfp[]" line="68"/>
                <declaration name="shift" type="Dfp" line="69"/>
            </method>
            <javadoc line="74">
                Multiply two numbers that are split in to two pieces that are
                  meant to be added together.
                  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1
                  Store the first term in result0, the rest in result1                
                <param>
                    a first factor of the multiplication, in split form                    
                </param>
                <param>
                    b second factor of the multiplication, in split form                    
                </param>
                <return>
                    a &times; b, in split form                    
                </return>
            </javadoc>
            <method name="splitMult" type="Dfp[]" line="83">
                <params>
                    <param name="a" type="Dfp[]"/>
                    <param name="b" type="Dfp[]"/>
                </params>
                <declaration name="result" type="Dfp[]" line="84"/>
                <scope line="87"/>
            </method>
            <javadoc line="93">
                Divide two numbers that are split in to two pieces that are meant to be added together.
                  Inverse of split multiply above:
                  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c2+cd) )                
                <param>
                    a dividend, in split form                    
                </param>
                <param>
                    b divisor, in split form                    
                </param>
                <return>
                    a / b, in split form                    
                </return>
            </javadoc>
            <method name="splitDiv" type="Dfp[]" line="101">
                <params>
                    <param name="a" type="Dfp[]"/>
                    <param name="b" type="Dfp[]"/>
                </params>
                <declaration name="result" type="Dfp[]" line="102"/>
            </method>
            <javadoc line="109">
                Raise a split base to the a power.                
                <param>
                    base number to raise                    
                </param>
                <param>
                    a power                    
                </param>
                <return>
                    base<sup>a</sup>                    
                </return>
            </javadoc>
            <method name="splitPow" type="Dfp" line="115">
                <params>
                    <param name="base" type="Dfp[]"/>
                    <param name="a" type="int"/>
                </params>
                <declaration name="invert" type="boolean" line="116"/>
                <declaration name="r" type="Dfp[]" line="117"/>
                <declaration name="result" type="Dfp[]" line="118"/>
                <scope line="121"/>
                <scope line="124"/>
                <scope line="128">
                    <declaration name="trial" type="int" line="131"/>
                    <declaration name="prevtrial" type="int" line="132"/>
                    <scope line="133">
                        <scope line="136"/>
                    </scope>
                </scope>
                <scope line="147"/>
            </method>
            <javadoc line="152">
                Raises base to the power a by successive squaring.                
                <param>
                    base number to raise                    
                </param>
                <param>
                    a power                    
                </param>
                <return>
                    base<sup>a</sup>                    
                </return>
            </javadoc>
            <method name="pow" type="Dfp" line="158">
                <params>
                    <param name="base" type="Dfp"/>
                    <param name="a" type="int"/>
                </params>
                <declaration name="invert" type="boolean" line="159"/>
                <declaration name="result" type="Dfp" line="160"/>
                <scope line="161"/>
                <scope line="164"/>
                <scope line="168">
                    <declaration name="r" type="Dfp" line="169"/>
                    <declaration name="prevr" type="Dfp" line="170"/>
                    <declaration name="trial" type="int" line="171"/>
                    <declaration name="prevtrial" type="int" line="172"/>
                    <scope line="173"/>
                </scope>
                <scope line="186"/>
            </method>
            <javadoc line="191">
                Computes e to the given power.
                  a is broken into two parts, such that a = n+m  where n is an integer.
                  We use pow() to compute e&lt;sup&gt;n&lt;/sup&gt; and a Taylor series to compute
                  e&lt;sup&gt;m&lt;/sup&gt;.  We return e&lt;sup&gt;n&lt;/sup&gt; &amp;times; e&lt;sup&gt;m&lt;/sup&gt;                
                <param>
                    a power at which e should be raised                    
                </param>
                <return>
                    e<sup>a</sup>                    
                </return>
            </javadoc>
            <method name="exp" type="Dfp" line="199">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="inta" type="Dfp" line="200"/>
                <declaration name="fraca" type="Dfp" line="201"/>
                <declaration name="ia" type="int" line="202"/>
                <scope line="203"/>
                <scope line="206"/>
                <declaration name="einta" type="Dfp" line="209"/>
                <declaration name="efraca" type="Dfp" line="210"/>
            </method>
            <javadoc line="213">
                Computes e to the given power.
                  Where -1 &lt; a &lt; 1.  Use the classic Taylor series.  1 + x2/2! + x3/3! + x4/4!  ...                
                <param>
                    a power at which e should be raised                    
                </param>
                <return>
                    e<sup>a</sup>                    
                </return>
            </javadoc>
            <method name="expInternal" type="Dfp" line="219">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="y" type="Dfp" line="220"/>
                <declaration name="x" type="Dfp" line="221"/>
                <declaration name="fact" type="Dfp" line="222"/>
                <declaration name="py" type="Dfp" line="223"/>
                <scope line="224">
                    <scope line="228"/>
                </scope>
            </method>
            <javadoc line="235">
                Returns the natural logarithm of a.
                  a is first split into three parts such that  a = (10000^h)(2^j)k.
                  ln(a) is computed by ln(a) = ln(5)h + ln(2)(h+j) + ln(k)
                  k is in the range 2/3 &lt; k &lt;4/3 and is passed on to a series expansion.                
                <param>
                    a number from which logarithm is requested                    
                </param>
                <return>
                    log(a)                    
                </return>
            </javadoc>
            <method name="log" type="Dfp" line="243">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="lr" type="int" line="244"/>
                <declaration name="x" type="Dfp" line="245"/>
                <declaration name="ix" type="int" line="246"/>
                <declaration name="p2" type="int" line="247"/>
                <scope line="248"/>
                <scope line="252"/>
                <scope line="259"/>
                <declaration name="spx" type="Dfp[]" line="263"/>
                <declaration name="spy" type="Dfp[]" line="264"/>
                <scope line="269"/>
                <declaration name="spz" type="Dfp[]" line="274"/>
            </method>
            <javadoc line="287">
                Computes the natural log of a number between 0 and 2.
                  Let f(x) = ln(x),
                  We know that f&apos;(x) = 1/x, thus from Taylor&apos;s theorum we have:
                  -----          n+1         n
                  f(x) =   \           (-1)    (x - 1)
                  /          ----------------    for 1 &lt;= n &lt;= infinity
                  -----             n
                  or
                  2        3       4
                  (x-1)   (x-1)    (x-1)
                  ln(x) =  (x-1) - ----- + ------ - ------ + ...
                  2       3        4
                  alternatively,
                  2    3   4
                  x    x   x
                  ln(x+1) =  x - -  + - - - + ...
                  2    3   4
                  This series can be used to compute ln(x), but it converges too slowly.
                  If we substitute -x for x above, we get
                  2    3    4
                  x    x    x
                  ln(1-x) =  -x - -  - -  - - + ...
                  2    3    4
                  Note that all terms are now negative.  Because the even powered ones
                  absorbed the sign.  Now, subtract the series above from the previous
                  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
                  only the odd ones
                  3     5      7
                  2x    2x     2x
                  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
                  3     5      7
                  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
                  3        5        7
                  x+1           /          x        x        x          \
                  ln ----- =   2   |  x  +   ----  +  ----  +  ---- + ...  |
                  x-1           \          3        5        7          /
                  But now we want to find ln(a), so we need to find the value of x
                  such that a = (x+1)/(x-1).   This is easily solved to find that
                  x = (a-1)/(a+1).                
                <param>
                    a number from which logarithm is requested, in split form                    
                </param>
                <return>
                    log(a)                    
                </return>
            </javadoc>
            <method name="logInternal" type="Dfp[]" line="330">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="t" type="Dfp" line="331"/>
                <declaration name="x" type="Dfp" line="332"/>
                <declaration name="y" type="Dfp" line="333"/>
                <declaration name="num" type="Dfp" line="334"/>
                <declaration name="py" type="Dfp" line="335"/>
                <declaration name="den" type="int" line="336"/>
                <scope line="337">
                    <scope line="343"/>
                </scope>
            </method>
            <javadoc line="351">
                Computes x to the y power.&lt;p&gt;
                  Uses the following method:&lt;p&gt;
                  &lt;ol&gt;
                  &lt;li&gt; Set u = rint(y), v = y-u
                  &lt;li&gt; Compute a = v  ln(x)
                  &lt;li&gt; Compute b = rint( a/ln(2) )
                  &lt;li&gt; Compute c = a - bln(2)
                  &lt;li&gt; x&lt;sup&gt;y&lt;/sup&gt; = x&lt;sup&gt;u&lt;/sup&gt;     2&lt;sup&gt;b&lt;/sup&gt;  e&lt;sup&gt;c&lt;/sup&gt;
                  &lt;/ol&gt;
                  if |y| &gt; 1e8, then we compute by exp(yln(x))   &lt;p&gt;
                  &lt;b&gt;Special Cases&lt;/b&gt;&lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;  if y is 0.0 or -0.0 then result is 1.0
                  &lt;li&gt;  if y is 1.0 then result is x
                  &lt;li&gt;  if y is NaN then result is NaN
                  &lt;li&gt;  if x is NaN and y is not zero then result is NaN
                  &lt;li&gt;  if |x| &gt; 1.0 and y is +Infinity then result is +Infinity
                  &lt;li&gt;  if |x| &lt; 1.0 and y is -Infinity then result is +Infinity
                  &lt;li&gt;  if |x| &gt; 1.0 and y is -Infinity then result is +0
                  &lt;li&gt;  if |x| &lt; 1.0 and y is +Infinity then result is +0
                  &lt;li&gt;  if |x| = 1.0 and y is +/-Infinity then result is NaN
                  &lt;li&gt;  if x = +0 and y &gt; 0 then result is +0
                  &lt;li&gt;  if x = +Inf and y &lt; 0 then result is +0
                  &lt;li&gt;  if x = +0 and y &lt; 0 then result is +Inf
                  &lt;li&gt;  if x = +Inf and y &gt; 0 then result is +Inf
                  &lt;li&gt;  if x = -0 and y &gt; 0, finite, not odd integer then result is +0
                  &lt;li&gt;  if x = -0 and y &lt; 0, finite, and odd integer then result is -Inf
                  &lt;li&gt;  if x = -Inf and y &gt; 0, finite, and odd integer then result is -Inf
                  &lt;li&gt;  if x = -0 and y &lt; 0, not finite odd integer then result is +Inf
                  &lt;li&gt;  if x = -Inf and y &gt; 0, not finite odd integer then result is +Inf
                  &lt;li&gt;  if x &lt; 0 and y &gt; 0, finite, and odd integer then result is -(|x|&lt;sup&gt;y&lt;/sup&gt;)
                  &lt;li&gt;  if x &lt; 0 and y &gt; 0, finite, and not integer then result is NaN
                  &lt;/ul&gt;                
                <param>
                    x base to be raised                    
                </param>
                <param>
                    y power to which base should be raised                    
                </param>
                <return>
                    x<sup>y</sup>                    
                </return>
            </javadoc>
            <method name="pow" type="Dfp" line="389">
                <params>
                    <param name="x" type="Dfp"/>
                    <param name="y" type="Dfp"/>
                </params>
                <scope line="390">
                    <declaration name="result" type="Dfp" line="392"/>
                </scope>
                <declaration name="zero" type="Dfp" line="396"/>
                <declaration name="one" type="Dfp" line="397"/>
                <declaration name="two" type="Dfp" line="398"/>
                <declaration name="invert" type="boolean" line="399"/>
                <declaration name="ui" type="int" line="400"/>
                <scope line="401"/>
                <scope line="404">
                    <scope line="405"/>
                </scope>
                <scope line="411"/>
                <scope line="415">
                    <scope line="416">
                        <scope line="417"/>
                        <scope line="420"/>
                    </scope>
                    <scope line="424">
                        <scope line="425">
                            <scope line="426"/>
                            <scope line="429"/>
                        </scope>
                        <scope line="433">
                            <scope line="434"/>
                            <scope line="437"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="443"/>
                <scope line="447">
                    <scope line="448"/>
                    <scope line="451"/>
                </scope>
                <scope line="455">
                    <scope line="456"/>
                    <scope line="459"/>
                </scope>
                <scope line="463"/>
                <scope line="467">
                    <scope line="468">
                        <scope line="469">
                            <scope line="470"/>
                            <scope line="473"/>
                        </scope>
                        <scope line="477">
                            <scope line="478"/>
                            <scope line="481"/>
                        </scope>
                    </scope>
                    <scope line="486">
                        <scope line="487"/>
                        <scope line="490"/>
                    </scope>
                </scope>
                <scope line="495"/>
                <declaration name="r" type="Dfp" line="499"/>
                <scope line="500">
                    <declaration name="u" type="Dfp" line="501"/>
                    <declaration name="v" type="Dfp" line="503"/>
                    <scope line="504">
                        <declaration name="a" type="Dfp" line="505"/>
                        <declaration name="b" type="Dfp" line="506"/>
                        <declaration name="c" type="Dfp" line="507"/>
                    </scope>
                    <scope line="512"/>
                </scope>
                <scope line="516"/>
                <scope line="519"/>
            </method>
            <javadoc line="524">
                Computes sin(a)  Used when 0 &lt; a &lt; pi/4.
                  Uses the classic Taylor series.  x - x3/3! + x5/5!  ...                
                <param>
                    a number from which sine is desired, in split form                    
                </param>
                <return>
                    sin(a)                    
                </return>
            </javadoc>
            <method name="sinInternal" type="Dfp" line="530">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="c" type="Dfp" line="531"/>
                <declaration name="y" type="Dfp" line="532"/>
                <declaration name="x" type="Dfp" line="534"/>
                <declaration name="fact" type="Dfp" line="535"/>
                <declaration name="py" type="Dfp" line="536"/>
                <scope line="537">
                    <scope line="542"/>
                </scope>
            </method>
            <javadoc line="549">
                Computes cos(a)  Used when 0 &lt; a &lt; pi/4.
                  Uses the classic Taylor series for cosine.  1 - x2/2! + x4/4!  ...                
                <param>
                    a number from which cosine is desired, in split form                    
                </param>
                <return>
                    cos(a)                    
                </return>
            </javadoc>
            <method name="cosInternal" type="Dfp" line="555">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="one" type="Dfp" line="556"/>
                <declaration name="x" type="Dfp" line="557"/>
                <declaration name="y" type="Dfp" line="558"/>
                <declaration name="c" type="Dfp" line="559"/>
                <declaration name="fact" type="Dfp" line="561"/>
                <declaration name="py" type="Dfp" line="562"/>
                <scope line="563">
                    <scope line="568"/>
                </scope>
            </method>
            <javadoc line="575">
                computes the sine of the argument.                
                <param>
                    a number from which sine is desired                    
                </param>
                <return>
                    sin(a)                    
                </return>
            </javadoc>
            <method name="sin" type="Dfp" line="580">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="pi" type="Dfp" line="581"/>
                <declaration name="zero" type="Dfp" line="582"/>
                <declaration name="neg" type="boolean" line="583"/>
                <declaration name="x" type="Dfp" line="584"/>
                <scope line="585"/>
                <scope line="589"/>
                <declaration name="y" type="Dfp" line="592"/>
                <scope line="593">
                    <declaration name="c" type="Dfp" line="594"/>
                </scope>
                <scope line="599">
                    <declaration name="c" type="Dfp" line="600"/>
                    <declaration name="piSplit" type="Dfp[]" line="601"/>
                </scope>
                <scope line="606"/>
            </method>
            <javadoc line="611">
                computes the cosine of the argument.                
                <param>
                    a number from which cosine is desired                    
                </param>
                <return>
                    cos(a)                    
                </return>
            </javadoc>
            <method name="cos" type="Dfp" line="616">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="pi" type="Dfp" line="617"/>
                <declaration name="zero" type="Dfp" line="618"/>
                <declaration name="neg" type="boolean" line="619"/>
                <declaration name="x" type="Dfp" line="620"/>
                <scope line="621"/>
                <scope line="624"/>
                <declaration name="y" type="Dfp" line="628"/>
                <scope line="629">
                    <declaration name="c" type="Dfp" line="630"/>
                </scope>
                <scope line="635">
                    <declaration name="c" type="Dfp" line="636"/>
                    <declaration name="piSplit" type="Dfp[]" line="637"/>
                </scope>
                <scope line="642"/>
            </method>
            <javadoc line="647">
                computes the tangent of the argument.                
                <param>
                    a number from which tangent is desired                    
                </param>
                <return>
                    tan(a)                    
                </return>
            </javadoc>
            <method name="tan" type="Dfp" line="652">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
            </method>
            <javadoc line="655">
                computes the arc-tangent of the argument.                
                <param>
                    a number from which arc-tangent is desired                    
                </param>
                <return>
                    atan(a)                    
                </return>
            </javadoc>
            <method name="atanInternal" type="Dfp" line="660">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="y" type="Dfp" line="661"/>
                <declaration name="x" type="Dfp" line="662"/>
                <declaration name="py" type="Dfp" line="663"/>
                <scope line="664">
                    <scope line="669"/>
                </scope>
            </method>
            <javadoc line="676">
                computes the arc tangent of the argument
                  Uses the typical taylor series
                  but may reduce arguments using the following identity
                  tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)tan(y))
                  since tan(PI/8) = sqrt(2)-1,
                  atan(x) = atan( (x - sqrt(2) + 1) / (1+xsqrt(2) - x) + PI/8.0                
                <param>
                    a number from which arc-tangent is desired                    
                </param>
                <return>
                    atan(a)                    
                </return>
            </javadoc>
            <method name="atan" type="Dfp" line="686">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="zero" type="Dfp" line="687"/>
                <declaration name="one" type="Dfp" line="688"/>
                <declaration name="sqr2Split" type="Dfp[]" line="689"/>
                <declaration name="piSplit" type="Dfp[]" line="690"/>
                <declaration name="recp" type="boolean" line="691"/>
                <declaration name="neg" type="boolean" line="692"/>
                <declaration name="sub" type="boolean" line="693"/>
                <declaration name="ty" type="Dfp" line="694"/>
                <declaration name="x" type="Dfp" line="695"/>
                <scope line="696"/>
                <scope line="700"/>
                <scope line="704">
                    <declaration name="sty" type="Dfp" line="705"/>
                    <declaration name="xs" type="Dfp[]" line="709"/>
                    <declaration name="ds" type="Dfp[]" line="710"/>
                </scope>
                <declaration name="y" type="Dfp" line="717"/>
                <scope line="718"/>
                <scope line="721"/>
                <scope line="724"/>
            </method>
            <javadoc line="729">
                computes the arc-sine of the argument.                
                <param>
                    a number from which arc-sine is desired                    
                </param>
                <return>
                    asin(a)                    
                </return>
            </javadoc>
            <method name="asin" type="Dfp" line="734">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
            </method>
            <javadoc line="737">
                computes the arc-cosine of the argument.                
                <param>
                    a number from which arc-cosine is desired                    
                </param>
                <return>
                    acos(a)                    
                </return>
            </javadoc>
            <method name="acos" type="Dfp" line="742">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="result" type="Dfp" line="743"/>
                <declaration name="negative" type="boolean" line="744"/>
                <scope line="745"/>
                <scope line="750"/>
            </method>
        </class>
    </source>