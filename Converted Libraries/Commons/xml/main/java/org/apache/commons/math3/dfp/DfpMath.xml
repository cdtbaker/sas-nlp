<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.dfp">
        <class name="DfpMath" line="20">
            <javadoc line="20">
                Mathematical routines for use with {@link Dfp}.
                  The constants are defined in {@link DfpField}                
                <version>
                    $Id: DfpMath.java 1538368 2013-11-03 13:57:37Z erans $                    
                </version>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <declaration name="POW_TRAP" type="String" line="27"/>
            <javadoc line="27">
                Name for traps triggered by pow.                
            </javadoc>
            <javadoc line="30">
                Private Constructor.                
            </javadoc>
            <method name="DfpMath" type="constructor" line="33"/>
            <javadoc line="36">
                Breaks a string representation up into two dfp&apos;s.
                  &lt;p&gt;The two dfp are such that the sum of them is equivalent
                  to the input string, but has higher precision than using a
                  single dfp. This is useful for improving accuracy of
                  exponentiation and critical multiplies.                
                <param>
                    field field to which the Dfp must belong                    
                </param>
                <param>
                    a string representation to split                    
                </param>
                <return>
                    an array of two {@link Dfp} which sum is a                    
                </return>
            </javadoc>
            <method name="split" type="Dfp[]" line="45">
                <params>
                    <param name="field" type="DfpField"/>
                    <param name="a" type="String"/>
                </params>
                <declaration name="result" type="Dfp" line="46"/>
                <declaration name="buf" type="char[]" line="47"/>
                <declaration name="leading" type="boolean" line="48"/>
                <declaration name="sp" type="int" line="49"/>
                <declaration name="sig" type="int" line="50"/>
                <scope line="54">
                    <scope line="57"/>
                    <scope line="61"/>
                    <scope line="66"/>
                    <scope line="71"/>
                </scope>
                <scope line="78">
                    <scope line="80"/>
                </scope>
            </method>
            <javadoc line="90">
                Splits a {@link Dfp} into 2 {@link Dfp}&apos;s such that their sum is equal to the input {@link Dfp}.                
                <param>
                    a number to split                    
                </param>
                <return>
                    two elements array containing the split number                    
                </return>
            </javadoc>
            <method name="split" type="Dfp[]" line="94">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="result" type="Dfp[]" line="95"/>
                <declaration name="shift" type="Dfp" line="96"/>
            </method>
            <javadoc line="102">
                Multiply two numbers that are split in to two pieces that are
                  meant to be added together.
                  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1
                  Store the first term in result0, the rest in result1                
                <param>
                    a first factor of the multiplication, in split form                    
                </param>
                <param>
                    b second factor of the multiplication, in split form                    
                </param>
                <return>
                    a &amp;times; b, in split form                    
                </return>
            </javadoc>
            <method name="splitMult" type="Dfp[]" line="110">
                <params>
                    <param name="a" type="Dfp[]"/>
                    <param name="b" type="Dfp[]"/>
                </params>
                <comment line="117">
                    If result[0] is infinite or zero, don&apos;t compute result[1].
                     Attempting to do so may produce NaNs.                    
                </comment>
                <declaration name="result" type="Dfp[]" line="111"/>
                <scope line="120"/>
            </method>
            <javadoc line="129">
                Divide two numbers that are split in to two pieces that are meant to be added together.
                  Inverse of split multiply above:
                  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c2+cd) )                
                <param>
                    a dividend, in split form                    
                </param>
                <param>
                    b divisor, in split form                    
                </param>
                <return>
                    a / b, in split form                    
                </return>
            </javadoc>
            <method name="splitDiv" type="Dfp[]" line="136">
                <params>
                    <param name="a" type="Dfp[]"/>
                    <param name="b" type="Dfp[]"/>
                </params>
                <declaration name="result" type="Dfp[]" line="137"/>
            </method>
            <javadoc line="148">
                Raise a split base to the a power.                
                <param>
                    base number to raise                    
                </param>
                <param>
                    a power                    
                </param>
                <return>
                    base&lt;sup&gt;a&lt;/sup&gt;                    
                </return>
            </javadoc>
            <method name="splitPow" type="Dfp" line="153">
                <params>
                    <param name="base" type="Dfp[]"/>
                    <param name="a" type="int"/>
                </params>
                <comment line="164">
                    Special case a = 0                    
                </comment>
                <comment line="169">
                    If a is less than zero                    
                </comment>
                <comment line="174">
                    Exponentiate by successive squaring                    
                </comment>
                <declaration name="invert" type="boolean" line="154"/>
                <declaration name="r" type="Dfp[]" line="156"/>
                <declaration name="result" type="Dfp[]" line="158"/>
                <scope line="162"/>
                <scope line="167"/>
                <scope line="174">
                    <declaration name="trial" type="int" line="177"/>
                    <declaration name="prevtrial" type="int" line="179"/>
                    <scope line="180">
                        <scope line="183"/>
                    </scope>
                </scope>
                <scope line="198"/>
            </method>
            <javadoc line="206">
                Raises base to the power a by successive squaring.                
                <param>
                    base number to raise                    
                </param>
                <param>
                    a power                    
                </param>
                <return>
                    base&lt;sup&gt;a&lt;/sup&gt;                    
                </return>
            </javadoc>
            <method name="pow" type="Dfp" line="212">
                <params>
                    <param name="base" type="Dfp"/>
                    <param name="a" type="int"/>
                </params>
                <comment line="219">
                    Special case                    
                </comment>
                <comment line="228">
                    Exponentiate by successive squaring                    
                </comment>
                <declaration name="invert" type="boolean" line="213"/>
                <declaration name="result" type="Dfp" line="215"/>
                <scope line="217"/>
                <scope line="222"/>
                <scope line="228">
                    <declaration name="r" type="Dfp" line="229"/>
                    <declaration name="prevr" type="Dfp" line="230"/>
                    <declaration name="trial" type="int" line="231"/>
                    <declaration name="prevtrial" type="int" line="232"/>
                    <scope line="234"/>
                </scope>
                <scope line="249"/>
            </method>
            <javadoc line="257">
                Computes e to the given power.
                  a is broken into two parts, such that a = n+m  where n is an integer.
                  We use pow() to compute e&lt;sup&gt;n&lt;/sup&gt; and a Taylor series to compute
                  e&lt;sup&gt;m&lt;/sup&gt;.  We return e&lt;sup&gt;n&lt;/sup&gt; &amp;times; e&lt;sup&gt;m&lt;/sup&gt;                
                <param>
                    a power at which e should be raised                    
                </param>
                <return>
                    e&lt;sup&gt;a&lt;/sup&gt;                    
                </return>
            </javadoc>
            <method name="exp" type="Dfp" line="264">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="272">
                    return +Infinity                    
                </comment>
                <comment line="277">
                    return 0;                    
                </comment>
                <declaration name="inta" type="Dfp" line="266"/>
                <declaration name="fraca" type="Dfp" line="267"/>
                <declaration name="ia" type="int" line="269"/>
                <scope line="270"/>
                <scope line="275"/>
                <declaration name="einta" type="Dfp" line="280"/>
                <declaration name="efraca" type="Dfp" line="281"/>
            </method>
            <javadoc line="286">
                Computes e to the given power.
                  Where -1 &lt; a &lt; 1.  Use the classic Taylor series.  1 + x2/2! + x3/3! + x4/4!  ...                
                <param>
                    a power at which e should be raised                    
                </param>
                <return>
                    e&lt;sup&gt;a&lt;/sup&gt;                    
                </return>
            </javadoc>
            <method name="expInternal" type="Dfp" line="291">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="y" type="Dfp" line="292"/>
                <declaration name="x" type="Dfp" line="293"/>
                <declaration name="fact" type="Dfp" line="294"/>
                <declaration name="py" type="Dfp" line="295"/>
                <scope line="297">
                    <scope line="301"/>
                </scope>
            </method>
            <javadoc line="310">
                Returns the natural logarithm of a.
                  a is first split into three parts such that  a = (10000^h)(2^j)k.
                  ln(a) is computed by ln(a) = ln(5)h + ln(2)(h+j) + ln(k)
                  k is in the range 2/3 &lt; k &lt;4/3 and is passed on to a series expansion.                
                <param>
                    a number from which logarithm is requested                    
                </param>
                <return>
                    log(a)                    
                </return>
            </javadoc>
            <method name="log" type="Dfp" line="317">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="324">
                    Check the arguments somewhat here                    
                </comment>
                <comment line="326">
                    negative, zero or NaN                    
                </comment>
                <comment line="338">
                                        
                </comment>
                <comment line="349">
                    use spy[0] temporarily as a divisor                    
                </comment>
                <comment line="353">
                    Use spy[0] for comparison                    
                </comment>
                <comment line="360">
                    X is now in the range of 2/3 &lt; x &lt; 4/3                    
                </comment>
                <declaration name="lr" type="int" line="318"/>
                <declaration name="x" type="Dfp" line="319"/>
                <declaration name="ix" type="int" line="320"/>
                <declaration name="p2" type="int" line="321"/>
                <scope line="324"/>
                <scope line="330"/>
                <scope line="340"/>
                <declaration name="spx" type="Dfp[]" line="346"/>
                <declaration name="spy" type="Dfp[]" line="347"/>
                <scope line="353"/>
                <declaration name="spz" type="Dfp[]" line="360"/>
            </method>
            <javadoc line="380">
                Computes the natural log of a number between 0 and 2.
                  Let f(x) = ln(x),
                  We know that f&apos;(x) = 1/x, thus from Taylor&apos;s theorum we have:
                  -----          n+1         n
                  f(x) =   \           (-1)    (x - 1)
                  /          ----------------    for 1 &lt;= n &lt;= infinity
                  -----             n
                  or
                  2        3       4
                  (x-1)   (x-1)    (x-1)
                  ln(x) =  (x-1) - ----- + ------ - ------ + ...
                  2       3        4
                  alternatively,
                  2    3   4
                  x    x   x
                  ln(x+1) =  x - -  + - - - + ...
                  2    3   4
                  This series can be used to compute ln(x), but it converges too slowly.
                  If we substitute -x for x above, we get
                  2    3    4
                  x    x    x
                  ln(1-x) =  -x - -  - -  - - + ...
                  2    3    4
                  Note that all terms are now negative.  Because the even powered ones
                  absorbed the sign.  Now, subtract the series above from the previous
                  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving
                  only the odd ones
                  3     5      7
                  2x    2x     2x
                  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...
                  3     5      7
                  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:
                  3        5        7
                  x+1           /          x        x        x          \
                  ln ----- =   2   |  x  +   ----  +  ----  +  ---- + ...  |
                  x-1           \          3        5        7          /
                  But now we want to find ln(a), so we need to find the value of x
                  such that a = (x+1)/(x-1).   This is easily solved to find that
                  x = (a-1)/(a+1).                
                <param>
                    a number from which logarithm is requested, in split form                    
                </param>
                <return>
                    log(a)                    
                </return>
            </javadoc>
            <method name="logInternal" type="Dfp[]" line="435">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="438">
                    Now we want to compute x = (a-1)(a+1) but this is prone to
                     loss of precision.  So instead, compute x = (a4 - 14)  (a4 + 14)                    
                </comment>
                <declaration name="t" type="Dfp" line="440"/>
                <declaration name="x" type="Dfp" line="441"/>
                <declaration name="y" type="Dfp" line="443"/>
                <declaration name="num" type="Dfp" line="444"/>
                <declaration name="py" type="Dfp" line="445"/>
                <declaration name="den" type="int" line="446"/>
                <scope line="447">
                    <scope line="453"/>
                </scope>
            </method>
            <javadoc line="465">
                Computes x to the y power.&lt;p&gt;
                  Uses the following method:&lt;p&gt;
                  &lt;ol&gt;
                  &lt;li&gt; Set u = rint(y), v = y-u
                  &lt;li&gt; Compute a = v  ln(x)
                  &lt;li&gt; Compute b = rint( a/ln(2) )
                  &lt;li&gt; Compute c = a - bln(2)
                  &lt;li&gt; x&lt;sup&gt;y&lt;/sup&gt; = x&lt;sup&gt;u&lt;/sup&gt;     2&lt;sup&gt;b&lt;/sup&gt;  e&lt;sup&gt;c&lt;/sup&gt;
                  &lt;/ol&gt;
                  if |y| &gt; 1e8, then we compute by exp(yln(x))   &lt;p&gt;
                  &lt;b&gt;Special Cases&lt;/b&gt;&lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;  if y is 0.0 or -0.0 then result is 1.0
                  &lt;li&gt;  if y is 1.0 then result is x
                  &lt;li&gt;  if y is NaN then result is NaN
                  &lt;li&gt;  if x is NaN and y is not zero then result is NaN
                  &lt;li&gt;  if |x| &gt; 1.0 and y is +Infinity then result is +Infinity
                  &lt;li&gt;  if |x| &lt; 1.0 and y is -Infinity then result is +Infinity
                  &lt;li&gt;  if |x| &gt; 1.0 and y is -Infinity then result is +0
                  &lt;li&gt;  if |x| &lt; 1.0 and y is +Infinity then result is +0
                  &lt;li&gt;  if |x| = 1.0 and y is +/-Infinity then result is NaN
                  &lt;li&gt;  if x = +0 and y &gt; 0 then result is +0
                  &lt;li&gt;  if x = +Inf and y &lt; 0 then result is +0
                  &lt;li&gt;  if x = +0 and y &lt; 0 then result is +Inf
                  &lt;li&gt;  if x = +Inf and y &gt; 0 then result is +Inf
                  &lt;li&gt;  if x = -0 and y &gt; 0, finite, not odd integer then result is +0
                  &lt;li&gt;  if x = -0 and y &lt; 0, finite, and odd integer then result is -Inf
                  &lt;li&gt;  if x = -Inf and y &gt; 0, finite, and odd integer then result is -Inf
                  &lt;li&gt;  if x = -0 and y &lt; 0, not finite odd integer then result is +Inf
                  &lt;li&gt;  if x = -Inf and y &gt; 0, not finite odd integer then result is +Inf
                  &lt;li&gt;  if x &lt; 0 and y &gt; 0, finite, and odd integer then result is -(|x|&lt;sup&gt;y&lt;/sup&gt;)
                  &lt;li&gt;  if x &lt; 0 and y &gt; 0, finite, and not integer then result is NaN
                  &lt;/ul&gt;                
                <param>
                    x base to be raised                    
                </param>
                <param>
                    y power to which base should be raised                    
                </param>
                <return>
                    x&lt;sup&gt;y&lt;/sup&gt;                    
                </return>
            </javadoc>
            <method name="pow" type="Dfp" line="505">
                <params>
                    <param name="x" type="Dfp"/>
                    <param name="y" type="Dfp"/>
                </params>
                <comment line="508">
                    make sure we don&apos;t mix number with different precision                    
                </comment>
                <comment line="522">
                                        
                </comment>
                <comment line="529">
                    Test for NaNs                    
                </comment>
                <comment line="537">
                    Test for NaNs                    
                </comment>
                <comment line="542">
                    X == 0                    
                </comment>
                <comment line="545">
                    X == +0                    
                </comment>
                <comment line="552">
                    X == -0                    
                </comment>
                <comment line="554">
                    If y is odd integer                    
                </comment>
                <comment line="561">
                    Y is not odd integer                    
                </comment>
                <comment line="572">
                    Make x positive, but keep track of it                    
                </comment>
                <comment line="599">
                    x = +/- inf                    
                </comment>
                <comment line="601">
                    negative infinity                    
                </comment>
                <comment line="603">
                    If y is odd integer                    
                </comment>
                <comment line="610">
                    Y is not odd integer                    
                </comment>
                <comment line="618">
                    positive infinity                    
                </comment>
                <comment line="632">
                    End special cases                    
                </comment>
                <comment line="653">
                    very large exponent.  |y| &gt; 1e8                    
                </comment>
                <comment line="658">
                    if y is odd integer                    
                </comment>
                <scope line="508">
                    <declaration name="result" type="Dfp" line="510"/>
                </scope>
                <declaration name="zero" type="Dfp" line="515"/>
                <declaration name="one" type="Dfp" line="516"/>
                <declaration name="two" type="Dfp" line="517"/>
                <declaration name="invert" type="boolean" line="518"/>
                <declaration name="ui" type="int" line="519"/>
                <scope line="522"/>
                <scope line="526">
                    <scope line="527"/>
                </scope>
                <scope line="535"/>
                <scope line="542">
                    <scope line="543">
                        <scope line="545"/>
                        <scope line="547"/>
                    </scope>
                    <scope line="550">
                        <scope line="552">
                            <scope line="554"/>
                            <scope line="556"/>
                        </scope>
                        <scope line="559">
                            <scope line="561"/>
                            <scope line="563"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="570"/>
                <scope line="576">
                    <scope line="577"/>
                    <scope line="579"/>
                </scope>
                <scope line="584">
                    <scope line="585"/>
                    <scope line="587"/>
                </scope>
                <scope line="592"/>
                <scope line="597">
                    <scope line="599">
                        <scope line="601">
                            <scope line="603"/>
                            <scope line="605"/>
                        </scope>
                        <scope line="608">
                            <scope line="610"/>
                            <scope line="612"/>
                        </scope>
                    </scope>
                    <scope line="616">
                        <scope line="618"/>
                        <scope line="620"/>
                    </scope>
                </scope>
                <scope line="626"/>
                <declaration name="r" type="Dfp" line="633"/>
                <scope line="634">
                    <declaration name="u" type="Dfp" line="635"/>
                    <declaration name="v" type="Dfp" line="638"/>
                    <scope line="640">
                        <declaration name="a" type="Dfp" line="641"/>
                        <declaration name="b" type="Dfp" line="642"/>
                        <declaration name="c" type="Dfp" line="644"/>
                    </scope>
                    <scope line="648"/>
                </scope>
                <scope line="651"/>
                <scope line="656"/>
            </method>
            <javadoc line="665">
                Computes sin(a)  Used when 0 &lt; a &lt; pi/4.
                  Uses the classic Taylor series.  x - x3/3! + x5/5!  ...                
                <param>
                    a number from which sine is desired, in split form                    
                </param>
                <return>
                    sin(a)                    
                </return>
            </javadoc>
            <method name="sinInternal" type="Dfp" line="670">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="684">
                    1 over fact                    
                </comment>
                <declaration name="c" type="Dfp" line="672"/>
                <declaration name="y" type="Dfp" line="673"/>
                <declaration name="x" type="Dfp" line="675"/>
                <declaration name="fact" type="Dfp" line="676"/>
                <declaration name="py" type="Dfp" line="677"/>
                <scope line="679">
                    <scope line="685"/>
                </scope>
            </method>
            <javadoc line="695">
                Computes cos(a)  Used when 0 &lt; a &lt; pi/4.
                  Uses the classic Taylor series for cosine.  1 - x2/2! + x4/4!  ...                
                <param>
                    a number from which cosine is desired, in split form                    
                </param>
                <return>
                    cos(a)                    
                </return>
            </javadoc>
            <method name="cosInternal" type="Dfp" line="700">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="717">
                    1 over fact                    
                </comment>
                <declaration name="one" type="Dfp" line="701"/>
                <declaration name="x" type="Dfp" line="704"/>
                <declaration name="y" type="Dfp" line="705"/>
                <declaration name="c" type="Dfp" line="706"/>
                <declaration name="fact" type="Dfp" line="709"/>
                <declaration name="py" type="Dfp" line="710"/>
                <scope line="712">
                    <scope line="719"/>
                </scope>
            </method>
            <javadoc line="729">
                computes the sine of the argument.                
                <param>
                    a number from which sine is desired                    
                </param>
                <return>
                    sin(a)                    
                </return>
            </javadoc>
            <method name="sin" type="Dfp" line="733">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="739">
                                        
                </comment>
                <comment line="742">
                                        
                </comment>
                <comment line="743">
                                        
                </comment>
                <comment line="749">
                    Since sine(x) = sine(pi - x) we can reduce the range to
                     0 &lt; x &lt; pi2                    
                </comment>
                <comment line="763">
                    y = sinInternal(c);                    
                </comment>
                <declaration name="pi" type="Dfp" line="734"/>
                <declaration name="zero" type="Dfp" line="735"/>
                <declaration name="neg" type="boolean" line="736"/>
                <declaration name="x" type="Dfp" line="739"/>
                <scope line="743"/>
                <scope line="752"/>
                <declaration name="y" type="Dfp" line="756"/>
                <scope line="757">
                    <declaration name="c" type="Dfp" line="758"/>
                </scope>
                <scope line="764">
                    <declaration name="c" type="Dfp" line="765"/>
                    <declaration name="piSplit" type="Dfp[]" line="766"/>
                </scope>
                <scope line="772"/>
            </method>
            <javadoc line="780">
                computes the cosine of the argument.                
                <param>
                    a number from which cosine is desired                    
                </param>
                <return>
                    cos(a)                    
                </return>
            </javadoc>
            <method name="cos" type="Dfp" line="784">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="790">
                                        
                </comment>
                <comment line="793">
                                        
                </comment>
                <comment line="794">
                                        
                </comment>
                <comment line="799">
                    Since cos(x) = -cos(pi - x) we can reduce the range to
                     0 &lt; x &lt; pi2                    
                </comment>
                <declaration name="pi" type="Dfp" line="785"/>
                <declaration name="zero" type="Dfp" line="786"/>
                <declaration name="neg" type="boolean" line="787"/>
                <declaration name="x" type="Dfp" line="790"/>
                <scope line="794"/>
                <scope line="802"/>
                <declaration name="y" type="Dfp" line="807"/>
                <scope line="808">
                    <declaration name="c" type="Dfp" line="809"/>
                </scope>
                <scope line="814">
                    <declaration name="c" type="Dfp" line="815"/>
                    <declaration name="piSplit" type="Dfp[]" line="816"/>
                </scope>
                <scope line="822"/>
            </method>
            <javadoc line="830">
                computes the tangent of the argument.                
                <param>
                    a number from which tangent is desired                    
                </param>
                <return>
                    tan(a)                    
                </return>
            </javadoc>
            <method name="tan" type="Dfp" line="834">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
            </method>
            <javadoc line="838">
                computes the arc-tangent of the argument.                
                <param>
                    a number from which arc-tangent is desired                    
                </param>
                <return>
                    atan(a)                    
                </return>
            </javadoc>
            <method name="atanInternal" type="Dfp" line="842">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <declaration name="y" type="Dfp" line="844"/>
                <declaration name="x" type="Dfp" line="845"/>
                <declaration name="py" type="Dfp" line="846"/>
                <scope line="848">
                    <scope line="853"/>
                </scope>
            </method>
            <javadoc line="863">
                computes the arc tangent of the argument
                  Uses the typical taylor series
                  but may reduce arguments using the following identity
                  tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)tan(y))
                  since tan(PI/8) = sqrt(2)-1,
                  atan(x) = atan( (x - sqrt(2) + 1) / (1+xsqrt(2) - x) + PI/8.0                
                <param>
                    a number from which arc-tangent is desired                    
                </param>
                <return>
                    atan(a)                    
                </return>
            </javadoc>
            <method name="atan" type="Dfp" line="876">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="917">
                    x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));                    
                </comment>
                <declaration name="zero" type="Dfp" line="877"/>
                <declaration name="one" type="Dfp" line="878"/>
                <declaration name="sqr2Split" type="Dfp[]" line="879"/>
                <declaration name="piSplit" type="Dfp[]" line="880"/>
                <declaration name="recp" type="boolean" line="881"/>
                <declaration name="neg" type="boolean" line="882"/>
                <declaration name="sub" type="boolean" line="883"/>
                <declaration name="ty" type="Dfp" line="885"/>
                <declaration name="x" type="Dfp" line="887"/>
                <scope line="888"/>
                <scope line="893"/>
                <scope line="898">
                    <declaration name="sty" type="Dfp" line="899"/>
                    <declaration name="xs" type="Dfp[]" line="905"/>
                    <declaration name="ds" type="Dfp[]" line="907"/>
                </scope>
                <declaration name="y" type="Dfp" line="919"/>
                <scope line="921"/>
                <scope line="925"/>
                <scope line="929"/>
            </method>
            <javadoc line="937">
                computes the arc-sine of the argument.                
                <param>
                    a number from which arc-sine is desired                    
                </param>
                <return>
                    asin(a)                    
                </return>
            </javadoc>
            <method name="asin" type="Dfp" line="941">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
            </method>
            <javadoc line="945">
                computes the arc-cosine of the argument.                
                <param>
                    a number from which arc-cosine is desired                    
                </param>
                <return>
                    acos(a)                    
                </return>
            </javadoc>
            <method name="acos" type="Dfp" line="949">
                <params>
                    <param name="a" type="Dfp"/>
                </params>
                <comment line="958">
                    absolute value                    
                </comment>
                <declaration name="result" type="Dfp" line="950"/>
                <declaration name="negative" type="boolean" line="951"/>
                <scope line="953"/>
                <scope line="961"/>
            </method>
        </class>
    </source>