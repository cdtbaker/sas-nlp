<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.fitting">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.analysis.function.HarmonicOscillator"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.ZeroException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder"/>
        <import package="org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem"/>
        <import package="org.apache.commons.math3.linear.DiagonalMatrix"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="HarmonicCurveFitter" line="33">
            <extends class="AbstractCurveFitter"/>
            <javadoc line="33">
                Fits points to a {@link org.apache.commons.math3.analysis.function.HarmonicOscillator.Parametric harmonic oscillator}function.
                  &lt;br/&gt;
                  The {@link #withStartPoint(double[]) initial guess values} must be passed
                  in the following order:
                  &lt;ul&gt;
                  &lt;li&gt;Amplitude&lt;/li&gt;
                  &lt;li&gt;Angular frequency&lt;/li&gt;
                  &lt;li&gt;phase&lt;/li&gt;
                  &lt;/ul&gt;
                  The optimal values will be returned in the same order.                
                <version>
                    $Id: HarmonicCurveFitter.java 1571640 2014-02-25 10:27:21Z erans $                    
                </version>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <declaration name="FUNCTION" type="HarmonicOscillator.Parametric" line="51"/>
            <javadoc line="51">
                Parametric function to be fitted.                
            </javadoc>
            <declaration name="initialGuess" type="double[]" line="53"/>
            <javadoc line="53">
                Initial guess.                
            </javadoc>
            <declaration name="maxIter" type="int" line="55"/>
            <javadoc line="55">
                Maximum number of iterations of the optimization algorithm.                
            </javadoc>
            <javadoc line="58">
                Contructor used by the factory methods.                
                <param>
                    initialGuess Initial guess. If set to {@code null}, the initial guess
                      will be estimated using the {@link ParameterGuesser}.                    
                </param>
                <param>
                    maxIter Maximum number of iterations of the optimization algorithm.                    
                </param>
            </javadoc>
            <method name="HarmonicCurveFitter" type="constructor" line="66">
                <params>
                    <param name="initialGuess" type="double[]"/>
                    <param name="maxIter" type="int"/>
                </params>
            </method>
            <javadoc line="71">
                Creates a default curve fitter.
                  The initial guess for the parameters will be {@link ParameterGuesser}computed automatically, and the maximum number of iterations of the
                  optimization algorithm is set to {@link Integer#MAX_VALUE}.                
                <return>
                    a curve fitter.                    
                </return>
                <see>
                    #withStartPoint(double[])                    
                </see>
                <see>
                    #withMaxIterations(int)                    
                </see>
            </javadoc>
            <method name="create" type="HarmonicCurveFitter" line="82"/>
            <javadoc line="86">
                Configure the start point (initial guess).                
                <param>
                    newStart new start point (initial guess)                    
                </param>
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withStartPoint" type="HarmonicCurveFitter" line="91">
                <params>
                    <param name="newStart" type="double[]"/>
                </params>
            </method>
            <javadoc line="96">
                Configure the maximum number of iterations.                
                <param>
                    newMaxIter maximum number of iterations                    
                </param>
                <return>
                    a new instance.                    
                </return>
            </javadoc>
            <method name="withMaxIterations" type="HarmonicCurveFitter" line="101">
                <params>
                    <param name="newMaxIter" type="int"/>
                </params>
            </method>
            <javadoc line="106">
                {@inheritDoc}                
            </javadoc>
            <method name="getProblem" type="LeastSquaresProblem" line="108">
                <params>
                    <param name="observations" type="Collection&lt;WeightedObservedPoint&gt;"/>
                </params>
                <comment line="110">
                    Prepare least-squares problem.                    
                </comment>
                <comment line="128">
                    Compute estimation.                    
                </comment>
                <comment line="131">
                    Return a new optimizer set up to fit a Gaussian curve to the
                     observed points.                    
                </comment>
                <declaration name="len" type="int" line="110"/>
                <declaration name="target" type="double[]" line="111"/>
                <declaration name="weights" type="double[]" line="112"/>
                <declaration name="i" type="int" line="114"/>
                <scope line="115"/>
                <declaration name="model" type="AbstractCurveFitter.TheoreticalValuesFunction" line="121"/>
                <declaration name="startPoint" type="double[]" line="125"/>
            </method>
            <class name="ParameterGuesser" line="143">
                <javadoc line="143">
                    This class guesses harmonic coefficients from a sample.
                      &lt;p&gt;The algorithm used to guess the coefficients is as follows:&lt;/p&gt;
                      &lt;p&gt;We know \( f(t) \) at some sampling points \( t_i \) and want
                      to find \( a \), \( \omega \) and \( \phi \) such that
                      \( f(t) = a \cos (\omega t + \phi) \).
                      &lt;/p&gt;
                      &lt;p&gt;From the analytical expression, we can compute two primitives :
                      \[
                      If2(t) = \int f^2 dt  = a^2 (t + S(t)) / 2
                      \]
                      \[
                      If&apos;2(t) = \int f&apos;^2 dt = a^2 \omega^2 (t - S(t)) / 2
                      \]
                      where \(S(t) = \frac{\sin(2 (\omega t + \phi))}{2\omega}\)
                      &lt;/p&gt;
                      &lt;p&gt;We can remove \(S\) between these expressions :
                      \[
                      If&apos;2(t) = a^2 \omega^2 t - \omega^2 If2(t)
                      \]
                      &lt;/p&gt;
                      &lt;p&gt;The preceding expression shows that \(If&apos;2 (t)\) is a linear
                      combination of both \(t\) and \(If2(t)\):
                      \[
                      If&apos;2(t) = A t + B If2(t)
                      \]
                      &lt;/p&gt;
                      &lt;p&gt;From the primitive, we can deduce the same form for definite
                      integrals between \(t_1\) and \(t_i\) for each \(t_i\) :
                      \[
                      If2(t_i) - If2(t_1) = A (t_i - t_1) + B (If2 (t_i) - If2(t_1))
                      \]
                      &lt;/p&gt;
                      &lt;p&gt;We can find the coefficients \(A\) and \(B\) that best fit the sample
                      to this linear expression by computing the definite integrals for
                      each sample points.
                      &lt;/p&gt;
                      &lt;p&gt;For a bilinear expression \(z(x_i, y_i) = A x_i + B y_i\), the
                      coefficients \(A\) and \(B\) that minimize a least-squares criterion
                      \(\sum (z_i - z(x_i, y_i))^2\) are given by these expressions:&lt;/p&gt;
                      \[
                      A = \frac{\sum y_i y_i \sum x_i z_i - \sum x_i y_i \sum y_i z_i}
                      {\sum x_i x_i \sum y_i y_i - \sum x_i y_i \sum x_i y_i}
                      \]
                      \[
                      B = \frac{\sum x_i x_i \sum y_i z_i - \sum x_i y_i \sum x_i z_i}
                      {\sum x_i x_i \sum y_i y_i - \sum x_i y_i \sum x_i y_i}
                      \]
                      &lt;p&gt;In fact, we can assume that both \(a\) and \(\omega\) are positive and
                      compute them directly, knowing that \(A = a^2 \omega^2\) and that
                      \(B = -\omega^2\). The complete algorithm is therefore:&lt;/p&gt;
                      For each \(t_i\) from \(t_1\) to \(t_{n-1}\), compute:
                      \[ f(t_i) \]
                      \[ f&apos;(t_i) = \frac{f (t_{i+1}) - f(t_{i-1})}{t_{i+1} - t_{i-1}} \]
                      \[ x_i = t_i  - t_1 \]
                      \[ y_i = \int_{t_1}^{t_i} f^2(t) dt \]
                      \[ z_i = \int_{t_1}^{t_i} f&apos;^2(t) dt \]
                      and update the sums:
                      \[ \sum x_i x_i, \sum y_i y_i, \sum x_i y_i, \sum x_i z_i, \sum y_i z_i \]
                      Then:
                      \[
                      a = \sqrt{\frac{\sum y_i y_i  \sum x_i z_i - \sum x_i y_i \sum y_i z_i }
                      {\sum x_i y_i  \sum x_i z_i - \sum x_i x_i \sum y_i z_i }}
                      \]
                      \[
                      \omega = \sqrt{\frac{\sum x_i y_i \sum x_i z_i - \sum x_i x_i \sum y_i z_i}
                      {\sum x_i x_i \sum y_i y_i - \sum x_i y_i \sum x_i y_i}}
                      \]
                      &lt;p&gt;Once we know \(\omega\) we can compute:
                      \[
                      fc = \omega f(t) \cos(\omega t) - f&apos;(t) \sin(\omega t)
                      \]
                      \[
                      fs = \omega f(t) \sin(\omega t) + f&apos;(t) \cos(\omega t)
                      \]
                      &lt;/p&gt;
                      &lt;p&gt;It appears that \(fc = a \omega \cos(\phi)\) and
                      \(fs = -a \omega \sin(\phi)\), so we can use these
                      expressions to compute \(\phi\). The best estimate over the sample is
                      given by averaging these expressions.
                      &lt;/p&gt;
                      &lt;p&gt;Since integrals and means are involved in the preceding
                      estimations, these operations run in \(O(n)\) time, where \(n\) is the
                      number of measurements.&lt;/p&gt;                    
                </javadoc>
                <declaration name="a" type="double" line="243"/>
                <javadoc line="243">
                    Amplitude.                    
                </javadoc>
                <declaration name="omega" type="double" line="245"/>
                <javadoc line="245">
                    Angular frequency.                    
                </javadoc>
                <declaration name="phi" type="double" line="247"/>
                <javadoc line="247">
                    Phase.                    
                </javadoc>
                <javadoc line="250">
                    Simple constructor.                    
                    <param>
                        observations Sampled observations.                        
                    </param>
                    <throws>
                        NumberIsTooSmallException if the sample is too short.                        
                    </throws>
                    <throws>
                        ZeroException if the abscissa range is zero.                        
                    </throws>
                    <throws>
                        MathIllegalStateException when the guessing procedure cannot
                          produce sensible results.                        
                    </throws>
                </javadoc>
                <method name="ParameterGuesser" type="constructor" line="259">
                    <params>
                        <param name="observations" type="Collection&lt;WeightedObservedPoint&gt;"/>
                    </params>
                    <scope line="260"/>
                    <declaration name="sorted" type="WeightedObservedPoint[]" line="265"/>
                    <declaration name="aOmega" type="double" line="268"/>
                </method>
                <javadoc line="275">
                    Gets an estimation of the parameters.                    
                    <return>
                        the guessed parameters, in the following order:
                          &lt;ul&gt;
                          &lt;li&gt;Amplitude&lt;/li&gt;
                          &lt;li&gt;Angular frequency&lt;/li&gt;
                          &lt;li&gt;Phase&lt;/li&gt;
                          &lt;/ul&gt;                        
                    </return>
                </javadoc>
                <method name="guess" type="double[]" line="285"/>
                <javadoc line="289">
                    Sort the observations with respect to the abscissa.                    
                    <param>
                        unsorted Input observations.                        
                    </param>
                    <return>
                        the input observations, sorted.                        
                    </return>
                </javadoc>
                <method name="sortObservations" type="List&lt;WeightedObservedPoint&gt;" line="295">
                    <params>
                        <param name="unsorted" type="Collection&lt;WeightedObservedPoint&gt;"/>
                    </params>
                    <comment line="299">
                        Since the samples are almost always already sorted, this
                         method is implemented as an insertion sort that reorders the
                         elements in place. Insertion sort is very efficient in this case.                        
                    </comment>
                    <comment line="308">
                        the current element should be inserted closer to the beginning                        
                    </comment>
                    <declaration name="observations" type="List&amp;lt;WeightedObservedPoint&amp;gt;" line="296"/>
                    <declaration name="curr" type="WeightedObservedPoint" line="301"/>
                    <declaration name="len" type="int" line="302"/>
                    <scope line="303">
                        <declaration name="prec" type="WeightedObservedPoint" line="304"/>
                        <scope line="306">
                            <declaration name="i" type="int" line="308"/>
                            <declaration name="mI" type="WeightedObservedPoint" line="309"/>
                            <scope line="310">
                                <scope line="312"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="324">
                    Estimate a first guess of the amplitude and angular frequency.                    
                    <param>
                        observations Observations, sorted w.r.t. abscissa.                        
                    </param>
                    <throws>
                        ZeroException if the abscissa range is zero.                        
                    </throws>
                    <throws>
                        MathIllegalStateException when the guessing procedure cannot
                          produce sensible results.                        
                    </throws>
                    <return>
                        the guessed amplitude (at index 0) and circular frequency
                          (at index 1).                        
                    </return>
                </javadoc>
                <method name="guessAOmega" type="double[]" line="334">
                    <params>
                        <param name="observations" type="WeightedObservedPoint[]"/>
                    </params>
                    <comment line="338">
                        initialize the sums for the linear model between the two integrals                        
                    </comment>
                    <comment line="351">
                        one step forward                        
                    </comment>
                    <comment line="357">
                        update the integrals of f&lt;sup&gt;2&lt;/sup&gt; and f&apos;&lt;sup&gt;2&lt;/sup&gt;
                         considering a linear model for f (and therefore constant f&apos;)                        
                    </comment>
                    <comment line="376">
                        compute the amplitude and pulsation coefficients                        
                    </comment>
                    <comment line="382">
                        Range of the observations, assuming that the
                         observations are sorted.                        
                    </comment>
                    <comment line="404">
                        In some ill-conditioned cases (cf. MATH-844), the guesser
                         procedure cannot produce sensible results.                        
                    </comment>
                    <declaration name="aOmega" type="double[]" line="335"/>
                    <declaration name="sx2" type="double" line="338"/>
                    <declaration name="sy2" type="double" line="339"/>
                    <declaration name="sxy" type="double" line="340"/>
                    <declaration name="sxz" type="double" line="341"/>
                    <declaration name="syz" type="double" line="342"/>
                    <declaration name="currentX" type="double" line="344"/>
                    <declaration name="currentY" type="double" line="345"/>
                    <declaration name="f2Integral" type="double" line="346"/>
                    <declaration name="fPrime2Integral" type="double" line="347"/>
                    <declaration name="startX" type="double" line="348"/>
                    <scope line="349">
                        <declaration name="previousX" type="double" line="351"/>
                        <declaration name="previousY" type="double" line="352"/>
                        <declaration name="dx" type="double" line="358"/>
                        <declaration name="dy" type="double" line="359"/>
                        <declaration name="f2StepIntegral" type="double" line="360"/>
                        <declaration name="fPrime2StepIntegral" type="double" line="362"/>
                        <declaration name="x" type="double" line="364"/>
                    </scope>
                    <declaration name="c1" type="double" line="376"/>
                    <declaration name="c2" type="double" line="377"/>
                    <declaration name="c3" type="double" line="378"/>
                    <scope line="379">
                        <declaration name="last" type="int" line="380"/>
                        <declaration name="xRange" type="double" line="383"/>
                        <scope line="384"/>
                        <declaration name="yMin" type="double" line="389"/>
                        <declaration name="yMax" type="double" line="390"/>
                        <scope line="391">
                            <declaration name="y" type="double" line="392"/>
                            <scope line="393"/>
                            <scope line="396"/>
                        </scope>
                    </scope>
                    <scope line="401">
                        <scope line="402"/>
                    </scope>
                </method>
                <javadoc line="415">
                    Estimate a first guess of the phase.                    
                    <param>
                        observations Observations, sorted w.r.t. abscissa.                        
                    </param>
                    <return>
                        the guessed phase.                        
                    </return>
                </javadoc>
                <method name="guessPhi" type="double" line="421">
                    <params>
                        <param name="observations" type="WeightedObservedPoint[]"/>
                    </params>
                    <comment line="423">
                        initialize the means                        
                    </comment>
                    <comment line="430">
                        one step forward                        
                    </comment>
                    <declaration name="fcMean" type="double" line="423"/>
                    <declaration name="fsMean" type="double" line="424"/>
                    <declaration name="currentX" type="double" line="426"/>
                    <declaration name="currentY" type="double" line="427"/>
                    <scope line="428">
                        <declaration name="previousX" type="double" line="430"/>
                        <declaration name="previousY" type="double" line="431"/>
                        <declaration name="currentYPrime" type="double" line="434"/>
                        <declaration name="omegaX" type="double" line="436"/>
                        <declaration name="cosine" type="double" line="437"/>
                        <declaration name="sine" type="double" line="438"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>