<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.distribution">
        <import package="java.io.Serializable"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.OutOfRangeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.random.RandomGenerator"/>
        <import package="org.apache.commons.math3.random.RandomDataImpl"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="AbstractIntegerDistribution" line="30">
            <implements interface="IntegerDistribution"/>
            <implements interface="Serializable"/>
            <javadoc line="30">
                Base class for integer-valued discrete distributions.  Default
                  implementations are provided for some of the methods that do not vary
                  from distribution to distribution.                
                <version>
                    $Id: AbstractIntegerDistribution.java 1455716 2013-03-12 21:12:21Z tn $                    
                </version>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="39"/>
            <javadoc line="39">
                Serializable version identifier                
            </javadoc>
            <declaration name="randomData" type="RandomDataImpl" line="42"/>
            <javadoc line="42">
                RandomData instance used to generate samples from the distribution.                
                <deprecated>
                    As of 3.1, to be removed in 4.0. Please use the{@link #random} instance variable instead.                    
                </deprecated>
            </javadoc>
            <declaration name="random" type="RandomGenerator" line="50"/>
            <javadoc line="50">
                RNG instance used to generate samples from the distribution.                
                <since>
                    3.1                    
                </since>
            </javadoc>
            <javadoc line="56">
                @deprecated As of 3.1, to be removed in 4.0. Please use{@link #AbstractIntegerDistribution(RandomGenerator)} instead.                
            </javadoc>
            <method name="AbstractIntegerDistribution" type="constructor" line="61">
                <comment line="63">
                    Legacy users are only allowed to access the deprecated &quot;randomData&quot;.
                     New users are forbidden to use this constructor.                    
                </comment>
            </method>
            <javadoc line="67">
                @param rng Random number generator.                
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="AbstractIntegerDistribution" type="constructor" line="71">
                <params>
                    <param name="rng" type="RandomGenerator"/>
                </params>
            </method>
            <javadoc line="75">
                {@inheritDoc}The default implementation uses the identity
                  &lt;p&gt;{@code P(x0 &lt; X &lt;= x1) = P(X &lt;= x1) - P(X &lt;= x0)}&lt;/p&gt;                
            </javadoc>
            <method name="cumulativeProbability" type="double" line="81">
                <params>
                    <param name="x0" type="int"/>
                    <param name="x1" type="int"/>
                </params>
                <scope line="82"/>
            </method>
            <javadoc line="89">
                {@inheritDoc}The default implementation returns
                  &lt;ul&gt;
                  &lt;li&gt;{@link #getSupportLowerBound()} for {@code p = 0},&lt;/li&gt;
                  &lt;li&gt;{@link #getSupportUpperBound()} for {@code p = 1}, and&lt;/li&gt;
                  &lt;li&gt;{@link #solveInverseCumulativeProbability(double,int,int)} for{@code 0 &lt; p &lt; 1}.&lt;/li&gt;
                  &lt;/ul&gt;                
            </javadoc>
            <method name="inverseCumulativeProbability" type="int" line="100">
                <params>
                    <param name="p" type="double"/>
                </params>
                <comment line="115">
                    this ensures cumulativeProbability(lower) &lt; p, which
                     is important for the solving step                    
                </comment>
                <comment line="124">
                    use the one-sided Chebyshev inequality to narrow the bracket
                     cf. AbstractRealDistribution.inverseCumulativeProbability(double)                    
                </comment>
                <scope line="101"/>
                <declaration name="lower" type="int" line="105"/>
                <scope line="106"/>
                <scope line="109">
                    <scope line="110"/>
                </scope>
                <scope line="113"/>
                <declaration name="upper" type="int" line="118"/>
                <scope line="119"/>
                <declaration name="mu" type="double" line="125"/>
                <declaration name="sigma" type="double" line="126"/>
                <declaration name="chebyshevApplies" type="boolean" line="127"/>
                <scope line="129">
                    <declaration name="k" type="double" line="130"/>
                    <declaration name="tmp" type="double" line="131"/>
                    <scope line="132"/>
                    <scope line="137"/>
                </scope>
            </method>
            <javadoc line="145">
                This is a utility function used by {@link #inverseCumulativeProbability(double)}. It assumes {@code 0 &lt; p &lt; 1} and
                  that the inverse cumulative probability lies in the bracket {@code(lower, upper]}. The implementation does simple bisection to find the
                  smallest {@code p}-quantile &lt;code&gt;inf{x in Z | P(X&lt;=x) &gt;= p}&lt;/code&gt;.                
                <param>
                    p the cumulative probability                    
                </param>
                <param>
                    lower a value satisfying {@code cumulativeProbability(lower) &lt; p}                    
                </param>
                <param>
                    upper a value satisfying {@code p &lt;= cumulativeProbability(upper)}                    
                </param>
                <return>
                    the smallest {@code p}-quantile of this distribution                    
                </return>
            </javadoc>
            <method name="solveInverseCumulativeProbability" type="int" line="157">
                <params>
                    <param name="p" type="double"/>
                    <param name="lower" type="int"/>
                    <param name="upper" type="int"/>
                </params>
                <comment line="162">
                    Overflow.
                     There will never be an overflow in both calculation methods
                     for xm at the same time                    
                </comment>
                <scope line="158">
                    <declaration name="xm" type="int" line="159"/>
                    <scope line="160"/>
                    <declaration name="pm" type="double" line="169"/>
                    <scope line="170"/>
                    <scope line="172"/>
                </scope>
            </method>
            <javadoc line="179">
                {@inheritDoc}                
            </javadoc>
            <method name="reseedRandomGenerator" type="void" line="180">
                <params>
                    <param name="seed" type="long"/>
                </params>
            </method>
            <javadoc line="185">
                {@inheritDoc}The default implementation uses the
                  &lt;a href=&quot;http://en.wikipedia.org/wiki/Inverse_transform_sampling&quot;&gt;
                  inversion method&lt;/a&gt;.                
            </javadoc>
            <method name="sample" type="int" line="192"/>
            <javadoc line="196">
                {@inheritDoc}The default implementation generates the sample by calling{@link #sample()} in a loop.                
            </javadoc>
            <method name="sample" type="int[]" line="202">
                <params>
                    <param name="sampleSize" type="int"/>
                </params>
                <scope line="203"/>
                <declaration name="out" type="int[]" line="207"/>
                <scope line="208"/>
            </method>
            <javadoc line="214">
                Computes the cumulative probability function and checks for {@code NaN}values returned. Throws {@code MathInternalError} if the value is{@code NaN}. Rethrows any exception encountered evaluating the cumulative
                  probability function. Throws {@code MathInternalError} if the cumulative
                  probability function returns {@code NaN}.                
                <param>
                    argument input value                    
                </param>
                <return>
                    the cumulative probability                    
                </return>
                <throws>
                    MathInternalError if the cumulative probability is {@code NaN}                    
                </throws>
            </javadoc>
            <method name="checkedCumulativeProbability" type="double" line="226">
                <params>
                    <param name="argument" type="int"/>
                </params>
                <declaration name="result" type="double" line="227"/>
                <scope line="229"/>
            </method>
        </class>
    </source>