<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar">
        <import package="org.apache.commons.math3.analysis.MultivariateFunction"/>
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.analysis.function.Logit"/>
        <import package="org.apache.commons.math3.analysis.function.Sigmoid"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="MultivariateFunctionMappingAdapter" line="10">
            <implements interface="MultivariateFunction"/>
            <javadoc line="10">
                &lt;p&gt;Adapter for mapping bounded {@link MultivariateFunction} to unbounded ones.&lt;/p&gt;
                  &lt;p&gt;
                  This adapter can be used to wrap functions subject to simple bounds on
                  parameters so they can be used by optimizers that do &lt;em&gt;not&lt;/em&gt; directly
                  support simple bounds.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The principle is that the user function that will be wrapped will see its
                  parameters bounded as required, i.e when its {@code value} method is called
                  with argument array {@code point}, the elements array will fulfill requirement{@code lower[i] &lt;= point[i] &lt;= upper[i]} for all i. Some of the components
                  may be unbounded or bounded only on one side if the corresponding bound is
                  set to an infinite value. The optimizer will not manage the user function by
                  itself, but it will handle this adapter and it is this adapter that will take
                  care the bounds are fulfilled. The adapter {@link #value(double[])} method will
                  be called by the optimizer with unbound parameters, and the adapter will map
                  the unbounded value to the bounded range using appropriate functions like{@link Sigmoid} for double bounded elements for example.
                  &lt;/p&gt;
                  &lt;p&gt;
                  As the optimizer sees only unbounded parameters, it should be noted that the
                  start point or simplex expected by the optimizer should be unbounded, so the
                  user is responsible for converting his bounded point to unbounded by calling{@link #boundedToUnbounded(double[])} before providing them to the optimizer.
                  For the same reason, the point returned by the {@link org.apache.commons.math3.optimization.BaseMultivariateOptimizer#optimize(int,MultivariateFunction,org.apache.commons.math3.optimization.GoalType,double[])}method is unbounded. So to convert this point to bounded, users must call{@link #unboundedToBounded(double[])} by themselves!&lt;/p&gt;
                  &lt;p&gt;
                  This adapter is only a poor man solution to simple bounds optimization constraints
                  that can be used with simple optimizers like{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerSimplexOptimizer}.
                  A better solution is to use an optimizer that directly supports simple bounds like{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerCMAESOptimizer} or{@link org.apache.commons.math3.optim.nonlinear.scalar.noderiv.BOBYQAOptimizerBOBYQAOptimizer}.
                  One caveat of this poor-man&apos;s solution is that behavior near the bounds may be
                  numerically unstable as bounds are mapped from infinite values.
                  Another caveat is that convergence values are evaluated by the optimizer with
                  respect to unbounded variables, so there will be scales differences when
                  converted to bounded variables.
                  &lt;/p&gt;                
                <see>
                    MultivariateFunctionPenaltyAdapter                    
                </see>
                <version>
                    $Id: MultivariateFunctionMappingAdapter.java 1435539 2013-01-19 13:27:24Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="bounded" type="MultivariateFunction" line="48"/>
            <javadoc line="48">
                Underlying bounded function.                
            </javadoc>
            <declaration name="mappers" type="Mapper[]" line="52"/>
            <javadoc line="52">
                Mapping functions.                
            </javadoc>
            <javadoc line="56">
                Simple constructor.                
                <param>
                    bounded bounded function                    
                </param>
                <param>
                    lower lower bounds for each element of the input parameters array
                      (some elements may be set to {@code Double.NEGATIVE_INFINITY} for
                      unbounded values)                    
                </param>
                <param>
                    upper upper bounds for each element of the input parameters array
                      (some elements may be set to {@code Double.POSITIVE_INFINITY} for
                      unbounded values)                    
                </param>
                <exception>
                    DimensionMismatchException if lower and upper bounds are not
                      consistent, either according to dimension or to values                    
                </exception>
            </javadoc>
            <method name="MultivariateFunctionMappingAdapter" type="constructor" line="68">
                <params>
                    <param name="bounded" type="MultivariateFunction"/>
                    <param name="lower" type="double[]"/>
                    <param name="upper" type="double[]"/>
                </params>
                <scope line="71"/>
                <scope line="74">
                    <scope line="75"/>
                </scope>
                <scope line="81">
                    <scope line="82">
                        <scope line="83"/>
                        <scope line="86"/>
                    </scope>
                    <scope line="90">
                        <scope line="91"/>
                        <scope line="94"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="100">
                Maps an array from unbounded to bounded.                
                <param>
                    point Unbounded values.                    
                </param>
                <return>
                    the bounded values.                    
                </return>
            </javadoc>
            <method name="unboundedToBounded" type="double[]" line="105">
                <params>
                    <param name="point" type="double[]"/>
                </params>
                <declaration name="mapped" type="double[]" line="106"/>
                <scope line="107"/>
            </method>
            <javadoc line="112">
                Maps an array from bounded to unbounded.                
                <param>
                    point Bounded values.                    
                </param>
                <return>
                    the unbounded values.                    
                </return>
            </javadoc>
            <method name="boundedToUnbounded" type="double[]" line="117">
                <params>
                    <param name="point" type="double[]"/>
                </params>
                <declaration name="mapped" type="double[]" line="118"/>
                <scope line="119"/>
            </method>
            <javadoc line="124">
                Compute the underlying function value from an unbounded point.
                  &lt;p&gt;
                  This method simply bounds the unbounded point using the mappings
                  set up at construction and calls the underlying function using
                  the bounded point.
                  &lt;/p&gt;                
                <param>
                    point unbounded value                    
                </param>
                <return>
                    underlying function value                    
                </return>
                <see>
                    #unboundedToBounded(double[])                    
                </see>
            </javadoc>
            <method name="value" type="double" line="135">
                <params>
                    <param name="point" type="double[]"/>
                </params>
            </method>
            <interface name="Mapper">
                <javadoc line="138">
                    Mapping interface.                    
                </javadoc>
                <method name="unboundedToBounded" type="double" line="142"/>
                <javadoc line="142">
                    Maps a value from unbounded to bounded.                    
                    <param>
                        y Unbounded value.                        
                    </param>
                    <return>
                        the bounded value.                        
                    </return>
                </javadoc>
                <method name="boundedToUnbounded" type="double" line="148"/>
                <javadoc line="148">
                    Maps a value from bounded to unbounded.                    
                    <param>
                        x Bounded value.                        
                    </param>
                    <return>
                        the unbounded value.                        
                    </return>
                </javadoc>
            </interface>
            <class name="NoBoundsMapper" line="155">
                <implements interface="Mapper"/>
                <javadoc line="155">
                    Local class for no bounds mapping.                    
                </javadoc>
                <javadoc line="159">
                    {@inheritDoc}                    
                </javadoc>
                <method name="unboundedToBounded" type="double" line="162">
                    <params>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="165">
                    {@inheritDoc}                    
                </javadoc>
                <method name="boundedToUnbounded" type="double" line="168">
                    <params>
                        <param name="x" type="double"/>
                    </params>
                </method>
            </class>
            <class name="LowerBoundMapper" line="172">
                <implements interface="Mapper"/>
                <javadoc line="172">
                    Local class for lower bounds mapping.                    
                </javadoc>
                <declaration name="lower" type="double" line="176"/>
                <javadoc line="176">
                    Low bound.                    
                </javadoc>
                <javadoc line="180">
                    Simple constructor.                    
                    <param>
                        lower lower bound                        
                    </param>
                </javadoc>
                <method name="LowerBoundMapper" type="constructor" line="184">
                    <params>
                        <param name="lower" type="double"/>
                    </params>
                </method>
                <javadoc line="187">
                    {@inheritDoc}                    
                </javadoc>
                <method name="unboundedToBounded" type="double" line="190">
                    <params>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="193">
                    {@inheritDoc}                    
                </javadoc>
                <method name="boundedToUnbounded" type="double" line="196">
                    <params>
                        <param name="x" type="double"/>
                    </params>
                </method>
            </class>
            <class name="UpperBoundMapper" line="200">
                <implements interface="Mapper"/>
                <javadoc line="200">
                    Local class for upper bounds mapping.                    
                </javadoc>
                <declaration name="upper" type="double" line="204"/>
                <javadoc line="204">
                    Upper bound.                    
                </javadoc>
                <javadoc line="208">
                    Simple constructor.                    
                    <param>
                        upper upper bound                        
                    </param>
                </javadoc>
                <method name="UpperBoundMapper" type="constructor" line="212">
                    <params>
                        <param name="upper" type="double"/>
                    </params>
                </method>
                <javadoc line="215">
                    {@inheritDoc}                    
                </javadoc>
                <method name="unboundedToBounded" type="double" line="218">
                    <params>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="221">
                    {@inheritDoc}                    
                </javadoc>
                <method name="boundedToUnbounded" type="double" line="224">
                    <params>
                        <param name="x" type="double"/>
                    </params>
                </method>
            </class>
            <class name="LowerUpperBoundMapper" line="228">
                <implements interface="Mapper"/>
                <javadoc line="228">
                    Local class for lower and bounds mapping.                    
                </javadoc>
                <declaration name="boundingFunction" type="UnivariateFunction" line="232"/>
                <javadoc line="232">
                    Function from unbounded to bounded.                    
                </javadoc>
                <declaration name="unboundingFunction" type="UnivariateFunction" line="236"/>
                <javadoc line="236">
                    Function from bounded to unbounded.                    
                </javadoc>
                <javadoc line="240">
                    Simple constructor.                    
                    <param>
                        lower lower bound                        
                    </param>
                    <param>
                        upper upper bound                        
                    </param>
                </javadoc>
                <method name="LowerUpperBoundMapper" type="constructor" line="245">
                    <params>
                        <param name="lower" type="double"/>
                        <param name="upper" type="double"/>
                    </params>
                </method>
                <javadoc line="249">
                    {@inheritDoc}                    
                </javadoc>
                <method name="unboundedToBounded" type="double" line="252">
                    <params>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="255">
                    {@inheritDoc}                    
                </javadoc>
                <method name="boundedToUnbounded" type="double" line="258">
                    <params>
                        <param name="x" type="double"/>
                    </params>
                </method>
            </class>
        </class>
    </source>