<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.ode.sampling">
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInput"/>
        <import package="java.io.ObjectOutput"/>
        <import package="org.apache.commons.math3.exception.MaxCountExceededException"/>
        <import package="org.apache.commons.math3.ode.EquationsMapper"/>
        <class name="AbstractStepInterpolator" line="27">
            <implements interface="StepInterpolator"/>
            <javadoc line="27">
                This abstract class represents an interpolator over the last step
                  during an ODE integration.
                  &lt;p&gt;The various ODE integrators provide objects extending this class
                  to the step handlers. The handlers can use these objects to
                  retrieve the state vector at intermediate times between the
                  previous and the current grid points (dense output).&lt;/p&gt;                
                <see>
                    org.apache.commons.math3.ode.FirstOrderIntegrator                    
                </see>
                <see>
                    org.apache.commons.math3.ode.SecondOrderIntegrator                    
                </see>
                <see>
                    StepHandler                    
                </see>
                <version>
                    $Id: AbstractStepInterpolator.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="h" type="double" line="47"/>
            <javadoc line="47">
                current time step                
            </javadoc>
            <declaration name="currentState" type="double[]" line="50"/>
            <javadoc line="50">
                current state                
            </javadoc>
            <declaration name="interpolatedTime" type="double" line="53"/>
            <javadoc line="53">
                interpolated time                
            </javadoc>
            <declaration name="interpolatedState" type="double[]" line="56"/>
            <javadoc line="56">
                interpolated state                
            </javadoc>
            <declaration name="interpolatedDerivatives" type="double[]" line="59"/>
            <javadoc line="59">
                interpolated derivatives                
            </javadoc>
            <declaration name="interpolatedPrimaryState" type="double[]" line="62"/>
            <javadoc line="62">
                interpolated primary state                
            </javadoc>
            <declaration name="interpolatedPrimaryDerivatives" type="double[]" line="65"/>
            <javadoc line="65">
                interpolated primary derivatives                
            </javadoc>
            <declaration name="interpolatedSecondaryState" type="double[][]" line="68"/>
            <javadoc line="68">
                interpolated secondary state                
            </javadoc>
            <declaration name="interpolatedSecondaryDerivatives" type="double[][]" line="71"/>
            <javadoc line="71">
                interpolated secondary derivatives                
            </javadoc>
            <declaration name="globalPreviousTime" type="double" line="74"/>
            <javadoc line="74">
                global previous time                
            </javadoc>
            <declaration name="globalCurrentTime" type="double" line="77"/>
            <javadoc line="77">
                global current time                
            </javadoc>
            <declaration name="softPreviousTime" type="double" line="80"/>
            <javadoc line="80">
                soft previous time                
            </javadoc>
            <declaration name="softCurrentTime" type="double" line="83"/>
            <javadoc line="83">
                soft current time                
            </javadoc>
            <declaration name="finalized" type="boolean" line="86"/>
            <javadoc line="86">
                indicate if the step has been finalized or not.                
            </javadoc>
            <declaration name="forward" type="boolean" line="89"/>
            <javadoc line="89">
                integration direction.                
            </javadoc>
            <declaration name="dirtyState" type="boolean" line="92"/>
            <javadoc line="92">
                indicator for dirty state.                
            </javadoc>
            <declaration name="primaryMapper" type="EquationsMapper" line="95"/>
            <javadoc line="95">
                Equations mapper for the primary equations set.                
            </javadoc>
            <declaration name="secondaryMappers" type="EquationsMapper[]" line="98"/>
            <javadoc line="98">
                Equations mappers for the secondary equations sets.                
            </javadoc>
            <javadoc line="101">
                Simple constructor.
                  This constructor builds an instance that is not usable yet, the{@link #reinitialize} method should be called before using the
                  instance in order to initialize the internal arrays. This
                  constructor is used only in order to delay the initialization in
                  some cases. As an example, the {@link org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator}class uses the prototyping design pattern to create the step
                  interpolators by cloning an uninitialized model and latter
                  initializing the copy.                
            </javadoc>
            <method name="AbstractStepInterpolator" type="constructor" line="112"/>
            <javadoc line="128">
                Simple constructor.                
                <param>
                    y reference to the integrator array holding the state at
                      the end of the step                    
                </param>
                <param>
                    forward integration direction indicator                    
                </param>
                <param>
                    primaryMapper equations mapper for the primary equations set                    
                </param>
                <param>
                    secondaryMappers equations mappers for the secondary equations sets                    
                </param>
            </javadoc>
            <method name="AbstractStepInterpolator" type="constructor" line="137">
                <params>
                    <param name="y" type="double[]"/>
                    <param name="forward" type="boolean"/>
                    <param name="primaryMapper" type="EquationsMapper"/>
                    <param name="secondaryMappers" type="EquationsMapper[]"/>
                </params>
            </method>
            <javadoc line="155">
                Copy constructor.
                  &lt;p&gt;The copied interpolator should have been finalized before the
                  copy, otherwise the copy will not be able to perform correctly
                  any derivative computation and will throw a {@link NullPointerException} later. Since we don&apos;t want this constructor
                  to throw the exceptions finalization may involve and since we
                  don&apos;t want this method to modify the state of the copied
                  interpolator, finalization is &lt;strong&gt;not&lt;/strong&gt; done
                  automatically, it remains under user control.&lt;/p&gt;
                  &lt;p&gt;The copy is a deep copy: its arrays are separated from the
                  original arrays of the instance.&lt;/p&gt;                
                <param>
                    interpolator interpolator to copy from.                    
                </param>
            </javadoc>
            <method name="AbstractStepInterpolator" type="constructor" line="172">
                <params>
                    <param name="interpolator" type="AbstractStepInterpolator"/>
                </params>
                <scope line="181"/>
                <scope line="186">
                    <scope line="194"/>
                </scope>
            </method>
            <javadoc line="209">
                Allocate the various interpolated states arrays.                
                <param>
                    dimension total dimension (negative if arrays should be set to null)                    
                </param>
            </javadoc>
            <method name="allocateInterpolatedArrays" type="void" line="212">
                <params>
                    <param name="dimension" type="int"/>
                </params>
                <scope line="213"/>
                <scope line="220">
                    <scope line="225"/>
                    <scope line="228">
                        <scope line="231"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="239">
                Reinitialize the instance                
                <param>
                    y reference to the integrator array holding the state at the end of the step                    
                </param>
                <param>
                    isForward integration direction indicator                    
                </param>
                <param>
                    primary equations mapper for the primary equations set                    
                </param>
                <param>
                    secondary equations mappers for the secondary equations sets                    
                </param>
            </javadoc>
            <method name="reinitialize" type="void" line="247">
                <params>
                    <param name="y" type="double[]"/>
                    <param name="isForward" type="boolean"/>
                    <param name="primary" type="EquationsMapper"/>
                    <param name="secondary" type="EquationsMapper[]"/>
                </params>
            </method>
            <javadoc line="265">
                {@inheritDoc}                
            </javadoc>
            <method name="copy" type="StepInterpolator" line="266">
                <comment line="269">
                    finalize the step before performing copy                    
                </comment>
                <comment line="272">
                    create the new independent instance                    
                </comment>
            </method>
            <method name="doCopy" type="StepInterpolator" line="276"/>
            <javadoc line="276">
                Really copy the finalized instance.
                  &lt;p&gt;This method is called by {@link #copy()} after the
                  step has been finalized. It must perform a deep copy
                  to have an new instance completely independent for the
                  original instance.                
                <return>
                    a copy of the finalized instance                    
                </return>
            </javadoc>
            <javadoc line="285">
                Shift one step forward.
                  Copy the current time into the previous time, hence preparing the
                  interpolator for future calls to {@link #storeTime storeTime}                
            </javadoc>
            <method name="shift" type="void" line="289"/>
            <javadoc line="295">
                Store the current step time.                
                <param>
                    t current time                    
                </param>
            </javadoc>
            <method name="storeTime" type="void" line="298">
                <params>
                    <param name="t" type="double"/>
                </params>
                <comment line="306">
                    the step is not finalized anymore                    
                </comment>
            </method>
            <javadoc line="310">
                Restrict step range to a limited part of the global step.
                  &lt;p&gt;
                  This method can be used to restrict a step and make it appear
                  as if the original step was smaller. Calling this method
                  &lt;em&gt;only&lt;/em&gt; changes the value returned by {@link #getPreviousTime()},
                  it does not change any other property
                  &lt;/p&gt;                
                <param>
                    softPreviousTime start of the restricted step                    
                </param>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="setSoftPreviousTime" type="void" line="320">
                <params>
                    <param name="softPreviousTime" type="double"/>
                </params>
            </method>
            <javadoc line="324">
                Restrict step range to a limited part of the global step.
                  &lt;p&gt;
                  This method can be used to restrict a step and make it appear
                  as if the original step was smaller. Calling this method
                  &lt;em&gt;only&lt;/em&gt; changes the value returned by {@link #getCurrentTime()},
                  it does not change any other property
                  &lt;/p&gt;                
                <param>
                    softCurrentTime end of the restricted step                    
                </param>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="setSoftCurrentTime" type="void" line="334">
                <params>
                    <param name="softCurrentTime" type="double"/>
                </params>
            </method>
            <javadoc line="338">
                Get the previous global grid point time.                
                <return>
                    previous global grid point time                    
                </return>
            </javadoc>
            <method name="getGlobalPreviousTime" type="double" line="342"/>
            <javadoc line="346">
                Get the current global grid point time.                
                <return>
                    current global grid point time                    
                </return>
            </javadoc>
            <method name="getGlobalCurrentTime" type="double" line="350"/>
            <javadoc line="354">
                Get the previous soft grid point time.                
                <return>
                    previous soft grid point time                    
                </return>
                <see>
                    #setSoftPreviousTime(double)                    
                </see>
            </javadoc>
            <method name="getPreviousTime" type="double" line="359"/>
            <javadoc line="363">
                Get the current soft grid point time.                
                <return>
                    current soft grid point time                    
                </return>
                <see>
                    #setSoftCurrentTime(double)                    
                </see>
            </javadoc>
            <method name="getCurrentTime" type="double" line="368"/>
            <javadoc line="372">
                {@inheritDoc}                
            </javadoc>
            <method name="getInterpolatedTime" type="double" line="373"/>
            <javadoc line="377">
                {@inheritDoc}                
            </javadoc>
            <method name="setInterpolatedTime" type="void" line="378">
                <params>
                    <param name="time" type="double"/>
                </params>
            </method>
            <javadoc line="383">
                {@inheritDoc}                
            </javadoc>
            <method name="isForward" type="boolean" line="384"/>
            <method name="computeInterpolatedStateAndDerivatives" type="void" line="388"/>
            <javadoc line="388">
                Compute the state and derivatives at the interpolated time.
                  This is the main processing method that should be implemented by
                  the derived classes to perform the interpolation.                
                <param>
                    theta normalized interpolation abscissa within the step
                      (theta is zero at the previous time step and one at the current time step)                    
                </param>
                <param>
                    oneMinusThetaH time gap between the interpolated time and
                      the current time                    
                </param>
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded                    
                </exception>
            </javadoc>
            <javadoc line="401">
                Lazy evaluation of complete interpolated state.                
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded                    
                </exception>
            </javadoc>
            <method name="evaluateCompleteInterpolatedState" type="void" line="405">
                <comment line="407">
                    lazy evaluation of the state                    
                </comment>
                <scope line="407">
                    <declaration name="oneMinusThetaH" type="double" line="408"/>
                    <declaration name="theta" type="double" line="409"/>
                </scope>
            </method>
            <javadoc line="415">
                {@inheritDoc}                
            </javadoc>
            <method name="getInterpolatedState" type="double[]" line="416"/>
            <javadoc line="423">
                {@inheritDoc}                
            </javadoc>
            <method name="getInterpolatedDerivatives" type="double[]" line="424"/>
            <javadoc line="431">
                {@inheritDoc}                
            </javadoc>
            <method name="getInterpolatedSecondaryState" type="double[]" line="432">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="439">
                {@inheritDoc}                
            </javadoc>
            <method name="getInterpolatedSecondaryDerivatives" type="double[]" line="440">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="447">
                Finalize the step.
                  &lt;p&gt;Some embedded Runge-Kutta integrators need fewer functions
                  evaluations than their counterpart step interpolators. These
                  interpolators should perform the last evaluations they need by
                  themselves only if they need them. This method triggers these
                  extra evaluations. It can be called directly by the user step
                  handler and it is called automatically if {@link #setInterpolatedTime} is called.&lt;/p&gt;
                  &lt;p&gt;Once this method has been called, &lt;strong&gt;no&lt;/strong&gt; other
                  evaluation will be performed on this step. If there is a need to
                  have some side effects between the step handler and the
                  differential equations (for example update some data in the
                  equations once the step has been done), it is advised to call
                  this method explicitly from the step handler before these side
                  effects are set up. If the step handler induces no side effect,
                  then this method can safely be ignored, it will be called
                  transparently as needed.&lt;/p&gt;
                  &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: since the step interpolator provided
                  to the step handler as a parameter of the {@link StepHandler#handleStep handleStep} is valid only for the duration
                  of the {@link StepHandler#handleStep handleStep} call, one cannot
                  simply store a reference and reuse it later. One should first
                  finalize the instance, then copy this finalized instance into a
                  new object that can be kept.&lt;/p&gt;
                  &lt;p&gt;This method calls the protected &lt;code&gt;doFinalize&lt;/code&gt; method
                  if it has never been called during this step and set a flag
                  indicating that it has been called once. It is the &lt;code&gt;
                  doFinalize&lt;/code&gt; method which should perform the evaluations.
                  This wrapping prevents from calling &lt;code&gt;doFinalize&lt;/code&gt; several
                  times and hence evaluating the differential equations too often.
                  Therefore, subclasses are not allowed not reimplement it, they
                  should rather reimplement &lt;code&gt;doFinalize&lt;/code&gt;.&lt;/p&gt;                
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded                    
                </exception>
            </javadoc>
            <method name="finalizeStep" type="void" line="488">
                <scope line="489"/>
            </method>
            <javadoc line="495">
                Really finalize the step.
                  The default implementation of this method does nothing.                
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded                    
                </exception>
            </javadoc>
            <method name="doFinalize" type="void" line="500"/>
            <method name="writeExternal" type="void" line="503"/>
            <javadoc line="503">
                {@inheritDoc}                
            </javadoc>
            <method name="readExternal" type="void" line="507"/>
            <javadoc line="507">
                {@inheritDoc}                
            </javadoc>
            <javadoc line="511">
                Save the base state of the instance.
                  This method performs step finalization if it has not been done
                  before.                
                <param>
                    out stream where to save the state                    
                </param>
                <exception>
                    IOException in case of write error                    
                </exception>
            </javadoc>
            <method name="writeBaseExternal" type="void" line="518">
                <params>
                    <param name="out" type="ObjectOutput"/>
                </params>
                <comment line="546">
                    we do not store the interpolated state,
                     it will be recomputed as needed after reading                    
                </comment>
                <comment line="550">
                    finalize the step (and don&apos;t bother saving the now true flag)                    
                </comment>
                <scope line="520"/>
                <scope line="522"/>
                <scope line="533"/>
                <scope line="537">
                    <scope line="538"/>
                </scope>
                <scope line="548"/>
                <scope line="551">
                    <declaration name="ioe" type="IOException" line="552"/>
                </scope>
            </method>
            <javadoc line="559">
                Read the base state of the instance.
                  This method does &lt;strong&gt;neither&lt;/strong&gt; set the interpolated
                  time nor state. It is up to the derived class to reset it
                  properly calling the {@link #setInterpolatedTime} method later,
                  once all rest of the object state has been set up properly.                
                <param>
                    in stream where to read the state from                    
                </param>
                <return>
                    interpolated time to be set later by the caller                    
                </return>
                <exception>
                    IOException in case of read error                    
                </exception>
                <exception>
                    ClassNotFoundException if an equation mapper class
                      cannot be found                    
                </exception>
            </javadoc>
            <method name="readBaseExternal" type="double" line="571">
                <params>
                    <param name="in" type="ObjectInput"/>
                </params>
                <comment line="597">
                    we do NOT handle the interpolated time and state here                    
                </comment>
                <declaration name="dimension" type="int" line="573"/>
                <scope line="582"/>
                <scope line="587"/>
                <scope line="589">
                    <scope line="591"/>
                </scope>
            </method>
        </class>
    </source>