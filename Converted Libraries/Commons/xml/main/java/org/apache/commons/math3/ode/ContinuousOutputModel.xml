<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.ode">
        <import package="java.io.Serializable"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.MaxCountExceededException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.ode.sampling.StepHandler"/>
        <import package="org.apache.commons.math3.ode.sampling.StepInterpolator"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="ContinuousOutputModel" line="32">
            <implements interface="StepHandler"/>
            <implements interface="Serializable"/>
            <javadoc line="32">
                This class stores all information provided by an ODE integrator
                  during the integration process and build a continuous model of the
                  solution from this.
                  &lt;p&gt;This class act as a step handler from the integrator point of
                  view. It is called iteratively during the integration process and
                  stores a copy of all steps information in a sorted collection for
                  later use. Once the integration process is over, the user can use
                  the {@link #setInterpolatedTime setInterpolatedTime} and {@link #getInterpolatedState getInterpolatedState} to retrieve this
                  information at any time. It is important to wait for the
                  integration to be over before attempting to call {@link #setInterpolatedTime setInterpolatedTime} because some internal
                  variables are set only once the last step has been handled.&lt;/p&gt;
                  &lt;p&gt;This is useful for example if the main loop of the user
                  application should remain independent from the integration process
                  or if one needs to mimic the behaviour of an analytical model
                  despite a numerical model is used (i.e. one needs the ability to
                  get the model value at any time or to navigate through the
                  data).&lt;/p&gt;
                  &lt;p&gt;If problem modeling is done with several separate
                  integration phases for contiguous intervals, the same
                  ContinuousOutputModel can be used as step handler for all
                  integration phases as long as they are performed in order and in
                  the same direction. As an example, one can extrapolate the
                  trajectory of a satellite with one model (i.e. one set of
                  differential equations) up to the beginning of a maneuver, use
                  another more complex model including thrusters modeling and
                  accurate attitude control during the maneuver, and revert to the
                  first model after the end of the maneuver. If the same continuous
                  output model handles the steps of all integration phases, the user
                  do not need to bother when the maneuver begins or ends, he has all
                  the data available in a transparent manner.&lt;/p&gt;
                  &lt;p&gt;An important feature of this class is that it implements the
                  &lt;code&gt;Serializable&lt;/code&gt; interface. This means that the result of
                  an integration can be serialized and reused later (if stored into a
                  persistent medium like a filesystem or a database) or elsewhere (if
                  sent to another application). Only the result of the integration is
                  stored, there is no reference to the integrated problem by
                  itself.&lt;/p&gt;
                  &lt;p&gt;One should be aware that the amount of data stored in a
                  ContinuousOutputModel instance can be important if the state vector
                  is large, if the integration interval is long or if the steps are
                  small (which can result from small tolerance settings in {@link org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator adaptive
                  step size integrators}).&lt;/p&gt;                
                <see>
                    StepHandler                    
                </see>
                <see>
                    StepInterpolator                    
                </see>
                <version>
                    $Id: ContinuousOutputModel.java 1463684 2013-04-02 19:04:13Z luc $                    
                </version>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="93"/>
            <javadoc line="93">
                Serializable version identifier                
            </javadoc>
            <declaration name="initialTime" type="double" line="96"/>
            <javadoc line="96">
                Initial integration time.                
            </javadoc>
            <declaration name="finalTime" type="double" line="99"/>
            <javadoc line="99">
                Final integration time.                
            </javadoc>
            <declaration name="forward" type="boolean" line="102"/>
            <javadoc line="102">
                Integration direction indicator.                
            </javadoc>
            <declaration name="index" type="int" line="105"/>
            <javadoc line="105">
                Current interpolator index.                
            </javadoc>
            <declaration name="steps" type="List&lt;StepInterpolator&gt;" line="108"/>
            <javadoc line="108">
                Steps table.                
            </javadoc>
            <javadoc line="111">
                Simple constructor.
                  Build an empty continuous output model.                
            </javadoc>
            <method name="ContinuousOutputModel" type="constructor" line="114"/>
            <javadoc line="122">
                Append another model at the end of the instance.                
                <param>
                    model model to add at the end of the instance                    
                </param>
                <exception>
                    MathIllegalArgumentException if the model to append is not
                      compatible with the instance (dimension of the state vector,
                      propagation direction, hole between the dates)                    
                </exception>
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded
                      during step finalization                    
                </exception>
            </javadoc>
            <method name="append" type="void" line="131">
                <params>
                    <param name="model" type="ContinuousOutputModel"/>
                </params>
                <scope line="133"/>
                <scope line="137"/>
                <scope line="140">
                    <scope line="142"/>
                    <scope line="147"/>
                    <declaration name="lastInterpolator" type="StepInterpolator" line="151"/>
                    <declaration name="current" type="double" line="152"/>
                    <declaration name="previous" type="double" line="153"/>
                    <declaration name="step" type="double" line="154"/>
                    <declaration name="gap" type="double" line="155"/>
                    <scope line="156"/>
                </scope>
                <scope line="163"/>
            </method>
            <javadoc line="172">
                {@inheritDoc}                
            </javadoc>
            <method name="init" type="void" line="173">
                <params>
                    <param name="t0" type="double"/>
                    <param name="y0" type="double[]"/>
                    <param name="t" type="double"/>
                </params>
            </method>
            <javadoc line="181">
                Handle the last accepted step.
                  A copy of the information provided by the last step is stored in
                  the instance for later use.                
                <param>
                    interpolator interpolator for the last accepted step.                    
                </param>
                <param>
                    isLast true if the step is the last one                    
                </param>
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded
                      during step finalization                    
                </exception>
            </javadoc>
            <method name="handleStep" type="void" line="190">
                <params>
                    <param name="interpolator" type="StepInterpolator"/>
                    <param name="isLast" type="boolean"/>
                </params>
                <scope line="192"/>
                <scope line="199"/>
            </method>
            <javadoc line="206">
                Get the initial integration time.                
                <return>
                    initial integration time                    
                </return>
            </javadoc>
            <method name="getInitialTime" type="double" line="210"/>
            <javadoc line="214">
                Get the final integration time.                
                <return>
                    final integration time                    
                </return>
            </javadoc>
            <method name="getFinalTime" type="double" line="218"/>
            <javadoc line="222">
                Get the time of the interpolated point.
                  If {@link #setInterpolatedTime} has not been called, it returns
                  the final integration time.                
                <return>
                    interpolation point time                    
                </return>
            </javadoc>
            <method name="getInterpolatedTime" type="double" line="228"/>
            <javadoc line="232">
                Set the time of the interpolated point.
                  &lt;p&gt;This method should &lt;strong&gt;not&lt;/strong&gt; be called before the
                  integration is over because some internal variables are set only
                  once the last step has been handled.&lt;/p&gt;
                  &lt;p&gt;Setting the time outside of the integration interval is now
                  allowed (it was not allowed up to version 5.9 of Mantissa), but
                  should be used with care since the accuracy of the interpolator
                  will probably be very poor far from this interval. This allowance
                  has been added to simplify implementation of search algorithms
                  near the interval endpoints.&lt;/p&gt;                
                <param>
                    time time of the interpolated point                    
                </param>
            </javadoc>
            <method name="setInterpolatedTime" type="void" line="244">
                <params>
                    <param name="time" type="double"/>
                </params>
                <comment line="247">
                    initialize the search with the complete steps table                    
                </comment>
                <comment line="256">
                    handle points outside of the integration interval
                     or in the first and last step                    
                </comment>
                <comment line="269">
                    reduction of the table slice size                    
                </comment>
                <comment line="272">
                    use the last estimated index as the splitting index                    
                </comment>
                <comment line="282">
                    we have found the target step, no need to continue searching                    
                </comment>
                <comment line="287">
                    compute a new estimate of the index in the reduced table slice                    
                </comment>
                <comment line="293">
                    too close to the bounds, we estimate using a simple dichotomy                    
                </comment>
                <comment line="296">
                    estimate the index using a reverse quadratic polynom
                     (reverse means we have i = P(t), thus allowing to simply
                     compute index = P(time) rather than solving a quadratic equation)                    
                </comment>
                <comment line="312">
                    force the next size reduction to be at least one tenth                    
                </comment>
                <comment line="323">
                    now the table slice is very small, we perform an iterative search                    
                </comment>
                <declaration name="iMin" type="int" line="247"/>
                <declaration name="sMin" type="StepInterpolator" line="248"/>
                <declaration name="tMin" type="double" line="249"/>
                <declaration name="iMax" type="int" line="251"/>
                <declaration name="sMax" type="StepInterpolator" line="252"/>
                <declaration name="tMax" type="double" line="253"/>
                <scope line="257"/>
                <scope line="262"/>
                <scope line="269">
                    <declaration name="si" type="StepInterpolator" line="272"/>
                    <declaration name="location" type="int" line="273"/>
                    <scope line="274"/>
                    <scope line="277"/>
                    <scope line="280"/>
                    <declaration name="iMed" type="int" line="287"/>
                    <declaration name="sMed" type="StepInterpolator" line="288"/>
                    <declaration name="tMed" type="double" line="289"/>
                    <scope line="291"/>
                    <scope line="294">
                        <declaration name="d12" type="double" line="298"/>
                        <declaration name="d23" type="double" line="299"/>
                        <declaration name="d13" type="double" line="300"/>
                        <declaration name="dt1" type="double" line="301"/>
                        <declaration name="dt2" type="double" line="302"/>
                        <declaration name="dt3" type="double" line="303"/>
                        <declaration name="iLagrange" type="double" line="304"/>
                    </scope>
                    <declaration name="low" type="int" line="312"/>
                    <declaration name="high" type="int" line="313"/>
                    <scope line="314"/>
                    <scope line="316"/>
                </scope>
                <scope line="324"/>
            </method>
            <javadoc line="332">
                Get the state vector of the interpolated point.                
                <return>
                    state vector at time {@link #getInterpolatedTime}                    
                </return>
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded                    
                </exception>
                <see>
                    #getInterpolatedSecondaryState(int)                    
                </see>
            </javadoc>
            <method name="getInterpolatedState" type="double[]" line="338"/>
            <javadoc line="342">
                Get the interpolated secondary state corresponding to the secondary equations.                
                <param>
                    secondaryStateIndex index of the secondary set, as returned by {@link org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(org.apache.commons.math3.ode.SecondaryEquations)ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}                    
                </param>
                <return>
                    interpolated secondary state at the current interpolation date                    
                </return>
                <see>
                    #getInterpolatedState()                    
                </see>
                <since>
                    3.2                    
                </since>
                <exception>
                    MaxCountExceededException if the number of functions evaluations is exceeded                    
                </exception>
            </javadoc>
            <method name="getInterpolatedSecondaryState" type="double[]" line="353">
                <params>
                    <param name="secondaryStateIndex" type="int"/>
                </params>
            </method>
            <javadoc line="357">
                Compare a step interval and a double.                
                <param>
                    time point to locate                    
                </param>
                <param>
                    interval step interval                    
                </param>
                <return>
                    -1 if the double is before the interval, 0 if it is in
                      the interval, and +1 if it is after the interval, according to
                      the interval direction                    
                </return>
            </javadoc>
            <method name="locatePoint" type="int" line="364">
                <params>
                    <param name="time" type="double"/>
                    <param name="interval" type="StepInterpolator"/>
                </params>
                <scope line="365">
                    <scope line="366"/>
                    <scope line="368"/>
                    <scope line="370"/>
                </scope>
                <scope line="374"/>
                <scope line="376"/>
                <scope line="378"/>
            </method>
        </class>
    </source>