<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar.noderiv">
        <import package="java.util.Comparator"/>
        <import package="org.apache.commons.math3.analysis.MultivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.MathUnsupportedOperationException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.ConvergenceChecker"/>
        <import package="org.apache.commons.math3.optim.PointValuePair"/>
        <import package="org.apache.commons.math3.optim.SimpleValueChecker"/>
        <import package="org.apache.commons.math3.optim.OptimizationData"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer"/>
        <class name="SimplexOptimizer" line="31">
            <extends class="MultivariateOptimizer"/>
            <javadoc line="31">
                This class implements simplex-based direct search optimization.
                  &lt;p&gt;
                  Direct search methods only use objective function values, they do
                  not need derivatives and don&apos;t either try to compute approximation
                  of the derivatives. According to a 1996 paper by Margaret H. Wright
                  (&lt;a href=&quot;http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz&quot;&gt;Direct
                  Search Methods: Once Scorned, Now Respectable&lt;/a&gt;), they are used
                  when either the computation of the derivative is impossible (noisy
                  functions, unpredictable discontinuities) or difficult (complexity,
                  computation cost). In the first cases, rather than an optimum, a
                  &lt;em&gt;not too bad&lt;/em&gt; point is desired. In the latter cases, an
                  optimum is desired but cannot be reasonably found. In all cases
                  direct search methods can be useful.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Simplex-based direct search methods are based on comparison of
                  the objective function values at the vertices of a simplex (which is a
                  set of n+1 points in dimension n) that is updated by the algorithms
                  steps.
                  &lt;p&gt;
                  &lt;p&gt;
                  The simplex update procedure ({@link NelderMeadSimplex} or{@link MultiDirectionalSimplex})  must be passed to the{@code optimize} method.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each call to {@code optimize} will re-use the start configuration of
                  the current simplex and move it such that its first vertex is at the
                  provided start point of the optimization.
                  If the {@code optimize} method is called to solve a different problem
                  and the number of parameters change, the simplex must be re-initialized
                  to one with the appropriate dimensions.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Convergence is checked by providing the &lt;em&gt;worst&lt;/em&gt; points of
                  previous and current simplex to the convergence checker, not the best
                  ones.
                  &lt;/p&gt;
                  &lt;p&gt;
                  This simplex optimizer implementation does not directly support constrained
                  optimization with simple bounds; so, for such optimizations, either a more
                  dedicated algorithm must be used like{@link CMAESOptimizer} or {@link BOBYQAOptimizer}, or the objective
                  function must be wrapped in an adapter like{@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionMappingAdapterMultivariateFunctionMappingAdapter} or{@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapterMultivariateFunctionPenaltyAdapter}.
                  &lt;br/&gt;
                  The call to {@link #optimize(OptimizationData[]) optimize} will throw{@link MathUnsupportedOperationException} if bounds are passed to it.
                  &lt;/p&gt;                
                <version>
                    $Id: SimplexOptimizer.java 1458323 2013-03-19 14:51:30Z erans $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="simplex" type="AbstractSimplex" line="90"/>
            <javadoc line="90">
                Simplex update rule.                
            </javadoc>
            <javadoc line="93">
                @param checker Convergence checker.                
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="96">
                <params>
                    <param name="checker" type="ConvergenceChecker<PointValuePair>"/>
                </params>
            </method>
            <javadoc line="100">
                @param rel Relative threshold.                
                <param>
                    abs Absolute threshold.                    
                </param>
            </javadoc>
            <method name="SimplexOptimizer" type="constructor" line="104">
                <params>
                    <param name="rel" type="double"/>
                    <param name="abs" type="double"/>
                </params>
            </method>
            <javadoc line="108">
                {@inheritDoc}                
                <param>
                    optData Optimization data. In addition to those documented in{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])MultivariateOptimizer}, this method will register the following data:
                      <ul>
                      <li>{@link AbstractSimplex}</li>
                      </ul>                    
                </param>
                <return>
                    {@inheritDoc}                    
                </return>
            </javadoc>
            <method name="optimize" type="PointValuePair" line="120">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="121">
                    Set up base class and perform computation.                    
                </comment>
            </method>
            <javadoc line="125">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="PointValuePair" line="127">
                <comment line="130">
                    Indirect call to &quot;computeObjectiveValue&quot; in order to update the                    
                </comment>
                <comment line="131">
                    evaluations counter.                    
                </comment>
                <comment line="150">
                    Initialize search.                    
                </comment>
                <comment line="166">
                    We have found an optimum.                    
                </comment>
                <comment line="171">
                    We still need to search.                    
                </comment>
                <anonymous_class line="133">
                    <method name="value" type="double" line="134">
                        <params>
                            <param name="point" type="double[]"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="evalFunc" type="MultivariateFunction" line="132"/>
                <declaration name="isMinim" type="boolean" line="139"/>
                <anonymous_class line="141">
                    <method name="compare" type="int" line="143">
                        <params>
                            <param name="o1" type="PointValuePair"/>
                            <param name="o2" type="PointValuePair"/>
                        </params>
                        <declaration name="v1" type="double" line="144"/>
                        <declaration name="v2" type="double" line="145"/>
                    </method>
                </anonymous_class>
                <declaration name="comparator" type="Comparator&lt;PointValuePair&gt;" line="140"/>
                <declaration name="previous" type="PointValuePair[]" line="154"/>
                <declaration name="iteration" type="int" line="155"/>
                <declaration name="checker" type="ConvergenceChecker&lt;PointValuePair&gt;" line="156"/>
                <scope line="157">
                    <scope line="158">
                        <declaration name="converged" type="boolean" line="159"/>
                        <scope line="160">
                            <declaration name="prev" type="PointValuePair" line="161"/>
                        </scope>
                        <scope line="165"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="179">
                Scans the list of (required and optional) optimization data that
                  characterize the problem.                
                <param>
                    optData Optimization data.
                      The following data will be looked for:
                      <ul>
                      <li>{@link AbstractSimplex}</li>
                      </ul>                    
                </param>
            </javadoc>
            <method name="parseOptimizationData" type="void" line="190">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="191">
                    Allow base class to register its own data.                    
                </comment>
                <comment line="194">
                    The existing values (as set by the previous call) are reused if                    
                </comment>
                <comment line="195">
                    not provided in the argument list.                    
                </comment>
                <comment line="199">
                    If more data must be parsed, this statement _must_ be                    
                </comment>
                <comment line="200">
                    changed to &quot;continue&quot;.                    
                </comment>
                <scope line="196">
                    <scope line="197"/>
                </scope>
            </method>
            <javadoc line="206">
                @throws MathUnsupportedOperationException if bounds were passed to the{@link #optimize(OptimizationData[]) optimize} method.                
                <throws>
                    NullArgumentException if no initial simplex was passed to the{@link #optimize(OptimizationData[]) optimize} method.                    
                </throws>
            </javadoc>
            <method name="checkParameters" type="void" line="212">
                <scope line="213"/>
                <scope line="217"/>
            </method>
        </class>
    </source>