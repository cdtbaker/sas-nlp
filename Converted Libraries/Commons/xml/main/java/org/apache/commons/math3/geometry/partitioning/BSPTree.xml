<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.geometry.partitioning">
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.geometry.Vector"/>
        <import package="org.apache.commons.math3.geometry.Space"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <class name="BSPTree" line="24">
            <type_params>
                <type_param name="S"/>
            </type_params>
            <javadoc line="24">
                This class represent a Binary Space Partition tree.
                  &lt;p&gt;BSP trees are an efficient way to represent space partitions and
                  to associate attributes with each cell. Each node in a BSP tree
                  represents a convex region which is partitioned in two convex
                  sub-regions at each side of a cut hyperplane. The root tree
                  contains the complete space.&lt;/p&gt;
                  &lt;p&gt;The main use of such partitions is to use a boolean attribute to
                  define an inside/outside property, hence representing arbitrary
                  polytopes (line segments in 1D, polygons in 2D and polyhedrons in
                  3D) and to operate on them.&lt;/p&gt;
                  &lt;p&gt;Another example would be to represent Voronoi tesselations, the
                  attribute of each cell holding the defining point of the cell.&lt;/p&gt;
                  &lt;p&gt;The application-defined attributes are shared among copied
                  instances and propagated to split parts. These attributes are not
                  used by the BSP-tree algorithms themselves, so the application can
                  use them for any purpose. Since the tree visiting method holds
                  internal and leaf nodes differently, it is possible to use
                  different classes for internal nodes attributes and leaf nodes
                  attributes. This should be used with care, though, because if the
                  tree is modified in any way after attributes have been set, some
                  internal nodes may become leaf nodes and some leaf nodes may become
                  internal nodes.&lt;/p&gt;
                  &lt;p&gt;One of the main sources for the development of this package was
                  Bruce Naylor, John Amanatides and William Thibault paper &lt;a
                  href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
                  BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph &apos;90,
                  Computer Graphics 24(4), August 1990, pp 115-124, published by the
                  Association for Computing Machinery (ACM).&lt;/p&gt;                
                <param>
                    &lt;S&gt;
                       Type of the space.                    
                </param>
                <version>
                    $Id: BSPTree.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="cut" type="SubHyperplane&lt;S&gt;" line="65"/>
            <javadoc line="65">
                Cut sub-hyperplane.                
            </javadoc>
            <declaration name="plus" type="BSPTree&lt;S&gt;" line="68"/>
            <javadoc line="68">
                Tree at the plus side of the cut hyperplane.                
            </javadoc>
            <declaration name="minus" type="BSPTree&lt;S&gt;" line="71"/>
            <javadoc line="71">
                Tree at the minus side of the cut hyperplane.                
            </javadoc>
            <declaration name="parent" type="BSPTree&lt;S&gt;" line="74"/>
            <javadoc line="74">
                Parent tree.                
            </javadoc>
            <declaration name="attribute" type="Object" line="77"/>
            <javadoc line="77">
                Application-defined attribute.                
            </javadoc>
            <javadoc line="80">
                Build a tree having only one root cell representing the whole space.                
            </javadoc>
            <method name="BSPTree" type="constructor" line="82"/>
            <javadoc line="90">
                Build a tree having only one root cell representing the whole space.                
                <param>
                    attribute attribute of the tree (may be null)                    
                </param>
            </javadoc>
            <method name="BSPTree" type="constructor" line="93">
                <params>
                    <param name="attribute" type="Object"/>
                </params>
            </method>
            <javadoc line="101">
                Build a BSPTree from its underlying elements.
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; perform any verification on
                  consistency of its arguments, it should therefore be used only
                  when then caller knows what it is doing.&lt;/p&gt;
                  &lt;p&gt;This method is mainly useful kto build trees
                  bottom-up. Building trees top-down is realized with the help of
                  method {@link #insertCut insertCut}.&lt;/p&gt;                
                <param>
                    cut cut sub-hyperplane for the tree                    
                </param>
                <param>
                    plus plus side sub-tree                    
                </param>
                <param>
                    minus minus side sub-tree                    
                </param>
                <param>
                    attribute attribute associated with the node (may be null)                    
                </param>
                <see>
                    #insertCut                    
                </see>
            </javadoc>
            <method name="BSPTree" type="constructor" line="115">
                <params>
                    <param name="cut" type="SubHyperplane<S>"/>
                    <param name="plus" type="BSPTree<S>"/>
                    <param name="minus" type="BSPTree<S>"/>
                    <param name="attribute" type="Object"/>
                </params>
            </method>
            <javadoc line="125">
                Insert a cut sub-hyperplane in a node.
                  &lt;p&gt;The sub-tree starting at this node will be completely
                  overwritten. The new cut sub-hyperplane will be built from the
                  intersection of the provided hyperplane with the cell. If the
                  hyperplane does intersect the cell, the cell will have two
                  children cells with {@code null} attributes on each side of
                  the inserted cut sub-hyperplane. If the hyperplane does not
                  intersect the cell then &lt;em&gt;no&lt;/em&gt; cut hyperplane will be
                  inserted and the cell will be changed to a leaf cell. The
                  attribute of the node is never changed.&lt;/p&gt;
                  &lt;p&gt;This method is mainly useful when called on leaf nodes
                  (i.e. nodes for which {@link #getCut getCut} returns{@code null}), in this case it provides a way to build a
                  tree top-down (whereas the {@link #BSPTree(SubHyperplane,BSPTree,BSPTree,Object) 4 arguments constructor} is devoted to
                  build trees bottom-up).&lt;/p&gt;                
                <param>
                    hyperplane hyperplane to insert, it will be chopped in
                      order to fit in the cell defined by the parent nodes of the
                      instance                    
                </param>
                <return>
                    true if a cut sub-hyperplane has been inserted (i.e. if
                      the cell now has two leaf child nodes)                    
                </return>
                <see>
                    #BSPTree(SubHyperplane,BSPTree,BSPTree,Object)                    
                </see>
            </javadoc>
            <method name="insertCut" type="boolean" line="148">
                <params>
                    <param name="hyperplane" type="Hyperplane<S>"/>
                </params>
                <scope line="150"/>
                <declaration name="chopped" type="SubHyperplane&lt;S&gt;" line="155"/>
                <scope line="156"/>
            </method>
            <javadoc line="172">
                Copy the instance.
                  &lt;p&gt;The instance created is completely independant of the original
                  one. A deep copy is used, none of the underlying objects are
                  shared (except for the nodes attributes and immutable
                  objects).&lt;/p&gt;                
                <return>
                    a new tree, copy of the instance                    
                </return>
            </javadoc>
            <method name="copySelf" type="BSPTree<S>" line="179">
                <scope line="181"/>
            </method>
            <javadoc line="190">
                Get the cut sub-hyperplane.                
                <return>
                    cut sub-hyperplane, null if this is a leaf tree                    
                </return>
            </javadoc>
            <method name="getCut" type="SubHyperplane<S>" line="193"/>
            <javadoc line="197">
                Get the tree on the plus side of the cut hyperplane.                
                <return>
                    tree on the plus side of the cut hyperplane, null if this
                      is a leaf tree                    
                </return>
            </javadoc>
            <method name="getPlus" type="BSPTree<S>" line="201"/>
            <javadoc line="205">
                Get the tree on the minus side of the cut hyperplane.                
                <return>
                    tree on the minus side of the cut hyperplane, null if this
                      is a leaf tree                    
                </return>
            </javadoc>
            <method name="getMinus" type="BSPTree<S>" line="209"/>
            <javadoc line="213">
                Get the parent node.                
                <return>
                    parent node, null if the node has no parents                    
                </return>
            </javadoc>
            <method name="getParent" type="BSPTree<S>" line="216"/>
            <javadoc line="220">
                Associate an attribute with the instance.                
                <param>
                    attribute attribute to associate with the node                    
                </param>
                <see>
                    #getAttribute                    
                </see>
            </javadoc>
            <method name="setAttribute" type="void" line="224">
                <params>
                    <param name="attribute" type="Object"/>
                </params>
            </method>
            <javadoc line="228">
                Get the attribute associated with the instance.                
                <return>
                    attribute associated with the node or null if no
                      attribute has been explicitly set using the {@link #setAttributesetAttribute} method                    
                </return>
                <see>
                    #setAttribute                    
                </see>
            </javadoc>
            <method name="getAttribute" type="Object" line="234"/>
            <javadoc line="238">
                Visit the BSP tree nodes.                
                <param>
                    visitor object visiting the tree nodes                    
                </param>
            </javadoc>
            <method name="visit" type="void" line="241">
                <params>
                    <param name="visitor" type="BSPTreeVisitor<S>"/>
                </params>
                <scope line="242"/>
                <scope line="244"/>
            </method>
            <javadoc line="283">
                Fit a sub-hyperplane inside the cell defined by the instance.
                  &lt;p&gt;Fitting is done by chopping off the parts of the
                  sub-hyperplane that lie outside of the cell using the
                  cut-hyperplanes of the parent nodes of the instance.&lt;/p&gt;                
                <param>
                    sub sub-hyperplane to fit                    
                </param>
                <return>
                    a new sub-hyperplane, guaranteed to have no part outside
                      of the instance cell                    
                </return>
            </javadoc>
            <method name="fitToCell" type="SubHyperplane<S>" line="291">
                <params>
                    <param name="sub" type="SubHyperplane<S>"/>
                </params>
                <declaration name="s" type="SubHyperplane&lt;S&gt;" line="292"/>
                <scope line="293">
                    <scope line="294"/>
                    <scope line="296"/>
                </scope>
            </method>
            <javadoc line="303">
                Get the cell to which a point belongs.
                  &lt;p&gt;If the returned cell is a leaf node the points belongs to the
                  interior of the node, if the cell is an internal node the points
                  belongs to the node cut sub-hyperplane.&lt;/p&gt;                
                <param>
                    point point to check                    
                </param>
                <return>
                    the tree cell to which the point belongs (can be                    
                </return>
            </javadoc>
            <method name="getCell" type="BSPTree<S>" line="310">
                <params>
                    <param name="point" type="Vector<S>"/>
                </params>
                <comment line="317">
                    position of the point with respect to the cut hyperplane                    
                </comment>
                <comment line="323">
                    point is on the minus side of the cut hyperplane                    
                </comment>
                <comment line="326">
                    point is on the plus side of the cut hyperplane                    
                </comment>
                <scope line="312"/>
                <declaration name="offset" type="double" line="317"/>
                <scope line="319"/>
                <scope line="321"/>
                <scope line="324"/>
            </method>
            <javadoc line="331">
                Perform condensation on a tree.
                  &lt;p&gt;The condensation operation is not recursive, it must be called
                  explicitely from leaves to root.&lt;/p&gt;                
            </javadoc>
            <method name="condense" type="void" line="335">
                <scope line="338"/>
            </method>
            <javadoc line="346">
                Merge a BSP tree with the instance.
                  &lt;p&gt;All trees are modified (parts of them are reused in the new
                  tree), it is the responsibility of the caller to ensure a copy
                  has been done before if any of the former tree should be
                  preserved, &lt;em&gt;no&lt;/em&gt; such copy is done here!&lt;/p&gt;
                  &lt;p&gt;The algorithm used here is directly derived from the one
                  described in the Naylor, Amanatides and Thibault paper (section
                  III, Binary Partitioning of a BSP Tree).&lt;/p&gt;                
                <param>
                    tree other tree to merge with the instance (will be
                      &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
                      instance itself)                    
                </param>
                <param>
                    leafMerger object implementing the final merging phase
                      (this is where the semantic of the operation occurs, generally
                      depending on the attribute of the leaf node)                    
                </param>
                <return>
                    a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
                      tree&lt;/code&gt;, this value can be ignored if parentTree is not null
                      since all connections have already been established                    
                </return>
            </javadoc>
            <method name="merge" type="BSPTree<S>" line="364">
                <params>
                    <param name="tree" type="BSPTree<S>"/>
                    <param name="leafMerger" type="LeafMerger<S>"/>
                </params>
            </method>
            <javadoc line="368">
                Merge a BSP tree with the instance.                
                <param>
                    tree other tree to merge with the instance (will be
                      &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
                      instance itself)                    
                </param>
                <param>
                    leafMerger object implementing the final merging phase
                      (this is where the semantic of the operation occurs, generally
                      depending on the attribute of the leaf node)                    
                </param>
                <param>
                    parentTree parent tree to connect to (may be null)                    
                </param>
                <param>
                    isPlusChild if true and if parentTree is not null, the
                      resulting tree should be the plus child of its parent, ignored if
                      parentTree is null                    
                </param>
                <return>
                    a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
                      tree&lt;/code&gt;, this value can be ignored if parentTree is not null
                      since all connections have already been established                    
                </return>
            </javadoc>
            <method name="merge" type="BSPTree<S>" line="384">
                <params>
                    <param name="tree" type="BSPTree<S>"/>
                    <param name="leafMerger" type="LeafMerger<S>"/>
                    <param name="parentTree" type="BSPTree<S>"/>
                    <param name="isPlusChild" type="boolean"/>
                </params>
                <comment line="387">
                    cell/tree operation                    
                </comment>
                <comment line="390">
                    tree/cell operation                    
                </comment>
                <comment line="393">
                    tree/tree operation                    
                </comment>
                <comment line="404">
                    merging phase                    
                </comment>
                <scope line="385"/>
                <scope line="388"/>
                <scope line="391">
                    <declaration name="merged" type="BSPTree&lt;S&gt;" line="393"/>
                    <scope line="394">
                        <scope line="396"/>
                        <scope line="398"/>
                    </scope>
                    <scope line="407"/>
                </scope>
            </method>
            <interface name="LeafMerger">
                <type_params>
                    <type_param name="S"/>
                </type_params>
                <javadoc line="417">
                    This interface gather the merging operations between a BSP tree
                      leaf and another BSP tree.
                      &lt;p&gt;As explained in Bruce Naylor, John Amanatides and William
                      Thibault paper &lt;a
                      href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
                      BSP Trees Yields Polyhedral Set Operations&lt;/a&gt;,
                      the operations on {@link BSPTree BSP trees} can be expressed as a
                      generic recursive merging operation where only the final part,
                      when one of the operand is a leaf, is specific to the real
                      operation semantics. For example, a tree representing a region
                      using a boolean attribute to identify inside cells and outside
                      cells would use four different objects to implement the final
                      merging phase of the four set operations union, intersection,
                      difference and symmetric difference (exclusive or).&lt;/p&gt;                    
                    <param>
                        &lt;S&gt;
                           Type of the space.                        
                    </param>
                </javadoc>
                <method name="merge" type="BSPTree<S>" line="435"/>
                <javadoc line="435">
                    Merge a leaf node and a tree node.
                      &lt;p&gt;This method is called at the end of a recursive merging
                      resulting from a {@code tree1.merge(tree2, leafMerger)}call, when one of the sub-trees involved is a leaf (i.e. when
                      its cut-hyperplane is null). This is the only place where the
                      precise semantics of the operation are required. For all upper
                      level nodes in the tree, the merging operation is only a
                      generic partitioning algorithm.&lt;/p&gt;
                      &lt;p&gt;Since the final operation may be non-commutative, it is
                      important to know if the leaf node comes from the instance tree
                      ({@code tree1}) or the argument tree
                      ({@code tree2}). The third argument of the method is
                      devoted to this. It can be ignored for commutative
                      operations.&lt;/p&gt;
                      &lt;p&gt;The {@link BSPTree#insertInTree BSPTree.insertInTree} method
                      may be useful to implement this method.&lt;/p&gt;                    
                    <param>
                        leaf leaf node (its cut hyperplane is guaranteed to be
                          null)                        
                    </param>
                    <param>
                        tree tree node (its cut hyperplane may be null or not)                        
                    </param>
                    <param>
                        parentTree parent tree to connect to (may be null)                        
                    </param>
                    <param>
                        isPlusChild if true and if parentTree is not null, the
                          resulting tree should be the plus child of its parent, ignored if
                          parentTree is null                        
                    </param>
                    <param>
                        leafFromInstance if true, the leaf node comes from the
                          instance tree ({@code tree1}) and the tree node comes from
                          the argument tree ({@code tree2})                        
                    </param>
                    <return>
                        the BSP tree resulting from the merging (may be one of
                          the arguments)                        
                    </return>
                </javadoc>
            </interface>
            <javadoc line="469">
                Split a BSP tree by an external sub-hyperplane.
                  &lt;p&gt;Split a tree in two halves, on each side of the
                  sub-hyperplane. The instance is not modified.&lt;/p&gt;
                  &lt;p&gt;The tree returned is not upward-consistent: despite all of its
                  sub-trees cut sub-hyperplanes (including its own cut
                  sub-hyperplane) are bounded to the current cell, it is &lt;em&gt;not&lt;/em&gt;
                  attached to any parent tree yet. This tree is intended to be
                  later inserted into an higher level tree.&lt;/p&gt;
                  &lt;p&gt;The algorithm used here is the one given in Naylor, Amanatides
                  and Thibault paper (section III, Binary Partitioning of a BSP
                  Tree).&lt;/p&gt;                
                <param>
                    sub partitioning sub-hyperplane, must be already clipped
                      to the convex region represented by the instance, will be used as
                      the cut sub-hyperplane of the returned tree                    
                </param>
                <return>
                    a tree having the specified sub-hyperplane as its cut
                      sub-hyperplane, the two parts of the split instance as its two
                      sub-trees and a null parent                    
                </return>
            </javadoc>
            <method name="split" type="BSPTree<S>" line="487">
                <params>
                    <param name="sub" type="SubHyperplane<S>"/>
                </params>
                <comment line="499">
                    the partitioning sub-hyperplane is entirely in the plus sub-tree                    
                </comment>
                <comment line="515">
                    the partitioning sub-hyperplane is entirely in the minus sub-tree                    
                </comment>
                <scope line="489"/>
                <declaration name="cHyperplane" type="Hyperplane&lt;S&gt;" line="494"/>
                <declaration name="sHyperplane" type="Hyperplane&lt;S&gt;" line="495"/>
                <scope line="498">
                    <declaration name="split" type="BSPTree&lt;S&gt;" line="499"/>
                    <scope line="500"/>
                    <scope line="505"/>
                </scope>
                <scope line="514">
                    <declaration name="split" type="BSPTree&lt;S&gt;" line="515"/>
                    <scope line="516"/>
                    <scope line="521"/>
                </scope>
                <scope line="530">
                    <declaration name="cutParts" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="531"/>
                    <declaration name="subParts" type="SubHyperplane.SplitSubHyperplane&lt;S&gt;" line="532"/>
                    <declaration name="split" type="BSPTree&lt;S&gt;" line="533"/>
                    <declaration name="tmp" type="BSPTree&lt;S&gt;" line="538"/>
                </scope>
            </method>
            <javadoc line="555">
                Insert the instance into another tree.
                  &lt;p&gt;The instance itself is modified so its former parent should
                  not be used anymore.&lt;/p&gt;                
                <param>
                    parentTree parent tree to connect to (may be null)                    
                </param>
                <param>
                    isPlusChild if true and if parentTree is not null, the
                      resulting tree should be the plus child of its parent, ignored if
                      parentTree is null                    
                </param>
                <see>
                    LeafMerger                    
                </see>
            </javadoc>
            <method name="insertInTree" type="void" line="564">
                <params>
                    <param name="parentTree" type="BSPTree<S>"/>
                    <param name="isPlusChild" type="boolean"/>
                </params>
                <comment line="567">
                    set up parent/child links                    
                </comment>
                <comment line="577">
                    make sure the inserted tree lies in the cell defined by its parent nodes                    
                </comment>
                <comment line="580">
                    explore the parent nodes from here towards tree root                    
                </comment>
                <comment line="583">
                    this is an hyperplane of some parent node                    
                </comment>
                <comment line="586">
                    chop off the parts of the inserted tree that extend
                     on the wrong side of this parent hyperplane                    
                </comment>
                <comment line="600">
                    since we may have drop some parts of the inserted tree,
                     perform a condensation pass to keep the tree structure simple                    
                </comment>
                <scope line="568">
                    <scope line="569"/>
                    <scope line="571"/>
                </scope>
                <scope line="577">
                    <scope line="580">
                        <declaration name="hyperplane" type="Hyperplane&lt;S&gt;" line="583"/>
                        <scope line="587"/>
                        <scope line="591"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="607">
                Chop off parts of the tree.
                  &lt;p&gt;The instance is modified in place, all the parts that are on
                  the minus side of the chopping hyperplane are discarded, only the
                  parts on the plus side remain.&lt;/p&gt;                
                <param>
                    hyperplane chopping hyperplane                    
                </param>
            </javadoc>
            <method name="chopOffMinus" type="void" line="613">
                <params>
                    <param name="hyperplane" type="Hyperplane<S>"/>
                </params>
                <scope line="614"/>
            </method>
            <javadoc line="621">
                Chop off parts of the tree.
                  &lt;p&gt;The instance is modified in place, all the parts that are on
                  the plus side of the chopping hyperplane are discarded, only the
                  parts on the minus side remain.&lt;/p&gt;                
                <param>
                    hyperplane chopping hyperplane                    
                </param>
            </javadoc>
            <method name="chopOffPlus" type="void" line="627">
                <params>
                    <param name="hyperplane" type="Hyperplane<S>"/>
                </params>
                <scope line="628"/>
            </method>
        </class>
    </source>