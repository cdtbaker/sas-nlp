<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.analysis.solvers">
        <import package="org.apache.commons.math3.analysis.UnivariateFunction"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.TooManyEvaluationsException"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.apache.commons.math3.util.Precision"/>
        <class name="BracketingNthOrderBrentSolver" line="29">
            <extends class="AbstractUnivariateSolver"/>
            <implements interface="BracketedUnivariateSolver">
                <type_params>
                    <type_param name="UnivariateFunction"/>
                </type_params>
            </implements>
            <javadoc line="29">
                This class implements a modification of the &lt;a
                  href=&quot;http://mathworld.wolfram.com/BrentsMethod.html&quot;&gt; Brent algorithm&lt;/a&gt;.
                  &lt;p&gt;
                  The changes with respect to the original Brent algorithm are:
                  &lt;ul&gt;
                  &lt;li&gt;the returned value is chosen in the current interval according
                  to user specified {@link AllowedSolution},&lt;/li&gt;
                  &lt;li&gt;the maximal order for the invert polynomial root search is
                  user-specified instead of being invert quadratic only&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/p&gt;
                  The given interval must bracket the root.                
                <version>
                    $Id: BracketingNthOrderBrentSolver.java 1379560 2012-08-31 19:40:30Z erans $                    
                </version>
            </javadoc>
            <declaration name="DEFAULT_ABSOLUTE_ACCURACY" type="double" line="49"/>
            <javadoc line="49">
                Default absolute accuracy.                
            </javadoc>
            <declaration name="DEFAULT_MAXIMAL_ORDER" type="int" line="52"/>
            <javadoc line="52">
                Default maximal order.                
            </javadoc>
            <declaration name="MAXIMAL_AGING" type="int" line="55"/>
            <javadoc line="55">
                Maximal aging triggering an attempt to balance the bracketing interval.                
            </javadoc>
            <declaration name="REDUCTION_FACTOR" type="double" line="58"/>
            <javadoc line="58">
                Reduction factor for attempts to balance the bracketing interval.                
            </javadoc>
            <declaration name="maximalOrder" type="int" line="61"/>
            <javadoc line="61">
                Maximal order.                
            </javadoc>
            <declaration name="allowed" type="AllowedSolution" line="64"/>
            <javadoc line="64">
                The kinds of solutions that the algorithm may accept.                
            </javadoc>
            <javadoc line="67">
                Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)                
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="70"/>
            <javadoc line="74">
                Construct a solver.                
                <param>
                    absoluteAccuracy Absolute accuracy.                    
                </param>
                <param>
                    maximalOrder maximal order.                    
                </param>
                <exception>
                    NumberIsTooSmallException if maximal order is lower than 2                    
                </exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="83">
                <params>
                    <param name="absoluteAccuracy" type="double"/>
                    <param name="maximalOrder" type="int"/>
                </params>
                <scope line="85"/>
            </method>
            <javadoc line="92">
                Construct a solver.                
                <param>
                    relativeAccuracy Relative accuracy.                    
                </param>
                <param>
                    absoluteAccuracy Absolute accuracy.                    
                </param>
                <param>
                    maximalOrder maximal order.                    
                </param>
                <exception>
                    NumberIsTooSmallException if maximal order is lower than 2                    
                </exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="103">
                <params>
                    <param name="relativeAccuracy" type="double"/>
                    <param name="absoluteAccuracy" type="double"/>
                    <param name="maximalOrder" type="int"/>
                </params>
                <scope line="105"/>
            </method>
            <javadoc line="112">
                Construct a solver.                
                <param>
                    relativeAccuracy Relative accuracy.                    
                </param>
                <param>
                    absoluteAccuracy Absolute accuracy.                    
                </param>
                <param>
                    functionValueAccuracy Function value accuracy.                    
                </param>
                <param>
                    maximalOrder maximal order.                    
                </param>
                <exception>
                    NumberIsTooSmallException if maximal order is lower than 2                    
                </exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolver" type="constructor" line="125">
                <params>
                    <param name="relativeAccuracy" type="double"/>
                    <param name="absoluteAccuracy" type="double"/>
                    <param name="functionValueAccuracy" type="double"/>
                    <param name="maximalOrder" type="int"/>
                </params>
                <scope line="127"/>
            </method>
            <javadoc line="134">
                Get the maximal order.                
                <return>
                    maximal order                    
                </return>
            </javadoc>
            <method name="getMaximalOrder" type="int" line="137"/>
            <javadoc line="141">
                {@inheritDoc}                
            </javadoc>
            <method name="doSolve" type="double" line="148">
                <comment line="150">
                    prepare arrays with the first points                    
                </comment>
                <comment line="158">
                    evaluate initial guess                    
                </comment>
                <comment line="161">
                    return the initial guess if it is a perfect root.                    
                </comment>
                <comment line="165">
                    evaluate first  endpoint                    
                </comment>
                <comment line="168">
                    return the first endpoint if it is a perfect root.                    
                </comment>
                <comment line="176">
                    reduce interval if it brackets the root                    
                </comment>
                <comment line="182">
                    evaluate second endpoint                    
                </comment>
                <comment line="185">
                    return the second endpoint if it is a perfect root.                    
                </comment>
                <comment line="190">
                    use all computed point as a start sampling array for solving                    
                </comment>
                <comment line="199">
                    prepare a work array for inverse polynomial interpolation                    
                </comment>
                <comment line="202">
                    current tightest bracketing of the root                    
                </comment>
                <comment line="212">
                    search loop                    
                </comment>
                <comment line="215">
                    check convergence of bracketing interval                    
                </comment>
                <comment line="231">
                    this should never happen                    
                </comment>
                <comment line="236">
                    target for the next evaluation point                    
                </comment>
                <comment line="239">
                    we keep updating the high bracket, try to compensate this                    
                </comment>
                <comment line="245">
                    we keep updating the low bracket, try to compensate this                    
                </comment>
                <comment line="251">
                    bracketing is balanced, try to find the root itself                    
                </comment>
                <comment line="255">
                    make a few attempts to guess a root,                    
                </comment>
                <comment line="261">
                    guess a value for current target, using inverse polynomial interpolation                    
                </comment>
                <comment line="266">
                    the guessed root is not strictly inside of the tightest bracketing interval                    
                </comment>
                <comment line="268">
                    the guessed root is either not strictly inside the interval or it
                     is a NaN (which occurs when some sampling points share the same y)
                     we try again with a lower interpolation order                    
                </comment>
                <comment line="272">
                    we have more points before the sign change, drop the lowest point                    
                </comment>
                <comment line="275">
                    we have more points after sign change, drop the highest point                    
                </comment>
                <comment line="279">
                    we need to do one more attempt                    
                </comment>
                <comment line="287">
                    fall back to bisection                    
                </comment>
                <comment line="293">
                    evaluate the function at the guessed root                    
                </comment>
                <comment line="296">
                    we have found an exact root, since it is not an approximation
                     we don&apos;t need to bother about the allowed solutions setting                    
                </comment>
                <comment line="303">
                    we have been forced to ignore some points to keep bracketing,
                     they are probably too far from the root, drop them from now on                    
                </comment>
                <comment line="312">
                    we have to drop one point in order to insert the new one                    
                </comment>
                <comment line="315">
                    keep the tightest bracketing interval as centered as possible                    
                </comment>
                <comment line="317">
                    we drop the lowest point, we have to shift the arrays and the index                    
                </comment>
                <comment line="325">
                    insert the last computed point
                    (by construction, we know it lies inside the tightest bracketing interval)                    
                </comment>
                <comment line="333">
                    update the bracketing interval                    
                </comment>
                <comment line="335">
                    the sign change occurs before the inserted point                    
                </comment>
                <comment line="342">
                    the sign change occurs after the inserted point                    
                </comment>
                <comment line="349">
                    update the sign change index                    
                </comment>
                <declaration name="x" type="double[]" line="150"/>
                <declaration name="y" type="double[]" line="151"/>
                <scope line="159"/>
                <scope line="166"/>
                <declaration name="nbPoints" type="int" line="171"/>
                <declaration name="signChangeIndex" type="int" line="172"/>
                <scope line="173"/>
                <scope line="179">
                    <scope line="183"/>
                    <scope line="188"/>
                    <scope line="192"/>
                </scope>
                <declaration name="tmpX" type="double[]" line="199"/>
                <declaration name="xA" type="double" line="202"/>
                <declaration name="yA" type="double" line="203"/>
                <declaration name="absYA" type="double" line="204"/>
                <declaration name="agingA" type="int" line="205"/>
                <declaration name="xB" type="double" line="206"/>
                <declaration name="yB" type="double" line="207"/>
                <declaration name="absYB" type="double" line="208"/>
                <declaration name="agingB" type="int" line="209"/>
                <scope line="212">
                    <declaration name="xTol" type="double" line="215"/>
                    <scope line="217"/>
                    <declaration name="targetY" type="double" line="236"/>
                    <scope line="237">
                        <declaration name="p" type="int" line="239"/>
                        <declaration name="weightA" type="double" line="240"/>
                        <declaration name="weightB" type="double" line="241"/>
                    </scope>
                    <scope line="243">
                        <declaration name="p" type="int" line="245"/>
                        <declaration name="weightA" type="double" line="246"/>
                        <declaration name="weightB" type="double" line="247"/>
                    </scope>
                    <scope line="249"/>
                    <declaration name="nextX" type="double" line="255"/>
                    <declaration name="start" type="int" line="256"/>
                    <declaration name="end" type="int" line="257"/>
                    <scope line="258">
                        <scope line="264">
                            <scope line="270"/>
                            <scope line="273"/>
                        </scope>
                    </scope>
                    <scope line="285"/>
                    <declaration name="nextY" type="double" line="293"/>
                    <scope line="294"/>
                    <scope line="300"/>
                    <scope line="309">
                        <scope line="315"/>
                    </scope>
                    <scope line="333"/>
                    <scope line="340"/>
                </scope>
            </method>
            <javadoc line="357">
                Guess an x value by n&lt;sup&gt;th&lt;/sup&gt; order inverse polynomial interpolation.
                  &lt;p&gt;
                  The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
                  is built such that for all considered points (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;),
                  Q(y&lt;sub&gt;i&lt;/sub&gt;) = x&lt;sub&gt;i&lt;/sub&gt;.
                  &lt;/p&gt;                
                <param>
                    targetY target value for y                    
                </param>
                <param>
                    x reference points abscissas for interpolation,
                      note that this array &lt;em&gt;is&lt;/em&gt; modified during computation                    
                </param>
                <param>
                    y reference points ordinates for interpolation                    
                </param>
                <param>
                    start start index of the points to consider (inclusive)                    
                </param>
                <param>
                    end end index of the points to consider (exclusive)                    
                </param>
                <return>
                    guessed root (will be a NaN if two points share the same y)                    
                </return>
            </javadoc>
            <method name="guessX" type="double" line="372">
                <params>
                    <param name="targetY" type="double"/>
                    <param name="x" type="double[]"/>
                    <param name="y" type="double[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="375">
                    compute Q Newton coefficients by divided differences                    
                </comment>
                <comment line="383">
                    evaluate Q(targetY)                    
                </comment>
                <scope line="375">
                    <declaration name="delta" type="int" line="376"/>
                    <scope line="377"/>
                </scope>
                <declaration name="x0" type="double" line="383"/>
                <scope line="384"/>
            </method>
            <javadoc line="392">
                {@inheritDoc}                
            </javadoc>
            <method name="solve" type="double" line="397">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
            </method>
            <javadoc line="402">
                {@inheritDoc}                
            </javadoc>
            <method name="solve" type="double" line="408">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateFunction"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                    <param name="startValue" type="double"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
            </method>
        </class>
    </source>