<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.dfp">
        <import package="org.apache.commons.math3.analysis.solvers.AllowedSolution"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.util.Incrementor"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="BracketingNthOrderBrentSolverDFP" line="9">
            <javadoc line="9">
                This class implements a modification of the &lt;a
                  href=&quot;http://mathworld.wolfram.com/BrentsMethod.html&quot;&gt; Brent algorithm&lt;/a&gt;.
                  &lt;p&gt;
                  The changes with respect to the original Brent algorithm are:
                  &lt;ul&gt;
                  &lt;li&gt;the returned value is chosen in the current interval according
                  to user specified {@link AllowedSolution},&lt;/li&gt;
                  &lt;li&gt;the maximal order for the invert polynomial root search is
                  user-specified instead of being invert quadratic only&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/p&gt;
                  The given interval must bracket the root.                
                <version>
                    $Id: BracketingNthOrderBrentSolverDFP.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
            </javadoc>
            <declaration name="MAXIMAL_AGING" type="int" line="25"/>
            <javadoc line="25">
                Maximal aging triggering an attempt to balance the bracketing interval.                
            </javadoc>
            <declaration name="maximalOrder" type="int" line="29"/>
            <javadoc line="29">
                Maximal order.                
            </javadoc>
            <declaration name="functionValueAccuracy" type="Dfp" line="33"/>
            <javadoc line="33">
                Function value accuracy.                
            </javadoc>
            <declaration name="absoluteAccuracy" type="Dfp" line="37"/>
            <javadoc line="37">
                Absolute accuracy.                
            </javadoc>
            <declaration name="relativeAccuracy" type="Dfp" line="41"/>
            <javadoc line="41">
                Relative accuracy.                
            </javadoc>
            <declaration name="evaluations" type="Incrementor" line="45"/>
            <javadoc line="45">
                Evaluations counter.                
            </javadoc>
            <javadoc line="49">
                Construct a solver.                
                <param>
                    relativeAccuracy Relative accuracy.                    
                </param>
                <param>
                    absoluteAccuracy Absolute accuracy.                    
                </param>
                <param>
                    functionValueAccuracy Function value accuracy.                    
                </param>
                <param>
                    maximalOrder maximal order.                    
                </param>
                <exception>
                    NumberIsTooSmallException if maximal order is lower than 2                    
                </exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolverDFP" type="constructor" line="57">
                <params>
                    <param name="relativeAccuracy" type="Dfp"/>
                    <param name="absoluteAccuracy" type="Dfp"/>
                    <param name="functionValueAccuracy" type="Dfp"/>
                    <param name="maximalOrder" type="int"/>
                </params>
                <scope line="58"/>
            </method>
            <javadoc line="66">
                Get the maximal order.                
                <return>
                    maximal order                    
                </return>
            </javadoc>
            <method name="getMaximalOrder" type="int" line="70"/>
            <javadoc line="73">
                Get the maximal number of function evaluations.                
                <return>
                    the maximal number of function evaluations.                    
                </return>
            </javadoc>
            <method name="getMaxEvaluations" type="int" line="77"/>
            <javadoc line="80">
                Get the number of evaluations of the objective function.
                  The number of evaluations corresponds to the last call to the{@code optimize} method. It is 0 if the method has not been
                  called yet.                
                <return>
                    the number of evaluations of the objective function.                    
                </return>
            </javadoc>
            <method name="getEvaluations" type="int" line="86"/>
            <javadoc line="89">
                Get the absolute accuracy.                
                <return>
                    absolute accuracy                    
                </return>
            </javadoc>
            <method name="getAbsoluteAccuracy" type="Dfp" line="93"/>
            <javadoc line="96">
                Get the relative accuracy.                
                <return>
                    relative accuracy                    
                </return>
            </javadoc>
            <method name="getRelativeAccuracy" type="Dfp" line="100"/>
            <javadoc line="103">
                Get the function accuracy.                
                <return>
                    function accuracy                    
                </return>
            </javadoc>
            <method name="getFunctionValueAccuracy" type="Dfp" line="107"/>
            <javadoc line="110">
                Solve for a zero in the given interval.
                  A solver may require that the interval brackets a single zero root.
                  Solvers that do require bracketing should be able to handle the case
                  where one of the endpoints is itself a root.                
                <param>
                    maxEval Maximum number of evaluations.                    
                </param>
                <param>
                    f Function to solve.                    
                </param>
                <param>
                    min Lower bound for the interval.                    
                </param>
                <param>
                    max Upper bound for the interval.                    
                </param>
                <param>
                    allowedSolution The kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <exception>
                    NullArgumentException if f is null.                    
                </exception>
                <exception>
                    NoBracketingException if root cannot be bracketed                    
                </exception>
            </javadoc>
            <method name="solve" type="Dfp" line="125">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateDfpFunction"/>
                    <param name="min" type="Dfp"/>
                    <param name="max" type="Dfp"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
            </method>
            <javadoc line="128">
                Solve for a zero in the given interval, start at {@code startValue}.
                  A solver may require that the interval brackets a single zero root.
                  Solvers that do require bracketing should be able to handle the case
                  where one of the endpoints is itself a root.                
                <param>
                    maxEval Maximum number of evaluations.                    
                </param>
                <param>
                    f Function to solve.                    
                </param>
                <param>
                    min Lower bound for the interval.                    
                </param>
                <param>
                    max Upper bound for the interval.                    
                </param>
                <param>
                    startValue Start value to use.                    
                </param>
                <param>
                    allowedSolution The kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <exception>
                    NullArgumentException if f is null.                    
                </exception>
                <exception>
                    NoBracketingException if root cannot be bracketed                    
                </exception>
            </javadoc>
            <method name="solve" type="Dfp" line="144">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateDfpFunction"/>
                    <param name="min" type="Dfp"/>
                    <param name="max" type="Dfp"/>
                    <param name="startValue" type="Dfp"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
                <declaration name="zero" type="Dfp" line="148"/>
                <declaration name="nan" type="Dfp" line="149"/>
                <declaration name="x" type="Dfp[]" line="150"/>
                <declaration name="y" type="Dfp[]" line="151"/>
                <scope line="157"/>
                <scope line="162"/>
                <declaration name="nbPoints" type="int" line="165"/>
                <declaration name="signChangeIndex" type="int" line="166"/>
                <scope line="167"/>
                <scope line="171">
                    <scope line="174"/>
                    <scope line="177"/>
                    <scope line="181"/>
                </scope>
                <declaration name="tmpX" type="Dfp[]" line="185"/>
                <declaration name="xA" type="Dfp" line="186"/>
                <declaration name="yA" type="Dfp" line="187"/>
                <declaration name="absXA" type="Dfp" line="188"/>
                <declaration name="absYA" type="Dfp" line="189"/>
                <declaration name="agingA" type="int" line="190"/>
                <declaration name="xB" type="Dfp" line="191"/>
                <declaration name="yB" type="Dfp" line="192"/>
                <declaration name="absXB" type="Dfp" line="193"/>
                <declaration name="absYB" type="Dfp" line="194"/>
                <declaration name="agingB" type="int" line="195"/>
                <scope line="196">
                    <declaration name="maxX" type="Dfp" line="197"/>
                    <declaration name="maxY" type="Dfp" line="198"/>
                    <declaration name="xTol" type="Dfp" line="199"/>
                    <scope line="200"/>
                    <declaration name="targetY" type="Dfp" line="216"/>
                    <scope line="217"/>
                    <scope line="220"/>
                    <scope line="223"/>
                    <declaration name="nextX" type="Dfp" line="226"/>
                    <declaration name="start" type="int" line="227"/>
                    <declaration name="end" type="int" line="228"/>
                    <scope line="229">
                        <scope line="232">
                            <scope line="233"/>
                            <scope line="236"/>
                        </scope>
                    </scope>
                    <scope line="243"/>
                    <declaration name="nextY" type="Dfp" line="249"/>
                    <scope line="250"/>
                    <scope line="253"/>
                    <scope line="259">
                        <scope line="261"/>
                    </scope>
                    <scope line="272"/>
                    <scope line="279"/>
                </scope>
            </method>
            <javadoc line="289">
                Guess an x value by n&lt;sup&gt;th&lt;/sup&gt; order inverse polynomial interpolation.
                  &lt;p&gt;
                  The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
                  is built such that for all considered points (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;),
                  Q(y&lt;sub&gt;i&lt;/sub&gt;) = x&lt;sub&gt;i&lt;/sub&gt;.
                  &lt;/p&gt;                
                <param>
                    targetY target value for y                    
                </param>
                <param>
                    x reference points abscissas for interpolation,
                      note that this array <em>is</em> modified during computation                    
                </param>
                <param>
                    y reference points ordinates for interpolation                    
                </param>
                <param>
                    start start index of the points to consider (inclusive)                    
                </param>
                <param>
                    end end index of the points to consider (exclusive)                    
                </param>
                <return>
                    guessed root (will be a NaN if two points share the same y)                    
                </return>
            </javadoc>
            <method name="guessX" type="Dfp" line="304">
                <params>
                    <param name="targetY" type="Dfp"/>
                    <param name="x" type="Dfp[]"/>
                    <param name="y" type="Dfp[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="305">
                    <declaration name="delta" type="int" line="306"/>
                    <scope line="307"/>
                </scope>
                <declaration name="x0" type="Dfp" line="311"/>
                <scope line="312"/>
            </method>
        </class>
    </source>