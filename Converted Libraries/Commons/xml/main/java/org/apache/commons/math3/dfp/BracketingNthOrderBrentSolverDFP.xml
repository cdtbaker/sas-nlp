<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.dfp">
        <import package="org.apache.commons.math3.analysis.solvers.AllowedSolution"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NoBracketingException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.util.Incrementor"/>
        <import package="org.apache.commons.math3.util.MathUtils"/>
        <class name="BracketingNthOrderBrentSolverDFP" line="28">
            <javadoc line="28">
                This class implements a modification of the &lt;a
                  href=&quot;http://mathworld.wolfram.com/BrentsMethod.html&quot;&gt; Brent algorithm&lt;/a&gt;.
                  &lt;p&gt;
                  The changes with respect to the original Brent algorithm are:
                  &lt;ul&gt;
                  &lt;li&gt;the returned value is chosen in the current interval according
                  to user specified {@link AllowedSolution},&lt;/li&gt;
                  &lt;li&gt;the maximal order for the invert polynomial root search is
                  user-specified instead of being invert quadratic only&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/p&gt;
                  The given interval must bracket the root.                
                <version>
                    $Id: BracketingNthOrderBrentSolverDFP.java 1416643 2012-12-03 19:37:14Z tn $                    
                </version>
            </javadoc>
            <declaration name="MAXIMAL_AGING" type="int" line="46"/>
            <javadoc line="46">
                Maximal aging triggering an attempt to balance the bracketing interval.                
            </javadoc>
            <declaration name="maximalOrder" type="int" line="49"/>
            <javadoc line="49">
                Maximal order.                
            </javadoc>
            <declaration name="functionValueAccuracy" type="Dfp" line="52"/>
            <javadoc line="52">
                Function value accuracy.                
            </javadoc>
            <declaration name="absoluteAccuracy" type="Dfp" line="55"/>
            <javadoc line="55">
                Absolute accuracy.                
            </javadoc>
            <declaration name="relativeAccuracy" type="Dfp" line="58"/>
            <javadoc line="58">
                Relative accuracy.                
            </javadoc>
            <declaration name="evaluations" type="Incrementor" line="61"/>
            <javadoc line="61">
                Evaluations counter.                
            </javadoc>
            <javadoc line="64">
                Construct a solver.                
                <param>
                    relativeAccuracy Relative accuracy.                    
                </param>
                <param>
                    absoluteAccuracy Absolute accuracy.                    
                </param>
                <param>
                    functionValueAccuracy Function value accuracy.                    
                </param>
                <param>
                    maximalOrder maximal order.                    
                </param>
                <exception>
                    NumberIsTooSmallException if maximal order is lower than 2                    
                </exception>
            </javadoc>
            <method name="BracketingNthOrderBrentSolverDFP" type="constructor" line="77">
                <params>
                    <param name="relativeAccuracy" type="Dfp"/>
                    <param name="absoluteAccuracy" type="Dfp"/>
                    <param name="functionValueAccuracy" type="Dfp"/>
                    <param name="maximalOrder" type="int"/>
                </params>
                <scope line="78"/>
            </method>
            <javadoc line="87">
                Get the maximal order.                
                <return>
                    maximal order                    
                </return>
            </javadoc>
            <method name="getMaximalOrder" type="int" line="90"/>
            <javadoc line="94">
                Get the maximal number of function evaluations.                
                <return>
                    the maximal number of function evaluations.                    
                </return>
            </javadoc>
            <method name="getMaxEvaluations" type="int" line="99"/>
            <javadoc line="103">
                Get the number of evaluations of the objective function.
                  The number of evaluations corresponds to the last call to the{@code optimize} method. It is 0 if the method has not been
                  called yet.                
                <return>
                    the number of evaluations of the objective function.                    
                </return>
            </javadoc>
            <method name="getEvaluations" type="int" line="111"/>
            <javadoc line="115">
                Get the absolute accuracy.                
                <return>
                    absolute accuracy                    
                </return>
            </javadoc>
            <method name="getAbsoluteAccuracy" type="Dfp" line="119"/>
            <javadoc line="123">
                Get the relative accuracy.                
                <return>
                    relative accuracy                    
                </return>
            </javadoc>
            <method name="getRelativeAccuracy" type="Dfp" line="127"/>
            <javadoc line="131">
                Get the function accuracy.                
                <return>
                    function accuracy                    
                </return>
            </javadoc>
            <method name="getFunctionValueAccuracy" type="Dfp" line="135"/>
            <javadoc line="139">
                Solve for a zero in the given interval.
                  A solver may require that the interval brackets a single zero root.
                  Solvers that do require bracketing should be able to handle the case
                  where one of the endpoints is itself a root.                
                <param>
                    maxEval Maximum number of evaluations.                    
                </param>
                <param>
                    f Function to solve.                    
                </param>
                <param>
                    min Lower bound for the interval.                    
                </param>
                <param>
                    max Upper bound for the interval.                    
                </param>
                <param>
                    allowedSolution The kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <exception>
                    NullArgumentException if f is null.                    
                </exception>
                <exception>
                    NoBracketingException if root cannot be bracketed                    
                </exception>
            </javadoc>
            <method name="solve" type="Dfp" line="157">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateDfpFunction"/>
                    <param name="min" type="Dfp"/>
                    <param name="max" type="Dfp"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
            </method>
            <javadoc line="161">
                Solve for a zero in the given interval, start at {@code startValue}.
                  A solver may require that the interval brackets a single zero root.
                  Solvers that do require bracketing should be able to handle the case
                  where one of the endpoints is itself a root.                
                <param>
                    maxEval Maximum number of evaluations.                    
                </param>
                <param>
                    f Function to solve.                    
                </param>
                <param>
                    min Lower bound for the interval.                    
                </param>
                <param>
                    max Upper bound for the interval.                    
                </param>
                <param>
                    startValue Start value to use.                    
                </param>
                <param>
                    allowedSolution The kind of solutions that the root-finding algorithm may
                      accept as solutions.                    
                </param>
                <return>
                    a value where the function is zero.                    
                </return>
                <exception>
                    NullArgumentException if f is null.                    
                </exception>
                <exception>
                    NoBracketingException if root cannot be bracketed                    
                </exception>
            </javadoc>
            <method name="solve" type="Dfp" line="181">
                <params>
                    <param name="maxEval" type="int"/>
                    <param name="f" type="UnivariateDfpFunction"/>
                    <param name="min" type="Dfp"/>
                    <param name="max" type="Dfp"/>
                    <param name="startValue" type="Dfp"/>
                    <param name="allowedSolution" type="AllowedSolution"/>
                </params>
                <comment line="184">
                    Checks.                    
                </comment>
                <comment line="187">
                    Reset.                    
                </comment>
                <comment line="193">
                    prepare arrays with the first points                    
                </comment>
                <comment line="200">
                    evaluate initial guess                    
                </comment>
                <comment line="204">
                    return the initial guess if it is a perfect root.                    
                </comment>
                <comment line="208">
                    evaluate first  endpoint                    
                </comment>
                <comment line="212">
                    return the first endpoint if it is a perfect root.                    
                </comment>
                <comment line="220">
                    reduce interval if it brackets the root                    
                </comment>
                <comment line="226">
                    evaluate second endpoint                    
                </comment>
                <comment line="230">
                    return the second endpoint if it is a perfect root.                    
                </comment>
                <comment line="235">
                    use all computed point as a start sampling array for solving                    
                </comment>
                <comment line="245">
                    prepare a work array for inverse polynomial interpolation                    
                </comment>
                <comment line="248">
                    current tightest bracketing of the root                    
                </comment>
                <comment line="260">
                    search loop                    
                </comment>
                <comment line="263">
                    check convergence of bracketing interval                    
                </comment>
                <comment line="281">
                    this should never happen                    
                </comment>
                <comment line="286">
                    target for the next evaluation point                    
                </comment>
                <comment line="289">
                    we keep updating the high bracket, try to compensate this                    
                </comment>
                <comment line="292">
                    we keep updating the low bracket, try to compensate this                    
                </comment>
                <comment line="295">
                    bracketing is balanced, try to find the root itself                    
                </comment>
                <comment line="299">
                    make a few attempts to guess a root,                    
                </comment>
                <comment line="305">
                    guess a value for current target, using inverse polynomial interpolation                    
                </comment>
                <comment line="310">
                    the guessed root is not strictly inside of the tightest bracketing interval                    
                </comment>
                <comment line="312">
                    the guessed root is either not strictly inside the interval or it
                     is a NaN (which occurs when some sampling points share the same y)
                     we try again with a lower interpolation order                    
                </comment>
                <comment line="316">
                    we have more points before the sign change, drop the lowest point                    
                </comment>
                <comment line="319">
                    we have more points after sign change, drop the highest point                    
                </comment>
                <comment line="323">
                    we need to do one more attempt                    
                </comment>
                <comment line="331">
                    fall back to bisection                    
                </comment>
                <comment line="337">
                    evaluate the function at the guessed root                    
                </comment>
                <comment line="341">
                    we have found an exact root, since it is not an approximation
                     we don&apos;t need to bother about the allowed solutions setting                    
                </comment>
                <comment line="348">
                    we have been forced to ignore some points to keep bracketing,
                     they are probably too far from the root, drop them from now on                    
                </comment>
                <comment line="357">
                    we have to drop one point in order to insert the new one                    
                </comment>
                <comment line="360">
                    keep the tightest bracketing interval as centered as possible                    
                </comment>
                <comment line="362">
                    we drop the lowest point, we have to shift the arrays and the index                    
                </comment>
                <comment line="370">
                    insert the last computed point
                    (by construction, we know it lies inside the tightest bracketing interval)                    
                </comment>
                <comment line="378">
                    update the bracketing interval                    
                </comment>
                <comment line="380">
                    the sign change occurs before the inserted point                    
                </comment>
                <comment line="387">
                    the sign change occurs after the inserted point                    
                </comment>
                <comment line="394">
                    update the sign change index                    
                </comment>
                <declaration name="zero" type="Dfp" line="189"/>
                <declaration name="nan" type="Dfp" line="190"/>
                <declaration name="x" type="Dfp[]" line="193"/>
                <declaration name="y" type="Dfp[]" line="194"/>
                <scope line="202"/>
                <scope line="210"/>
                <declaration name="nbPoints" type="int" line="215"/>
                <declaration name="signChangeIndex" type="int" line="216"/>
                <scope line="217"/>
                <scope line="223">
                    <scope line="228"/>
                    <scope line="233"/>
                    <scope line="237"/>
                </scope>
                <declaration name="tmpX" type="Dfp[]" line="245"/>
                <declaration name="xA" type="Dfp" line="248"/>
                <declaration name="yA" type="Dfp" line="249"/>
                <declaration name="absXA" type="Dfp" line="250"/>
                <declaration name="absYA" type="Dfp" line="251"/>
                <declaration name="agingA" type="int" line="252"/>
                <declaration name="xB" type="Dfp" line="253"/>
                <declaration name="yB" type="Dfp" line="254"/>
                <declaration name="absXB" type="Dfp" line="255"/>
                <declaration name="absYB" type="Dfp" line="256"/>
                <declaration name="agingB" type="int" line="257"/>
                <scope line="260">
                    <declaration name="maxX" type="Dfp" line="263"/>
                    <declaration name="maxY" type="Dfp" line="264"/>
                    <declaration name="xTol" type="Dfp" line="265"/>
                    <scope line="267"/>
                    <declaration name="targetY" type="Dfp" line="286"/>
                    <scope line="287"/>
                    <scope line="290"/>
                    <scope line="293"/>
                    <declaration name="nextX" type="Dfp" line="299"/>
                    <declaration name="start" type="int" line="300"/>
                    <declaration name="end" type="int" line="301"/>
                    <scope line="302">
                        <scope line="308">
                            <scope line="314"/>
                            <scope line="317"/>
                        </scope>
                    </scope>
                    <scope line="329"/>
                    <declaration name="nextY" type="Dfp" line="338"/>
                    <scope line="339"/>
                    <scope line="345"/>
                    <scope line="354">
                        <scope line="360"/>
                    </scope>
                    <scope line="378"/>
                    <scope line="385"/>
                </scope>
            </method>
            <javadoc line="402">
                Guess an x value by n&lt;sup&gt;th&lt;/sup&gt; order inverse polynomial interpolation.
                  &lt;p&gt;
                  The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q
                  is built such that for all considered points (x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;),
                  Q(y&lt;sub&gt;i&lt;/sub&gt;) = x&lt;sub&gt;i&lt;/sub&gt;.
                  &lt;/p&gt;                
                <param>
                    targetY target value for y                    
                </param>
                <param>
                    x reference points abscissas for interpolation,
                      note that this array <em>is</em> modified during computation                    
                </param>
                <param>
                    y reference points ordinates for interpolation                    
                </param>
                <param>
                    start start index of the points to consider (inclusive)                    
                </param>
                <param>
                    end end index of the points to consider (exclusive)                    
                </param>
                <return>
                    guessed root (will be a NaN if two points share the same y)                    
                </return>
            </javadoc>
            <method name="guessX" type="Dfp" line="417">
                <params>
                    <param name="targetY" type="Dfp"/>
                    <param name="x" type="Dfp[]"/>
                    <param name="y" type="Dfp[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="420">
                    compute Q Newton coefficients by divided differences                    
                </comment>
                <comment line="428">
                    evaluate Q(targetY)                    
                </comment>
                <scope line="420">
                    <declaration name="delta" type="int" line="421"/>
                    <scope line="422"/>
                </scope>
                <declaration name="x0" type="Dfp" line="428"/>
                <scope line="429"/>
            </method>
        </class>
    </source>