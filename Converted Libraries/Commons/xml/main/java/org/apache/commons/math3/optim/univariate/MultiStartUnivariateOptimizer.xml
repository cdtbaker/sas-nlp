<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.univariate">
        <import package="java.util.Arrays"/>
        <import package="java.util.Comparator"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <import package="org.apache.commons.math3.random.RandomGenerator"/>
        <import package="org.apache.commons.math3.optim.MaxEval"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.OptimizationData"/>
        <class name="MultiStartUnivariateOptimizer" line="30">
            <extends class="UnivariateOptimizer"/>
            <javadoc line="30">
                Special implementation of the {@link UnivariateOptimizer} interface
                  adding multi-start features to an existing optimizer.
                  &lt;br/&gt;
                  This class wraps an optimizer in order to use it several times in
                  turn with different starting points (trying to avoid being trapped
                  in a local extremum when looking for a global one).                
                <version>
                    $Id: MultiStartUnivariateOptimizer.java 1435539 2013-01-19 13:27:24Z tn $                    
                </version>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <declaration name="optimizer" type="UnivariateOptimizer" line="43"/>
            <javadoc line="43">
                Underlying classical optimizer.                
            </javadoc>
            <declaration name="totalEvaluations" type="int" line="45"/>
            <javadoc line="45">
                Number of evaluations already performed for all starts.                
            </javadoc>
            <declaration name="starts" type="int" line="47"/>
            <javadoc line="47">
                Number of starts to go.                
            </javadoc>
            <declaration name="generator" type="RandomGenerator" line="49"/>
            <javadoc line="49">
                Random generator for multi-start.                
            </javadoc>
            <declaration name="optima" type="UnivariatePointValuePair[]" line="51"/>
            <javadoc line="51">
                Found optima.                
            </javadoc>
            <declaration name="optimData" type="OptimizationData[]" line="53"/>
            <javadoc line="53">
                Optimization data.                
            </javadoc>
            <declaration name="maxEvalIndex" type="int" line="55"/>
            <javadoc line="55">
                Location in {@link #optimData} where the updated maximum
                  number of evaluations will be stored.                
            </javadoc>
            <declaration name="searchIntervalIndex" type="int" line="60"/>
            <javadoc line="60">
                Location in {@link #optimData} where the updated start value
                  will be stored.                
            </javadoc>
            <javadoc line="66">
                Create a multi-start optimizer from a single-start optimizer.                
                <param>
                    optimizer Single-start optimizer to wrap.                    
                </param>
                <param>
                    starts Number of starts to perform. If {@code starts == 1},
                      the {@code optimize} methods will return the same solution as{@code optimizer} would.                    
                </param>
                <param>
                    generator Random generator to use for restarts.                    
                </param>
                <throws>
                    NotStrictlyPositiveException if {@code starts < 1}.                    
                </throws>
            </javadoc>
            <method name="MultiStartUnivariateOptimizer" type="constructor" line="78">
                <params>
                    <param name="optimizer" type="UnivariateOptimizer"/>
                    <param name="starts" type="int"/>
                    <param name="generator" type="RandomGenerator"/>
                </params>
                <scope line="81"/>
            </method>
            <javadoc line="90">
                {@inheritDoc}                
            </javadoc>
            <method name="getEvaluations" type="int" line="92"/>
            <javadoc line="96">
                Gets all the optima found during the last call to {@code optimize}.
                  The optimizer stores all the optima found during a set of
                  restarts. The {@code optimize} method returns the best point only.
                  This method returns all the points found at the end of each starts,
                  including the best one already returned by the {@code optimize} method.
                  &lt;br/&gt;
                  The returned array as one element for each start as specified
                  in the constructor. It is ordered with the results from the
                  runs that did converge first, sorted from best to worst
                  objective value (i.e in ascending order if minimizing and in
                  descending order if maximizing), followed by {@code null} elements
                  corresponding to the runs that did not converge. This means all
                  elements will be {@code null} if the {@code optimize} method did throw
                  an exception.
                  This also means that if the first element is not {@code null}, it is
                  the best point found across all starts.                
                <return>
                    an array containing the optima.                    
                </return>
                <throws>
                    MathIllegalStateException if {@link #optimize(OptimizationData[])optimize} has not been called.                    
                </throws>
            </javadoc>
            <method name="getOptima" type="UnivariatePointValuePair[]" line="118">
                <scope line="119"/>
            </method>
            <javadoc line="125">
                {@inheritDoc}                
                <throws>
                    MathIllegalStateException if {@code optData} does not contain an
                      instance of {@link MaxEval} or {@link SearchInterval}.                    
                </throws>
            </javadoc>
            <method name="optimize" type="UnivariatePointValuePair" line="132">
                <params>
                    <param name="optData" type="OptimizationData"/>
                </params>
                <comment line="133">
                    Store arguments in order to pass them to the internal optimizer.                    
                </comment>
                <comment line="135">
                    Set up base class and perform computations.                    
                </comment>
            </method>
            <javadoc line="139">
                {@inheritDoc}                
            </javadoc>
            <method name="doOptimize" type="UnivariatePointValuePair" line="141">
                <comment line="142">
                    Remove all instances of &quot;MaxEval&quot; and &quot;SearchInterval&quot; from the                    
                </comment>
                <comment line="143">
                    array that will be passed to the internal optimizer.                    
                </comment>
                <comment line="144">
                    The former is to enforce smaller numbers of allowed evaluations                    
                </comment>
                <comment line="145">
                    (according to how many have been used up already), and the latter                    
                </comment>
                <comment line="146">
                    to impose a different start value for each start.                    
                </comment>
                <comment line="175">
                    Multi-start loop.                    
                </comment>
                <comment line="177">
                    CHECKSTYLE: stop IllegalCatch                    
                </comment>
                <comment line="179">
                    Decrease number of allowed evaluations.                    
                </comment>
                <comment line="181">
                    New start value.                    
                </comment>
                <comment line="186">
                    Optimize.                    
                </comment>
                <comment line="192">
                    CHECKSTYLE: resume IllegalCatch                    
                </comment>
                <comment line="200">
                    Cannot be null if starts &gt;= 1.                    
                </comment>
                <comment line="203">
                    Return the point with the best objective function value.                    
                </comment>
                <scope line="147">
                    <scope line="148"/>
                    <scope line="153"/>
                </scope>
                <scope line="159"/>
                <scope line="162"/>
                <declaration name="lastException" type="RuntimeException" line="166"/>
                <declaration name="maxEval" type="int" line="170"/>
                <declaration name="min" type="double" line="171"/>
                <declaration name="max" type="double" line="172"/>
                <declaration name="startValue" type="double" line="173"/>
                <scope line="176">
                    <scope line="178">
                        <declaration name="s" type="double" line="182"/>
                    </scope>
                    <scope line="188"/>
                </scope>
                <scope line="199"/>
            </method>
            <javadoc line="207">
                Sort the optima from best to worst, followed by {@code null} elements.                
                <param>
                    goal Goal type.                    
                </param>
            </javadoc>
            <method name="sortPairs" type="void" line="212">
                <params>
                    <param name="goal" type="GoalType"/>
                </params>
                <anonymous_class line="213">
                    <method name="compare" type="int" line="215">
                        <params>
                            <param name="o1" type="UnivariatePointValuePair"/>
                            <param name="o2" type="UnivariatePointValuePair"/>
                        </params>
                        <scope line="216"/>
                        <scope line="218"/>
                        <declaration name="v1" type="double" line="221"/>
                        <declaration name="v2" type="double" line="222"/>
                    </method>
                </anonymous_class>
            </method>
        </class>
    </source>