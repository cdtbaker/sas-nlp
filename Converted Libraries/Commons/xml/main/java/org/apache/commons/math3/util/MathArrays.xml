<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.util">
        <import package="java.lang.reflect.Array"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.List"/>
        <import package="org.apache.commons.math3.Field"/>
        <import package="org.apache.commons.math3.random.RandomGenerator"/>
        <import package="org.apache.commons.math3.random.Well19937c"/>
        <import package="org.apache.commons.math3.distribution.UniformIntegerDistribution"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathArithmeticException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalArgumentException"/>
        <import package="org.apache.commons.math3.exception.MathInternalError"/>
        <import package="org.apache.commons.math3.exception.NoDataException"/>
        <import package="org.apache.commons.math3.exception.NonMonotonicSequenceException"/>
        <import package="org.apache.commons.math3.exception.NotPositiveException"/>
        <import package="org.apache.commons.math3.exception.NotStrictlyPositiveException"/>
        <import package="org.apache.commons.math3.exception.NullArgumentException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.util.LocalizedFormats"/>
        <class name="MathArrays" line="43">
            <javadoc line="43">
                Arrays utilities.                
                <since>
                    3.0                    
                </since>
                <version>
                    $Id: MathArrays.java 1591835 2014-05-02 09:04:01Z tn $                    
                </version>
            </javadoc>
            <declaration name="SPLIT_FACTOR" type="int" line="50"/>
            <javadoc line="50">
                Factor used for splitting double numbers: n = 2^27 + 1 (i.e. {@value}).                
            </javadoc>
            <javadoc line="53">
                Private constructor.                
            </javadoc>
            <method name="MathArrays" type="constructor" line="56"/>
            <interface name="Function">
                <javadoc line="58">
                    Real-valued function that operate on an array or a part of it.                    
                    <since>
                        3.1                        
                    </since>
                </javadoc>
                <method name="evaluate" type="double" line="63"/>
                <javadoc line="63">
                    Operates on an entire array.                    
                    <param>
                        array Array to operate on.                        
                    </param>
                    <return>
                        the result of the operation.                        
                    </return>
                </javadoc>
                <method name="evaluate" type="double" line="70"/>
                <javadoc line="70">
                    @param array Array to operate on.                    
                    <param>
                        startIndex Index of the first element to take into account.                        
                    </param>
                    <param>
                        numElements Number of elements to take into account.                        
                    </param>
                    <return>
                        the result of the operation.                        
                    </return>
                </javadoc>
            </interface>
            <javadoc line="81">
                Create a copy of an array scaled by a value.                
                <param>
                    arr Array to scale.                    
                </param>
                <param>
                    val Scalar.                    
                </param>
                <return>
                    scaled copy of array with each entry multiplied by val.                    
                </return>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <method name="scale" type="double[]" line="89">
                <params>
                    <param name="val" type="double"/>
                    <param name="arr" type="double[]"/>
                </params>
                <declaration name="newArr" type="double[]" line="90"/>
                <scope line="91"/>
            </method>
            <javadoc line="97">
                &lt;p&gt;Multiply each element of an array by a value.&lt;/p&gt;
                  &lt;p&gt;The array is modified in place (no copy is created).&lt;/p&gt;                
                <param>
                    arr Array to scale                    
                </param>
                <param>
                    val Scalar                    
                </param>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <method name="scaleInPlace" type="void" line="106">
                <params>
                    <param name="val" type="double"/>
                    <param name="arr" type="double[]"/>
                </params>
                <scope line="107"/>
            </method>
            <javadoc line="112">
                Creates an array whose contents will be the element-by-element
                  addition of the arguments.                
                <param>
                    a First term of the addition.                    
                </param>
                <param>
                    b Second term of the addition.                    
                </param>
                <return>
                    a new array {@code r} where {@code r[i] = a[i] + b[i]}.                    
                </return>
                <throws>
                    DimensionMismatchException if the array lengths differ.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="ebeAdd" type="double[]" line="123">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="b" type="double[]"/>
                </params>
                <scope line="124"/>
                <declaration name="result" type="double[]" line="128"/>
                <scope line="129"/>
            </method>
            <javadoc line="134">
                Creates an array whose contents will be the element-by-element
                  subtraction of the second argument from the first.                
                <param>
                    a First term.                    
                </param>
                <param>
                    b Element to be subtracted.                    
                </param>
                <return>
                    a new array {@code r} where {@code r[i] = a[i] - b[i]}.                    
                </return>
                <throws>
                    DimensionMismatchException if the array lengths differ.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="ebeSubtract" type="double[]" line="145">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="b" type="double[]"/>
                </params>
                <scope line="146"/>
                <declaration name="result" type="double[]" line="150"/>
                <scope line="151"/>
            </method>
            <javadoc line="156">
                Creates an array whose contents will be the element-by-element
                  multiplication of the arguments.                
                <param>
                    a First factor of the multiplication.                    
                </param>
                <param>
                    b Second factor of the multiplication.                    
                </param>
                <return>
                    a new array {@code r} where {@code r[i] = a[i]  b[i]}.                    
                </return>
                <throws>
                    DimensionMismatchException if the array lengths differ.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="ebeMultiply" type="double[]" line="167">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="b" type="double[]"/>
                </params>
                <scope line="168"/>
                <declaration name="result" type="double[]" line="172"/>
                <scope line="173"/>
            </method>
            <javadoc line="178">
                Creates an array whose contents will be the element-by-element
                  division of the first argument by the second.                
                <param>
                    a Numerator of the division.                    
                </param>
                <param>
                    b Denominator of the division.                    
                </param>
                <return>
                    a new array {@code r} where {@code r[i] = a[i] / b[i]}.                    
                </return>
                <throws>
                    DimensionMismatchException if the array lengths differ.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="ebeDivide" type="double[]" line="189">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="b" type="double[]"/>
                </params>
                <scope line="190"/>
                <declaration name="result" type="double[]" line="194"/>
                <scope line="195"/>
            </method>
            <javadoc line="201">
                Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.                
                <param>
                    p1 the first point                    
                </param>
                <param>
                    p2 the second point                    
                </param>
                <return>
                    the L&lt;sub&gt;1&lt;/sub&gt; distance between the two points                    
                </return>
            </javadoc>
            <method name="distance1" type="double" line="208">
                <params>
                    <param name="p1" type="double[]"/>
                    <param name="p2" type="double[]"/>
                </params>
                <declaration name="sum" type="double" line="209"/>
                <scope line="210"/>
            </method>
            <javadoc line="216">
                Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.                
                <param>
                    p1 the first point                    
                </param>
                <param>
                    p2 the second point                    
                </param>
                <return>
                    the L&lt;sub&gt;1&lt;/sub&gt; distance between the two points                    
                </return>
            </javadoc>
            <method name="distance1" type="int" line="223">
                <params>
                    <param name="p1" type="int[]"/>
                    <param name="p2" type="int[]"/>
                </params>
                <declaration name="sum" type="int" line="224"/>
                <scope line="225"/>
            </method>
            <javadoc line="231">
                Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.                
                <param>
                    p1 the first point                    
                </param>
                <param>
                    p2 the second point                    
                </param>
                <return>
                    the L&lt;sub&gt;2&lt;/sub&gt; distance between the two points                    
                </return>
            </javadoc>
            <method name="distance" type="double" line="238">
                <params>
                    <param name="p1" type="double[]"/>
                    <param name="p2" type="double[]"/>
                </params>
                <declaration name="sum" type="double" line="239"/>
                <scope line="240">
                    <declaration name="dp" type="double" line="241"/>
                </scope>
            </method>
            <javadoc line="247">
                Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.                
                <param>
                    p1 the first point                    
                </param>
                <param>
                    p2 the second point                    
                </param>
                <return>
                    the L&lt;sub&gt;2&lt;/sub&gt; distance between the two points                    
                </return>
            </javadoc>
            <method name="distance" type="double" line="254">
                <params>
                    <param name="p1" type="int[]"/>
                    <param name="p2" type="int[]"/>
                </params>
                <declaration name="sum" type="double" line="255"/>
                <scope line="256">
                    <declaration name="dp" type="double" line="257"/>
                </scope>
            </method>
            <javadoc line="263">
                Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.                
                <param>
                    p1 the first point                    
                </param>
                <param>
                    p2 the second point                    
                </param>
                <return>
                    the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; distance between the two points                    
                </return>
            </javadoc>
            <method name="distanceInf" type="double" line="270">
                <params>
                    <param name="p1" type="double[]"/>
                    <param name="p2" type="double[]"/>
                </params>
                <declaration name="max" type="double" line="271"/>
                <scope line="272"/>
            </method>
            <javadoc line="278">
                Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.                
                <param>
                    p1 the first point                    
                </param>
                <param>
                    p2 the second point                    
                </param>
                <return>
                    the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; distance between the two points                    
                </return>
            </javadoc>
            <method name="distanceInf" type="int" line="285">
                <params>
                    <param name="p1" type="int[]"/>
                    <param name="p2" type="int[]"/>
                </params>
                <declaration name="max" type="int" line="286"/>
                <scope line="287"/>
            </method>
            <declaration name="OrderDirection" type="enum" line="293"/>
            <javadoc line="293">
                Specification of ordering direction.                
            </javadoc>
            <scope line="296"/>
            <javadoc line="303">
                Check that an array is monotonically increasing or decreasing.                
                <param>
                    &lt;T&gt;
                       the type of the elements in the specified array                    
                </param>
                <param>
                    val Values.                    
                </param>
                <param>
                    dir Ordering direction.                    
                </param>
                <param>
                    strict Whether the order should be strict.                    
                </param>
                <return>
                    {@code true} if sorted, {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isMonotonic" type="boolean" line="314">
                <params>
                    <param name="val" type="T[]"/>
                    <param name="dir" type="OrderDirection"/>
                    <param name="strict" type="boolean"/>
                </params>
                <comment line="346">
                    Should never happen.                    
                </comment>
                <declaration name="previous" type="T" line="315"/>
                <declaration name="max" type="int" line="316"/>
                <scope line="317">
                    <declaration name="comp" type="int" line="318"/>
                    <scope line="322">
                        <scope line="323"/>
                    </scope>
                    <scope line="326">
                        <scope line="327"/>
                    </scope>
                    <scope line="334">
                        <scope line="335"/>
                    </scope>
                    <scope line="338">
                        <scope line="339"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="354">
                Check that an array is monotonically increasing or decreasing.                
                <param>
                    val Values.                    
                </param>
                <param>
                    dir Ordering direction.                    
                </param>
                <param>
                    strict Whether the order should be strict.                    
                </param>
                <return>
                    {@code true} if sorted, {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isMonotonic" type="boolean" line="362">
                <params>
                    <param name="val" type="double[]"/>
                    <param name="dir" type="OrderDirection"/>
                    <param name="strict" type="boolean"/>
                </params>
            </method>
            <javadoc line="366">
                Check that the given array is sorted.                
                <param>
                    val Values.                    
                </param>
                <param>
                    dir Ordering direction.                    
                </param>
                <param>
                    strict Whether the order should be strict.                    
                </param>
                <param>
                    abort Whether to throw an exception if the check fails.                    
                </param>
                <return>
                    {@code true} if the array is sorted.                    
                </return>
                <throws>
                    NonMonotonicSequenceException if the array is not sorted
                      and {@code abort} is {@code true}.                    
                </throws>
            </javadoc>
            <method name="checkOrder" type="boolean" line="379">
                <params>
                    <param name="val" type="double[]"/>
                    <param name="dir" type="OrderDirection"/>
                    <param name="strict" type="boolean"/>
                    <param name="abort" type="boolean"/>
                </params>
                <comment line="411">
                    Should never happen.                    
                </comment>
                <comment line="419">
                    Loop completed.                    
                </comment>
                <comment line="423">
                    Loop early exit means wrong ordering.                    
                </comment>
                <declaration name="previous" type="double" line="380"/>
                <declaration name="max" type="int" line="381"/>
                <declaration name="index" type="int" line="383"/>
                <scope line="385">
                    <scope line="388">
                        <scope line="389"/>
                    </scope>
                    <scope line="392">
                        <scope line="393"/>
                    </scope>
                    <scope line="399">
                        <scope line="400"/>
                    </scope>
                    <scope line="403">
                        <scope line="404"/>
                    </scope>
                </scope>
                <scope line="417"/>
                <scope line="423"/>
                <scope line="425"/>
            </method>
            <javadoc line="430">
                Check that the given array is sorted.                
                <param>
                    val Values.                    
                </param>
                <param>
                    dir Ordering direction.                    
                </param>
                <param>
                    strict Whether the order should be strict.                    
                </param>
                <throws>
                    NonMonotonicSequenceException if the array is not sorted.                    
                </throws>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="checkOrder" type="void" line="440">
                <params>
                    <param name="val" type="double[]"/>
                    <param name="dir" type="OrderDirection"/>
                    <param name="strict" type="boolean"/>
                </params>
            </method>
            <javadoc line="444">
                Check that the given array is sorted in strictly increasing order.                
                <param>
                    val Values.                    
                </param>
                <throws>
                    NonMonotonicSequenceException if the array is not sorted.                    
                </throws>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="checkOrder" type="void" line="451">
                <params>
                    <param name="val" type="double[]"/>
                </params>
            </method>
            <javadoc line="455">
                Throws DimensionMismatchException if the input array is not rectangular.                
                <param>
                    in array to be tested                    
                </param>
                <throws>
                    NullArgumentException if input array is null                    
                </throws>
                <throws>
                    DimensionMismatchException if input array is not rectangular                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="checkRectangular" type="void" line="464">
                <params>
                    <param name="in" type="long[][]"/>
                </params>
                <scope line="466">
                    <scope line="467"/>
                </scope>
            </method>
            <javadoc line="475">
                Check that all entries of the input array are strictly positive.                
                <param>
                    in Array to be tested                    
                </param>
                <throws>
                    NotStrictlyPositiveException if any entries of the array are not
                      strictly positive.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="checkPositive" type="void" line="484">
                <params>
                    <param name="in" type="double[]"/>
                </params>
                <scope line="485">
                    <scope line="486"/>
                </scope>
            </method>
            <javadoc line="492">
                Check that all entries of the input array are &gt;= 0.                
                <param>
                    in Array to be tested                    
                </param>
                <throws>
                    NotPositiveException if any array entries are less than 0.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="checkNonNegative" type="void" line="500">
                <params>
                    <param name="in" type="long[]"/>
                </params>
                <scope line="501">
                    <scope line="502"/>
                </scope>
            </method>
            <javadoc line="508">
                Check all entries of the input array are &gt;= 0.                
                <param>
                    in Array to be tested                    
                </param>
                <throws>
                    NotPositiveException if any array entries are less than 0.                    
                </throws>
                <since>
                    3.1                    
                </since>
            </javadoc>
            <method name="checkNonNegative" type="void" line="516">
                <params>
                    <param name="in" type="long[][]"/>
                </params>
                <scope line="517">
                    <scope line="518">
                        <scope line="519"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="526">
                Returns the Cartesian norm (2-norm), handling both overflow and underflow.
                  Translation of the minpack enorm subroutine.
                  The redistribution policy for MINPACK is available
                  &lt;a href=&quot;http://www.netlib.org/minpack/disclaimer&quot;&gt;here&lt;/a&gt;, for
                  convenience, it is reproduced below.&lt;/p&gt;
                  &lt;table border=&quot;0&quot; width=&quot;80%&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;#E0E0E0&quot;&gt;
                  &lt;tr&gt;&lt;td&gt;
                  Minpack Copyright Notice (1999) University of Chicago.
                  All rights reserved
                  &lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;
                  Redistribution and use in source and binary forms, with or without
                  modification, are permitted provided that the following conditions
                  are met:
                  &lt;ol&gt;
                  &lt;li&gt;Redistributions of source code must retain the above copyright
                  notice, this list of conditions and the following disclaimer.&lt;/li&gt;
                  &lt;li&gt;Redistributions in binary form must reproduce the above
                  copyright notice, this list of conditions and the following
                  disclaimer in the documentation and/or other materials provided
                  with the distribution.&lt;/li&gt;
                  &lt;li&gt;The end-user documentation included with the redistribution, if any,
                  must include the following acknowledgment:{@code This product includes software developed by the University of
                  Chicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself,
                  if and wherever such third-party acknowledgments normally appear.&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED &quot;AS IS&quot;
                  WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
                  UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
                  THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
                  IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
                  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
                  OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
                  OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
                  USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
                  THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
                  DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
                  UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
                  BE CORRECTED.&lt;/strong&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
                  HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
                  ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
                  INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
                  ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
                  PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
                  SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
                  (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
                  EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
                  POSSIBILITY OF SUCH LOSS OR DAMAGES.&lt;/strong&gt;&lt;/li&gt;
                  &lt;ol&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    v Vector of doubles.                    
                </param>
                <return>
                    the 2-norm of the vector.                    
                </return>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="safeNorm" type="double" line="586">
                <params>
                    <param name="v" type="double[]"/>
                </params>
                <declaration name="rdwarf" type="double" line="587"/>
                <declaration name="rgiant" type="double" line="588"/>
                <declaration name="s1" type="double" line="589"/>
                <declaration name="s2" type="double" line="590"/>
                <declaration name="s3" type="double" line="591"/>
                <declaration name="x1max" type="double" line="592"/>
                <declaration name="x3max" type="double" line="593"/>
                <declaration name="floatn" type="double" line="594"/>
                <declaration name="agiant" type="double" line="595"/>
                <scope line="596">
                    <declaration name="xabs" type="double" line="597"/>
                    <scope line="598">
                        <scope line="599">
                            <scope line="600">
                                <declaration name="r" type="double" line="601"/>
                            </scope>
                            <scope line="604">
                                <declaration name="r" type="double" line="605"/>
                            </scope>
                        </scope>
                        <scope line="608">
                            <scope line="609">
                                <declaration name="r" type="double" line="610"/>
                            </scope>
                            <scope line="613">
                                <scope line="614">
                                    <declaration name="r" type="double" line="615"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="620"/>
                </scope>
                <declaration name="norm" type="double" line="624"/>
                <scope line="625"/>
                <scope line="627">
                    <scope line="628"/>
                    <scope line="630">
                        <scope line="631"/>
                        <scope line="633"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="641">
                Sort an array in ascending order in place and perform the same reordering
                  of entries on other arrays. For example, if{@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then{@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},{@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.                
                <param>
                    x Array to be sorted and used as a pattern for permutation
                      of the other arrays.                    
                </param>
                <param>
                    yList Set of arrays whose permutations of entries will follow
                      those performed on {@code x}.                    
                </param>
                <throws>
                    DimensionMismatchException if any {@code y} is not the same
                      size as {@code x}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code x} or any {@code y} is null.                    
                </throws>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <method name="sortInPlace" type="void" line="658">
                <params>
                    <param name="x" type="double[]"/>
                    <param name="yList" type="double[]"/>
                </params>
            </method>
            <javadoc line="662">
                Sort an array in place and perform the same reordering of entries on
                  other arrays.  This method works the same as the other{@link #sortInPlace(double[],double[][]) sortInPlace} method, but
                  allows the order of the sort to be provided in the {@code dir}parameter.                
                <param>
                    x Array to be sorted and used as a pattern for permutation
                      of the other arrays.                    
                </param>
                <param>
                    dir Order direction.                    
                </param>
                <param>
                    yList Set of arrays whose permutations of entries will follow
                      those performed on {@code x}.                    
                </param>
                <throws>
                    DimensionMismatchException if any {@code y} is not the same
                      size as {@code x}.                    
                </throws>
                <throws>
                    NullArgumentException if {@code x} or any {@code y} is null                    
                </throws>
                <since>
                    3.0                    
                </since>
            </javadoc>
            <method name="sortInPlace" type="void" line="683">
                <params>
                    <param name="x" type="double[]"/>
                    <param name="dir" type="OrderDirection"/>
                    <param name="yList" type="double[]"/>
                </params>
                <comment line="686">
                    Consistency checks.                    
                </comment>
                <comment line="704">
                    Associate each abscissa &quot;x[i]&quot; with its index &quot;i&quot;.                    
                </comment>
                <comment line="711">
                    Create comparators for increasing and decreasing orders.                    
                </comment>
                <comment line="726">
                    Sort.                    
                </comment>
                <comment line="729">
                    Modify the original array so that its elements are in
                     the prescribed order.
                     Retrieve indices of original locations.                    
                </comment>
                <comment line="739">
                    In each of the associated arrays, move the
                     elements to their new location.                    
                </comment>
                <comment line="742">
                    Input array will be modified in place.                    
                </comment>
                <scope line="686"/>
                <declaration name="yListLen" type="int" line="690"/>
                <declaration name="len" type="int" line="691"/>
                <scope line="693">
                    <declaration name="y" type="double[]" line="694"/>
                    <scope line="695"/>
                    <scope line="698"/>
                </scope>
                <declaration name="list" type="List&amp;lt;Pair&amp;lt;Double,Integer&amp;gt;&amp;gt;" line="704"/>
                <scope line="706"/>
                <anonymous_class line="713">
                    <method name="compare" type="int" line="715">
                        <params>
                            <param name="o1" type="Pair&lt;Double,Integer&gt;"/>
                            <param name="o2" type="Pair&lt;Double,Integer&gt;"/>
                        </params>
                    </method>
                </anonymous_class>
                <anonymous_class line="718">
                    <method name="compare" type="int" line="720">
                        <params>
                            <param name="o1" type="Pair&lt;Double,Integer&gt;"/>
                            <param name="o2" type="Pair&lt;Double,Integer&gt;"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="Comparator&amp;lt;Pair&amp;lt;Double,Integer&amp;gt;&amp;gt;" line="711"/>
                <declaration name="indices" type="int[]" line="731"/>
                <scope line="732">
                    <declaration name="e" type="Pair&amp;lt;Double,Integer&amp;gt;" line="733"/>
                </scope>
                <scope line="740">
                    <declaration name="yInPlace" type="double[]" line="742"/>
                    <declaration name="yOrig" type="double[]" line="743"/>
                    <scope line="745"/>
                </scope>
            </method>
            <javadoc line="751">
                Creates a copy of the {@code source} array.                
                <param>
                    source Array to be copied.                    
                </param>
                <return>
                    the copied array.                    
                </return>
            </javadoc>
            <method name="copyOf" type="int[]" line="757">
                <params>
                    <param name="source" type="int[]"/>
                </params>
            </method>
            <javadoc line="761">
                Creates a copy of the {@code source} array.                
                <param>
                    source Array to be copied.                    
                </param>
                <return>
                    the copied array.                    
                </return>
            </javadoc>
            <method name="copyOf" type="double[]" line="767">
                <params>
                    <param name="source" type="double[]"/>
                </params>
            </method>
            <javadoc line="771">
                Creates a copy of the {@code source} array.                
                <param>
                    source Array to be copied.                    
                </param>
                <param>
                    len Number of entries to copy. If smaller then the source
                      length, the copy will be truncated, if larger it will padded with
                      zeroes.                    
                </param>
                <return>
                    the copied array.                    
                </return>
            </javadoc>
            <method name="copyOf" type="int[]" line="780">
                <params>
                    <param name="source" type="int[]"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="output" type="int[]" line="781"/>
            </method>
            <javadoc line="786">
                Creates a copy of the {@code source} array.                
                <param>
                    source Array to be copied.                    
                </param>
                <param>
                    len Number of entries to copy. If smaller then the source
                      length, the copy will be truncated, if larger it will padded with
                      zeroes.                    
                </param>
                <return>
                    the copied array.                    
                </return>
            </javadoc>
            <method name="copyOf" type="double[]" line="795">
                <params>
                    <param name="source" type="double[]"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="output" type="double[]" line="796"/>
            </method>
            <javadoc line="801">
                Compute a linear combination accurately.
                  This method computes the sum of the products
                  &lt;code&gt;a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt; to high accuracy.
                  It does so by using specific multiplication and addition algorithms to
                  preserve accuracy and reduce cancellation effects.
                  &lt;br/&gt;
                  It is based on the 2005 paper
                  &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                  Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita, Siegfried M. Rump,
                  and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.                
                <param>
                    a Factors.                    
                </param>
                <param>
                    b Factors.                    
                </param>
                <return>
                    &lt;code&gt;&amp;Sigma;&lt;sub&gt;i&lt;/sub&gt; a&lt;sub&gt;i&lt;/sub&gt; b&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt;.                    
                </return>
                <throws>
                    DimensionMismatchException if arrays dimensions don&apos;t match                    
                </throws>
            </javadoc>
            <method name="linearCombination" type="double" line="819">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="b" type="double[]"/>
                </params>
                <comment line="827">
                    Revert to scalar multiplication.                    
                </comment>
                <comment line="871">
                    either we have split infinite numbers or some coefficients were NaNs,
                     just rely on the naive implementation and let IEEE754 handle this                    
                </comment>
                <declaration name="len" type="int" line="820"/>
                <scope line="821"/>
                <scope line="825"/>
                <declaration name="prodHigh" type="double[]" line="830"/>
                <declaration name="prodLowSum" type="double" line="831"/>
                <scope line="833">
                    <declaration name="ai" type="double" line="834"/>
                    <declaration name="ca" type="double" line="835"/>
                    <declaration name="aHigh" type="double" line="836"/>
                    <declaration name="aLow" type="double" line="837"/>
                    <declaration name="bi" type="double" line="839"/>
                    <declaration name="cb" type="double" line="840"/>
                    <declaration name="bHigh" type="double" line="841"/>
                    <declaration name="bLow" type="double" line="842"/>
                    <declaration name="prodLow" type="double" line="844"/>
                </scope>
                <declaration name="prodHighCur" type="double" line="852"/>
                <declaration name="prodHighNext" type="double" line="853"/>
                <declaration name="sHighPrev" type="double" line="854"/>
                <declaration name="sPrime" type="double" line="855"/>
                <declaration name="sLowSum" type="double" line="856"/>
                <declaration name="lenMinusOne" type="int" line="858"/>
                <scope line="859">
                    <declaration name="sHighCur" type="double" line="861"/>
                </scope>
                <declaration name="result" type="double" line="867"/>
                <scope line="869">
                    <scope line="873"/>
                </scope>
            </method>
            <javadoc line="881">
                Compute a linear combination accurately.
                  &lt;p&gt;
                  This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                  a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; to high accuracy. It does
                  so by using specific multiplication and addition algorithms to
                  preserve accuracy and reduce cancellation effects. It is based
                  on the 2005 paper &lt;a
                  href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                  Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
                  Siegfried M. Rump, and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.
                  &lt;/p&gt;                
                <param>
                    a1 first factor of the first term                    
                </param>
                <param>
                    b1 second factor of the first term                    
                </param>
                <param>
                    a2 first factor of the second term                    
                </param>
                <param>
                    b2 second factor of the second term                    
                </param>
                <return>
                    a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                      a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt;                    
                </return>
                <see>
                    #linearCombination(double,double,double,double,double,double)                    
                </see>
                <see>
                    #linearCombination(double,double,double,double,double,double,double,double)                    
                </see>
            </javadoc>
            <method name="linearCombination" type="double" line="903">
                <params>
                    <param name="a1" type="double"/>
                    <param name="b1" type="double"/>
                    <param name="a2" type="double"/>
                    <param name="b2" type="double"/>
                </params>
                <comment line="906">
                    the code below is split in many additions/subtractions that may
                     appear redundant. However, they should NOT be simplified, as they
                     use IEEE754 floating point arithmetic rounding properties.
                     as an example, the expression &quot;ca1 - (ca1 - a1)&quot; is NOT the same as &quot;a1&quot;
                     The variable naming conventions are that xyzHigh contains the most significant
                     bits of xyz and xyzLow contains its least significant bits. So theoretically
                     xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
                     be represented in only one double precision number so we preserve two numbers
                     to hold it as long as we can, combining the high and low order bits together
                     only at the end, after cancellation may have occurred on high order bits                    
                </comment>
                <comment line="917">
                    split a1 and b1 as two 26 bits numbers                    
                </comment>
                <comment line="925">
                    accurate multiplication a1 * b1                    
                </comment>
                <comment line="929">
                    split a2 and b2 as two 26 bits numbers                    
                </comment>
                <comment line="937">
                    accurate multiplication a2 * b2                    
                </comment>
                <comment line="941">
                    accurate addition a1 * b1 + a2 * b2                    
                </comment>
                <comment line="946">
                    final rounding, s12 may have suffered many cancellations, we try
                     to recover some bits from the extra words we have saved up to now                    
                </comment>
                <comment line="951">
                    either we have split infinite numbers or some coefficients were NaNs,
                     just rely on the naive implementation and let IEEE754 handle this                    
                </comment>
                <declaration name="ca1" type="double" line="917"/>
                <declaration name="a1High" type="double" line="918"/>
                <declaration name="a1Low" type="double" line="919"/>
                <declaration name="cb1" type="double" line="920"/>
                <declaration name="b1High" type="double" line="921"/>
                <declaration name="b1Low" type="double" line="922"/>
                <declaration name="prod1High" type="double" line="925"/>
                <declaration name="prod1Low" type="double" line="926"/>
                <declaration name="ca2" type="double" line="929"/>
                <declaration name="a2High" type="double" line="930"/>
                <declaration name="a2Low" type="double" line="931"/>
                <declaration name="cb2" type="double" line="932"/>
                <declaration name="b2High" type="double" line="933"/>
                <declaration name="b2Low" type="double" line="934"/>
                <declaration name="prod2High" type="double" line="937"/>
                <declaration name="prod2Low" type="double" line="938"/>
                <declaration name="s12High" type="double" line="941"/>
                <declaration name="s12Prime" type="double" line="942"/>
                <declaration name="s12Low" type="double" line="943"/>
                <declaration name="result" type="double" line="947"/>
                <scope line="949"/>
            </method>
            <javadoc line="958">
                Compute a linear combination accurately.
                  &lt;p&gt;
                  This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                  a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;
                  to high accuracy. It does so by using specific multiplication and
                  addition algorithms to preserve accuracy and reduce cancellation effects.
                  It is based on the 2005 paper &lt;a
                  href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                  Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
                  Siegfried M. Rump, and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.
                  &lt;/p&gt;                
                <param>
                    a1 first factor of the first term                    
                </param>
                <param>
                    b1 second factor of the first term                    
                </param>
                <param>
                    a2 first factor of the second term                    
                </param>
                <param>
                    b2 second factor of the second term                    
                </param>
                <param>
                    a3 first factor of the third term                    
                </param>
                <param>
                    b3 second factor of the third term                    
                </param>
                <return>
                    a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                      a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt;                    
                </return>
                <see>
                    #linearCombination(double,double,double,double)                    
                </see>
                <see>
                    #linearCombination(double,double,double,double,double,double,double,double)                    
                </see>
            </javadoc>
            <method name="linearCombination" type="double" line="983">
                <params>
                    <param name="a1" type="double"/>
                    <param name="b1" type="double"/>
                    <param name="a2" type="double"/>
                    <param name="b2" type="double"/>
                    <param name="a3" type="double"/>
                    <param name="b3" type="double"/>
                </params>
                <comment line="986">
                    the code below is split in many additions/subtractions that may
                     appear redundant. However, they should NOT be simplified, as they
                     do use IEEE754 floating point arithmetic rounding properties.
                     as an example, the expression &quot;ca1 - (ca1 - a1)&quot; is NOT the same as &quot;a1&quot;
                     The variables naming conventions are that xyzHigh contains the most significant
                     bits of xyz and xyzLow contains its least significant bits. So theoretically
                     xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
                     be represented in only one double precision number so we preserve two numbers
                     to hold it as long as we can, combining the high and low order bits together
                     only at the end, after cancellation may have occurred on high order bits                    
                </comment>
                <comment line="997">
                    split a1 and b1 as two 26 bits numbers                    
                </comment>
                <comment line="1005">
                    accurate multiplication a1 * b1                    
                </comment>
                <comment line="1009">
                    split a2 and b2 as two 26 bits numbers                    
                </comment>
                <comment line="1017">
                    accurate multiplication a2 * b2                    
                </comment>
                <comment line="1021">
                    split a3 and b3 as two 26 bits numbers                    
                </comment>
                <comment line="1029">
                    accurate multiplication a3 * b3                    
                </comment>
                <comment line="1033">
                    accurate addition a1 * b1 + a2 * b2                    
                </comment>
                <comment line="1038">
                    accurate addition a1 * b1 + a2 * b2 + a3 * b3                    
                </comment>
                <comment line="1043">
                    final rounding, s123 may have suffered many cancellations, we try
                     to recover some bits from the extra words we have saved up to now                    
                </comment>
                <comment line="1048">
                    either we have split infinite numbers or some coefficients were NaNs,
                     just rely on the naive implementation and let IEEE754 handle this                    
                </comment>
                <declaration name="ca1" type="double" line="997"/>
                <declaration name="a1High" type="double" line="998"/>
                <declaration name="a1Low" type="double" line="999"/>
                <declaration name="cb1" type="double" line="1000"/>
                <declaration name="b1High" type="double" line="1001"/>
                <declaration name="b1Low" type="double" line="1002"/>
                <declaration name="prod1High" type="double" line="1005"/>
                <declaration name="prod1Low" type="double" line="1006"/>
                <declaration name="ca2" type="double" line="1009"/>
                <declaration name="a2High" type="double" line="1010"/>
                <declaration name="a2Low" type="double" line="1011"/>
                <declaration name="cb2" type="double" line="1012"/>
                <declaration name="b2High" type="double" line="1013"/>
                <declaration name="b2Low" type="double" line="1014"/>
                <declaration name="prod2High" type="double" line="1017"/>
                <declaration name="prod2Low" type="double" line="1018"/>
                <declaration name="ca3" type="double" line="1021"/>
                <declaration name="a3High" type="double" line="1022"/>
                <declaration name="a3Low" type="double" line="1023"/>
                <declaration name="cb3" type="double" line="1024"/>
                <declaration name="b3High" type="double" line="1025"/>
                <declaration name="b3Low" type="double" line="1026"/>
                <declaration name="prod3High" type="double" line="1029"/>
                <declaration name="prod3Low" type="double" line="1030"/>
                <declaration name="s12High" type="double" line="1033"/>
                <declaration name="s12Prime" type="double" line="1034"/>
                <declaration name="s12Low" type="double" line="1035"/>
                <declaration name="s123High" type="double" line="1038"/>
                <declaration name="s123Prime" type="double" line="1039"/>
                <declaration name="s123Low" type="double" line="1040"/>
                <declaration name="result" type="double" line="1044"/>
                <scope line="1046"/>
            </method>
            <javadoc line="1055">
                Compute a linear combination accurately.
                  &lt;p&gt;
                  This method computes a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                  a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
                  a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;
                  to high accuracy. It does so by using specific multiplication and
                  addition algorithms to preserve accuracy and reduce cancellation effects.
                  It is based on the 2005 paper &lt;a
                  href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547&quot;&gt;
                  Accurate Sum and Dot Product&lt;/a&gt; by Takeshi Ogita,
                  Siegfried M. Rump, and Shin&apos;ichi Oishi published in SIAM J. Sci. Comput.
                  &lt;/p&gt;                
                <param>
                    a1 first factor of the first term                    
                </param>
                <param>
                    b1 second factor of the first term                    
                </param>
                <param>
                    a2 first factor of the second term                    
                </param>
                <param>
                    b2 second factor of the second term                    
                </param>
                <param>
                    a3 first factor of the third term                    
                </param>
                <param>
                    b3 second factor of the third term                    
                </param>
                <param>
                    a4 first factor of the third term                    
                </param>
                <param>
                    b4 second factor of the third term                    
                </param>
                <return>
                    a&lt;sub&gt;1&lt;/sub&gt;&amp;times;b&lt;sub&gt;1&lt;/sub&gt; +
                      a&lt;sub&gt;2&lt;/sub&gt;&amp;times;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;3&lt;/sub&gt;&amp;times;b&lt;sub&gt;3&lt;/sub&gt; +
                      a&lt;sub&gt;4&lt;/sub&gt;&amp;times;b&lt;sub&gt;4&lt;/sub&gt;                    
                </return>
                <see>
                    #linearCombination(double,double,double,double)                    
                </see>
                <see>
                    #linearCombination(double,double,double,double,double,double)                    
                </see>
            </javadoc>
            <method name="linearCombination" type="double" line="1085">
                <params>
                    <param name="a1" type="double"/>
                    <param name="b1" type="double"/>
                    <param name="a2" type="double"/>
                    <param name="b2" type="double"/>
                    <param name="a3" type="double"/>
                    <param name="b3" type="double"/>
                    <param name="a4" type="double"/>
                    <param name="b4" type="double"/>
                </params>
                <comment line="1088">
                    the code below is split in many additions/subtractions that may
                     appear redundant. However, they should NOT be simplified, as they
                     do use IEEE754 floating point arithmetic rounding properties.
                     as an example, the expression &quot;ca1 - (ca1 - a1)&quot; is NOT the same as &quot;a1&quot;
                     The variables naming conventions are that xyzHigh contains the most significant
                     bits of xyz and xyzLow contains its least significant bits. So theoretically
                     xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot
                     be represented in only one double precision number so we preserve two numbers
                     to hold it as long as we can, combining the high and low order bits together
                     only at the end, after cancellation may have occurred on high order bits                    
                </comment>
                <comment line="1099">
                    split a1 and b1 as two 26 bits numbers                    
                </comment>
                <comment line="1107">
                    accurate multiplication a1 * b1                    
                </comment>
                <comment line="1111">
                    split a2 and b2 as two 26 bits numbers                    
                </comment>
                <comment line="1119">
                    accurate multiplication a2 * b2                    
                </comment>
                <comment line="1123">
                    split a3 and b3 as two 26 bits numbers                    
                </comment>
                <comment line="1131">
                    accurate multiplication a3 * b3                    
                </comment>
                <comment line="1135">
                    split a4 and b4 as two 26 bits numbers                    
                </comment>
                <comment line="1143">
                    accurate multiplication a4 * b4                    
                </comment>
                <comment line="1147">
                    accurate addition a1 * b1 + a2 * b2                    
                </comment>
                <comment line="1152">
                    accurate addition a1 * b1 + a2 * b2 + a3 * b3                    
                </comment>
                <comment line="1157">
                    accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4                    
                </comment>
                <comment line="1162">
                    final rounding, s1234 may have suffered many cancellations, we try
                     to recover some bits from the extra words we have saved up to now                    
                </comment>
                <comment line="1167">
                    either we have split infinite numbers or some coefficients were NaNs,
                     just rely on the naive implementation and let IEEE754 handle this                    
                </comment>
                <declaration name="ca1" type="double" line="1099"/>
                <declaration name="a1High" type="double" line="1100"/>
                <declaration name="a1Low" type="double" line="1101"/>
                <declaration name="cb1" type="double" line="1102"/>
                <declaration name="b1High" type="double" line="1103"/>
                <declaration name="b1Low" type="double" line="1104"/>
                <declaration name="prod1High" type="double" line="1107"/>
                <declaration name="prod1Low" type="double" line="1108"/>
                <declaration name="ca2" type="double" line="1111"/>
                <declaration name="a2High" type="double" line="1112"/>
                <declaration name="a2Low" type="double" line="1113"/>
                <declaration name="cb2" type="double" line="1114"/>
                <declaration name="b2High" type="double" line="1115"/>
                <declaration name="b2Low" type="double" line="1116"/>
                <declaration name="prod2High" type="double" line="1119"/>
                <declaration name="prod2Low" type="double" line="1120"/>
                <declaration name="ca3" type="double" line="1123"/>
                <declaration name="a3High" type="double" line="1124"/>
                <declaration name="a3Low" type="double" line="1125"/>
                <declaration name="cb3" type="double" line="1126"/>
                <declaration name="b3High" type="double" line="1127"/>
                <declaration name="b3Low" type="double" line="1128"/>
                <declaration name="prod3High" type="double" line="1131"/>
                <declaration name="prod3Low" type="double" line="1132"/>
                <declaration name="ca4" type="double" line="1135"/>
                <declaration name="a4High" type="double" line="1136"/>
                <declaration name="a4Low" type="double" line="1137"/>
                <declaration name="cb4" type="double" line="1138"/>
                <declaration name="b4High" type="double" line="1139"/>
                <declaration name="b4Low" type="double" line="1140"/>
                <declaration name="prod4High" type="double" line="1143"/>
                <declaration name="prod4Low" type="double" line="1144"/>
                <declaration name="s12High" type="double" line="1147"/>
                <declaration name="s12Prime" type="double" line="1148"/>
                <declaration name="s12Low" type="double" line="1149"/>
                <declaration name="s123High" type="double" line="1152"/>
                <declaration name="s123Prime" type="double" line="1153"/>
                <declaration name="s123Low" type="double" line="1154"/>
                <declaration name="s1234High" type="double" line="1157"/>
                <declaration name="s1234Prime" type="double" line="1158"/>
                <declaration name="s1234Low" type="double" line="1159"/>
                <declaration name="result" type="double" line="1163"/>
                <scope line="1165"/>
            </method>
            <javadoc line="1174">
                Returns true iff both arguments are null or have same dimensions and all
                  their elements are equal as defined by{@link Precision#equals(float,float)}.                
                <param>
                    x first array                    
                </param>
                <param>
                    y second array                    
                </param>
                <return>
                    true if the values are both null or have same dimension
                      and equal elements.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1184">
                <params>
                    <param name="x" type="float[]"/>
                    <param name="y" type="float[]"/>
                </params>
                <scope line="1185"/>
                <scope line="1188"/>
                <scope line="1191">
                    <scope line="1192"/>
                </scope>
            </method>
            <javadoc line="1199">
                Returns true iff both arguments are null or have same dimensions and all
                  their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.                
                <param>
                    x first array                    
                </param>
                <param>
                    y second array                    
                </param>
                <return>
                    true if the values are both null or have same dimension and
                      equal elements                    
                </return>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="equalsIncludingNaN" type="boolean" line="1210">
                <params>
                    <param name="x" type="float[]"/>
                    <param name="y" type="float[]"/>
                </params>
                <scope line="1211"/>
                <scope line="1214"/>
                <scope line="1217">
                    <scope line="1218"/>
                </scope>
            </method>
            <javadoc line="1225">
                Returns {@code true} iff both arguments are {@code null} or have same
                  dimensions and all their elements are equal as defined by{@link Precision#equals(double,double)}.                
                <param>
                    x First array.                    
                </param>
                <param>
                    y Second array.                    
                </param>
                <return>
                    {@code true} if the values are both {@code null} or have same
                      dimension and equal elements.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1235">
                <params>
                    <param name="x" type="double[]"/>
                    <param name="y" type="double[]"/>
                </params>
                <scope line="1236"/>
                <scope line="1239"/>
                <scope line="1242">
                    <scope line="1243"/>
                </scope>
            </method>
            <javadoc line="1250">
                Returns {@code true} iff both arguments are {@code null} or have same
                  dimensions and all their elements are equal as defined by{@link Precision#equalsIncludingNaN(double,double) this method}.                
                <param>
                    x First array.                    
                </param>
                <param>
                    y Second array.                    
                </param>
                <return>
                    {@code true} if the values are both {@code null} or have same
                      dimension and equal elements.                    
                </return>
                <since>
                    2.2                    
                </since>
            </javadoc>
            <method name="equalsIncludingNaN" type="boolean" line="1261">
                <params>
                    <param name="x" type="double[]"/>
                    <param name="y" type="double[]"/>
                </params>
                <scope line="1262"/>
                <scope line="1265"/>
                <scope line="1268">
                    <scope line="1269"/>
                </scope>
            </method>
            <javadoc line="1276">
                Normalizes an array to make it sum to a specified value.
                  Returns the result of the transformation
                  &lt;pre&gt;
                  x |-&gt; x  normalizedSum / sum
                  &lt;/pre&gt;
                  applied to each non-NaN element x of the input array, where sum is the
                  sum of the non-NaN entries in the input array.
                  &lt;p&gt;
                  Throws IllegalArgumentException if {@code normalizedSum} is infinite
                  or NaN and ArithmeticException if the input array contains any infinite elements
                  or sums to 0.
                  &lt;p&gt;
                  Ignores (i.e., copies unchanged to the output array) NaNs in the input array.                
                <param>
                    values Input array to be normalized                    
                </param>
                <param>
                    normalizedSum Target sum for the normalized array                    
                </param>
                <return>
                    the normalized array.                    
                </return>
                <throws>
                    MathArithmeticException if the input array contains infinite
                      elements or sums to zero.                    
                </throws>
                <throws>
                    MathIllegalArgumentException if the target sum is infinite or {@code NaN}.                    
                </throws>
                <since>
                    2.1                    
                </since>
            </javadoc>
            <method name="normalizeArray" type="double[]" line="1300">
                <params>
                    <param name="values" type="double[]"/>
                    <param name="normalizedSum" type="double"/>
                </params>
                <scope line="1301"/>
                <scope line="1304"/>
                <declaration name="sum" type="double" line="1307"/>
                <declaration name="len" type="int" line="1308"/>
                <declaration name="out" type="double[]" line="1309"/>
                <scope line="1310">
                    <scope line="1311"/>
                    <scope line="1314"/>
                </scope>
                <scope line="1318"/>
                <scope line="1321">
                    <scope line="1322"/>
                    <scope line="1324"/>
                </scope>
            </method>
            <javadoc line="1331">
                Build an array of elements.
                  &lt;p&gt;
                  Arrays are filled with field.getZero()                
                <param>
                    &lt;T&gt;
                       the type of the field elements                    
                </param>
                <param>
                    field field to which array elements belong                    
                </param>
                <param>
                    length of the array                    
                </param>
                <return>
                    a new array                    
                </return>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <method name="buildArray" type="T[]" line="1341">
                <params>
                    <param name="field" type="Field&lt;T&gt;"/>
                    <param name="length" type="int"/>
                </params>
                <comment line="1343">
                    OK because field must be correct class                    
                </comment>
                <declaration name="array" type="T[]" line="1342"/>
            </method>
            <javadoc line="1348">
                Build a double dimension  array of elements.
                  &lt;p&gt;
                  Arrays are filled with field.getZero()                
                <param>
                    &lt;T&gt;
                       the type of the field elements                    
                </param>
                <param>
                    field field to which array elements belong                    
                </param>
                <param>
                    rows number of rows in the array                    
                </param>
                <param>
                    columns number of columns (may be negative to build partial
                      arrays in the same way &lt;code&gt;new Field[rows][]&lt;/code&gt; works)                    
                </param>
                <return>
                    a new array                    
                </return>
                <since>
                    3.2                    
                </since>
            </javadoc>
            <method name="buildArray" type="T[][]" line="1361">
                <params>
                    <param name="field" type="Field&lt;T&gt;"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                </params>
                <declaration name="array" type="T[][]" line="1362"/>
                <scope line="1363">
                    <declaration name="dummyRow" type="T[]" line="1364"/>
                </scope>
                <scope line="1366">
                    <scope line="1371"/>
                </scope>
            </method>
            <javadoc line="1378">
                Calculates the &lt;a href=&quot;http://en.wikipedia.org/wiki/Convolution&quot;&gt;
                  convolution&lt;/a&gt; between two sequences.
                  &lt;p&gt;
                  The solution is obtained via straightforward computation of the
                  convolution sum (and not via FFT). Whenever the computation needs
                  an element that would be located at an index outside the input arrays,
                  the value is assumed to be zero.                
                <param>
                    x First sequence.
                      Typically, this sequence will represent an input signal to a system.                    
                </param>
                <param>
                    h Second sequence.
                      Typically, this sequence will represent the impulse response of the system.                    
                </param>
                <return>
                    the convolution of {@code x} and {@code h}.
                      This array&apos;s length will be {@code x.length + h.length - 1}.                    
                </return>
                <throws>
                    NullArgumentException if either {@code x} or {@code h} is {@code null}.                    
                </throws>
                <throws>
                    NoDataException if either {@code x} or {@code h} is empty.                    
                </throws>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="convolve" type="double[]" line="1400">
                <params>
                    <param name="x" type="double[]"/>
                    <param name="h" type="double[]"/>
                </params>
                <comment line="1412">
                    initialize the output array                    
                </comment>
                <comment line="1416">
                    straightforward implementation of the convolution sum                    
                </comment>
                <declaration name="xLen" type="int" line="1404"/>
                <declaration name="hLen" type="int" line="1405"/>
                <scope line="1407"/>
                <declaration name="totalLength" type="int" line="1412"/>
                <declaration name="y" type="double[]" line="1413"/>
                <scope line="1416">
                    <declaration name="yn" type="double" line="1417"/>
                    <declaration name="k" type="int" line="1418"/>
                    <declaration name="j" type="int" line="1419"/>
                    <scope line="1420"/>
                </scope>
            </method>
            <declaration name="Position" type="enum" line="1429"/>
            <javadoc line="1429">
                Specification for indicating that some operation applies
                  before or after a given index.                
            </javadoc>
            <scope line="1433"/>
            <javadoc line="1440">
                Shuffle the entries of the given array.
                  The {@code start} and {@code pos} parameters select which portion
                  of the array is randomized and which is left untouched.                
                <see>
                    #shuffle(int[],int,Position,RandomGenerator)                    
                </see>
                <param>
                    list Array whose entries will be shuffled (in-place).                    
                </param>
                <param>
                    start Index at which shuffling begins.                    
                </param>
                <param>
                    pos Shuffling is performed for index positions between{@code start} and either the end (if {@link Position#TAIL})
                      or the beginning (if {@link Position#HEAD}) of the array.                    
                </param>
            </javadoc>
            <method name="shuffle" type="void" line="1455">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="start" type="int"/>
                    <param name="pos" type="Position"/>
                </params>
            </method>
            <javadoc line="1459">
                Shuffle the entries of the given array, using the
                  &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher–Yates_shuffle#The_modern_algorithm&quot;&gt;
                  Fisher–Yates&lt;/a&gt; algorithm.
                  The {@code start} and {@code pos} parameters select which portion
                  of the array is randomized and which is left untouched.                
                <param>
                    list Array whose entries will be shuffled (in-place).                    
                </param>
                <param>
                    start Index at which shuffling begins.                    
                </param>
                <param>
                    pos Shuffling is performed for index positions between{@code start} and either the end (if {@link Position#TAIL})
                      or the beginning (if {@link Position#HEAD}) of the array.                    
                </param>
                <param>
                    rng Random number generator.                    
                </param>
            </javadoc>
            <method name="shuffle" type="void" line="1476">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="start" type="int"/>
                    <param name="pos" type="Position"/>
                    <param name="rng" type="RandomGenerator"/>
                </params>
                <comment line="1485">
                    NumberIsTooLargeException cannot occur.                    
                </comment>
                <comment line="1500">
                    NumberIsTooLargeException cannot occur.                    
                </comment>
                <comment line="1510">
                    Should never happen.                    
                </comment>
                <scope line="1478">
                    <scope line="1479">
                        <declaration name="target" type="int" line="1480"/>
                        <scope line="1481"/>
                        <scope line="1483"/>
                        <declaration name="temp" type="int" line="1487"/>
                    </scope>
                </scope>
                <scope line="1493">
                    <scope line="1494">
                        <declaration name="target" type="int" line="1495"/>
                        <scope line="1496"/>
                        <scope line="1498"/>
                        <declaration name="temp" type="int" line="1502"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1513">
                Shuffle the entries of the given array.                
                <see>
                    #shuffle(int[],int,Position,RandomGenerator)                    
                </see>
                <param>
                    list Array whose entries will be shuffled (in-place).                    
                </param>
                <param>
                    rng Random number generator.                    
                </param>
            </javadoc>
            <method name="shuffle" type="void" line="1522">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="rng" type="RandomGenerator"/>
                </params>
            </method>
            <javadoc line="1526">
                Shuffle the entries of the given array.                
                <see>
                    #shuffle(int[],int,Position,RandomGenerator)                    
                </see>
                <param>
                    list Array whose entries will be shuffled (in-place).                    
                </param>
            </javadoc>
            <method name="shuffle" type="void" line="1533">
                <params>
                    <param name="list" type="int[]"/>
                </params>
            </method>
            <javadoc line="1537">
                Returns an array representing the natural number {@code n}.                
                <param>
                    n Natural number.                    
                </param>
                <return>
                    an array whose entries are the numbers 0, 1, ..., {@code n}-1.
                      If {@code n == 0}, the returned array is empty.                    
                </return>
            </javadoc>
            <method name="natural" type="int[]" line="1544">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="a" type="int[]" line="1545"/>
                <scope line="1546"/>
            </method>
            <javadoc line="1551">
                This method is used
                  to verify that the input parameters designate a subarray of positive length.
                  &lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
                  positive length&lt;/li&gt;
                  &lt;li&gt;throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or
                  or the indices are invalid&lt;/li&gt;
                  &lt;li&gt;returns &lt;code&gt;false&lt;/li&gt; if the array is non-null, but
                  &lt;code&gt;length&lt;/code&gt; is 0.
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    values the input array                    
                </param>
                <param>
                    begin index of the first array element to include                    
                </param>
                <param>
                    length the number of elements to include                    
                </param>
                <return>
                    true if the parameters are valid and designate a subarray of positive length                    
                </return>
                <throws>
                    MathIllegalArgumentException if the indices are invalid or the array is null                    
                </throws>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="verifyValues" type="boolean" line="1572">
                <params>
                    <param name="values" type="double[]"/>
                    <param name="begin" type="int"/>
                    <param name="length" type="int"/>
                </params>
            </method>
            <javadoc line="1576">
                This method is used
                  to verify that the input parameters designate a subarray of positive length.
                  &lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
                  non-negative length&lt;/li&gt;
                  &lt;li&gt;throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null or
                  or the indices are invalid&lt;/li&gt;
                  &lt;li&gt;returns &lt;code&gt;false&lt;/li&gt; if the array is non-null, but
                  &lt;code&gt;length&lt;/code&gt; is 0 unless &lt;code&gt;allowEmpty&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    values the input array                    
                </param>
                <param>
                    begin index of the first array element to include                    
                </param>
                <param>
                    length the number of elements to include                    
                </param>
                <param>
                    allowEmpty if &lt;code&gt;true&lt;/code&gt; then zero length arrays are allowed                    
                </param>
                <return>
                    true if the parameters are valid                    
                </return>
                <throws>
                    MathIllegalArgumentException if the indices are invalid or the array is null                    
                </throws>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="verifyValues" type="boolean" line="1598">
                <params>
                    <param name="values" type="double[]"/>
                    <param name="begin" type="int"/>
                    <param name="length" type="int"/>
                    <param name="allowEmpty" type="boolean"/>
                </params>
                <scope line="1600"/>
                <scope line="1604"/>
                <scope line="1608"/>
                <scope line="1612"/>
                <scope line="1617"/>
            </method>
            <javadoc line="1625">
                This method is used
                  to verify that the begin and length parameters designate a subarray of positive length
                  and the weights are all non-negative, non-NaN, finite, and not all zero.
                  &lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
                  positive length and the weights array contains legitimate values.&lt;/li&gt;
                  &lt;li&gt;throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if any of the following are true:
                  &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
                  &lt;li&gt;the weights array is null&lt;/li&gt;
                  &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
                  &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
                  &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
                  &lt;li&gt;the weights array contains negative values&lt;/li&gt;
                  &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;&lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;returns &lt;code&gt;false&lt;/li&gt; if the array is non-null, but
                  &lt;code&gt;length&lt;/code&gt; is 0.
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    values the input array                    
                </param>
                <param>
                    weights the weights array                    
                </param>
                <param>
                    begin index of the first array element to include                    
                </param>
                <param>
                    length the number of elements to include                    
                </param>
                <return>
                    true if the parameters are valid and designate a subarray of positive length                    
                </return>
                <throws>
                    MathIllegalArgumentException if the indices are invalid or the array is null                    
                </throws>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="verifyValues" type="boolean" line="1658">
                <params>
                    <param name="values" type="double[]"/>
                    <param name="weights" type="double[]"/>
                    <param name="begin" type="int"/>
                    <param name="length" type="int"/>
                </params>
            </method>
            <javadoc line="1662">
                This method is used
                  to verify that the begin and length parameters designate a subarray of positive length
                  and the weights are all non-negative, non-NaN, finite, and not all zero.
                  &lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
                  non-negative length and the weights array contains legitimate values.&lt;/li&gt;
                  &lt;li&gt;throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
                  &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
                  &lt;li&gt;the weights array is null&lt;/li&gt;
                  &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
                  &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
                  &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
                  &lt;li&gt;the weights array contains negative values&lt;/li&gt;
                  &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;&lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;returns &lt;code&gt;false&lt;/li&gt; if the array is non-null, but
                  &lt;code&gt;length&lt;/code&gt; is 0 unless &lt;code&gt;allowEmpty&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.
                  &lt;/ul&gt;&lt;/p&gt;                
                <param>
                    values the input array.                    
                </param>
                <param>
                    weights the weights array.                    
                </param>
                <param>
                    begin index of the first array element to include.                    
                </param>
                <param>
                    length the number of elements to include.                    
                </param>
                <param>
                    allowEmpty if {@code true} than allow zero length arrays to pass.                    
                </param>
                <return>
                    {@code true} if the parameters are valid.                    
                </return>
                <throws>
                    NullArgumentException if either of the arrays are null                    
                </throws>
                <throws>
                    MathIllegalArgumentException if the array indices are not valid,
                      the weights array contains NaN, infinite or negative elements, or there
                      are no positive weights.                    
                </throws>
                <since>
                    3.3                    
                </since>
            </javadoc>
            <method name="verifyValues" type="boolean" line="1696">
                <params>
                    <param name="values" type="double[]"/>
                    <param name="weights" type="double[]"/>
                    <param name="begin" type="int"/>
                    <param name="length" type="int"/>
                    <param name="allowEmpty" type="boolean"/>
                </params>
                <scope line="1698"/>
                <scope line="1702"/>
                <declaration name="containsPositiveWeight" type="boolean" line="1706"/>
                <scope line="1707">
                    <declaration name="weight" type="double" line="1708"/>
                    <scope line="1709"/>
                    <scope line="1712"/>
                    <scope line="1715"/>
                    <scope line="1718"/>
                </scope>
                <scope line="1723"/>
            </method>
        </class>
    </source>