<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.apache.commons.math3.optim.nonlinear.scalar.noderiv">
        <import package="java.util.Arrays"/>
        <import package="java.util.Random"/>
        <import package="org.apache.commons.math3.Retry"/>
        <import package="org.apache.commons.math3.RetryRunner"/>
        <import package="org.apache.commons.math3.analysis.MultivariateFunction"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooLargeException"/>
        <import package="org.apache.commons.math3.exception.NumberIsTooSmallException"/>
        <import package="org.apache.commons.math3.exception.DimensionMismatchException"/>
        <import package="org.apache.commons.math3.exception.MathUnsupportedOperationException"/>
        <import package="org.apache.commons.math3.exception.MathIllegalStateException"/>
        <import package="org.apache.commons.math3.exception.NotPositiveException"/>
        <import package="org.apache.commons.math3.exception.OutOfRangeException"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.GoalType"/>
        <import package="org.apache.commons.math3.optim.PointValuePair"/>
        <import package="org.apache.commons.math3.optim.InitialGuess"/>
        <import package="org.apache.commons.math3.optim.SimpleBounds"/>
        <import package="org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction"/>
        <import package="org.apache.commons.math3.optim.MaxEval"/>
        <import package="org.apache.commons.math3.random.MersenneTwister"/>
        <import package="org.apache.commons.math3.util.FastMath"/>
        <import package="org.junit.Assert"/>
        <import package="org.junit.Test"/>
        <import package="org.junit.Ignore"/>
        <import package="org.junit.runner.RunWith"/>
        <class name="CMAESOptimizerTest" line="44">
            <javadoc line="44">
                Test for {@link CMAESOptimizer}.                
            </javadoc>
            <declaration name="DIM" type="int" line="50"/>
            <declaration name="LAMBDA" type="int" line="51"/>
            <method name="testInitOutofbounds1" type="void" line="54">
                <declaration name="startPoint" type="double[]" line="55"/>
                <declaration name="insigma" type="double[]" line="56"/>
                <declaration name="boundaries" type="double[][]" line="57"/>
                <declaration name="expected" type="PointValuePair" line="58"/>
            </method>
            <method name="testInitOutofbounds2" type="void" line="65">
                <declaration name="startPoint" type="double[]" line="66"/>
                <declaration name="insigma" type="double[]" line="67"/>
                <declaration name="boundaries" type="double[][]" line="68"/>
                <declaration name="expected" type="PointValuePair" line="69"/>
            </method>
            <method name="testBoundariesDimensionMismatch" type="void" line="77">
                <declaration name="startPoint" type="double[]" line="78"/>
                <declaration name="insigma" type="double[]" line="79"/>
                <declaration name="boundaries" type="double[][]" line="80"/>
                <declaration name="expected" type="PointValuePair" line="81"/>
            </method>
            <method name="testInputSigmaNegative" type="void" line="89">
                <declaration name="startPoint" type="double[]" line="90"/>
                <declaration name="insigma" type="double[]" line="91"/>
                <declaration name="boundaries" type="double[][]" line="92"/>
                <declaration name="expected" type="PointValuePair" line="93"/>
            </method>
            <method name="testInputSigmaOutOfRange" type="void" line="101">
                <declaration name="startPoint" type="double[]" line="102"/>
                <declaration name="insigma" type="double[]" line="103"/>
                <declaration name="boundaries" type="double[][]" line="104"/>
                <declaration name="expected" type="PointValuePair" line="105"/>
            </method>
            <method name="testInputSigmaDimensionMismatch" type="void" line="113">
                <declaration name="startPoint" type="double[]" line="114"/>
                <declaration name="insigma" type="double[]" line="115"/>
                <declaration name="boundaries" type="double[][]" line="116"/>
                <declaration name="expected" type="PointValuePair" line="117"/>
            </method>
            <method name="testRosen" type="void" line="126">
                <declaration name="startPoint" type="double[]" line="127"/>
                <declaration name="insigma" type="double[]" line="128"/>
                <declaration name="boundaries" type="double[][]" line="129"/>
                <declaration name="expected" type="PointValuePair" line="130"/>
            </method>
            <method name="testMaximize" type="void" line="142">
                <declaration name="startPoint" type="double[]" line="143"/>
                <declaration name="insigma" type="double[]" line="144"/>
                <declaration name="boundaries" type="double[][]" line="145"/>
                <declaration name="expected" type="PointValuePair" line="146"/>
            </method>
            <method name="testEllipse" type="void" line="162">
                <declaration name="startPoint" type="double[]" line="163"/>
                <declaration name="insigma" type="double[]" line="164"/>
                <declaration name="boundaries" type="double[][]" line="165"/>
                <declaration name="expected" type="PointValuePair" line="166"/>
            </method>
            <method name="testElliRotated" type="void" line="177">
                <declaration name="startPoint" type="double[]" line="178"/>
                <declaration name="insigma" type="double[]" line="179"/>
                <declaration name="boundaries" type="double[][]" line="180"/>
                <declaration name="expected" type="PointValuePair" line="181"/>
            </method>
            <method name="testCigar" type="void" line="192">
                <declaration name="startPoint" type="double[]" line="193"/>
                <declaration name="insigma" type="double[]" line="194"/>
                <declaration name="boundaries" type="double[][]" line="195"/>
                <declaration name="expected" type="PointValuePair" line="196"/>
            </method>
            <method name="testCigarWithBoundaries" type="void" line="207">
                <declaration name="startPoint" type="double[]" line="208"/>
                <declaration name="insigma" type="double[]" line="209"/>
                <declaration name="boundaries" type="double[][]" line="210"/>
                <declaration name="expected" type="PointValuePair" line="211"/>
            </method>
            <method name="testTwoAxes" type="void" line="222">
                <declaration name="startPoint" type="double[]" line="223"/>
                <declaration name="insigma" type="double[]" line="224"/>
                <declaration name="boundaries" type="double[][]" line="225"/>
                <declaration name="expected" type="PointValuePair" line="226"/>
            </method>
            <method name="testCigTab" type="void" line="237">
                <declaration name="startPoint" type="double[]" line="238"/>
                <declaration name="insigma" type="double[]" line="239"/>
                <declaration name="boundaries" type="double[][]" line="240"/>
                <declaration name="expected" type="PointValuePair" line="241"/>
            </method>
            <method name="testSphere" type="void" line="252">
                <declaration name="startPoint" type="double[]" line="253"/>
                <declaration name="insigma" type="double[]" line="254"/>
                <declaration name="boundaries" type="double[][]" line="255"/>
                <declaration name="expected" type="PointValuePair" line="256"/>
            </method>
            <method name="testTablet" type="void" line="267">
                <declaration name="startPoint" type="double[]" line="268"/>
                <declaration name="insigma" type="double[]" line="269"/>
                <declaration name="boundaries" type="double[][]" line="270"/>
                <declaration name="expected" type="PointValuePair" line="271"/>
            </method>
            <method name="testDiffPow" type="void" line="282">
                <declaration name="startPoint" type="double[]" line="283"/>
                <declaration name="insigma" type="double[]" line="284"/>
                <declaration name="boundaries" type="double[][]" line="285"/>
                <declaration name="expected" type="PointValuePair" line="286"/>
            </method>
            <method name="testSsDiffPow" type="void" line="297">
                <declaration name="startPoint" type="double[]" line="298"/>
                <declaration name="insigma" type="double[]" line="299"/>
                <declaration name="boundaries" type="double[][]" line="300"/>
                <declaration name="expected" type="PointValuePair" line="301"/>
            </method>
            <method name="testAckley" type="void" line="312">
                <declaration name="startPoint" type="double[]" line="313"/>
                <declaration name="insigma" type="double[]" line="314"/>
                <declaration name="boundaries" type="double[][]" line="315"/>
                <declaration name="expected" type="PointValuePair" line="316"/>
            </method>
            <method name="testRastrigin" type="void" line="327">
                <declaration name="startPoint" type="double[]" line="328"/>
                <declaration name="insigma" type="double[]" line="329"/>
                <declaration name="boundaries" type="double[][]" line="330"/>
                <declaration name="expected" type="PointValuePair" line="331"/>
            </method>
            <method name="testConstrainedRosen" type="void" line="342">
                <declaration name="startPoint" type="double[]" line="343"/>
                <declaration name="insigma" type="double[]" line="344"/>
                <declaration name="boundaries" type="double[][]" line="345"/>
                <declaration name="expected" type="PointValuePair" line="346"/>
            </method>
            <method name="testDiagonalRosen" type="void" line="357">
                <declaration name="startPoint" type="double[]" line="358"/>
                <declaration name="insigma" type="double[]" line="359"/>
                <declaration name="boundaries" type="double[][]" line="360"/>
                <declaration name="expected" type="PointValuePair" line="361"/>
            </method>
            <method name="testMath864" type="void" line="369">
                <declaration name="optimizer" type="CMAESOptimizer" line="370"/>
                <anonymous_class line="373">
                    <method name="value" type="double" line="374">
                        <params>
                            <param name="parameters" type="double[]"/>
                        </params>
                        <declaration name="target" type="double" line="375"/>
                        <declaration name="error" type="double" line="376"/>
                    </method>
                </anonymous_class>
                <declaration name="fitnessFunction" type="MultivariateFunction" line="373"/>
                <declaration name="start" type="double[]" line="381"/>
                <declaration name="lower" type="double[]" line="382"/>
                <declaration name="upper" type="double[]" line="383"/>
                <declaration name="sigma" type="double[]" line="384"/>
                <declaration name="result" type="double[]" line="385"/>
            </method>
            <javadoc line="396">
                Cf. MATH-867                
            </javadoc>
            <method name="testFitAccuracyDependsOnBoundary" type="void" line="400">
                <comment line="415">
                    No bounds.                    
                </comment>
                <comment line="425">
                    Optimum is near the lower bound.                    
                </comment>
                <comment line="438">
                    Optimum is near the upper bound.                    
                </comment>
                <comment line="450">
                    System.out.println(&quot;resNoBound=&quot; + resNoBound +
                                        &quot; resNearLo=&quot; + resNearLo +
                                        &quot; resNearHi=&quot; + resNearHi);                    
                </comment>
                <comment line="454">
                    The two values currently differ by a substantial amount, indicating that
                     the bounds definition can prevent reaching the optimum.                    
                </comment>
                <declaration name="optimizer" type="CMAESOptimizer" line="401"/>
                <anonymous_class line="404">
                    <method name="value" type="double" line="405">
                        <params>
                            <param name="parameters" type="double[]"/>
                        </params>
                        <declaration name="target" type="double" line="406"/>
                        <declaration name="error" type="double" line="407"/>
                    </method>
                </anonymous_class>
                <declaration name="fitnessFunction" type="MultivariateFunction" line="404"/>
                <declaration name="start" type="double[]" line="412"/>
                <declaration name="result" type="PointValuePair" line="415"/>
                <declaration name="resNoBound" type="double" line="422"/>
                <declaration name="lower" type="double[]" line="425"/>
                <declaration name="upper" type="double[]" line="426"/>
                <declaration name="sigma" type="double[]" line="427"/>
                <declaration name="resNearLo" type="double" line="435"/>
                <declaration name="resNearHi" type="double" line="447"/>
            </method>
            <javadoc line="459">
                @param func Function to optimize.                
                <param>
                    startPoint Starting point.                    
                </param>
                <param>
                    inSigma Individual input sigma.                    
                </param>
                <param>
                    boundaries Upper / lower point limit.                    
                </param>
                <param>
                    goal Minimization or maximization.                    
                </param>
                <param>
                    lambda Population size used for offspring.                    
                </param>
                <param>
                    isActive Covariance update mechanism.                    
                </param>
                <param>
                    diagonalOnly Simplified covariance update.                    
                </param>
                <param>
                    stopValue Termination criteria for optimization.                    
                </param>
                <param>
                    fTol Tolerance relative error on the objective function.                    
                </param>
                <param>
                    pointTol Tolerance for checking that the optimum is correct.                    
                </param>
                <param>
                    maxEvaluations Maximum number of evaluations.                    
                </param>
                <param>
                    expected Expected point / value.                    
                </param>
            </javadoc>
            <method name="doTest" type="void" line="486">
                <params>
                    <param name="func" type="MultivariateFunction"/>
                    <param name="startPoint" type="double[]"/>
                    <param name="inSigma" type="double[]"/>
                    <param name="boundaries" type="double[][]"/>
                    <param name="goal" type="GoalType"/>
                    <param name="lambda" type="int"/>
                    <param name="isActive" type="boolean"/>
                    <param name="diagonalOnly" type="int"/>
                    <param name="stopValue" type="double"/>
                    <param name="fTol" type="double"/>
                    <param name="pointTol" type="double"/>
                    <param name="maxEvaluations" type="int"/>
                    <param name="expected" type="PointValuePair"/>
                </params>
                <comment line="489">
                    test diagonalOnly = 0 - slow but normally fewer feval#                    
                </comment>
                <comment line="509">
                    System.out.println(&quot;sol=&quot; + Arrays.toString(result.getPoint()));                    
                </comment>
                <declaration name="dim" type="int" line="487"/>
                <declaration name="optim" type="CMAESOptimizer" line="489"/>
                <declaration name="result" type="PointValuePair" line="491"/>
                <scope line="510"/>
            </method>
            <method name="point" type="double[]" line="517">
                <params>
                    <param name="n" type="int"/>
                    <param name="value" type="double"/>
                </params>
                <declaration name="ds" type="double[]" line="518"/>
            </method>
            <method name="boundaries" type="double[][]" line="524">
                <params>
                    <param name="dim" type="int"/>
                    <param name="lower" type="double"/>
                    <param name="upper" type="double"/>
                </params>
                <declaration name="boundaries" type="double[][]" line="525"/>
            </method>
            <class name="Sphere" line="533">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <method name="value" type="double" line="535">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="536"/>
                </method>
            </class>
            <class name="Cigar" line="543">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="factor" type="double" line="544"/>
                <method name="Cigar" type="constructor" line="546"/>
                <method name="Cigar" type="constructor" line="550">
                    <params>
                        <param name="axisratio" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="554">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="555"/>
                </method>
            </class>
            <class name="Tablet" line="562">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="factor" type="double" line="563"/>
                <method name="Tablet" type="constructor" line="565"/>
                <method name="Tablet" type="constructor" line="569">
                    <params>
                        <param name="axisratio" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="573">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="574"/>
                </method>
            </class>
            <class name="CigTab" line="581">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="factor" type="double" line="582"/>
                <method name="CigTab" type="constructor" line="584"/>
                <method name="CigTab" type="constructor" line="588">
                    <params>
                        <param name="axisratio" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="592">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="end" type="int" line="593"/>
                    <declaration name="f" type="double" line="594"/>
                </method>
            </class>
            <class name="TwoAxes" line="601">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="factor" type="double" line="603"/>
                <method name="TwoAxes" type="constructor" line="605"/>
                <method name="TwoAxes" type="constructor" line="609">
                    <params>
                        <param name="axisratio" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="613">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="614"/>
                </method>
            </class>
            <class name="ElliRotated" line="621">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="B" type="Basis" line="622"/>
                <declaration name="factor" type="double" line="623"/>
                <method name="ElliRotated" type="constructor" line="625"/>
                <method name="ElliRotated" type="constructor" line="629">
                    <params>
                        <param name="axisratio" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="633">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="634"/>
                </method>
            </class>
            <class name="Elli" line="642">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="factor" type="double" line="644"/>
                <method name="Elli" type="constructor" line="646"/>
                <method name="Elli" type="constructor" line="650">
                    <params>
                        <param name="axisratio" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="654">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="655"/>
                </method>
            </class>
            <class name="MinusElli" line="662">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <method name="value" type="double" line="664">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                </method>
            </class>
            <class name="DiffPow" line="669">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <method name="value" type="double" line="671">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="672"/>
                </method>
            </class>
            <class name="SsDiffPow" line="680">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <method name="value" type="double" line="682">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="683"/>
                </method>
            </class>
            <class name="Rosen" line="688">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <method name="value" type="double" line="690">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="691"/>
                </method>
            </class>
            <class name="Ackley" line="699">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="axisratio" type="double" line="700"/>
                <method name="Ackley" type="constructor" line="702">
                    <params>
                        <param name="axra" type="double"/>
                    </params>
                </method>
                <method name="Ackley" type="constructor" line="706"/>
                <method name="value" type="double" line="710">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="711"/>
                    <declaration name="res2" type="double" line="712"/>
                    <declaration name="fac" type="double" line="713"/>
                    <scope line="714"/>
                </method>
            </class>
            <class name="Rastrigin" line="725">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <implements interface="MultivariateFunction"/>
                <declaration name="axisratio" type="double" line="727"/>
                <declaration name="amplitude" type="double" line="728"/>
                <method name="Rastrigin" type="constructor" line="730"/>
                <method name="Rastrigin" type="constructor" line="734">
                    <params>
                        <param name="axisratio" type="double"/>
                        <param name="amplitude" type="double"/>
                    </params>
                </method>
                <method name="value" type="double" line="739">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="f" type="double" line="740"/>
                    <declaration name="fac" type="double" line="741"/>
                    <scope line="742"/>
                </method>
            </class>
            <class name="Basis" line="753">
                <comment line="756">
                    use not always the same basis                    
                </comment>
                <declaration name="basis" type="double[][]" line="754"/>
                <declaration name="rand" type="Random" line="755"/>
                <method name="Rotate" type="double[]" line="757">
                    <params>
                        <param name="x" type="double[]"/>
                    </params>
                    <declaration name="y" type="double[]" line="759"/>
                    <scope line="760"/>
                </method>
                <method name="GenBasis" type="void" line="768">
                    <params>
                        <param name="DIM" type="int"/>
                    </params>
                    <comment line="776">
                                                
                    </comment>
                    <comment line="779">
                                                
                    </comment>
                    <comment line="782">
                                                
                    </comment>
                    <comment line="785">
                                                
                    </comment>
                    <comment line="787">
                                                
                    </comment>
                    <comment line="789">
                                                
                    </comment>
                    <comment line="791">
                                                
                    </comment>
                    <declaration name="sp" type="double" line="772"/>
                    <declaration name="i" type="int" line="773"/>
                    <scope line="777">
                        <scope line="782"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>