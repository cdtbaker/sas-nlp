<?xml version="1.0" encoding="UTF-8"?>
    <source package="no.uib.cipr.matrix.sparse">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="no.uib.cipr.matrix.DenseLU"/>
        <import package="no.uib.cipr.matrix.DenseMatrix"/>
        <import package="no.uib.cipr.matrix.DenseVector"/>
        <import package="no.uib.cipr.matrix.Matrix"/>
        <import package="no.uib.cipr.matrix.Vector"/>
        <class name="AMG" line="38">
            <implements interface="Preconditioner"/>
            <javadoc line="38">
                Algebraic multigrid preconditioner. Uses the smoothed aggregation method
                  described by Vanek, Mandel, and Brezina (1996).                
            </javadoc>
            <declaration name="preM" type="SSOR[]" line="44"/>
            <javadoc line="44">
                Relaxations at each level                
            </javadoc>
            <declaration name="m" type="int" line="49"/>
            <javadoc line="49">
                The number of levels                
            </javadoc>
            <declaration name="A" type="CompRowMatrix[]" line="54"/>
            <javadoc line="54">
                System matrix at each level, except at the coarsest                
            </javadoc>
            <declaration name="lu" type="DenseLU" line="59"/>
            <javadoc line="59">
                LU factorization at the coarsest level                
            </javadoc>
            <declaration name="u" type="DenseVector[]" line="64"/>
            <javadoc line="64">
                Solution, right-hand side, and residual vectors at each level                
            </javadoc>
            <declaration name="I" type="CompColMatrix[]" line="69"/>
            <javadoc line="69">
                Interpolation operators going to a finer mesh                
            </javadoc>
            <declaration name="min" type="int" line="74"/>
            <javadoc line="74">
                Smallest matrix size before terminating the AMG setup phase. Matrices
                  smaller than this will be solved by a direct solver                
            </javadoc>
            <declaration name="nu1" type="int" line="80"/>
            <javadoc line="80">
                Number of times to perform the pre- and post-smoothings                
            </javadoc>
            <declaration name="gamma" type="int" line="85"/>
            <javadoc line="85">
                Determines cycle type. gamma=1 is V, gamma=2 is W                
            </javadoc>
            <declaration name="omegaPreF" type="double" line="90"/>
            <javadoc line="90">
                Overrelaxation parameters in the pre- and post-smoothings, and with the
                  possibility of distinct values in the forward and reverse sweeps                
            </javadoc>
            <declaration name="reverse" type="boolean" line="96"/>
            <javadoc line="96">
                Perform a reverse (backwards) smoothing sweep                
            </javadoc>
            <declaration name="omega" type="double" line="101"/>
            <javadoc line="101">
                Jacobi damping parameter, between zero and one. If it equals zero, the
                  method reduces to the standard aggregate multigrid method                
            </javadoc>
            <declaration name="transpose" type="boolean" line="107"/>
            <javadoc line="107">
                Operating in transpose mode?                
            </javadoc>
            <javadoc line="112">
                Sets up the algebraic multigrid preconditioner                
                <param>
                    omegaPreFOverrelaxation parameter in the forward sweep of the
                      pre-smoothing                    
                </param>
                <param>
                    omegaPreROverrelaxation parameter in the backwards sweep of the
                      pre-smoothing                    
                </param>
                <param>
                    omegaPostFOverrelaxation parameter in the forward sweep of the
                      post-smoothing                    
                </param>
                <param>
                    omegaPostROverrelaxation parameter in the backwards sweep of the
                      post-smoothing                    
                </param>
                <param>
                    nu1Number of pre-relaxations to perform                    
                </param>
                <param>
                    nu2Number of post-relaxations to perform                    
                </param>
                <param>
                    gammaNumber of times to go to a coarser level                    
                </param>
                <param>
                    minSmallest matrix size before using a direct solver                    
                </param>
                <param>
                    omegaJacobi damping parameter, between zero and one. If it equals
                      zero, the method reduces to the standard aggregate multigrid
                      method                    
                </param>
            </javadoc>
            <method name="AMG" type="constructor" line="142">
                <params>
                    <param name="omegaPreF" type="double"/>
                    <param name="omegaPreR" type="double"/>
                    <param name="omegaPostF" type="double"/>
                    <param name="omegaPostR" type="double"/>
                    <param name="nu1" type="int"/>
                    <param name="nu2" type="int"/>
                    <param name="gamma" type="int"/>
                    <param name="min" type="int"/>
                    <param name="omega" type="double"/>
                </params>
            </method>
            <javadoc line="158">
                Sets up the algebraic multigrid preconditioner. Uses an SOR method,
                  without the backward sweep in SSOR                
                <param>
                    omegaPreOverrelaxation parameter in the pre-smoothing                    
                </param>
                <param>
                    omegaPostOverrelaxation parameter in the post-smoothing                    
                </param>
                <param>
                    nu1Number of pre-relaxations to perform                    
                </param>
                <param>
                    nu2Number of post-relaxations to perform                    
                </param>
                <param>
                    gammaNumber of times to go to a coarser level                    
                </param>
                <param>
                    minSmallest matrix size before using a direct solver                    
                </param>
                <param>
                    omegaJacobi damping parameter, between zero and one. If it equals
                      zero, the method reduces to the standard aggregate multigrid
                      method                    
                </param>
            </javadoc>
            <method name="AMG" type="constructor" line="180">
                <params>
                    <param name="omegaPre" type="double"/>
                    <param name="omegaPost" type="double"/>
                    <param name="nu1" type="int"/>
                    <param name="nu2" type="int"/>
                    <param name="gamma" type="int"/>
                    <param name="min" type="int"/>
                    <param name="omega" type="double"/>
                </params>
            </method>
            <javadoc line="196">
                Sets up the algebraic multigrid preconditioner using some default
                  parameters. In the presmoothing, &lt;code&gt;omegaF=1&lt;/code&gt; and
                  &lt;code&gt;omegaR=1.85&lt;/code&gt;, while in the postsmoothing,
                  &lt;code&gt;omegaF=1.85&lt;/code&gt; and &lt;code&gt;omegaR=1&lt;/code&gt;. Sets
                  &lt;code&gt;nu1=nu2=gamma=1&lt;/code&gt;, has a smallest matrix size of 40, and
                  sets &lt;code&gt;omega=2/3&lt;/code&gt;.                
            </javadoc>
            <method name="AMG" type="constructor" line="204"/>
            <method name="apply" type="Vector" line="208">
                <params>
                    <param name="b" type="Vector"/>
                    <param name="x" type="Vector"/>
                </params>
            </method>
            <method name="transApply" type="Vector" line="218">
                <params>
                    <param name="b" type="Vector"/>
                    <param name="x" type="Vector"/>
                </params>
            </method>
            <method name="setMatrix" type="void" line="228">
                <params>
                    <param name="A" type="Matrix"/>
                </params>
                <comment line="241">
                    Create the aggregates                    
                </comment>
                <comment line="244">
                    If no aggregates were created, no interpolation operator will be
                     created, and the setup phase stops                    
                </comment>
                <comment line="249">
                    Create an interpolation operator using smoothing. This also
                     creates the Galerkin operator                    
                </comment>
                <comment line="257">
                    Copy to array storage                    
                </comment>
                <comment line="269">
                    Create a LU decomposition of the smallest Galerkin matrix                    
                </comment>
                <comment line="274">
                    Allocate vectors at each level                    
                </comment>
                <comment line="285">
                    Set up the SSOR relaxation schemes                    
                </comment>
                <declaration name="Al" type="List&amp;lt;CompRowMatrix&amp;gt;" line="229"/>
                <declaration name="Il" type="List&amp;lt;CompColMatrix&amp;gt;" line="230"/>
                <scope line="234">
                    <declaration name="Af" type="CompRowMatrix" line="236"/>
                    <declaration name="eps" type="double" line="238"/>
                    <declaration name="aggregator" type="Aggregator" line="241"/>
                    <declaration name="sa" type="Interpolator" line="250"/>
                </scope>
                <declaration name="Ac" type="DenseMatrix" line="269"/>
                <scope line="277">
                    <declaration name="n" type="int" line="278"/>
                </scope>
                <scope line="287">
                    <declaration name="Ak" type="CompRowMatrix" line="288"/>
                </scope>
            </method>
            <javadoc line="296">
                Performs a multigrid cycle                
                <param>
                    kLevel to cycle at. Start by calling &lt;code&gt;cycle(0)&lt;/code&gt;                    
                </param>
            </javadoc>
            <method name="cycle" type="void" line="302">
                <params>
                    <param name="k" type="int"/>
                </params>
                <comment line="308">
                    Presmoothings                    
                </comment>
                <comment line="313">
                    Compute the residual                    
                </comment>
                <comment line="316">
                    Restrict to the next coarser level                    
                </comment>
                <comment line="319">
                    Recurse to next level                    
                </comment>
                <comment line="323">
                    Add residual correction by prolongation                    
                </comment>
                <comment line="326">
                    Postsmoothings                    
                </comment>
                <scope line="305"/>
            </method>
            <javadoc line="330">
                Solves directly at the coarsest level                
            </javadoc>
            <method name="directSolve" type="void" line="333">
                <declaration name="k" type="int" line="334"/>
                <declaration name="U" type="DenseMatrix" line="336"/>
            </method>
            <javadoc line="344">
                Applies the relaxation scheme at the given level                
                <param>
                    kMultigrid level                    
                </param>
            </javadoc>
            <method name="preRelax" type="void" line="350">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="358">
                Applies the relaxation scheme at the given level                
                <param>
                    kMultigrid level                    
                </param>
            </javadoc>
            <method name="postRelax" type="void" line="364">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <class name="Aggregator" line="372">
                <javadoc line="372">
                    Creates aggregates. These are disjoint sets, each of which represents one
                      node at a coarser mesh by aggregating together a set of fine nodes                    
                </javadoc>
                <declaration name="C" type="List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;" line="378"/>
                <javadoc line="378">
                    The aggregates                    
                </javadoc>
                <declaration name="diagind" type="int[]" line="383"/>
                <javadoc line="383">
                    Diagonal indices into the sparse matrix                    
                </javadoc>
                <declaration name="N" type="List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;" line="388"/>
                <javadoc line="388">
                    The strongly coupled node neighborhood of a given node                    
                </javadoc>
                <javadoc line="393">
                    Creates the aggregates                    
                    <param>
                        ASparse matrix                        
                    </param>
                    <param>
                        epsTolerance for selecting the strongly coupled node
                          neighborhoods. Between zero and one.                        
                    </param>
                </javadoc>
                <method name="Aggregator" type="constructor" line="402">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="eps" type="double"/>
                    </params>
                    <comment line="408">
                        Initialization. Remove isolated nodes from the aggregates                        
                    </comment>
                    <comment line="414">
                        Startup aggregation. Use disjoint strongly coupled neighborhoods
                         as the initial aggregate approximation                        
                    </comment>
                    <comment line="421">
                        Enlargment of the aggregates. Add nodes to each aggregate based
                         on how strongly connected the nodes are to a given aggregate                        
                    </comment>
                    <comment line="428">
                        Handling of the remenants. Put all remaining unallocated nodes
                         into new aggregates defined by the intersection of N and R                        
                    </comment>
                    <declaration name="R" type="boolean[]" line="411"/>
                </method>
                <javadoc line="435">
                    Gets the aggregates                    
                </javadoc>
                <method name="getAggregates" type="List&lt;Set&lt;Integer&gt;&gt;" line="438"/>
                <javadoc line="442">
                    Returns the matrix diagonal indices. This is a by-product of the
                      aggregation                    
                </javadoc>
                <method name="getDiagonalIndices" type="int[]" line="446"/>
                <javadoc line="450">
                    Returns the strongly coupled node neighborhoods of a given node. This
                      is a by-product of the aggregation                    
                </javadoc>
                <method name="getNodeNeighborhoods" type="List&lt;Set&lt;Integer&gt;&gt;" line="454"/>
                <javadoc line="458">
                    Finds the diagonal indices of the matrix                    
                </javadoc>
                <method name="findDiagonalIndices" type="int[]" line="461">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                    </params>
                    <declaration name="rowptr" type="int[]" line="462"/>
                    <declaration name="colind" type="int[]" line="463"/>
                    <declaration name="diagind" type="int[]" line="465"/>
                    <scope line="467"/>
                </method>
                <javadoc line="479">
                    Finds the strongly coupled node neighborhoods                    
                </javadoc>
                <method name="findNodeNeighborhood" type="List&lt;Set&lt;Integer&gt;&gt;" line="483">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="diagind" type="int[]"/>
                        <param name="eps" type="double"/>
                    </params>
                    <declaration name="rowptr" type="int[]" line="487"/>
                    <declaration name="colind" type="int[]" line="488"/>
                    <declaration name="data" type="double[]" line="489"/>
                    <scope line="491">
                        <declaration name="Ni" type="Set&amp;lt;Integer&amp;gt;" line="492"/>
                        <declaration name="aii" type="double" line="494"/>
                        <scope line="495">
                            <declaration name="aij" type="double" line="496"/>
                            <declaration name="ajj" type="double" line="497"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="509">
                    Creates the initial R-set by including only the connected nodes                    
                </javadoc>
                <method name="createInitialR" type="boolean[]" line="512">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                    </params>
                    <declaration name="R" type="boolean[]" line="513"/>
                    <declaration name="rowptr" type="int[]" line="515"/>
                    <declaration name="colind" type="int[]" line="516"/>
                    <declaration name="data" type="double[]" line="517"/>
                    <scope line="519">
                        <declaration name="hasOffDiagonal" type="boolean" line="520"/>
                        <scope line="523"/>
                    </scope>
                </method>
                <javadoc line="534">
                    Creates the initial aggregates                    
                </javadoc>
                <method name="createInitialAggregates" type="List&lt;Set&lt;Integer&gt;&gt;" line="538">
                    <params>
                        <param name="N" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="R" type="boolean[]"/>
                    </params>
                    <comment line="544">
                        Skip non-free nodes                        
                    </comment>
                    <comment line="548">
                        See if all nodes in the current N-set are free                        
                    </comment>
                    <comment line="553">
                        Create an aggregate out of N[i]                        
                    </comment>
                    <scope line="541">
                        <declaration name="free" type="boolean" line="548"/>
                        <scope line="553"/>
                    </scope>
                </method>
                <javadoc line="564">
                    Enlarges the aggregates                    
                </javadoc>
                <method name="enlargeAggregates" type="List&lt;Set&lt;Integer&gt;&gt;" line="568">
                    <params>
                        <param name="C" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="N" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="R" type="boolean[]"/>
                    </params>
                    <comment line="571">
                        Contains the aggregates each node is coupled to                        
                    </comment>
                    <comment line="576">
                        Find which aggregate each node is coupled to. This is used for
                         the intersection between Ni and Ck                        
                    </comment>
                    <comment line="582">
                        Number of nodes in the intersection between each C and Ni                        
                    </comment>
                    <comment line="587">
                        Skip non-free nodes                        
                    </comment>
                    <comment line="591">
                        Find the number of nodes intersecting Ni and every C, and
                         keep a track on the largest overlap                        
                    </comment>
                    <comment line="597">
                        The k-index is to an aggregate coupled to node j                        
                    </comment>
                    <comment line="606">
                        Add the node to the proper C-set, and mark it as used
                         Also, check if the node actually does couple to a set                        
                    </comment>
                    <declaration name="belong" type="List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;" line="571"/>
                    <declaration name="intersect" type="int[]" line="582"/>
                    <scope line="584">
                        <declaration name="largest" type="int" line="593"/>
                        <scope line="597">
                            <scope line="599"/>
                        </scope>
                        <scope line="607"/>
                    </scope>
                </method>
                <javadoc line="616">
                    Creates final aggregates from the remaining unallocated nodes                    
                </javadoc>
                <method name="createFinalAggregates" type="List&lt;Set&lt;Integer&gt;&gt;" line="620">
                    <params>
                        <param name="C" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="N" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="R" type="boolean[]"/>
                    </params>
                    <comment line="625">
                        Skip non-free nodes                        
                    </comment>
                    <comment line="629">
                        Create new aggregate from the nodes in N[i] which are free                        
                    </comment>
                    <scope line="622">
                        <declaration name="Cn" type="Set&amp;lt;Integer&amp;gt;" line="629"/>
                        <scope line="631"/>
                    </scope>
                </method>
            </class>
            <class name="Interpolator" line="644">
                <javadoc line="644">
                    Creates interpolation (prolongation) operators using based on the
                      aggregates. Can optionally smooth the aggregates                    
                </javadoc>
                <declaration name="Ac" type="CompRowMatrix" line="650"/>
                <javadoc line="650">
                    The Galerkin coarse-space operator                    
                </javadoc>
                <declaration name="I" type="CompColMatrix" line="655"/>
                <javadoc line="655">
                    The interpolation (prolongation) matrix                    
                </javadoc>
                <javadoc line="660">
                    Creates the interpolation (prolongation) and Galerkin operators                    
                    <param>
                        aggregatorAggregates                        
                    </param>
                    <param>
                        AMatrix                        
                    </param>
                    <param>
                        omegaJacobi damping parameter between zero and one. If zero, no
                          smoothing is performed, and a faster algorithm for forming
                          the Galerkin operator will be used.                        
                    </param>
                </javadoc>
                <method name="Interpolator" type="constructor" line="672">
                    <params>
                        <param name="aggregator" type="Aggregator"/>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="omega" type="double"/>
                    </params>
                    <comment line="678">
                        Create the tentative prolongation, in compressed form                        
                    </comment>
                    <comment line="681">
                        Apply Jacobi smoothing to the prolongator                        
                    </comment>
                    <comment line="687">
                        Smooth the operator by a damped Jacobi method                        
                    </comment>
                    <comment line="691">
                        Form a compressed column storage for the operator                        
                    </comment>
                    <comment line="694">
                        Create the Galerkin operator using a slow method                        
                    </comment>
                    <comment line="698">
                        Use the aggregates as-is                        
                    </comment>
                    <comment line="704">
                        Create the Galerkin operator using a fast method                        
                    </comment>
                    <comment line="707">
                        Form an explicit interpolation operator                        
                    </comment>
                    <declaration name="C" type="List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;" line="673"/>
                    <declaration name="N" type="List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;" line="674"/>
                    <declaration name="diagind" type="int[]" line="675"/>
                    <declaration name="pt" type="int[]" line="678"/>
                    <scope line="684">
                        <declaration name="P" type="List&amp;lt;Map&amp;lt;Integer,Double&amp;gt;&amp;gt;" line="687"/>
                    </scope>
                    <scope line="701"/>
                </method>
                <javadoc line="711">
                    Creates the tentative prolongation operator. Since the columns are
                      all disjoint, and its entries are binary, it is possible to store it
                      in a single array. Its length equals the number of fine nodes, and
                      the entries are the indices to the corresponding aggregate (C-set).                    
                </javadoc>
                <method name="createTentativeProlongation" type="int[]" line="717">
                    <params>
                        <param name="C" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="pt" type="int[]" line="718"/>
                </method>
                <javadoc line="728">
                    Creates the Galerkin operator using the assumption of disjoint
                      (non-smoothed) aggregates                    
                </javadoc>
                <method name="createGalerkinFast" type="CompRowMatrix" line="733">
                    <params>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="pt" type="int[]"/>
                        <param name="c" type="int"/>
                    </params>
                    <declaration name="n" type="int" line="734"/>
                    <declaration name="Ac" type="FlexCompRowMatrix" line="736"/>
                    <declaration name="rowptr" type="int[]" line="738"/>
                    <declaration name="colind" type="int[]" line="739"/>
                    <declaration name="data" type="double[]" line="740"/>
                </method>
                <javadoc line="751">
                    Creates the interpolation (prolongation) matrix based on the smoothed
                      aggregates                    
                </javadoc>
                <method name="createInterpolationMatrix" type="CompColMatrix" line="756">
                    <params>
                        <param name="P" type="List&lt;Map&lt;Integer,Double&gt;&gt;"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="759">
                        Determine the sparsity pattern of I                        
                    </comment>
                    <comment line="774">
                        Populate it with numerical entries                        
                    </comment>
                    <declaration name="c" type="int" line="759"/>
                    <declaration name="nz" type="int[][]" line="760"/>
                    <scope line="761">
                        <declaration name="Pj" type="Map&amp;lt;Integer,Double&amp;gt;" line="763"/>
                        <declaration name="l" type="int" line="766"/>
                    </scope>
                    <scope line="774">
                        <declaration name="Pj" type="Map&amp;lt;Integer,Double&amp;gt;" line="776"/>
                    </scope>
                </method>
                <javadoc line="785">
                    Creates the interpolation (prolongation) matrix based on the
                      non-smoothed aggregates                    
                </javadoc>
                <method name="createInterpolationMatrix" type="CompColMatrix" line="789">
                    <params>
                        <param name="pt" type="int[]"/>
                        <param name="c" type="int"/>
                    </params>
                    <declaration name="If" type="FlexCompColMatrix" line="790"/>
                </method>
                <javadoc line="799">
                    Gets the interpolation (prolongation) operator                    
                </javadoc>
                <method name="getInterpolationOperator" type="CompColMatrix" line="802"/>
                <javadoc line="806">
                    Creates the smoothes interpolation (prolongation) operator by a
                      single sweep of the damped Jacobi method                    
                </javadoc>
                <method name="createSmoothedProlongation" type="List&lt;Map&lt;Integer,Double&gt;&gt;" line="812">
                    <params>
                        <param name="C" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="N" type="List&lt;Set&lt;Integer&gt;&gt;"/>
                        <param name="A" type="CompRowMatrix"/>
                        <param name="diagind" type="int[]"/>
                        <param name="omega" type="double"/>
                        <param name="pt" type="int[]"/>
                    </params>
                    <comment line="817">
                        Allocate the interpolation (prolongation) operator
                         It is stored by columns, so the maps take row-indices as keys                        
                    </comment>
                    <comment line="830">
                        Apply the damped Jacobi smoother                        
                    </comment>
                    <comment line="839">
                        Calculate A*Pt, except for the diagonal                        
                    </comment>
                    <comment line="848">
                        Off-diagonal, include only strong couplings, and add the
                         weak couplings to the diagonal                        
                    </comment>
                    <comment line="858">
                        Subtract the weak couplings from the diagonal part of A*Pt                        
                    </comment>
                    <comment line="861">
                        Scale by omega and the inverse of the diagonal (damping)                        
                    </comment>
                    <comment line="866">
                        Set to (I-omega*D^{-1}*A)*Pt                        
                    </comment>
                    <comment line="869">
                        This has formed a whole row of P=(I-omega*D^{-1}*A)*Pt
                         Store the non-zeros into the sparse structure                        
                    </comment>
                    <declaration name="n" type="int" line="814"/>
                    <declaration name="P" type="List&amp;lt;Map&amp;lt;Integer,Double&amp;gt;&amp;gt;" line="818"/>
                    <declaration name="rowptr" type="int[]" line="823"/>
                    <declaration name="colind" type="int[]" line="824"/>
                    <declaration name="data" type="double[]" line="825"/>
                    <declaration name="dot" type="double[]" line="827"/>
                    <scope line="830">
                        <declaration name="Ni" type="Set&amp;lt;Integer&amp;gt;" line="836"/>
                        <declaration name="weakAij" type="double" line="839"/>
                        <scope line="840">
                            <declaration name="aij" type="double" line="845"/>
                            <scope line="849"/>
                        </scope>
                        <declaration name="scale" type="double" line="861"/>
                    </scope>
                </method>
                <javadoc line="878">
                    Creates the entries of the Galerkin operator
                      &lt;code&gt;Ac = I&lt;sup&gt;T&lt;/sup&gt; A I&lt;/code&gt;. This is a very
                      time-consuming operation                    
                </javadoc>
                <method name="createGalerkinSlow" type="CompRowMatrix" line="884">
                    <params>
                        <param name="I" type="CompColMatrix"/>
                        <param name="A" type="CompRowMatrix"/>
                    </params>
                    <comment line="902">
                        Expand column &apos;k&apos; of I to dense storage                        
                    </comment>
                    <comment line="907">
                        Form column &apos;k&apos; of A*I                        
                    </comment>
                    <comment line="910">
                        Form column &apos;k&apos; of I&apos;*A*I                        
                    </comment>
                    <comment line="913">
                        Store non-zeros into Ac                        
                    </comment>
                    <declaration name="n" type="int" line="885"/>
                    <declaration name="Ac" type="FlexCompRowMatrix" line="886"/>
                    <declaration name="aiCol" type="double[]" line="888"/>
                    <declaration name="iCol" type="double[]" line="889"/>
                    <declaration name="aiV" type="DenseVector" line="890"/>
                    <declaration name="iV" type="DenseVector" line="891"/>
                    <declaration name="itaiCol" type="double[]" line="892"/>
                    <declaration name="itaiV" type="DenseVector" line="893"/>
                    <declaration name="colptr" type="int[]" line="895"/>
                    <declaration name="rowind" type="int[]" line="896"/>
                    <declaration name="Idata" type="double[]" line="897"/>
                    <scope line="899"/>
                </method>
                <javadoc line="921">
                    Gets the Galerkin operator                    
                </javadoc>
                <method name="getGalerkinOperator" type="CompRowMatrix" line="924"/>
            </class>
        </class>
    </source>