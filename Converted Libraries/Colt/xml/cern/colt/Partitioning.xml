<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt">
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.list.DoubleArrayList"/>
        <import package="cern.colt.list.IntArrayList"/>
        <class name="Partitioning" line="14">
            <extends class="Object"/>
            <comment line="46">
                benchmark only                
            </comment>
            <javadoc line="14">
                Given some interval boundaries, partitions arrays such that all elements falling into an interval are placed next to each other.
                  &lt;p&gt;
                  The algorithms partition arrays into two or more intervals. 
                  They distinguish between &lt;i&gt;synchronously&lt;/i&gt; partitioning either one, two or three arrays.
                  They further come in templated versions, either partitioning &lt;tt&gt;int[]&lt;/tt&gt; arrays or &lt;tt&gt;double[]&lt;/tt&gt; arrays.
                  &lt;p&gt;
                  You may want to start out reading about the simplest case: Partitioning one &lt;tt&gt;int[]&lt;/tt&gt; array into two intervals.
                  To do so, read {@link #partition(int[],int,int,int)}.
                  Next, building upon that foundation comes a method partitioning &lt;tt&gt;int[]&lt;/tt&gt; arrays into multiple intervals.
                  See {@link #partition(int[],int,int,int[],int,int,int[])} for related documentation.
                  &lt;p&gt;
                  All other methods are no different than the one&apos;s you now already understand, except that they operate on slightly different data types.
                  &lt;p&gt;
                  &lt;b&gt;Performance&lt;/b&gt;
                  &lt;p&gt;
                  Partitioning into two intervals is &lt;tt&gt;O( N )&lt;/tt&gt;.
                  Partitioning into k intervals is &lt;tt&gt;O( N  log(k))&lt;/tt&gt;.
                  Constants factors are minimized.
                  No temporary memory is allocated; Partitioning is in-place.                
                <see>
                    cern.colt.matrix.doublealgo.Partitioning                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 03-Jul-99                    
                </version>
            </javadoc>
            <declaration name="SMALL" type="int" line="42"/>
            <declaration name="MEDIUM" type="int" line="43"/>
            <declaration name="steps" type="int" line="46"/>
            <declaration name="swappedElements" type="int" line="47"/>
            <javadoc line="48">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Partitioning" type="constructor" line="51"/>
            <javadoc line="52">
                Finds the given key &quot;a&quot; within some generic data using the binary search algorithm.                
                <param>
                    a the index of the key to search for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <param>
                    comp the comparator determining the order of the generic data.
                      Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
                      Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
                      point</i> is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or <tt>list.length</tt>, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="69">
                <params>
                    <param name="a" type="int"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <comment line="75">
                    key found                    
                </comment>
                <comment line="77">
                    key not found.                    
                </comment>
                <scope line="70">
                    <declaration name="mid" type="int" line="71"/>
                    <declaration name="comparison" type="int" line="72"/>
                </scope>
            </method>
            <javadoc line="79">
                Same as {@link #dualPartition(int[],int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="dualPartition" type="void" line="83">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="secondary" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="double[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="84">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="86">
                    nothing to do                    
                </comment>
                <comment line="87">
                    all bins are empty                    
                </comment>
                <comment line="93">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="94">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="95">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="97">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="100">
                    we do have a choice                    
                </comment>
                <comment line="101">
                    Small arrays, middle element                    
                </comment>
                <comment line="106">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="112">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="115">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="117">
                    not found                    
                </comment>
                <comment line="118">
                    not found, one past the end                    
                </comment>
                <comment line="123">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="124">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="128">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="129">
                    no element falls into this bin                    
                </comment>
                <comment line="130">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="135">
                    all elements fall into this bin                    
                </comment>
                <comment line="136">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="142">
                    recursively partition left half                    
                </comment>
                <comment line="147">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="double" line="84"/>
                <scope line="87"/>
                <declaration name="medianIndex" type="int" line="96"/>
                <scope line="97"/>
                <scope line="100">
                    <declaration name="m" type="int" line="101"/>
                    <declaration name="len" type="int" line="102"/>
                    <scope line="103">
                        <declaration name="l" type="int" line="104"/>
                        <declaration name="n" type="int" line="105"/>
                        <scope line="106">
                            <declaration name="s" type="int" line="107"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="125"/>
                <scope line="129">
                    <declaration name="i" type="int" line="131"/>
                </scope>
                <scope line="135">
                    <declaration name="i" type="int" line="137"/>
                </scope>
                <scope line="143"/>
                <scope line="148"/>
            </method>
            <javadoc line="152">
                Same as {@link #dualPartition(int[],int[],int,int,int)} 
                  except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="dualPartition" type="int" line="156">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="secondary" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="double"/>
                </params>
                <comment line="157">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="161">
                    swap x[i] with x[from]                    
                </comment>
                <declaration name="element" type="double" line="157"/>
                <scope line="158">
                    <scope line="160"/>
                </scope>
            </method>
            <javadoc line="172">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions two arrays at the same time;
                  both arrays are partially sorted according to the elements of the primary array.
                  In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array is also moved from index A to B.
                  &lt;p&gt;
                  &lt;b&gt;Use cases:&lt;/b&gt;
                  &lt;p&gt;
                  Image having a large list of 2-dimensional points. 
                  If memory consumption and performance matter, it is a good idea to physically lay them out as two 1-dimensional arrays
                  (using something like &lt;tt&gt;Point2D&lt;/tt&gt; objects would be prohibitively expensive, both in terms of time and space).
                  Now imagine wanting to histogram the points.
                  We may want to partially sort the points by x-coordinate into intervals.
                  This method efficiently does the job.
                  &lt;p&gt;
                  &lt;b&gt;Performance:&lt;/b&gt;
                  &lt;p&gt;
                  Same as for single-partition methods.                
            </javadoc>
            <method name="dualPartition" type="void" line="190">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="secondary" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="int[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="191">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="193">
                    nothing to do                    
                </comment>
                <comment line="194">
                    all bins are empty                    
                </comment>
                <comment line="200">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="201">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="202">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="204">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="207">
                    we do have a choice                    
                </comment>
                <comment line="208">
                    Small arrays, middle element                    
                </comment>
                <comment line="213">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="219">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="222">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="224">
                    not found                    
                </comment>
                <comment line="225">
                    not found, one past the end                    
                </comment>
                <comment line="230">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="231">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="235">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="236">
                    no element falls into this bin                    
                </comment>
                <comment line="237">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="242">
                    all elements fall into this bin                    
                </comment>
                <comment line="243">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="249">
                    recursively partition left half                    
                </comment>
                <comment line="254">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="int" line="191"/>
                <scope line="194"/>
                <declaration name="medianIndex" type="int" line="203"/>
                <scope line="204"/>
                <scope line="207">
                    <declaration name="m" type="int" line="208"/>
                    <declaration name="len" type="int" line="209"/>
                    <scope line="210">
                        <declaration name="l" type="int" line="211"/>
                        <declaration name="n" type="int" line="212"/>
                        <scope line="213">
                            <declaration name="s" type="int" line="214"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="232"/>
                <scope line="236">
                    <declaration name="i" type="int" line="238"/>
                </scope>
                <scope line="242">
                    <declaration name="i" type="int" line="244"/>
                </scope>
                <scope line="250"/>
                <scope line="255"/>
            </method>
            <javadoc line="259">
                Same as {@link #partition(int[],int,int,int)} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions two arrays at the same time;
                  both arrays are partially sorted according to the elements of the primary array.
                  In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array is also moved from index A to B.
                  &lt;p&gt;
                  &lt;b&gt;Performance:&lt;/b&gt;
                  &lt;p&gt;
                  Same as for single-partition methods.                
            </javadoc>
            <method name="dualPartition" type="int" line="268">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="secondary" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="int"/>
                </params>
                <comment line="269">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="273">
                    swap x[i] with x[from]                    
                </comment>
                <declaration name="element" type="int" line="269"/>
                <scope line="270">
                    <scope line="272"/>
                </scope>
            </method>
            <javadoc line="284">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;generically&lt;/i&gt; partitions arbitrary shaped data (for example matrices or multiple arrays) rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.
                  &lt;p&gt;
                  This method operates on arbitrary shaped data and arbitrary shaped splitters. 
                  In fact, it has no idea what kind of data by what kind of splitters it is partitioning. Comparisons and swapping 
                  are delegated to user provided objects which know their data and can do the 
                  job. 
                  &lt;p&gt;
                  Lets call the generic data &lt;tt&gt;g&lt;/tt&gt; (it may be a matrix, one array, three linked lists 
                  or whatever). Lets call the generic splitters &lt;tt&gt;s&lt;/tt&gt;.
                  This class takes a user comparison function operating on two indexes 
                  &lt;tt&gt;(a,b)&lt;/tt&gt;, namely an {@link IntComparator}. 
                  The comparison function determines whether &lt;tt&gt;s[a]&lt;/tt&gt; is equal, less or greater than &lt;tt&gt;g[b]&lt;/tt&gt;. 
                  This method can then decide to swap the data &lt;tt&gt;g[b]&lt;/tt&gt; 
                  with the data &lt;tt&gt;g[c]&lt;/tt&gt; (yes, &lt;tt&gt;c&lt;/tt&gt;, not &lt;tt&gt;a&lt;/tt&gt;). 
                  It calls a user provided {@link cern.colt.Swapper} 
                  object that knows how to swap the data of these two indexes.
                  &lt;p&gt;
                  Again, note the details: Comparisons compare &lt;tt&gt;s[a]&lt;/tt&gt; with &lt;tt&gt;g[b]&lt;/tt&gt;.
                  Swaps swap &lt;tt&gt;g[b]&lt;/tt&gt; with &lt;tt&gt;g[c]&lt;/tt&gt;. 
                  Prior to calling this method, the generic splitters &lt;tt&gt;s&lt;/tt&gt; must be sorted ascending and must not contain multiple equal values.
                  These preconditions are not checked; be sure that they are met.                
                <param>
                    from the index of the first element within <tt>g</tt> to be considered.                    
                </param>
                <param>
                    to the index of the last element within <tt>g</tt> to be considered.
                      The method considers the elements <tt>g[from] .. g[to]</tt>.                    
                </param>
                <param>
                    splitFrom the index of the first splitter element to be considered.                    
                </param>
                <param>
                    splitTo the index of the last splitter element to be considered.
                      The method considers the splitter elements <tt>s[splitFrom] .. s[splitTo]</tt>.                    
                </param>
                <param>
                    splitIndexes a list into which this method fills the indexes of elements delimiting intervals.
                      Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
                      Therefore, must satisfy <tt>splitIndexes.length > splitTo</tt>.                    
                </param>
                <param>
                    comp the comparator comparing a splitter with an element of the generic data.
                      Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
                      Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.                    
                </param>
                <param>
                    comp2 the comparator to determine the order of the generic data.
                      Takes as first argument the index <tt>a</tt> within the generic data <tt>g</tt>.
                      Takes as second argument the index <tt>b</tt> within the generic data <tt>g</tt>.                    
                </param>
                <param>
                    comp3 the comparator comparing a splitter with another splitter.
                      Takes as first argument the index <tt>a</tt> within the generic splitters <tt>s</tt>.
                      Takes as second argument the index <tt>b</tt> within the generic splitters <tt>g</tt>.                    
                </param>
                <param>
                    swapper an object that knows how to swap the elements at any two indexes (a,b).
                      Takes as first argument the index <tt>b</tt> within the generic data <tt>g</tt>.
                      Takes as second argument the index <tt>c</tt> within the generic data <tt>g</tt>.
                      <p>
                      Tip: Normally you will have <tt>splitIndexes.length == s.length</tt> as well as <tt>from==0, to==g.length-1</tt> and <tt>splitFrom==0, splitTo==s.length-1</tt>.                    
                </param>
                <see>
                    Sort                    
                </see>
                <see>
                    Sort#sort(int,int,IntComparator,Swapper)                    
                </see>
                <see>
                    Sorting#binarySearchFromTo(int,int,IntComparator)                    
                </see>
            </javadoc>
            <method name="genericPartition" type="void" line="341">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                    <param name="comp" type="IntComparator"/>
                    <param name="comp2" type="IntComparator"/>
                    <param name="comp3" type="IntComparator"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="342">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="344">
                    nothing to do                    
                </comment>
                <comment line="345">
                    all bins are empty                    
                </comment>
                <comment line="351">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="352">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="353">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="355">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="358">
                    we do have a choice                    
                </comment>
                <comment line="359">
                    Small arrays, middle element                    
                </comment>
                <comment line="364">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="370">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="373">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="375">
                    not found                    
                </comment>
                <comment line="376">
                    not found, one past the end                    
                </comment>
                <comment line="381">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="382">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="387">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="388">
                    no element falls into this bin                    
                </comment>
                <comment line="389">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="394">
                    all elements fall into this bin                    
                </comment>
                <comment line="395">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="402">
                    recursively partition left half                    
                </comment>
                <comment line="407">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="int" line="342"/>
                <scope line="345"/>
                <declaration name="medianIndex" type="int" line="354"/>
                <scope line="355"/>
                <scope line="358">
                    <declaration name="m" type="int" line="359"/>
                    <declaration name="len" type="int" line="360"/>
                    <scope line="361">
                        <declaration name="l" type="int" line="362"/>
                        <declaration name="n" type="int" line="363"/>
                        <scope line="364">
                            <declaration name="s" type="int" line="365"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="383"/>
                <scope line="388">
                    <declaration name="i" type="int" line="390"/>
                </scope>
                <scope line="394">
                    <declaration name="i" type="int" line="396"/>
                </scope>
                <scope line="403"/>
                <scope line="408"/>
            </method>
            <javadoc line="412">
                Same as {@link #partition(int[],int,int,int)} 
                  except that it &lt;i&gt;generically&lt;/i&gt; partitions arbitrary shaped data (for example matrices or multiple arrays) rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="genericPartition" type="int" line="416">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="int"/>
                    <param name="comp" type="IntComparator"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="419">
                    swap x[i] with x[from]                    
                </comment>
                <scope line="417">
                    <scope line="418"/>
                </scope>
            </method>
            <javadoc line="426">
                Returns the index of the median of the three indexed elements.                
            </javadoc>
            <method name="med3" type="int" line="429">
                <params>
                    <param name="x" type="double"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                </params>
            </method>
            <javadoc line="434">
                Returns the index of the median of the three indexed elements.                
            </javadoc>
            <method name="med3" type="int" line="437">
                <params>
                    <param name="x" type="int"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                </params>
            </method>
            <javadoc line="442">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="445">
                <params>
                    <param name="x" type="Object"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="java.util.Comparator"/>
                </params>
                <declaration name="ab" type="int" line="446"/>
                <declaration name="ac" type="int" line="447"/>
                <declaration name="bc" type="int" line="448"/>
            </method>
            <javadoc line="453">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="456">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <declaration name="ab" type="int" line="457"/>
                <declaration name="ac" type="int" line="458"/>
                <declaration name="bc" type="int" line="459"/>
            </method>
            <javadoc line="464">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="partition" type="void" line="468">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="double[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="469">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="471">
                    nothing to do                    
                </comment>
                <comment line="472">
                    all bins are empty                    
                </comment>
                <comment line="478">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="479">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="480">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="482">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="485">
                    we do have a choice                    
                </comment>
                <comment line="486">
                    Small arrays, middle element                    
                </comment>
                <comment line="491">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="497">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="500">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="502">
                    not found                    
                </comment>
                <comment line="503">
                    not found, one past the end                    
                </comment>
                <comment line="508">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="509">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="513">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="514">
                    no element falls into this bin                    
                </comment>
                <comment line="515">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="520">
                    all elements fall into this bin                    
                </comment>
                <comment line="521">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="527">
                    recursively partition left half                    
                </comment>
                <comment line="532">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="double" line="469"/>
                <scope line="472"/>
                <declaration name="medianIndex" type="int" line="481"/>
                <scope line="482"/>
                <scope line="485">
                    <declaration name="m" type="int" line="486"/>
                    <declaration name="len" type="int" line="487"/>
                    <scope line="488">
                        <declaration name="l" type="int" line="489"/>
                        <declaration name="n" type="int" line="490"/>
                        <scope line="491">
                            <declaration name="s" type="int" line="492"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="510"/>
                <scope line="514">
                    <declaration name="i" type="int" line="516"/>
                </scope>
                <scope line="520">
                    <declaration name="i" type="int" line="522"/>
                </scope>
                <scope line="528"/>
                <scope line="533"/>
            </method>
            <javadoc line="537">
                Same as {@link #partition(int[],int,int,int)}except that it partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="partition" type="int" line="541">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="double"/>
                </params>
                <comment line="542">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="546">
                    swap x[i] with x[from]                    
                </comment>
                <declaration name="element" type="double" line="542"/>
                <scope line="543">
                    <scope line="545"/>
                </scope>
            </method>
            <javadoc line="553">
                Partitions (partially sorts) the given list such that all elements falling into some intervals are placed next to each other.
                  Returns the indexes of elements delimiting intervals.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;
                  &lt;tt&gt;list = (7, 4, 5, 50, 6, 4, 3, 6), splitters = (5, 10, 30)&lt;/tt&gt;
                  defines the three intervals &lt;tt&gt;[-infinity,5), [5,10), [10,30)&lt;/tt&gt;.
                  Lets define to sort the entire list (&lt;tt&gt;from=0, to=7&lt;/tt&gt;) using all splitters (&lt;tt&gt;splitFrom==0, splitTo=2&lt;/tt&gt;).
                  &lt;p&gt;
                  The method modifies the list to be &lt;tt&gt;list = (4, 4, 3, 6, 7, 5, 6, 50)&lt;/tt&gt;
                  and returns the &lt;tt&gt;splitIndexes = (2, 6, 6)&lt;/tt&gt;.
                  In other words,
                  &lt;ul&gt;
                  &lt;li&gt;All values &lt;tt&gt;list[0..2]&lt;/tt&gt; fall into &lt;tt&gt;[-infinity,5)&lt;/tt&gt;.
                  &lt;li&gt;All values &lt;tt&gt;list[3..6]&lt;/tt&gt; fall into &lt;tt&gt;[5,10)&lt;/tt&gt;.
                  &lt;li&gt;All values &lt;tt&gt;list[7..6]&lt;/tt&gt; fall into &lt;tt&gt;[10,30)&lt;/tt&gt;, i.e. no elements, since &lt;tt&gt;7&gt;6&lt;/tt&gt;.
                  &lt;li&gt;All values &lt;tt&gt;list[7 .. 7=list.length-1]&lt;/tt&gt; fall into &lt;tt&gt;[30,infinity]&lt;/tt&gt;.
                  &lt;li&gt;In general, all values &lt;tt&gt;list[splitIndexes[j-1]+1 .. splitIndexes[j]]&lt;/tt&gt; fall into interval &lt;tt&gt;j&lt;/tt&gt;.
                  &lt;/ul&gt;
                  As can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other.
                  Note that &lt;i&gt;within&lt;/i&gt; an interval, elements are entirelly unsorted.
                  They are only sorted across interval boundaries.
                  In particular, this partitioning algorithm is not &lt;i&gt;stable&lt;/i&gt;: the relative order of elements is not preserved
                  (Producing a stable algorithm would require no more than minor modifications to method partition(int[],int,int,int)).
                  &lt;p&gt;
                  More formally, this method guarantees that upon return &lt;tt&gt;for all j = splitFrom .. splitTo&lt;/tt&gt; there holds:
                  &lt;br&gt;&lt;tt&gt;for all i = splitIndexes[j-1]+1 .. splitIndexes[j]: splitters[j-1] &lt;= list[i] &lt; splitters[j]&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Performance:&lt;/b&gt;
                  &lt;p&gt;
                  Let &lt;tt&gt;N=to-from+1&lt;/tt&gt; be the number of elements to be partitioned.
                  Let &lt;tt&gt;k=splitTo-splitFrom+1&lt;/tt&gt; be the number of splitter elements.
                  Then we have the following time complexities
                  &lt;ul&gt;
                  &lt;li&gt;Worst case:  &lt;tt&gt;O( N  log(k) )&lt;/tt&gt;.
                  &lt;li&gt;Average case: &lt;tt&gt;O( N  log(k) )&lt;/tt&gt;.
                  &lt;li&gt;Best case: &lt;tt&gt;O( N )&lt;/tt&gt;. 
                  In general, the more uniform (skewed) the data is spread across intervals, the more performance approaches the worst (best) case.
                  If no elements fall into the given intervals, running time is linear.
                  &lt;/ul&gt;
                  No temporary memory is allocated; the sort is in-place.
                  &lt;p&gt;
                  &lt;b&gt;Implementation:&lt;/b&gt;
                  &lt;p&gt;
                  The algorithm can be seen as a Bentley/McIlroy quicksort where swapping and insertion sort are omitted.
                  It is designed to detect and take advantage of skew while maintaining good performance in the uniform case.                
                <param>
                    list the list to be partially sorted.                    
                </param>
                <param>
                    from the index of the first element within <tt>list</tt> to be considered.                    
                </param>
                <param>
                    to the index of the last element within <tt>list</tt> to be considered.
                      The method considers the elements <tt>list[from] .. list[to]</tt>.                    
                </param>
                <param>
                    splitters the values at which the list shall be split into intervals.
                      Must be sorted ascending and must not contain multiple identical values.
                      These preconditions are not checked; be sure that they are met.                    
                </param>
                <param>
                    splitFrom the index of the first splitter element to be considered.                    
                </param>
                <param>
                    splitTo the index of the last splitter element to be considered.
                      The method considers the splitter elements <tt>splitters[splitFrom] .. splitters[splitTo]</tt>.                    
                </param>
                <param>
                    splitIndexes a list into which this method fills the indexes of elements delimiting intervals.
                      Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
                      Therefore, must satisfy <tt>splitIndexes.length > splitTo</tt>.
                      <p>
                      Tip: Normally you will have <tt>splitIndexes.length == splitters.length</tt> as well as <tt>from==0, to==list.length-1</tt> and <tt>splitFrom==0, splitTo==splitters.length-1</tt>.                    
                </param>
                <see>
                    cern.colt.Arrays                    
                </see>
                <see>
                    cern.colt.GenericSorting                    
                </see>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="partition" type="void" line="625">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="int[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="626">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="628">
                    nothing to do                    
                </comment>
                <comment line="629">
                    all bins are empty                    
                </comment>
                <comment line="635">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="636">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="637">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="639">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="642">
                    we do have a choice                    
                </comment>
                <comment line="643">
                    Small arrays, middle element                    
                </comment>
                <comment line="648">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="654">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="657">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="660">
                    int key = list[m];                    
                </comment>
                <comment line="661">
                    if (splitTo-splitFrom+1 &lt; 5) {  on short lists linear search is quicker
                    int i=splitFrom-1;
                    while (++i &lt;= splitTo &amp;&amp; list[i] &lt; key);
                    if (i &gt; splitTo || list[i] &gt; key) i = -i-1;  not found
                    medianIndex = i;
                    }                    
                </comment>
                <comment line="669">
                    else {                    
                </comment>
                <comment line="670">
                    int low = splitFrom;
                    int high = splitTo;
                    int comparison;
                    
                    int mid=0;
                    while (low &lt;= high) {
                    mid = (low + high)  2;
                    comparison = splitters[mid]-key;
                    if (comparison &lt; 0) low = mid + 1;
                    else if (comparison &gt; 0) high = mid - 1;
                    else break; return mid;  key found
                    }
                    medianIndex = mid;
                    if (low &gt; high) medianIndex = -(medianIndex + 1);   key not found.
                    }                    
                </comment>
                <comment line="690">
                    not found                    
                </comment>
                <comment line="691">
                    not found, one past the end                    
                </comment>
                <comment line="696">
                    System.out.println(&quot;medianIndex=&quot;+medianIndex);                    
                </comment>
                <comment line="697">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="698">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="699">
                    Could simply call:                    
                </comment>
                <comment line="701">
                    but for speed the code is manually inlined.                    
                </comment>
                <comment line="702">
                    steps += to-from+1;
                    int head = from;
                    for (int i=from-1; ++i&lt;=to; ) {  swap all elements &lt; splitter to front
                    element = list[i];
                    if (element &lt; splitter) {
                    list[i] = list[head];
                    list[head++] = element;
                    swappedElements++;
                    }
                    }
                    int splitIndex = head-1;                    
                </comment>
                <comment line="722">
                    System.out.println(&quot;splitIndex=&quot;+splitIndex);                    
                </comment>
                <comment line="725">
                    if (splitFrom == splitTo) return; // done                    
                </comment>
                <comment line="727">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="728">
                    no element falls into this bin                    
                </comment>
                <comment line="729">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="734">
                    all elements fall into this bin                    
                </comment>
                <comment line="735">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="741">
                    recursively partition left half                    
                </comment>
                <comment line="743">
                    System.out.println(&quot;1.recursive: from=&quot;+from+&quot;, to=&quot;+splitIndex+&quot;, splitFrom=&quot;+splitFrom+&quot;, splitTo=&quot;+(medianIndex-1));                    
                </comment>
                <comment line="747">
                    recursively partition right half                    
                </comment>
                <comment line="749">
                    System.out.println(&quot;2.recursive: from=&quot;+(splitIndex+1)+&quot;, to=&quot;+to+&quot;, splitFrom=&quot;+(medianIndex+1)+&quot;, splitTo=&quot;+splitTo);                    
                </comment>
                <comment line="752">
                    System.out.println(&quot;BACK TRACKING\n\n&quot;);                    
                </comment>
                <declaration name="element" type="int" line="626"/>
                <scope line="629"/>
                <declaration name="medianIndex" type="int" line="638"/>
                <scope line="639"/>
                <scope line="642">
                    <declaration name="m" type="int" line="643"/>
                    <declaration name="len" type="int" line="644"/>
                    <scope line="645">
                        <declaration name="l" type="int" line="646"/>
                        <declaration name="n" type="int" line="647"/>
                        <scope line="648">
                            <declaration name="s" type="int" line="649"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="700"/>
                <scope line="728">
                    <declaration name="i" type="int" line="730"/>
                </scope>
                <scope line="734">
                    <declaration name="i" type="int" line="736"/>
                </scope>
                <scope line="742"/>
                <scope line="748"/>
            </method>
            <javadoc line="754">
                Partitions (partially sorts) the given list such that all elements falling into the given interval are placed next to each other.
                  Returns the index of the element delimiting the interval.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;
                  &lt;tt&gt;list = (7, 4, 5, 50, 6, 4, 3, 6), splitter = 5&lt;/tt&gt;
                  defines the two intervals &lt;tt&gt;[-infinity,5), [5,+infinity]&lt;/tt&gt;.
                  &lt;p&gt;
                  The method modifies the list to be &lt;tt&gt;list = (4, 4, 3, 50, 6, 7, 5, 6)&lt;/tt&gt;
                  and returns the split index &lt;tt&gt;2&lt;/tt&gt;.
                  In other words,
                  &lt;ul&gt;
                  &lt;li&gt;All values &lt;tt&gt;list[0..2]&lt;/tt&gt; fall into &lt;tt&gt;[-infinity,5)&lt;/tt&gt;.
                  &lt;li&gt;All values &lt;tt&gt;list[3=2+1 .. 7=list.length-1]&lt;/tt&gt; fall into &lt;tt&gt;[5,+infinity]&lt;/tt&gt;.
                  &lt;/ul&gt;
                  As can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other.
                  Note that &lt;i&gt;within&lt;/i&gt; an interval, elements are entirelly unsorted.
                  They are only sorted across interval boundaries.
                  In particular, this partitioning algorithm is not &lt;i&gt;stable&lt;/i&gt;.
                  &lt;p&gt;
                  More formally, this method guarantees that upon return there holds:
                  &lt;ul&gt;
                  &lt;li&gt;for all &lt;tt&gt;i = from .. returnValue: list[i] &lt; splitter&lt;/tt&gt; and
                  &lt;li&gt;for all &lt;tt&gt;i = returnValue+1 .. list.length-1: !(list[i] &lt; splitter)&lt;/tt&gt;.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  &lt;b&gt;Performance:&lt;/b&gt;
                  &lt;p&gt;
                  Let &lt;tt&gt;N=to-from+1&lt;/tt&gt; be the number of elements to be partially sorted.
                  Then the time complexity is &lt;tt&gt;O( N )&lt;/tt&gt;.
                  No temporary memory is allocated; the sort is in-place.
                  &lt;p&gt;                
                <param>
                    list the list to be partially sorted.                    
                </param>
                <param>
                    from the index of the first element within <tt>list</tt> to be considered.                    
                </param>
                <param>
                    to the index of the last element within <tt>list</tt> to be considered.
                      The method considers the elements <tt>list[from] .. list[to]</tt>.                    
                </param>
                <param>
                    splitter the value at which the list shall be split.                    
                </param>
                <return>
                    the index of the largest element falling into the interval <tt>[-infinity,splitter)</tt>, as seen after partitioning.                    
                </return>
            </javadoc>
            <method name="partition" type="int" line="798">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="int"/>
                </params>
                <comment line="801">
                    System.out.println();
                    if (from&lt;=to) {
                    System.out.println(&quot;SORT WORKING: from=&quot;+from+&quot;, to=&quot;+to+&quot;, splitter=&quot;+splitter);
                    }
                    else {
                    System.out.println(&quot;SORT WORKING: NOTHING TO DO.&quot;);
                    }                    
                </comment>
                <comment line="815">
                    returns index of last element &lt; splitter                    
                </comment>
                <comment line="818">
                    for (int i=from-1; ++i&lt;=to; ) {
                    if (list[i] &lt; splitter) {
                    int element = list[i];
                    list[i] = list[from];
                    list[from++] = element;
                    }
                    }                    
                </comment>
                <comment line="835">
                    swap x[i] with x[from]                    
                </comment>
                <comment line="838">
                    swappedElements++;                    
                </comment>
                <comment line="841">
                    if (from&lt;=to) System.out.println(&quot;Swapped &quot;+(head-from)+&quot; elements&quot;);                    
                </comment>
                <comment line="844">
                    JAL:
                    int first = from;
                    int last = to+1;
                    --first;
                    while (true) {
                    while (++first &lt; last &amp;&amp; list[first] &lt; splitter);
                    while (first &lt; --last &amp;&amp; !(list[last] &lt; splitter));
                    if (first &gt;= last) return first-1;
                    int tmp = list[first];
                    list[first] = list[last];
                    list[last] = tmp;
                    }                    
                </comment>
                <comment line="861">
                    System.out.println(&quot;splitter=&quot;+splitter);
                    System.out.println(&quot;before=&quot;+new IntArrayList(list));
                    int head = from;
                    int trail = to;
                    int element;
                    while (head&lt;=trail) {
                    head--;
                    while (++head &lt; trail &amp;&amp; list[head] &lt; splitter);
                    
                    trail++;
                    while (--trail &gt; head &amp;&amp; list[trail] &gt;= splitter);
                    
                    if (head != trail) {
                    element = list[head];
                    list[head] = list[trail];
                    list[trail] = element;
                    }
                    head++;
                    trail--;
                    System.out.println(&quot;after =&quot;+new IntArrayList(list)+&quot;, head=&quot;+head);
                    }                    
                </comment>
                <comment line="886">
                    System.out.println(&quot;splitter=&quot;+splitter);
                    System.out.println(&quot;before=&quot;+new IntArrayList(list));
                    to++;
                    int head = from;
                    int element;
                    int oldHead;
                    while (--to &gt;= from) {
                    element = list[to];
                    if (element &lt; splitter) {
                    from--;
                    while (++from &lt; to &amp;&amp; list[from] &lt; splitter);
                    if (head != to) {
                    list[to] = list[from];
                    list[from++] = element;
                    oldHead = list[head];
                    list[head] = element;
                    list[i] = oldHead;
                    
                    head++;
                    }
                    head++;
                    }
                    System.out.println(&quot;after =&quot;+new IntArrayList(list)+&quot;, head=&quot;+head);
                    }                    
                </comment>
                <comment line="913">
                    int i=from-1;
                    int head = from;
                    int trail = to;
                    while (++i &lt;= trail) {
                    int element = list[i];
                    if (element &lt; splitter) {
                    if (head == i) head++;
                    else {
                     swap list[i] with list[from]
                    int oldHead = list[head];
                    int oldTrail = list[trail];
                    list[head++] = element;
                    list[i--] = oldTrail;
                    list[trail--] = oldHead;
                    }
                    }
                    System.out.println(new IntArrayList(list));
                    
                    }                    
                </comment>
                <comment line="937">
                    return head-1;                    
                </comment>
                <declaration name="element" type="int" line="831"/>
                <scope line="832">
                    <scope line="834"/>
                </scope>
            </method>
            <javadoc line="939">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it partitions &lt;tt&gt;Object[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="partition" type="void" line="943">
                <params>
                    <param name="list" type="Object[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="Object[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                    <param name="comp" type="java.util.Comparator"/>
                </params>
                <comment line="944">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="946">
                    nothing to do                    
                </comment>
                <comment line="947">
                    all bins are empty                    
                </comment>
                <comment line="953">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="954">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="955">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="957">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="960">
                    we do have a choice                    
                </comment>
                <comment line="961">
                    Small arrays, middle element                    
                </comment>
                <comment line="966">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="972">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="975">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="977">
                    not found                    
                </comment>
                <comment line="978">
                    not found, one past the end                    
                </comment>
                <comment line="983">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="984">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="988">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="989">
                    no element falls into this bin                    
                </comment>
                <comment line="990">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="995">
                    all elements fall into this bin                    
                </comment>
                <comment line="996">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="1002">
                    recursively partition left half                    
                </comment>
                <comment line="1007">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="Object" line="944"/>
                <scope line="947"/>
                <declaration name="medianIndex" type="int" line="956"/>
                <scope line="957"/>
                <scope line="960">
                    <declaration name="m" type="int" line="961"/>
                    <declaration name="len" type="int" line="962"/>
                    <scope line="963">
                        <declaration name="l" type="int" line="964"/>
                        <declaration name="n" type="int" line="965"/>
                        <scope line="966">
                            <declaration name="s" type="int" line="967"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="985"/>
                <scope line="989">
                    <declaration name="i" type="int" line="991"/>
                </scope>
                <scope line="995">
                    <declaration name="i" type="int" line="997"/>
                </scope>
                <scope line="1003"/>
                <scope line="1008"/>
            </method>
            <javadoc line="1012">
                Same as {@link #partition(int[],int,int,int)} 
                  except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the objects of the given list by the order of the given comparator.                
            </javadoc>
            <method name="partition" type="int" line="1016">
                <params>
                    <param name="list" type="Object[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="Object"/>
                    <param name="comp" type="java.util.Comparator"/>
                </params>
                <comment line="1017">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="1021">
                    swap x[i] with x[from]                    
                </comment>
                <declaration name="element" type="Object" line="1017"/>
                <scope line="1018">
                    <scope line="1020"/>
                </scope>
            </method>
            <javadoc line="1029">
                Equivalent to &lt;tt&gt;partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())&lt;/tt&gt;.                
            </javadoc>
            <method name="partition" type="void" line="1032">
                <params>
                    <param name="list" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="DoubleArrayList"/>
                    <param name="splitIndexes" type="IntArrayList"/>
                </params>
            </method>
            <javadoc line="1035">
                Equivalent to &lt;tt&gt;partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())&lt;/tt&gt;.                
            </javadoc>
            <method name="partition" type="void" line="1038">
                <params>
                    <param name="list" type="IntArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="IntArrayList"/>
                    <param name="splitIndexes" type="IntArrayList"/>
                </params>
            </method>
            <javadoc line="1041">
                Same as {@link #triplePartition(int[],int[],int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="triplePartition" type="void" line="1045">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="secondary" type="double[]"/>
                    <param name="tertiary" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="double[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="1046">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="1048">
                    nothing to do                    
                </comment>
                <comment line="1049">
                    all bins are empty                    
                </comment>
                <comment line="1055">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="1056">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="1057">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="1059">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="1062">
                    we do have a choice                    
                </comment>
                <comment line="1063">
                    Small arrays, middle element                    
                </comment>
                <comment line="1068">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="1074">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="1077">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="1079">
                    not found                    
                </comment>
                <comment line="1080">
                    not found, one past the end                    
                </comment>
                <comment line="1085">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="1086">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="1090">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="1091">
                    no element falls into this bin                    
                </comment>
                <comment line="1092">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="1097">
                    all elements fall into this bin                    
                </comment>
                <comment line="1098">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="1104">
                    recursively partition left half                    
                </comment>
                <comment line="1109">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="double" line="1046"/>
                <scope line="1049"/>
                <declaration name="medianIndex" type="int" line="1058"/>
                <scope line="1059"/>
                <scope line="1062">
                    <declaration name="m" type="int" line="1063"/>
                    <declaration name="len" type="int" line="1064"/>
                    <scope line="1065">
                        <declaration name="l" type="int" line="1066"/>
                        <declaration name="n" type="int" line="1067"/>
                        <scope line="1068">
                            <declaration name="s" type="int" line="1069"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="1087"/>
                <scope line="1091">
                    <declaration name="i" type="int" line="1093"/>
                </scope>
                <scope line="1097">
                    <declaration name="i" type="int" line="1099"/>
                </scope>
                <scope line="1105"/>
                <scope line="1110"/>
            </method>
            <javadoc line="1114">
                Same as {@link #triplePartition(int[],int[],int[],int,int,int)} 
                  except that it &lt;i&gt;synchronously&lt;/i&gt; partitions &lt;tt&gt;double[]&lt;/tt&gt; rather than &lt;tt&gt;int[]&lt;/tt&gt; arrays.                
            </javadoc>
            <method name="triplePartition" type="int" line="1118">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="secondary" type="double[]"/>
                    <param name="tertiary" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="double"/>
                </params>
                <comment line="1119">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="1123">
                    swap x[i] with x[from]                    
                </comment>
                <declaration name="element" type="double" line="1119"/>
                <scope line="1120">
                    <scope line="1122"/>
                </scope>
            </method>
            <javadoc line="1139">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions three arrays at the same time;
                  all three arrays are partially sorted according to the elements of the primary array.
                  In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index A to B.
                  &lt;p&gt;
                  &lt;b&gt;Use cases:&lt;/b&gt;
                  &lt;p&gt;
                  Image having a large list of 3-dimensional points. 
                  If memory consumption and performance matter, it is a good idea to physically lay them out as three 1-dimensional arrays
                  (using something like &lt;tt&gt;Point3D&lt;/tt&gt; objects would be prohibitively expensive, both in terms of time and space).
                  Now imagine wanting to histogram the points.
                  We may want to partially sort the points by x-coordinate into intervals.
                  This method efficiently does the job.
                  &lt;p&gt;
                  &lt;b&gt;Performance:&lt;/b&gt;
                  &lt;p&gt;
                  Same as for single-partition methods.                
            </javadoc>
            <method name="triplePartition" type="void" line="1157">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="secondary" type="int[]"/>
                    <param name="tertiary" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="int[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="1158">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="1160">
                    nothing to do                    
                </comment>
                <comment line="1161">
                    all bins are empty                    
                </comment>
                <comment line="1167">
                    Choose a partition (pivot) index, m                    
                </comment>
                <comment line="1168">
                    Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.                    
                </comment>
                <comment line="1169">
                    However, computing the median is expensive, so we use an approximation.                    
                </comment>
                <comment line="1171">
                    we don&apos;t really have a choice                    
                </comment>
                <comment line="1174">
                    we do have a choice                    
                </comment>
                <comment line="1175">
                    Small arrays, middle element                    
                </comment>
                <comment line="1180">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="1186">
                    Mid-size, pseudomedian of 3                    
                </comment>
                <comment line="1189">
                    Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.                    
                </comment>
                <comment line="1191">
                    not found                    
                </comment>
                <comment line="1192">
                    not found, one past the end                    
                </comment>
                <comment line="1197">
                    Partition the list according to the splitter, i.e.                    
                </comment>
                <comment line="1198">
                    Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to                    
                </comment>
                <comment line="1202">
                    Optimization: Handle special cases to cut down recursions.                    
                </comment>
                <comment line="1203">
                    no element falls into this bin                    
                </comment>
                <comment line="1204">
                    all bins with splitters[i] &lt;= splitter are empty                    
                </comment>
                <comment line="1209">
                    all elements fall into this bin                    
                </comment>
                <comment line="1210">
                    all bins with splitters[i] &gt;= splitter are empty                    
                </comment>
                <comment line="1216">
                    recursively partition left half                    
                </comment>
                <comment line="1221">
                    recursively partition right half                    
                </comment>
                <declaration name="splitter" type="int" line="1158"/>
                <scope line="1161"/>
                <declaration name="medianIndex" type="int" line="1170"/>
                <scope line="1171"/>
                <scope line="1174">
                    <declaration name="m" type="int" line="1175"/>
                    <declaration name="len" type="int" line="1176"/>
                    <scope line="1177">
                        <declaration name="l" type="int" line="1178"/>
                        <declaration name="n" type="int" line="1179"/>
                        <scope line="1180">
                            <declaration name="s" type="int" line="1181"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="splitIndex" type="int" line="1199"/>
                <scope line="1203">
                    <declaration name="i" type="int" line="1205"/>
                </scope>
                <scope line="1209">
                    <declaration name="i" type="int" line="1211"/>
                </scope>
                <scope line="1217"/>
                <scope line="1222"/>
            </method>
            <javadoc line="1226">
                Same as {@link #partition(int[],int,int,int)} except that this method &lt;i&gt;synchronously&lt;/i&gt; partitions three arrays at the same time;
                  all three arrays are partially sorted according to the elements of the primary array.
                  In other words, each time an element in the primary array is moved from index A to B, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index A to B.
                  &lt;p&gt;
                  &lt;b&gt;Performance:&lt;/b&gt;
                  &lt;p&gt;
                  Same as for single-partition methods.                
            </javadoc>
            <method name="triplePartition" type="int" line="1235">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="secondary" type="int[]"/>
                    <param name="tertiary" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="int"/>
                </params>
                <comment line="1236">
                    int, double --&gt; template type dependent                    
                </comment>
                <comment line="1240">
                    swap x[i] with x[from]                    
                </comment>
                <declaration name="element" type="int" line="1236"/>
                <scope line="1237">
                    <scope line="1239"/>
                </scope>
            </method>
        </class>
    </source>