<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.doublealgo">
        <import package="cern.colt.Swapper"/>
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="Partitioning" line="6">
            <extends class="Object"/>
            <javadoc line="6">
                Given some interval boundaries, partitions matrices such that cell values falling into an interval are placed next to each other.
                  &lt;p&gt;
                  &lt;b&gt;Performance&lt;/b&gt;
                  &lt;p&gt;
                  Partitioning into two intervals is &lt;tt&gt;O( N )&lt;/tt&gt;.
                  Partitioning into k intervals is &lt;tt&gt;O( N  log(k))&lt;/tt&gt;.
                  Constants factors are minimized.                
                <see>
                    cern.colt.Partitioning "Partitioning arrays (provides more documentation)"                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <javadoc line="19">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Partitioning" type="constructor" line="22"/>
            <javadoc line="24">
                Same as {@link cern.colt.Partitioning#partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Note that arguments are not checked for validity.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;column = 0;&lt;br&gt;
                  rowIndexes = {0,1,2,..,matrix.rows()-1};
                  rowFrom = 0;&lt;br&gt;
                  rowTo = matrix.rows()-1;&lt;br&gt;
                  splitters = {5,10,12}&lt;br&gt;
                  c = 0; &lt;br&gt;
                  d = splitters.length-1;&lt;br&gt;
                  partition(matrix,rowIndexes,rowFrom,rowTo,column,splitters,c,d,splitIndexes);&lt;br&gt;
                  ==&gt;&lt;br&gt;
                  splitIndexes == {0, 2, 3}&lt;br&gt;
                  rowIndexes == {7, 6, 5, 4, 0, 1, 2, 3}&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;
                  The matrix IS NOT REORDERED.&lt;br&gt;
                  Here is how it would look&lt;br&gt;
                  like, if it would be reordered&lt;br&gt;
                  accoring to &lt;tt&gt;rowIndexes&lt;/tt&gt;.&lt;br&gt;
                  &lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  2,  1,  0&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be partitioned.                    
                </param>
                <param>
                    rowIndexes the index of the i-th row; is modified by this method to reflect partitioned indexes.                    
                </param>
                <param>
                    rowFrom the index of the first row (inclusive).                    
                </param>
                <param>
                    rowTo the index of the last row (inclusive).                    
                </param>
                <param>
                    column the index of the column to partition on.                    
                </param>
                <param>
                    splitters the values at which the rows shall be split into intervals.
                      Must be sorted ascending and must not contain multiple identical values.
                      These preconditions are not checked; be sure that they are met.                    
                </param>
                <param>
                    splitFrom the index of the first splitter element to be considered.                    
                </param>
                <param>
                    splitTo the index of the last splitter element to be considered.
                      The method considers the splitter elements <tt>splitters[splitFrom] .. splitters[splitTo]</tt>.                    
                </param>
                <param>
                    splitIndexes a list into which this method fills the indexes of rows delimiting intervals.
                      Upon return <tt>splitIndexes[splitFrom..splitTo]</tt> will be set accordingly.
                      Therefore, must satisfy <tt>splitIndexes.length >= splitters.length</tt>.                    
                </param>
            </javadoc>
            <method name="partition" type="void" line="94">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="rowIndexes" type="int[]"/>
                    <param name="rowFrom" type="int"/>
                    <param name="rowTo" type="int"/>
                    <param name="column" type="int"/>
                    <param name="splitters" type="double[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <declaration name="g" type="int[]" line="99"/>
                <anonymous_class line="100">
                    <method name="swap" type="void" line="101">
                        <params>
                            <param name="b" type="int"/>
                            <param name="c" type="int"/>
                        </params>
                        <declaration name="tmp" type="int" line="102"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="Swapper" line="100"/>
                <declaration name="columnView" type="DoubleMatrix1D" line="108"/>
                <anonymous_class line="109">
                    <method name="compare" type="int" line="110">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="av" type="double" line="111"/>
                        <declaration name="bv" type="double" line="112"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="109"/>
                <anonymous_class line="117">
                    <method name="compare" type="int" line="118">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="av" type="double" line="119"/>
                        <declaration name="bv" type="double" line="120"/>
                    </method>
                </anonymous_class>
                <declaration name="comp2" type="IntComparator" line="117"/>
                <anonymous_class line="125">
                    <method name="compare" type="int" line="126">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="av" type="double" line="127"/>
                        <declaration name="bv" type="double" line="128"/>
                    </method>
                </anonymous_class>
                <declaration name="comp3" type="IntComparator" line="125"/>
            </method>
            <javadoc line="135">
                Same as {@link cern.colt.Partitioning#partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Note that arguments are not checked for validity.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;tt&gt;column = 0;&lt;br&gt;
                  splitters = {5,10,12}&lt;br&gt;
                  partition(matrix,column,splitters,splitIndexes);&lt;br&gt;
                  ==&gt;&lt;br&gt;
                  splitIndexes == {0, 2, 3}&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;
                  The matrix IS NOT REORDERED.&lt;br&gt;
                  The new VIEW IS REORDERED:&lt;br&gt;
                  &lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  2,  1,  0&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be partitioned.                    
                </param>
                <param>
                    column the index of the column to partition on.                    
                </param>
                <param>
                    splitters the values at which the rows shall be split into intervals.
                      Must be sorted ascending and must not contain multiple identical values.
                      These preconditions are not checked; be sure that they are met.                    
                </param>
                <param>
                    splitIndexes a list into which this method fills the indexes of rows delimiting intervals.
                      Therefore, must satisfy <tt>splitIndexes.length >= splitters.length</tt>.                    
                </param>
                <return>
                    a new matrix view having rows partitioned by the given column and splitters.                    
                </return>
            </javadoc>
            <method name="partition" type="DoubleMatrix2D" line="191">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="column" type="int"/>
                    <param name="splitters" type="double[]"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <declaration name="rowFrom" type="int" line="192"/>
                <declaration name="rowTo" type="int" line="193"/>
                <declaration name="splitFrom" type="int" line="194"/>
                <declaration name="splitTo" type="int" line="195"/>
                <declaration name="rowIndexes" type="int[]" line="196"/>
                <declaration name="columnIndexes" type="int[]" line="199"/>
            </method>
            <javadoc line="203">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Of course, the column must not be a column of a different matrix.
                  More formally, there must hold: &lt;br&gt;
                  There exists an &lt;tt&gt;i&lt;/tt&gt; such that &lt;tt&gt;matrix.viewColumn(i)==column&lt;/tt&gt;.
                  &lt;p&gt;
                  Note that arguments are not checked for validity.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;column = matrix.viewColumn(0);&lt;br&gt;
                  a = 0;&lt;br&gt;
                  b = column.size()-1;&lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
                  splitters={5,10,12}&lt;br&gt;
                  c=0; &lt;br&gt;
                  d=splitters.length-1;&lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
                  partition(matrix,column,a,b,splitters,c,d,splitIndexes);&lt;br&gt;
                  ==&gt;&lt;br&gt;
                  splitIndexes == {0, 2, 3}&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  2,  1,  0&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
            </javadoc>
            <method name="xPartitionOld" type="void" line="256">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="column" type="DoubleMatrix1D"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="double[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
            </method>
            <javadoc line="258">
                Same as {@link #partition(int[],int,int,int)} 
                  except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Of course, the column must not be a column of a different matrix.
                  More formally, there must hold: &lt;br&gt;
                  There exists an &lt;tt&gt;i&lt;/tt&gt; such that &lt;tt&gt;matrix.viewColumn(i)==column&lt;/tt&gt;.
                  Note that arguments are not checked for validity.                
            </javadoc>
            <method name="xPartitionOld" type="int" line="276">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="column" type="DoubleMatrix1D"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="double"/>
                </params>
            </method>
        </class>
    </source>