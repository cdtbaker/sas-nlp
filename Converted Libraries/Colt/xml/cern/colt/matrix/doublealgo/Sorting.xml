<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.doublealgo">
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.matrix.DoubleFactory2D"/>
        <import package="cern.colt.matrix.DoubleFactory3D"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <import package="cern.colt.matrix.DoubleMatrix3D"/>
        <import package="cern.colt.matrix.impl.DenseDoubleMatrix1D"/>
        <class name="Sorting" line="18">
            <extends class="cern.colt.PersistentObject"/>
            <comment line="47">
                already has quicksort implemented                
            </comment>
            <javadoc line="18">
                Matrix quicksorts and mergesorts.
                  Use idioms like &lt;tt&gt;Sorting.quickSort.sort(...)&lt;/tt&gt; and &lt;tt&gt;Sorting.mergeSort.sort(...)&lt;/tt&gt;.
                  &lt;p&gt;
                  This is another case demonstrating one primary goal of this library: Delivering easy to use, yet very efficient APIs.
                  The sorts return convenient &lt;i&gt;sort views&lt;/i&gt;.
                  This enables the usage of algorithms which scale well with the problem size:
                  For example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix.
                  This is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices.
                  The original matrix is left unaffected.
                  &lt;p&gt;
                  The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in turn, based on Bentley&apos;s and McIlroy&apos;s fine work).
                  The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
                  Mergesort is &lt;i&gt;stable&lt;/i&gt; (by definition), while quicksort is not.
                  A stable sort is, for example, helpful, if matrices are sorted successively 
                  by multiple columns. It preserves the relative position of equal elements.                
                <see>
                    cern.colt.GenericSorting                    
                </see>
                <see>
                    cern.colt.Sorting                    
                </see>
                <see>
                    java.util.Arrays                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.1, 25/May/2000                    
                </version>
            </javadoc>
            <declaration name="quickSort" type="Sorting" line="43"/>
            <javadoc line="43">
                A prefabricated quicksort.                
            </javadoc>
            <declaration name="mergeSort" type="Sorting" line="48"/>
            <javadoc line="48">
                A prefabricated mergesort.                
            </javadoc>
            <anonymous_class line="51">
                <method name="runSort" type="void" line="52">
                    <params>
                        <param name="a" type="int[]"/>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                        <param name="c" type="IntComparator"/>
                    </params>
                </method>
                <method name="runSort" type="void" line="55">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                        <param name="c" type="IntComparator"/>
                        <param name="swapper" type="cern.colt.Swapper"/>
                    </params>
                </method>
            </anonymous_class>
            <javadoc line="59">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Sorting" type="constructor" line="62"/>
            <javadoc line="63">
                Compare two values, one of which is assumed to be Double.NaN                
            </javadoc>
            <method name="compareNaN" type="int" line="66">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
                <comment line="69">
                    NaN equals NaN                    
                </comment>
                <comment line="70">
                    e.g. NaN &gt; 5                    
                </comment>
                <comment line="72">
                    e.g. 5 &lt; NaN                    
                </comment>
                <scope line="67"/>
            </method>
            <method name="runSort" type="void" line="73">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="IntComparator"/>
                </params>
            </method>
            <method name="runSort" type="void" line="76">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="IntComparator"/>
                    <param name="swapper" type="cern.colt.Swapper"/>
                </params>
            </method>
            <javadoc line="79">
                Sorts the vector into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt;.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  To sort ranges use sub-ranging views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt; 7, 1, 3, 1&lt;br&gt;
                  &lt;/tt&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt; ==&amp;gt; 1, 1, 3, 7&lt;br&gt;
                  The vector IS NOT SORTED.&lt;br&gt;
                  The new VIEW IS SORTED.&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    vector the vector to be sorted.                    
                </param>
                <return>
                    a new sorted vector (matrix) view. 
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
            </javadoc>
            <method name="sort" type="DoubleMatrix1D" line="101">
                <params>
                    <param name="vector" type="DoubleMatrix1D"/>
                </params>
                <comment line="103">
                    row indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="110">
                    swap NaNs to the end                    
                </comment>
                <declaration name="indexes" type="int[]" line="102"/>
                <anonymous_class line="105">
                    <method name="compare" type="int" line="106">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <comment line="110">
                            swap NaNs to the end                            
                        </comment>
                        <declaration name="av" type="double" line="107"/>
                        <declaration name="bv" type="double" line="108"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="105"/>
            </method>
            <javadoc line="118">
                Sorts the vector into ascending order, according to the order induced by the specified comparator.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  The algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other.
                  To sort ranges use sub-ranging views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  // sort by sinus of cells
                  DoubleComparator comp = new DoubleComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(double a, double b) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double as = Math.sin(a); double bs = Math.sin(b);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  sorted = quickSort(vector,comp);
                  &lt;/pre&gt;                
                <param>
                    vector the vector to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order.                    
                </param>
                <return>
                    a new matrix view sorted as specified.
                      <b>Note that the original vector (matrix) is left unaffected.</b>                    
                </return>
            </javadoc>
            <method name="sort" type="DoubleMatrix1D" line="141">
                <params>
                    <param name="vector" type="DoubleMatrix1D"/>
                    <param name="c" type="cern.colt.function.DoubleComparator"/>
                </params>
                <comment line="143">
                    row indexes to reorder instead of matrix itself                    
                </comment>
                <declaration name="indexes" type="int[]" line="142"/>
                <anonymous_class line="145">
                    <method name="compare" type="int" line="146">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="145"/>
            </method>
            <javadoc line="155">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the virtual column &lt;tt&gt;aggregates&lt;/tt&gt;;
                  Particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts.
                  Essentially, this algorithm makes expensive comparisons cheap.
                  Normally each element of &lt;tt&gt;aggregates&lt;/tt&gt; is a summary measure of a row.
                  Speedup over comparator based sorting = &lt;tt&gt;2log(rows)&lt;/tt&gt;, on average.
                  For this operation, quicksort is usually faster.
                  &lt;p&gt;
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  Each aggregate is the sum of a row
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
                  1, 1&lt;br&gt;
                  5, 4&lt;br&gt;
                  3, 0&lt;br&gt;
                  4, 4 &lt;br&gt;
                  &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;tt&gt;aggregates=&lt;br&gt;
                  2&lt;br&gt;
                  9&lt;br&gt;
                  3&lt;br&gt;
                  8&lt;br&gt;
                  ==&gt;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
                  1, 1&lt;br&gt;
                  3, 0&lt;br&gt;
                  4, 4&lt;br&gt;
                  5, 4&lt;/tt&gt;&lt;br&gt;
                  The matrix IS NOT SORTED.&lt;br&gt;
                  The new VIEW IS SORTED.&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;table&gt;
                  &lt;td class=&quot;PRE&quot;&gt; 
                  &lt;pre&gt;
                  // sort 10000 x 1000 matrix by sum of logarithms in a row (i.e. by geometric mean)
                  DoubleMatrix2D matrix = new DenseDoubleMatrix2D(10000,1000);
                  matrix.assign(new cern.jet.random.engine.MersenneTwister()); // initialized randomly
                  cern.jet.math.Functions F = cern.jet.math.Functions.functions; // alias for convenience
                  // THE QUICK VERSION (takes some 3 secs)
                  // aggregates[i] = Sum(log(row));
                  double[] aggregates = new double[matrix.rows()];
                  for (int i = matrix.rows(); --i &gt;= 0; ) aggregates[i] = matrix.viewRow(i).aggregate(F.plus, F.log);
                  DoubleMatrix2D sorted = quickSort(matrix,aggregates);
                  // THE SLOW VERSION (takes some 90 secs)
                  DoubleMatrix1DComparator comparator = new DoubleMatrix1DComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix1D x, DoubleMatrix1D y) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a = x.aggregate(F.plus,F.log);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double b = y.aggregate(F.plus,F.log);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return a &lt; b ? -1 : a==b ? 0 : 1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  DoubleMatrix2D sorted = quickSort(matrix,comparator);
                  &lt;/pre&gt;
                  &lt;/td&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be sorted.                    
                </param>
                <param>
                    aggregates the values to sort on. (As a side effect, this array will also get sorted).                    
                </param>
                <return>
                    a new matrix view having rows sorted.
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>aggregates.length != matrix.rows()</tt>.                    
                </throws>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="228">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="aggregates" type="double[]"/>
                </params>
                <comment line="233">
                    set up index reordering                    
                </comment>
                <comment line="237">
                    compares two aggregates at a time                    
                </comment>
                <comment line="242">
                    swap NaNs to the end                    
                </comment>
                <comment line="246">
                    swaps aggregates and reorders indexes                    
                </comment>
                <comment line="255">
                    sort indexes and aggregates                    
                </comment>
                <comment line="258">
                    view the matrix according to the reordered row indexes
                     take all columns in the original order                    
                </comment>
                <declaration name="rows" type="int" line="229"/>
                <declaration name="indexes" type="int[]" line="233"/>
                <anonymous_class line="237">
                    <method name="compare" type="int" line="238">
                        <params>
                            <param name="x" type="int"/>
                            <param name="y" type="int"/>
                        </params>
                        <comment line="242">
                            swap NaNs to the end                            
                        </comment>
                        <declaration name="a" type="double" line="239"/>
                        <declaration name="b" type="double" line="240"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.IntComparator" line="237"/>
                <anonymous_class line="246">
                    <method name="swap" type="void" line="247">
                        <params>
                            <param name="x" type="int"/>
                            <param name="y" type="int"/>
                        </params>
                        <declaration name="t1" type="int" line="248"/>
                        <declaration name="t2" type="double" line="248"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="246"/>
            </method>
            <javadoc line="261">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given column.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
                  7, 6&lt;br&gt;
                  5, 4&lt;br&gt;
                  3, 2&lt;br&gt;
                  1, 0 &lt;br&gt;
                  &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;column = 0;&lt;br&gt;
                  view = quickSort(matrix,column);&lt;br&gt;
                  System.out.println(view); &lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
                  ==&gt; &lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
                  1, 0&lt;br&gt;
                  3, 2&lt;br&gt;
                  5, 4&lt;br&gt;
                  7, 6&lt;/tt&gt;&lt;br&gt;
                  The matrix IS NOT SORTED.&lt;br&gt;
                  The new VIEW IS SORTED.&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be sorted.                    
                </param>
                <param>
                    column the index of the column inducing the order.                    
                </param>
                <return>
                    a new matrix view having rows sorted by the given column.
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>column < 0 || column >= matrix.columns()</tt>.                    
                </throws>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="299">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="column" type="int"/>
                </params>
                <comment line="303">
                    row indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="311">
                    swap NaNs to the end                    
                </comment>
                <comment line="318">
                    view the matrix according to the reordered row indexes
                     take all columns in the original order                    
                </comment>
                <declaration name="rowIndexes" type="int[]" line="302"/>
                <declaration name="col" type="DoubleMatrix1D" line="305"/>
                <anonymous_class line="306">
                    <method name="compare" type="int" line="307">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <comment line="311">
                            swap NaNs to the end                            
                        </comment>
                        <declaration name="av" type="double" line="308"/>
                        <declaration name="bv" type="double" line="309"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="306"/>
            </method>
            <javadoc line="321">
                Sorts the matrix rows according to the order induced by the specified comparator.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  The algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
                  To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  // sort by sum of values in a row
                  DoubleMatrix1DComparator comp = new DoubleMatrix1DComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix1D a, DoubleMatrix1D b) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double as = a.zSum(); double bs = b.zSum();
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  sorted = quickSort(matrix,comp);
                  &lt;/pre&gt;                
                <param>
                    matrix the matrix to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order.                    
                </param>
                <return>
                    a new matrix view having rows sorted as specified.
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="344">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="c" type="DoubleMatrix1DComparator"/>
                </params>
                <comment line="346">
                    row indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="349">
                    precompute views for speed                    
                </comment>
                <comment line="354">
                    return c.compare(matrix.viewRow(a), matrix.viewRow(b));                    
                </comment>
                <comment line="361">
                    view the matrix according to the reordered row indexes
                     take all columns in the original order                    
                </comment>
                <declaration name="rowIndexes" type="int[]" line="345"/>
                <declaration name="views" type="DoubleMatrix1D[]" line="348"/>
                <anonymous_class line="351">
                    <method name="compare" type="int" line="352">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <comment line="354">
                            return c.compare(matrix.viewRow(a), matrix.viewRow(b));                            
                        </comment>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="351"/>
            </method>
            <javadoc line="364">
                Sorts the matrix rows into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the values computed by applying the given aggregation function to each row;
                  Particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts.
                  Essentially, this algorithm makes expensive comparisons cheap.
                  Normally &lt;tt&gt;aggregates&lt;/tt&gt; defines a summary measure of a row.
                  Speedup over comparator based sorting = &lt;tt&gt;2log(rows)&lt;/tt&gt;, on average.
                  &lt;p&gt;
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  To sort ranges use sub-ranging views. To sort columns by rows, use dice views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  Each aggregate is the sum of a row
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;4 x 2 matrix: &lt;br&gt;
                  1, 1&lt;br&gt;
                  5, 4&lt;br&gt;
                  3, 0&lt;br&gt;
                  4, 4 &lt;br&gt;
                  &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;tt&gt;aggregates=&lt;br&gt;
                  hep.aida.bin.BinFunctions1D.sum&lt;br&gt;
                  ==&gt;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;4 x 2 matrix:&lt;br&gt;
                  1, 1&lt;br&gt;
                  3, 0&lt;br&gt;
                  4, 4&lt;br&gt;
                  5, 4&lt;/tt&gt;&lt;br&gt;
                  The matrix IS NOT SORTED.&lt;br&gt;
                  The new VIEW IS SORTED.&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;table&gt;
                  &lt;td class=&quot;PRE&quot;&gt; 
                  &lt;pre&gt;
                  // sort 10000 x 1000 matrix by median or by sum of logarithms in a row (i.e. by geometric mean)
                  DoubleMatrix2D matrix = new DenseDoubleMatrix2D(10000,1000);
                  matrix.assign(new cern.jet.random.engine.MersenneTwister()); // initialized randomly
                  cern.jet.math.Functions F = cern.jet.math.Functions.functions; // alias for convenience
                  // THE QUICK VERSION (takes some 10 secs)
                  DoubleMatrix2D sorted = quickSort(matrix,hep.aida.bin.BinFunctions1D.median);
                  //DoubleMatrix2D sorted = quickSort(matrix,hep.aida.bin.BinFunctions1D.sumOfLogarithms);
                  // THE SLOW VERSION (takes some 300 secs)
                  DoubleMatrix1DComparator comparator = new DoubleMatrix1DComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix1D x, DoubleMatrix1D y) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double a = cern.colt.matrix.doublealgo.Statistic.bin(x).median();
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double b = cern.colt.matrix.doublealgo.Statistic.bin(y).median();
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// double a = x.aggregate(F.plus,F.log);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// double b = y.aggregate(F.plus,F.log);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return a &lt; b ? -1 : a==b ? 0 : 1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  DoubleMatrix2D sorted = quickSort(matrix,comparator);
                  &lt;/pre&gt;
                  &lt;/td&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be sorted.                    
                </param>
                <param>
                    aggregate the function to sort on; aggregates values in a row.                    
                </param>
                <return>
                    a new matrix view having rows sorted.
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
            </javadoc>
            <method name="sort" type="DoubleMatrix2D" line="432">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                    <param name="aggregate" type="hep.aida.bin.BinFunction1D"/>
                </params>
                <comment line="434">
                    precompute aggregates over rows, as defined by &quot;aggregate&quot;                    
                </comment>
                <comment line="436">
                    a bit clumsy, because Statistic.aggregate(...) is defined on columns, so we need to transpose views                    
                </comment>
                <declaration name="tmp" type="DoubleMatrix2D" line="436"/>
                <declaration name="func" type="hep.aida.bin.BinFunction1D[]" line="437"/>
                <declaration name="aggr" type="double[]" line="439"/>
            </method>
            <javadoc line="442">
                Sorts the matrix slices into ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of the matrix values in the given &lt;tt&gt;[row,column]&lt;/tt&gt; position.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
                  &lt;p&gt;
                  The algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other.
                  Comparison is based on the cell &lt;tt&gt;[row,column]&lt;/tt&gt; within a slice.
                  Let &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;B&lt;/tt&gt; be two 2-d slices. Then we have the following rules
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;A &amp;lt;  B  iff A.get(row,column) &amp;lt;  B.get(row,column)&lt;/tt&gt;
                  &lt;li&gt;&lt;tt&gt;A == B iff A.get(row,column) == B.get(row,column)&lt;/tt&gt;
                  &lt;li&gt;&lt;tt&gt;A &amp;gt;  B  iff A.get(row,column) &amp;gt;  B.get(row,column)&lt;/tt&gt;
                  &lt;/ul&gt;                
                <param>
                    matrix the matrix to be sorted.                    
                </param>
                <param>
                    row the index of the row inducing the order.                    
                </param>
                <param>
                    column the index of the column inducing the order.                    
                </param>
                <return>
                    a new matrix view having slices sorted by the values of the slice view <tt>matrix.viewRow(row).viewColumn(column)</tt>.
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>row < 0 || row >= matrix.rows() || column < 0 || column >= matrix.columns()</tt>.                    
                </throws>
            </javadoc>
            <method name="sort" type="DoubleMatrix3D" line="463">
                <params>
                    <param name="matrix" type="DoubleMatrix3D"/>
                    <param name="row" type="int"/>
                    <param name="column" type="int"/>
                </params>
                <comment line="468">
                    indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="476">
                    swap NaNs to the end                    
                </comment>
                <comment line="483">
                    view the matrix according to the reordered slice indexes
                     take all rows and columns in the original order                    
                </comment>
                <declaration name="sliceIndexes" type="int[]" line="467"/>
                <declaration name="sliceView" type="DoubleMatrix1D" line="470"/>
                <anonymous_class line="471">
                    <method name="compare" type="int" line="472">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <comment line="476">
                            swap NaNs to the end                            
                        </comment>
                        <declaration name="av" type="double" line="473"/>
                        <declaration name="bv" type="double" line="474"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="471"/>
            </method>
            <javadoc line="486">
                Sorts the matrix slices according to the order induced by the specified comparator.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.
                  The algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other.
                  To sort ranges use sub-ranging views. To sort by other dimensions, use dice views. To sort descending, use flip views ...
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  // sort by sum of values in a slice
                  DoubleMatrix2DComparator comp = new DoubleMatrix2DComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(DoubleMatrix2D a, DoubleMatrix2D b) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double as = a.zSum(); double bs = b.zSum();
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return as &lt; bs ? -1 : as == bs ? 0 : 1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  sorted = quickSort(matrix,comp);
                  &lt;/pre&gt;                
                <param>
                    matrix the matrix to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order.                    
                </param>
                <return>
                    a new matrix view having slices sorted as specified.
                      <b>Note that the original matrix is left unaffected.</b>                    
                </return>
            </javadoc>
            <method name="sort" type="DoubleMatrix3D" line="509">
                <params>
                    <param name="matrix" type="DoubleMatrix3D"/>
                    <param name="c" type="DoubleMatrix2DComparator"/>
                </params>
                <comment line="511">
                    indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="514">
                    precompute views for speed                    
                </comment>
                <comment line="519">
                    return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));                    
                </comment>
                <comment line="526">
                    view the matrix according to the reordered slice indexes
                     take all rows and columns in the original order                    
                </comment>
                <declaration name="sliceIndexes" type="int[]" line="510"/>
                <declaration name="views" type="DoubleMatrix2D[]" line="513"/>
                <anonymous_class line="516">
                    <method name="compare" type="int" line="517">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <comment line="519">
                            return c.compare(matrix.viewSlice(a), matrix.viewSlice(b));                            
                        </comment>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="516"/>
            </method>
            <javadoc line="529">
                Demonstrates advanced sorting.
                  Sorts by sum of row.                
            </javadoc>
            <method name="zdemo1" type="void" line="533">
                <declaration name="sort" type="Sorting" line="534"/>
                <declaration name="matrix" type="DoubleMatrix2D" line="535"/>
                <anonymous_class line="536">
                    <method name="compare" type="int" line="537">
                        <params>
                            <param name="a" type="DoubleMatrix1D"/>
                            <param name="b" type="DoubleMatrix1D"/>
                        </params>
                        <declaration name="as" type="double" line="538"/>
                        <declaration name="bs" type="double" line="538"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="DoubleMatrix1DComparator" line="536"/>
            </method>
            <javadoc line="545">
                Demonstrates advanced sorting.
                  Sorts by sum of slice.                
            </javadoc>
            <method name="zdemo2" type="void" line="549">
                <declaration name="sort" type="Sorting" line="550"/>
                <declaration name="matrix" type="DoubleMatrix3D" line="551"/>
                <anonymous_class line="552">
                    <method name="compare" type="int" line="553">
                        <params>
                            <param name="a" type="DoubleMatrix2D"/>
                            <param name="b" type="DoubleMatrix2D"/>
                        </params>
                        <declaration name="as" type="double" line="554"/>
                        <declaration name="bs" type="double" line="555"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="DoubleMatrix2DComparator" line="552"/>
            </method>
            <javadoc line="562">
                Demonstrates advanced sorting.
                  Sorts by sinus of cell values.                
            </javadoc>
            <method name="zdemo3" type="void" line="566">
                <comment line="582">
                    check whether it is really sorted                    
                </comment>
                <comment line="584">
                    sorted.assign(
                    new cern.colt.function.DoubleFunction() {
                    public double apply(double arg) { return Math.sin(arg); }
                    }
                    );                    
                </comment>
                <declaration name="sort" type="Sorting" line="567"/>
                <declaration name="values" type="double[]" line="568"/>
                <declaration name="matrix" type="DoubleMatrix1D" line="569"/>
                <anonymous_class line="570">
                    <method name="compare" type="int" line="571">
                        <params>
                            <param name="a" type="double"/>
                            <param name="b" type="double"/>
                        </params>
                        <declaration name="as" type="double" line="572"/>
                        <declaration name="bs" type="double" line="572"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.DoubleComparator" line="570"/>
                <declaration name="sorted" type="DoubleMatrix1D" line="578"/>
            </method>
            <javadoc line="592">
                Demonstrates applying functions.                
            </javadoc>
            <method name="zdemo4" type="void" line="595">
                <comment line="606">
                    matrix1.assign(matrix2,
                    new cern.colt.function.DoubleDoubleFunction() {
                    public double apply(double x, double y) { return Math.pow(x,y); }
                    }
                    );                    
                </comment>
                <declaration name="values1" type="double[]" line="596"/>
                <declaration name="values2" type="double[]" line="597"/>
                <declaration name="matrix1" type="DoubleMatrix1D" line="598"/>
                <declaration name="matrix2" type="DoubleMatrix1D" line="599"/>
            </method>
            <javadoc line="615">
                Demonstrates sorting with precomputation of aggregates (median and sum of logarithms).                
            </javadoc>
            <method name="zdemo5" type="void" line="618">
                <params>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="621">
                    for reliable benchmarks, call this method twice: once with small dummy parameters to &quot;warm up&quot; the jitter, then with your real work-load                    
                </comment>
                <comment line="629">
                    initialize randomly                    
                </comment>
                <comment line="632">
                    also benchmark copying in its several implementation flavours                    
                </comment>
                <comment line="643">
                    System.out.println(A);                    
                </comment>
                <comment line="652">
                    THE QUICK VERSION (takes some 10 secs)                    
                </comment>
                <comment line="654">
                    A = sort.sort(A,hep.aida.bin.BinFunctions1D.sumLog);                    
                </comment>
                <comment line="657">
                    check results for correctness
                     WARNING: be sure NOT TO PRINT huge matrices unless you have tons of main memory and time!!
                     so we just show the first 5 rows                    
                </comment>
                <comment line="679">
                    double a = x.aggregate(F.plus,F.log);
                    double b = y.aggregate(F.plus,F.log);                    
                </comment>
                <declaration name="sort" type="Sorting" line="619"/>
                <declaration name="timer" type="cern.colt.Timer" line="624"/>
                <declaration name="F" type="cern.jet.math.Functions" line="626"/>
                <declaration name="A" type="DoubleMatrix2D" line="627"/>
                <declaration name="B" type="DoubleMatrix2D" line="632"/>
                <scope line="659">
                    <declaration name="r" type="int" line="660"/>
                    <declaration name="funs" type="hep.aida.bin.BinFunction1D[]" line="661"/>
                    <declaration name="rowNames" type="String[]" line="662"/>
                    <declaration name="columnNames" type="String[]" line="663"/>
                </scope>
                <anonymous_class line="674">
                    <method name="compare" type="int" line="675">
                        <params>
                            <param name="x" type="DoubleMatrix1D"/>
                            <param name="y" type="DoubleMatrix1D"/>
                        </params>
                        <comment line="679">
                            double a = x.aggregate(F.plus,F.log);
                            double b = y.aggregate(F.plus,F.log);                            
                        </comment>
                        <declaration name="a" type="double" line="676"/>
                        <declaration name="b" type="double" line="677"/>
                    </method>
                </anonymous_class>
                <declaration name="fun" type="cern.colt.matrix.doublealgo.DoubleMatrix1DComparator" line="674"/>
            </method>
            <javadoc line="687">
                Demonstrates advanced sorting.
                  Sorts by sum of row.                
            </javadoc>
            <method name="zdemo6" type="void" line="691">
                <comment line="708">
                    DoubleMatrix1DComparator comp = new DoubleMatrix1DComparator() {
                    public int compare(DoubleMatrix1D a, DoubleMatrix1D b) {
                    double as = a.zSum(); double bs = b.zSum();
                    return as &lt; bs ? -1 : as == bs ? 0 : 1;
                    }
                    };                    
                </comment>
                <declaration name="sort" type="Sorting" line="692"/>
                <declaration name="values" type="double[][]" line="693"/>
                <declaration name="A" type="DoubleMatrix2D" line="705"/>
                <declaration name="B" type="DoubleMatrix2D" line="706"/>
            </method>
            <javadoc line="725">
                Demonstrates sorting with precomputation of aggregates, comparing mergesort with quicksort.                
            </javadoc>
            <method name="zdemo7" type="void" line="728">
                <params>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="730">
                    for reliable benchmarks, call this method twice: once with small dummy parameters to &quot;warm up&quot; the jitter, then with your real work-load                    
                </comment>
                <comment line="737">
                    initialize randomly                    
                </comment>
                <declaration name="F" type="cern.jet.math.Functions" line="734"/>
                <declaration name="A" type="DoubleMatrix2D" line="735"/>
                <declaration name="B" type="DoubleMatrix2D" line="737"/>
                <declaration name="v1" type="double[]" line="739"/>
                <declaration name="v2" type="double[]" line="740"/>
                <declaration name="timer" type="cern.colt.Timer" line="742"/>
            </method>
        </class>
    </source>