<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.linalg">
        <import package="cern.colt.matrix.DoubleFactory2D"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="Algebra" line="5">
            <extends class="cern.colt.PersistentObject"/>
            <javadoc line="5">
                Linear algebraic matrix operations operating on {@link DoubleMatrix2D}; concentrates most functionality of this package.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <declaration name="DEFAULT" type="Algebra" line="11"/>
            <javadoc line="11">
                A default Algebra object; has {@link Property#DEFAULT} attached for tolerance. 
                  Allows ommiting to construct an Algebra object time and again.
                  Note that this Algebra object is immutable.
                  Any attempt to assign a new Property object to it (via method &lt;tt&gt;setProperty&lt;/tt&gt;), or to alter the tolerance of its property object (via &lt;tt&gt;property().setTolerance(...)&lt;/tt&gt;) will throw an exception.                
            </javadoc>
            <declaration name="ZERO" type="Algebra" line="18"/>
            <javadoc line="18">
                A default Algebra object; has {@link Property#ZERO} attached for tolerance. 
                  Allows ommiting to construct an Algebra object time and again.
                  Note that this Algebra object is immutable.
                  Any attempt to assign a new Property object to it (via method &lt;tt&gt;setProperty&lt;/tt&gt;), or to alter the tolerance of its property object (via &lt;tt&gt;property().setTolerance(...)&lt;/tt&gt;) will throw an exception.                
            </javadoc>
            <declaration name="property" type="Property" line="25"/>
            <javadoc line="25">
                The property object attached to this instance.                
            </javadoc>
            <scope line="29"/>
            <javadoc line="35">
                Constructs a new instance with an equality tolerance given by &lt;tt&gt;Property.DEFAULT.tolerance()&lt;/tt&gt;.                
            </javadoc>
            <method name="Algebra" type="constructor" line="38"/>
            <javadoc line="41">
                Constructs a new instance with the given equality tolerance.                
                <param>
                    tolerance the tolerance to be used for equality operations.                    
                </param>
            </javadoc>
            <method name="Algebra" type="constructor" line="45">
                <params>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="48">
                Constructs and returns the cholesky-decomposition of the given matrix.                
            </javadoc>
            <method name="chol" type="CholeskyDecomposition" line="51">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="54">
                Returns a copy of the receiver.
                  The attached property object is also copied. Hence, the property object of the copy is mutable.                
                <return>
                    a copy of the receiver.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="59"/>
            <javadoc line="62">
                Returns the condition of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the ratio of largest to smallest singular value.                
            </javadoc>
            <method name="cond" type="double" line="65">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="68">
                Returns the determinant of matrix &lt;tt&gt;A&lt;/tt&gt;.                
                <return>
                    the determinant.                    
                </return>
            </javadoc>
            <method name="det" type="double" line="72">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="75">
                Constructs and returns the Eigenvalue-decomposition of the given matrix.                
            </javadoc>
            <method name="eig" type="EigenvalueDecomposition" line="78">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="81">
                Returns sqrt(a^2 + b^2) without under/overflow.                
            </javadoc>
            <method name="hypot" type="double" line="84">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
                <declaration name="r" type="double" line="85"/>
                <scope line="86"/>
                <scope line="90"/>
                <scope line="94"/>
            </method>
            <javadoc line="99">
                Returns sqrt(a^2 + b^2) without under/overflow.                
            </javadoc>
            <method name="hypotFunction" type="cern.colt.function.DoubleDoubleFunction" line="102">
                <anonymous_class line="103">
                    <method name="apply" type="double" line="104">
                        <params>
                            <param name="a" type="double"/>
                            <param name="b" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="110">
                Returns the inverse or pseudo-inverse of matrix &lt;tt&gt;A&lt;/tt&gt;.                
                <return>
                    a new independent matrix; inverse(matrix) if the matrix is square, pseudoinverse otherwise.                    
                </return>
            </javadoc>
            <method name="inverse" type="DoubleMatrix2D" line="114">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <scope line="115">
                    <declaration name="inv" type="DoubleMatrix2D" line="116"/>
                    <declaration name="isNonSingular" type="boolean" line="117"/>
                </scope>
            </method>
            <javadoc line="123">
                Constructs and returns the LU-decomposition of the given matrix.                
            </javadoc>
            <method name="lu" type="LUDecomposition" line="126">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="129">
                Inner product of two vectors; &lt;tt&gt;Sum(x[i]  y[i])&lt;/tt&gt;.
                  Also known as dot product.
                  &lt;br&gt;
                  Equivalent to &lt;tt&gt;x.zDotProduct(y)&lt;/tt&gt;.                
                <param>
                    x the first source vector.                    
                </param>
                <param>
                    y the second source matrix.                    
                </param>
                <return>
                    the inner product.                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>x.size() != y.size()</tt>.                    
                </throws>
            </javadoc>
            <method name="mult" type="double" line="139">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="142">
                Linear algebraic matrix-vector multiplication; &lt;tt&gt;z = A  y&lt;/tt&gt;.
                  &lt;tt&gt;z[i] = Sum(A[i,j]  y[j]), i=0..A.rows()-1, j=0..y.size()-1&lt;/tt&gt;.                
                <param>
                    A the source matrix.                    
                </param>
                <param>
                    y the source vector.                    
                </param>
                <return>
                    <tt>z</tt>; a new vector with <tt>z.size()==A.rows()</tt>.                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>A.columns() != y.size()</tt>.                    
                </throws>
            </javadoc>
            <method name="mult" type="DoubleMatrix1D" line="150">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="153">
                Linear algebraic matrix-matrix multiplication; &lt;tt&gt;C = A x B&lt;/tt&gt;.
                  &lt;tt&gt;C[i,j] = Sum(A[i,k]  B[k,j]), k=0..n-1&lt;/tt&gt;.
                  &lt;br&gt;
                  Matrix shapes: &lt;tt&gt;A(m x n), B(n x p), C(m x p)&lt;/tt&gt;.                
                <param>
                    A the first source matrix.                    
                </param>
                <param>
                    B the second source matrix.                    
                </param>
                <return>
                    <tt>C</tt>; a new matrix holding the results, with <tt>C.rows()=A.rows(), C.columns()==B.columns()</tt>.                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>B.rows() != A.columns()</tt>.                    
                </throws>
            </javadoc>
            <method name="mult" type="DoubleMatrix2D" line="163">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="166">
                Outer product of two vectors; Sets &lt;tt&gt;A[i,j] = x[i]  y[j]&lt;/tt&gt;.                
                <param>
                    x the first source vector.                    
                </param>
                <param>
                    y the second source vector.                    
                </param>
                <param>
                    A the matrix to hold the results. Set this parameter to <tt>null</tt> to indicate that a new result matrix shall be constructed.                    
                </param>
                <return>
                    A (for convenience only).                    
                </return>
                <throws>
                    IllegalArgumentException	if <tt>A.rows() != x.size() || A.columns() != y.size()</tt>.                    
                </throws>
            </javadoc>
            <method name="multOuter" type="DoubleMatrix2D" line="174">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="rows" type="int" line="175"/>
                <declaration name="columns" type="int" line="176"/>
            </method>
            <javadoc line="183">
                Returns the one-norm of vector &lt;tt&gt;x&lt;/tt&gt;, which is &lt;tt&gt;Sum(abs(x[i]))&lt;/tt&gt;.                
            </javadoc>
            <method name="norm1" type="double" line="186">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="190">
                Returns the one-norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum absolute column sum.                
            </javadoc>
            <method name="norm1" type="double" line="193">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="max" type="double" line="194"/>
                <scope line="195"/>
            </method>
            <javadoc line="200">
                Returns the two-norm (aka &lt;i&gt;euclidean norm&lt;/i&gt;) of vector &lt;tt&gt;x&lt;/tt&gt;; equivalent to &lt;tt&gt;mult(x,x)&lt;/tt&gt;.                
            </javadoc>
            <method name="norm2" type="double" line="203">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="206">
                Returns the two-norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum singular value; obtained from SVD.                
            </javadoc>
            <method name="norm2" type="double" line="209">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="212">
                Returns the Frobenius norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is &lt;tt&gt;Sqrt(Sum(A[i,j]&lt;sup&gt;2&lt;/sup&gt;))&lt;/tt&gt;.                
            </javadoc>
            <method name="normF" type="double" line="215">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="219">
                Returns the infinity norm of vector &lt;tt&gt;x&lt;/tt&gt;, which is &lt;tt&gt;Max(abs(x[i]))&lt;/tt&gt;.                
            </javadoc>
            <method name="normInfinity" type="double" line="222">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="226">
                Returns the infinity norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum absolute row sum.                
            </javadoc>
            <method name="normInfinity" type="double" line="229">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="max" type="double" line="230"/>
                <scope line="231"/>
            </method>
            <javadoc line="236">
                Modifies the given vector &lt;tt&gt;A&lt;/tt&gt; such that it is permuted as specified; Useful for pivoting.
                  Cell &lt;tt&gt;A[i]&lt;/tt&gt; will go into cell &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
                  [A,E,C,D,B]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[2], A[3]&lt;--A[3], A[4]&lt;--A[1].
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
                  [A,E,B,C,D]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[1], A[3]&lt;--A[2], A[4]&lt;--A[3].
                  &lt;/pre&gt;                
                <param>
                    A   the vector to permute.                    
                </param>
                <param>
                    indexes the permutation indexes, must satisfy <tt>indexes.length==A.size() && indexes[i] >= 0 && indexes[i] < A.size()</tt>;                    
                </param>
                <param>
                    work the working storage, must satisfy <tt>work.length >= A.size()</tt>; set <tt>work==null</tt> if you don't care about performance.                    
                </param>
                <return>
                    the modified <tt>A</tt> (for convenience only).                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>indexes.length != A.size()</tt>.                    
                </throws>
            </javadoc>
            <method name="permute" type="DoubleMatrix1D" line="257">
                <params>
                    <param name="A" type="DoubleMatrix1D"/>
                    <param name="indexes" type="int[]"/>
                    <param name="work" type="double[]"/>
                </params>
                <declaration name="size" type="int" line="258"/>
                <scope line="260"/>
                <scope line="263"/>
            </method>
            <javadoc line="269">
                Constructs and returns a new row and column permuted &lt;i&gt;selection view&lt;/i&gt; of matrix &lt;tt&gt;A&lt;/tt&gt;; equivalent to {@link DoubleMatrix2D#viewSelection(int[],int[])}.
                  The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
                  Use idioms like &lt;tt&gt;result = permute(...).copy()&lt;/tt&gt; to generate an independent sub matrix.                
                <return>
                    the new permuted selection view.                    
                </return>
            </javadoc>
            <method name="permute" type="DoubleMatrix2D" line="275">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="rowIndexes" type="int[]"/>
                    <param name="columnIndexes" type="int[]"/>
                </params>
            </method>
            <javadoc line="278">
                Modifies the given matrix &lt;tt&gt;A&lt;/tt&gt; such that it&apos;s columns are permuted as specified; Useful for pivoting.
                  Column &lt;tt&gt;A[i]&lt;/tt&gt; will go into column &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
                  Equivalent to &lt;tt&gt;permuteRows(transpose(A), indexes, work)&lt;/tt&gt;.                
                <param>
                    A   the matrix to permute.                    
                </param>
                <param>
                    indexes the permutation indexes, must satisfy <tt>indexes.length==A.columns() && indexes[i] >= 0 && indexes[i] < A.columns()</tt>;                    
                </param>
                <param>
                    work the working storage, must satisfy <tt>work.length >= A.columns()</tt>; set <tt>work==null</tt> if you don't care about performance.                    
                </param>
                <return>
                    the modified <tt>A</tt> (for convenience only).                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>indexes.length != A.columns()</tt>.                    
                </throws>
            </javadoc>
            <method name="permuteColumns" type="DoubleMatrix2D" line="288">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="indexes" type="int[]"/>
                    <param name="work" type="int[]"/>
                </params>
            </method>
            <javadoc line="291">
                Modifies the given matrix &lt;tt&gt;A&lt;/tt&gt; such that it&apos;s rows are permuted as specified; Useful for pivoting.
                  Row &lt;tt&gt;A[i]&lt;/tt&gt; will go into row &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
                  [A,E,C,D,B]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[2], A[3]&lt;--A[3], A[4]&lt;--A[1].
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
                  [A,E,B,C,D]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[1], A[3]&lt;--A[2], A[4]&lt;--A[3].
                  &lt;/pre&gt;                
                <param>
                    A   the matrix to permute.                    
                </param>
                <param>
                    indexes the permutation indexes, must satisfy <tt>indexes.length==A.rows() && indexes[i] >= 0 && indexes[i] < A.rows()</tt>;                    
                </param>
                <param>
                    work the working storage, must satisfy <tt>work.length >= A.rows()</tt>; set <tt>work==null</tt> if you don't care about performance.                    
                </param>
                <return>
                    the modified <tt>A</tt> (for convenience only).                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>indexes.length != A.rows()</tt>.                    
                </throws>
            </javadoc>
            <method name="permuteRows" type="DoubleMatrix2D" line="312">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="indexes" type="int[]"/>
                    <param name="work" type="int[]"/>
                </params>
                <declaration name="size" type="int" line="313"/>
                <declaration name="columns" type="int" line="315"/>
                <scope line="316">
                    <declaration name="doubleWork" type="double[]" line="317"/>
                </scope>
                <anonymous_class line="321">
                    <method name="swap" type="void" line="322">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="321"/>
            </method>
            <javadoc line="330">
                Linear algebraic matrix power; &lt;tt&gt;B = A&lt;sup&gt;k&lt;/sup&gt; &lt;==&gt; B = AA...A&lt;/tt&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;p &amp;gt;= 1: B = AA...A&lt;/tt&gt;.&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;p == 0: B = identity matrix&lt;/tt&gt;.&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;p &amp;lt;  0: B = pow(inverse(A),-p)&lt;/tt&gt;.&lt;/li&gt;
                  &lt;/ul&gt;
                  Implementation: Based on logarithms of 2, memory usage minimized.                
                <param>
                    A the source matrix; must be square; stays unaffected by this operation.                    
                </param>
                <param>
                    p the exponent, can be any number.                    
                </param>
                <return>
                    <tt>B</tt>, a newly constructed result matrix; storage-independent of <tt>A</tt>.                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>!property().isSquare(A)</tt>.                    
                </throws>
            </javadoc>
            <method name="pow" type="DoubleMatrix2D" line="343">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="p" type="int"/>
                </params>
                <declaration name="blas" type="Blas" line="344"/>
                <scope line="346"/>
                <declaration name="T" type="DoubleMatrix2D" line="351"/>
                <scope line="353"/>
                <declaration name="k" type="int" line="357"/>
                <declaration name="i" type="int" line="358"/>
                <scope line="359">
                    <declaration name="swap" type="DoubleMatrix2D" line="361"/>
                </scope>
                <declaration name="B" type="DoubleMatrix2D" line="366"/>
                <scope line="368">
                    <declaration name="swap" type="DoubleMatrix2D" line="370"/>
                    <scope line="373"/>
                </scope>
            </method>
            <javadoc line="382">
                Returns the property object attached to this Algebra, defining tolerance.                
                <return>
                    the Property object.                    
                </return>
                <see>
                    #setProperty(Property)                    
                </see>
            </javadoc>
            <method name="property" type="Property" line="387"/>
            <javadoc line="390">
                Constructs and returns the QR-decomposition of the given matrix.                
            </javadoc>
            <method name="qr" type="QRDecomposition" line="393">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="396">
                Returns the effective numerical rank of matrix &lt;tt&gt;A&lt;/tt&gt;, obtained from Singular Value Decomposition.                
            </javadoc>
            <method name="rank" type="int" line="399">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="402">
                Attaches the given property object to this Algebra, defining tolerance.                
                <param>
                    the Property object to be attached.                    
                </param>
                <throws>
                    UnsupportedOperationException if <tt>this==DEFAULT && property!=this.property()</tt> - The DEFAULT Algebra object is immutable.                    
                </throws>
                <throws>
                    UnsupportedOperationException if <tt>this==ZERO && property!=this.property()</tt> - The ZERO Algebra object is immutable.                    
                </throws>
                <see>
                    #property                    
                </see>
            </javadoc>
            <method name="setProperty" type="void" line="409">
                <params>
                    <param name="property" type="Property"/>
                </params>
            </method>
            <javadoc line="414">
                Solves AX = B.                
                <return>
                    X; a new independent matrix; solution if A is square, least squares solution otherwise.                    
                </return>
            </javadoc>
            <method name="solve" type="DoubleMatrix2D" line="418">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="421">
                Solves XA = B, which is also A&apos;X&apos; = B&apos;.                
                <return>
                    X; a new independent matrix; solution if A is square, least squares solution otherwise.                    
                </return>
            </javadoc>
            <method name="solveTranspose" type="DoubleMatrix2D" line="425">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="428">
                Copies the columns of the indicated rows into a new sub matrix.
                  &lt;tt&gt;sub[0..rowIndexes.length-1,0..columnTo-columnFrom] = A[rowIndexes(:),columnFrom..columnTo]&lt;/tt&gt;;
                  The returned matrix is &lt;i&gt;not backed&lt;/i&gt; by this matrix, so changes in the returned matrix are &lt;i&gt;not reflected&lt;/i&gt; in this matrix, and vice-versa.                
                <param>
                    A   the source matrix to copy from.                    
                </param>
                <param>
                    rowIndexes the indexes of the rows to copy. May be unsorted.                    
                </param>
                <param>
                    columnFrom the index of the first column to copy (inclusive).                    
                </param>
                <param>
                    columnTo the index of the last column to copy (inclusive).                    
                </param>
                <return>
                    a new sub matrix; with <tt>sub.rows()==rowIndexes.length; sub.columns()==columnTo-columnFrom+1</tt>.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>columnFrom<0 || columnTo-columnFrom+1<0 || columnTo+1>matrix.columns() || for any row=rowIndexes[i]: row < 0 || row >= matrix.rows()</tt>.                    
                </throws>
            </javadoc>
            <method name="subMatrix" type="DoubleMatrix2D" line="439">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="rowIndexes" type="int[]"/>
                    <param name="columnFrom" type="int"/>
                    <param name="columnTo" type="int"/>
                </params>
                <declaration name="width" type="int" line="440"/>
                <declaration name="rows" type="int" line="441"/>
                <declaration name="sub" type="DoubleMatrix2D" line="443"/>
                <scope line="444">
                    <declaration name="row" type="int" line="445"/>
                </scope>
            </method>
            <javadoc line="451">
                Copies the rows of the indicated columns into a new sub matrix.
                  &lt;tt&gt;sub[0..rowTo-rowFrom,0..columnIndexes.length-1] = A[rowFrom..rowTo,columnIndexes(:)]&lt;/tt&gt;;
                  The returned matrix is &lt;i&gt;not backed&lt;/i&gt; by this matrix, so changes in the returned matrix are &lt;i&gt;not reflected&lt;/i&gt; in this matrix, and vice-versa.                
                <param>
                    A   the source matrix to copy from.                    
                </param>
                <param>
                    rowFrom the index of the first row to copy (inclusive).                    
                </param>
                <param>
                    rowTo the index of the last row to copy (inclusive).                    
                </param>
                <param>
                    columnIndexes the indexes of the columns to copy. May be unsorted.                    
                </param>
                <return>
                    a new sub matrix; with <tt>sub.rows()==rowTo-rowFrom+1; sub.columns()==columnIndexes.length</tt>.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>rowFrom<0 || rowTo-rowFrom+1<0 || rowTo+1>matrix.rows() || for any col=columnIndexes[i]: col < 0 || col >= matrix.columns()</tt>.                    
                </throws>
            </javadoc>
            <method name="subMatrix" type="DoubleMatrix2D" line="462">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="rowFrom" type="int"/>
                    <param name="rowTo" type="int"/>
                    <param name="columnIndexes" type="int[]"/>
                </params>
                <declaration name="height" type="int" line="464"/>
                <declaration name="columns" type="int" line="465"/>
                <declaration name="sub" type="DoubleMatrix2D" line="467"/>
                <scope line="468">
                    <declaration name="column" type="int" line="469"/>
                </scope>
            </method>
            <javadoc line="475">
                Constructs and returns a new &lt;i&gt;sub-range view&lt;/i&gt; which is the sub matrix &lt;tt&gt;A[fromRow..toRow,fromColumn..toColumn]&lt;/tt&gt;.
                  The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
                  Use idioms like &lt;tt&gt;result = subMatrix(...).copy()&lt;/tt&gt; to generate an independent sub matrix.                
                <param>
                    A the source matrix.                    
                </param>
                <param>
                    fromRow   The index of the first row (inclusive).                    
                </param>
                <param>
                    toRow   The index of the last row (inclusive).                    
                </param>
                <param>
                    fromColumn   The index of the first column (inclusive).                    
                </param>
                <param>
                    toColumn   The index of the last column (inclusive).                    
                </param>
                <return>
                    a new sub-range view.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <tt>fromColumn<0 || toColumn-fromColumn+1<0 || toColumn>=A.columns() || fromRow<0 || toRow-fromRow+1<0 || toRow>=A.rows()</tt>                    
                </throws>
            </javadoc>
            <method name="subMatrix" type="DoubleMatrix2D" line="487">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="fromRow" type="int"/>
                    <param name="toRow" type="int"/>
                    <param name="fromColumn" type="int"/>
                    <param name="toColumn" type="int"/>
                </params>
            </method>
            <javadoc line="490">
                Constructs and returns the SingularValue-decomposition of the given matrix.                
            </javadoc>
            <method name="svd" type="SingularValueDecomposition" line="493">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="496">
                Returns a String with (propertyName, propertyValue) pairs.
                  Useful for debugging or to quickly get the rough picture.
                  For example,
                  &lt;pre&gt;
                  cond          : 14.073264490042144
                  det           : Illegal operation or error: Matrix must be square.
                  norm1         : 0.9620244354009628
                  norm2         : 3.0
                  normF         : 1.304841791648992
                  normInfinity  : 1.5406551198102534
                  rank          : 3
                  trace         : 0
                  &lt;/pre&gt;                
            </javadoc>
            <method name="toString" type="String" line="511">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
                <declaration name="names" type="cern.colt.list.ObjectArrayList" line="512"/>
                <declaration name="values" type="cern.colt.list.ObjectArrayList" line="513"/>
                <declaration name="unknown" type="String" line="514"/>
                <scope line="516"/>
                <scope line="519"/>
                <scope line="523"/>
                <scope line="526"/>
                <scope line="530"/>
                <scope line="533"/>
                <scope line="537"/>
                <scope line="540"/>
                <scope line="544"/>
                <scope line="547"/>
                <scope line="551"/>
                <scope line="554"/>
                <scope line="558"/>
                <scope line="561"/>
                <scope line="565"/>
                <scope line="568"/>
                <anonymous_class line="571">
                    <method name="compare" type="int" line="572">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.IntComparator" line="571"/>
                <anonymous_class line="577">
                    <method name="swap" type="void" line="578">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="tmp" type="Object" line="579"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="577"/>
                <declaration name="maxLength" type="int" line="590"/>
                <scope line="591">
                    <declaration name="length" type="int" line="592"/>
                </scope>
                <declaration name="buf" type="StringBuffer" line="595"/>
                <scope line="596">
                    <declaration name="name" type="String" line="597"/>
                </scope>
            </method>
            <javadoc line="606">
                Returns the results of &lt;tt&gt;toString(A)&lt;/tt&gt; and additionally the results of all sorts of decompositions applied to the given matrix.
                  Useful for debugging or to quickly get the rough picture.
                  For example,
                  &lt;pre&gt;
                  A = 3 x 3 matrix
                  249  66  68
                  104 214 108
                  144 146 293
                  cond         : 3.931600417472078
                  det          : 9638870.0
                  norm1        : 497.0
                  norm2        : 473.34508217011404
                  normF        : 516.873292016525
                  normInfinity : 583.0
                  rank         : 3
                  trace        : 756.0
                  density                      : 1.0
                  isDiagonal                   : false
                  isDiagonallyDominantByColumn : true
                  isDiagonallyDominantByRow    : true
                  isIdentity                   : false
                  isLowerBidiagonal            : false
                  isLowerTriangular            : false
                  isNonNegative                : true
                  isOrthogonal                 : false
                  isPositive                   : true
                  isSingular                   : false
                  isSkewSymmetric              : false
                  isSquare                     : true
                  isStrictlyLowerTriangular    : false
                  isStrictlyTriangular         : false
                  isStrictlyUpperTriangular    : false
                  isSymmetric                  : false
                  isTriangular                 : false
                  isTridiagonal                : false
                  isUnitTriangular             : false
                  isUpperBidiagonal            : false
                  isUpperTriangular            : false
                  isZero                       : false
                  lowerBandwidth               : 2
                  semiBandwidth                : 3
                  upperBandwidth               : 2
                  -----------------------------------------------------------------------------
                  LUDecompositionQuick(A) --&gt; isNonSingular(A), det(A), pivot, L, U, inverse(A)
                  -----------------------------------------------------------------------------
                  isNonSingular = true
                  det = 9638870.0
                  pivot = [0, 1, 2]
                  L = 3 x 3 matrix
                  1        0       0
                  0.417671 1       0
                  0.578313 0.57839 1
                  U = 3 x 3 matrix
                  249  66         68       
                  0 186.433735  79.598394
                  0   0        207.635819
                  inverse(A) = 3 x 3 matrix
                  0.004869 -0.000976 -0.00077 
                  -0.001548  0.006553 -0.002056
                  -0.001622 -0.002786  0.004816
                  -----------------------------------------------------------------
                  QRDecomposition(A) --&gt; hasFullRank(A), H, Q, R, pseudo inverse(A)
                  -----------------------------------------------------------------
                  hasFullRank = true
                  H = 3 x 3 matrix
                  1.814086 0        0
                  0.34002  1.903675 0
                  0.470797 0.428218 2
                  Q = 3 x 3 matrix
                  -0.814086  0.508871  0.279845
                  -0.34002  -0.808296  0.48067 
                  -0.470797 -0.296154 -0.831049
                  R = 3 x 3 matrix
                  -305.864349 -195.230337 -230.023539
                  0        -182.628353  467.703164
                  0           0        -309.13388 
                  pseudo inverse(A) = 3 x 3 matrix
                  0.006601  0.001998 -0.005912
                  -0.005105  0.000444  0.008506
                  -0.000905 -0.001555  0.002688
                  --------------------------------------------------------------------------
                  CholeskyDecomposition(A) --&gt; isSymmetricPositiveDefinite(A), L, inverse(A)
                  --------------------------------------------------------------------------
                  isSymmetricPositiveDefinite = false
                  L = 3 x 3 matrix
                  15.779734  0         0       
                  6.590732 13.059948  0       
                  9.125629  6.573948 12.903724
                  inverse(A) = Illegal operation or error: Matrix is not symmetric positive definite.
                  ---------------------------------------------------------------------
                  EigenvalueDecomposition(A) --&gt; D, V, realEigenvalues, imagEigenvalues
                  ---------------------------------------------------------------------
                  realEigenvalues = 1 x 3 matrix
                  462.796507 172.382058 120.821435
                  imagEigenvalues = 1 x 3 matrix
                  0 0 0
                  D = 3 x 3 matrix
                  462.796507   0          0       
                  0        172.382058   0       
                  0          0        120.821435
                  V = 3 x 3 matrix
                  -0.398877 -0.778282  0.094294
                  -0.500327  0.217793 -0.806319
                  -0.768485  0.66553   0.604862
                  ---------------------------------------------------------------------
                  SingularValueDecomposition(A) --&gt; cond(A), rank(A), norm2(A), U, S, V
                  ---------------------------------------------------------------------
                  cond = 3.931600417472078
                  rank = 3
                  norm2 = 473.34508217011404
                  U = 3 x 3 matrix
                  0.46657  -0.877519  0.110777
                  0.50486   0.161382 -0.847982
                  0.726243  0.45157   0.51832 
                  S = 3 x 3 matrix
                  473.345082   0          0       
                  0        169.137441   0       
                  0          0        120.395013
                  V = 3 x 3 matrix
                  0.577296 -0.808174  0.116546
                  0.517308  0.251562 -0.817991
                  0.631761  0.532513  0.563301
                  &lt;/pre&gt;                
            </javadoc>
            <method name="toVerboseString" type="String" line="731">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
                <declaration name="constructionException" type="String" line="732"/>
                <declaration name="buf" type="StringBuffer" line="733"/>
                <declaration name="lu" type="LUDecomposition" line="738"/>
                <scope line="739"/>
                <scope line="742"/>
                <declaration name="qr" type="QRDecomposition" line="746"/>
                <scope line="747"/>
                <scope line="750"/>
                <declaration name="chol" type="CholeskyDecomposition" line="754"/>
                <scope line="755"/>
                <scope line="758"/>
                <declaration name="eig" type="EigenvalueDecomposition" line="762"/>
                <scope line="763"/>
                <scope line="766"/>
                <declaration name="svd" type="SingularValueDecomposition" line="770"/>
                <scope line="771"/>
                <scope line="774"/>
            </method>
            <javadoc line="780">
                Returns the sum of the diagonal elements of matrix &lt;tt&gt;A&lt;/tt&gt;; &lt;tt&gt;Sum(A[i,i])&lt;/tt&gt;.                
            </javadoc>
            <method name="trace" type="double" line="783">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="sum" type="double" line="784"/>
                <scope line="785"/>
            </method>
            <javadoc line="790">
                Constructs and returns a new view which is the transposition of the given matrix &lt;tt&gt;A&lt;/tt&gt;.
                  Equivalent to {@link DoubleMatrix2D#viewDice A.viewDice()}.
                  This is a zero-copy transposition, taking O(1), i.e. constant time.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
                  Use idioms like &lt;tt&gt;result = transpose(A).copy()&lt;/tt&gt; to generate an independent matrix.
                  &lt;p&gt; 
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                  1, 2, 3&lt;br&gt;
                  4, 5, 6 &lt;/td&gt;
                  &lt;td&gt;transpose ==&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;3 x 2 matrix:&lt;br&gt;
                  1, 4 &lt;br&gt;
                  2, 5 &lt;br&gt;
                  3, 6&lt;/td&gt;
                  &lt;td&gt;transpose ==&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                  1, 2, 3&lt;br&gt;
                  4, 5, 6 &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <return>
                    a new transposed view.                    
                </return>
            </javadoc>
            <method name="transpose" type="DoubleMatrix2D" line="816">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="819">
                Modifies the matrix to be a lower trapezoidal matrix.                
                <return>
                    <tt>A</tt> (for convenience only).                    
                </return>
                <see>
                    #triangulateLower(DoubleMatrix2D)                    
                </see>
            </javadoc>
            <method name="trapezoidalLower" type="DoubleMatrix2D" line="824">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="rows" type="int" line="825"/>
                <declaration name="columns" type="int" line="826"/>
                <scope line="827">
                    <scope line="828"/>
                </scope>
            </method>
            <javadoc line="834">
                Outer product of two vectors; Returns a matrix with &lt;tt&gt;A[i,j] = x[i]  y[j]&lt;/tt&gt;.                
                <param>
                    x the first source vector.                    
                </param>
                <param>
                    y the second source vector.                    
                </param>
                <return>
                    the outer product </tt>A</tt>.                    
                </return>
            </javadoc>
            <method name="xmultOuter" type="DoubleMatrix2D" line="840">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
                <declaration name="A" type="DoubleMatrix2D" line="841"/>
            </method>
            <javadoc line="845">
                Linear algebraic matrix power; &lt;tt&gt;B = A&lt;sup&gt;k&lt;/sup&gt; &lt;==&gt; B = AA...A&lt;/tt&gt;.                
                <param>
                    A the source matrix; must be square.                    
                </param>
                <param>
                    k the exponent, can be any number.                    
                </param>
                <return>
                    a new result matrix.                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>!Testing.isSquare(A)</tt>.                    
                </throws>
            </javadoc>
            <method name="xpowSlow" type="DoubleMatrix2D" line="852">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="k" type="int"/>
                </params>
                <declaration name="result" type="DoubleMatrix2D" line="853"/>
                <scope line="854"/>
            </method>
        </class>
    </source>