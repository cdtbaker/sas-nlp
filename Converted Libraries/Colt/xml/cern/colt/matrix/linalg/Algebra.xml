<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.linalg">
        <import package="cern.colt.matrix.DoubleFactory2D"/>
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="Algebra" line="14">
            <extends class="cern.colt.PersistentObject"/>
            <javadoc line="14">
                Linear algebraic matrix operations operating on {@link DoubleMatrix2D}; concentrates most functionality of this package.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <declaration name="DEFAULT" type="Algebra" line="21"/>
            <javadoc line="21">
                A default Algebra object; has {@link Property#DEFAULT} attached for tolerance. 
                  Allows ommiting to construct an Algebra object time and again.
                  Note that this Algebra object is immutable.
                  Any attempt to assign a new Property object to it (via method &lt;tt&gt;setProperty&lt;/tt&gt;), or to alter the tolerance of its property object (via &lt;tt&gt;property().setTolerance(...)&lt;/tt&gt;) will throw an exception.                
            </javadoc>
            <declaration name="ZERO" type="Algebra" line="30"/>
            <javadoc line="30">
                A default Algebra object; has {@link Property#ZERO} attached for tolerance. 
                  Allows ommiting to construct an Algebra object time and again.
                  Note that this Algebra object is immutable.
                  Any attempt to assign a new Property object to it (via method &lt;tt&gt;setProperty&lt;/tt&gt;), or to alter the tolerance of its property object (via &lt;tt&gt;property().setTolerance(...)&lt;/tt&gt;) will throw an exception.                
            </javadoc>
            <declaration name="property" type="Property" line="39"/>
            <javadoc line="39">
                The property object attached to this instance.                
            </javadoc>
            <scope line="44"/>
            <javadoc line="52">
                Constructs a new instance with an equality tolerance given by &lt;tt&gt;Property.DEFAULT.tolerance()&lt;/tt&gt;.                
            </javadoc>
            <method name="Algebra" type="constructor" line="55"/>
            <javadoc line="58">
                Constructs a new instance with the given equality tolerance.                
                <param>
                    tolerance the tolerance to be used for equality operations.                    
                </param>
            </javadoc>
            <method name="Algebra" type="constructor" line="62">
                <params>
                    <param name="tolerance" type="double"/>
                </params>
            </method>
            <javadoc line="65">
                Constructs and returns the cholesky-decomposition of the given matrix.                
            </javadoc>
            <method name="chol" type="CholeskyDecomposition" line="68">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="71">
                Returns a copy of the receiver.
                  The attached property object is also copied. Hence, the property object of the copy is mutable.                
                <return>
                    a copy of the receiver.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="77"/>
            <javadoc line="80">
                Returns the condition of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the ratio of largest to smallest singular value.                
            </javadoc>
            <method name="cond" type="double" line="83">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="86">
                Returns the determinant of matrix &lt;tt&gt;A&lt;/tt&gt;.                
                <return>
                    the determinant.                    
                </return>
            </javadoc>
            <method name="det" type="double" line="90">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="93">
                Constructs and returns the Eigenvalue-decomposition of the given matrix.                
            </javadoc>
            <method name="eig" type="EigenvalueDecomposition" line="96">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="99">
                Returns sqrt(a^2 + b^2) without under/overflow.                
            </javadoc>
            <method name="hypot" type="double" line="102">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
                <declaration name="r" type="double" line="103"/>
                <scope line="104"/>
                <scope line="107"/>
                <scope line="110"/>
            </method>
            <javadoc line="115">
                Returns sqrt(a^2 + b^2) without under/overflow.                
            </javadoc>
            <method name="hypotFunction" type="cern.colt.function.DoubleDoubleFunction" line="118">
                <anonymous_class line="119">
                    <method name="apply" type="double" line="120">
                        <params>
                            <param name="a" type="double"/>
                            <param name="b" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="125">
                Returns the inverse or pseudo-inverse of matrix &lt;tt&gt;A&lt;/tt&gt;.                
                <return>
                    a new independent matrix; inverse(matrix) if the matrix is square, pseudoinverse otherwise.                    
                </return>
            </javadoc>
            <method name="inverse" type="DoubleMatrix2D" line="129">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <scope line="130">
                    <declaration name="inv" type="DoubleMatrix2D" line="131"/>
                    <declaration name="isNonSingular" type="boolean" line="132"/>
                </scope>
            </method>
            <javadoc line="138">
                Constructs and returns the LU-decomposition of the given matrix.                
            </javadoc>
            <method name="lu" type="LUDecomposition" line="141">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="144">
                Inner product of two vectors; &lt;tt&gt;Sum(x[i]  y[i])&lt;/tt&gt;.
                  Also known as dot product.
                  &lt;br&gt;
                  Equivalent to &lt;tt&gt;x.zDotProduct(y)&lt;/tt&gt;.                
                <param>
                    x the first source vector.                    
                </param>
                <param>
                    y the second source matrix.                    
                </param>
                <return>
                    the inner product.                    
                </return>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;x.size() != y.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="mult" type="double" line="156">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="159">
                Linear algebraic matrix-vector multiplication; &lt;tt&gt;z = A  y&lt;/tt&gt;.
                  &lt;tt&gt;z[i] = Sum(A[i,j]  y[j]), i=0..A.rows()-1, j=0..y.size()-1&lt;/tt&gt;.                
                <param>
                    A the source matrix.                    
                </param>
                <param>
                    y the source vector.                    
                </param>
                <return>
                    &lt;tt&gt;z&lt;/tt&gt;; a new vector with &lt;tt&gt;z.size()==A.rows()&lt;/tt&gt;.                    
                </return>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;A.columns() != y.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="mult" type="DoubleMatrix1D" line="168">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="171">
                Linear algebraic matrix-matrix multiplication; &lt;tt&gt;C = A x B&lt;/tt&gt;.
                  &lt;tt&gt;C[i,j] = Sum(A[i,k]  B[k,j]), k=0..n-1&lt;/tt&gt;.
                  &lt;br&gt;
                  Matrix shapes: &lt;tt&gt;A(m x n), B(n x p), C(m x p)&lt;/tt&gt;.                
                <param>
                    A the first source matrix.                    
                </param>
                <param>
                    B the second source matrix.                    
                </param>
                <return>
                    &lt;tt&gt;C&lt;/tt&gt;; a new matrix holding the results, with &lt;tt&gt;C.rows()=A.rows(), C.columns()==B.columns()&lt;/tt&gt;.                    
                </return>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;B.rows() != A.columns()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="mult" type="DoubleMatrix2D" line="183">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="186">
                Outer product of two vectors; Sets &lt;tt&gt;A[i,j] = x[i]  y[j]&lt;/tt&gt;.                
                <param>
                    x the first source vector.                    
                </param>
                <param>
                    y the second source vector.                    
                </param>
                <param>
                    A the matrix to hold the results. Set this parameter to &lt;tt&gt;null&lt;/tt&gt; to indicate that a new result matrix shall be constructed.                    
                </param>
                <return>
                    A (for convenience only).                    
                </return>
                <throws>
                    IllegalArgumentException	if &lt;tt&gt;A.rows() != x.size() || A.columns() != y.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="multOuter" type="DoubleMatrix2D" line="195">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="rows" type="int" line="196"/>
                <declaration name="columns" type="int" line="197"/>
            </method>
            <javadoc line="206">
                Returns the one-norm of vector &lt;tt&gt;x&lt;/tt&gt;, which is &lt;tt&gt;Sum(abs(x[i]))&lt;/tt&gt;.                
            </javadoc>
            <method name="norm1" type="double" line="209">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="213">
                Returns the one-norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum absolute column sum.                
            </javadoc>
            <method name="norm1" type="double" line="216">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="max" type="double" line="217"/>
                <scope line="218"/>
            </method>
            <javadoc line="223">
                Returns the two-norm (aka &lt;i&gt;euclidean norm&lt;/i&gt;) of vector &lt;tt&gt;x&lt;/tt&gt;; equivalent to &lt;tt&gt;mult(x,x)&lt;/tt&gt;.                
            </javadoc>
            <method name="norm2" type="double" line="226">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                </params>
            </method>
            <javadoc line="229">
                Returns the two-norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum singular value; obtained from SVD.                
            </javadoc>
            <method name="norm2" type="double" line="232">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="235">
                Returns the Frobenius norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is &lt;tt&gt;Sqrt(Sum(A[i,j]&lt;sup&gt;2&lt;/sup&gt;))&lt;/tt&gt;.                
            </javadoc>
            <method name="normF" type="double" line="238">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="242">
                Returns the infinity norm of vector &lt;tt&gt;x&lt;/tt&gt;, which is &lt;tt&gt;Max(abs(x[i]))&lt;/tt&gt;.                
            </javadoc>
            <method name="normInfinity" type="double" line="245">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                </params>
                <comment line="247">
                    fix for bug reported by T.J.Hunt@open.ac.uk                    
                </comment>
                <comment line="250">
                    if (x.size()==0) return 0;
                    	return x.aggregate(cern.jet.math.Functions.plus,cern.jet.math.Functions.abs);
                    	double max = 0;
                    	for (int i = x.size(); --i &gt;= 0; ) {
                    		max = Math.max(max, x.getQuick(i));
                    	}
                    	return max;                    
                </comment>
            </method>
            <javadoc line="257">
                Returns the infinity norm of matrix &lt;tt&gt;A&lt;/tt&gt;, which is the maximum absolute row sum.                
            </javadoc>
            <method name="normInfinity" type="double" line="260">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <comment line="264">
                    max = Math.max(max, normInfinity(A.viewRow(row)));                    
                </comment>
                <declaration name="max" type="double" line="261"/>
                <scope line="262"/>
            </method>
            <javadoc line="268">
                Modifies the given vector &lt;tt&gt;A&lt;/tt&gt; such that it is permuted as specified; Useful for pivoting.
                  Cell &lt;tt&gt;A[i]&lt;/tt&gt; will go into cell &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
                  [A,E,C,D,B]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[2], A[3]&lt;--A[3], A[4]&lt;--A[1].
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
                  [A,E,B,C,D]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[1], A[3]&lt;--A[2], A[4]&lt;--A[3].
                  &lt;/pre&gt;                
                <param>
                    A   the vector to permute.                    
                </param>
                <param>
                    indexes the permutation indexes, must satisfy &lt;tt&gt;indexes.length==A.size() &amp;&amp; indexes[i] &gt;= 0 &amp;&amp; indexes[i] &lt; A.size()&lt;/tt&gt;;                    
                </param>
                <param>
                    work the working storage, must satisfy &lt;tt&gt;work.length &gt;= A.size()&lt;/tt&gt;; set &lt;tt&gt;work==null&lt;/tt&gt; if you don&apos;t care about performance.                    
                </param>
                <return>
                    the modified &lt;tt&gt;A&lt;/tt&gt; (for convenience only).                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;indexes.length != A.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="permute" type="DoubleMatrix1D" line="291">
                <params>
                    <param name="A" type="DoubleMatrix1D"/>
                    <param name="indexes" type="int[]"/>
                    <param name="work" type="double[]"/>
                </params>
                <comment line="293">
                    check validity                    
                </comment>
                <comment line="297">
                    int i=size;
                    int a;
                    while (--i &gt;= 0 &amp;&amp; (a=indexes[i])==i) if (a &lt; 0 || a &gt;= size) throw new IndexOutOfBoundsException(&quot;invalid permutation&quot;);
                    if (i&lt;0) return;  nothing to permute                    
                </comment>
                <declaration name="size" type="int" line="293"/>
                <scope line="303"/>
                <scope line="306"/>
            </method>
            <javadoc line="312">
                Constructs and returns a new row and column permuted &lt;i&gt;selection view&lt;/i&gt; of matrix &lt;tt&gt;A&lt;/tt&gt;; equivalent to {@link DoubleMatrix2D#viewSelection(int[],int[])}.
                  The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
                  Use idioms like &lt;tt&gt;result = permute(...).copy()&lt;/tt&gt; to generate an independent sub matrix.                
                <return>
                    the new permuted selection view.                    
                </return>
            </javadoc>
            <method name="permute" type="DoubleMatrix2D" line="318">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="rowIndexes" type="int[]"/>
                    <param name="columnIndexes" type="int[]"/>
                </params>
            </method>
            <javadoc line="321">
                Modifies the given matrix &lt;tt&gt;A&lt;/tt&gt; such that it&apos;s columns are permuted as specified; Useful for pivoting.
                  Column &lt;tt&gt;A[i]&lt;/tt&gt; will go into column &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
                  Equivalent to &lt;tt&gt;permuteRows(transpose(A), indexes, work)&lt;/tt&gt;.                
                <param>
                    A   the matrix to permute.                    
                </param>
                <param>
                    indexes the permutation indexes, must satisfy &lt;tt&gt;indexes.length==A.columns() &amp;&amp; indexes[i] &gt;= 0 &amp;&amp; indexes[i] &lt; A.columns()&lt;/tt&gt;;                    
                </param>
                <param>
                    work the working storage, must satisfy &lt;tt&gt;work.length &gt;= A.columns()&lt;/tt&gt;; set &lt;tt&gt;work==null&lt;/tt&gt; if you don&apos;t care about performance.                    
                </param>
                <return>
                    the modified &lt;tt&gt;A&lt;/tt&gt; (for convenience only).                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;indexes.length != A.columns()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="permuteColumns" type="DoubleMatrix2D" line="331">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="indexes" type="int[]"/>
                    <param name="work" type="int[]"/>
                </params>
            </method>
            <javadoc line="334">
                Modifies the given matrix &lt;tt&gt;A&lt;/tt&gt; such that it&apos;s rows are permuted as specified; Useful for pivoting.
                  Row &lt;tt&gt;A[i]&lt;/tt&gt; will go into row &lt;tt&gt;A[indexes[i]]&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;pre&gt;
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,2,3,1] yields 
                  [A,E,C,D,B]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[2], A[3]&lt;--A[3], A[4]&lt;--A[1].
                  Reordering
                  [A,B,C,D,E] with indexes [0,4,1,2,3] yields 
                  [A,E,B,C,D]
                  In other words A[0]&lt;--A[0], A[1]&lt;--A[4], A[2]&lt;--A[1], A[3]&lt;--A[2], A[4]&lt;--A[3].
                  &lt;/pre&gt;                
                <param>
                    A   the matrix to permute.                    
                </param>
                <param>
                    indexes the permutation indexes, must satisfy &lt;tt&gt;indexes.length==A.rows() &amp;&amp; indexes[i] &gt;= 0 &amp;&amp; indexes[i] &lt; A.rows()&lt;/tt&gt;;                    
                </param>
                <param>
                    work the working storage, must satisfy &lt;tt&gt;work.length &gt;= A.rows()&lt;/tt&gt;; set &lt;tt&gt;work==null&lt;/tt&gt; if you don&apos;t care about performance.                    
                </param>
                <return>
                    the modified &lt;tt&gt;A&lt;/tt&gt; (for convenience only).                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;indexes.length != A.rows()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="permuteRows" type="DoubleMatrix2D" line="357">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="indexes" type="int[]"/>
                    <param name="work" type="int[]"/>
                </params>
                <comment line="359">
                    check validity                    
                </comment>
                <comment line="363">
                    int i=size;
                    int a;
                    while (--i &gt;= 0 &amp;&amp; (a=indexes[i])==i) if (a &lt; 0 || a &gt;= size) throw new IndexOutOfBoundsException(&quot;invalid permutation&quot;);
                    if (i&lt;0) return;  nothing to permute                    
                </comment>
                <comment line="371">
                    quicker                    
                </comment>
                <declaration name="size" type="int" line="359"/>
                <declaration name="columns" type="int" line="369"/>
                <scope line="370">
                    <declaration name="doubleWork" type="double[]" line="371"/>
                </scope>
                <anonymous_class line="376">
                    <method name="swap" type="void" line="377">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="376"/>
            </method>
            <javadoc line="385">
                Linear algebraic matrix power; &lt;tt&gt;B = A&lt;sup&gt;k&lt;/sup&gt; &lt;==&gt; B = AA...A&lt;/tt&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;p &amp;gt;= 1: B = AA...A&lt;/tt&gt;.&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;p == 0: B = identity matrix&lt;/tt&gt;.&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;p &amp;lt;  0: B = pow(inverse(A),-p)&lt;/tt&gt;.&lt;/li&gt;
                  &lt;/ul&gt;
                  Implementation: Based on logarithms of 2, memory usage minimized.                
                <param>
                    A the source matrix; must be square; stays unaffected by this operation.                    
                </param>
                <param>
                    p the exponent, can be any number.                    
                </param>
                <return>
                    &lt;tt&gt;B&lt;/tt&gt;, a newly constructed result matrix; storage-independent of &lt;tt&gt;A&lt;/tt&gt;.                    
                </return>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;!property().isSquare(A)&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="pow" type="DoubleMatrix2D" line="399">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="p" type="int"/>
                </params>
                <comment line="401">
                    matrix multiplication based on log2 method: A*A*....*A is slow, ((A * A)^2)^2 * ... is faster
                     allocates two auxiliary matrices as work space                    
                </comment>
                <comment line="404">
                    for parallel matrix mult; if not initialized defaults to sequential blas                    
                </comment>
                <comment line="411">
                    temporary                    
                </comment>
                <comment line="412">
                    safes one auxiliary matrix allocation                    
                </comment>
                <comment line="414">
                    mult(A,A); // safes one auxiliary matrix allocation                    
                </comment>
                <comment line="418">
                    index of highest bit in state &quot;true&quot;                    
                </comment>
                <comment line="420">
                    this is the naive version:
                    DoubleMatrix2D B = A.copy();
                    for (int i=0; i&lt;p-1; i++) {
                    B = mult(B,A);
                    }
                    return B;                    
                </comment>
                <comment line="429">
                    here comes the optimized version:
                    cern.colt.Timer timer = new cern.colt.Timer().start();                    
                </comment>
                <comment line="433">
                    while (bit i of p == false)                    
                </comment>
                <comment line="434">
                    A = mult(A,A); would allocate a lot of temporary memory                    
                </comment>
                <comment line="435">
                    A.zMult(A,T);                    
                </comment>
                <comment line="436">
                    swap A with T                    
                </comment>
                <comment line="443">
                    A = mult(A,A); would allocate a lot of temporary memory                    
                </comment>
                <comment line="444">
                    A.zMult(A,T);                    
                </comment>
                <comment line="445">
                    swap A with T                    
                </comment>
                <comment line="447">
                    if (bit i of p == true)                    
                </comment>
                <comment line="448">
                    B = mult(B,A); would allocate a lot of temporary memory                    
                </comment>
                <comment line="449">
                    B.zMult(A,T);                    
                </comment>
                <comment line="450">
                    swap B with T                    
                </comment>
                <comment line="453">
                    timer.stop().display();                    
                </comment>
                <declaration name="blas" type="Blas" line="403"/>
                <scope line="405"/>
                <declaration name="T" type="DoubleMatrix2D" line="410"/>
                <scope line="412"/>
                <declaration name="k" type="int" line="417"/>
                <declaration name="i" type="int" line="431"/>
                <scope line="432">
                    <declaration name="swap" type="DoubleMatrix2D" line="435"/>
                </scope>
                <declaration name="B" type="DoubleMatrix2D" line="439"/>
                <scope line="441">
                    <declaration name="swap" type="DoubleMatrix2D" line="444"/>
                    <scope line="446"/>
                </scope>
            </method>
            <javadoc line="455">
                Returns the property object attached to this Algebra, defining tolerance.                
                <return>
                    the Property object.                    
                </return>
                <see>
                    #setProperty(Property)                    
                </see>
            </javadoc>
            <method name="property" type="Property" line="460"/>
            <javadoc line="463">
                Constructs and returns the QR-decomposition of the given matrix.                
            </javadoc>
            <method name="qr" type="QRDecomposition" line="466">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="469">
                Returns the effective numerical rank of matrix &lt;tt&gt;A&lt;/tt&gt;, obtained from Singular Value Decomposition.                
            </javadoc>
            <method name="rank" type="int" line="472">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="475">
                Attaches the given property object to this Algebra, defining tolerance.                
                <param>
                    the Property object to be attached.                    
                </param>
                <throws>
                    UnsupportedOperationException if &lt;tt&gt;this==DEFAULT &amp;&amp; property!=this.property()&lt;/tt&gt; - The DEFAULT Algebra object is immutable.                    
                </throws>
                <throws>
                    UnsupportedOperationException if &lt;tt&gt;this==ZERO &amp;&amp; property!=this.property()&lt;/tt&gt; - The ZERO Algebra object is immutable.                    
                </throws>
                <see>
                    #property                    
                </see>
            </javadoc>
            <method name="setProperty" type="void" line="482">
                <params>
                    <param name="property" type="Property"/>
                </params>
            </method>
            <javadoc line="487">
                Solves AX = B.                
                <return>
                    X; a new independent matrix; solution if A is square, least squares solution otherwise.                    
                </return>
            </javadoc>
            <method name="solve" type="DoubleMatrix2D" line="491">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="494">
                Solves XA = B, which is also A&apos;X&apos; = B&apos;.                
                <return>
                    X; a new independent matrix; solution if A is square, least squares solution otherwise.                    
                </return>
            </javadoc>
            <method name="solveTranspose" type="DoubleMatrix2D" line="498">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="501">
                Copies the columns of the indicated rows into a new sub matrix.
                  &lt;tt&gt;sub[0..rowIndexes.length-1,0..columnTo-columnFrom] = A[rowIndexes(:),columnFrom..columnTo]&lt;/tt&gt;;
                  The returned matrix is &lt;i&gt;not backed&lt;/i&gt; by this matrix, so changes in the returned matrix are &lt;i&gt;not reflected&lt;/i&gt; in this matrix, and vice-versa.                
                <param>
                    A   the source matrix to copy from.                    
                </param>
                <param>
                    rowIndexes the indexes of the rows to copy. May be unsorted.                    
                </param>
                <param>
                    columnFrom the index of the first column to copy (inclusive).                    
                </param>
                <param>
                    columnTo the index of the last column to copy (inclusive).                    
                </param>
                <return>
                    a new sub matrix; with &lt;tt&gt;sub.rows()==rowIndexes.length; sub.columns()==columnTo-columnFrom+1&lt;/tt&gt;.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;columnFrom&lt;0 || columnTo-columnFrom+1&lt;0 || columnTo+1&gt;matrix.columns() || for any row=rowIndexes[i]: row &lt; 0 || row &gt;= matrix.rows()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="subMatrix" type="DoubleMatrix2D" line="513">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="rowIndexes" type="int[]"/>
                    <param name="columnFrom" type="int"/>
                    <param name="columnTo" type="int"/>
                </params>
                <declaration name="width" type="int" line="514"/>
                <declaration name="rows" type="int" line="515"/>
                <declaration name="sub" type="DoubleMatrix2D" line="517"/>
                <scope line="519">
                    <declaration name="row" type="int" line="520"/>
                </scope>
            </method>
            <javadoc line="527">
                Copies the rows of the indicated columns into a new sub matrix.
                  &lt;tt&gt;sub[0..rowTo-rowFrom,0..columnIndexes.length-1] = A[rowFrom..rowTo,columnIndexes(:)]&lt;/tt&gt;;
                  The returned matrix is &lt;i&gt;not backed&lt;/i&gt; by this matrix, so changes in the returned matrix are &lt;i&gt;not reflected&lt;/i&gt; in this matrix, and vice-versa.                
                <param>
                    A   the source matrix to copy from.                    
                </param>
                <param>
                    rowFrom the index of the first row to copy (inclusive).                    
                </param>
                <param>
                    rowTo the index of the last row to copy (inclusive).                    
                </param>
                <param>
                    columnIndexes the indexes of the columns to copy. May be unsorted.                    
                </param>
                <return>
                    a new sub matrix; with &lt;tt&gt;sub.rows()==rowTo-rowFrom+1; sub.columns()==columnIndexes.length&lt;/tt&gt;.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;rowFrom&lt;0 || rowTo-rowFrom+1&lt;0 || rowTo+1&gt;matrix.rows() || for any col=columnIndexes[i]: col &lt; 0 || col &gt;= matrix.columns()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="subMatrix" type="DoubleMatrix2D" line="539">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="rowFrom" type="int"/>
                    <param name="rowTo" type="int"/>
                    <param name="columnIndexes" type="int[]"/>
                </params>
                <declaration name="height" type="int" line="541"/>
                <declaration name="columns" type="int" line="542"/>
                <declaration name="sub" type="DoubleMatrix2D" line="544"/>
                <scope line="546">
                    <declaration name="column" type="int" line="547"/>
                </scope>
            </method>
            <javadoc line="554">
                Constructs and returns a new &lt;i&gt;sub-range view&lt;/i&gt; which is the sub matrix &lt;tt&gt;A[fromRow..toRow,fromColumn..toColumn]&lt;/tt&gt;.
                  The returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.
                  Use idioms like &lt;tt&gt;result = subMatrix(...).copy()&lt;/tt&gt; to generate an independent sub matrix.                
                <param>
                    A the source matrix.                    
                </param>
                <param>
                    fromRow   The index of the first row (inclusive).                    
                </param>
                <param>
                    toRow   The index of the last row (inclusive).                    
                </param>
                <param>
                    fromColumn   The index of the first column (inclusive).                    
                </param>
                <param>
                    toColumn   The index of the last column (inclusive).                    
                </param>
                <return>
                    a new sub-range view.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;fromColumn&lt;0 || toColumn-fromColumn+1&lt;0 || toColumn&gt;=A.columns() || fromRow&lt;0 || toRow-fromRow+1&lt;0 || toRow&gt;=A.rows()&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="subMatrix" type="DoubleMatrix2D" line="567">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="fromRow" type="int"/>
                    <param name="toRow" type="int"/>
                    <param name="fromColumn" type="int"/>
                    <param name="toColumn" type="int"/>
                </params>
            </method>
            <javadoc line="570">
                Constructs and returns the SingularValue-decomposition of the given matrix.                
            </javadoc>
            <method name="svd" type="SingularValueDecomposition" line="573">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="576">
                Returns a String with (propertyName, propertyValue) pairs.
                  Useful for debugging or to quickly get the rough picture.
                  For example,
                  &lt;pre&gt;
                  cond          : 14.073264490042144
                  det           : Illegal operation or error: Matrix must be square.
                  norm1         : 0.9620244354009628
                  norm2         : 3.0
                  normF         : 1.304841791648992
                  normInfinity  : 1.5406551198102534
                  rank          : 3
                  trace         : 0
                  &lt;/pre&gt;                
            </javadoc>
            <method name="toString" type="String" line="591">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
                <comment line="597">
                    determine properties                    
                </comment>
                <comment line="631">
                    sort ascending by property name                    
                </comment>
                <comment line="646">
                    determine padding for nice formatting                    
                </comment>
                <comment line="653">
                    finally, format properties                    
                </comment>
                <declaration name="names" type="cern.colt.list.ObjectArrayList" line="592"/>
                <declaration name="values" type="cern.colt.list.ObjectArrayList" line="593"/>
                <declaration name="unknown" type="String" line="594"/>
                <scope line="598"/>
                <scope line="599"/>
                <scope line="602"/>
                <scope line="603"/>
                <scope line="606"/>
                <scope line="607"/>
                <scope line="610"/>
                <scope line="611"/>
                <scope line="614"/>
                <scope line="615"/>
                <scope line="618"/>
                <scope line="619"/>
                <scope line="622"/>
                <scope line="623"/>
                <scope line="626"/>
                <scope line="627"/>
                <anonymous_class line="631">
                    <method name="compare" type="int" line="632">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.IntComparator" line="631"/>
                <anonymous_class line="636">
                    <method name="swap" type="void" line="637">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="tmp" type="Object" line="638"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="636"/>
                <declaration name="maxLength" type="int" line="646"/>
                <scope line="647">
                    <declaration name="length" type="int" line="648"/>
                </scope>
                <declaration name="buf" type="StringBuffer" line="653"/>
                <scope line="654">
                    <declaration name="name" type="String" line="655"/>
                </scope>
            </method>
            <javadoc line="666">
                Returns the results of &lt;tt&gt;toString(A)&lt;/tt&gt; and additionally the results of all sorts of decompositions applied to the given matrix.
                  Useful for debugging or to quickly get the rough picture.
                  For example,
                  &lt;pre&gt;
                  A = 3 x 3 matrix
                  249  66  68
                  104 214 108
                  144 146 293
                  cond         : 3.931600417472078
                  det          : 9638870.0
                  norm1        : 497.0
                  norm2        : 473.34508217011404
                  normF        : 516.873292016525
                  normInfinity : 583.0
                  rank         : 3
                  trace        : 756.0
                  density                      : 1.0
                  isDiagonal                   : false
                  isDiagonallyDominantByColumn : true
                  isDiagonallyDominantByRow    : true
                  isIdentity                   : false
                  isLowerBidiagonal            : false
                  isLowerTriangular            : false
                  isNonNegative                : true
                  isOrthogonal                 : false
                  isPositive                   : true
                  isSingular                   : false
                  isSkewSymmetric              : false
                  isSquare                     : true
                  isStrictlyLowerTriangular    : false
                  isStrictlyTriangular         : false
                  isStrictlyUpperTriangular    : false
                  isSymmetric                  : false
                  isTriangular                 : false
                  isTridiagonal                : false
                  isUnitTriangular             : false
                  isUpperBidiagonal            : false
                  isUpperTriangular            : false
                  isZero                       : false
                  lowerBandwidth               : 2
                  semiBandwidth                : 3
                  upperBandwidth               : 2
                  -----------------------------------------------------------------------------
                  LUDecompositionQuick(A) --&gt; isNonSingular(A), det(A), pivot, L, U, inverse(A)
                  -----------------------------------------------------------------------------
                  isNonSingular = true
                  det = 9638870.0
                  pivot = [0, 1, 2]
                  L = 3 x 3 matrix
                  1        0       0
                  0.417671 1       0
                  0.578313 0.57839 1
                  U = 3 x 3 matrix
                  249  66         68       
                  0 186.433735  79.598394
                  0   0        207.635819
                  inverse(A) = 3 x 3 matrix
                  0.004869 -0.000976 -0.00077 
                  -0.001548  0.006553 -0.002056
                  -0.001622 -0.002786  0.004816
                  -----------------------------------------------------------------
                  QRDecomposition(A) --&gt; hasFullRank(A), H, Q, R, pseudo inverse(A)
                  -----------------------------------------------------------------
                  hasFullRank = true
                  H = 3 x 3 matrix
                  1.814086 0        0
                  0.34002  1.903675 0
                  0.470797 0.428218 2
                  Q = 3 x 3 matrix
                  -0.814086  0.508871  0.279845
                  -0.34002  -0.808296  0.48067 
                  -0.470797 -0.296154 -0.831049
                  R = 3 x 3 matrix
                  -305.864349 -195.230337 -230.023539
                  0        -182.628353  467.703164
                  0           0        -309.13388 
                  pseudo inverse(A) = 3 x 3 matrix
                  0.006601  0.001998 -0.005912
                  -0.005105  0.000444  0.008506
                  -0.000905 -0.001555  0.002688
                  --------------------------------------------------------------------------
                  CholeskyDecomposition(A) --&gt; isSymmetricPositiveDefinite(A), L, inverse(A)
                  --------------------------------------------------------------------------
                  isSymmetricPositiveDefinite = false
                  L = 3 x 3 matrix
                  15.779734  0         0       
                  6.590732 13.059948  0       
                  9.125629  6.573948 12.903724
                  inverse(A) = Illegal operation or error: Matrix is not symmetric positive definite.
                  ---------------------------------------------------------------------
                  EigenvalueDecomposition(A) --&gt; D, V, realEigenvalues, imagEigenvalues
                  ---------------------------------------------------------------------
                  realEigenvalues = 1 x 3 matrix
                  462.796507 172.382058 120.821435
                  imagEigenvalues = 1 x 3 matrix
                  0 0 0
                  D = 3 x 3 matrix
                  462.796507   0          0       
                  0        172.382058   0       
                  0          0        120.821435
                  V = 3 x 3 matrix
                  -0.398877 -0.778282  0.094294
                  -0.500327  0.217793 -0.806319
                  -0.768485  0.66553   0.604862
                  ---------------------------------------------------------------------
                  SingularValueDecomposition(A) --&gt; cond(A), rank(A), norm2(A), U, S, V
                  ---------------------------------------------------------------------
                  cond = 3.931600417472078
                  rank = 3
                  norm2 = 473.34508217011404
                  U = 3 x 3 matrix
                  0.46657  -0.877519  0.110777
                  0.50486   0.161382 -0.847982
                  0.726243  0.45157   0.51832 
                  S = 3 x 3 matrix
                  473.345082   0          0       
                  0        169.137441   0       
                  0          0        120.395013
                  V = 3 x 3 matrix
                  0.577296 -0.808174  0.116546
                  0.517308  0.251562 -0.817991
                  0.631761  0.532513  0.563301
                  &lt;/pre&gt;                
            </javadoc>
            <method name="toVerboseString" type="String" line="812">
                <params>
                    <param name="matrix" type="DoubleMatrix2D"/>
                </params>
                <comment line="814">
                    StringBuffer buf = new StringBuffer();
                    String unknown = &quot;Illegal operation or error: &quot;;
                    String constructionException = &quot;Illegal operation or error upon construction: &quot;;
                    
                    buf.append(&quot;------------------------------------------------------------------\n&quot;);
                    buf.append(&quot;LUDecomposition(A) --&gt; isNonSingular, det, pivot, L, U, inverse(A)\n&quot;);
                    buf.append(&quot;------------------------------------------------------------------\n&quot;);                    
                </comment>
                <declaration name="constructionException" type="String" line="823"/>
                <declaration name="buf" type="StringBuffer" line="824"/>
                <declaration name="lu" type="LUDecomposition" line="832"/>
                <scope line="833"/>
                <scope line="834"/>
                <declaration name="qr" type="QRDecomposition" line="839"/>
                <scope line="840"/>
                <scope line="841"/>
                <declaration name="chol" type="CholeskyDecomposition" line="846"/>
                <scope line="847"/>
                <scope line="848"/>
                <declaration name="eig" type="EigenvalueDecomposition" line="853"/>
                <scope line="854"/>
                <scope line="855"/>
                <declaration name="svd" type="SingularValueDecomposition" line="860"/>
                <scope line="861"/>
                <scope line="862"/>
            </method>
            <javadoc line="869">
                Returns the sum of the diagonal elements of matrix &lt;tt&gt;A&lt;/tt&gt;; &lt;tt&gt;Sum(A[i,i])&lt;/tt&gt;.                
            </javadoc>
            <method name="trace" type="double" line="872">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="sum" type="double" line="873"/>
                <scope line="874"/>
            </method>
            <javadoc line="879">
                Constructs and returns a new view which is the transposition of the given matrix &lt;tt&gt;A&lt;/tt&gt;.
                  Equivalent to {@link DoubleMatrix2D#viewDice A.viewDice()}.
                  This is a zero-copy transposition, taking O(1), i.e. constant time.
                  The returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 
                  Use idioms like &lt;tt&gt;result = transpose(A).copy()&lt;/tt&gt; to generate an independent matrix.
                  &lt;p&gt; 
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                  1, 2, 3&lt;br&gt;
                  4, 5, 6 &lt;/td&gt;
                  &lt;td&gt;transpose ==&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;3 x 2 matrix:&lt;br&gt;
                  1, 4 &lt;br&gt;
                  2, 5 &lt;br&gt;
                  3, 6&lt;/td&gt;
                  &lt;td&gt;transpose ==&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;2 x 3 matrix: &lt;br&gt;
                  1, 2, 3&lt;br&gt;
                  4, 5, 6 &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <return>
                    a new transposed view.                    
                </return>
            </javadoc>
            <method name="transpose" type="DoubleMatrix2D" line="905">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
            </method>
            <javadoc line="908">
                Modifies the matrix to be a lower trapezoidal matrix.                
                <return>
                    &lt;tt&gt;A&lt;/tt&gt; (for convenience only).                    
                </return>
                <see>
                    #triangulateLower(DoubleMatrix2D)                    
                </see>
            </javadoc>
            <method name="trapezoidalLower" type="DoubleMatrix2D" line="913">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <declaration name="rows" type="int" line="914"/>
                <declaration name="columns" type="int" line="915"/>
                <scope line="916">
                    <scope line="917"/>
                </scope>
            </method>
            <javadoc line="923">
                Outer product of two vectors; Returns a matrix with &lt;tt&gt;A[i,j] = x[i]  y[j]&lt;/tt&gt;.                
                <param>
                    x the first source vector.                    
                </param>
                <param>
                    y the second source vector.                    
                </param>
                <return>
                    the outer product &lt;/tt&gt;A&lt;/tt&gt;.                    
                </return>
            </javadoc>
            <method name="xmultOuter" type="DoubleMatrix2D" line="930">
                <params>
                    <param name="x" type="DoubleMatrix1D"/>
                    <param name="y" type="DoubleMatrix1D"/>
                </params>
                <declaration name="A" type="DoubleMatrix2D" line="931"/>
            </method>
            <javadoc line="935">
                Linear algebraic matrix power; &lt;tt&gt;B = A&lt;sup&gt;k&lt;/sup&gt; &lt;==&gt; B = AA...A&lt;/tt&gt;.                
                <param>
                    A the source matrix; must be square.                    
                </param>
                <param>
                    k the exponent, can be any number.                    
                </param>
                <return>
                    a new result matrix.                    
                </return>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;!Testing.isSquare(A)&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="xpowSlow" type="DoubleMatrix2D" line="943">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                    <param name="k" type="int"/>
                </params>
                <comment line="945">
                    cern.colt.Timer timer = new cern.colt.Timer().start();                    
                </comment>
                <comment line="950">
                    timer.stop().display();                    
                </comment>
                <declaration name="result" type="DoubleMatrix2D" line="945"/>
                <scope line="946"/>
            </method>
        </class>
    </source>