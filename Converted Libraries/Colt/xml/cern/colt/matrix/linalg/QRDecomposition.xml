<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.linalg">
        <import package="cern.colt.matrix.DoubleMatrix1D"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="QRDecomposition" line="14">
            <comment line="32">
                private double[][] QR;                
            </comment>
            <implements interface="java.io.Serializable"/>
            <javadoc line="14">
                For an &lt;tt&gt;m x n&lt;/tt&gt; matrix &lt;tt&gt;A&lt;/tt&gt; with &lt;tt&gt;m &gt;= n&lt;/tt&gt;, the QR decomposition is an &lt;tt&gt;m x n&lt;/tt&gt;
                  orthogonal matrix &lt;tt&gt;Q&lt;/tt&gt; and an &lt;tt&gt;n x n&lt;/tt&gt; upper triangular matrix &lt;tt&gt;R&lt;/tt&gt; so that
                  &lt;tt&gt;A = QR&lt;/tt&gt;.
                  &lt;P&gt;
                  The QR decompostion always exists, even if the matrix does not have
                  full rank, so the constructor will never fail.  The primary use of the
                  QR decomposition is in the least squares solution of nonsquare systems
                  of simultaneous linear equations.  This will fail if &lt;tt&gt;isFullRank()&lt;/tt&gt;
                  returns &lt;tt&gt;false&lt;/tt&gt;.                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="26"/>
            <declaration name="QR" type="DoubleMatrix2D" line="27"/>
            <javadoc line="27">
                Array for internal storage of decomposition.                
                <serial>
                    internal array storage.                    
                </serial>
            </javadoc>
            <declaration name="m" type="int" line="33"/>
            <javadoc line="33">
                Row and column dimensions.                
                <serial>
                    column dimension.                    
                </serial>
                <serial>
                    row dimension.                    
                </serial>
            </javadoc>
            <declaration name="Rdiag" type="DoubleMatrix1D" line="39"/>
            <javadoc line="39">
                Array for internal storage of diagonal of R.                
                <serial>
                    diagonal of R.                    
                </serial>
            </javadoc>
            <javadoc line="43">
                Constructs and returns a new QR decomposition object;  computed by Householder reflections;
                  The decomposed matrices can be retrieved via instance methods of the returned decomposition object.                
                <param>
                    A    A rectangular matrix.                    
                </param>
                <return>
                    a decomposition object to access <tt>R</tt> and the Householder vectors <tt>H</tt>, and to compute <tt>Q</tt>.                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>A.rows() < A.columns()</tt>.                    
                </throws>
            </javadoc>
            <method name="QRDecomposition" type="constructor" line="51">
                <params>
                    <param name="A" type="DoubleMatrix2D"/>
                </params>
                <comment line="55">
                    Initialize.                    
                </comment>
                <comment line="60">
                    Rdiag = new double[n];                    
                </comment>
                <comment line="63">
                    precompute and cache some views to avoid regenerating them time and again                    
                </comment>
                <comment line="71">
                    Main loop.                    
                </comment>
                <comment line="73">
                    DoubleMatrix1D QRcolk = QR.viewColumn(k).viewPart(k,m-k);                    
                </comment>
                <comment line="74">
                    Compute 2-norm of k-th column without under/overflow.                    
                </comment>
                <comment line="76">
                    if (k&lt;m) nrm = QRcolumnsPart[k].aggregate(hypot,F.identity);                    
                </comment>
                <comment line="78">
                    fixes bug reported by hong.44@osu.edu                    
                </comment>
                <comment line="84">
                    Form k-th Householder vector.                    
                </comment>
                <comment line="87">
                    for (int i = k; i &lt; m; i++) {
                    QR[i][k] = nrm;
                    }                    
                </comment>
                <comment line="95">
                    Apply transformation to remaining columns.                    
                </comment>
                <comment line="99">
                    fixes bug reported by John Chambers
                    DoubleMatrix1D QRcolj = QR.viewColumn(j).viewPart(k,m-k);
                    double s = QRcolumnsPart[k].zDotProduct(QRcolumns[j]);
                    double s = 0.0;
                    for (int i = k; i &lt; m; i++) {
                    s += QR[i][k]QR[i][j];
                    }                    
                </comment>
                <comment line="109">
                    QRcolumnsPart[j].assign(QRcolumns[k], F.plusMult(s));                    
                </comment>
                <declaration name="F" type="cern.jet.math.Functions" line="54"/>
                <declaration name="hypot" type="cern.colt.function.DoubleDoubleFunction" line="61"/>
                <declaration name="QRcolumns" type="DoubleMatrix1D[]" line="64"/>
                <declaration name="QRcolumnsPart" type="DoubleMatrix1D[]" line="65"/>
                <scope line="66"/>
                <scope line="72">
                    <declaration name="nrm" type="double" line="75"/>
                    <scope line="78"/>
                    <scope line="83">
                        <scope line="96">
                            <declaration name="QRcolj" type="DoubleMatrix1D" line="97"/>
                            <declaration name="s" type="double" line="98"/>
                            <scope line="111"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="120">
                Returns the Householder vectors &lt;tt&gt;H&lt;/tt&gt;.                
                <return>
                    A lower trapezoidal matrix whose columns define the householder reflections.                    
                </return>
            </javadoc>
            <method name="getH" type="DoubleMatrix2D" line="124"/>
            <javadoc line="127">
                Generates and returns the (economy-sized) orthogonal factor &lt;tt&gt;Q&lt;/tt&gt;.                
                <return>
                    <tt>Q</tt>                    
                </return>
            </javadoc>
            <method name="getQ" type="DoubleMatrix2D" line="131">
                <comment line="134">
                    double[][] Q = X.getArray();                    
                </comment>
                <declaration name="F" type="cern.jet.math.Functions" line="132"/>
                <declaration name="Q" type="DoubleMatrix2D" line="133"/>
                <scope line="135">
                    <declaration name="QRcolk" type="DoubleMatrix1D" line="136"/>
                    <scope line="138">
                        <scope line="139">
                            <declaration name="Qcolj" type="DoubleMatrix1D" line="140"/>
                            <declaration name="s" type="double" line="141"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="149">
                Returns the upper triangular factor, &lt;tt&gt;R&lt;/tt&gt;.                
                <return>
                    <tt>R</tt>                    
                </return>
            </javadoc>
            <method name="getR" type="DoubleMatrix2D" line="153">
                <declaration name="R" type="DoubleMatrix2D" line="154"/>
                <scope line="155">
                    <scope line="156"/>
                </scope>
            </method>
            <javadoc line="167">
                Returns whether the matrix &lt;tt&gt;A&lt;/tt&gt; has full rank.                
                <return>
                    true if <tt>R</tt>, and hence <tt>A</tt>, has full rank.                    
                </return>
            </javadoc>
            <method name="hasFullRank" type="boolean" line="171">
                <scope line="172"/>
            </method>
            <javadoc line="177">
                Least squares solution of &lt;tt&gt;AX = B&lt;/tt&gt;; &lt;tt&gt;returns X&lt;/tt&gt;.                
                <param>
                    B    A matrix with as many rows as <tt>A</tt> and any number of columns.                    
                </param>
                <return>
                    <tt>X</tt> that minimizes the two norm of <tt>QRX - B</tt>.                    
                </return>
                <exception>
                    IllegalArgumentException  if <tt>B.rows() != A.rows()</tt>.                    
                </exception>
                <exception>
                    IllegalArgumentException  if <tt>!this.hasFullRank()</tt> (<tt>A</tt> is rank deficient).                    
                </exception>
            </javadoc>
            <method name="solve" type="DoubleMatrix2D" line="184">
                <params>
                    <param name="B" type="DoubleMatrix2D"/>
                </params>
                <comment line="193">
                    Copy right hand side                    
                </comment>
                <comment line="197">
                    Compute Y = transpose(Q)*B                    
                </comment>
                <comment line="210">
                    Solve R*X = Y;                    
                </comment>
                <declaration name="F" type="cern.jet.math.Functions" line="185"/>
                <scope line="186"/>
                <scope line="189"/>
                <declaration name="nx" type="int" line="194"/>
                <declaration name="X" type="DoubleMatrix2D" line="195"/>
                <scope line="198">
                    <scope line="199">
                        <declaration name="s" type="double" line="200"/>
                        <scope line="201"/>
                        <scope line="205"/>
                    </scope>
                </scope>
                <scope line="211">
                    <scope line="212"/>
                    <scope line="215">
                        <scope line="216"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="223">
                Returns a String with (propertyName, propertyValue) pairs.
                  Useful for debugging or to quickly get the rough picture.
                  For example,
                  &lt;pre&gt;
                  rank          : 3
                  trace         : 0
                  &lt;/pre&gt;                
            </javadoc>
            <method name="toString" type="String" line="232">
                <declaration name="buf" type="StringBuffer" line="233"/>
                <declaration name="unknown" type="String" line="234"/>
                <scope line="241"/>
                <scope line="242"/>
                <scope line="245"/>
                <scope line="246"/>
                <scope line="249"/>
                <scope line="250"/>
                <scope line="253"/>
                <scope line="254"/>
                <scope line="257"/>
                <scope line="258"/>
            </method>
        </class>
    </source>