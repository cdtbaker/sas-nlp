<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.impl">
        <import package="cern.colt.map.AbstractIntDoubleMap"/>
        <import package="cern.colt.map.OpenIntDoubleHashMap"/>
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <import package="cern.colt.matrix.DoubleMatrix3D"/>
        <class name="SparseDoubleMatrix3D" line="15">
            <extends class="DoubleMatrix3D"/>
            <comment line="79">
                The elements of the matrix.                
            </comment>
            <javadoc line="15">
                Sparse hashed 3-d matrix holding &lt;tt&gt;double&lt;/tt&gt; elements.
                  First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                  &lt;p&gt;
                  &lt;b&gt;Implementation:&lt;/b&gt;
                  &lt;p&gt;
                  Note that this implementation is not synchronized.
                  Uses a {@link cern.colt.map.OpenIntDoubleHashMap}, which is a compact and performant hashing technique.
                  &lt;p&gt;
                  &lt;b&gt;Memory requirements:&lt;/b&gt;
                  &lt;p&gt;
                  Cells that
                  &lt;ul&gt;
                  &lt;li&gt;are never set to non-zero values do not use any memory.
                  &lt;li&gt;switch from zero to non-zero state do use memory.
                  &lt;li&gt;switch back from non-zero to zero state also do use memory. However, their memory is automatically reclaimed from time to time. It can also manually be reclaimed by calling {@link #trimToSize()}.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  worst case: &lt;tt&gt;memory [bytes] = (1/minLoadFactor)  nonZeros  13&lt;/tt&gt;.
                  &lt;br&gt;best  case: &lt;tt&gt;memory [bytes] = (1/maxLoadFactor)  nonZeros  13&lt;/tt&gt;.
                  &lt;br&gt;Where &lt;tt&gt;nonZeros = cardinality()&lt;/tt&gt; is the number of non-zero cells.
                  Thus, a 100 x 100 x 100 matrix with minLoadFactor=0.25 and maxLoadFactor=0.5 and 1000000 non-zero cells consumes between 25 MB and 50 MB.
                  The same 100 x 100 x 100 matrix with 1000 non-zero cells consumes between 25 and 50 KB.
                  &lt;p&gt;
                  &lt;b&gt;Time complexity:&lt;/b&gt;
                  &lt;p&gt;
                  This class offers &lt;i&gt;expected&lt;/i&gt; time complexity &lt;tt&gt;O(1)&lt;/tt&gt; (i.e. constant time) for the basic operations
                  &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;getQuick&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, &lt;tt&gt;setQuick&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;
                  assuming the hash function disperses the elements properly among the buckets.
                  Otherwise, pathological cases, although highly improbable, can occur, degrading performance to &lt;tt&gt;O(N)&lt;/tt&gt; in the worst case.
                  As such this sparse class is expected to have no worse time complexity than its dense counterpart {@link DenseDoubleMatrix2D}.
                  However, constant factors are considerably larger.
                  &lt;p&gt;
                  Cells are internally addressed in (in decreasing order of significance): slice major, row major, column major.
                  Applications demanding utmost speed can exploit this fact.
                  Setting/getting values in a loop slice-by-slice, row-by-row, column-by-column is quicker than, for example, column-by-column, row-by-row, slice-by-slice.
                  Thus
                  &lt;pre&gt;
                  for (int slice=0; slice &lt; slices; slice++) {
                  for (int row=0; row &lt; rows; row++) {
                  for (int column=0; column &lt; columns; column++) {
                  matrix.setQuick(slice,row,column,someValue);
                  }		    
                  }
                  }
                  &lt;/pre&gt;
                  is quicker than
                  &lt;pre&gt;
                  for (int column=0; column &lt; columns; column++) {
                  for (int row=0; row &lt; rows; row++) {
                  for (int slice=0; slice &lt; slices; slice++) {
                  matrix.setQuick(slice,row,column,someValue);
                  }
                  }
                  }
                  &lt;/pre&gt;                
                <see>
                    cern.colt.map                    
                </see>
                <see>
                    cern.colt.map.OpenIntDoubleHashMap                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <declaration name="elements" type="AbstractIntDoubleMap" line="81"/>
            <javadoc line="82">
                Constructs a matrix with a copy of the given values.
                  &lt;tt&gt;values&lt;/tt&gt; is required to have the form &lt;tt&gt;values[slice][row][column]&lt;/tt&gt;
                  and have exactly the same number of rows in in every slice and exactly the same number of columns in in every row.
                  &lt;p&gt;
                  The values are copied. So subsequent changes in &lt;tt&gt;values&lt;/tt&gt; are not reflected in the matrix, and vice-versa.                
                <param>
                    values The values to be filled into the new matrix.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;for any 1 &amp;lt;= slice &amp;lt; values.length: values[slice].length != values[slice-1].length&lt;/tt&gt;.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;for any 1 &amp;lt;= row &amp;lt; values[0].length: values[slice][row].length != values[slice][row-1].length&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="SparseDoubleMatrix3D" type="constructor" line="93">
                <params>
                    <param name="values" type="double[][][]"/>
                </params>
            </method>
            <javadoc line="97">
                Constructs a matrix with a given number of slices, rows and columns and default memory usage.
                  All entries are initially &lt;tt&gt;0&lt;/tt&gt;.                
                <param>
                    slices the number of slices the matrix shall have.                    
                </param>
                <param>
                    rows the number of rows the matrix shall have.                    
                </param>
                <param>
                    columns the number of columns the matrix shall have.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;(double)slicescolumnsrows &gt; Integer.MAX_VALUE&lt;/tt&gt;.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;slices&lt;0 || rows&lt;0 || columns&lt;0&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="SparseDoubleMatrix3D" type="constructor" line="106">
                <params>
                    <param name="slices" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                </params>
            </method>
            <javadoc line="109">
                Constructs a matrix with a given number of slices, rows and columns using memory as specified.
                  All entries are initially &lt;tt&gt;0&lt;/tt&gt;.
                  For details related to memory usage see {@link cern.colt.map.OpenIntDoubleHashMap}.                
                <param>
                    slices the number of slices the matrix shall have.                    
                </param>
                <param>
                    rows the number of rows the matrix shall have.                    
                </param>
                <param>
                    columns the number of columns the matrix shall have.                    
                </param>
                <param>
                    initialCapacity   the initial capacity of the hash map.
                      If not known, set &lt;tt&gt;initialCapacity=0&lt;/tt&gt; or small.                    
                </param>
                <param>
                    minLoadFactor        the minimum load factor of the hash map.                    
                </param>
                <param>
                    maxLoadFactor        the maximum load factor of the hash map.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;initialCapacity &lt; 0 || (minLoadFactor &lt; 0.0 || minLoadFactor &gt;= 1.0) || (maxLoadFactor &lt;= 0.0 || maxLoadFactor &gt;= 1.0) || (minLoadFactor &gt;= maxLoadFactor)&lt;/tt&gt;.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;(double)columnsrows &gt; Integer.MAX_VALUE&lt;/tt&gt;.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;slices&lt;0 || rows&lt;0 || columns&lt;0&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="SparseDoubleMatrix3D" type="constructor" line="125">
                <params>
                    <param name="slices" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="initialCapacity" type="int"/>
                    <param name="minLoadFactor" type="double"/>
                    <param name="maxLoadFactor" type="double"/>
                </params>
            </method>
            <javadoc line="129">
                Constructs a view with the given parameters.                
                <param>
                    slices the number of slices the matrix shall have.                    
                </param>
                <param>
                    rows the number of rows the matrix shall have.                    
                </param>
                <param>
                    columns the number of columns the matrix shall have.                    
                </param>
                <param>
                    elements the cells.                    
                </param>
                <param>
                    sliceZero the position of the first element.                    
                </param>
                <param>
                    rowZero the position of the first element.                    
                </param>
                <param>
                    columnZero the position of the first element.                    
                </param>
                <param>
                    sliceStride the number of elements between two slices, i.e. &lt;tt&gt;index(k+1,i,j)-index(k,i,j)&lt;/tt&gt;.                    
                </param>
                <param>
                    rowStride the number of elements between two rows, i.e. &lt;tt&gt;index(k,i+1,j)-index(k,i,j)&lt;/tt&gt;.                    
                </param>
                <param>
                    columnnStride the number of elements between two columns, i.e. &lt;tt&gt;index(k,i,j+1)-index(k,i,j)&lt;/tt&gt;.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;(double)slicescolumnsrows &gt; Integer.MAX_VALUE&lt;/tt&gt;.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;slices&lt;0 || rows&lt;0 || columns&lt;0&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="SparseDoubleMatrix3D" type="constructor" line="144">
                <params>
                    <param name="slices" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="elements" type="AbstractIntDoubleMap"/>
                    <param name="sliceZero" type="int"/>
                    <param name="rowZero" type="int"/>
                    <param name="columnZero" type="int"/>
                    <param name="sliceStride" type="int"/>
                    <param name="rowStride" type="int"/>
                    <param name="columnStride" type="int"/>
                </params>
            </method>
            <javadoc line="149">
                Sets all cells to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <param>
                    value the value to be filled into the cells.                    
                </param>
                <return>
                    &lt;tt&gt;this&lt;/tt&gt; (for convenience only).                    
                </return>
            </javadoc>
            <method name="assign" type="DoubleMatrix3D" line="154">
                <params>
                    <param name="value" type="double"/>
                </params>
                <comment line="156">
                    overriden for performance only                    
                </comment>
            </method>
            <javadoc line="160">
                Returns the number of cells having non-zero values.                
            </javadoc>
            <method name="cardinality" type="int" line="163"/>
            <javadoc line="167">
                Ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory.
                  If necessary, allocates new internal memory and increases the capacity of the receiver.
                  &lt;p&gt;
                  This method never need be called; it is for performance tuning only.
                  Calling this method before tt&gt;set()&lt;/tt&gt;ing a large number of non-zero values boosts performance,
                  because the receiver will grow only once instead of potentially many times and hash collisions get less probable.                
                <param>
                    minNonZeros   the desired minimum number of non-zero cells.                    
                </param>
            </javadoc>
            <method name="ensureCapacity" type="void" line="177">
                <params>
                    <param name="minCapacity" type="int"/>
                </params>
            </method>
            <javadoc line="180">
                Returns the matrix cell value at coordinate &lt;tt&gt;[slice,row,column]&lt;/tt&gt;.
                  &lt;p&gt;Provided with invalid parameters this method may return invalid objects without throwing any exception.
                  &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                  Precondition (unchecked): &lt;tt&gt;slice&amp;lt;0 || slice&amp;gt;=slices() || row&amp;lt;0 || row&amp;gt;=rows() || column&amp;lt;0 || column&amp;gt;=column()&lt;/tt&gt;.                
                <param>
                    slice   the index of the slice-coordinate.                    
                </param>
                <param>
                    row   the index of the row-coordinate.                    
                </param>
                <param>
                    column   the index of the column-coordinate.                    
                </param>
                <return>
                    the value at the specified coordinate.                    
                </return>
            </javadoc>
            <method name="getQuick" type="double" line="192">
                <params>
                    <param name="slice" type="int"/>
                    <param name="row" type="int"/>
                    <param name="column" type="int"/>
                </params>
                <comment line="194">
                    if (debug) if (slice&lt;0 || slice&gt;=slices || row&lt;0 || row&gt;=rows || column&lt;0 || column&gt;=columns) throw new IndexOutOfBoundsException(&quot;slice:&quot;+slice+&quot;, row:&quot;+row+&quot;, column:&quot;+column);
                    return elements.get(index(slice,row,column));
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="198">
                Returns &lt;tt&gt;true&lt;/tt&gt; if both matrices share at least one identical cell.                
            </javadoc>
            <method name="haveSharedCellsRaw" type="boolean" line="201">
                <params>
                    <param name="other" type="DoubleMatrix3D"/>
                </params>
                <scope line="202">
                    <declaration name="otherMatrix" type="SelectedSparseDoubleMatrix3D" line="203"/>
                </scope>
                <scope line="206">
                    <declaration name="otherMatrix" type="SparseDoubleMatrix3D" line="207"/>
                </scope>
            </method>
            <javadoc line="212">
                Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array.                
                <param>
                    slice   the index of the slice-coordinate.                    
                </param>
                <param>
                    row   the index of the row-coordinate.                    
                </param>
                <param>
                    column   the index of the third-coordinate.                    
                </param>
            </javadoc>
            <method name="index" type="int" line="219">
                <params>
                    <param name="slice" type="int"/>
                    <param name="row" type="int"/>
                    <param name="column" type="int"/>
                </params>
                <comment line="221">
                    return _sliceOffset(_sliceRank(slice)) + _rowOffset(_rowRank(row)) + _columnOffset(_columnRank(column));
                    manually inlined:                    
                </comment>
            </method>
            <javadoc line="224">
                Construct and returns a new empty matrix &lt;i&gt;of the same dynamic type&lt;/i&gt; as the receiver, having the specified number of slices, rows and columns.
                  For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseDoubleMatrix3D&lt;/tt&gt;,
                  if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseDoubleMatrix3D&lt;/tt&gt;, etc.
                  In general, the new matrix should have internal parametrization as similar as possible.                
                <param>
                    slices the number of slices the matrix shall have.                    
                </param>
                <param>
                    rows the number of rows the matrix shall have.                    
                </param>
                <param>
                    columns the number of columns the matrix shall have.                    
                </param>
                <return>
                    a new empty matrix of the same dynamic type.                    
                </return>
            </javadoc>
            <method name="like" type="DoubleMatrix3D" line="235">
                <params>
                    <param name="slices" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                </params>
            </method>
            <javadoc line="238">
                Construct and returns a new 2-d matrix &lt;i&gt;of the corresponding dynamic type&lt;/i&gt;, sharing the same cells.
                  For example, if the receiver is an instance of type &lt;tt&gt;DenseDoubleMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt;,
                  if the receiver is an instance of type &lt;tt&gt;SparseDoubleMatrix3D&lt;/tt&gt; the new matrix must also be of type &lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt;, etc.                
                <param>
                    rows the number of rows the matrix shall have.                    
                </param>
                <param>
                    columns the number of columns the matrix shall have.                    
                </param>
                <param>
                    rowZero the position of the first element.                    
                </param>
                <param>
                    columnZero the position of the first element.                    
                </param>
                <param>
                    rowStride the number of elements between two rows, i.e. &lt;tt&gt;index(i+1,j)-index(i,j)&lt;/tt&gt;.                    
                </param>
                <param>
                    columnStride the number of elements between two columns, i.e. &lt;tt&gt;index(i,j+1)-index(i,j)&lt;/tt&gt;.                    
                </param>
                <return>
                    a new matrix of the corresponding dynamic type.                    
                </return>
            </javadoc>
            <method name="like2D" type="DoubleMatrix2D" line="251">
                <params>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="rowZero" type="int"/>
                    <param name="columnZero" type="int"/>
                    <param name="rowStride" type="int"/>
                    <param name="columnStride" type="int"/>
                </params>
            </method>
            <javadoc line="254">
                Sets the matrix cell at coordinate &lt;tt&gt;[slice,row,column]&lt;/tt&gt; to the specified value.
                  &lt;p&gt;Provided with invalid parameters this method may access illegal indexes without throwing any exception.
                  &lt;b&gt;You should only use this method when you are absolutely sure that the coordinate is within bounds.&lt;/b&gt;
                  Precondition (unchecked): &lt;tt&gt;slice&amp;lt;0 || slice&amp;gt;=slices() || row&amp;lt;0 || row&amp;gt;=rows() || column&amp;lt;0 || column&amp;gt;=column()&lt;/tt&gt;.                
                <param>
                    slice   the index of the slice-coordinate.                    
                </param>
                <param>
                    row   the index of the row-coordinate.                    
                </param>
                <param>
                    column   the index of the column-coordinate.                    
                </param>
                <param>
                    value the value to be filled into the specified cell.                    
                </param>
            </javadoc>
            <method name="setQuick" type="void" line="266">
                <params>
                    <param name="slice" type="int"/>
                    <param name="row" type="int"/>
                    <param name="column" type="int"/>
                    <param name="value" type="double"/>
                </params>
                <comment line="268">
                    if (debug) if (slice&lt;0 || slice&gt;=slices || row&lt;0 || row&gt;=rows || column&lt;0 || column&gt;=columns) throw new IndexOutOfBoundsException(&quot;slice:&quot;+slice+&quot;, row:&quot;+row+&quot;, column:&quot;+column);
                    int index =	index(slice,row,column);
                    manually inlined:                    
                </comment>
                <declaration name="index" type="int" line="270"/>
            </method>
            <javadoc line="276">
                Releases any superfluous memory created by explicitly putting zero values into cells formerly having non-zero values; 
                  An application can use this operation to minimize the
                  storage of the receiver.
                  &lt;p&gt;
                  &lt;b&gt;Background:&lt;/b&gt;
                  &lt;p&gt;
                  Cells that &lt;ul&gt;
                  &lt;li&gt;are never set to non-zero values do not use any memory.
                  &lt;li&gt;switch from zero to non-zero state do use memory.
                  &lt;li&gt;switch back from non-zero to zero state also do use memory. However, their memory can be reclaimed by calling &lt;tt&gt;trimToSize()&lt;/tt&gt;.
                  &lt;/ul&gt;
                  A sequence like &lt;tt&gt;set(s,r,c,5); set(s,r,c,0);&lt;/tt&gt;
                  sets a cell to non-zero state and later back to zero state.
                  Such as sequence generates obsolete memory that is automatically reclaimed from time to time or can manually be reclaimed by calling &lt;tt&gt;trimToSize()&lt;/tt&gt;.
                  Putting zeros into cells already containing zeros does not generate obsolete memory since no memory was allocated to them in the first place.                
            </javadoc>
            <method name="trimToSize" type="void" line="293"/>
            <javadoc line="296">
                Construct and returns a new selection view.                
                <param>
                    sliceOffsets the offsets of the visible elements.                    
                </param>
                <param>
                    rowOffsets the offsets of the visible elements.                    
                </param>
                <param>
                    columnOffsets the offsets of the visible elements.                    
                </param>
                <return>
                    a new view.                    
                </return>
            </javadoc>
            <method name="viewSelectionLike" type="DoubleMatrix3D" line="304">
                <params>
                    <param name="sliceOffsets" type="int[]"/>
                    <param name="rowOffsets" type="int[]"/>
                    <param name="columnOffsets" type="int[]"/>
                </params>
            </method>
        </class>
    </source>