<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.impl">
        <import package="cern.colt.matrix.DoubleMatrix2D"/>
        <class name="BenchmarkMatrix2D" line="12">
            <javadoc line="12">
                Benchmarks the performance of matrices. Here are the results of some encouraging 
                  measurements. Note that all benchmarks only measure the time spent in accessing 
                  a matrix element; they exclude the loop itself. 
                  &lt;p&gt; 
                  &lt;center&gt;
                  &lt;table border cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; align=&quot;center&quot;&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#33CC66&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td nowrap colspan=&quot;7&quot;&gt; &lt;font size=&quot;+2&quot;&gt;Iteration Performance [million method 
                  calls per second]&lt;/font&gt;&lt;br&gt;
                  &lt;font size=&quot;-1&quot;&gt;Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic,&lt;br&gt;
                  60 times repeating the same iteration &lt;/font&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#33CC66&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td nowrap&gt; 
                  &lt;div align=&quot;left&quot;&gt; Element type&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td nowrap colspan=&quot;6&quot;&gt; Matrix2D type &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td nowrap bgcolor=&quot;#FF9966&quot; rowspan=&quot;2&quot;&gt; 
                  &lt;div align=&quot;left&quot;&gt; .&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot; colspan=&quot;2&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;DenseDoubleMatrix2D&lt;/tt&gt;&lt;br&gt;
                  1000 x 1000 &lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot; colspan=&quot;2&quot;&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot; colspan=&quot;2&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;SparseDoubleMatrix2D&lt;/tt&gt;&lt;br&gt;
                  100 x 1000,&lt;br&gt;
                  &lt;font size=&quot;-1&quot;&gt; minLoadFactor=0.2, maxLoadFactor=0.5, initialCapacity 
                  = 0&lt;/font&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td bgcolor=&quot;#FF9966&quot;&gt; getQuick&lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot;&gt; setQuick&lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot;&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot;&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot;&gt; getQuick&lt;/td&gt;
                  &lt;td bgcolor=&quot;#FF9966&quot;&gt;setQuick&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td nowrap bgcolor=&quot;#FF9966&quot;&gt;double&lt;/td&gt;
                  &lt;td nowrap&gt;5&lt;/td&gt;
                  &lt;td nowrap&gt;5&lt;/td&gt;
                  &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td nowrap&gt;1&lt;/td&gt;
                  &lt;td nowrap&gt;0.27&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td nowrap bgcolor=&quot;#FF9966&quot;&gt; int&lt;/td&gt;
                  &lt;td nowrap&gt;5 &lt;/td&gt;
                  &lt;td nowrap&gt;5.5 &lt;/td&gt;
                  &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td nowrap&gt;&amp;nbsp;&lt;/td&gt;
                  &lt;td nowrap&gt;1 &lt;/td&gt;
                  &lt;td nowrap&gt;0.3&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/center&gt;
                  &lt;p align=&quot;left&quot;&gt; As can be seen, sparse matrices are certainly not quite as quick 
                  as dense ones, but not really slow either. Considering their minimal footprint 
                  they can be a real alternative. 
                  &lt;p&gt; Comparing the OO abstractions to zero-abstraction primitive Java arrays may 
                  or may not be useful. Still, the table below provides some interesting information. 
                  For example, access to &lt;tt&gt;Type_T_Matrix2D&lt;/tt&gt; is quicker than naive usage 
                  of &lt;tt&gt;Type_T_[]&lt;/tt&gt;. Primitive arrays should only be considered if the optimized 
                  form can be applied. Note again that all benchmarks only measure the time spent 
                  in accessing a matrix element; they exclude the loop itself. 
                  &lt;p&gt; 
                  &lt;center&gt;
                  &lt;table border cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; width=&quot;617&quot;&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#33CC66&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td height=&quot;30&quot; nowrap colspan=&quot;7&quot;&gt; &lt;font size=&quot;+2&quot;&gt;Iteration Performance 
                  [million element accesses per second]&lt;/font&gt;&lt;br&gt;
                  &lt;font size=&quot;-1&quot;&gt;Pentium Pro 200 Mhz, SunJDK 1.2.2, NT, java -classic,&lt;br&gt;
                  200 times repeating the same iteration &lt;/font&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#33CC66&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td width=&quot;78&quot; height=&quot;30&quot; nowrap&gt; 
                  &lt;div align=&quot;left&quot;&gt; Element type&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td height=&quot;30&quot; nowrap colspan=&quot;6&quot;&gt; 
                  &lt;div align=&quot;center&quot;&gt;Matrix2D type = Java array &lt;tt&gt;double[][]&lt;/tt&gt;&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td width=&quot;78&quot; height=&quot;60&quot; nowrap bgcolor=&quot;#FF9966&quot; rowspan=&quot;2&quot;&gt; 
                  &lt;div align=&quot;left&quot;&gt; .&lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td height=&quot;132&quot; bgcolor=&quot;#FF9966&quot; colspan=&quot;2&quot;&gt; 
                  &lt;p&gt;Unoptimized Form&lt;br&gt;
                  1000 x 1000&lt;br&gt;
                  &lt;div align=&quot;left&quot;&gt; &lt;font size=&quot;-1&quot;&gt; 
                  &lt;pre&gt;
                  for (int row=0; row &lt; rows; row++) { 
                  for (int col=0; col &lt; columns; ) { 
                  value = m[row][col++];
                  ...
                  }
                  }
                  &lt;/pre&gt;
                  &lt;/font&gt; &lt;/div&gt;
                  &lt;/td&gt;
                  &lt;td height=&quot;132&quot; bgcolor=&quot;#FF9966&quot; colspan=&quot;4&quot;&gt; Optimized Form&lt;br&gt;
                  1000 x 1000 
                  &lt;div align=&quot;left&quot;&gt; &lt;font size=&quot;-1&quot;&gt; 
                  &lt;pre&gt;
                  for (int row=0; row &lt; rows; row++) { 
                  int[] r = matrix[row]; 
                  for (int col=0; col &lt; columns; ) { 
                  value = r[col++];
                  ...
                  }
                  }
                  &lt;/pre&gt;
                  &lt;/font&gt; &lt;/div&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td width=&quot;152&quot; height=&quot;30&quot; bgcolor=&quot;#FF9966&quot;&gt; getting&lt;/td&gt;
                  &lt;td width=&quot;144&quot; height=&quot;30&quot; bgcolor=&quot;#FF9966&quot;&gt; setting&lt;/td&gt;
                  &lt;td width=&quot;150&quot; height=&quot;30&quot; bgcolor=&quot;#FF9966&quot;&gt; getting&lt;/td&gt;
                  &lt;td width=&quot;138&quot; height=&quot;30&quot; bgcolor=&quot;#FF9966&quot; colspan=&quot;3&quot;&gt; setting&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td width=&quot;78&quot; height=&quot;30&quot; nowrap bgcolor=&quot;#FF9966&quot;&gt;double&lt;/td&gt;
                  &lt;td width=&quot;152&quot; height=&quot;30&quot; nowrap&gt;1.6&lt;/td&gt;
                  &lt;td width=&quot;144&quot; height=&quot;30&quot; nowrap&gt;1.8&lt;/td&gt;
                  &lt;td width=&quot;150&quot; height=&quot;30&quot; nowrap&gt;18&lt;/td&gt;
                  &lt;td width=&quot;138&quot; height=&quot;30&quot; nowrap colspan=&quot;3&quot;&gt;11&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr valign=&quot;middle&quot; bgcolor=&quot;#66CCFF&quot; nowrap align=&quot;center&quot;&gt; 
                  &lt;td width=&quot;78&quot; height=&quot;30&quot; nowrap bgcolor=&quot;#FF9966&quot;&gt; int&lt;/td&gt;
                  &lt;td width=&quot;152&quot; height=&quot;30&quot; nowrap&gt;1.5 &lt;/td&gt;
                  &lt;td width=&quot;144&quot; height=&quot;30&quot; nowrap&gt;1.8&lt;/td&gt;
                  &lt;td width=&quot;150&quot; height=&quot;30&quot; nowrap&gt;28&lt;/td&gt;
                  &lt;td width=&quot;138&quot; height=&quot;30&quot; nowrap colspan=&quot;3&quot;&gt;26&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/center&gt;
                  &lt;left&gt;                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <javadoc line="162">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="BenchmarkMatrix2D" type="constructor" line="165"/>
            <javadoc line="168">
                Runs a bench on matrices holding double elements.                
            </javadoc>
            <method name="doubleBenchmark" type="void" line="171">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="kind" type="String"/>
                    <param name="print" type="boolean"/>
                    <param name="initialCapacity" type="int"/>
                    <param name="minLoadFactor" type="double"/>
                    <param name="maxLoadFactor" type="double"/>
                </params>
                <comment line="174">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops                    
                </comment>
                <comment line="194">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="207">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="216">
                    else if (kind.equals(&quot;denseArray&quot;)) matrix = new DoubleArrayMatrix2D(rows,columns);                    
                </comment>
                <comment line="220">
                    if (kind.equals(&quot;sparse&quot;)) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;                    
                </comment>
                <comment line="238">
                    invite gc                    
                </comment>
                <comment line="247">
                    if (kind.equals(&quot;sparse&quot;)) {
                    int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
                    System.out.println(&quot;hashCollisions=&quot;+hashCollisions);
                    System.out.println(&quot;--&gt; &quot;+ ((double)hashCollisions  (rowscolumns)) +&quot; hashCollisionselement on average.&quot;);
                    }                    
                </comment>
                <comment line="256">
                    if (kind.equals(&quot;sparse&quot;)) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;                    
                </comment>
                <comment line="270">
                    if (kind.equals(&quot;sparse&quot;)) System.out.println(&quot;hashCollisions=&quot;+((SparseDoubleMatrix2D)matrix).elements.hashCollisions);                    
                </comment>
                <comment line="271">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="288">
                    if (kind.equals(&quot;sparse&quot;)) System.out.println(&quot;hashCollisions=&quot;+((SparseDoubleMatrix2D)view).elements.hashCollisions);                    
                </comment>
                <comment line="289">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="293">
                    if (kind.equals(&quot;sparse&quot;)) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;                    
                </comment>
                <comment line="295">
                    initializing                    
                </comment>
                <comment line="312">
                    invite gc                    
                </comment>
                <comment line="319">
                    if (kind.equals(&quot;sparse&quot;)) System.out.println(&quot;hashCollisions&quot;+((SparseDoubleMatrix2D)matrix).elements.hashCollisions);                    
                </comment>
                <declaration name="timer1" type="cern.colt.Timer" line="176"/>
                <declaration name="timer2" type="cern.colt.Timer" line="177"/>
                <declaration name="timer3" type="cern.colt.Timer" line="178"/>
                <declaration name="timer4" type="cern.colt.Timer" line="179"/>
                <declaration name="emptyLoop" type="cern.colt.Timer" line="180"/>
                <declaration name="emptyLoop2" type="cern.colt.Timer" line="181"/>
                <declaration name="dummy" type="int" line="184"/>
                <scope line="185">
                    <scope line="186">
                        <scope line="187"/>
                    </scope>
                </scope>
                <declaration name="dummy2" type="double" line="197"/>
                <scope line="198">
                    <scope line="199">
                        <scope line="200"/>
                    </scope>
                </scope>
                <declaration name="before" type="long" line="209"/>
                <declaration name="size" type="long" line="210"/>
                <declaration name="matrix" type="DoubleMatrix2D" line="212"/>
                <scope line="220">
                    <declaration name="value" type="int" line="225"/>
                    <scope line="226">
                        <scope line="227"/>
                    </scope>
                </scope>
                <scope line="238"/>
                <scope line="238"/>
                <declaration name="after" type="long" line="239"/>
                <scope line="242"/>
                <declaration name="element" type="double" line="257"/>
                <scope line="258">
                    <scope line="259">
                        <scope line="260"/>
                    </scope>
                </scope>
                <declaration name="view" type="DoubleMatrix2D" line="273"/>
                <scope line="276">
                    <scope line="277">
                        <scope line="278"/>
                    </scope>
                </scope>
                <scope line="293">
                    <scope line="295">
                        <scope line="296"/>
                    </scope>
                    <scope line="301">
                        <scope line="302"/>
                    </scope>
                </scope>
                <scope line="312"/>
                <scope line="312"/>
            </method>
            <javadoc line="323">
                Runs a bench on matrices holding double elements.                
            </javadoc>
            <method name="doubleBenchmarkMult" type="void" line="326">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="kind" type="String"/>
                    <param name="print" type="boolean"/>
                    <param name="initialCapacity" type="int"/>
                    <param name="minLoadFactor" type="double"/>
                    <param name="maxLoadFactor" type="double"/>
                </params>
                <comment line="329">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops                    
                </comment>
                <comment line="340">
                    else if (kind.equals(&quot;denseArray&quot;)) matrix = new DoubleArrayMatrix2D(rows,columns);                    
                </comment>
                <comment line="345">
                    if (kind.equals(&quot;sparse&quot;)) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;                    
                </comment>
                <comment line="357">
                    if (kind.equals(&quot;sparse&quot;)) {
                    int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
                    System.out.println(&quot;hashCollisions=&quot;+hashCollisions);
                    System.out.println(&quot;--&gt; &quot;+ ((double)hashCollisions  (rowscolumns)) +&quot; hashCollisionselement on average.&quot;);
                    }                    
                </comment>
                <comment line="367">
                    if (kind.equals(&quot;sparse&quot;)) ((SparseDoubleMatrix2D)matrix).elements.hashCollisions = 0;                    
                </comment>
                <comment line="379">
                    if (kind.equals(&quot;sparse&quot;)) {
                    int hashCollisions = ((SparseDoubleMatrix2D)matrix).elements.hashCollisions;
                    System.out.println(&quot;hashCollisions=&quot;+hashCollisions);
                    System.out.println(&quot;--&gt; &quot;+ ((double)hashCollisions  (rowscolumns)) +&quot; hashCollisionselement on average.&quot;);
                    }                    
                </comment>
                <declaration name="timer1" type="cern.colt.Timer" line="331"/>
                <declaration name="timer2" type="cern.colt.Timer" line="332"/>
                <declaration name="size" type="long" line="334"/>
                <declaration name="matrix" type="DoubleMatrix2D" line="336"/>
                <scope line="345"/>
                <scope line="353"/>
                <scope line="367"/>
                <scope line="375"/>
            </method>
            <javadoc line="387">
                Runs a bench on matrices holding double elements.                
            </javadoc>
            <method name="doubleBenchmarkPrimitive" type="void" line="390">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="392">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops                    
                </comment>
                <comment line="410">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="423">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="445">
                    invite gc                    
                </comment>
                <comment line="473">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="478">
                    initializing
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    matrix.setQuick(row,column,1);
                    }
                    }                    
                </comment>
                <comment line="497">
                    invite gc                    
                </comment>
                <declaration name="timer1" type="cern.colt.Timer" line="393"/>
                <declaration name="timer2" type="cern.colt.Timer" line="394"/>
                <declaration name="timer3" type="cern.colt.Timer" line="395"/>
                <declaration name="emptyLoop" type="cern.colt.Timer" line="396"/>
                <declaration name="emptyLoop2" type="cern.colt.Timer" line="397"/>
                <declaration name="dummy" type="int" line="400"/>
                <scope line="401">
                    <scope line="402">
                        <scope line="403"/>
                    </scope>
                </scope>
                <declaration name="dummy2" type="double" line="413"/>
                <scope line="414">
                    <scope line="415">
                        <scope line="416"/>
                    </scope>
                </scope>
                <declaration name="before" type="long" line="424"/>
                <declaration name="size" type="long" line="425"/>
                <declaration name="matrix" type="double[][]" line="427"/>
                <scope line="430">
                    <declaration name="value" type="int" line="432"/>
                    <scope line="433">
                        <scope line="434"/>
                    </scope>
                </scope>
                <scope line="445"/>
                <scope line="445"/>
                <declaration name="after" type="long" line="446"/>
                <scope line="448">
                    <declaration name="m" type="DenseDoubleMatrix2D" line="449"/>
                </scope>
                <declaration name="element" type="double" line="456"/>
                <scope line="457">
                    <scope line="458">
                        <scope line="459"/>
                    </scope>
                </scope>
                <scope line="467">
                    <declaration name="m" type="DenseDoubleMatrix2D" line="468"/>
                </scope>
                <scope line="476">
                    <scope line="486">
                        <scope line="487"/>
                    </scope>
                </scope>
                <scope line="497"/>
                <scope line="497"/>
                <scope line="502">
                    <declaration name="m" type="DenseDoubleMatrix2D" line="503"/>
                </scope>
            </method>
            <javadoc line="510">
                Runs a bench on matrices holding double elements.                
            </javadoc>
            <method name="doubleBenchmarkPrimitiveOptimized" type="void" line="513">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="515">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops                    
                </comment>
                <comment line="533">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="546">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="561">
                    matrix[row][column] = value++;                    
                </comment>
                <comment line="570">
                    invite gc                    
                </comment>
                <comment line="588">
                    element += matrix[row][column];                    
                </comment>
                <comment line="600">
                    !!! so that the jitter can&apos;t optimize away the whole loop                    
                </comment>
                <comment line="610">
                    matrix[row][column] = 0;                    
                </comment>
                <comment line="618">
                    invite gc                    
                </comment>
                <declaration name="timer1" type="cern.colt.Timer" line="516"/>
                <declaration name="timer2" type="cern.colt.Timer" line="517"/>
                <declaration name="timer3" type="cern.colt.Timer" line="518"/>
                <declaration name="emptyLoop" type="cern.colt.Timer" line="519"/>
                <declaration name="emptyLoop2" type="cern.colt.Timer" line="520"/>
                <declaration name="dummy" type="int" line="523"/>
                <scope line="524">
                    <scope line="525">
                        <scope line="526"/>
                    </scope>
                </scope>
                <declaration name="dummy2" type="double" line="536"/>
                <scope line="537">
                    <scope line="538">
                        <scope line="539"/>
                    </scope>
                </scope>
                <declaration name="before" type="long" line="547"/>
                <declaration name="size" type="long" line="548"/>
                <declaration name="matrix" type="double[][]" line="550"/>
                <scope line="553">
                    <declaration name="value" type="int" line="555"/>
                    <scope line="556">
                        <declaration name="r" type="double[]" line="557"/>
                        <scope line="558"/>
                    </scope>
                </scope>
                <scope line="570"/>
                <scope line="570"/>
                <declaration name="after" type="long" line="571"/>
                <scope line="573">
                    <declaration name="m" type="DenseDoubleMatrix2D" line="574"/>
                </scope>
                <declaration name="element" type="double" line="581"/>
                <scope line="582">
                    <scope line="583">
                        <declaration name="r" type="double[]" line="584"/>
                        <scope line="585"/>
                    </scope>
                </scope>
                <scope line="594">
                    <declaration name="m" type="DenseDoubleMatrix2D" line="595"/>
                </scope>
                <scope line="603">
                    <scope line="605">
                        <declaration name="r" type="double[]" line="606"/>
                        <scope line="607"/>
                    </scope>
                </scope>
                <scope line="618"/>
                <scope line="618"/>
                <scope line="623">
                    <declaration name="m" type="DenseDoubleMatrix2D" line="624"/>
                </scope>
            </method>
            <javadoc line="631">
                Runs a bench on matrices holding int elements.                
            </javadoc>
            <method name="intBenchmark" type="void" line="634">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="kind" type="String"/>
                    <param name="print" type="boolean"/>
                    <param name="initialCapacity" type="int"/>
                    <param name="minLoadFactor" type="double"/>
                    <param name="maxLoadFactor" type="double"/>
                </params>
                <comment line="637">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops
                    
                    cern.colt.Timer timer1 = new cern.colt.Timer();
                    cern.colt.Timer timer2 = new cern.colt.Timer();
                    cern.colt.Timer timer3 = new cern.colt.Timer();
                    cern.colt.Timer emptyLoop = new cern.colt.Timer();
                    cern.colt.Timer emptyLoop2 = new cern.colt.Timer();
                    
                    emptyLoop.start();
                    int dummy = 0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    dummy++;
                    }
                    }
                    }
                    emptyLoop.stop();
                    System.out.println(dummy);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    emptyLoop2.start();
                    dummy = 3;
                    int dummy2 = 0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int value = 0, column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    dummy2 += dummy;
                    }
                    }
                    }
                    emptyLoop2.stop();
                    System.out.println(dummy2);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    long before = Runtime.getRuntime().freeMemory();
                    long size = (((long)rows)columns)runs;
                    
                    AbstractIntMatrix2D  matrix = null;
                    if (kind.equals(&quot;sparse&quot;)) matrix = new SparseIntMatrix2D(rows,columns,initialCapacity,minLoadFactor,maxLoadFactor);
                    else if (kind.equals(&quot;dense&quot;)) matrix = new DenseIntMatrix2D(rows,columns);
                    else if (kind.equals(&quot;denseArray&quot;)) matrix = new DoubleArrayMatrix2D(rows,columns);
                    else throw new RuntimeException(&quot;unknown kind&quot;);
                    
                    System.out.println(&quot;\nNow filling...&quot;);
                    if (kind.equals(&quot;sparse&quot;)) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
                    for (int i=0; i&lt;runs; i++) {
                    matrix.assign(0);
                    matrix.ensureCapacity(initialCapacity);
                    if (kind.equals(&quot;sparse&quot;)) ((SparseIntMatrix2D)matrix).ensureCapacity(initialCapacity);
                    timer1.start();
                    int value = 0;
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    matrix.setQuick(row,column,value++);
                    }
                    }
                    timer1.stop();
                    }
                    timer1.display();
                    timer1.minus(emptyLoop).display();
                    System.out.println(size  timer1.minus(emptyLoop).seconds() +&quot; elements  sec&quot;);
                    
                    Runtime.getRuntime().gc();  invite gc
                    try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
                    long after = Runtime.getRuntime().freeMemory();
                    System.out.println(&quot;KB needed=&quot;+(before-after)  1024);
                    System.out.println(&quot;bytes needed per non-zero=&quot;+(before-after)  (double)matrix.cardinality());
                    if (print) {
                    System.out.println(matrix);
                    if (kind.equals(&quot;sparse&quot;)) System.out.println(&quot;map=&quot;+((SparseIntMatrix2D)matrix).elements);
                    }
                    if (kind.equals(&quot;sparse&quot;)) {
                    int hashCollisions = ((SparseIntMatrix2D)matrix).elements.hashCollisions;
                    System.out.println(&quot;hashCollisions=&quot;+hashCollisions);
                    System.out.println(&quot;--&gt; &quot;+ ((double)hashCollisions  (rowscolumns)) +&quot; probeselement on average.&quot;);
                    }
                    
                    System.out.println(&quot;\nNow reading...&quot;);
                    if (kind.equals(&quot;sparse&quot;)) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
                    timer2.start();
                    int element=0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    element += matrix.getQuick(row,column);
                    }
                    }
                    }
                    timer2.stop().display();
                    timer2.minus(emptyLoop2).display();
                    System.out.println(size  timer2.minus(emptyLoop2).seconds() +&quot; elements  sec&quot;);
                    if (print) System.out.println(matrix);
                    if (kind.equals(&quot;sparse&quot;)) System.out.println(&quot;hashCollisions=&quot;+((SparseIntMatrix2D)matrix).elements.hashCollisions);
                    System.out.println(element);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    System.out.println(&quot;\nNow removing...&quot;);
                    before = Runtime.getRuntime().freeMemory();
                    if (kind.equals(&quot;sparse&quot;)) ((SparseIntMatrix2D)matrix).elements.hashCollisions = 0;
                    for (int i=0; i&lt;runs; i++) {
                     initializing
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    matrix.setQuick(row,column,1);
                    }
                    }
                    timer3.start();
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    matrix.setQuick(row,column,0);
                    }
                    }
                    timer3.stop();
                    }
                    timer3.display();
                    timer3.minus(emptyLoop).display();
                    System.out.println(size  timer3.minus(emptyLoop).seconds() +&quot; elements  sec&quot;);
                    Runtime.getRuntime().gc();  invite gc
                    try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
                    after = Runtime.getRuntime().freeMemory();
                    System.out.println(&quot;KB needed=&quot;+(before-after)1024);
                    System.out.println(&quot;KB free=&quot;+(after1024));
                    
                    if (print) System.out.println(matrix);
                    if (kind.equals(&quot;sparse&quot;)) System.out.println(&quot;hashCollisions=&quot;+((SparseIntMatrix2D)matrix).elements.hashCollisions);
                    
                    
                    System.out.println(&quot;bye bye.&quot;);                    
                </comment>
            </method>
            <javadoc line="766">
                Runs a bench on matrices holding int elements.                
            </javadoc>
            <method name="intBenchmarkPrimitive" type="void" line="769">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="772">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops
                    cern.colt.Timer timer1 = new cern.colt.Timer();
                    cern.colt.Timer timer2 = new cern.colt.Timer();
                    cern.colt.Timer timer3 = new cern.colt.Timer();
                    cern.colt.Timer emptyLoop = new cern.colt.Timer();
                    cern.colt.Timer emptyLoop2 = new cern.colt.Timer();
                    
                    emptyLoop.start();
                    int dummy = 0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    dummy++;
                    }
                    }
                    }
                    emptyLoop.stop();
                    System.out.println(dummy);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    emptyLoop2.start();
                    dummy = 3;
                    int dummy2 = 0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    dummy2 += dummy;
                    }
                    }
                    }
                    emptyLoop2.stop();
                    System.out.println(dummy2);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    long before = Runtime.getRuntime().freeMemory();
                    long size = (((long)rows)columns)runs;
                    
                    int[][] matrix = new int[rows][columns];
                    
                    System.out.println(&quot;\nNow filling...&quot;);
                    for (int i=0; i&lt;runs; i++) {
                    timer1.start();
                    int value = 0;
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    matrix[row][column] = value++;
                    }
                    }
                    timer1.stop();
                    }
                    timer1.display();
                    timer1.minus(emptyLoop).display();
                    System.out.println(size  timer1.minus(emptyLoop).seconds() +&quot; elements  sec&quot;);
                    
                    Runtime.getRuntime().gc();  invite gc
                    try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
                    long after = Runtime.getRuntime().freeMemory();
                    System.out.println(&quot;KB needed=&quot;+(before-after)  1024);
                    if (print) {
                    DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
                    m.assign(matrix);
                    System.out.println(m);
                    }
                    
                    System.out.println(&quot;\nNow reading...&quot;);
                    timer2.start();
                    int element=0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    element += matrix[row][column];
                    }
                    }
                    }
                    timer2.stop().display();
                    timer2.minus(emptyLoop2).display();
                    System.out.println(size  timer2.minus(emptyLoop2).seconds() +&quot; elements  sec&quot;);
                    if (print) {
                    DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
                    m.assign(matrix);
                    System.out.println(m);
                    }
                    System.out.println(element);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    System.out.println(&quot;\nNow removing...&quot;);
                    before = Runtime.getRuntime().freeMemory();
                    for (int i=0; i&lt;runs; i++) {
                    timer3.start();
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    matrix[row][column] = 0;
                    }
                    }
                    timer3.stop();
                    }
                    timer3.display();
                    timer3.minus(emptyLoop).display();
                    System.out.println(size  timer3.minus(emptyLoop).seconds() +&quot; elements  sec&quot;);
                    Runtime.getRuntime().gc();  invite gc
                    try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
                    after = Runtime.getRuntime().freeMemory();
                    System.out.println(&quot;KB needed=&quot;+(before-after)1024);
                    System.out.println(&quot;KB free=&quot;+(after1024));
                    
                    if (print) {
                    DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
                    m.assign(matrix);
                    System.out.println(m);
                    }
                    
                    System.out.println(&quot;bye bye.&quot;);                    
                </comment>
            </method>
            <javadoc line="884">
                Runs a bench on matrices holding int elements.                
            </javadoc>
            <method name="intBenchmarkPrimitiveOptimized" type="void" line="887">
                <params>
                    <param name="runs" type="int"/>
                    <param name="rows" type="int"/>
                    <param name="columns" type="int"/>
                    <param name="print" type="boolean"/>
                </params>
                <comment line="890">
                    certain loops need to be constructed so that the jitter can&apos;t optimize them away and we get fantastic numbers.
                     this involves primarly read-loops
                    cern.colt.Timer timer1 = new cern.colt.Timer();
                    cern.colt.Timer timer2 = new cern.colt.Timer();
                    cern.colt.Timer timer3 = new cern.colt.Timer();
                    cern.colt.Timer emptyLoop = new cern.colt.Timer();
                    cern.colt.Timer emptyLoop2 = new cern.colt.Timer();
                    
                    emptyLoop.start();
                    int dummy = 0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    dummy++;
                    }
                    }
                    }
                    emptyLoop.stop();
                    System.out.println(dummy);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    int[][] matrix = new int[rows][columns];
                    emptyLoop2.start();
                    dummy = 3;
                    int dummy2 = 7;
                    System.out.println(dummy2);  !!! so that the jitter can&apos;t optimize away the whole loop
                    for (int i=0; i&lt;runs; i++) {
                    for (int column=0; column &lt; columns; column++) {
                    for (int row=0; row &lt; rows; row++) {
                    dummy2 += dummy; matrix[row][column];
                    }
                    }
                    }
                    emptyLoop2.stop();
                    System.out.println(dummy2);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    long before = Runtime.getRuntime().freeMemory();
                    long size = (((long)rows)columns)runs;
                    
                    
                    System.out.println(&quot;\nNow filling...&quot;);
                    for (int i=0; i&lt;runs; i++) {
                    timer1.start();
                    int value = 0;
                    for (int row=0; row &lt; rows; row++) {
                    int[] r = matrix[row];
                    for (int column=0; column &lt; columns; column++) {
                    r[column] = value++;
                    matrix[row][column] = value++;
                    }
                    }
                    timer1.stop();
                    }
                    timer1.display();
                    timer1.minus(emptyLoop).display();
                    System.out.println(size  timer1.minus(emptyLoop).seconds() +&quot; elements  sec&quot;);
                    
                    Runtime.getRuntime().gc();  invite gc
                    try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
                    long after = Runtime.getRuntime().freeMemory();
                    System.out.println(&quot;KB needed=&quot;+(before-after)  1024);
                    if (print) {
                    DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
                    m.assign(matrix);
                    System.out.println(m);
                    }
                    
                    System.out.println(&quot;\nNow reading...&quot;);
                    timer2.start();
                    int element=0;
                    for (int i=0; i&lt;runs; i++) {
                    for (int row=0; row &lt; rows; row++) {
                    int[] r = matrix[row];
                    for (int column=0; column &lt; columns; column++) {
                    element += r[column];
                    element += matrix[row][column];
                    }
                    }
                    }
                    timer2.stop().display();
                    timer2.minus(emptyLoop2).display();
                    System.out.println(size  timer2.minus(emptyLoop2).seconds() +&quot; elements  sec&quot;);
                    if (print) {
                    DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
                    m.assign(matrix);
                    System.out.println(m);
                    }
                    System.out.println(element);  !!! so that the jitter can&apos;t optimize away the whole loop
                    
                    System.out.println(&quot;\nNow removing...&quot;);
                    before = Runtime.getRuntime().freeMemory();
                    for (int i=0; i&lt;runs; i++) {
                    timer3.start();
                    for (int row=0; row &lt; rows; row++) {
                    int[] r = matrix[row];
                    for (int column=0; column &lt; columns; column++) {
                    r[column] = 0;
                    matrix[row][column] = 0;
                    }
                    }
                    timer3.stop();
                    }
                    timer3.display();
                    timer3.minus(emptyLoop).display();
                    System.out.println(size  timer3.minus(emptyLoop).seconds() +&quot; elements  sec&quot;);
                    Runtime.getRuntime().gc();  invite gc
                    try { Thread.currentThread().sleep(1000); } catch (InterruptedException exc) {};
                    after = Runtime.getRuntime().freeMemory();
                    System.out.println(&quot;KB needed=&quot;+(before-after)1024);
                    System.out.println(&quot;KB free=&quot;+(after1024));
                    
                    if (print) {
                    DenseIntMatrix2D m = new DenseIntMatrix2D(rows,columns);
                    m.assign(matrix);
                    System.out.println(m);
                    }
                    
                    System.out.println(&quot;bye bye.&quot;);                    
                </comment>
            </method>
            <javadoc line="1009">
                Benchmarks various methods of this class.                
            </javadoc>
            <method name="main" type="void" line="1012">
                <params>
                    <param name="args" type="String"/>
                </params>
                <comment line="1017">
                    int size = Integer.parseInt(args[3]);
                    boolean isSparse = args[4].equals(&quot;sparse&quot;);                    
                </comment>
                <declaration name="runs" type="int" line="1013"/>
                <declaration name="rows" type="int" line="1014"/>
                <declaration name="columns" type="int" line="1015"/>
                <declaration name="kind" type="String" line="1018"/>
                <declaration name="initialCapacity" type="int" line="1019"/>
                <declaration name="minLoadFactor" type="double" line="1020"/>
                <declaration name="maxLoadFactor" type="double" line="1021"/>
                <declaration name="print" type="boolean" line="1022"/>
                <declaration name="type" type="String" line="1023"/>
                <declaration name="command" type="String" line="1024"/>
                <scope line="1026"/>
                <scope line="1031"/>
            </method>
        </class>
    </source>