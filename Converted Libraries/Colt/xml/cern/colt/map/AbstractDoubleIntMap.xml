<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.map">
        <import package="cern.colt.function.DoubleIntProcedure"/>
        <import package="cern.colt.function.DoubleProcedure"/>
        <import package="cern.colt.list.DoubleArrayList"/>
        <import package="cern.colt.list.IntArrayList"/>
        <class name="AbstractDoubleIntMap" line="15">
            <extends class="AbstractMap"/>
            <comment line="30">
                public static int hashCollisions = 0; // for debug only                
            </comment>
            <javadoc line="15">
                Abstract base class for hash maps holding (key,value) associations of type &lt;tt&gt;(double--&gt;int)&lt;/tt&gt;.
                  First see the &lt;a href=&quot;package-summary.html&quot;&gt;package summary&lt;/a&gt; and javadoc &lt;a href=&quot;package-tree.html&quot;&gt;tree view&lt;/a&gt; to get the broad picture.
                  &lt;p&gt;
                  &lt;b&gt;Implementation&lt;/b&gt;:
                  &lt;p&gt;
                  Almost all methods are expressed in terms of {@link #forEachKey(DoubleProcedure)}. 
                  As such they are fully functional, but inefficient. Override them in subclasses if necessary.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
                <see>
                    java.util.HashMap                    
                </see>
            </javadoc>
            <javadoc line="30">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="AbstractDoubleIntMap" type="constructor" line="33"/>
            <javadoc line="34">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the receiver contains the specified key.                
                <return>
                    <tt>true</tt> if the receiver contains the specified key.                    
                </return>
            </javadoc>
            <method name="containsKey" type="boolean" line="39">
                <params>
                    <param name="key" type="double"/>
                </params>
                <anonymous_class line="41">
                    <method name="apply" type="boolean" line="42">
                        <params>
                            <param name="iterKey" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="48">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the receiver contains the specified value.                
                <return>
                    <tt>true</tt> if the receiver contains the specified value.                    
                </return>
            </javadoc>
            <method name="containsValue" type="boolean" line="53">
                <params>
                    <param name="value" type="int"/>
                </params>
                <anonymous_class line="55">
                    <method name="apply" type="boolean" line="56">
                        <params>
                            <param name="iterKey" type="double"/>
                            <param name="iterValue" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="62">
                Returns a deep copy of the receiver; uses &lt;code&gt;clone()&lt;/code&gt; and casts the result.                
                <return>
                    a deep copy of the receiver.                    
                </return>
            </javadoc>
            <method name="copy" type="AbstractDoubleIntMap" line="67"/>
            <javadoc line="70">
                Compares the specified object with this map for equality.  Returns
                  &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map and the two maps
                  represent the same mappings.  More formally, two maps &lt;tt&gt;m1&lt;/tt&gt; and
                  &lt;tt&gt;m2&lt;/tt&gt; represent the same mappings iff
                  &lt;pre&gt;
                  m1.forEachPair(
                  new DoubleIntProcedure() {
                  public boolean apply(double key, int value) {
                  return m2.containsKey(key) &amp;&amp; m2.get(key) == value;
                  }
                  }
                  )
                  &amp;&amp;
                  m2.forEachPair(
                  new DoubleIntProcedure() {
                  public boolean apply(double key, int value) {
                  return m1.containsKey(key) &amp;&amp; m1.get(key) == value;
                  }
                  }
                  );
                  &lt;/pre&gt;
                  This implementation first checks if the specified object is this map;
                  if so it returns &lt;tt&gt;true&lt;/tt&gt;.  Then, it checks if the specified
                  object is a map whose size is identical to the size of this set; if
                  not, it it returns &lt;tt&gt;false&lt;/tt&gt;.  If so, it applies the iteration as described above.                
                <param>
                    obj object to be compared for equality with this map.                    
                </param>
                <return>
                    <tt>true</tt> if the specified object is equal to this map.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="101">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="other" type="AbstractDoubleIntMap" line="105"/>
                <anonymous_class line="110">
                    <method name="apply" type="boolean" line="111">
                        <params>
                            <param name="key" type="double"/>
                            <param name="value" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <anonymous_class line="118">
                    <method name="apply" type="boolean" line="119">
                        <params>
                            <param name="key" type="double"/>
                            <param name="value" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <method name="forEachKey" type="boolean" line="125"/>
            <javadoc line="125">
                Applies a procedure to each key of the receiver, if any.
                  Note: Iterates over the keys in no particular order.
                  Subclasses can define a particular order, for example, &quot;sorted by key&quot;.
                  All methods which &lt;i&gt;can&lt;/i&gt; be expressed in terms of this method (most methods can) &lt;i&gt;must guarantee&lt;/i&gt; to use the &lt;i&gt;same&lt;/i&gt; order defined by this method, even if it is no particular order.
                  This is necessary so that, for example, methods &lt;tt&gt;keys&lt;/tt&gt; and &lt;tt&gt;values&lt;/tt&gt; will yield association pairs, not two uncorrelated lists.                
                <param>
                    procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </param>
                <return>
                    <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.                    
                </return>
            </javadoc>
            <javadoc line="136">
                Applies a procedure to each (key,value) pair of the receiver, if any.
                  Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.                
                <param>
                    procedure    the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise continues.                    
                </param>
                <return>
                    <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.                    
                </return>
            </javadoc>
            <method name="forEachPair" type="boolean" line="143">
                <params>
                    <param name="procedure" type="DoubleIntProcedure"/>
                </params>
                <anonymous_class line="145">
                    <method name="apply" type="boolean" line="146">
                        <params>
                            <param name="key" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <method name="get" type="int" line="152"/>
            <javadoc line="152">
                Returns the value associated with the specified key.
                  It is often a good idea to first check with {@link #containsKey(double)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not.                
                <param>
                    key the key to be searched for.                    
                </param>
                <return>
                    the value associated with the specified key; <tt>0</tt> if no such key is present.                    
                </return>
            </javadoc>
            <javadoc line="160">
                Returns the first key the given value is associated with.
                  It is often a good idea to first check with {@link #containsValue(int)} whether there exists an association from a key to this value.
                  Search order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.                
                <param>
                    value the value to search for.                    
                </param>
                <return>
                    the first key for which holds <tt>get(key) == value</tt>; 
                      returns <tt>Double.NaN</tt> if no such key exists.                    
                </return>
            </javadoc>
            <method name="keyOf" type="double" line="169">
                <params>
                    <param name="value" type="int"/>
                </params>
                <declaration name="foundKey" type="double[]" line="170"/>
                <anonymous_class line="172">
                    <method name="apply" type="boolean" line="173">
                        <params>
                            <param name="iterKey" type="double"/>
                            <param name="iterValue" type="int"/>
                        </params>
                        <declaration name="found" type="boolean" line="174"/>
                    </method>
                </anonymous_class>
                <declaration name="notFound" type="boolean" line="171"/>
            </method>
            <javadoc line="183">
                Returns a list filled with all keys contained in the receiver.
                  The returned list has a size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  Note: Keys are filled into the list in no particular order.
                  However, the order is &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.
                  &lt;p&gt;
                  This method can be used to iterate over the keys of the receiver.                
                <return>
                    the keys.                    
                </return>
            </javadoc>
            <method name="keys" type="DoubleArrayList" line="193">
                <declaration name="list" type="DoubleArrayList" line="194"/>
            </method>
            <javadoc line="198">
                Fills all keys contained in the receiver into the specified list.
                  Fills the list, starting at index 0.
                  After this call returns the specified list has a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.
                  &lt;p&gt;
                  This method can be used to iterate over the keys of the receiver.                
                <param>
                    list the list to be filled, can have any size.                    
                </param>
            </javadoc>
            <method name="keys" type="void" line="208">
                <params>
                    <param name="list" type="DoubleArrayList"/>
                </params>
                <anonymous_class line="211">
                    <method name="apply" type="boolean" line="212">
                        <params>
                            <param name="key" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="219">
                Fills all keys &lt;i&gt;sorted ascending by their associated value&lt;/i&gt; into the specified list.
                  Fills into the list, starting at index 0.
                  After this call returns the specified list has a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  Primary sort criterium is &quot;value&quot;, secondary sort criterium is &quot;key&quot;. 
                  This means that if any two values are equal, the smaller key comes first.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;br&gt;
                  &lt;tt&gt;keys = (8,7,6), values = (1,2,2) --&gt; keyList = (8,6,7)&lt;/tt&gt;                
                <param>
                    keyList the list to be filled, can have any size.                    
                </param>
            </javadoc>
            <method name="keysSortedByValue" type="void" line="232">
                <params>
                    <param name="keyList" type="DoubleArrayList"/>
                </params>
            </method>
            <javadoc line="235">
                Fills all pairs satisfying a given condition into the specified lists.
                  Fills into the lists, starting at index 0.
                  After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
                  Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;br&gt;
                  &lt;pre&gt;
                  DoubleIntProcedure condition = new DoubleIntProcedure() { // match even values only
                  public boolean apply(double key, int value) { return value%2==0; }
                  }
                  keys = (8,7,6), values = (1,2,2) --&gt; keyList = (6,8), valueList = (2,1)&lt;/tt&gt;
                  &lt;/pre&gt;                
                <param>
                    condition    the condition to be matched. Takes the current key as first and the current value as second argument.                    
                </param>
                <param>
                    keyList the list to be filled with keys, can have any size.                    
                </param>
                <param>
                    valueList the list to be filled with values, can have any size.                    
                </param>
            </javadoc>
            <method name="pairsMatching" type="void" line="254">
                <params>
                    <param name="condition" type="DoubleIntProcedure"/>
                    <param name="keyList" type="DoubleArrayList"/>
                    <param name="valueList" type="IntArrayList"/>
                </params>
                <anonymous_class line="259">
                    <method name="apply" type="boolean" line="260">
                        <params>
                            <param name="key" type="double"/>
                            <param name="value" type="int"/>
                        </params>
                        <scope line="261"/>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="270">
                Fills all keys and values &lt;i&gt;sorted ascending by key&lt;/i&gt; into the specified lists.
                  Fills into the lists, starting at index 0.
                  After this call returns the specified lists both have a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;br&gt;
                  &lt;tt&gt;keys = (8,7,6), values = (1,2,2) --&gt; keyList = (6,7,8), valueList = (2,2,1)&lt;/tt&gt;                
                <param>
                    keyList the list to be filled with keys, can have any size.                    
                </param>
                <param>
                    valueList the list to be filled with values, can have any size.                    
                </param>
            </javadoc>
            <method name="pairsSortedByKey" type="void" line="282">
                <params>
                    <param name="keyList" type="DoubleArrayList"/>
                    <param name="valueList" type="IntArrayList"/>
                </params>
                <comment line="284">
                    keys(keyList);
                    values(valueList);
                    
                    final double[] k = keyList.elements();
                    final int[] v = valueList.elements();
                    cern.colt.Swapper swapper = new cern.colt.Swapper() {
                    public void swap(int a, int b) {
                    int t1;	double t2;
                    t1 = v[a]; v[a] = v[b]; v[b] = t1;
                    t2 = k[a]; k[a] = k[b];	k[b] = t2;
                    }
                    };
                    
                    cern.colt.function.IntComparator comp = new cern.colt.function.IntComparator() {
                    public int compare(int a, int b) {
                    return k[a]&lt;k[b] ? -1 : k[a]==k[b] ? 0 : 1;
                    }
                    };
                    cern.colt.MultiSorting.sort(0,keyList.size(),comp,swapper);                    
                </comment>
                <comment line="308">
                    this variant may be quicker
                    cern.colt.map.OpenDoubleIntHashMap.hashCollisions = 0;
                    System.out.println(&quot;collisions=&quot;+cern.colt.map.OpenDoubleIntHashMap.hashCollisions);                    
                </comment>
                <comment line="317">
                    System.out.println(&quot;collisions=&quot;+cern.colt.map.OpenDoubleIntHashMap.hashCollisions);                    
                </comment>
                <scope line="313"/>
            </method>
            <javadoc line="319">
                Fills all keys and values &lt;i&gt;sorted ascending by value&lt;/i&gt; into the specified lists.
                  Fills into the lists, starting at index 0.
                  After this call returns the specified lists both have a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  Primary sort criterium is &quot;value&quot;, secondary sort criterium is &quot;key&quot;. 
                  This means that if any two values are equal, the smaller key comes first.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;br&gt;
                  &lt;tt&gt;keys = (8,7,6), values = (1,2,2) --&gt; keyList = (8,6,7), valueList = (1,2,2)&lt;/tt&gt;                
                <param>
                    keyList the list to be filled with keys, can have any size.                    
                </param>
                <param>
                    valueList the list to be filled with values, can have any size.                    
                </param>
            </javadoc>
            <method name="pairsSortedByValue" type="void" line="333">
                <params>
                    <param name="keyList" type="DoubleArrayList"/>
                    <param name="valueList" type="IntArrayList"/>
                </params>
                <comment line="354">
                    cern.colt.map.OpenDoubleIntHashMap.hashCollisions = 0;                    
                </comment>
                <comment line="356">
                    System.out.println(&quot;collisions=&quot;+cern.colt.map.OpenDoubleIntHashMap.hashCollisions);                    
                </comment>
                <declaration name="k" type="double[]" line="337"/>
                <declaration name="v" type="int[]" line="338"/>
                <anonymous_class line="339">
                    <method name="swap" type="void" line="340">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="t1" type="int" line="341"/>
                        <declaration name="t2" type="double" line="341"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="cern.colt.Swapper" line="339"/>
                <anonymous_class line="347">
                    <method name="compare" type="int" line="348">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="cern.colt.function.IntComparator" line="347"/>
            </method>
            <method name="put" type="boolean" line="357"/>
            <javadoc line="357">
                Associates the given key with the given value.
                  Replaces any old &lt;tt&gt;(key,someOtherValue)&lt;/tt&gt; association, if existing.                
                <param>
                    key the key the value shall be associated with.                    
                </param>
                <param>
                    value the value to be associated.                    
                </param>
                <return>
                    <tt>true</tt> if the receiver did not already contain such a key;
                      <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.                    
                </return>
            </javadoc>
            <method name="removeKey" type="boolean" line="367"/>
            <javadoc line="367">
                Removes the given key with its associated element from the receiver, if present.                
                <param>
                    key the key to be removed from the receiver.                    
                </param>
                <return>
                    <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise.                    
                </return>
            </javadoc>
            <javadoc line="374">
                Returns a string representation of the receiver, containing
                  the String representation of each key-value pair, sorted ascending by key.                
            </javadoc>
            <method name="toString" type="String" line="378">
                <declaration name="theKeys" type="DoubleArrayList" line="379"/>
                <declaration name="buf" type="StringBuffer" line="382"/>
                <declaration name="maxIndex" type="int" line="384"/>
                <scope line="385">
                    <declaration name="key" type="double" line="386"/>
                </scope>
            </method>
            <javadoc line="395">
                Returns a string representation of the receiver, containing
                  the String representation of each key-value pair, sorted ascending by value.                
            </javadoc>
            <method name="toStringByValue" type="String" line="399">
                <declaration name="theKeys" type="DoubleArrayList" line="400"/>
                <declaration name="buf" type="StringBuffer" line="403"/>
                <declaration name="maxIndex" type="int" line="405"/>
                <scope line="406">
                    <declaration name="key" type="double" line="407"/>
                </scope>
            </method>
            <javadoc line="416">
                Returns a list filled with all values contained in the receiver.
                  The returned list has a size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.
                  &lt;p&gt;
                  This method can be used to iterate over the values of the receiver.                
                <return>
                    the values.                    
                </return>
            </javadoc>
            <method name="values" type="IntArrayList" line="425">
                <declaration name="list" type="IntArrayList" line="426"/>
            </method>
            <javadoc line="430">
                Fills all values contained in the receiver into the specified list.
                  Fills the list, starting at index 0.
                  After this call returns the specified list has a new size that equals &lt;tt&gt;this.size()&lt;/tt&gt;.
                  Iteration order is guaranteed to be &lt;i&gt;identical&lt;/i&gt; to the order used by method {@link #forEachKey(DoubleProcedure)}.
                  &lt;p&gt;
                  This method can be used to iterate over the values of the receiver.                
                <param>
                    list the list to be filled, can have any size.                    
                </param>
            </javadoc>
            <method name="values" type="void" line="440">
                <params>
                    <param name="list" type="IntArrayList"/>
                </params>
                <anonymous_class line="443">
                    <method name="apply" type="boolean" line="444">
                        <params>
                            <param name="key" type="double"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
        </class>
    </source>