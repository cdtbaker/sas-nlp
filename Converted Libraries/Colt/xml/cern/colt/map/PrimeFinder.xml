<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.map">
        <class name="PrimeFinder" line="2">
            <extends class="Object"/>
            <javadoc line="2">
                Not of interest for users; only for implementors of hashtables.
                  Used to keep hash table capacities prime numbers.
                  &lt;p&gt;Choosing prime numbers as hash table capacities is a good idea to keep them working fast,
                  particularly under hash table expansions.
                  &lt;p&gt;However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to keep capacities prime.
                  This class provides efficient means to choose prime capacities.
                  &lt;p&gt;Choosing a prime is &lt;tt&gt;O(log 300)&lt;/tt&gt; (binary search in a list of 300 int&apos;s).
                  Memory requirements: 1 KB static memory.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <declaration name="largestPrime" type="int" line="15"/>
            <javadoc line="15">
                The largest prime this class can generate; currently equal to &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.                
            </javadoc>
            <declaration name="primeCapacities" type="int[]" line="19"/>
            <javadoc line="19">
                The prime number list consists of 11 chunks.
                  Each chunk contains prime numbers.
                  A chunk starts with a prime P1. The next element is a prime P2. P2 is the smallest prime for which holds: P2 &gt;= 2P1.
                  The next element is P3, for which the same holds with respect to P2, and so on.
                  Chunks are chosen such that for any desired capacity &gt;= 1000 
                  the list includes a prime number &lt;= desired capacity  1.11 (11%).
                  For any desired capacity &gt;= 200 
                  the list includes a prime number &lt;= desired capacity  1.16 (16%).
                  For any desired capacity &gt;= 16
                  the list includes a prime number &lt;= desired capacity  1.21 (21%).
                  Therefore, primes can be retrieved which are quite close to any desired capacity,
                  which in turn avoids wasting memory.
                  For example, the list includes 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081.
                  So if you need a prime &gt;= 1040, you will find a prime &lt;= 10401.11=1154.
                  Chunks are chosen such that they are optimized for a hashtable growthfactor of 2.0;
                  If your hashtable has such a growthfactor then,  
                  after initially &quot;rounding to a prime&quot; upon hashtable construction, 
                  it will later expand to prime capacities such that there exist no better primes.
                  In total these are about 3210=320 numbers -&gt; 1 KB of static memory needed.
                  If you are stingy, then delete every second or fourth chunk.                
            </javadoc>
            <scope line="42"/>
            <javadoc line="45">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="PrimeFinder" type="constructor" line="48"/>
            <javadoc line="50">
                Tests correctness. Try 
                  from=1000, to=10000
                  from=200,  to=1000
                  from=16,   to=1000
                  from=1000, to=Integer.MAX_VALUE                
            </javadoc>
            <method name="main" type="void" line="57">
                <params>
                    <param name="args" type="String"/>
                </params>
                <declaration name="from" type="int" line="58"/>
                <declaration name="to" type="int" line="59"/>
            </method>
            <javadoc line="62">
                Returns a prime number which is &lt;code&gt;&amp;gt;= desiredCapacity&lt;/code&gt; and very close to &lt;code&gt;desiredCapacity&lt;/code&gt; (within 11% if &lt;code&gt;desiredCapacity &amp;gt;= 1000&lt;/code&gt;).                
                <param>
                    desiredCapacity the capacity desired by the user.                    
                </param>
                <return>
                    the capacity which should be used for a hashtable.                    
                </return>
            </javadoc>
            <method name="nextPrime" type="int" line="67">
                <params>
                    <param name="desiredCapacity" type="int"/>
                </params>
                <declaration name="i" type="int" line="68"/>
                <scope line="69"/>
            </method>
            <javadoc line="74">
                Tests correctness.                
            </javadoc>
            <method name="statistics" type="void" line="77">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <scope line="78"/>
                <declaration name="accDeviation" type="double" line="81"/>
                <declaration name="maxDeviation" type="double" line="82"/>
                <scope line="83">
                    <declaration name="primeCapacity" type="int" line="84"/>
                    <declaration name="deviation" type="double" line="85"/>
                    <scope line="86"/>
                </scope>
                <declaration name="width" type="long" line="92"/>
                <declaration name="meanDeviation" type="double" line="93"/>
            </method>
        </class>
    </source>