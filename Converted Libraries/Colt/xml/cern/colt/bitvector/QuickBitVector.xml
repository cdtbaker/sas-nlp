<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.bitvector">
        <class name="QuickBitVector" line="11">
            <extends class="Object"/>
            <comment line="33">
                64=2^6                
            </comment>
            <comment line="34">
                = 1 &lt;&lt; ADDRESS_BITS_PER_UNIT                
            </comment>
            <comment line="35">
                = BITS_PER_UNIT - 1;                
            </comment>
            <comment line="37">
                precompute bitmasks for speed                
            </comment>
            <javadoc line="11">
                Implements quick non polymorphic non bounds checking low level bitvector operations.
                  Includes some operations that interpret sub-bitstrings as long integers.
                  &lt;p&gt;
                  &lt;b&gt;WARNING: Methods of this class do not check preconditions.&lt;/b&gt;
                  Provided with invalid parameters these method may return (or set) invalid values without throwing any exception.
                  &lt;b&gt;You should only use this class when performance is critical and you are absolutely sure that indexes are within bounds.&lt;/b&gt;
                  &lt;p&gt;	 
                  A bitvector is modelled as a long array, i.e. &lt;tt&gt;long[] bits&lt;/tt&gt; holds bits of a bitvector.
                  Each long value holds 64 bits.
                  The i-th bit is stored in bits[i/64] at
                  bit position i % 64 (where bit position 0 refers to the least
                  significant bit and 63 refers to the most significant bit).                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
                <see>
                    BitVector                    
                </see>
                <see>
                    BitMatrix                    
                </see>
                <see>
                    java.util.BitSet                    
                </see>
            </javadoc>
            <declaration name="ADDRESS_BITS_PER_UNIT" type="int" line="32"/>
            <declaration name="BITS_PER_UNIT" type="int" line="33"/>
            <declaration name="BIT_INDEX_MASK" type="int" line="34"/>
            <declaration name="pows" type="long[]" line="36"/>
            <javadoc line="37">
                Makes this class non instantiable, but still inheritable.                
            </javadoc>
            <method name="QuickBitVector" type="constructor" line="40"/>
            <javadoc line="42">
                Returns a bit mask with bits in the specified range set to 1, all the rest set to 0.
                  In other words, returns a bit mask having 0,1,2,3,...,64 bits set.
                  If &lt;tt&gt;to-from+1==0&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).
                  Precondition (not checked): &lt;tt&gt;to-from+1 &amp;gt;= 0 &amp;&amp; to-from+1 &amp;lt;= 64&lt;/tt&gt;.                
                <param>
                    from index of start bit (inclusive)                    
                </param>
                <param>
                    to index of end bit (inclusive).                    
                </param>
                <return>
                    the bit mask having all bits between <tt>from</tt> and <tt>to</tt> set to 1.                    
                </return>
            </javadoc>
            <method name="bitMaskWithBitsSetFromTo" type="long" line="52">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="55">
                    This turned out to be slower:                    
                </comment>
                <comment line="56">
                    0xffffffffffffffffL == ~0L == -1L == all 64 bits set.                    
                </comment>
                <comment line="57">
                    int width;                    
                </comment>
                <comment line="58">
                    return (width=to-from+1) == 0 ? 0L : (0xffffffffffffffffL &gt;&gt;&gt; (BITS_PER_UNIT-width)) &lt;&lt; from;                    
                </comment>
            </method>
            <javadoc line="60">
                Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the &quot;clear&quot; (&lt;tt&gt;false&lt;/tt&gt;) state.                
                <param>
                    bits   the bitvector.                    
                </param>
                <param>
                    bitIndex   the index of the bit to be cleared.                    
                </param>
            </javadoc>
            <method name="clear" type="void" line="66">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="69">
                Returns from the bitvector the value of the bit with the specified index.
                  The value is &lt;tt&gt;true&lt;/tt&gt; if the bit with the index &lt;tt&gt;bitIndex&lt;/tt&gt; 
                  is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.                
                <param>
                    bits   the bitvector.                    
                </param>
                <param>
                    bitIndex   the bit index.                    
                </param>
                <return>
                    the value of the bit with the specified index.                    
                </return>
            </javadoc>
            <method name="get" type="boolean" line="78">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="81">
                Returns a long value representing bits of a bitvector from index &lt;tt&gt;from&lt;/tt&gt; to index &lt;tt&gt;to&lt;/tt&gt;.
                  Bits are returned as a long value with the return value having bit 0 set to bit &lt;code&gt;from&lt;/code&gt;, ..., bit &lt;code&gt;to-from&lt;/code&gt; set to bit &lt;code&gt;to&lt;/code&gt;.
                  All other bits of return value are set to 0.
                  If &lt;tt&gt;from &amp;gt; to&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).
                  Precondition (not checked): &lt;tt&gt;to-from+1 &amp;lt;= 64&lt;/tt&gt;.                
                <param>
                    bits the bitvector.                    
                </param>
                <param>
                    from index of start bit (inclusive).                    
                </param>
                <param>
                    to index of end bit (inclusive).                    
                </param>
                <return>
                    the specified bits as long value.                    
                </return>
            </javadoc>
            <method name="getLongFromTo" type="long" line="92">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="95">
                    equivalent to from/64                    
                </comment>
                <comment line="97">
                    equivalent to from%64                    
                </comment>
                <comment line="99">
                    this is equivalent to the above, but slower:                    
                </comment>
                <comment line="100">
                    final int fromIndex=from/BITS_PER_UNIT;                    
                </comment>
                <comment line="101">
                    final int toIndex=to/BITS_PER_UNIT;                    
                </comment>
                <comment line="102">
                    final int fromOffset=from%BITS_PER_UNIT;                    
                </comment>
                <comment line="103">
                    final int toOffset=to%BITS_PER_UNIT;                    
                </comment>
                <comment line="107">
                    range does not cross unit boundaries; value to retrieve is contained in one single long value.                    
                </comment>
                <comment line="113">
                    range crosses unit boundaries; value to retrieve is spread over two long values.                    
                </comment>
                <comment line="114">
                    get part from first long value                    
                </comment>
                <comment line="118">
                    get part from second long value                    
                </comment>
                <comment line="122">
                    combine                    
                </comment>
                <declaration name="fromIndex" type="int" line="95"/>
                <declaration name="toIndex" type="int" line="96"/>
                <declaration name="fromOffset" type="int" line="97"/>
                <declaration name="toOffset" type="int" line="98"/>
                <declaration name="mask" type="long" line="106"/>
                <scope line="107"/>
                <declaration name="x1" type="long" line="116"/>
                <declaration name="x2" type="long" line="120"/>
            </method>
            <javadoc line="125">
                Returns the index of the least significant bit in state &quot;true&quot;.
                  Returns 32 if no bit is in state &quot;true&quot;.
                  Examples: 
                  &lt;pre&gt;
                  0x80000000 --&gt; 31
                  0x7fffffff --&gt; 0
                  0x00000001 --&gt; 0
                  0x00000000 --&gt; 32
                  &lt;/pre&gt;                
            </javadoc>
            <method name="leastSignificantBit" type="int" line="136">
                <params>
                    <param name="value" type="int"/>
                </params>
                <declaration name="i" type="int" line="137"/>
            </method>
            <javadoc line="141">
                Constructs a low level bitvector that holds &lt;tt&gt;size&lt;/tt&gt; elements, with each element taking &lt;tt&gt;bitsPerElement&lt;/tt&gt; bits.                
                <param>
                    size   the number of elements to be stored in the bitvector (must be &gt;= 0).                    
                </param>
                <param>
                    bitsPerElement   the number of bits one single element takes.                    
                </param>
                <return>
                    a low level bitvector.                    
                </return>
            </javadoc>
            <method name="makeBitVector" type="long[]" line="148">
                <params>
                    <param name="size" type="int"/>
                    <param name="bitsPerElement" type="int"/>
                </params>
                <declaration name="nBits" type="int" line="149"/>
                <declaration name="unitIndex" type="int" line="150"/>
                <declaration name="bitVector" type="long[]" line="151"/>
            </method>
            <javadoc line="154">
                Returns the index of the most significant bit in state &quot;true&quot;.
                  Returns -1 if no bit is in state &quot;true&quot;.
                  Examples: 
                  &lt;pre&gt;
                  0x80000000 --&gt; 31
                  0x7fffffff --&gt; 30
                  0x00000001 --&gt; 0
                  0x00000000 --&gt; -1
                  &lt;/pre&gt;                
            </javadoc>
            <method name="mostSignificantBit" type="int" line="165">
                <params>
                    <param name="value" type="int"/>
                </params>
                <declaration name="i" type="int" line="166"/>
            </method>
            <javadoc line="170">
                Returns the index within the unit that contains the given bitIndex.                
            </javadoc>
            <method name="offset" type="int" line="173">
                <params>
                    <param name="bitIndex" type="int"/>
                </params>
                <comment line="175">
                    equivalent to bitIndex%64                    
                </comment>
            </method>
            <javadoc line="177">
                Initializes a table with numbers having 1,2,3,...,64 bits set.
                  pows[i] has bits [0..i-1] set.
                  pows[64] == -1L == ~0L == has all 64 bits set --&gt; correct.
                  to speedup calculations in subsequent methods.                
            </javadoc>
            <method name="precomputePows" type="long[]" line="183">
                <comment line="188">
                    System.out.println((i)+&quot;:&quot;+pows[i]);                    
                </comment>
                <comment line="191">
                    System.out.println((0)+&quot;:&quot;+pows[0]);                    
                </comment>
                <comment line="194">
                    OLD STUFF                    
                </comment>
                <comment line="195">
                    for (int i=BITS_PER_UNIT+1; --i &gt;= 0; ) {
                    pows[i]=value;
                    value = value &gt;&gt;&gt; 1;
                    System.out.println((i)+&quot;:&quot;+pows[i]);
                    }                    
                </comment>
                <comment line="203">
                    long[] pows=new long[BITS_PER_UNIT];
                    for (int i=0; i&lt;BITS_PER_UNIT-1; i++) {
                    pows[i]=Math.round(Math.pow(2.0,i+1))-1;
                    System.out.println((i)+&quot;:&quot;+pows[i]);
                    }
                    pows[BITS_PER_UNIT-1] = ~0L;
                    System.out.println((BITS_PER_UNIT-1)+&quot;:&quot;+pows[BITS_PER_UNIT-1]);
                    return pows;                    
                </comment>
                <declaration name="pows" type="long[]" line="184"/>
                <declaration name="value" type="long" line="185"/>
                <scope line="186"/>
            </method>
            <javadoc line="214">
                Sets the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <param>
                    bits   the bitvector.                    
                </param>
                <param>
                    bitIndex   the index of the bit to be changed.                    
                </param>
                <param>
                    value   the value to be stored in the bit.                    
                </param>
            </javadoc>
            <method name="put" type="void" line="221">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="bitIndex" type="int"/>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="227">
                Sets bits of a bitvector from index &lt;code&gt;from&lt;/code&gt; to index &lt;code&gt;to&lt;/code&gt; to the bits of &lt;code&gt;value&lt;/code&gt;.
                  Bit &lt;code&gt;from&lt;/code&gt; is set to bit 0 of &lt;code&gt;value&lt;/code&gt;, ..., bit &lt;code&gt;to&lt;/code&gt; is set to bit &lt;code&gt;to-from&lt;/code&gt; of &lt;code&gt;value&lt;/code&gt;.
                  All other bits stay unaffected.
                  If &lt;tt&gt;from &amp;gt; to&lt;/tt&gt; then does nothing.
                  Precondition (not checked): &lt;tt&gt;to-from+1 &amp;lt;= 64&lt;/tt&gt;.                
                <param>
                    bits the bitvector.                    
                </param>
                <param>
                    value the value to be copied into the bitvector.                    
                </param>
                <param>
                    from index of start bit (inclusive).                    
                </param>
                <param>
                    to index of end bit (inclusive).                    
                </param>
            </javadoc>
            <method name="putLongFromTo" type="void" line="239">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="value" type="long"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="242">
                    equivalent to from/64                    
                </comment>
                <comment line="244">
                    equivalent to from%64                    
                </comment>
                <comment line="246">
                    this is equivalent to the above, but slower:
                    int fromIndex=fromBITS_PER_UNIT;
                    int toIndex=toBITS_PER_UNIT;
                    int fromOffset=from%BITS_PER_UNIT;
                    int toOffset=to%BITS_PER_UNIT;                    
                </comment>
                <comment line="254">
                    make sure all unused bits to the left are cleared.                    
                </comment>
                <comment line="261">
                    range does not cross unit boundaries; should go into one single long value.                    
                </comment>
                <comment line="269">
                    range crosses unit boundaries; value should go into two long values.                    
                </comment>
                <comment line="270">
                    copy into first long value.                    
                </comment>
                <comment line="275">
                    copy into second long value.                    
                </comment>
                <declaration name="fromIndex" type="int" line="242"/>
                <declaration name="toIndex" type="int" line="243"/>
                <declaration name="fromOffset" type="int" line="244"/>
                <declaration name="toOffset" type="int" line="245"/>
                <declaration name="mask" type="long" line="255"/>
                <declaration name="cleanValue" type="long" line="257"/>
                <declaration name="shiftedValue" type="long" line="259"/>
                <scope line="261"/>
            </method>
            <javadoc line="280">
                Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; in the bitvector &lt;tt&gt;bits&lt;/tt&gt; to the &quot;set&quot; (&lt;tt&gt;true&lt;/tt&gt;) state.                
                <param>
                    bits   the bitvector.                    
                </param>
                <param>
                    bitIndex   the index of the bit to be set.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="286">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="289">
                Returns the index of the unit that contains the given bitIndex.                
            </javadoc>
            <method name="unit" type="int" line="292">
                <params>
                    <param name="bitIndex" type="int"/>
                </params>
                <comment line="294">
                    equivalent to bitIndex/64                    
                </comment>
            </method>
        </class>
    </source>