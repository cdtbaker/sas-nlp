<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt">
        <import package="cern.colt.function.IntComparator"/>
        <class name="GenericSorting" line="12">
            <extends class="Object"/>
            <javadoc line="12">
                Generically sorts arbitrary shaped data (for example multiple arrays, 1,2 or 3-d matrices, and so on) using a 
                  quicksort or mergesort. This class addresses two problems, namely 
                  &lt;ul&gt;
                  &lt;li&gt;&lt;i&gt;Sorting multiple arrays in sync&lt;/i&gt; 
                  &lt;li&gt;&lt;i&gt;Sorting by multiple sorting criteria&lt;/i&gt; (primary, secondary, tertiary, 
                  ...) 
                  &lt;/ul&gt;
                  &lt;h4&gt;Sorting multiple arrays in sync&lt;/h4&gt;
                  &lt;p&gt;
                  Assume we have three arrays X, Y and Z. We want to sort all three arrays by 
                  X (or some arbitrary comparison function). For example, we have&lt;br&gt;
                  &lt;tt&gt;X=[3, 2, 1], Y=[3.0, 2.0, 1.0], Z=[6.0, 7.0, 8.0]&lt;/tt&gt;. The output should 
                  be &lt;tt&gt;&lt;br&gt;
                  X=[1, 2, 3], Y=[1.0, 2.0, 3.0], Z=[8.0, 7.0, 6.0]&lt;/tt&gt;. &lt;/p&gt;
                  &lt;p&gt;How can we achive this? Here are several alternatives. We could ... &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt; make a list of Point3D objects, sort the list as desired using a comparison 
                  function, then copy the results back into X, Y and Z. The classic object-oriented 
                  way. &lt;/li&gt;
                  &lt;li&gt;make an index list [0,1,2,...,N-1], sort the index list using a comparison function, 
                  then reorder the elements of X,Y,Z as defined by the index list. Reordering 
                  cannot be done in-place, so we need to copy X to some temporary array, then 
                  copy in the right order back from the temporary into X. Same for Y and Z. 
                  &lt;/li&gt;
                  &lt;li&gt; use a generic quicksort or mergesort which, whenever two elements in X are swapped, 
                  also swaps the corresponding elements in Y and Z. &lt;/li&gt;
                  &lt;/ol&gt;
                  Alternatives 1 and 2 involve quite a lot of copying and allocate significant amounts 
                  of temporary memory. Alternative 3 involves more swapping, more polymorphic message dispatches, no copying and does not need any temporary memory. 
                  &lt;p&gt; This class implements alternative 3. It operates on arbitrary shaped data. 
                  In fact, it has no idea what kind of data it is sorting. Comparisons and swapping 
                  are delegated to user provided objects which know their data and can do the 
                  job. 
                  &lt;p&gt; Lets call the generic data &lt;tt&gt;g&lt;/tt&gt; (it may be one array, three linked lists 
                  or whatever). This class takes a user comparison function operating on two indexes 
                  &lt;tt&gt;(a,b)&lt;/tt&gt;, namely an {@link IntComparator}. The comparison function determines 
                  whether &lt;tt&gt;g[a]&lt;/tt&gt; is equal, less or greater than &lt;tt&gt;g[b]&lt;/tt&gt;. The sort, 
                  depending on its implementation, can decide to swap the data at index &lt;tt&gt;a&lt;/tt&gt; 
                  with the data at index &lt;tt&gt;b&lt;/tt&gt;. It calls a user provided {@link cern.colt.Swapper} 
                  object that knows how to swap the data of these indexes. 
                  &lt;p&gt;The following snippet shows how to solve the problem. 
                  &lt;table&gt;
                  &lt;td class=&quot;PRE&quot;&gt; 
                  &lt;pre&gt;
                  final int[] x;
                  final double[] y;
                  final double[] z;
                  x = new int[]    {3,   2,   1  };
                  y = new double[] {3.0, 2.0, 1.0};
                  z = new double[] {6.0, 7.0, 8.0};
                  // this one knows how to swap two indexes (a,b)
                  Swapper swapper = new Swapper() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public void swap(int a, int b) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int t1;	double t2, t3;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1 = x[a]; x[a] = x[b];	x[b] = t1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2 = y[a]; y[a] = y[b]; y[b] = t2;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t3 = z[a]; z[a] = z[b];	z[b] = t3;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  // simple comparison: compare by X and ignore Y,Z&lt;br&gt;
                  IntComparator comp = new IntComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(int a, int b) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return x[a]==x[b] ? 0 : (x[a]&amp;lt;x[b] ? -1 : 1);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  System.out.println(&quot;before:&quot;);
                  System.out.println(&quot;X=&quot;+Arrays.toString(x));
                  System.out.println(&quot;Y=&quot;+Arrays.toString(y));
                  System.out.println(&quot;Z=&quot;+Arrays.toString(z));
                  GenericSorting.quickSort(0, X.length, comp, swapper);
                  // GenericSorting.mergeSort(0, X.length, comp, swapper);
                  System.out.println(&quot;after:&quot;);
                  System.out.println(&quot;X=&quot;+Arrays.toString(x));
                  System.out.println(&quot;Y=&quot;+Arrays.toString(y));
                  System.out.println(&quot;Z=&quot;+Arrays.toString(z));
                  &lt;/pre&gt;
                  &lt;/td&gt;
                  &lt;/table&gt;
                  &lt;h4&gt;Sorting by multiple sorting criterias (primary, secondary, tertiary, ...)&lt;/h4&gt;
                  &lt;p&gt;Assume again we have three arrays X, Y and Z. Now we want to sort all three 
                  arrays, primarily by Y, secondarily by Z (if Y elements are equal). For example, 
                  we have&lt;br&gt;
                  &lt;tt&gt;X=[6, 7, 8, 9], Y=[3.0, 2.0, 1.0, 3.0], Z=[5.0, 4.0, 4.0, 1.0]&lt;/tt&gt;. The 
                  output should be &lt;tt&gt;&lt;br&gt;
                  X=[8, 7, 9, 6], Y=[1.0, 2.0, 3.0, 3.0], Z=[4.0, 4.0, 1.0, 5.0]&lt;/tt&gt;. &lt;/p&gt;
                  &lt;p&gt;Here is how to solve the problem. All code in the above example stays the same, 
                  except that we modify the comparison function as follows&lt;/p&gt;
                  &lt;table&gt;
                  &lt;td class=&quot;PRE&quot;&gt; 
                  &lt;pre&gt;
                  //compare by Y, if that doesn&apos;t help, reside to Z
                  IntComparator comp = new IntComparator() {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;public int compare(int a, int b) {
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (y[a]==y[b]) return z[a]==z[b] ? 0 : (z[a]&amp;lt;z[b] ? -1 : 1);
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return y[a]&amp;lt;y[b] ? -1 : 1;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;}
                  };
                  &lt;/pre&gt;
                  &lt;/td&gt;
                  &lt;/table&gt;
                  &lt;h4&gt;Notes&lt;/h4&gt;
                  &lt;p&gt;&lt;/p&gt;
                  &lt;p&gt; Sorts involving floating point data and not involving comparators, like, for 
                  example provided in the JDK {@link java.util.Arrays} and in the Colt {@link cern.colt.Sorting} handle floating point numbers in special ways to guarantee 
                  that NaN&apos;s are swapped to the end and -0.0 comes before 0.0. Methods delegating 
                  to comparators cannot do this. They rely on the comparator. Thus, if such boundary 
                  cases are an issue for the application at hand, comparators explicitly need 
                  to implement -0.0 and NaN aware comparisons. Remember: &lt;tt&gt;-0.0 &lt; 0.0 == false&lt;/tt&gt;, 
                  &lt;tt&gt;(-0.0 == 0.0) == true&lt;/tt&gt;, as well as &lt;tt&gt;5.0 &amp;lt; Double.NaN == false&lt;/tt&gt;, 
                  &lt;tt&gt;5.0 &amp;gt; Double.NaN == false&lt;/tt&gt;. Same for &lt;tt&gt;float&lt;/tt&gt;.
                  &lt;h4&gt;Implementation &lt;/h4&gt;
                  &lt;p&gt;The quicksort is a derivative of the JDK 1.2 V1.26 algorithms (which are, in 
                  turn, based on Bentley&apos;s and McIlroy&apos;s fine work).
                  The mergesort is a derivative of the JAL algorithms, with optimisations taken from the JDK algorithms.
                  Both quick and merge sort are &quot;in-place&quot;, i.e. do not allocate temporary memory (helper arrays).
                  Mergesort is &lt;i&gt;stable&lt;/i&gt; (by definition), while quicksort is not.
                  A stable sort is, for example, helpful, if matrices are sorted successively 
                  by multiple columns. It preserves the relative position of equal elements.                
                <see>
                    java.util.Arrays                    
                </see>
                <see>
                    cern.colt.Sorting                    
                </see>
                <see>
                    cern.colt.matrix.doublealgo.Sorting                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 03-Jul-99                    
                </version>
            </javadoc>
            <declaration name="SMALL" type="int" line="148"/>
            <declaration name="MEDIUM" type="int" line="149"/>
            <javadoc line="150">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="GenericSorting" type="constructor" line="153"/>
            <javadoc line="154">
                Transforms two consecutive sorted ranges into a single sorted 
                  range.  The initial ranges are &lt;code&gt;[first, middle)&lt;/code&gt;
                  and &lt;code&gt;[middle, last)&lt;/code&gt;, and the resulting range is
                  &lt;code&gt;[first, last)&lt;/code&gt;.  
                  Elements in the first input range will precede equal elements in the 
                  second.                
            </javadoc>
            <method name="inplace_merge" type="void" line="162">
                <params>
                    <param name="first" type="int"/>
                    <param name="middle" type="int"/>
                    <param name="last" type="int"/>
                    <param name="comp" type="IntComparator"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="183">
                    rotate(firstCut, middle, secondCut, swapper);
                     is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are &quot;static private&quot;)
                     speedup = 1.7
                     begin inline                    
                </comment>
                <comment line="196">
                    end inline                    
                </comment>
                <scope line="165">
                    <scope line="166"/>
                </scope>
                <declaration name="firstCut" type="int" line="171"/>
                <declaration name="secondCut" type="int" line="172"/>
                <scope line="173"/>
                <scope line="177"/>
                <declaration name="first2" type="int" line="186"/>
                <declaration name="middle2" type="int" line="186"/>
                <declaration name="last2" type="int" line="186"/>
                <scope line="187">
                    <declaration name="first1" type="int" line="188"/>
                    <declaration name="last1" type="int" line="188"/>
                </scope>
            </method>
            <javadoc line="201">
                Performs a binary search on an already-sorted range: finds the first
                  position where an element can be inserted without violating the ordering.
                  Sorting is by a user-supplied comparison function.                
                <param>
                    array    Array containing the range.                    
                </param>
                <param>
                    first    Beginning of the range.                    
                </param>
                <param>
                    last     One past the end of the range.                    
                </param>
                <param>
                    x        Element to be searched for.                    
                </param>
                <param>
                    comp     Comparison function.                    
                </param>
                <return>
                    The largest index i such that, for every j in the
                      range <code>[first, i)</code>, 
                      <code>comp.apply(array[j], x)</code> is
                      <code>true</code>.                    
                </return>
                <see>
                    Sorting#upper_bound                    
                </see>
                <see>
                    Sorting#equal_range                    
                </see>
                <see>
                    Sorting#binary_search                    
                </see>
            </javadoc>
            <method name="lower_bound" type="int" line="218">
                <params>
                    <param name="first" type="int"/>
                    <param name="last" type="int"/>
                    <param name="x" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <comment line="220">
                    if (comp==null) throw new NullPointerException();                    
                </comment>
                <declaration name="len" type="int" line="220"/>
                <scope line="221">
                    <declaration name="half" type="int" line="222"/>
                    <declaration name="middle" type="int" line="223"/>
                    <scope line="224"/>
                    <scope line="228"/>
                </scope>
            </method>
            <javadoc line="234">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="237">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <declaration name="ab" type="int" line="238"/>
                <declaration name="ac" type="int" line="239"/>
                <declaration name="bc" type="int" line="240"/>
            </method>
            <javadoc line="245">
                Sorts the specified range of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(a, b)&lt;/tt&gt; must not throw an
                  exception for any indexes &lt;tt&gt;a&lt;/tt&gt; and
                  &lt;tt&gt;b&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    fromIndex the index of the first element (inclusive) to be sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the generic data.                    
                </param>
                <param>
                    swapper an object that knows how to swap the elements at any two indexes (a,b).                    
                </param>
                <see>
                    IntComparator                    
                </see>
                <see>
                    Swapper                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="270">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="IntComparator"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="272">
                    We retain the same method signature as quickSort.
                    Given only a comparator and swapper we do not know how to copy and move elements fromto temporary arrays.
                    Hence, in contrast to the JDK mergesorts this is an &quot;in-place&quot; mergesort, i.e. does not allocate any temporary arrays.
                    A non-inplace mergesort would perhaps be faster in most cases, but would require non-intuitive delegate objects...                    
                </comment>
                <comment line="280">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="290">
                    Recursively sort halves                    
                </comment>
                <comment line="295">
                    If list is already sorted, nothing left to do.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="299">
                    Merge sorted halves                    
                </comment>
                <declaration name="length" type="int" line="277"/>
                <scope line="280">
                    <scope line="281">
                        <scope line="282"/>
                    </scope>
                </scope>
                <declaration name="mid" type="int" line="290"/>
            </method>
            <javadoc line="301">
                Sorts the specified range of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(a, b)&lt;/tt&gt; must not throw an
                  exception for any indexes &lt;tt&gt;a&lt;/tt&gt; and
                  &lt;tt&gt;b&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    fromIndex the index of the first element (inclusive) to be sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the generic data.                    
                </param>
                <param>
                    swapper an object that knows how to swap the elements at any two indexes (a,b).                    
                </param>
                <see>
                    IntComparator                    
                </see>
                <see>
                    Swapper                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="324">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="IntComparator"/>
                    <param name="swapper" type="Swapper"/>
                </params>
            </method>
            <javadoc line="327">
                Sorts the specified sub-array into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="330">
                <params>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="IntComparator"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="332">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="341">
                    Choose a partition element, v                    
                </comment>
                <comment line="342">
                    Small arrays, middle element                    
                </comment>
                <comment line="346">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="352">
                    Mid-size, med of 3                    
                </comment>
                <comment line="354">
                    long v = x[m];                    
                </comment>
                <comment line="356">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="362">
                    moving target; DELTA to JDK !!!                    
                </comment>
                <comment line="363">
                    moving target; DELTA to JDK !!!                    
                </comment>
                <comment line="370">
                    moving target; DELTA to JDK !!!                    
                </comment>
                <comment line="371">
                    moving target; DELTA to JDK !!!                    
                </comment>
                <comment line="377">
                    moving target; DELTA to JDK !!!                    
                </comment>
                <comment line="378">
                    moving target; DELTA to JDK !!!                    
                </comment>
                <comment line="382">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="387">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="332">
                    <scope line="334"/>
                </scope>
                <declaration name="m" type="int" line="341"/>
                <scope line="342">
                    <declaration name="l" type="int" line="343"/>
                    <declaration name="n" type="int" line="344"/>
                    <scope line="345">
                        <declaration name="s" type="int" line="346"/>
                    </scope>
                </scope>
                <declaration name="a" type="int" line="356"/>
                <scope line="357">
                    <declaration name="comparison" type="int" line="358"/>
                    <scope line="359">
                        <scope line="360"/>
                    </scope>
                    <scope line="367">
                        <scope line="368"/>
                    </scope>
                </scope>
                <declaration name="s" type="int" line="382"/>
            </method>
            <javadoc line="392">
                Reverses a sequence of elements.                
                <param>
                    array      Array containing the sequence                    
                </param>
                <param>
                    first      Beginning of the range                    
                </param>
                <param>
                    last       One past the end of the range                    
                </param>
                <exception>
                    ArrayIndexOutOfBoundsException If the range
                      is invalid.                    
                </exception>
            </javadoc>
            <method name="reverse" type="void" line="400">
                <params>
                    <param name="first" type="int"/>
                    <param name="last" type="int"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="402">
                    no more needed since manually inlined                    
                </comment>
                <scope line="402"/>
            </method>
            <javadoc line="406">
                Rotate a range in place: &lt;code&gt;array[middle]&lt;/code&gt; is put in
                  &lt;code&gt;array[first]&lt;/code&gt;, &lt;code&gt;array[middle+1]&lt;/code&gt; is put in
                  &lt;code&gt;array[first+1]&lt;/code&gt;, etc.  Generally, the element in position
                  &lt;code&gt;i&lt;/code&gt; is put into position 
                  &lt;code&gt;(i + (last-middle)) % (last-first)&lt;/code&gt;.                
                <param>
                    array    Array containing the range                    
                </param>
                <param>
                    first    Beginning of the range                    
                </param>
                <param>
                    middle   Index of the element that will be put in
                      <code>array[first]</code>                    
                </param>
                <param>
                    last     One past the end of the range                    
                </param>
            </javadoc>
            <method name="rotate" type="void" line="418">
                <params>
                    <param name="first" type="int"/>
                    <param name="middle" type="int"/>
                    <param name="last" type="int"/>
                    <param name="swapper" type="Swapper"/>
                </params>
                <comment line="420">
                    no more needed since manually inlined                    
                </comment>
                <scope line="420"/>
            </method>
            <javadoc line="426">
                Performs a binary search on an already-sorted range: finds the last
                  position where an element can be inserted without violating the ordering.
                  Sorting is by a user-supplied comparison function.                
                <param>
                    array    Array containing the range.                    
                </param>
                <param>
                    first    Beginning of the range.                    
                </param>
                <param>
                    last     One past the end of the range.                    
                </param>
                <param>
                    x        Element to be searched for.                    
                </param>
                <param>
                    comp     Comparison function.                    
                </param>
                <return>
                    The largest index i such that, for every j in the
                      range <code>[first, i)</code>, 
                      <code>comp.apply(x, array[j])</code> is 
                      <code>false</code>.                    
                </return>
                <see>
                    Sorting#lower_bound                    
                </see>
                <see>
                    Sorting#equal_range                    
                </see>
                <see>
                    Sorting#binary_search                    
                </see>
            </javadoc>
            <method name="upper_bound" type="int" line="443">
                <params>
                    <param name="first" type="int"/>
                    <param name="last" type="int"/>
                    <param name="x" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <comment line="445">
                    if (comp==null) throw new NullPointerException();                    
                </comment>
                <declaration name="len" type="int" line="445"/>
                <scope line="446">
                    <declaration name="half" type="int" line="447"/>
                    <declaration name="middle" type="int" line="448"/>
                    <scope line="449"/>
                    <scope line="452"/>
                </scope>
            </method>
            <javadoc line="459">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="462">
                <params>
                    <param name="swapper" type="Swapper"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
        </class>
    </source>