<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.jet.stat.quantile">
        <import package="cern.colt.list.DoubleArrayList"/>
        <interface name="DoubleQuantileFinder">
            <implements interface="java.io.Serializable"/>
            <comment line="19">
                public interface DoubleQuantileFinder extends com.objy.db.iapp.PersistentEvents, java.io.Serializable {                
            </comment>
            <javadoc line="12">
                The interface shared by all quantile finders, no matter if they are exact or approximate.
                  It is usually completely sufficient to operate on this interface only.
                  Also see {@link hep.aida.bin.QuantileBin1D}, demonstrating how this package can be used.                
            </javadoc>
            <method name="add" type="void" line="19"/>
            <javadoc line="19">
                Adds a value to the receiver.                
                <param>
                    value the value to add.                    
                </param>
            </javadoc>
            <method name="addAllOf" type="void" line="24"/>
            <javadoc line="24">
                Adds all values of the specified list to the receiver.                
                <param>
                    values the list of which all values shall be added.                    
                </param>
            </javadoc>
            <method name="addAllOfFromTo" type="void" line="29"/>
            <javadoc line="29">
                Adds the part of the specified list between indexes &lt;tt&gt;from&lt;/tt&gt; (inclusive) and &lt;tt&gt;to&lt;/tt&gt; (inclusive) to the receiver.                
                <param>
                    values the list of which elements shall be added.                    
                </param>
                <param>
                    from the index of the first element to be added (inclusive).                    
                </param>
                <param>
                    to the index of the last element to be added (inclusive).                    
                </param>
            </javadoc>
            <method name="clear" type="void" line="37"/>
            <javadoc line="37">
                Removes all elements from the receiver.  The receiver will
                  be empty after this call returns, and its memory requirements will be close to zero.                
            </javadoc>
            <method name="clone" type="Object" line="42"/>
            <javadoc line="42">
                Returns a deep copy of the receiver.                
                <return>
                    a deep copy of the receiver.                    
                </return>
            </javadoc>
            <method name="forEach" type="boolean" line="48"/>
            <javadoc line="48">
                Applies a procedure to each element of the receiver, if any.
                  Iterates over the receiver in no particular order.                
                <param>
                    procedure    the procedure to be applied. Stops iteration if the procedure returns &lt;tt&gt;false&lt;/tt&gt;, otherwise continues.                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; if the procedure stopped before all elements where iterated over, &lt;tt&gt;true&lt;/tt&gt; otherwise.                    
                </return>
            </javadoc>
            <method name="memory" type="long" line="55"/>
            <javadoc line="55">
                Returns the number of elements currently needed to store all contained elements.
                  This number usually differs from the results of method &lt;tt&gt;size()&lt;/tt&gt;, according to the underlying datastructure.                
            </javadoc>
            <method name="phi" type="double" line="60"/>
            <javadoc line="60">
                Returns how many percent of the elements contained in the receiver are &lt;tt&gt;&amp;lt;= element&lt;/tt&gt;.
                  Does linear interpolation if the element is not contained but lies in between two contained elements.
                  Writing a wrapper is a good idea if you can think of better ways of doing interpolation.
                  Same if you want to keep min,max and other such measures.                
                <param>
                    the element to search for.                    
                </param>
                <return>
                    the percentage &lt;tt&gt;p&lt;/tt&gt; of elements &lt;tt&gt;&amp;lt;= element&lt;/tt&gt; (&lt;tt&gt;0.0 &amp;lt;= p &amp;lt;=1.0)&lt;/tt&gt;.                    
                </return>
            </javadoc>
            <method name="quantileElements" type="DoubleArrayList" line="70"/>
            <javadoc line="70">
                Computes the specified quantile elements over the values previously added.                
                <param>
                    phis the quantiles for which elements are to be computed. Each phi must be in the interval [0.0,1.0]. &lt;tt&gt;phis&lt;/tt&gt; must be sorted ascending.                    
                </param>
                <return>
                    the quantile elements.                    
                </return>
            </javadoc>
            <method name="size" type="long" line="76"/>
            <javadoc line="76">
                Returns the number of elements currently contained in the receiver (identical to the number of values added so far).                
            </javadoc>
            <method name="totalMemory" type="long" line="80"/>
            <javadoc line="80">
                Returns the number of elements currently needed to store all contained elements.
                  This number usually differs from the results of method &lt;tt&gt;size()&lt;/tt&gt;, according to the underlying datastructure.                
            </javadoc>
        </interface>
    </source>