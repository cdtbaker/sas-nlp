<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.jet.random">
        <import package="cern.jet.random.engine.RandomEngine"/>
        <class name="EmpiricalWalker" line="12">
            <extends class="AbstractDiscreteDistribution"/>
            <comment line="49">
                cumulative distribution function                
            </comment>
            <comment line="50">
                James Theiler, jt@lanl.gov, the author of the GSL routine this port is based on, describes his approach as follows:
                
                 Based on: Alastair J Walker, An efficient method for generating
                 discrete random variables with general distributions, ACM Trans
                 Math Soft 3, 253-256 (1977).  See also: D. E. Knuth, The Art of
                 Computer Programming, Volume 2 (Seminumerical algorithms), 3rd
                 edition, Addison-Wesley (1997), p120.
                
                 Walker&apos;s algorithm does some preprocessing, and provides two
                 arrays: floating point F[k] and integer A[k].  A value k is chosen
                 from 0..K-1 with equal likelihood, and then a uniform random number
                 u is compared to F[k].  If it is less than F[k], then k is
                 returned.  Otherwise, A[k] is returned.
                
                 Walker&apos;s original paper describes an O(K^2) algorithm for setting
                 up the F and A arrays.  I found this disturbing since I wanted to
                 use very large values of K.  I&apos;m sure I&apos;m not the first to realize
                 this, but in fact the preprocessing can be done in O(K) steps.
                
                 A figure of merit for the preprocessing is the average value for
                 the F[k]&apos;s (that is, SUM_k F[k]K); this corresponds to the
                 probability that k is returned, instead of A[k], thereby saving a
                 redirection.  Walker&apos;s O(K^2) preprocessing will generally improve
                 that figure of merit, compared to my cheaper O(K) method; from some
                 experiments with a perl script, I get values of around 0.6 for my
                 method and just under 0.75 for Walker&apos;s.  Knuth has pointed out
                 that finding _the_ optimum lookup tables, which maximize the
                 average F[k], is a combinatorially difficult problem.  But any
                 valid preprocessing will still provide O(1) time for the call to
                 gsl_ran_discrete().  I find that if I artificially set F[k]=1 --
                 ie, better than optimum! -- I get a speedup of maybe 20%, so that&apos;s
                 the maximum I could expect from the most expensive preprocessing.
                 Folding in the difference of 0.6 vs 0.75, I&apos;d estimate that the
                 speedup would be less than 10%.
                
                 I&apos;ve not implemented it here, but one compromise is to sort the
                 probabilities once, and then work from the two ends inward.  This
                 requires O(K log K), still lots cheaper than O(K^2), and from my
                 experiments with the perl script, the figure of merit is within
                 about 0.01 for K up to 1000, and no sign of diverging (in fact,
                 they seemed to be converging, but it&apos;s hard to say with just a
                 handful of runs).
                
                 The O(K) algorithm goes through all the p_k&apos;s and decides if they
                 are &quot;smalls&quot; or &quot;bigs&quot; according to whether they are less than or
                 greater than the mean value 1K.  The indices to the smalls and the
                 bigs are put in separate stacks, and then we work through the
                 stacks together.  For each small, we pair it up with the next big
                 in the stack (Walker always wanted to pair up the smallest small
                 with the biggest big).  The small &quot;borrows&quot; from the big just
                 enough to bring the small up to mean.  This reduces the size of the
                 big, so the (smaller) big is compared again to the mean, and if it
                 is smaller, it gets &quot;popped&quot; from the big stack and &quot;pushed&quot; to the
                 small stack.  Otherwise, it stays put.  Since every time we pop a
                 small, we are able to deal with it right then and there, and we
                 never have to pop more than K smalls, then the algorithm is O(K).
                
                 This implementation sets up two separate stacks, and allocates K
                 elements between them.  Since neither stack ever grows, we do an
                 extra O(K) pass through the data to determine how many smalls and
                 bigs there are to begin with and allocate appropriately.  In all
                 there are 2Ksizeof(double) transient bytes of memory that are
                 used than returned, and K(sizeof(int)+sizeof(double)) bytes used
                 in the lookup table.
                
                 Walker spoke of using two random numbers (an integer 0..K-1, and a
                 floating point u in [0,1]), but Knuth points out that one can just
                 use the integer and fractional parts of Ku where u is in [0,1].
                 In fact, Knuth further notes that taking F&apos;[k]=(k+F[k])K, one can
                 directly compare u to F&apos;[k] without having to explicitly set
                 u=Ku-int(Ku).
                
                 Usage:
                
                 Starting with an array of probabilities P, initialize and do
                 preprocessing with a call to:
                
                    gsl_rng r;
                    gsl_ran_discrete_t f;
                    f = gsl_ran_discrete_preproc(K,P);
                
                 Then, whenever a random index 0..K-1 is desired, use
                
                    k = gsl_ran_discrete(r,f);
                
                 Note that several different randevent struct&apos;s can be
                 simultaneously active.
                
                 Aside: A very clever alternative approach is described in
                 Abramowitz and Stegun, p 950, citing: Marsaglia, Random variables
                 and computers, Proc Third Prague Conference in Probability Theory,
                 1962.  A more accesible reference is: G. Marsaglia, Generating
                 discrete random numbers in a computer, Comm ACM 6, 37-38 (1963).
                 If anybody is interested, I (jt) have also coded up this version as
                 part of another software package.  However, I&apos;ve done some
                 comparisons, and the Walker method is both faster and more stingy
                 with memory.  So, in the end I decided not to include it with the
                 GSL package.
                
                 Written 26 Jan 1999, James Theiler, jt@lanl.gov
                 Adapted to GSL, 30 Jan 1999, jt                
            </comment>
            <javadoc line="12">
                Discrete Empirical distribution (pdf&apos;s can be specified).
                  &lt;p&gt;
                  The probability distribution function (pdf) must be provided by the user as an array of positive real numbers. 
                  The pdf does not need to be provided in the form of relative probabilities, absolute probabilities are also accepted.
                  &lt;p&gt;
                  &lt;p&gt;
                  Instance methods operate on a user supplied uniform random number generator; they are unsynchronized.
                  &lt;dt&gt;
                  Static methods operate on a default uniform random number generator; they are synchronized.
                  &lt;p&gt;
                  &lt;b&gt;Implementation:&lt;/b&gt;
                  Walker&apos;s algorithm. 
                  Generating a random number takes &lt;tt&gt;O(1)&lt;/tt&gt;, i.e. constant time, as opposed to commonly used algorithms with logarithmic time complexity.
                  Preprocessing time (on object construction) is &lt;tt&gt;O(k)&lt;/tt&gt; where &lt;tt&gt;k&lt;/tt&gt; is the number of elements of the provided empirical pdf.
                  Space complexity is &lt;tt&gt;O(k)&lt;/tt&gt;.
                  &lt;p&gt;
                  This is a port of &lt;A HREF=&quot;http://sourceware.cygnus.com/cgi-bin/cvsweb.cgi/gsl/randist/discrete.c?cvsroot=gsl&quot;&gt;discrete.c&lt;/A&gt; which was written by James Theiler and is distributed with &lt;A HREF=&quot;http://sourceware.cygnus.com/gsl/&quot;&gt;GSL 0.4.1&lt;/A&gt;.
                  Theiler&apos;s implementation in turn is based upon
                  &lt;p&gt;
                  Alastair J. Walker, An efficient method for generating
                  discrete random variables with general distributions, ACM Trans
                  Math Soft 3, 253-256 (1977).
                  &lt;p&gt;
                  See also: D. E. Knuth, The Art of
                  Computer Programming, Volume 2 (Seminumerical algorithms), 3rd
                  edition, Addison-Wesley (1997), p120.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <declaration name="K" type="int" line="44"/>
            <declaration name="A" type="int[]" line="45"/>
            <declaration name="F" type="double[]" line="46"/>
            <declaration name="cdf" type="double[]" line="48"/>
            <javadoc line="153">
                Constructs an Empirical distribution.
                  The probability distribution function (pdf) is an array of positive real numbers. 
                  It need not be provided in the form of relative probabilities, absolute probabilities are also accepted.
                  The &lt;tt&gt;pdf&lt;/tt&gt; must satisfy both of the following conditions
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;0.0 &amp;lt;= pdf[i] : 0&amp;lt;=i&amp;lt;=pdf.length-1&lt;/tt&gt;
                  &lt;li&gt;&lt;tt&gt;0.0 &amp;lt; Sum(pdf[i]) : 0&amp;lt;=i&amp;lt;=pdf.length-1&lt;/tt&gt;
                  &lt;/ul&gt;                
                <param>
                    pdf the probability distribution function.                    
                </param>
                <param>
                    interpolationType can be either &lt;tt&gt;Empirical.NO_INTERPOLATION&lt;/tt&gt; or &lt;tt&gt;Empirical.LINEAR_INTERPOLATION&lt;/tt&gt;.                    
                </param>
                <param>
                    randomGenerator a uniform random number generator.                    
                </param>
                <throws>
                    IllegalArgumentException if at least one of the three conditions above is violated.                    
                </throws>
            </javadoc>
            <method name="EmpiricalWalker" type="constructor" line="167">
                <params>
                    <param name="pdf" type="double[]"/>
                    <param name="interpolationType" type="int"/>
                    <param name="randomGenerator" type="RandomEngine"/>
                </params>
            </method>
            <javadoc line="172">
                Returns the cumulative distribution function.                
            </javadoc>
            <method name="cdf" type="double" line="175">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="180">
                Returns a deep copy of the receiver; the copy will produce identical sequences.
                  After this call has returned, the copy and the receiver have equal but separate state.                
                <return>
                    a copy of the receiver.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="186">
                <declaration name="copy" type="EmpiricalWalker" line="187"/>
            </method>
            <javadoc line="193">
                Returns a random integer &lt;tt&gt;k&lt;/tt&gt; with probability &lt;tt&gt;pdf(k)&lt;/tt&gt;.                
            </javadoc>
            <method name="nextInt" type="int" line="196">
                <comment line="201">
                    #if KNUTH_CONVENTION
                        c = (int)(u*(g-&gt;K));
                    #else                    
                </comment>
                <comment line="207">
                    #endif                    
                </comment>
                <comment line="209">
                    fprintf(stderr,&quot;c,f,u: %d %.4f %f\n&quot;,c,f,u);                    
                </comment>
                <declaration name="c" type="int" line="197"/>
                <declaration name="u" type="double" line="198"/>
                <scope line="210"/>
                <scope line="213"/>
            </method>
            <javadoc line="217">
                Returns the probability distribution function.                
            </javadoc>
            <method name="pdf" type="double" line="220">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="224">
                Sets the distribution parameters.
                  The &lt;tt&gt;pdf&lt;/tt&gt; must satisfy all of the following conditions
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;pdf != null &amp;&amp; pdf.length &amp;gt; 0&lt;/tt&gt;
                  &lt;li&gt;&lt;tt&gt;0.0 &amp;lt;= pdf[i] : 0 &amp;lt; =i &amp;lt;= pdf.length-1&lt;/tt&gt;
                  &lt;li&gt;&lt;tt&gt;0.0 &amp;lt; Sum(pdf[i]) : 0 &amp;lt;=i &amp;lt;= pdf.length-1&lt;/tt&gt;
                  &lt;/ul&gt;                
                <param>
                    pdf probability distribution function.                    
                </param>
                <throws>
                    IllegalArgumentException if at least one of the three conditions above is violated.                    
                </throws>
            </javadoc>
            <method name="setState" type="void" line="235">
                <params>
                    <param name="pdf" type="double[]"/>
                    <param name="interpolationType" type="int"/>
                </params>
                <comment line="241">
                    compute cumulative distribution function (cdf) from probability distribution function (pdf)                    
                </comment>
                <comment line="251">
                    now normalize to 1 (relative probabilities).                    
                </comment>
                <comment line="255">
                    cdf is now cached...                    
                </comment>
                <scope line="236"/>
                <declaration name="nBins" type="int" line="241"/>
                <scope line="245"/>
                <scope line="251"/>
            </method>
            <javadoc line="256">
                Sets the distribution parameters.
                  The &lt;tt&gt;pdf&lt;/tt&gt; must satisfy both of the following conditions
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;0.0 &amp;lt;= pdf[i] : 0 &amp;lt; =i &amp;lt;= pdf.length-1&lt;/tt&gt;
                  &lt;li&gt;&lt;tt&gt;0.0 &amp;lt; Sum(pdf[i]) : 0 &amp;lt;=i &amp;lt;= pdf.length-1&lt;/tt&gt;
                  &lt;/ul&gt;                
                <param>
                    pdf probability distribution function.                    
                </param>
                <throws>
                    IllegalArgumentException if at least one of the three conditions above is violated.                    
                </throws>
            </javadoc>
            <method name="setState2" type="void" line="266">
                <params>
                    <param name="pdf" type="double[]"/>
                </params>
                <comment line="277">
                    if (size &lt; 1) {
                    	throw new IllegalArgumentException(&quot;must have size greater than zero&quot;);
                    }                    
                </comment>
                <comment line="280">
                    Make sure elements of ProbArray[] are positive.
                     Won&apos;t enforce that sum is unity; instead will just normalize                    
                </comment>
                <comment line="284">
                    if (pdf[k] &lt; 0) {                    
                </comment>
                <comment line="285">
                    throw new IllegalArgumentException(&quot;Probabilities must be &gt;= 0: &quot;+pdf[k]);                    
                </comment>
                <comment line="286">
                    }                    
                </comment>
                <comment line="290">
                                        
                </comment>
                <comment line="295">
                    normalize to relative probability                    
                </comment>
                <comment line="301">
                                        
                </comment>
                <comment line="319">
                                        
                </comment>
                <comment line="323">
                                        
                </comment>
                <comment line="331">
                    #if DEBUG
                    fprintf(stderr,&quot;s=%2d, A=%2d, F=%.4f\n&quot;,s,(g-&gt;A)[s],(g-&gt;F)[s]);
                    #endif                    
                </comment>
                <comment line="337">
                                        
                </comment>
                <comment line="340">
                                        
                </comment>
                <comment line="343">
                                        
                </comment>
                <comment line="346">
                                        
                </comment>
                <comment line="356">
                                        
                </comment>
                <comment line="359">
                    #if 0                    
                </comment>
                <comment line="360">
                    if 1, then artificially set all F[k]&apos;s to unity.  This will
                     give wrong answers, but you&apos;ll get them faster.  But, not
                     that much faster (I get maybe 20%); that&apos;s an upper bound
                     on what the optimal preprocessing would give.                    
                </comment>
                <comment line="365">
                    for (k=0; k&lt;size; ++k) {
                    F[k] = 1.0;
                    }
                    #endif                    
                </comment>
                <comment line="372">
                    #if KNUTH_CONVENTION                    
                </comment>
                <comment line="373">
                                        
                </comment>
                <comment line="374">
                    This saves some arithmetic in gsl_ran_discrete(); I find that
                     it doesn&apos;t actually make much difference.                    
                </comment>
                <comment line="377">
                    for (k=0; k&lt;size; ++k) {
                    F[k] += k;
                    F[k] = size;
                    }
                    #endif                    
                </comment>
                <comment line="384">
                    free_stack(Bigs);
                    free_stack(Smalls);
                    free((char )E);
                    
                    return g;                    
                </comment>
                <declaration name="size" type="int" line="267"/>
                <declaration name="k" type="int" line="268"/>
                <declaration name="nBigs" type="int" line="269"/>
                <declaration name="Bigs" type="Stack" line="270"/>
                <declaration name="Smalls" type="Stack" line="271"/>
                <declaration name="E" type="double[]" line="272"/>
                <declaration name="pTotal" type="double" line="273"/>
                <declaration name="mean" type="double" line="274"/>
                <scope line="282"/>
                <scope line="296"/>
                <scope line="304"/>
                <scope line="310">
                    <scope line="311"/>
                    <scope line="314"/>
                </scope>
                <scope line="319">
                    <scope line="321"/>
                    <scope line="338"/>
                    <scope line="341"/>
                    <scope line="344"/>
                </scope>
                <scope line="350"/>
            </method>
            <javadoc line="392">
                Returns a String representation of the receiver.                
            </javadoc>
            <method name="toString" type="String" line="395">
                <declaration name="interpolation" type="String" line="396"/>
            </method>
        </class>
    </source>