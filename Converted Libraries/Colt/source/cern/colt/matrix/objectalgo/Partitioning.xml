<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.matrix.objectalgo">
        <import package="cern.colt.Swapper"/>
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.matrix.ObjectMatrix1D"/>
        <import package="cern.colt.matrix.ObjectMatrix2D"/>
        <class name="Partitioning" line="15">
            <extends class="Object"/>
            <javadoc line="15">
                Given some interval boundaries, partitions matrices such that cell values falling into an interval are placed next to each other.
                  &lt;p&gt;
                  &lt;b&gt;Performance&lt;/b&gt;
                  &lt;p&gt;
                  Partitioning into two intervals is &lt;tt&gt;O( N )&lt;/tt&gt;.
                  Partitioning into k intervals is &lt;tt&gt;O( N  log(k))&lt;/tt&gt;.
                  Constants factors are minimized.                
                <see>
                    cern.colt.Partitioning &quot;Partitioning arrays (provides more documentation)&quot;                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 09/24/99                    
                </version>
            </javadoc>
            <javadoc line="30">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Partitioning" type="constructor" line="33"/>
            <javadoc line="34">
                Same as {@link cern.colt.Partitioning#partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Note that arguments are not checked for validity.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;column = 0;&lt;br&gt;
                  rowIndexes = {0,1,2,..,matrix.rows()-1};
                  rowFrom = 0;&lt;br&gt;
                  rowTo = matrix.rows()-1;&lt;br&gt;
                  splitters = {5,10,12}&lt;br&gt;
                  c = 0; &lt;br&gt;
                  d = splitters.length-1;&lt;br&gt;
                  partition(matrix,rowIndexes,rowFrom,rowTo,column,splitters,c,d,splitIndexes);&lt;br&gt;
                  ==&gt;&lt;br&gt;
                  splitIndexes == {0, 2, 3}&lt;br&gt;
                  rowIndexes == {7, 6, 5, 4, 0, 1, 2, 3}&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;
                  The matrix IS NOT REORDERED.&lt;br&gt;
                  Here is how it would look&lt;br&gt;
                  like, if it would be reordered&lt;br&gt;
                  accoring to &lt;tt&gt;rowIndexes&lt;/tt&gt;.&lt;br&gt;
                  &lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  2,  1,  0&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be partitioned.                    
                </param>
                <param>
                    rowIndexes the index of the i-th row; is modified by this method to reflect partitioned indexes.                    
                </param>
                <param>
                    rowFrom the index of the first row (inclusive).                    
                </param>
                <param>
                    rowTo the index of the last row (inclusive).                    
                </param>
                <param>
                    column the index of the column to partition on.                    
                </param>
                <param>
                    splitters the values at which the rows shall be split into intervals.
                      Must be sorted ascending and must not contain multiple identical values.
                      These preconditions are not checked; be sure that they are met.                    
                </param>
                <param>
                    splitFrom the index of the first splitter element to be considered.                    
                </param>
                <param>
                    splitTo the index of the last splitter element to be considered.
                      The method considers the splitter elements &lt;tt&gt;splitters[splitFrom] .. splitters[splitTo]&lt;/tt&gt;.                    
                </param>
                <param>
                    splitIndexes a list into which this method fills the indexes of rows delimiting intervals.
                      Upon return &lt;tt&gt;splitIndexes[splitFrom..splitTo]&lt;/tt&gt; will be set accordingly.
                      Therefore, must satisfy &lt;tt&gt;splitIndexes.length &gt;= splitters.length&lt;/tt&gt;.                    
                </param>
            </javadoc>
            <method name="partition" type="void" line="107">
                <params>
                    <param name="matrix" type="ObjectMatrix2D"/>
                    <param name="rowIndexes" type="int[]"/>
                    <param name="rowFrom" type="int"/>
                    <param name="rowTo" type="int"/>
                    <param name="column" type="int"/>
                    <param name="splitters" type="Object[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="114">
                    this one knows how to swap two row indexes (a,b)                    
                </comment>
                <comment line="122">
                    compare splitter[a] with columnView[rowIndexes[b]]                    
                </comment>
                <comment line="133">
                    compare columnView[rowIndexes[a]] with columnView[rowIndexes[b]]                    
                </comment>
                <comment line="143">
                    compare splitter[a] with splitter[b]                    
                </comment>
                <comment line="153">
                    generic partitioning does the main work of reordering row indexes                    
                </comment>
                <declaration name="g" type="int[]" line="114"/>
                <anonymous_class line="115">
                    <method name="swap" type="void" line="116">
                        <params>
                            <param name="b" type="int"/>
                            <param name="c" type="int"/>
                        </params>
                        <declaration name="tmp" type="int" line="117"/>
                    </method>
                </anonymous_class>
                <declaration name="swapper" type="Swapper" line="115"/>
                <declaration name="columnView" type="ObjectMatrix1D" line="122"/>
                <anonymous_class line="123">
                    <method name="compare" type="int" line="124">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="av" type="Comparable" line="125"/>
                        <declaration name="bv" type="Comparable" line="126"/>
                        <declaration name="r" type="int" line="127"/>
                    </method>
                </anonymous_class>
                <declaration name="comp" type="IntComparator" line="123"/>
                <anonymous_class line="133">
                    <method name="compare" type="int" line="134">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="av" type="Comparable" line="135"/>
                        <declaration name="bv" type="Comparable" line="136"/>
                        <declaration name="r" type="int" line="137"/>
                    </method>
                </anonymous_class>
                <declaration name="comp2" type="IntComparator" line="133"/>
                <anonymous_class line="143">
                    <method name="compare" type="int" line="144">
                        <params>
                            <param name="a" type="int"/>
                            <param name="b" type="int"/>
                        </params>
                        <declaration name="av" type="Comparable" line="145"/>
                        <declaration name="bv" type="Comparable" line="146"/>
                        <declaration name="r" type="int" line="147"/>
                    </method>
                </anonymous_class>
                <declaration name="comp3" type="IntComparator" line="143"/>
            </method>
            <javadoc line="155">
                Same as {@link cern.colt.Partitioning#partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Note that arguments are not checked for validity.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt; 
                  &lt;tt&gt;column = 0;&lt;br&gt;
                  splitters = {5,10,12}&lt;br&gt;
                  partition(matrix,column,splitters,splitIndexes);&lt;br&gt;
                  ==&gt;&lt;br&gt;
                  splitIndexes == {0, 2, 3}&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;
                  The matrix IS NOT REORDERED.&lt;br&gt;
                  The new VIEW IS REORDERED:&lt;br&gt;
                  &lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  2,  1,  0&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
                <param>
                    matrix the matrix to be partitioned.                    
                </param>
                <param>
                    column the index of the column to partition on.                    
                </param>
                <param>
                    splitters the values at which the rows shall be split into intervals.
                      Must be sorted ascending and must not contain multiple identical values.
                      These preconditions are not checked; be sure that they are met.                    
                </param>
                <param>
                    splitIndexes a list into which this method fills the indexes of rows delimiting intervals.
                      Therefore, must satisfy &lt;tt&gt;splitIndexes.length &gt;= splitters.length&lt;/tt&gt;.                    
                </param>
                <return>
                    a new matrix view having rows partitioned by the given column and splitters.                    
                </return>
            </javadoc>
            <method name="partition" type="ObjectMatrix2D" line="214">
                <params>
                    <param name="matrix" type="ObjectMatrix2D"/>
                    <param name="column" type="int"/>
                    <param name="splitters" type="Object[]"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="220">
                    row indexes to reorder instead of matrix itself                    
                </comment>
                <comment line="225">
                    take all columns in the original order                    
                </comment>
                <comment line="229">
                    view the matrix according to the reordered row indexes                    
                </comment>
                <declaration name="rowFrom" type="int" line="215"/>
                <declaration name="rowTo" type="int" line="216"/>
                <declaration name="splitFrom" type="int" line="217"/>
                <declaration name="splitTo" type="int" line="218"/>
                <declaration name="rowIndexes" type="int[]" line="219"/>
                <declaration name="columnIndexes" type="int[]" line="225"/>
            </method>
            <javadoc line="231">
                Same as {@link #partition(int[],int,int,int[],int,int,int[])}except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Of course, the column must not be a column of a different matrix.
                  More formally, there must hold: &lt;br&gt;
                  There exists an &lt;tt&gt;i&lt;/tt&gt; such that &lt;tt&gt;matrix.viewColumn(i)==column&lt;/tt&gt;.
                  &lt;p&gt;
                  Note that arguments are not checked for validity.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt; 
                  &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
                  &lt;tr nowrap&gt; 
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  2,  1,  0 &lt;/tt&gt;&lt;/td&gt;
                  &lt;td align=&quot;left&quot;&gt; 
                  &lt;p&gt;&lt;tt&gt;column = matrix.viewColumn(0);&lt;br&gt;
                  a = 0;&lt;br&gt;
                  b = column.size()-1;&lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
                  splitters={5,10,12}&lt;br&gt;
                  c=0; &lt;br&gt;
                  d=splitters.length-1;&lt;/tt&gt;&lt;tt&gt;&lt;br&gt;
                  partition(matrix,column,a,b,splitters,c,d,splitIndexes);&lt;br&gt;
                  ==&gt;&lt;br&gt;
                  splitIndexes == {0, 2, 3}&lt;/tt&gt;&lt;/p&gt;
                  &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;8 x 3 matrix:&lt;br&gt;
                  2,  1,  0&lt;br&gt;
                  5,  4,  3&lt;br&gt;
                  8,  7,  6&lt;br&gt;
                  11, 10, 9&lt;br&gt;
                  23, 22, 21&lt;br&gt;
                  20, 19, 18&lt;br&gt;
                  17, 16, 15&lt;br&gt;
                  14, 13, 12 &lt;/tt&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;                
            </javadoc>
            <method name="xPartitionOld" type="void" line="285">
                <params>
                    <param name="matrix" type="ObjectMatrix2D"/>
                    <param name="column" type="ObjectMatrix1D"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitters" type="Object[]"/>
                    <param name="splitFrom" type="int"/>
                    <param name="splitTo" type="int"/>
                    <param name="splitIndexes" type="int[]"/>
                </params>
                <comment line="287">
                    Object splitter;  int, Object --&gt; template type dependent
                    
                    if (splitFrom&gt;splitTo) return;  nothing to do
                    if (from&gt;to) {  all bins are empty
                    from--;
                    for (int i = splitFrom; i&lt;=splitTo; ) splitIndexes[i++] = from;
                    return;
                    }
                    
                     Choose a partition (pivot) index, m
                     Ideally, the pivot should be the median, because a median splits a list into two equal sized sublists.
                     However, computing the median is expensive, so we use an approximation.
                    int medianIndex;
                    if (splitFrom==splitTo) {  we don&apos;t really have a choice
                    medianIndex = splitFrom;
                    }
                    else {  we do have a choice
                    int m = (from+to)  2;        Small arrays, middle element
                    int len = to-from+1;
                    if (len &gt; SMALL) {
                    int l = from;
                    int n = to;
                    if (len &gt; MEDIUM) {         Big arrays, pseudomedian of 9
                    int s = len8;
                    l = med3(column, l,     l+s, l+2s);
                    m = med3(column, m-s,   m,   m+s);
                    n = med3(column, n-2s, n-s, n);
                    }
                    m = med3(column, l, m, n);  Mid-size, pseudomedian of 3
                    }
                    
                     Find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists.
                    medianIndex = cern.colt.Sorting.binarySearchFromTo(splitters,column.getQuick(m),splitFrom,splitTo);
                    if (medianIndex &lt; 0) medianIndex = -medianIndex - 1;  not found
                    if (medianIndex &gt; splitTo) medianIndex = splitTo;  not found, one past the end
                    
                    }
                    splitter = splitters[medianIndex];
                    
                     Partition the list according to the splitter, i.e.
                     Establish invariant: list[i] &lt; splitter &lt;= list[j] for i=from..medianIndex and j=medianIndex+1 .. to
                    int	splitIndex = xPartitionOld(matrix,column,from,to,splitter);
                    splitIndexes[medianIndex] = splitIndex;
                    
                     Optimization: Handle special cases to cut down recursions.
                    if (splitIndex &lt; from) {  no element falls into this bin
                     all bins with splitters[i] &lt;= splitter are empty
                    int i = medianIndex-1;
                    while (i&gt;=splitFrom &amp;&amp; (!(splitter &lt; splitters[i]))) splitIndexes[i--] = splitIndex;
                    splitFrom = medianIndex+1;
                    }
                    else if (splitIndex &gt;= to) {  all elements fall into this bin
                     all bins with splitters[i] &gt;= splitter are empty
                    int i = medianIndex+1;
                    while (i&lt;=splitTo &amp;&amp; (!(splitter &gt; splitters[i]))) splitIndexes[i++] = splitIndex;
                    splitTo = medianIndex-1;
                    }
                    
                     recursively partition left half
                    if (splitFrom &lt;= medianIndex-1) {
                    xPartitionOld(matrix, column, from,         splitIndex, splitters, splitFrom, medianIndex-1,  splitIndexes);
                    }
                    
                     recursively partition right half
                    if (medianIndex+1 &lt;= splitTo) {
                    xPartitionOld(matrix, column, splitIndex+1, to,         splitters, medianIndex+1,  splitTo,   splitIndexes);
                    }                    
                </comment>
            </method>
            <javadoc line="356">
                Same as {@link #partition(int[],int,int,int)} 
                  except that it &lt;i&gt;synchronously&lt;/i&gt; partitions the rows of the given matrix by the values of the given matrix column;
                  This is essentially the same as partitioning a list of composite objects by some instance variable;
                  In other words, two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Let&apos;s say, a &quot;row&quot; is an &quot;object&quot; (tuple, d-dimensional point).
                  A &quot;column&quot; is the list of &quot;object&quot; values of a given variable (field, dimension).
                  A &quot;matrix&quot; is a list of &quot;objects&quot; (tuples, points).
                  &lt;p&gt;
                  Now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension).
                  Two entire rows of the matrix are swapped, whenever two column values indicate so.
                  &lt;p&gt;
                  Of course, the column must not be a column of a different matrix.
                  More formally, there must hold: &lt;br&gt;
                  There exists an &lt;tt&gt;i&lt;/tt&gt; such that &lt;tt&gt;matrix.viewColumn(i)==column&lt;/tt&gt;.
                  Note that arguments are not checked for validity.                
            </javadoc>
            <method name="xPartitionOld" type="int" line="375">
                <params>
                    <param name="matrix" type="ObjectMatrix2D"/>
                    <param name="column" type="ObjectMatrix1D"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="splitter" type="Object"/>
                </params>
                <comment line="377">
                    Object element;   int, Object --&gt; template type dependent
                    for (int i=from-1; ++i&lt;=to; ) {
                    element = column.getQuick(i);
                    if (element &lt; splitter) {
                     swap x[i] with x[from]
                    matrix.swapRows(i,from);
                    from++;
                    }
                    }
                    return from-1;                    
                </comment>
            </method>
        </class>
    </source>