<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt">
        <import package="java.util.Comparator"/>
        <import package="cern.colt.function.ByteComparator"/>
        <import package="cern.colt.function.CharComparator"/>
        <import package="cern.colt.function.DoubleComparator"/>
        <import package="cern.colt.function.FloatComparator"/>
        <import package="cern.colt.function.IntComparator"/>
        <import package="cern.colt.function.LongComparator"/>
        <import package="cern.colt.function.ShortComparator"/>
        <class name="Sorting" line="20">
            <extends class="Object"/>
            <javadoc line="20">
                Quicksorts, mergesorts and binary searches; complements &lt;tt&gt;java.util.Arrays&lt;/tt&gt;.
                  Contains, for example, the quicksort on Comparators and Comparables, which are still missing in &lt;tt&gt;java.util.Arrays&lt;/tt&gt; of JDK 1.2.
                  Also provides mergesorts for types not supported in &lt;tt&gt;java.util.Arrays&lt;/tt&gt;, as well as a couple of other methods for primitive arrays.
                  The quicksorts and mergesorts are the JDK 1.2 V1.26 algorithms, modified as necessary.                
                <see>
                    cern.colt.GenericSorting                    
                </see>
                <see>
                    cern.colt.matrix.doublealgo.Sorting                    
                </see>
                <see>
                    java.util.Arrays                    
                </see>
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.0, 03-Jul-99                    
                </version>
            </javadoc>
            <declaration name="SMALL" type="int" line="34"/>
            <declaration name="MEDIUM" type="int" line="35"/>
            <javadoc line="36">
                Makes this class non instantiable, but still let&apos;s others inherit from it.                
            </javadoc>
            <method name="Sorting" type="constructor" line="39"/>
            <javadoc line="40">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="63">
                <params>
                    <param name="list" type="byte[]"/>
                    <param name="key" type="byte"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="71">
                    key found                    
                </comment>
                <comment line="73">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="byte" line="64"/>
                <scope line="65">
                    <declaration name="mid" type="int" line="66"/>
                </scope>
            </method>
            <javadoc line="74">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="97">
                <params>
                    <param name="list" type="char[]"/>
                    <param name="key" type="char"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="105">
                    key found                    
                </comment>
                <comment line="107">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="char" line="98"/>
                <scope line="99">
                    <declaration name="mid" type="int" line="100"/>
                </scope>
            </method>
            <javadoc line="108">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="131">
                <params>
                    <param name="list" type="double[]"/>
                    <param name="key" type="double"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="139">
                    key found                    
                </comment>
                <comment line="141">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="double" line="132"/>
                <scope line="133">
                    <declaration name="mid" type="int" line="134"/>
                </scope>
            </method>
            <javadoc line="142">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="165">
                <params>
                    <param name="list" type="float[]"/>
                    <param name="key" type="float"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="173">
                    key found                    
                </comment>
                <comment line="175">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="float" line="166"/>
                <scope line="167">
                    <declaration name="mid" type="int" line="168"/>
                </scope>
            </method>
            <javadoc line="176">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="199">
                <params>
                    <param name="list" type="int[]"/>
                    <param name="key" type="int"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="207">
                    key found                    
                </comment>
                <comment line="209">
                    key not found.                    
                </comment>
                <comment line="211">
                    even for very short lists (0,1,2,3 elems) this is only 10% faster
                    while (from&lt;=to &amp;&amp; list[from++] &lt; key) ;
                    if (from&lt;=to) {
                    if (list[--from] == key) return from;
                    }
                    return -(from + 1);                    
                </comment>
                <declaration name="midVal" type="int" line="200"/>
                <scope line="201">
                    <declaration name="mid" type="int" line="202"/>
                </scope>
            </method>
            <javadoc line="219">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="242">
                <params>
                    <param name="list" type="long[]"/>
                    <param name="key" type="long"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="250">
                    key found                    
                </comment>
                <comment line="252">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="long" line="243"/>
                <scope line="244">
                    <declaration name="mid" type="int" line="245"/>
                </scope>
            </method>
            <javadoc line="253">
                Searches the list for the specified value using
                  the binary search algorithm. The list must be sorted into ascending order
                  according to the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  If the list is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which instance
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <param>
                    comparator the comparator by which the list is sorted.                    
                </param>
                <throws>
                    ClassCastException if the list contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
                <see>
                    java.util.Comparator                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="286">
                <params>
                    <param name="list" type="Object[]"/>
                    <param name="key" type="Object"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="comparator" type="java.util.Comparator"/>
                </params>
                <comment line="296">
                    key found                    
                </comment>
                <comment line="298">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="Object" line="287"/>
                <scope line="288">
                    <declaration name="mid" type="int" line="289"/>
                    <declaration name="cmp" type="int" line="291"/>
                </scope>
            </method>
            <javadoc line="299">
                Searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="322">
                <params>
                    <param name="list" type="short[]"/>
                    <param name="key" type="short"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="330">
                    key found                    
                </comment>
                <comment line="332">
                    key not found.                    
                </comment>
                <declaration name="midVal" type="short" line="323"/>
                <scope line="324">
                    <declaration name="mid" type="int" line="325"/>
                </scope>
            </method>
            <javadoc line="333">
                Generically searches the list for the specified value using
                  the binary search algorithm.  The list must &lt;strong&gt;must&lt;/strong&gt; be
                  sorted (as by the sort method) prior to making this call.  If
                  it is not sorted, the results are undefined: in particular, the call
                  may enter an infinite loop.  If the list contains multiple elements
                  equal to the specified key, there is no guarantee which of the multiple elements
                  will be found.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the value to be searched for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    index of the search key, if it is contained in the list;
                      otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The &lt;i&gt;insertion
                      point&lt;/i&gt; is defined as the the point at which the value would
                      be inserted into the list: the index of the first
                      element greater than the key, or &lt;tt&gt;list.length&lt;/tt&gt;, if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &amp;gt;= 0 if
                      and only if the key is found.                    
                </return>
                <see>
                    java.util.Arrays                    
                </see>
            </javadoc>
            <method name="binarySearchFromTo" type="int" line="356">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <comment line="364">
                    key found                    
                </comment>
                <comment line="366">
                    key not found.                    
                </comment>
                <declaration name="dummy" type="int" line="357"/>
                <scope line="358">
                    <declaration name="mid" type="int" line="359"/>
                    <declaration name="comparison" type="int" line="360"/>
                </scope>
            </method>
            <method name="lower_bound" type="int" line="368">
                <params>
                    <param name="array" type="int[]"/>
                    <param name="first" type="int"/>
                    <param name="last" type="int"/>
                    <param name="x" type="int"/>
                </params>
                <declaration name="len" type="int" line="369"/>
                <scope line="370">
                    <declaration name="half" type="int" line="371"/>
                    <declaration name="middle" type="int" line="372"/>
                    <scope line="373"/>
                </scope>
            </method>
            <method name="upper_bound" type="int" line="382">
                <params>
                    <param name="array" type="int[]"/>
                    <param name="first" type="int"/>
                    <param name="last" type="int"/>
                    <param name="x" type="int"/>
                </params>
                <declaration name="len" type="int" line="383"/>
                <scope line="384">
                    <declaration name="half" type="int" line="385"/>
                    <declaration name="middle" type="int" line="386"/>
                    <scope line="389"/>
                </scope>
            </method>
            <method name="inplace_merge" type="void" line="397">
                <params>
                    <param name="array" type="int[]"/>
                    <param name="first" type="int"/>
                    <param name="middle" type="int"/>
                    <param name="last" type="int"/>
                </params>
                <comment line="419">
                    rotate(array, firstCut, middle, secondCut);
                     is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are &quot;static private&quot;)
                     speedup = 1.7
                     begin inline                    
                </comment>
                <comment line="433">
                    end inline                    
                </comment>
                <scope line="400">
                    <scope line="401">
                        <declaration name="tmp" type="int" line="402"/>
                    </scope>
                </scope>
                <declaration name="firstCut" type="int" line="408"/>
                <declaration name="secondCut" type="int" line="409"/>
                <scope line="410"/>
                <scope line="413"/>
                <declaration name="first2" type="int" line="422"/>
                <declaration name="middle2" type="int" line="422"/>
                <declaration name="last2" type="int" line="422"/>
                <scope line="423">
                    <declaration name="first1" type="int" line="424"/>
                    <declaration name="last1" type="int" line="424"/>
                    <declaration name="tmp" type="int" line="425"/>
                    <scope line="426"/>
                    <scope line="428"/>
                    <scope line="430"/>
                </scope>
            </method>
            <javadoc line="439">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="442">
                <params>
                    <param name="x" type="byte"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="ByteComparator"/>
                </params>
                <declaration name="ab" type="int" line="443"/>
                <declaration name="ac" type="int" line="444"/>
                <declaration name="bc" type="int" line="445"/>
            </method>
            <javadoc line="450">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="453">
                <params>
                    <param name="x" type="char"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="CharComparator"/>
                </params>
                <declaration name="ab" type="int" line="454"/>
                <declaration name="ac" type="int" line="455"/>
                <declaration name="bc" type="int" line="456"/>
            </method>
            <javadoc line="461">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="464">
                <params>
                    <param name="x" type="double"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="DoubleComparator"/>
                </params>
                <declaration name="ab" type="int" line="465"/>
                <declaration name="ac" type="int" line="466"/>
                <declaration name="bc" type="int" line="467"/>
            </method>
            <javadoc line="472">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="475">
                <params>
                    <param name="x" type="float"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="FloatComparator"/>
                </params>
                <declaration name="ab" type="int" line="476"/>
                <declaration name="ac" type="int" line="477"/>
                <declaration name="bc" type="int" line="478"/>
            </method>
            <javadoc line="483">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="486">
                <params>
                    <param name="x" type="int"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <declaration name="ab" type="int" line="487"/>
                <declaration name="ac" type="int" line="488"/>
                <declaration name="bc" type="int" line="489"/>
            </method>
            <javadoc line="494">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="497">
                <params>
                    <param name="x" type="long"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="LongComparator"/>
                </params>
                <declaration name="ab" type="int" line="498"/>
                <declaration name="ac" type="int" line="499"/>
                <declaration name="bc" type="int" line="500"/>
            </method>
            <javadoc line="505">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="508">
                <params>
                    <param name="x" type="Object"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                </params>
                <declaration name="ab" type="int" line="509"/>
                <declaration name="ac" type="int" line="510"/>
                <declaration name="bc" type="int" line="511"/>
            </method>
            <javadoc line="516">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="519">
                <params>
                    <param name="x" type="Object"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="Comparator"/>
                </params>
                <declaration name="ab" type="int" line="520"/>
                <declaration name="ac" type="int" line="521"/>
                <declaration name="bc" type="int" line="522"/>
            </method>
            <javadoc line="527">
                Returns the index of the median of the three indexed chars.                
            </javadoc>
            <method name="med3" type="int" line="530">
                <params>
                    <param name="x" type="short"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                    <param name="comp" type="ShortComparator"/>
                </params>
                <declaration name="ab" type="int" line="531"/>
                <declaration name="ac" type="int" line="532"/>
                <declaration name="bc" type="int" line="533"/>
            </method>
            <javadoc line="539">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="559">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="aux" type="byte" line="561"/>
            </method>
            <javadoc line="564">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="593">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="ByteComparator"/>
                </params>
                <declaration name="aux" type="byte" line="595"/>
            </method>
            <javadoc line="598">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="618">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="aux" type="char" line="620"/>
            </method>
            <javadoc line="623">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="652">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="CharComparator"/>
                </params>
                <declaration name="aux" type="char" line="654"/>
            </method>
            <javadoc line="657">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="677">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="680">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="709">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="DoubleComparator"/>
                </params>
                <declaration name="aux" type="double" line="711"/>
            </method>
            <javadoc line="714">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="734">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="737">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="766">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="FloatComparator"/>
                </params>
                <declaration name="aux" type="float" line="768"/>
            </method>
            <javadoc line="771">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="791">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="aux" type="int" line="793"/>
            </method>
            <javadoc line="796">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="825">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="IntComparator"/>
                </params>
                <declaration name="aux" type="int" line="827"/>
            </method>
            <javadoc line="830">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="850">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="aux" type="long" line="852"/>
            </method>
            <javadoc line="855">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="884">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="LongComparator"/>
                </params>
                <declaration name="aux" type="long" line="886"/>
            </method>
            <javadoc line="889">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSort" type="void" line="909">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="aux" type="short" line="911"/>
            </method>
            <javadoc line="914">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="mergeSort" type="void" line="943">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="ShortComparator"/>
                </params>
                <declaration name="aux" type="short" line="945"/>
            </method>
            <method name="mergeSort1" type="void" line="948">
                <params>
                    <param name="src" type="byte"/>
                    <param name="dest" type="byte"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="952">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="960">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="965">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="972">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="949"/>
                <scope line="952"/>
                <declaration name="mid" type="int" line="960"/>
                <scope line="966"/>
                <scope line="972"/>
            </method>
            <method name="mergeSort1" type="void" line="979">
                <params>
                    <param name="src" type="byte"/>
                    <param name="dest" type="byte"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="ByteComparator"/>
                </params>
                <comment line="983">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="991">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="996">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1003">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="980"/>
                <scope line="983"/>
                <declaration name="mid" type="int" line="991"/>
                <scope line="997"/>
                <scope line="1003"/>
            </method>
            <method name="mergeSort1" type="void" line="1010">
                <params>
                    <param name="src" type="char"/>
                    <param name="dest" type="char"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="1014">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1022">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1027">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1034">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1011"/>
                <scope line="1014"/>
                <declaration name="mid" type="int" line="1022"/>
                <scope line="1028"/>
                <scope line="1034"/>
            </method>
            <method name="mergeSort1" type="void" line="1041">
                <params>
                    <param name="src" type="char"/>
                    <param name="dest" type="char"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="CharComparator"/>
                </params>
                <comment line="1045">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1053">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1058">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1065">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1042"/>
                <scope line="1045"/>
                <declaration name="mid" type="int" line="1053"/>
                <scope line="1059"/>
                <scope line="1065"/>
            </method>
            <method name="mergeSort1" type="void" line="1072">
                <params>
                    <param name="src" type="double"/>
                    <param name="dest" type="double"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="1076">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1084">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1089">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1096">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1073"/>
                <scope line="1076"/>
                <declaration name="mid" type="int" line="1084"/>
                <scope line="1090"/>
                <scope line="1096"/>
            </method>
            <method name="mergeSort1" type="void" line="1103">
                <params>
                    <param name="src" type="double"/>
                    <param name="dest" type="double"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="DoubleComparator"/>
                </params>
                <comment line="1107">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1115">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1120">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1127">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1104"/>
                <scope line="1107"/>
                <declaration name="mid" type="int" line="1115"/>
                <scope line="1121"/>
                <scope line="1127"/>
            </method>
            <method name="mergeSort1" type="void" line="1134">
                <params>
                    <param name="src" type="float"/>
                    <param name="dest" type="float"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="1138">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1146">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1151">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1158">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1135"/>
                <scope line="1138"/>
                <declaration name="mid" type="int" line="1146"/>
                <scope line="1152"/>
                <scope line="1158"/>
            </method>
            <method name="mergeSort1" type="void" line="1165">
                <params>
                    <param name="src" type="float"/>
                    <param name="dest" type="float"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="FloatComparator"/>
                </params>
                <comment line="1169">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1177">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1182">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1189">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1166"/>
                <scope line="1169"/>
                <declaration name="mid" type="int" line="1177"/>
                <scope line="1183"/>
                <scope line="1189"/>
            </method>
            <method name="mergeSort1" type="void" line="1196">
                <params>
                    <param name="src" type="int"/>
                    <param name="dest" type="int"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="1200">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1208">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1213">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1220">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1197"/>
                <scope line="1200"/>
                <declaration name="mid" type="int" line="1208"/>
                <scope line="1214"/>
                <scope line="1220"/>
            </method>
            <method name="mergeSort1" type="void" line="1227">
                <params>
                    <param name="src" type="int"/>
                    <param name="dest" type="int"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="IntComparator"/>
                </params>
                <comment line="1231">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1239">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1244">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1251">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1228"/>
                <scope line="1231"/>
                <declaration name="mid" type="int" line="1239"/>
                <scope line="1245"/>
                <scope line="1251"/>
            </method>
            <method name="mergeSort1" type="void" line="1258">
                <params>
                    <param name="src" type="long"/>
                    <param name="dest" type="long"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="1262">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1270">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1275">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1282">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1259"/>
                <scope line="1262"/>
                <declaration name="mid" type="int" line="1270"/>
                <scope line="1276"/>
                <scope line="1282"/>
            </method>
            <method name="mergeSort1" type="void" line="1289">
                <params>
                    <param name="src" type="long"/>
                    <param name="dest" type="long"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="LongComparator"/>
                </params>
                <comment line="1293">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1301">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1306">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1313">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1290"/>
                <scope line="1293"/>
                <declaration name="mid" type="int" line="1301"/>
                <scope line="1307"/>
                <scope line="1313"/>
            </method>
            <method name="mergeSort1" type="void" line="1320">
                <params>
                    <param name="src" type="short"/>
                    <param name="dest" type="short"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                </params>
                <comment line="1324">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1332">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1337">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1344">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1321"/>
                <scope line="1324"/>
                <declaration name="mid" type="int" line="1332"/>
                <scope line="1338"/>
                <scope line="1344"/>
            </method>
            <method name="mergeSort1" type="void" line="1351">
                <params>
                    <param name="src" type="short"/>
                    <param name="dest" type="short"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="c" type="ShortComparator"/>
                </params>
                <comment line="1355">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1363">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="1368">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1375">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="1352"/>
                <scope line="1355"/>
                <declaration name="mid" type="int" line="1363"/>
                <scope line="1369"/>
                <scope line="1375"/>
            </method>
            <method name="mergeSort2" type="void" line="1382">
                <params>
                    <param name="a" type="double"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <comment line="1386">
                    The sort is done in three phases to avoid the expense of using
                     NaN and -0.0 aware comparisons during the main sort.                    
                </comment>
                <comment line="1391">
                    Preprocessing phase:  Move any NaN&apos;s to end of array, count the
                     number of -0.0&apos;s, and turn them into 0.0&apos;s.                    
                </comment>
                <comment line="1410">
                    Main sort phase: mergesort everything but the NaN&apos;s                    
                </comment>
                <comment line="1414">
                    Postprocessing phase: change 0.0&apos;s to -0.0&apos;s as required                    
                </comment>
                <comment line="1416">
                    posn of ANY zero                    
                </comment>
                <comment line="1421">
                    j is now one less than the index of the FIRST zero                    
                </comment>
                <declaration name="NEG_ZERO_BITS" type="long" line="1384"/>
                <declaration name="numNegZeros" type="int" line="1394"/>
                <declaration name="i" type="int" line="1395"/>
                <scope line="1396">
                    <scope line="1397"/>
                    <scope line="1400">
                        <scope line="1401"/>
                    </scope>
                </scope>
                <declaration name="aux" type="double" line="1410"/>
                <scope line="1414">
                    <declaration name="j" type="int" line="1415"/>
                    <scope line="1416"/>
                </scope>
            </method>
            <method name="mergeSort2" type="void" line="1425">
                <params>
                    <param name="a" type="float"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <comment line="1429">
                    The sort is done in three phases to avoid the expense of using
                     NaN and -0.0 aware comparisons during the main sort.                    
                </comment>
                <comment line="1434">
                    Preprocessing phase:  Move any NaN&apos;s to end of array, count the
                     number of -0.0&apos;s, and turn them into 0.0&apos;s.                    
                </comment>
                <comment line="1453">
                    Main sort phase: mergesort everything but the NaN&apos;s                    
                </comment>
                <comment line="1457">
                    Postprocessing phase: change 0.0&apos;s to -0.0&apos;s as required                    
                </comment>
                <comment line="1459">
                    posn of ANY zero                    
                </comment>
                <comment line="1464">
                    j is now one less than the index of the FIRST zero                    
                </comment>
                <declaration name="NEG_ZERO_BITS" type="int" line="1427"/>
                <declaration name="numNegZeros" type="int" line="1437"/>
                <declaration name="i" type="int" line="1438"/>
                <scope line="1439">
                    <scope line="1440"/>
                    <scope line="1443">
                        <scope line="1444"/>
                    </scope>
                </scope>
                <declaration name="aux" type="float" line="1453"/>
                <scope line="1457">
                    <declaration name="j" type="int" line="1458"/>
                    <scope line="1459"/>
                </scope>
            </method>
            <javadoc line="1468">
                Sorts the specified range of the specified array of elements.
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="mergeSortInPlace" type="void" line="1488">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <comment line="1493">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1503">
                    Recursively sort halves                    
                </comment>
                <comment line="1508">
                    If list is already sorted, nothing left to do.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="1512">
                    Merge sorted halves
                    jal.INT.Sorting.inplace_merge(a, fromIndex, mid, toIndex);                    
                </comment>
                <declaration name="length" type="int" line="1490"/>
                <scope line="1493">
                    <scope line="1494">
                        <scope line="1495">
                            <declaration name="tmp" type="int" line="1496"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="mid" type="int" line="1503"/>
            </method>
            <javadoc line="1515">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1542">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="ByteComparator"/>
                </params>
            </method>
            <javadoc line="1546">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1573">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="CharComparator"/>
                </params>
            </method>
            <javadoc line="1577">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1604">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="DoubleComparator"/>
                </params>
            </method>
            <javadoc line="1608">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1635">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="FloatComparator"/>
                </params>
            </method>
            <javadoc line="1639">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1666">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="IntComparator"/>
                </params>
            </method>
            <javadoc line="1670">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1697">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="LongComparator"/>
                </params>
            </method>
            <javadoc line="1701">
                Sorts the specified range of the receiver into
                  ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of its
                  elements.  All elements in this range must implement the
                  &lt;tt&gt;Comparable&lt;/tt&gt; interface.  Furthermore, all elements in this range
                  must be &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt;
                  must not throw a &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements
                  &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in the array).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort, adapted from Jon
                  L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a Sort Function&quot;,
                  Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November
                  1993).  This algorithm offers nlog(n) performance on many data sets
                  that cause other quicksorts to degrade to quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
            </javadoc>
            <method name="quickSort" type="void" line="1718">
                <params>
                    <param name="a" type="Object[]"/>
                </params>
            </method>
            <javadoc line="1721">
                Sorts the specified range of the receiver into
                  ascending order, according to the &lt;i&gt;natural ordering&lt;/i&gt; of its
                  elements.  All elements in this range must implement the
                  &lt;tt&gt;Comparable&lt;/tt&gt; interface.  Furthermore, all elements in this range
                  must be &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt;
                  must not throw a &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements
                  &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; in the array).&lt;p&gt;                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="quickSort" type="void" line="1738">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="1742">
                Sorts the specified range of the specified array according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the receiver.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1769">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="Comparator"/>
                </params>
            </method>
            <javadoc line="1773">
                Sorts the specified array according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  The sorting algorithm is a tuned quicksort,
                  adapted from Jon L. Bentley and M. Douglas McIlroy&apos;s &quot;Engineering a
                  Sort Function&quot;, Software-Practice and Experience, Vol. 23(11)
                  P. 1249-1265 (November 1993).  This algorithm offers nlog(n)
                  performance on many data sets that cause other quicksorts to degrade to
                  quadratic performance.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the receiver.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1797">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="c" type="Comparator"/>
                </params>
            </method>
            <javadoc line="1800">
                Sorts the specified range of the specified array of elements according
                  to the order induced by the specified comparator.  All elements in the
                  range must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator
                  (that is, &lt;tt&gt;c.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the range).&lt;p&gt;
                  This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.&lt;p&gt;
                  The sorting algorithm is a modified mergesort (in which the merge is
                  omitted if the highest element in the low sublist is less than the
                  lowest element in the high sublist).  This algorithm offers guaranteed
                  nlog(n) performance, and can approach linear performance on nearly
                  sorted lists.                
                <param>
                    a the array to be sorted.                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted.                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the array.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
                      &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;                    
                </throws>
                <see>
                    Comparator                    
                </see>
            </javadoc>
            <method name="quickSort" type="void" line="1829">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="ShortComparator"/>
                </params>
            </method>
            <javadoc line="1833">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="1836">
                <params>
                    <param name="x" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="ByteComparator"/>
                </params>
                <comment line="1838">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1846">
                    Choose a partition element, v                    
                </comment>
                <comment line="1847">
                    Small arrays, middle element                    
                </comment>
                <comment line="1851">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="1857">
                    Mid-size, med of 3                    
                </comment>
                <comment line="1861">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="1880">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="1885">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="1838"/>
                <declaration name="m" type="int" line="1846"/>
                <scope line="1847">
                    <declaration name="l" type="int" line="1848"/>
                    <declaration name="n" type="int" line="1849"/>
                    <scope line="1850">
                        <declaration name="s" type="int" line="1851"/>
                    </scope>
                </scope>
                <declaration name="v" type="byte" line="1858"/>
                <declaration name="a" type="int" line="1861"/>
                <scope line="1862">
                    <declaration name="comparison" type="int" line="1863"/>
                    <scope line="1864"/>
                    <scope line="1869"/>
                </scope>
                <declaration name="s" type="int" line="1880"/>
            </method>
            <javadoc line="1890">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="1893">
                <params>
                    <param name="x" type="char"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="CharComparator"/>
                </params>
                <comment line="1895">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1903">
                    Choose a partition element, v                    
                </comment>
                <comment line="1904">
                    Small arrays, middle element                    
                </comment>
                <comment line="1908">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="1914">
                    Mid-size, med of 3                    
                </comment>
                <comment line="1918">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="1937">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="1942">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="1895"/>
                <declaration name="m" type="int" line="1903"/>
                <scope line="1904">
                    <declaration name="l" type="int" line="1905"/>
                    <declaration name="n" type="int" line="1906"/>
                    <scope line="1907">
                        <declaration name="s" type="int" line="1908"/>
                    </scope>
                </scope>
                <declaration name="v" type="char" line="1915"/>
                <declaration name="a" type="int" line="1918"/>
                <scope line="1919">
                    <declaration name="comparison" type="int" line="1920"/>
                    <scope line="1921"/>
                    <scope line="1926"/>
                </scope>
                <declaration name="s" type="int" line="1937"/>
            </method>
            <javadoc line="1947">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="1950">
                <params>
                    <param name="x" type="double"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="DoubleComparator"/>
                </params>
                <comment line="1952">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="1960">
                    Choose a partition element, v                    
                </comment>
                <comment line="1961">
                    Small arrays, middle element                    
                </comment>
                <comment line="1965">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="1971">
                    Mid-size, med of 3                    
                </comment>
                <comment line="1975">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="1994">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="1999">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="1952"/>
                <declaration name="m" type="int" line="1960"/>
                <scope line="1961">
                    <declaration name="l" type="int" line="1962"/>
                    <declaration name="n" type="int" line="1963"/>
                    <scope line="1964">
                        <declaration name="s" type="int" line="1965"/>
                    </scope>
                </scope>
                <declaration name="v" type="double" line="1972"/>
                <declaration name="a" type="int" line="1975"/>
                <scope line="1976">
                    <declaration name="comparison" type="int" line="1977"/>
                    <scope line="1978"/>
                    <scope line="1983"/>
                </scope>
                <declaration name="s" type="int" line="1994"/>
            </method>
            <javadoc line="2004">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2007">
                <params>
                    <param name="x" type="float"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="FloatComparator"/>
                </params>
                <comment line="2009">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2017">
                    Choose a partition element, v                    
                </comment>
                <comment line="2018">
                    Small arrays, middle element                    
                </comment>
                <comment line="2022">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="2028">
                    Mid-size, med of 3                    
                </comment>
                <comment line="2032">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2051">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2056">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2009"/>
                <declaration name="m" type="int" line="2017"/>
                <scope line="2018">
                    <declaration name="l" type="int" line="2019"/>
                    <declaration name="n" type="int" line="2020"/>
                    <scope line="2021">
                        <declaration name="s" type="int" line="2022"/>
                    </scope>
                </scope>
                <declaration name="v" type="float" line="2029"/>
                <declaration name="a" type="int" line="2032"/>
                <scope line="2033">
                    <declaration name="comparison" type="int" line="2034"/>
                    <scope line="2035"/>
                    <scope line="2040"/>
                </scope>
                <declaration name="s" type="int" line="2051"/>
            </method>
            <javadoc line="2061">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2064">
                <params>
                    <param name="x" type="int"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="IntComparator"/>
                </params>
                <comment line="2066">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2074">
                    Choose a partition element, v                    
                </comment>
                <comment line="2075">
                    Small arrays, middle element                    
                </comment>
                <comment line="2079">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="2085">
                    Mid-size, med of 3                    
                </comment>
                <comment line="2089">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2108">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2113">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2066"/>
                <declaration name="m" type="int" line="2074"/>
                <scope line="2075">
                    <declaration name="l" type="int" line="2076"/>
                    <declaration name="n" type="int" line="2077"/>
                    <scope line="2078">
                        <declaration name="s" type="int" line="2079"/>
                    </scope>
                </scope>
                <declaration name="v" type="int" line="2086"/>
                <declaration name="a" type="int" line="2089"/>
                <scope line="2090">
                    <declaration name="comparison" type="int" line="2091"/>
                    <scope line="2092"/>
                    <scope line="2097"/>
                </scope>
                <declaration name="s" type="int" line="2108"/>
            </method>
            <javadoc line="2118">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2121">
                <params>
                    <param name="x" type="long"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="LongComparator"/>
                </params>
                <comment line="2123">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2131">
                    Choose a partition element, v                    
                </comment>
                <comment line="2132">
                    Small arrays, middle element                    
                </comment>
                <comment line="2136">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="2142">
                    Mid-size, med of 3                    
                </comment>
                <comment line="2146">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2165">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2170">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2123"/>
                <declaration name="m" type="int" line="2131"/>
                <scope line="2132">
                    <declaration name="l" type="int" line="2133"/>
                    <declaration name="n" type="int" line="2134"/>
                    <scope line="2135">
                        <declaration name="s" type="int" line="2136"/>
                    </scope>
                </scope>
                <declaration name="v" type="long" line="2143"/>
                <declaration name="a" type="int" line="2146"/>
                <scope line="2147">
                    <declaration name="comparison" type="int" line="2148"/>
                    <scope line="2149"/>
                    <scope line="2154"/>
                </scope>
                <declaration name="s" type="int" line="2165"/>
            </method>
            <javadoc line="2175">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2178">
                <params>
                    <param name="x" type="Object"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="2180">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2188">
                    Choose a partition element, v                    
                </comment>
                <comment line="2189">
                    Small arrays, middle element                    
                </comment>
                <comment line="2193">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="2199">
                    Mid-size, med of 3                    
                </comment>
                <comment line="2203">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2222">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2227">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2180"/>
                <declaration name="m" type="int" line="2188"/>
                <scope line="2189">
                    <declaration name="l" type="int" line="2190"/>
                    <declaration name="n" type="int" line="2191"/>
                    <scope line="2192">
                        <declaration name="s" type="int" line="2193"/>
                    </scope>
                </scope>
                <declaration name="v" type="Comparable" line="2200"/>
                <declaration name="a" type="int" line="2203"/>
                <scope line="2204">
                    <declaration name="comparison" type="int" line="2205"/>
                    <scope line="2206"/>
                    <scope line="2211"/>
                </scope>
                <declaration name="s" type="int" line="2222"/>
            </method>
            <javadoc line="2232">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2235">
                <params>
                    <param name="x" type="Object"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="Comparator"/>
                </params>
                <comment line="2237">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2245">
                    Choose a partition element, v                    
                </comment>
                <comment line="2246">
                    Small arrays, middle element                    
                </comment>
                <comment line="2250">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="2256">
                    Mid-size, med of 3                    
                </comment>
                <comment line="2260">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2279">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2284">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2237"/>
                <declaration name="m" type="int" line="2245"/>
                <scope line="2246">
                    <declaration name="l" type="int" line="2247"/>
                    <declaration name="n" type="int" line="2248"/>
                    <scope line="2249">
                        <declaration name="s" type="int" line="2250"/>
                    </scope>
                </scope>
                <declaration name="v" type="Object" line="2257"/>
                <declaration name="a" type="int" line="2260"/>
                <scope line="2261">
                    <declaration name="comparison" type="int" line="2262"/>
                    <scope line="2263"/>
                    <scope line="2268"/>
                </scope>
                <declaration name="s" type="int" line="2279"/>
            </method>
            <javadoc line="2289">
                Sorts the specified sub-array of chars into ascending order.                
            </javadoc>
            <method name="quickSort1" type="void" line="2292">
                <params>
                    <param name="x" type="short"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="comp" type="ShortComparator"/>
                </params>
                <comment line="2294">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="2302">
                    Choose a partition element, v                    
                </comment>
                <comment line="2303">
                    Small arrays, middle element                    
                </comment>
                <comment line="2307">
                    Big arrays, pseudomedian of 9                    
                </comment>
                <comment line="2313">
                    Mid-size, med of 3                    
                </comment>
                <comment line="2317">
                    Establish Invariant: v* (&lt;v)* (&gt;v)* v*                    
                </comment>
                <comment line="2336">
                    Swap partition elements back to middle                    
                </comment>
                <comment line="2341">
                    Recursively sort non-partition-elements                    
                </comment>
                <scope line="2294"/>
                <declaration name="m" type="int" line="2302"/>
                <scope line="2303">
                    <declaration name="l" type="int" line="2304"/>
                    <declaration name="n" type="int" line="2305"/>
                    <scope line="2306">
                        <declaration name="s" type="int" line="2307"/>
                    </scope>
                </scope>
                <declaration name="v" type="short" line="2314"/>
                <declaration name="a" type="int" line="2317"/>
                <scope line="2318">
                    <declaration name="comparison" type="int" line="2319"/>
                    <scope line="2320"/>
                    <scope line="2325"/>
                </scope>
                <declaration name="s" type="int" line="2336"/>
            </method>
            <javadoc line="2346">
                Check that fromIndex and toIndex are in range, and throw an
                  appropriate exception if they aren&apos;t.                
            </javadoc>
            <method name="rangeCheck" type="void" line="2350">
                <params>
                    <param name="arrayLen" type="int"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="2359">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2362">
                <params>
                    <param name="x" type="byte"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="byte" line="2363"/>
            </method>
            <javadoc line="2367">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2370">
                <params>
                    <param name="x" type="char"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="char" line="2371"/>
            </method>
            <javadoc line="2375">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2378">
                <params>
                    <param name="x" type="double"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="double" line="2379"/>
            </method>
            <javadoc line="2383">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2386">
                <params>
                    <param name="x" type="float"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="float" line="2387"/>
            </method>
            <javadoc line="2391">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2394">
                <params>
                    <param name="x" type="int"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="int" line="2395"/>
            </method>
            <javadoc line="2399">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2402">
                <params>
                    <param name="x" type="long"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="long" line="2403"/>
            </method>
            <javadoc line="2407">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2410">
                <params>
                    <param name="x" type="Object"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="Object" line="2411"/>
            </method>
            <javadoc line="2415">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="2418">
                <params>
                    <param name="x" type="short"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="short" line="2419"/>
            </method>
            <javadoc line="2423">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2426">
                <params>
                    <param name="x" type="byte"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2430">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2433">
                <params>
                    <param name="x" type="char"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2437">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2440">
                <params>
                    <param name="x" type="double"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2444">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2447">
                <params>
                    <param name="x" type="float"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2451">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2454">
                <params>
                    <param name="x" type="int"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2458">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2461">
                <params>
                    <param name="x" type="long"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2465">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2468">
                <params>
                    <param name="x" type="Object"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2472">
                Swaps x[a .. (a+n-1)] with x[b .. (b+n-1)].                
            </javadoc>
            <method name="vecswap" type="void" line="2475">
                <params>
                    <param name="x" type="short"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="n" type="int"/>
                </params>
            </method>
        </class>
    </source>