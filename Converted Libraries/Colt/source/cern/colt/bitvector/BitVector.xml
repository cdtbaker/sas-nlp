<?xml version="1.0" encoding="UTF-8"?>
    <source package="cern.colt.bitvector">
        <class name="BitVector" line="11">
            <extends class="cern.colt.PersistentObject"/>
            <comment line="53">
                Bits are packed into arrays of &quot;units.&quot;  Currently a unit is a long,
                 which consists of 64 bits, requiring 6 address bits.  The choice of unit
                 is determined purely by performance concerns.                
            </comment>
            <comment line="68">
                the size                
            </comment>
            <comment line="70">
                IntProcedure for method indexOfFromTo(...)                
            </comment>
            <javadoc line="11">
                Fixed sized (non resizable) bitvector.
                  Upon instance construction a bitvector is told to hold a fixed number of bits - it&apos;s size.
                  The size can be any number (need not be a power of 2 or so).
                  The bits of a &lt;tt&gt;BitVector&lt;/tt&gt; are indexed by nonnegative integers. 
                  Any attempt to access a bit at an &lt;tt&gt;index&amp;lt;0 || index&amp;gt;=size()&lt;/tt&gt; will throw an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt;.
                  &lt;p&gt;
                  Individual indexed bits can be examined, set, or cleared.
                  Subranges can quickly be extracted, copied and replaced.
                  Quick iteration over subranges is provided by optimized internal iterators (&lt;tt&gt;forEach()&lt;/tt&gt; methods).
                  One &lt;code&gt;BitVector&lt;/code&gt; may be used to modify the contents of another 
                  &lt;code&gt;BitVector&lt;/code&gt; through logical AND, OR, XOR and other similar operations.
                  &lt;p&gt;
                  All operations consider the bits &lt;tt&gt;0..size()-1&lt;/tt&gt; and nothing else.
                  Operations involving two bitvectors (like AND, OR, XOR, etc.) will throw an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; if the secondary bit vector has a size smaller than the receiver.
                  &lt;p&gt;
                  A &lt;tt&gt;BitVector&lt;/tt&gt; is never automatically resized,
                  but it can manually be grown or shrinked via &lt;tt&gt;setSize(...)&lt;/tt&gt;.
                  &lt;p&gt;
                  For use cases that need to store several bits per information entity, quick accessors are provided that interpret subranges as 64 bit &lt;tt&gt;long&lt;/tt&gt; integers.
                  &lt;p&gt;
                  Why this class? Fist, &lt;tt&gt;boolean[]&lt;/tt&gt; take one byte per stored bit. This class takes one bit per stored bit.
                  Second, many applications find the semantics of &lt;tt&gt;java.util.BitSet&lt;/tt&gt; not particularly helpful for their needs.
                  Third, operations working on all bits of a bitvector are extremely quick.
                  For example, on NT, Pentium Pro 200 Mhz, SunJDK1.2.2, java -classic, for two bitvectors A,B (both much larger than processor cache), the following results are obtained.
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;A.and(B)&lt;/tt&gt; i.e. A = A &amp; B --&gt; runs at about 35 MB/sec
                  &lt;li&gt;&lt;tt&gt;A.cardinality()&lt;/tt&gt;, i.e. determining the selectivity, the number of bits in state &quot;true&quot; --&gt; runs at about 80 MB/sec
                  &lt;li&gt;Similar performance for &lt;tt&gt;or, xor, andNot, not, copy, replace, partFromTo, indexOf, clear&lt;/tt&gt; etc.
                  &lt;/ul&gt;
                  If you need extremely quick access to individual bits: Although getting and setting individual bits with methods &lt;tt&gt;get(...)&lt;/tt&gt;, &lt;tt&gt;set(...)&lt;/tt&gt; and &lt;tt&gt;put(...)&lt;/tt&gt;is quick, it is even quicker (&lt;b&gt;but not safe&lt;/b&gt;) to use &lt;tt&gt;getQuick(...)&lt;/tt&gt; and &lt;tt&gt;putQuick(...)&lt;/tt&gt; or even &lt;tt&gt;QuickBitVector&lt;/tt&gt;.
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt; that this implementation is not synchronized.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    1.01, 11/10/99                    
                </version>
                <see>
                    QuickBitVector                    
                </see>
                <see>
                    BitMatrix                    
                </see>
                <see>
                    java.util.BitSet                    
                </see>
            </javadoc>
            <declaration name="bits" type="long" line="58"/>
            <javadoc line="58">
                The bits of this object.  The ith bit is stored in bits[i/64] at
                  bit position i % 64 (where bit position 0 refers to the least
                  significant bit and 63 refers to the most significant bit).                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="nbits" type="int" line="67"/>
            <class name="IndexProcedure" line="70">
                <implements interface="cern.colt.function.IntProcedure"/>
                <declaration name="foundPos" type="int" line="71"/>
                <method name="apply" type="boolean" line="72">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
            </class>
            <javadoc line="78">
                You normally need not use this method. Use this method only if performance is critical. 
                  Constructs a bit vector with the given backing bits and size.
                  &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
                  So if subsequently you modify the specified array directly via the [] operator, be sure you know what you&apos;re doing.
                  &lt;p&gt;A bitvector is modelled as a long array, i.e. &lt;tt&gt;long[] bits&lt;/tt&gt; holds bits of a bitvector.
                  Each long value holds 64 bits.
                  The i-th bit is stored in bits[i/64] at
                  bit position i % 64 (where bit position 0 refers to the least
                  significant bit and 63 refers to the most significant bit).                
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size &amp;lt; 0 || size &amp;gt; bits.length64&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="BitVector" type="constructor" line="92">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="size" type="int"/>
                </params>
            </method>
            <javadoc line="95">
                Constructs a bit vector that holds &lt;tt&gt;size&lt;/tt&gt; bits. All bits are initially &lt;tt&gt;false&lt;/tt&gt;.                
                <param>
                    size the number of bits the bit vector shall have.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size &amp;lt; 0&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="BitVector" type="constructor" line="101">
                <params>
                    <param name="size" type="int"/>
                </params>
            </method>
            <javadoc line="104">
                Performs a logical &lt;b&gt;AND&lt;/b&gt; of the receiver with another bit vector (A = A &amp; B).
                  The receiver is modified so that a bit in it has the
                  value &lt;code&gt;true&lt;/code&gt; if and only if it already had the 
                  value &lt;code&gt;true&lt;/code&gt; and the corresponding bit in the other bit vector
                  argument has the value &lt;code&gt;true&lt;/code&gt;.                
                <param>
                    other   a bit vector.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size() &amp;gt; other.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="and" type="void" line="114">
                <params>
                    <param name="other" type="BitVector"/>
                </params>
                <comment line="118">
                    cached for speed.                    
                </comment>
                <comment line="119">
                    cached for speed.                    
                </comment>
                <declaration name="theBits" type="long[]" line="117"/>
                <declaration name="otherBits" type="long[]" line="118"/>
            </method>
            <javadoc line="121">
                Clears all of the bits in receiver whose corresponding
                  bit is set in the other bitvector (A = A \ B).
                  In other words, determines the difference (A=A\B) between two bitvectors.                
                <param>
                    other   a bitvector with which to mask the receiver.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size() &amp;gt; other.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="andNot" type="void" line="129">
                <params>
                    <param name="other" type="BitVector"/>
                </params>
                <comment line="132">
                    cached for speed.                    
                </comment>
                <comment line="133">
                    cached for speed.                    
                </comment>
                <declaration name="theBits" type="long[]" line="131"/>
                <declaration name="otherBits" type="long[]" line="132"/>
            </method>
            <javadoc line="135">
                Returns the number of bits currently in the &lt;tt&gt;true&lt;/tt&gt; state.
                  Optimized for speed. Particularly quick if the receiver is either sparse or dense.                
            </javadoc>
            <method name="cardinality" type="int" line="139">
                <comment line="145">
                    determine cardinality on full units                    
                </comment>
                <comment line="149">
                    all bits set?                    
                </comment>
                <comment line="152">
                    more than one bit set?                    
                </comment>
                <comment line="159">
                    determine cardinality on remaining partial unit, if any.                    
                </comment>
                <declaration name="cardinality" type="int" line="140"/>
                <declaration name="fullUnits" type="int" line="141"/>
                <declaration name="bitsPerUnit" type="int" line="142"/>
                <declaration name="theBits" type="long[]" line="145"/>
                <scope line="146">
                    <declaration name="val" type="long" line="147"/>
                    <scope line="148"/>
                    <scope line="151">
                        <scope line="152"/>
                    </scope>
                </scope>
                <scope line="159"/>
            </method>
            <javadoc line="165">
                Checks if the given range is within the contained array&apos;s bounds.                
            </javadoc>
            <method name="checkRangeFromTo" type="void" line="168">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="theSize" type="int"/>
                </params>
            </method>
            <javadoc line="172">
                Sanity check for operations requiring another bitvector with at least the same size.                
            </javadoc>
            <method name="checkSize" type="void" line="175">
                <params>
                    <param name="other" type="BitVector"/>
                </params>
            </method>
            <javadoc line="178">
                Clears all bits of the receiver.                
            </javadoc>
            <method name="clear" type="void" line="181">
                <comment line="186">
                    new LongArrayList(bits).fillFromToWith(0,size()-1,0L);                    
                </comment>
                <declaration name="theBits" type="long[]" line="182"/>
            </method>
            <javadoc line="187">
                Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; to the &quot;clear&quot; (&lt;tt&gt;false&lt;/tt&gt;) state.                
                <param>
                    bitIndex   the index of the bit to be cleared.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;bitIndex&amp;lt;0 || bitIndex&amp;gt;=size()&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="clear" type="void" line="193">
                <params>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="197">
                Cloning this &lt;code&gt;BitVector&lt;/code&gt; produces a new &lt;code&gt;BitVector&lt;/code&gt; 
                  that is equal to it.
                  The clone of the bit vector is another bit vector that has exactly the 
                  same bits set to &lt;code&gt;true&lt;/code&gt; as this bit vector and the same 
                  current size, but independent state.                
                <return>
                    a deep copy of this bit vector.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="206">
                <declaration name="clone" type="BitVector" line="207"/>
            </method>
            <javadoc line="211">
                Returns a deep copy of the receiver; calls &lt;code&gt;clone()&lt;/code&gt; and casts the result.                
                <return>
                    a deep copy of the receiver.                    
                </return>
            </javadoc>
            <method name="copy" type="BitVector" line="216"/>
            <javadoc line="219">
                You normally need not use this method. Use this method only if performance is critical. 
                  Returns the bit vector&apos;s backing bits.
                  &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
                  So if subsequently you modify the returned array directly via the [] operator, be sure you know what you&apos;re doing.
                  &lt;p&gt;A bitvector is modelled as a long array, i.e. &lt;tt&gt;long[] bits&lt;/tt&gt; holds bits of a bitvector.
                  Each long value holds 64 bits.
                  The i-th bit is stored in bits[i/64] at
                  bit position i % 64 (where bit position 0 refers to the least
                  significant bit and 63 refers to the most significant bit).                
            </javadoc>
            <method name="elements" type="long[]" line="231"/>
            <javadoc line="234">
                You normally need not use this method. Use this method only if performance is critical. 
                  Sets the bit vector&apos;s backing bits and size.
                  &lt;b&gt;WARNING:&lt;/b&gt; For efficiency reasons and to keep memory usage low, &lt;b&gt;the array is not copied&lt;/b&gt;.
                  So if subsequently you modify the specified array directly via the [] operator, be sure you know what you&apos;re doing.
                  &lt;p&gt;A bitvector is modelled as a long array, i.e. &lt;tt&gt;long[] bits&lt;/tt&gt; holds bits of a bitvector.
                  Each long value holds 64 bits.
                  The i-th bit is stored in bits[i/64] at
                  bit position i % 64 (where bit position 0 refers to the least
                  significant bit and 63 refers to the most significant bit).                
                <param>
                    bits the backing bits of the bit vector.                    
                </param>
                <param>
                    size the number of bits the bit vector shall hold.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size &amp;lt; 0 || size &amp;gt; bits.length64&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="elements" type="void" line="250">
                <params>
                    <param name="bits" type="long[]"/>
                    <param name="size" type="int"/>
                </params>
            </method>
            <javadoc line="255">
                Compares this object against the specified object.
                  The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is 
                  not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;BitVector&lt;/code&gt; object
                  that has the same size as the receiver and 
                  the same bits set to &lt;code&gt;true&lt;/code&gt; as the receiver.
                  That is, for every nonnegative &lt;code&gt;int&lt;/code&gt; index &lt;code&gt;k&lt;/code&gt;, 
                  &lt;pre&gt;((BitVector)obj).get(k) == this.get(k)&lt;/pre&gt;
                  must be true.                
                <param>
                    obj   the object to compare with.                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the objects are the same;
                      &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="269">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="280">
                    perform logical comparison on full units                    
                </comment>
                <comment line="284">
                    perform logical comparison on remaining bits                    
                </comment>
                <declaration name="other" type="BitVector" line="275"/>
                <declaration name="fullUnits" type="int" line="278"/>
                <declaration name="i" type="int" line="284"/>
                <scope line="285"/>
            </method>
            <javadoc line="292">
                Applies a procedure to each bit index within the specified range that holds a bit in the given state.
                  Starts at index &lt;tt&gt;from&lt;/tt&gt;, moves rightwards to &lt;tt&gt;to&lt;/tt&gt;.
                  Useful, for example, if you want to copy bits into an image or somewhere else.
                  &lt;p&gt;
                  Optimized for speed. Particularly quick if one of the following conditions holds
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;state==true&lt;/tt&gt; and the receiver is sparse (&lt;tt&gt;cardinality()&lt;/tt&gt; is small compared to &lt;tt&gt;size()&lt;/tt&gt;).
                  &lt;li&gt;&lt;tt&gt;state==false&lt;/tt&gt; and the receiver is dense (&lt;tt&gt;cardinality()&lt;/tt&gt; is large compared to &lt;tt&gt;size()&lt;/tt&gt;).
                  &lt;/ul&gt;                
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <param>
                    state element to search for.                    
                </param>
                <param>
                    procedure a procedure object taking as argument the current bit index. Stops iteration if the procedure returns &lt;tt&gt;false&lt;/tt&gt;, otherwise continues.                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; if the procedure stopped before all elements where iterated over, &lt;tt&gt;true&lt;/tt&gt; otherwise.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).                    
                </throws>
            </javadoc>
            <method name="forEachIndexFromToInState" type="boolean" line="310">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="state" type="boolean"/>
                    <param name="procedure" type="cern.colt.function.IntProcedure"/>
                </params>
                <comment line="312">
                    this version is equivalent to the low level version below, but about 100 times slower for large ranges.
                    if (nbits==0) return true;
                    checkRangeFromTo(from, to, nbits);
                    final long[] theBits = this.bits;  cached for speed
                    int length=to-from+1;
                    for (int i=from; --length &gt;= 0; i++) {
                    if (QuickBitVector.get(theBits,i)==state) {
                    if (!function.apply(i)) return false;
                    }
                    }
                    return true;                    
                </comment>
                <comment line="327">
                    This low level implementation exploits the fact that for any full unit one can determine in O(1)
                     whether it contains at least one true bit,
                     and whether it contains at least one false bit.
                     Thus, 64 bits can often be skipped with one simple comparison if the vector is either sparse or dense.
                    
                     However, careful coding must be done for leading andor trailing units which are not entirely contained in the query range.                    
                </comment>
                <comment line="338">
                    System.out.println(&quot;\n&quot;);
                    System.out.println(this);
                    System.out.println(&quot;from=&quot;+from+&quot;, to=&quot;+to+&quot;, bit=&quot;+state);                    
                </comment>
                <comment line="342">
                    Cache some vars for speed.                    
                </comment>
                <comment line="346">
                    Prepare                    
                </comment>
                <comment line="349">
                    current bitvector index                    
                </comment>
                <comment line="351">
                    Iterate over the leading partial unit, if any.                    
                </comment>
                <comment line="354">
                    There exists a leading partial unit.                    
                </comment>
                <comment line="356">
                    System.out.println(&quot;partialWidth1=&quot;+partialWidth);                    
                </comment>
                <comment line="362">
                    leading partial unit is done.                    
                </comment>
                <comment line="365">
                    done                    
                </comment>
                <comment line="367">
                    If there is a trailing partial unit, then there is one full unit less to test.                    
                </comment>
                <comment line="370">
                    trailing partial unit needs to be tested extra.                    
                </comment>
                <comment line="376">
                    System.out.println(&quot;partialWidth2=&quot;+partialWidth);                    
                </comment>
                <comment line="378">
                    Iterate over all full units, if any.
                     (It does not matter that iterating over partial units is a little bit slow,
                     the only thing that matters is that iterating over full units is quick.)                    
                </comment>
                <comment line="383">
                    all 64 bits set                    
                </comment>
                <comment line="385">
                    System.out.println(&quot;fromUnit=&quot;+fromUnit+&quot;, toUnit=&quot;+toUnit);                    
                </comment>
                <comment line="389">
                    at least one element within current unit matches.
                     iterate over all bits within current unit.                    
                </comment>
                <comment line="393">
                    is bit set?                    
                </comment>
                <comment line="400">
                    is bit cleared?                    
                </comment>
                <comment line="411">
                    System.out.println(&quot;trail with i=&quot;+i);                    
                </comment>
                <comment line="413">
                    Iterate over trailing partial unit, if any.                    
                </comment>
                <declaration name="theBits" type="long[]" line="342"/>
                <declaration name="bitsPerUnit" type="int" line="343"/>
                <declaration name="fromUnit" type="int" line="346"/>
                <declaration name="toUnit" type="int" line="347"/>
                <declaration name="i" type="int" line="348"/>
                <declaration name="bitIndex" type="int" line="351"/>
                <declaration name="partialWidth" type="int" line="352"/>
                <scope line="353">
                    <scope line="356">
                        <scope line="357"/>
                    </scope>
                </scope>
                <scope line="368"/>
                <scope line="372"/>
                <declaration name="comparator" type="long" line="380"/>
                <scope line="385">
                    <declaration name="val" type="long" line="386"/>
                    <scope line="387">
                        <scope line="390">
                            <scope line="391">
                                <scope line="392"/>
                            </scope>
                        </scope>
                        <scope line="397">
                            <scope line="398">
                                <scope line="399"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="405"/>
                </scope>
                <scope line="413">
                    <scope line="414"/>
                </scope>
            </method>
            <javadoc line="421">
                Returns from the bitvector the value of the bit with the specified index.
                  The value is &lt;tt&gt;true&lt;/tt&gt; if the bit with the index &lt;tt&gt;bitIndex&lt;/tt&gt; 
                  is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.                
                <param>
                    bitIndex   the bit index.                    
                </param>
                <return>
                    the value of the bit with the specified index.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;bitIndex&amp;lt;0 || bitIndex&amp;gt;=size()&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="get" type="boolean" line="430">
                <params>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="434">
                Returns a long value representing bits of the receiver from index &lt;tt&gt;from&lt;/tt&gt; to index &lt;tt&gt;to&lt;/tt&gt;.
                  Bits are returned as a long value with the return value having bit 0 set to bit &lt;code&gt;from&lt;/code&gt;, ..., bit &lt;code&gt;to-from&lt;/code&gt; set to bit &lt;code&gt;to&lt;/code&gt;.
                  All other bits of the return value are set to 0.
                  If &lt;tt&gt;to-from+1==0&lt;/tt&gt; then returns zero (&lt;tt&gt;0L&lt;/tt&gt;).                
                <param>
                    from index of start bit (inclusive).                    
                </param>
                <param>
                    to index of end bit (inclusive).                    
                </param>
                <return>
                    the specified bits as long value.                    
                </return>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;from&amp;lt;0 || from&amp;gt;=size() || to&amp;lt;0 || to&amp;gt;=size() || to-from+1&lt;0 || to-from+1&gt;64&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="getLongFromTo" type="long" line="444">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="width" type="int" line="445"/>
            </method>
            <javadoc line="450">
                Returns from the bitvector the value of the bit with the specified index; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions.
                  The value is &lt;tt&gt;true&lt;/tt&gt; if the bit with the index &lt;tt&gt;bitIndex&lt;/tt&gt; 
                  is currently set; otherwise, returns &lt;tt&gt;false&lt;/tt&gt;.
                  &lt;p&gt;Provided with invalid parameters this method may return invalid values without throwing any exception.
                  &lt;b&gt;You should only use this method when you are absolutely sure that the index is within bounds.&lt;/b&gt;
                  Precondition (unchecked): &lt;tt&gt;bitIndex &amp;gt;= 0 &amp;&amp; bitIndex &amp;lt; size()&lt;/tt&gt;.                
                <param>
                    bitIndex   the bit index.                    
                </param>
                <return>
                    the value of the bit with the specified index.                    
                </return>
            </javadoc>
            <method name="getQuick" type="boolean" line="462">
                <params>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="465">
                Returns a hash code value for the receiver. The hash code 
                  depends only on which bits have been set within the receiver.
                  The algorithm used to compute it may 
                  be described as follows.&lt;p&gt;
                  Suppose the bits in the receiver were to be stored 
                  in an array of &lt;code&gt;long&lt;/code&gt; integers called, say, 
                  &lt;code&gt;bits&lt;/code&gt;, in such a manner that bit &lt;code&gt;k&lt;/code&gt; is 
                  set in the receiver (for nonnegative values of 
                  &lt;code&gt;k&lt;/code&gt;) if and only if the expression 
                  &lt;pre&gt;((k&amp;gt;&amp;gt;6) &amp;lt; bits.length) &amp;&amp; ((bits[k&amp;gt;&amp;gt;6] &amp; (1L &amp;lt;&amp;lt; (bit &amp; 0x3F))) != 0)&lt;/pre&gt;
                  is true. Then the following definition of the &lt;code&gt;hashCode&lt;/code&gt; 
                  method would be a correct implementation of the actual algorithm:
                  &lt;pre&gt;
                  public int hashCode() {
                  long h = 1234;
                  for (int i = bits.length; --i &amp;gt;= 0; ) {
                  h ^= bits[i]  (i + 1);
                  }
                  return (int)((h &amp;gt;&amp;gt; 32) ^ h);
                  }&lt;/pre&gt;
                  Note that the hash code values change if the set of bits is altered.                
                <return>
                    a hash code value for the receiver.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="490">
                <declaration name="h" type="long" line="491"/>
            </method>
            <javadoc line="496">
                Returns the index of the first occurrence of the specified
                  state. Returns &lt;code&gt;-1&lt;/code&gt; if the receiver does not contain this state.
                  Searches between &lt;code&gt;from&lt;/code&gt;, inclusive and &lt;code&gt;to&lt;/code&gt;, inclusive.
                  &lt;p&gt;
                  Optimized for speed. Preliminary performance (200Mhz Pentium Pro, JDK 1.2, NT): size=10^6, from=0, to=size-1, receiver contains matching state in the very end --&gt; 0.002 seconds elapsed time.                
                <param>
                    state state to search for.                    
                </param>
                <param>
                    from the leftmost search position, inclusive.                    
                </param>
                <param>
                    to the rightmost search position, inclusive.                    
                </param>
                <return>
                    the index of the first occurrence of the element in the receiver; returns &lt;code&gt;-1&lt;/code&gt; if the element is not found.                    
                </return>
                <exception>
                    IndexOutOfBoundsException if (&lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;).                    
                </exception>
            </javadoc>
            <method name="indexOfFromTo" type="int" line="509">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="state" type="boolean"/>
                </params>
                <declaration name="indexProcedure" type="IndexProcedure" line="510"/>
            </method>
            <javadoc line="514">
                Performs a logical &lt;b&gt;NOT&lt;/b&gt; on the bits of the receiver (A = ~A).                
            </javadoc>
            <method name="not" type="void" line="517">
                <declaration name="theBits" type="long[]" line="518"/>
            </method>
            <javadoc line="521">
                Returns the number of bits used in the trailing PARTIAL unit.
                  Returns zero if there is no such trailing partial unit.                
            </javadoc>
            <method name="numberOfBitsInPartialUnit" type="int" line="525"/>
            <javadoc line="528">
                Returns the number of units that are FULL (not PARTIAL).                
            </javadoc>
            <method name="numberOfFullUnits" type="int" line="531"/>
            <javadoc line="534">
                Performs a logical &lt;b&gt;OR&lt;/b&gt; of the receiver with another bit vector (A = A | B).
                  The receiver is modified so that a bit in it has the
                  value &lt;code&gt;true&lt;/code&gt; if and only if it either already had the 
                  value &lt;code&gt;true&lt;/code&gt; or the corresponding bit in the other bit vector
                  argument has the value &lt;code&gt;true&lt;/code&gt;.                
                <param>
                    other   a bit vector.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size() &amp;gt; other.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="or" type="void" line="544">
                <params>
                    <param name="other" type="BitVector"/>
                </params>
                <comment line="548">
                    cached for speed.                    
                </comment>
                <comment line="549">
                    cached for speed.                    
                </comment>
                <declaration name="theBits" type="long[]" line="547"/>
                <declaration name="otherBits" type="long[]" line="548"/>
            </method>
            <javadoc line="551">
                Constructs and returns a new bit vector which is a copy of the given range.
                  The new bitvector has &lt;tt&gt;size()==to-from+1&lt;/tt&gt;.                
                <param>
                    from the start index within the receiver, inclusive.                    
                </param>
                <param>
                    to the end index within the receiver, inclusive.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size()))&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="partFromTo" type="BitVector" line="559">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="width" type="int" line="563"/>
                <declaration name="part" type="BitVector" line="564"/>
            </method>
            <javadoc line="568">
                Sets the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; to the state specified by &lt;tt&gt;value&lt;/tt&gt;.                
                <param>
                    bitIndex   the index of the bit to be changed.                    
                </param>
                <param>
                    value   the value to be stored in the bit.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;bitIndex&amp;lt;0 || bitIndex&amp;gt;=size()&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="put" type="void" line="575">
                <params>
                    <param name="bitIndex" type="int"/>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="582">
                Sets bits of the receiver from index &lt;code&gt;from&lt;/code&gt; to index &lt;code&gt;to&lt;/code&gt; to the bits of &lt;code&gt;value&lt;/code&gt;.
                  Bit &lt;code&gt;from&lt;/code&gt; is set to bit 0 of &lt;code&gt;value&lt;/code&gt;, ..., bit &lt;code&gt;to&lt;/code&gt; is set to bit &lt;code&gt;to-from&lt;/code&gt; of &lt;code&gt;value&lt;/code&gt;.
                  All other bits stay unaffected.
                  If &lt;tt&gt;to-from+1==0&lt;/tt&gt; then does nothing.                
                <param>
                    value the value to be copied into the receiver.                    
                </param>
                <param>
                    from index of start bit (inclusive).                    
                </param>
                <param>
                    to index of end bit (inclusive).                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;from&amp;lt;0 || from&amp;gt;=size() || to&amp;lt;0 || to&amp;gt;=size() || to-from+1&lt;0 || to-from+1&gt;64&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="putLongFromTo" type="void" line="592">
                <params>
                    <param name="value" type="long"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="width" type="int" line="593"/>
            </method>
            <javadoc line="598">
                Sets the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; to the state specified by &lt;tt&gt;value&lt;/tt&gt;; &lt;b&gt;WARNING:&lt;/b&gt; Does not check preconditions.
                  &lt;p&gt;Provided with invalid parameters this method may set invalid values without throwing any exception.
                  &lt;b&gt;You should only use this method when you are absolutely sure that the index is within bounds.&lt;/b&gt;
                  Precondition (unchecked): &lt;tt&gt;bitIndex &amp;gt;= 0 &amp;&amp; bitIndex &amp;lt; size()&lt;/tt&gt;.                
                <param>
                    bitIndex   the index of the bit to be changed.                    
                </param>
                <param>
                    value   the value to be stored in the bit.                    
                </param>
            </javadoc>
            <method name="putQuick" type="void" line="608">
                <params>
                    <param name="bitIndex" type="int"/>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="614">
                Replaces the bits of the receiver in the given range with the bits of another bit vector.
                  Replaces the range &lt;tt&gt;[from,to]&lt;/tt&gt; with the contents of the range &lt;tt&gt;[sourceFrom,sourceFrom+to-from]&lt;/tt&gt;, all inclusive.
                  If &lt;tt&gt;source==this&lt;/tt&gt; and the source and destination range intersect in an ambiguous way, then replaces as if using an intermediate auxiliary copy of the receiver.
                  &lt;p&gt;
                  Optimized for speed. Preliminary performance (200Mhz Pentium Pro, JDK 1.2, NT): replace 10^6 ill aligned bits --&gt; 0.02 seconds elapsed time.                
                <param>
                    from the start index within the receiver, inclusive.                    
                </param>
                <param>
                    to the end index within the receiver, inclusive.                    
                </param>
                <param>
                    source the source bitvector to copy from.                    
                </param>
                <param>
                    sourceFrom the start index within &lt;tt&gt;source&lt;/tt&gt;, inclusive.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size() || sourceFrom&lt;0 || sourceFrom+to-from+1&gt;source.size()))&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="replaceFromToWith" type="void" line="627">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="source" type="BitVector"/>
                    <param name="sourceFrom" type="int"/>
                </params>
                <comment line="636">
                    dangerous intersection                    
                </comment>
                <comment line="640">
                    cached for speed.                    
                </comment>
                <comment line="641">
                    cached for speed.                    
                </comment>
                <comment line="643">
                    This version is equivalent to the version below but 20 times slower...
                    for (int i=from; --length &gt;= 0; i++, sourceFrom++) {
                    QuickBitVector.put(theBits,i,QuickBitVector.get(sourceBits,sourceFrom));
                    }                    
                </comment>
                <comment line="650">
                    Low level implementation for speed.
                     This could be done even faster by implementing on even lower levels. But then the code would probably become a &quot;don&apos;t touch&quot; piece.                    
                </comment>
                <comment line="653">
                    width/64                    
                </comment>
                <comment line="657">
                    copy entire 64 bit blocks, if any.                    
                </comment>
                <comment line="665">
                    copy trailing bits, if any.                    
                </comment>
                <comment line="666">
                    width%64                    
                </comment>
                <declaration name="length" type="int" line="630"/>
                <scope line="631"/>
                <scope line="635"/>
                <declaration name="theBits" type="long[]" line="639"/>
                <declaration name="sourceBits" type="long[]" line="640"/>
                <declaration name="width" type="int" line="651"/>
                <declaration name="blocks" type="int" line="652"/>
                <declaration name="bitsPerUnit" type="int" line="653"/>
                <declaration name="bitsPerUnitMinusOne" type="int" line="654"/>
                <scope line="657">
                    <declaration name="val" type="long" line="658"/>
                </scope>
                <declaration name="offset" type="int" line="665"/>
                <declaration name="val" type="long" line="666"/>
            </method>
            <javadoc line="669">
                Sets the bits in the given range to the state specified by &lt;tt&gt;value&lt;/tt&gt;.
                  &lt;p&gt;
                  Optimized for speed. Preliminary performance (200Mhz Pentium Pro, JDK 1.2, NT): replace 10^6 ill aligned bits --&gt; 0.002 seconds elapsed time.                
                <param>
                    from the start index, inclusive.                    
                </param>
                <param>
                    to the end index, inclusive.                    
                </param>
                <param>
                    value the value to be stored in the bits of the range.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=size())&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="replaceFromToWith" type="void" line="679">
                <params>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="value" type="boolean"/>
                </params>
                <comment line="683">
                    cached for speed                    
                </comment>
                <comment line="696">
                    only one unit to do                    
                </comment>
                <comment line="698">
                    slower: for (; bitIndex&lt;=to; ) QuickBitVector.put(theBits,bitIndex++,value);                    
                </comment>
                <comment line="702">
                    treat leading partial unit, if any.                    
                </comment>
                <comment line="703">
                    fix by Olivier Janssens                    
                </comment>
                <comment line="706">
                    slower:
                    for (int i=bitsPerUnit-fromOffset; --i &gt;= 0; ) {
                    QuickBitVector.put(theBits,bitIndex++,value);                    
                </comment>
                <comment line="712">
                    there is a trailing partial unit                    
                </comment>
                <comment line="714">
                    treat full units, if any.                    
                </comment>
                <comment line="718">
                    treat trailing partial unit, if any.                    
                </comment>
                <comment line="721">
                    slower:
                    for (int i=toOffset+1; --i &gt;= 0; ) {
                    QuickBitVector.put(theBits,bitIndex++,value);                    
                </comment>
                <declaration name="theBits" type="long[]" line="682"/>
                <declaration name="fromUnit" type="int" line="684"/>
                <declaration name="fromOffset" type="int" line="685"/>
                <declaration name="toUnit" type="int" line="686"/>
                <declaration name="toOffset" type="int" line="687"/>
                <declaration name="bitsPerUnit" type="int" line="688"/>
                <declaration name="filler" type="long" line="690"/>
                <declaration name="bitIndex" type="int" line="694"/>
                <scope line="695"/>
                <scope line="702"/>
                <scope line="718"/>
            </method>
            <javadoc line="726">
                Changes the bit with index &lt;tt&gt;bitIndex&lt;/tt&gt; to the &quot;set&quot; (&lt;tt&gt;true&lt;/tt&gt;) state.                
                <param>
                    bitIndex   the index of the bit to be set.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;bitIndex&amp;lt;0 || bitIndex&amp;gt;=size()&lt;/tt&gt;                    
                </throws>
            </javadoc>
            <method name="set" type="void" line="732">
                <params>
                    <param name="bitIndex" type="int"/>
                </params>
            </method>
            <javadoc line="736">
                Shrinks or expands the receiver so that it holds &lt;tt&gt;newSize&lt;/tt&gt; bits.
                  If the receiver is expanded, additional &lt;tt&gt;false&lt;/tt&gt; bits are added to the end.
                  If the receiver is shrinked, all bits between the old size and the new size are lost; their memory is subject to garbage collection.
                  (This method introduces a new backing array of elements. WARNING: if you have more than one BitVector or BitMatrix sharing identical backing elements, be sure you know what you are doing.)                
                <param>
                    newSize the number of bits the bit vector shall have.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size &amp;lt; 0&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="setSize" type="void" line="745">
                <params>
                    <param name="newSize" type="int"/>
                </params>
                <scope line="746">
                    <declaration name="newVector" type="BitVector" line="747"/>
                </scope>
            </method>
            <javadoc line="752">
                Returns the size of the receiver.                
            </javadoc>
            <method name="size" type="int" line="755"/>
            <javadoc line="758">
                Returns a string representation of the receiver. For every index 
                  for which the receiver contains a bit in the &quot;set&quot; (&lt;tt&gt;true&lt;/tt&gt;)
                  state, the decimal representation of that index is included in 
                  the result. Such indeces are listed in order from lowest to 
                  highest, separated by &quot;,&amp;nbsp;&quot; (a comma and a space) and 
                  surrounded by braces.                
                <return>
                    a string representation of this bit vector.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="768">
                <declaration name="buffer" type="StringBuffer" line="769"/>
                <declaration name="separator" type="String" line="770"/>
                <scope line="773">
                    <scope line="774"/>
                </scope>
            </method>
            <javadoc line="784">
                Performs a logical &lt;b&gt;XOR&lt;/b&gt; of the receiver with another bit vector (A = A ^ B).
                  The receiver is modified so that a bit in it has the
                  value &lt;code&gt;true&lt;/code&gt; if and only if one of the following statements holds:
                  &lt;ul&gt;
                  &lt;li&gt;The bit initially has the value &lt;code&gt;true&lt;/code&gt;, and the 
                  corresponding bit in the argument has the value &lt;code&gt;false&lt;/code&gt;.
                  &lt;li&gt;The bit initially has the value &lt;code&gt;false&lt;/code&gt;, and the 
                  corresponding bit in the argument has the value &lt;code&gt;true&lt;/code&gt;. 
                  &lt;/ul&gt;                
                <param>
                    other   a bit vector.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;size() &amp;gt; other.size()&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="xor" type="void" line="798">
                <params>
                    <param name="other" type="BitVector"/>
                </params>
                <comment line="801">
                    cached for speed.                    
                </comment>
                <comment line="802">
                    cached for speed.                    
                </comment>
                <declaration name="theBits" type="long[]" line="800"/>
                <declaration name="otherBits" type="long[]" line="801"/>
            </method>
        </class>
    </source>