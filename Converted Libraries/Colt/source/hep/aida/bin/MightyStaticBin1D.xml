<?xml version="1.0" encoding="UTF-8"?>
    <source package="hep.aida.bin">
        <import package="cern.colt.list.DoubleArrayList"/>
        <import package="cern.jet.stat.Descriptive"/>
        <class name="MightyStaticBin1D" line="5">
            <extends class="StaticBin1D"/>
            <comment line="17">
                Sum( Log(x[i]) )                
            </comment>
            <comment line="20">
                Sum( 1/x[i] )                
            </comment>
            <comment line="22">
                Sum( x[i]^3 ) .. Sum( x[i]^max_k )                
            </comment>
            <javadoc line="5">
                Static and the same as its superclass, except that it can do more: Additionally computes moments of arbitrary integer order, harmonic mean, geometric mean, etc.
                  Constructors need to be told what functionality is required for the given use case.
                  Only maintains aggregate measures (incrementally) - the added elements themselves are not kept.                
                <author>
                    wolfgang.hoschek@cern.ch                    
                </author>
                <version>
                    0.9, 03-Jul-99                    
                </version>
            </javadoc>
            <declaration name="hasSumOfLogarithms" type="boolean" line="15"/>
            <declaration name="sumOfLogarithms" type="double" line="16"/>
            <declaration name="hasSumOfInversions" type="boolean" line="18"/>
            <declaration name="sumOfInversions" type="double" line="19"/>
            <declaration name="sumOfPowers" type="double[]" line="21"/>
            <javadoc line="22">
                Constructs and returns an empty bin with limited functionality but good performance; equivalent to &lt;tt&gt;MightyStaticBin1D(false,false,4)&lt;/tt&gt;.                
            </javadoc>
            <method name="MightyStaticBin1D" type="constructor" line="25"/>
            <javadoc line="28">
                Constructs and returns an empty bin with the given capabilities.                
                <param>
                    hasSumOfLogarithms  Tells whether {@link #sumOfLogarithms()} can return meaningful results.
                      Set this parameter to &lt;tt&gt;false&lt;/tt&gt; if measures of sum of logarithms, geometric mean and product are not required.
                      &lt;p&gt;                    
                </param>
                <param>
                    hasSumOfInversions  Tells whether {@link #sumOfInversions()} can return meaningful results.
                      Set this parameter to &lt;tt&gt;false&lt;/tt&gt; if measures of sum of inversions, harmonic mean and sumOfPowers(-1) are not required.
                      &lt;p&gt;                    
                </param>
                <param>
                    maxOrderForSumOfPowers  The maximum order &lt;tt&gt;k&lt;/tt&gt; for which {@link #sumOfPowers(int)} can return meaningful results.
                      Set this parameter to at least 3 if the skew is required, to at least 4 if the kurtosis is required.
                      In general, if moments are required set this parameter at least as large as the largest required moment.
                      This method always substitutes &lt;tt&gt;Math.max(2,maxOrderForSumOfPowers)&lt;/tt&gt; for the parameter passed in.
                      Thus, &lt;tt&gt;sumOfPowers(0..2)&lt;/tt&gt; always returns meaningful results.                    
                </param>
                <see>
                    #hasSumOfPowers(int)                    
                </see>
                <see>
                    #moment(int,double)                    
                </see>
            </javadoc>
            <method name="MightyStaticBin1D" type="constructor" line="46">
                <params>
                    <param name="hasSumOfLogarithms" type="boolean"/>
                    <param name="hasSumOfInversions" type="boolean"/>
                    <param name="maxOrderForSumOfPowers" type="int"/>
                </params>
            </method>
            <javadoc line="52">
                Adds the part of the specified list between indexes &lt;tt&gt;from&lt;/tt&gt; (inclusive) and &lt;tt&gt;to&lt;/tt&gt; (inclusive) to the receiver.                
                <param>
                    list the list of which elements shall be added.                    
                </param>
                <param>
                    from the index of the first element to be added (inclusive).                    
                </param>
                <param>
                    to the index of the last element to be added (inclusive).                    
                </param>
                <throws>
                    IndexOutOfBoundsException if &lt;tt&gt;list.size()&amp;gt;0 &amp;&amp; (from&amp;lt;0 || from&amp;gt;to || to&amp;gt;=list.size())&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="addAllOfFromTo" type="void" line="60">
                <params>
                    <param name="list" type="DoubleArrayList"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="65">
                    int max_k = this.min_k + this.sumOfPowers.length-1;                    
                </comment>
                <scope line="63"/>
                <scope line="68"/>
                <scope line="72"/>
            </method>
            <javadoc line="76">
                Resets the values of all measures.                
            </javadoc>
            <method name="clearAllMeasures" type="void" line="79">
                <scope line="85">
                    <scope line="86"/>
                </scope>
            </method>
            <javadoc line="91">
                Returns a deep copy of the receiver.                
                <return>
                    a deep copy of the receiver.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="96">
                <declaration name="clone" type="MightyStaticBin1D" line="97"/>
            </method>
            <javadoc line="101">
                Computes the deviations from the receiver&apos;s measures to another bin&apos;s measures.                
                <param>
                    other the other bin to compare with                    
                </param>
                <return>
                    a summary of the deviations.                    
                </return>
            </javadoc>
            <method name="compareWith" type="String" line="106">
                <params>
                    <param name="other" type="AbstractBin1D"/>
                </params>
                <declaration name="buf" type="StringBuffer" line="107"/>
                <scope line="108">
                    <declaration name="m" type="MightyStaticBin1D" line="109"/>
                </scope>
            </method>
            <javadoc line="122">
                Returns the geometric mean, which is &lt;tt&gt;Product( x[i] )&lt;sup&gt;1.0/size()&lt;/sup&gt;&lt;/tt&gt;.
                  This method tries to avoid overflows at the expense of an equivalent but somewhat inefficient definition:
                  &lt;tt&gt;geoMean = exp( Sum( Log(x[i]) ) / size())&lt;/tt&gt;.
                  Note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.                
                <return>
                    the geometric mean; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfLogarithms()&lt;/tt&gt;.                    
                </return>
            </javadoc>
            <method name="geometricMean" type="double" line="130"/>
            <javadoc line="133">
                Returns the maximum order &lt;tt&gt;k&lt;/tt&gt; for which sums of powers are retrievable, as specified upon instance construction.                
                <see>
                    #hasSumOfPowers(int)                    
                </see>
                <see>
                    #sumOfPowers(int)                    
                </see>
            </javadoc>
            <method name="getMaxOrderForSumOfPowers" type="int" line="138">
                <comment line="140">
                    order 0..2 is always recorded.
                    order 0 is size()
                    order 1 is sum()
                    order 2 is sum_xx()                    
                </comment>
            </method>
            <javadoc line="148">
                Returns the minimum order &lt;tt&gt;k&lt;/tt&gt; for which sums of powers are retrievable, as specified upon instance construction.                
                <see>
                    #hasSumOfPowers(int)                    
                </see>
                <see>
                    #sumOfPowers(int)                    
                </see>
            </javadoc>
            <method name="getMinOrderForSumOfPowers" type="int" line="153">
                <declaration name="minOrder" type="int" line="154"/>
            </method>
            <javadoc line="158">
                Returns the harmonic mean, which is &lt;tt&gt;size() / Sum( 1/x[i] )&lt;/tt&gt;.
                  Remember: If the receiver contains at least one element of &lt;tt&gt;0.0&lt;/tt&gt;, the harmonic mean is &lt;tt&gt;0.0&lt;/tt&gt;.                
                <return>
                    the harmonic mean; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfInversions()&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfInversions()                    
                </see>
            </javadoc>
            <method name="harmonicMean" type="double" line="164"/>
            <javadoc line="167">
                Returns whether &lt;tt&gt;sumOfInversions()&lt;/tt&gt; can return meaningful results.                
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.
                      See the constructors for proper parametrization.                    
                </return>
            </javadoc>
            <method name="hasSumOfInversions" type="boolean" line="172"/>
            <javadoc line="175">
                Tells whether &lt;tt&gt;sumOfLogarithms()&lt;/tt&gt; can return meaningful results.                
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.
                      See the constructors for proper parametrization.                    
                </return>
            </javadoc>
            <method name="hasSumOfLogarithms" type="boolean" line="180"/>
            <javadoc line="183">
                Tells whether &lt;tt&gt;sumOfPowers(k)&lt;/tt&gt; can return meaningful results.
                  Defined as &lt;tt&gt;hasSumOfPowers(k) &lt;==&gt; getMinOrderForSumOfPowers() &lt;= k &amp;&amp; k &lt;= getMaxOrderForSumOfPowers()&lt;/tt&gt;.
                  A return value of &lt;tt&gt;true&lt;/tt&gt; implies that &lt;tt&gt;hasSumOfPowers(k-1) .. hasSumOfPowers(0)&lt;/tt&gt; will also return &lt;tt&gt;true&lt;/tt&gt;.
                  See the constructors for proper parametrization.
                  &lt;p&gt;
                  &lt;b&gt;Details&lt;/b&gt;: 
                  &lt;tt&gt;hasSumOfPowers(0..2)&lt;/tt&gt; will always yield &lt;tt&gt;true&lt;/tt&gt;.
                  &lt;tt&gt;hasSumOfPowers(-1) &lt;==&gt; hasSumOfInversions()&lt;/tt&gt;.                
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.                    
                </return>
                <see>
                    #getMinOrderForSumOfPowers()                    
                </see>
                <see>
                    #getMaxOrderForSumOfPowers()                    
                </see>
            </javadoc>
            <method name="hasSumOfPowers" type="boolean" line="197">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
            <javadoc line="200">
                Returns the kurtosis (aka excess), which is &lt;tt&gt;-3 + moment(4,mean()) / standardDeviation()&lt;sup&gt;4&lt;/sup&gt;&lt;/tt&gt;.                
                <return>
                    the kurtosis; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPowers(4)&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfPowers(int)                    
                </see>
            </javadoc>
            <method name="kurtosis" type="double" line="205"/>
            <javadoc line="208">
                Returns the moment of &lt;tt&gt;k&lt;/tt&gt;-th order with value &lt;tt&gt;c&lt;/tt&gt;,
                  which is &lt;tt&gt;Sum( (x[i]-c)&lt;sup&gt;k&lt;/sup&gt; ) / size()&lt;/tt&gt;.                
                <param>
                    k the order; must be greater than or equal to zero.                    
                </param>
                <param>
                    c any number.                    
                </param>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;k &lt; 0&lt;/tt&gt;.                    
                </throws>
                <return>
                    &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPower(k)&lt;/tt&gt;.                    
                </return>
            </javadoc>
            <method name="moment" type="double" line="217">
                <params>
                    <param name="k" type="int"/>
                    <param name="c" type="double"/>
                </params>
                <comment line="220">
                    checkOrder(k);                    
                </comment>
                <declaration name="maxOrder" type="int" line="222"/>
                <declaration name="sumOfPows" type="DoubleArrayList" line="223"/>
            </method>
            <javadoc line="231">
                Returns the product, which is &lt;tt&gt;Prod( x[i] )&lt;/tt&gt;.
                  In other words: &lt;tt&gt;x[0]x[1]...x[size()-1]&lt;/tt&gt;.                
                <return>
                    the product; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfLogarithms()&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfLogarithms()                    
                </see>
            </javadoc>
            <method name="product" type="double" line="237"/>
            <javadoc line="240">
                Sets the range of orders in which sums of powers are to be computed.
                  In other words, &lt;tt&gt;sumOfPower(k)&lt;/tt&gt; will return &lt;tt&gt;Sum( x[i]^k )&lt;/tt&gt; if &lt;tt&gt;min_k &lt;= k &lt;= max_k || 0 &lt;= k &lt;= 2&lt;/tt&gt;
                  and throw an exception otherwise.                
                <see>
                    #isLegalOrder(int)                    
                </see>
                <see>
                    #sumOfPowers(int)                    
                </see>
                <see>
                    #getRangeForSumOfPowers()                    
                </see>
            </javadoc>
            <method name="setMaxOrderForSumOfPowers" type="void" line="248">
                <params>
                    <param name="max_k" type="int"/>
                </params>
                <comment line="250">
                    if (max_k &lt; ) throw new IllegalArgumentException();                    
                </comment>
                <scope line="251"/>
                <scope line="254"/>
            </method>
            <javadoc line="258">
                Returns the skew, which is &lt;tt&gt;moment(3,mean()) / standardDeviation()&lt;sup&gt;3&lt;/sup&gt;&lt;/tt&gt;.                
                <return>
                    the skew; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPowers(3)&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfPowers(int)                    
                </see>
            </javadoc>
            <method name="skew" type="double" line="263"/>
            <javadoc line="266">
                Returns the sum of inversions, which is &lt;tt&gt;Sum( 1 / x[i] )&lt;/tt&gt;.                
                <return>
                    the sum of inversions; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfInversions()&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfInversions()                    
                </see>
            </javadoc>
            <method name="sumOfInversions" type="double" line="271">
                <comment line="274">
                    if (! this.hasSumOfInversions) throw new IllegalOperationException(&quot;You must specify upon instance construction that the sum of inversions shall be computed.&quot;);                    
                </comment>
            </method>
            <javadoc line="276">
                Returns the sum of logarithms, which is &lt;tt&gt;Sum( Log(x[i]) )&lt;/tt&gt;.                
                <return>
                    the sum of logarithms; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfLogarithms()&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfLogarithms()                    
                </see>
            </javadoc>
            <method name="sumOfLogarithms" type="double" line="281">
                <comment line="284">
                    if (! this.hasSumOfLogarithms) throw new IllegalOperationException(&quot;You must specify upon instance construction that the sum of logarithms shall be computed.&quot;);                    
                </comment>
            </method>
            <javadoc line="286">
                Returns the &lt;tt&gt;k-th&lt;/tt&gt; order sum of powers, which is &lt;tt&gt;Sum( x[i]&lt;sup&gt;k&lt;/sup&gt; )&lt;/tt&gt;.                
                <param>
                    k the order of the powers.                    
                </param>
                <return>
                    the sum of powers; &lt;tt&gt;Double.NaN&lt;/tt&gt; if &lt;tt&gt;!hasSumOfPowers(k)&lt;/tt&gt;.                    
                </return>
                <see>
                    #hasSumOfPowers(int)                    
                </see>
            </javadoc>
            <method name="sumOfPowers" type="double" line="292">
                <params>
                    <param name="k" type="int"/>
                </params>
                <comment line="295">
                    checkOrder(k);                    
                </comment>
            </method>
            <javadoc line="302">
                Returns a String representation of the receiver.                
            </javadoc>
            <method name="toString" type="String" line="305">
                <comment line="320">
                    don&apos;t print tons of measures                    
                </comment>
                <declaration name="buf" type="StringBuffer" line="306"/>
                <scope line="308"/>
                <scope line="313"/>
                <declaration name="maxOrder" type="int" line="318"/>
                <declaration name="maxPrintOrder" type="int" line="319"/>
                <scope line="320">
                    <scope line="321"/>
                    <scope line="324"/>
                    <scope line="327"/>
                    <scope line="330"/>
                    <scope line="333"/>
                </scope>
            </method>
            <javadoc line="339">
                @throws IllegalOperationException if &lt;tt&gt;! isLegalOrder(k)&lt;/tt&gt;.                
            </javadoc>
            <method name="xcheckOrder" type="void" line="342">
                <params>
                    <param name="k" type="int"/>
                </params>
                <comment line="344">
                    if (! isLegalOrder(k)) return Double.NaN;
                    if (! xisLegalOrder(k)) throw new IllegalOperationException(&quot;Illegal order of sum of powers: k=&quot;+k+&quot;. Upon instance construction legal range was fixed to be &quot;+getMinOrderForSumOfPowers()+&quot; &lt;= k &lt;= &quot;+getMaxOrderForSumOfPowers());                    
                </comment>
            </method>
            <javadoc line="346">
                Returns whether two bins are equal; 
                  They are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum, sumOfSquares, sumOfInversions and sumOfLogarithms.                
            </javadoc>
            <method name="xequals" type="boolean" line="350">
                <params>
                    <param name="object" type="Object"/>
                </params>
                <declaration name="other" type="MightyStaticBin1D" line="352"/>
            </method>
            <javadoc line="355">
                Tells whether &lt;tt&gt;sumOfPowers(fromK) .. sumOfPowers(toK)&lt;/tt&gt; can return meaningful results.                
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; if the bin was constructed with insufficient parametrization, &lt;tt&gt;true&lt;/tt&gt; otherwise.
                      See the constructors for proper parametrization.                    
                </return>
                <throws>
                    IllegalArgumentException if &lt;tt&gt;fromK &gt; toK&lt;/tt&gt;.                    
                </throws>
            </javadoc>
            <method name="xhasSumOfPowers" type="boolean" line="361">
                <params>
                    <param name="fromK" type="int"/>
                    <param name="toK" type="int"/>
                </params>
            </method>
            <javadoc line="365">
                Returns &lt;tt&gt;getMinOrderForSumOfPowers() &lt;= k &amp;&amp; k &lt;= getMaxOrderForSumOfPowers()&lt;/tt&gt;.                
            </javadoc>
            <method name="xisLegalOrder" type="boolean" line="368">
                <params>
                    <param name="k" type="int"/>
                </params>
            </method>
        </class>
    </source>