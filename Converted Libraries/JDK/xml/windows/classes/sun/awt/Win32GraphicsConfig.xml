<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt.AWTException"/>
        <import package="java.awt.BufferCapabilities"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.ImageCapabilities"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Toolkit"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.Window"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="sun.awt.windows.WComponentPeer"/>
        <import package="sun.awt.image.OffScreenImage"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.InvalidPipeException"/>
        <import package="sun.java2d.loops.RenderLoops"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.windows.GDIWindowSurfaceData"/>
        <class name="Win32GraphicsConfig" line="60">
            <extends class="GraphicsConfiguration"/>
            <comment line="72">
                PixelFormatID                
            </comment>
            <comment line="232">
                The following methods are invoked from WComponentPeer.java rather
                 than having the Win32-dependent implementations hardcoded in that
                 class.  This way the appropriate actions are taken based on the peer&apos;s
                 GraphicsConfig, whether it is a Win32GraphicsConfig or a
                 WGLGraphicsConfig.                
            </comment>
            <comment line="264">
                The following methods correspond to the multibuffering methods in
                 WComponentPeer.java...                
            </comment>
            <implements interface="DisplayChangedListener"/>
            <implements interface="SurfaceManager.ProxiedGraphicsConfig"/>
            <javadoc line="60">
                This is an implementation of a GraphicsConfiguration object for a
                  single Win32 visual.                
                <see>
                    GraphicsEnvironment                    
                </see>
                <see>
                    GraphicsDevice                    
                </see>
            </javadoc>
            <declaration name="screen" type="Win32GraphicsDevice" line="70"/>
            <declaration name="visual" type="int" line="71"/>
            <declaration name="solidloops" type="RenderLoops" line="72"/>
            <method name="initIDs" type="void" line="74"/>
            <scope line="76"/>
            <javadoc line="80">
                Returns a Win32GraphicsConfiguration object with the given device
                  and PixelFormat.  Note that this method does NOT check to ensure that
                  the returned Win32GraphicsConfig will correctly support rendering into a
                  Java window.  This method is provided so that client code can do its
                  own checking as to the appropriateness of a particular PixelFormat.
                  Safer access to Win32GraphicsConfigurations is provided by
                  Win32GraphicsDevice.getConfigurations().                
            </javadoc>
            <method name="getConfig" type="Win32GraphicsConfig" line="91">
                <params>
                    <param name="device" type="Win32GraphicsDevice"/>
                    <param name="pixFormatID" type="int"/>
                </params>
            </method>
            <javadoc line="95">
                @deprecated as of JDK version 1.3
                  replaced by &lt;code&gt;getConfig()&lt;/code&gt;                
            </javadoc>
            <method name="Win32GraphicsConfig" type="constructor" line="100">
                <params>
                    <param name="device" type="GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                </params>
            </method>
            <javadoc line="106">
                Return the graphics device associated with this configuration.                
            </javadoc>
            <method name="getDevice" type="GraphicsDevice" line="109"/>
            <javadoc line="113">
                Return the PixelFormatIndex this GraphicsConfig uses                
            </javadoc>
            <method name="getVisual" type="int" line="116"/>
            <method name="getProxyKey" type="Object" line="120"/>
            <declaration name="sTypeOrig" type="SurfaceType" line="124"/>
            <javadoc line="124">
                Return the RenderLoops this type of destination uses for
                  solid fills and strokes.                
            </javadoc>
            <method name="getSolidLoops" type="RenderLoops" line="129">
                <params>
                    <param name="stype" type="SurfaceType"/>
                </params>
                <scope line="130"/>
            </method>
            <javadoc line="139">
                Returns the color model associated with this configuration.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="142"/>
            <javadoc line="146">
                Returns a new color model for this configuration.  This call
                  is only used internally, by images and components that are
                  associated with the graphics device.  When attributes of that
                  device change (for example, when the device palette is updated),
                  then this device-based color model will be updated internally
                  to reflect the new situation.                
            </javadoc>
            <method name="getDeviceColorModel" type="ColorModel" line="154"/>
            <javadoc line="158">
                Returns the color model associated with this configuration that
                  supports the specified transparency.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="162">
                <params>
                    <param name="transparency" type="int"/>
                </params>
            </method>
            <javadoc line="175">
                Returns the default Transform for this configuration.  This
                  Transform is typically the Identity transform for most normal
                  screens.  Device coordinates for screen and printer devices will
                  have the origin in the upper left-hand corner of the target region of
                  the device, with X coordinates
                  increasing to the right and Y coordinates increasing downwards.
                  For image buffers, this Transform will be the Identity transform.                
            </javadoc>
            <method name="getDefaultTransform" type="AffineTransform" line="184"/>
            <javadoc line="188">
                Returns a Transform that can be composed with the default Transform
                  of a Graphics2D so that 72 units in user space will equal 1 inch
                  in device space.
                  Given a Graphics2D, g, one can reset the transformation to create
                  such a mapping by using the following pseudocode:
                  &lt;pre&gt;
                  GraphicsConfiguration gc = g.getGraphicsConfiguration();
                  g.setTransform(gc.getDefaultTransform());
                  g.transform(gc.getNormalizingTransform());
                  &lt;/pre&gt;
                  Note that sometimes this Transform will be identity (e.g. for
                  printers or metafile output) and that this Transform is only
                  as accurate as the information supplied by the underlying system.
                  For image buffers, this Transform will be the Identity transform,
                  since there is no valid distance measurement.                
            </javadoc>
            <method name="getNormalizingTransform" type="AffineTransform" line="207">
                <declaration name="ge" type="Win32GraphicsEnvironment" line="208"/>
                <declaration name="xscale" type="double" line="210"/>
                <declaration name="yscale" type="double" line="211"/>
            </method>
            <method name="toString" type="String" line="215"/>
            <method name="getBounds" type="Rectangle" line="219"/>
            <method name="getBounds" type="Rectangle" line="221"/>
            <method name="displayChanged" type="void" line="225"/>
            <method name="paletteChanged" type="void" line="229"/>
            <javadoc line="239">
                Creates a new SurfaceData that will be associated with the given
                  WComponentPeer.                
            </javadoc>
            <method name="createSurfaceData" type="SurfaceData" line="245">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                    <param name="numBackBuffers" type="int"/>
                </params>
            </method>
            <javadoc line="249">
                Creates a new managed image of the given width and height
                  that is associated with the target Component.                
            </javadoc>
            <method name="createAcceleratedImage" type="Image" line="255">
                <params>
                    <param name="target" type="Component"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="model" type="ColorModel" line="256"/>
                <declaration name="wr" type="WritableRaster" line="257"/>
            </method>
            <javadoc line="268">
                Checks that the requested configuration is natively supported; if not,
                  an AWTException is thrown.                
            </javadoc>
            <method name="assertOperationSupported" type="void" line="276">
                <params>
                    <param name="target" type="Component"/>
                    <param name="numBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
                <comment line="278">
                    the default pipeline doesn&apos;t support flip buffer strategy                    
                </comment>
            </method>
            <javadoc line="282">
                This method is called from WComponentPeer when a surface data is replaced
                  REMIND: while the default pipeline doesn&apos;t support flipping, it may
                  happen that the accelerated device may have this graphics config
                  (like if the device restoration failed when one device exits fs mode
                  while others remain).                
            </javadoc>
            <method name="createBackBuffer" type="VolatileImage" line="289">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                </params>
                <declaration name="target" type="Component" line="290"/>
            </method>
            <javadoc line="296">
                Performs the native flip operation for the given target Component.
                  REMIND: we should really not get here because that would mean that
                  a FLIP BufferStrategy has been created, and one could only be created
                  if accelerated pipeline is present but in some rare (and transitional)
                  cases it may happen that the accelerated graphics device may have a
                  default graphics configuraiton, so this is just a precaution.                
            </javadoc>
            <method name="flip" type="void" line="309">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                    <param name="target" type="Component"/>
                    <param name="backBuffer" type="VolatileImage"/>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <comment line="333">
                    the rest of the flip actions are not supported                    
                </comment>
                <scope line="311">
                    <declaration name="g" type="Graphics" line="312"/>
                    <scope line="313"/>
                    <scope line="318"/>
                </scope>
                <scope line="321">
                    <declaration name="g" type="Graphics" line="322"/>
                    <scope line="323"/>
                    <scope line="328"/>
                </scope>
            </method>
            <method name="isTranslucencyCapable" type="boolean" line="336">
                <comment line="338">
                    XXX: worth checking if 8-bit? Anyway, it doesn&apos;t hurt.                    
                </comment>
            </method>
        </class>
    </source>