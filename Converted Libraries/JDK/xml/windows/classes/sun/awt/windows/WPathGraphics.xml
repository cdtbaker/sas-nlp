<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.windows">
        <import package="java.awt.BasicStroke"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Shape"/>
        <import package="java.awt.Stroke"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.awt.font.GlyphVector"/>
        <import package="java.awt.font.TextLayout"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.geom.Line2D"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.IndexColorModel"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.image.ComponentSampleModel"/>
        <import package="java.awt.image.MultiPixelPackedSampleModel"/>
        <import package="java.awt.image.SampleModel"/>
        <import package="sun.awt.image.ByteComponentRaster"/>
        <import package="sun.awt.image.BytePackedRaster"/>
        <import package="java.awt.print.PageFormat"/>
        <import package="java.awt.print.Printable"/>
        <import package="java.awt.print.PrinterException"/>
        <import package="java.awt.print.PrinterJob"/>
        <import package="java.util.Arrays"/>
        <import package="sun.font.CharToGlyphMapper"/>
        <import package="sun.font.CompositeFont"/>
        <import package="sun.font.Font2D"/>
        <import package="sun.font.FontUtilities"/>
        <import package="sun.font.PhysicalFont"/>
        <import package="sun.font.TrueTypeFont"/>
        <import package="sun.print.PathGraphics"/>
        <import package="sun.print.ProxyGraphics2D"/>
        <class name="WPathGraphics" line="77">
            <extends class="PathGraphics"/>
            <comment line="89">
                Note that preferGDITextLayout implies useGDITextLayout.
                 &quot;prefer&quot; is used to override cases where would otherwise
                 choose not to use it. Note that non-layout factors may
                 still mean that GDI cannot be used.                
            </comment>
            <comment line="269">
                A return value of 0 would mean font not available to GDI, or the
                 it can&apos;t be used for this string.
                 A return of 1 means it is suitable, including for composites.
                 We check that the transform in effect is doable with GDI, and that
                 this is a composite font AWT can handle, or a physical font GDI
                 can handle directly. Its possible that some strings may ultimately
                 fail the more stringent tests in drawString but this is rare and
                 also that method will always succeed, as if the font isn&apos;t available
                 it will use outlines via a superclass call. Also it is only called for
                 the default render context (as canDrawStringToWidth() will return
                 false. That is why it ignores the frc and width arguments.                
            </comment>
            <comment line="325">
                In case GDI doesn&apos;t handle shaping or BIDI consistently with
                 2D&apos;s TextLayout, we can detect these cases and redelegate up to
                 be drawn via TextLayout, which in is rendered as runs of
                 GlyphVectors, to which we can assign positions for each glyph.                
            </comment>
            <comment line="832">
                If 2D and GDI agree on the advance of the string we do not
                 need to explicitly assign glyph positions.
                 If we are to use the GDI advance, require it to agree with
                 JDK to a precision of &lt;= 0.2% - ie 1 pixel in 500
                 discrepancy after rounding the 2D advance to the
                 nearest pixel and is greater than one pixel in total.
                 ie strings &lt; 500 pixels in length will be OK so long
                 as they differ by only 1 pixel even though that is &gt; 0.02%
                 The bounds from 2D are in user space so need to
                 be scaled to device space for comparison with GDI.
                 scaleX is the scale from user space to device space needed for this.                
            </comment>
            <comment line="1423">
                Fill the path defined by &lt;code&gt;pathIter&lt;code&gt;
                 with the specified color.
                 The path is provided in device coordinates.                
            </comment>
            <comment line="1437">
                Set the printer device&apos;s clip to be the
                 path defined by &lt;code&gt;pathIter&lt;code&gt;
                 The path is provided in device coordinates.                
            </comment>
            <comment line="1537">
                Fill the rectangle with specified color and using Windows&apos;
                 GDI fillRect function.
                 Boundaries are determined by the given coordinates.                
            </comment>
            <declaration name="DEFAULT_USER_RES" type="int" line="79"/>
            <javadoc line="79">
                For a drawing application the initial user space
                  resolution is 72dpi.                
            </javadoc>
            <declaration name="MIN_DEVICE_LINEWIDTH" type="float" line="85"/>
            <declaration name="MAX_THINLINE_INCHES" type="float" line="86"/>
            <declaration name="useGDITextLayout" type="boolean" line="93"/>
            <declaration name="preferGDITextLayout" type="boolean" line="94"/>
            <scope line="95">
                <declaration name="textLayoutStr" type="String" line="96"/>
                <scope line="101">
                    <scope line="103">
                        <scope line="104"/>
                    </scope>
                </scope>
            </scope>
            <method name="WPathGraphics" type="constructor" line="114">
                <params>
                    <param name="graphics" type="Graphics2D"/>
                    <param name="printerJob" type="PrinterJob"/>
                    <param name="painter" type="Printable"/>
                    <param name="pageFormat" type="PageFormat"/>
                    <param name="pageIndex" type="int"/>
                    <param name="canRedraw" type="boolean"/>
                </params>
            </method>
            <javadoc line="118">
                Creates a new &lt;code&gt;Graphics&lt;/code&gt; object that is
                  a copy of this &lt;code&gt;Graphics&lt;/code&gt; object.                
                <return>
                    a new graphics context that is a copy of
                      this graphics context.                    
                </return>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="create" type="Graphics" line="126"/>
            <javadoc line="136">
                Strokes the outline of a Shape using the settings of the current
                  graphics state.  The rendering attributes applied include the
                  clip, transform, paint or color, composite and stroke attributes.                
                <param>
                    s The shape to be drawn.                    
                </param>
                <see>
                    #setStroke                    
                </see>
                <see>
                    #setPaint                    
                </see>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
                <see>
                    #transform                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #clip                    
                </see>
                <see>
                    #setClip                    
                </see>
                <see>
                    #setComposite                    
                </see>
            </javadoc>
            <method name="draw" type="void" line="151">
                <params>
                    <param name="s" type="Shape"/>
                </params>
                <comment line="155">
                    If the line being drawn is thinner than can be
                     rendered, then change the line width, stroke
                     the shape, and then set the line width back.
                     We can only do this for BasicStroke&apos;s.                    
                </comment>
                <comment line="168">
                    Get the requested line width in user space.                    
                </comment>
                <comment line="174">
                    Compute the line width in device coordinates.
                     Work on a point in case there is asymetric scaling
                     between user and device space.
                     Take the absolute value in case there is negative
                     scaling in effect.                    
                </comment>
                <comment line="185">
                    If the requested line is too thin then map our
                     minimum line width back to user space and set
                     a new BasicStroke.                    
                </comment>
                <comment line="199">
                    Convert the minimum line width from device
                     space to user space.                    
                </comment>
                <comment line="208">
                    Use all of the parameters from the current
                     stroke but change the line width to our
                     calculated minimum.                    
                </comment>
                <comment line="221">
                    If we can&apos;t invert the matrix there is something
                     very wrong so don&apos;t worry about the minor matter
                     of a minimum line width.                    
                </comment>
                <comment line="230">
                    If we changed the stroke, put back the old
                     stroke in order to maintain a minimum line
                     width.                    
                </comment>
                <comment line="238">
                    The stroke in effect was not a BasicStroke so we
                     will not try to enforce a minimum line width.                    
                </comment>
                <declaration name="stroke" type="Stroke" line="153"/>
                <scope line="160">
                    <declaration name="lineStroke" type="BasicStroke" line="161"/>
                    <declaration name="minLineStroke" type="BasicStroke" line="162"/>
                    <declaration name="deviceLineWidth" type="float" line="163"/>
                    <declaration name="lineWidth" type="float" line="164"/>
                    <declaration name="deviceTransform" type="AffineTransform" line="165"/>
                    <declaration name="penSize" type="Point2D.Float" line="166"/>
                    <scope line="189">
                        <declaration name="minPenSize" type="Point2D.Float" line="191"/>
                        <scope line="195">
                            <declaration name="inverse" type="AffineTransform" line="196"/>
                            <declaration name="minLineWidth" type="float" line="197"/>
                        </scope>
                        <scope line="220"/>
                    </scope>
                    <scope line="234"/>
                </scope>
                <scope line="241"/>
            </method>
            <javadoc line="246">
                Draws the text given by the specified string, using this
                  graphics context&apos;s current font and color. The baseline of the
                  first character is at position (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in this
                  graphics context&apos;s coordinate system.                
                <param>
                    str      the string to be drawn.                    
                </param>
                <param>
                    x        the <i>x</i> coordinate.                    
                </param>
                <param>
                    y        the <i>y</i> coordinate.                    
                </param>
                <see>
                    java.awt.Graphics#drawBytes                    
                </see>
                <see>
                    java.awt.Graphics#drawChars                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="drawString" type="void" line="259">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <method name="drawString" type="void" line="264">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <method name="platformFontCount" type="int" line="281">
                <params>
                    <param name="font" type="Font"/>
                    <param name="str" type="String"/>
                </params>
                <comment line="288">
                                        
                </comment>
                <comment line="298">
                    Since all windows fonts are available, and the JRE fonts
                     are also registered. Only the Font.createFont() case is presently
                     unknown to GDI. Those can be registered too, although that
                     code does not exist yet, it can be added too, so we should not
                     fail that case. Just do a quick check whether its a TrueTypeFont
                     - ie not a Type1 font etc, and let drawString() resolve the rest.                    
                </comment>
                <declaration name="deviceTransform" type="AffineTransform" line="283"/>
                <declaration name="fontTransform" type="AffineTransform" line="284"/>
                <declaration name="transformType" type="int" line="286"/>
                <declaration name="directToGDI" type="boolean" line="289"/>
                <scope line="294"/>
                <declaration name="font2D" type="Font2D" line="305"/>
                <scope line="307"/>
                <scope line="309"/>
            </method>
            <method name="isXP" type="boolean" line="314">
                <declaration name="osVersion" type="String" line="315"/>
                <scope line="316">
                    <declaration name="version" type="Float" line="317"/>
                </scope>
                <scope line="319"/>
            </method>
            <method name="strNeedsTextLayout" type="boolean" line="329">
                <params>
                    <param name="str" type="String"/>
                    <param name="font" type="Font"/>
                </params>
                <declaration name="chars" type="char[]" line="330"/>
                <declaration name="isComplex" type="boolean" line="331"/>
                <scope line="332"/>
                <scope line="334"/>
                <scope line="336">
                    <scope line="338"/>
                    <scope line="340"/>
                </scope>
            </method>
            <method name="getAngle" type="int" line="346">
                <params>
                    <param name="pt" type="Point2D.Double"/>
                </params>
                <comment line="347">
                    Get the rotation in 110&apos;ths degree (as needed by Windows)
                     so that GDI can draw the text rotated.
                     This calculation is only valid for a uniform scale, no shearing.                    
                </comment>
                <comment line="355">
                    Windows specifies the rotation anti-clockwise from the x-axis
                     of the device, 2D specifies +ve rotation towards the y-axis
                     Since the 2D y-axis runs from top-to-bottom, windows angle of
                     rotation here is opposite than 2D&apos;s, so the rotation needed
                     needs to be recalculated in the opposite direction.                    
                </comment>
                <declaration name="angle" type="double" line="351"/>
                <scope line="352"/>
                <scope line="361"/>
            </method>
            <method name="getAwScale" type="float" line="367">
                <params>
                    <param name="scaleFactorX" type="double"/>
                    <param name="scaleFactorY" type="double"/>
                </params>
                <comment line="370">
                                        
                </comment>
                <declaration name="awScale" type="float" line="369"/>
                <scope line="371"/>
            </method>
            <javadoc line="377">
                Renders the text specified by the specified &lt;code&gt;String&lt;/code&gt;,
                  using the current &lt;code&gt;Font&lt;/code&gt; and &lt;code&gt;Paint&lt;/code&gt; attributes
                  in the &lt;code&gt;Graphics2D&lt;/code&gt; context.
                  The baseline of the first character is at position
                  (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in the User Space.
                  The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
                  &lt;code&gt;Transform&lt;/code&gt;, &lt;code&gt;Paint&lt;/code&gt;, &lt;code&gt;Font&lt;/code&gt; and
                  &lt;code&gt;Composite&lt;/code&gt; attributes. For characters in script systems
                  such as Hebrew and Arabic, the glyphs can be rendered from right to
                  left, in which case the coordinate supplied is the location of the
                  leftmost character on the baseline.                
                <param>
                    s the <code>String</code> to be rendered                    
                </param>
                <param>
                    x,&nbsp;y the coordinates where the <code>String</code>
                      should be rendered                    
                </param>
                <see>
                    #setPaint                    
                </see>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
                <see>
                    java.awt.Graphics#setFont                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #setComposite                    
                </see>
                <see>
                    #setClip                    
                </see>
            </javadoc>
            <method name="drawString" type="void" line="401">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="targetW" type="float"/>
                </params>
                <comment line="411">
                    If the Font has layout attributes we need to delegate to TextLayout.
                     TextLayout renders text as GlyphVectors. We try to print those
                     using printer fonts - ie using Postscript text operators so
                     we may be reinvoked. In that case the &quot;!printingGlyphVector&quot; test
                     prevents us recursing and instead sends us into the body of the
                     method where we can safely ignore layout attributes as those
                     are already handled by TextLayout.
                     Similarly if layout is needed based on the text, then we
                     delegate to TextLayout if possible, or failing that we delegate
                     upwards to filled shapes.                    
                </comment>
                <comment line="438">
                    Use GDI for the text if the graphics transform is something
                     for which we can obtain a suitable GDI font.
                     A flip or shearing transform on the graphics or a transform
                     on the font force us to decompose the text into a shape.                    
                </comment>
                <comment line="451">
                    peek should detect such paints.                    
                </comment>
                <comment line="460">
                    Now we have checked everything is OK to go through GDI as text
                     with the exception of testing GDI can find and use the font. That
                     is handled in the textOut() call.                    
                </comment>
                <comment line="465">
                    Compute the starting position of the string in
                     device space.                    
                </comment>
                <comment line="471">
                    Already have the translate from the deviceTransform,
                     but the font may have a translation component too.                    
                </comment>
                <comment line="488">
                    Get the font size in device coordinates.
                     The size needed is the font height scaled to device space.
                     Although we have already tested that there is no shear,
                     there may be a non-uniform scale, so the width of the font
                     does not scale equally with the height. That is handled
                     by specifying an &apos;average width&apos; scale to GDI.                    
                </comment>
                <comment line="517">
                    Composite fonts are made up of multiple fonts and each
                     substring that uses a particular component font needs to
                     be separately sent to GDI.
                     This works for standard composite fonts, alternate ones,
                     Fonts that are a physical font backed by a standard composite,
                     and with fallback fonts.                    
                </comment>
                <scope line="402"/>
                <scope line="406"/>
                <declaration name="layoutNeeded" type="boolean" line="422"/>
                <scope line="424">
                    <declaration name="layout" type="TextLayout" line="425"/>
                </scope>
                <scope line="428"/>
                <declaration name="deviceTransform" type="AffineTransform" line="433"/>
                <declaration name="fontTransform" type="AffineTransform" line="434"/>
                <declaration name="transformType" type="int" line="436"/>
                <declaration name="directToGDI" type="boolean" line="443"/>
                <declaration name="wPrinterJob" type="WPrinterJob" line="448"/>
                <scope line="449"/>
                <scope line="451"/>
                <scope line="455"/>
                <declaration name="userpos" type="Point2D.Float" line="468"/>
                <declaration name="devpos" type="Point2D.Float" line="469"/>
                <scope line="474">
                    <declaration name="fontTx" type="AffineTransform" line="475"/>
                    <declaration name="translateX" type="float" line="476"/>
                    <declaration name="translateY" type="float" line="477"/>
                </scope>
                <scope line="484"/>
                <declaration name="fontSize" type="float" line="495"/>
                <declaration name="pty" type="Point2D.Double" line="497"/>
                <declaration name="scaleFactorY" type="double" line="499"/>
                <declaration name="scaledFontSizeY" type="float" line="500"/>
                <declaration name="ptx" type="Point2D.Double" line="502"/>
                <declaration name="scaleFactorX" type="double" line="504"/>
                <declaration name="scaledFontSizeX" type="float" line="505"/>
                <declaration name="awScale" type="float" line="507"/>
                <declaration name="iangle" type="int" line="508"/>
                <declaration name="font2D" type="Font2D" line="510"/>
                <scope line="511"/>
                <scope line="516">
                    <declaration name="compFont" type="CompositeFont" line="524"/>
                    <declaration name="userx" type="float" line="525"/>
                    <declaration name="devx" type="float" line="526"/>
                    <declaration name="chars" type="char[]" line="527"/>
                    <declaration name="len" type="int" line="528"/>
                    <declaration name="glyphs" type="int[]" line="529"/>
                    <declaration name="startChar" type="int" line="532"/>
                    <scope line="533">
                        <scope line="538"/>
                        <declaration name="substr" type="String" line="541"/>
                        <declaration name="slotFont" type="PhysicalFont" line="542"/>
                        <declaration name="bds" type="Rectangle2D" line="547"/>
                        <declaration name="xAdvance" type="float" line="548"/>
                    </scope>
                </scope>
                <scope line="553"/>
            </method>
            <javadoc line="558">
                return true if the Graphics instance can directly print
                  this glyphvector                
            </javadoc>
            <method name="printGlyphVector" type="boolean" line="562">
                <params>
                    <param name="gv" type="GlyphVector"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="563">
                    We don&apos;t want to try to handle per-glyph transforms. GDI can&apos;t
                     handle per-glyph rotations, etc. There&apos;s no way to express it
                     in a single call, so just bail for this uncommon case.                    
                </comment>
                <comment line="577">
                    Use GDI for the text if the graphics transform is something
                     for which we can obtain a suitable GDI font.
                     A flip or shearing transform on the graphics or a transform
                     on the font force us to decompose the text into a shape.                    
                </comment>
                <comment line="589">
                    peek should detect such paints.                    
                </comment>
                <comment line="596">
                    Compute the starting position of the string in
                     device space.                    
                </comment>
                <comment line="602">
                    Already have the translate from the deviceTransform,
                     but the font may have a translation component too.                    
                </comment>
                <comment line="619">
                    Get the font size in device coordinates.
                     The size needed is the font height scaled to device space.
                     Although we have already tested that there is no shear,
                     there may be a non-uniform scale, so the width of the font
                     does not scale equally with the height. That is handled
                     by specifying an &apos;average width&apos; scale to GDI.                    
                </comment>
                <comment line="645">
                    layout replaces glyphs which have been combined away
                     with 0xfffe or 0xffff. These are supposed to be invisible
                     and we need to handle this here as GDI will interpret it
                     as a missing glyph. We&apos;ll do it here by compacting the
                     glyph codes array, but we have to do it in conjunction with
                     compacting the positionsadvances arrays too AND updating
                     the number of glyphs ..
                     Note that since the slot number for composites is in the
                     significant byte we need to mask out that for comparison of
                     the invisible glyph.                    
                </comment>
                <comment line="682">
                    To get GDI to rotate glyphs we need to specify the angle
                     of rotation to GDI when creating the HFONT. This implicitly
                     also rotates the baseline, and this adjusts the X &amp; Y advances
                     of the glyphs accordingly.
                     When we specify the advances, they are in device space, so
                     we don&apos;t want any further interpretation applied by GDI, but
                     since as noted the advances are interpreted in the HFONT&apos;s
                     coordinate space, our advances would be rotated again.
                     We don&apos;t have any way to tell GDI to rotate only the glyphs and
                     not the advances, so we need to account for this in the advances
                     we supply, by supplying unrotated advances.
                     Note that &quot;iangle&quot; is in the opposite direction to 2D&apos;s normal
                     direction of rotation, so this rotation inverts the
                     rotation element of the deviceTransform.                    
                </comment>
                <comment line="702">
                    source                    
                </comment>
                <comment line="703">
                    destination                    
                </comment>
                <comment line="704">
                    num points                    
                </comment>
                <comment line="717">
                    Composite fonts are made up of multiple fonts and each
                     substring that uses a particular component font needs to
                     be separately sent to GDI.
                     This works for standard composite fonts, alternate ones,
                     Fonts that are a physical font backed by a standard composite,
                     and with fallback fonts.                    
                </comment>
                <comment line="737">
                    If we can&apos;t get the font, bail to outlines.
                     But we should always be able to get all fonts for
                     Composites, so this is unlikely, so any overstriking
                     if only one slot is unavailable is not worth worrying
                     about.                    
                </comment>
                <scope line="567"/>
                <declaration name="deviceTransform" type="AffineTransform" line="571"/>
                <declaration name="fontTransform" type="AffineTransform" line="572"/>
                <declaration name="font" type="Font" line="573"/>
                <declaration name="transformType" type="int" line="575"/>
                <declaration name="directToGDI" type="boolean" line="582"/>
                <declaration name="wPrinterJob" type="WPrinterJob" line="586"/>
                <scope line="587"/>
                <scope line="589"/>
                <scope line="593"/>
                <declaration name="userpos" type="Point2D.Float" line="599"/>
                <declaration name="devpos" type="Point2D.Float" line="600"/>
                <scope line="605">
                    <declaration name="fontTx" type="AffineTransform" line="606"/>
                    <declaration name="translateX" type="float" line="607"/>
                    <declaration name="translateY" type="float" line="608"/>
                </scope>
                <scope line="615"/>
                <declaration name="fontSize" type="float" line="626"/>
                <declaration name="pty" type="Point2D.Double" line="628"/>
                <declaration name="scaleFactorY" type="double" line="630"/>
                <declaration name="scaledFontSizeY" type="float" line="631"/>
                <declaration name="pt" type="Point2D.Double" line="633"/>
                <declaration name="scaleFactorX" type="double" line="635"/>
                <declaration name="scaledFontSizeX" type="float" line="636"/>
                <declaration name="awScale" type="float" line="638"/>
                <declaration name="iangle" type="int" line="639"/>
                <declaration name="numGlyphs" type="int" line="641"/>
                <declaration name="glyphCodes" type="int[]" line="642"/>
                <declaration name="glyphPos" type="float[]" line="643"/>
                <declaration name="invisibleGlyphCnt" type="int" line="656"/>
                <scope line="657">
                    <scope line="659"/>
                </scope>
                <scope line="663">
                    <declaration name="visibleGlyphCnt" type="int" line="664"/>
                    <declaration name="visibleGlyphCodes" type="int[]" line="665"/>
                    <declaration name="visiblePositions" type="float[]" line="666"/>
                    <declaration name="index" type="int" line="667"/>
                    <scope line="668">
                        <scope line="670"/>
                    </scope>
                </scope>
                <declaration name="advanceTransform" type="AffineTransform" line="697"/>
                <declaration name="glyphAdvPos" type="float[]" line="700"/>
                <declaration name="font2D" type="Font2D" line="706"/>
                <scope line="707">
                    <declaration name="family" type="String" line="708"/>
                    <declaration name="style" type="int" line="709"/>
                    <scope line="711"/>
                </scope>
                <scope line="716">
                    <declaration name="compFont" type="CompositeFont" line="724"/>
                    <declaration name="userx" type="float" line="725"/>
                    <declaration name="devx" type="float" line="726"/>
                    <declaration name="start" type="int" line="728"/>
                    <scope line="729">
                        <scope line="734"/>
                        <declaration name="slotFont" type="PhysicalFont" line="743"/>
                        <scope line="744"/>
                        <declaration name="family" type="String" line="747"/>
                        <declaration name="style" type="int" line="748"/>
                        <scope line="750"/>
                        <declaration name="glyphs" type="int[]" line="754"/>
                        <declaration name="posns" type="float[]" line="755"/>
                        <scope line="757">
                            <declaration name="p" type="Point2D.Float" line="758"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="767"/>
            </method>
            <method name="textOut" type="void" line="780">
                <params>
                    <param name="str" type="String"/>
                    <param name="font" type="Font"/>
                    <param name="font2D" type="PhysicalFont"/>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="deviceSize" type="float"/>
                    <param name="rotation" type="int"/>
                    <param name="awScale" type="float"/>
                    <param name="deviceTransform" type="AffineTransform"/>
                    <param name="scaleFactorX" type="double"/>
                    <param name="userx" type="float"/>
                    <param name="usery" type="float"/>
                    <param name="devx" type="float"/>
                    <param name="devy" type="float"/>
                    <param name="targetW" type="float"/>
                </params>
                <comment line="794">
                    If there is a 1:1 char-&gt;glyph mapping then char positions
                     are the same as glyph positions and we can tell GDI
                     where to place the glyphs.
                     On drawing we remove control chars so these need to be
                     removed now so the string and positions are the same length.
                     For other cases we need to pass glyph codes to GDI.                    
                </comment>
                <comment line="815">
                    GDI advances must not include device space rotation.
                     See earlier comment in printGlyphVector() for details.                    
                </comment>
                <comment line="823">
                    source                    
                </comment>
                <comment line="824">
                    destination                    
                </comment>
                <comment line="825">
                    num points                    
                </comment>
                <declaration name="family" type="String" line="782"/>
                <declaration name="style" type="int" line="783"/>
                <declaration name="wPrinterJob" type="WPrinterJob" line="784"/>
                <declaration name="setFont" type="boolean" line="785"/>
                <scope line="787"/>
                <declaration name="glyphPos" type="float[]" line="792"/>
                <scope line="793">
                    <declaration name="chars" type="char[]" line="802"/>
                    <declaration name="len" type="int" line="803"/>
                    <declaration name="gv" type="GlyphVector" line="804"/>
                    <scope line="805"/>
                    <scope line="808"/>
                    <declaration name="gvAdvPt" type="Point2D" line="813"/>
                    <declaration name="advanceTransform" type="AffineTransform" line="818"/>
                    <declaration name="glyphAdvPos" type="float[]" line="821"/>
                </scope>
            </method>
            <method name="okGDIMetrics" type="boolean" line="844">
                <params>
                    <param name="str" type="String"/>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="scaleX" type="double"/>
                </params>
                <declaration name="bds" type="Rectangle2D" line="846"/>
                <declaration name="jdkAdvance" type="double" line="847"/>
                <declaration name="gdiAdvance" type="int" line="849"/>
                <scope line="850">
                    <declaration name="diff" type="double" line="851"/>
                    <declaration name="ratio" type="double" line="852"/>
                    <scope line="853"/>
                </scope>
            </method>
            <javadoc line="861">
                The various &lt;code&gt;drawImage()&lt;/code&gt; methods for
                  &lt;code&gt;WPathGraphics&lt;/code&gt; are all decomposed
                  into an invocation of &lt;code&gt;drawImageToPlatform&lt;/code&gt;.
                  The portion of the passed in image defined by
                  &lt;code&gt;srcX, srcY, srcWidth, and srcHeight&lt;/code&gt;
                  is transformed by the supplied AffineTransform and
                  drawn using GDI to the printer context.                
                <param>
                    img     The image to be drawn.                    
                </param>
                <param>
                    xform   Used to tranform the image before drawing.
                      This can be null.                    
                </param>
                <param>
                    bgcolor This color is drawn where the image has transparent
                      pixels. If this parameter is null then the
                      pixels already in the destination should show
                      through.                    
                </param>
                <param>
                    srcX    With srcY this defines the upper-left corner
                      of the portion of the image to be drawn.                    
                </param>
                <param>
                    srcY    With srcX this defines the upper-left corner
                      of the portion of the image to be drawn.                    
                </param>
                <param>
                    srcWidth    The width of the portion of the image to
                      be drawn.                    
                </param>
                <param>
                    srcHeight   The height of the portion of the image to
                      be drawn.                    
                </param>
                <param>
                    handlingTransparency if being recursively called to
                      print opaque region of transparent image                    
                </param>
            </javadoc>
            <method name="drawImageToPlatform" type="boolean" line="893">
                <params>
                    <param name="image" type="Image"/>
                    <param name="xform" type="AffineTransform"/>
                    <param name="bgcolor" type="Color"/>
                    <param name="srcX" type="int"/>
                    <param name="srcY" type="int"/>
                    <param name="srcWidth" type="int"/>
                    <param name="srcHeight" type="int"/>
                    <param name="handlingTransparency" type="boolean"/>
                </params>
                <comment line="902">
                    The full transform to be applied to the image is the
                     caller&apos;s transform concatenated on to the transform
                     from user space to device space. If the caller didn&apos;t
                     supply a transform then we just act as if they passed
                     in the identify transform.                    
                </comment>
                <comment line="914">
                    Split the full transform into a pair of
                     transforms. The first transform holds effects
                     that GDI (under Win95) can not perform such
                     as rotation and shearing. The second transform
                     is setup to hold only the scaling effects.
                     These transforms are created such that a point,
                     p, in user space, when transformed by &apos;fullTransform&apos;
                     lands in the same place as when it is transformed
                     by &apos;rotTransform&apos; and then &apos;scaleTransform&apos;.
                    
                     The entire image transformation is not in Java in order
                     to minimize the amount of memory needed in the VM. By
                     dividing the transform in two, we rotate and shear
                     the source image in its own space and only go to
                     the, usually, larger, device space when we ask
                     GDI to perform the final scaling.
                     Clamp this to the device scale for better quality printing.                    
                </comment>
                <comment line="935">
                    Calculate the amount of scaling in the x
                     and y directions. This scaling is computed by
                     transforming a unit vector along each axis
                     and computing the resulting magnitude.
                     The computed values &apos;scaleX&apos; and &apos;scaleY&apos;
                     represent the amount of scaling GDI will be asked
                     to perform.                    
                </comment>
                <comment line="957">
                                        
                </comment>
                <comment line="967">
                    We do not need to draw anything if either scaling
                     factor is zero.                    
                </comment>
                <comment line="972">
                    Here&apos;s the transformation we will do with Java2D,                    
                </comment>
                <comment line="975">
                    m00                    
                </comment>
                <comment line="976">
                    m10                    
                </comment>
                <comment line="977">
                    m01                    
                </comment>
                <comment line="978">
                    m11                    
                </comment>
                <comment line="979">
                    m02                    
                </comment>
                <comment line="980">
                    m12                    
                </comment>
                <comment line="982">
                    The scale transform is not used directly: we instead
                     directly multiply by scaleX and scaleY.
                    
                     Conceptually here is what the scaleTransform is:
                    
                     AffineTransform scaleTransform = new AffineTransform(
                                          scaleX,                     m00
                                          0,                          m10
                                          0,                          m01
                                          scaleY,                     m11
                                          0,                          m02
                                          0);                         m12                    
                </comment>
                <comment line="996">
                    Convert the image source&apos;s rectangle into the rotated
                     and sheared space. Once there, we calculate a rectangle
                     that encloses the resulting shape. It is this rectangle
                     which defines the size of the BufferedImage we need to
                     create to hold the transformed image.                    
                </comment>
                <comment line="1009">
                    add a fudge factor as some fp precision problems have
                     been observed which caused pixels to be rounded down and
                     out of the image.                    
                </comment>
                <comment line="1022">
                    If the image has transparent or semi-transparent
                     pixels then we&apos;ll have the application re-render
                     the portion of the page covered by the image.
                     The BufferedImage will be at the image&apos;s resolution
                     to avoid wasting memory. By re-rendering this portion
                     of a page all compositing is done by Java2D into
                     the BufferedImage and then that image is copied to
                     GDI.
                     However several special cases can be handled otherwise:
                     - bitmask transparency with a solid background colour
                     - images which have transparency color models but no
                     transparent pixels
                     - images with bitmask transparency and an IndexColorModel
                     (the common transparent GIF case) can be handled by
                     rendering just the opaque pixels.                    
                </comment>
                <comment line="1046">
                    image drawn, just return.                    
                </comment>
                <comment line="1058">
                    if there&apos;s no transparent pixels there&apos;s no need                    
                </comment>
                <comment line="1059">
                    for a background colour. This can avoid edge artifacts                    
                </comment>
                <comment line="1060">
                    in rotation cases.                    
                </comment>
                <comment line="1063">
                    if src region extends beyond the image, the &quot;opaque&quot; path                    
                </comment>
                <comment line="1064">
                    may blit b/g colour (including white) where it shoudn&apos;t.                    
                </comment>
                <comment line="1075">
                    m00                    
                </comment>
                <comment line="1076">
                    m10                    
                </comment>
                <comment line="1077">
                    m01                    
                </comment>
                <comment line="1078">
                    m11                    
                </comment>
                <comment line="1079">
                    m02                    
                </comment>
                <comment line="1080">
                    m12                    
                </comment>
                <comment line="1086">
                    Region isn&apos;t user space because its potentially                    
                </comment>
                <comment line="1087">
                    been rotated for landscape.                    
                </comment>
                <comment line="1094">
                    Try to limit the amount of memory used to 8Mb, so                    
                </comment>
                <comment line="1095">
                    if at device resolution this exceeds a certain                    
                </comment>
                <comment line="1096">
                    image size then scale down the region to fit in                    
                </comment>
                <comment line="1097">
                    that memory, but never to less than 72 dpi.                    
                </comment>
                <comment line="1127">
                    We need to have the clip as part of the saved state,
                     either directly, or all the components that are
                     needed to reconstitute it (image source area,
                     image transform and current graphics transform).
                     The clip is described in user space, so we need to
                     save the current graphics transform anyway so just
                     save these two.                    
                </comment>
                <comment line="1139">
                    The image can be rendered directly by GDI so we
                     copy it into a BufferedImage (this takes care of
                     ColorSpace and BufferedImageOp issues) and then
                     send that to GDI.                    
                </comment>
                <comment line="1145">
                    Create a buffered image big enough to hold the portion
                     of the source image being printed.
                     The image format will be 3BYTE_BGR for most cases
                     except where we can represent the image as a 1, 4 or 8
                     bits-per-pixel DIB.                    
                </comment>
                <comment line="1162">
                    BYTE_BINARY may be 2 bpp which DIB can&apos;t handle.
                     Convert this to 4bpp.                    
                </comment>
                <comment line="1184">
                    If there is no special transform needed (this is a
                     simple BLIT) and dibType == img.getType() and we
                     didn&apos;t create a new IndexColorModel AND the whole of
                     the source image is being drawn (GDI can&apos;t handle a
                     portion of the original source image) then we
                     don&apos;t need to create this intermediate image - GDI
                     can access the data from the original image.
                     Since a subimage can be created by calling
                     BufferedImage.getSubImage() that condition needs to
                     be accounted for too. This implies inspecting the
                     data buffer. In the end too many cases are not able
                     to take advantage of this option until we can teach
                     the native code to properly navigate the data buffer.
                     There was a concern that since in native code since we
                     need to DWORD align and flip to a bottom up DIB that
                     the &quot;original&quot; image may get perturbed by this.
                     But in fact we always malloc new memory for the aligned
                     copy so this isn&apos;t a problem.
                     This points out that we allocate two temporaries copies
                     of the image : one in Java and one in native. If
                     we can be smarter about not allocating this one when
                     not needed, that would seem like a good thing to do,
                     even if in many cases the ColorModels don&apos;t match and
                     its needed.
                     Until all of this is resolved newImage is always true.                    
                </comment>
                <comment line="1218">
                    Setup a Graphics2D on to the BufferedImage so that
                     the source image when copied, lands within the
                     image buffer.                    
                </comment>
                <comment line="1231">
                    Fill the BufferedImage either with the caller
                     supplied color, &apos;bgColor&apos; or, if null, with white.                    
                </comment>
                <comment line="1251">
                    Scale the bounding rectangle by the scale transform.
                     Because the scaling transform has only x and y
                     scaling components it is equivalent to multiply
                     the x components of the bounding rectangle by
                     the x scaling factor and to multiply the y components
                     by the y scaling factor.                    
                </comment>
                <comment line="1265">
                    Pull the raster data from the buffered image
                     and pass it along to GDI.                    
                </comment>
                <comment line="1297">
                    Because the caller&apos;s image has been rotated
                     and sheared into our BufferedImage and because
                     we will be handing that BufferedImage directly to
                     GDI, we need to set an additional clip. This clip
                     makes sure that only parts of the BufferedImage
                     that are also part of the caller&apos;s image are drawn.                    
                </comment>
                <declaration name="img" type="BufferedImage" line="895"/>
                <scope line="896"/>
                <declaration name="wPrinterJob" type="WPrinterJob" line="900"/>
                <declaration name="fullTransform" type="AffineTransform" line="908"/>
                <scope line="909"/>
                <declaration name="fullMatrix" type="double[]" line="932"/>
                <declaration name="unitVectorX" type="Point2D.Float" line="943"/>
                <declaration name="unitVectorY" type="Point2D.Float" line="944"/>
                <declaration name="origin" type="Point2D.Float" line="948"/>
                <declaration name="scaleX" type="double" line="949"/>
                <declaration name="scaleY" type="double" line="950"/>
                <declaration name="devResX" type="double" line="952"/>
                <declaration name="devResY" type="double" line="953"/>
                <declaration name="devScaleX" type="double" line="954"/>
                <declaration name="devScaleY" type="double" line="955"/>
                <declaration name="transformType" type="int" line="958"/>
                <declaration name="clampScale" type="boolean" line="959"/>
                <scope line="962"/>
                <scope line="970">
                    <declaration name="rotTransform" type="AffineTransform" line="974"/>
                    <declaration name="srcRect" type="Rectangle2D.Float" line="1002"/>
                    <declaration name="rotShape" type="Shape" line="1006"/>
                    <declaration name="rotBounds" type="Rectangle2D" line="1007"/>
                    <declaration name="boundsWidth" type="int" line="1017"/>
                    <declaration name="boundsHeight" type="int" line="1018"/>
                    <scope line="1020">
                        <declaration name="drawOpaque" type="boolean" line="1038"/>
                        <scope line="1039">
                            <scope line="1041">
                                <scope line="1042">
                                    <scope line="1045"/>
                                </scope>
                                <scope line="1050"/>
                            </scope>
                            <scope line="1054"/>
                        </scope>
                        <scope line="1057"/>
                        <scope line="1067"/>
                        <scope line="1070">
                            <declaration name="tx" type="AffineTransform" line="1073"/>
                            <declaration name="rect" type="Rectangle2D.Float" line="1082"/>
                            <declaration name="shape" type="Shape" line="1085"/>
                            <declaration name="region" type="Rectangle2D" line="1088"/>
                            <declaration name="w" type="int" line="1099"/>
                            <declaration name="h" type="int" line="1100"/>
                            <declaration name="nbytes" type="int" line="1101"/>
                            <declaration name="maxBytes" type="int" line="1102"/>
                            <declaration name="origDpi" type="double" line="1103"/>
                            <declaration name="dpi" type="int" line="1104"/>
                            <declaration name="scaleFactor" type="double" line="1105"/>
                            <declaration name="maxSFX" type="double" line="1107"/>
                            <declaration name="maxSFY" type="double" line="1108"/>
                            <declaration name="maxSF" type="double" line="1109"/>
                            <declaration name="minDpi" type="int" line="1110"/>
                            <scope line="1113"/>
                            <scope line="1118"/>
                        </scope>
                        <scope line="1144">
                            <declaration name="dibType" type="int" line="1151"/>
                            <declaration name="icm" type="IndexColorModel" line="1152"/>
                            <declaration name="cm" type="ColorModel" line="1154"/>
                            <declaration name="imgType" type="int" line="1155"/>
                            <scope line="1159">
                                <scope line="1166">
                                    <declaration name="rgbs" type="int[]" line="1168"/>
                                    <declaration name="transparent" type="boolean" line="1170"/>
                                    <declaration name="transpixel" type="int" line="1172"/>
                                </scope>
                            </scope>
                            <declaration name="iw" type="int" line="1181"/>
                            <declaration name="ih" type="int" line="1182"/>
                            <declaration name="deepImage" type="BufferedImage" line="1183"/>
                            <declaration name="newImage" type="boolean" line="1210"/>
                            <scope line="1211">
                                <scope line="1212"/>
                                <scope line="1214"/>
                                <declaration name="imageGraphics" type="Graphics2D" line="1222"/>
                                <scope line="1234"/>
                            </scope>
                            <scope line="1247"/>
                            <declaration name="scaledBounds" type="Rectangle2D.Float" line="1258"/>
                            <declaration name="raster" type="WritableRaster" line="1268"/>
                            <declaration name="data" type="byte[]" line="1269"/>
                            <scope line="1270"/>
                            <scope line="1272"/>
                            <scope line="1274"/>
                            <declaration name="bitsPerPixel" type="int" line="1278"/>
                            <declaration name="sm" type="SampleModel" line="1279"/>
                            <scope line="1280">
                                <declaration name="csm" type="ComponentSampleModel" line="1281"/>
                            </scope>
                            <scope line="1283">
                                <declaration name="mppsm" type="MultiPixelPackedSampleModel" line="1284"/>
                            </scope>
                            <scope line="1287">
                                <scope line="1288">
                                    <declaration name="diw" type="int" line="1289"/>
                                    <declaration name="dih" type="int" line="1290"/>
                                    <scope line="1291"/>
                                </scope>
                            </scope>
                            <declaration name="holdClip" type="Shape" line="1304"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1324">
                Have the printing application redraw everything that falls
                  within the page bounds defined by &lt;code&gt;region&lt;/code&gt;.                
            </javadoc>
            <method name="redrawRegion" type="void" line="1330">
                <params>
                    <param name="region" type="Rectangle2D"/>
                    <param name="scaleX" type="double"/>
                    <param name="scaleY" type="double"/>
                    <param name="savedClip" type="Shape"/>
                    <param name="savedTransform" type="AffineTransform"/>
                </params>
                <comment line="1337">
                    Create a buffered image big enough to hold the portion
                     of the source image being printed.                    
                </comment>
                <comment line="1345">
                    Get a graphics for the application to render into.
                     We initialize the buffer to white in order to
                     match the paper and then we shift the BufferedImage
                     so that it covers the area on the page where the
                     caller&apos;s Image will be drawn.                    
                </comment>
                <comment line="1359">
                    Calculate the resolution of the source image.                    
                </comment>
                <comment line="1364">
                    The application expects to see user space at 72 dpi.
                     so change user space from image source resolution to
                      72 dpi.                    
                </comment>
                <comment line="1376">
                                        
                </comment>
                <comment line="1384">
                    We need to set the device clip using saved information.
                     savedClip intersects the user clip with a clip that restricts
                     the GDI rendered area of our BufferedImage to that which
                     may correspond to a rotate or shear.
                     The saved device transform is needed as the current transform
                     is not likely to be the same.                    
                </comment>
                <comment line="1393">
                    Scale the bounding rectangle by the scale transform.
                     Because the scaling transform has only x and y
                     scaling components it is equivalent to multiplying
                     the x components of the bounding rectangle by
                     the x scaling factor and to multiplying the y components
                     by the y scaling factor.                    
                </comment>
                <comment line="1407">
                    Pull the raster data from the buffered image
                     and pass it along to GDI.                    
                </comment>
                <declaration name="wPrinterJob" type="WPrinterJob" line="1332"/>
                <declaration name="painter" type="Printable" line="1333"/>
                <declaration name="pageFormat" type="PageFormat" line="1334"/>
                <declaration name="pageIndex" type="int" line="1335"/>
                <declaration name="deepImage" type="BufferedImage" line="1340"/>
                <declaration name="g" type="Graphics2D" line="1351"/>
                <declaration name="proxy" type="ProxyGraphics2D" line="1352"/>
                <declaration name="sourceResX" type="float" line="1361"/>
                <declaration name="sourceResY" type="float" line="1362"/>
                <declaration name="scaledBounds" type="Rectangle2D.Float" line="1400"/>
                <declaration name="tile" type="ByteComponentRaster" line="1410"/>
            </method>
            <method name="deviceFill" type="void" line="1427">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                    <param name="color" type="Color"/>
                </params>
                <declaration name="wPrinterJob" type="WPrinterJob" line="1429"/>
            </method>
            <method name="deviceClip" type="void" line="1441">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                </params>
                <declaration name="wPrinterJob" type="WPrinterJob" line="1443"/>
            </method>
            <javadoc line="1449">
                Draw the bounding rectangle using transformed coordinates.                
            </javadoc>
            <method name="deviceFrameRect" type="void" line="1453">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="color" type="Color"/>
                </params>
                <comment line="1457">
                                        
                </comment>
                <comment line="1477">
                    check for default style and try to optimize it by
                     calling the frameRect native function instead of using paths.                    
                </comment>
                <comment line="1492">
                                        
                </comment>
                <comment line="1496">
                                        
                </comment>
                <comment line="1506">
                                        
                </comment>
                <comment line="1512">
                                        
                </comment>
                <comment line="1519">
                                        
                </comment>
                <declaration name="deviceTransform" type="AffineTransform" line="1455"/>
                <declaration name="transformType" type="int" line="1458"/>
                <declaration name="usePath" type="boolean" line="1459"/>
                <scope line="1463"/>
                <declaration name="stroke" type="Stroke" line="1468"/>
                <scope line="1470">
                    <declaration name="lineStroke" type="BasicStroke" line="1471"/>
                    <declaration name="endCap" type="int" line="1473"/>
                    <declaration name="lineJoin" type="int" line="1474"/>
                    <scope line="1482">
                        <declaration name="lineWidth" type="float" line="1484"/>
                        <declaration name="penSize" type="Point2D.Float" line="1485"/>
                        <declaration name="deviceLineWidth" type="float" line="1489"/>
                        <declaration name="ul_pos" type="Point2D.Float" line="1493"/>
                        <declaration name="lr_pos" type="Point2D.Float" line="1497"/>
                        <declaration name="w" type="float" line="1501"/>
                        <declaration name="h" type="float" line="1502"/>
                        <declaration name="wPrinterJob" type="WPrinterJob" line="1504"/>
                        <scope line="1508"/>
                        <scope line="1513">
                            <declaration name="lowerRes" type="double" line="1515"/>
                            <scope line="1518"/>
                            <scope line="1524"/>
                        </scope>
                    </scope>
                    <scope line="1529"/>
                </scope>
            </method>
            <method name="deviceFillRect" type="void" line="1542">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="color" type="Color"/>
                </params>
                <comment line="1543">
                    Transform to device coordinates                    
                </comment>
                <comment line="1548">
                                        
                </comment>
                <declaration name="deviceTransform" type="AffineTransform" line="1546"/>
                <declaration name="transformType" type="int" line="1549"/>
                <declaration name="usePath" type="boolean" line="1550"/>
                <scope line="1553"/>
                <declaration name="tlc_pos" type="Point2D.Float" line="1558"/>
                <declaration name="brc_pos" type="Point2D.Float" line="1561"/>
                <declaration name="deviceWidth" type="float" line="1564"/>
                <declaration name="deviceHeight" type="float" line="1565"/>
                <declaration name="wPrinterJob" type="WPrinterJob" line="1567"/>
            </method>
            <javadoc line="1573">
                Draw a line using a pen created using the specified color
                  and current stroke properties.                
            </javadoc>
            <method name="deviceDrawLine" type="void" line="1578">
                <params>
                    <param name="xBegin" type="int"/>
                    <param name="yBegin" type="int"/>
                    <param name="xEnd" type="int"/>
                    <param name="yEnd" type="int"/>
                    <param name="color" type="Color"/>
                </params>
                <comment line="1607">
                                        
                </comment>
                <comment line="1611">
                    endCap other than Round will not print!
                     due to Windows GDI limitation, force it to CAP_ROUND                    
                </comment>
                <comment line="1620">
                                        
                </comment>
                <comment line="1628">
                                        
                </comment>
                <comment line="1631">
                    let&apos;s see if we can use a a default pen
                      if it&apos;s round end (Windows&apos; default style)
                      or it&apos;s verticalhorizontal
                      or stroke is too thin.                    
                </comment>
                <declaration name="stroke" type="Stroke" line="1579"/>
                <scope line="1581">
                    <declaration name="lineStroke" type="BasicStroke" line="1582"/>
                    <scope line="1584"/>
                    <declaration name="lineWidth" type="float" line="1589"/>
                    <declaration name="penSize" type="Point2D.Float" line="1590"/>
                    <declaration name="deviceTransform" type="AffineTransform" line="1592"/>
                    <declaration name="deviceLineWidth" type="float" line="1595"/>
                    <declaration name="begin_pos" type="Point2D.Float" line="1598"/>
                    <declaration name="end_pos" type="Point2D.Float" line="1601"/>
                    <declaration name="endCap" type="int" line="1604"/>
                    <declaration name="lineJoin" type="int" line="1605"/>
                    <scope line="1609"/>
                    <declaration name="wPrinterJob" type="WPrinterJob" line="1618"/>
                    <scope line="1622"/>
                    <scope line="1629">
                        <declaration name="lowerRes" type="double" line="1636"/>
                        <scope line="1641"/>
                        <scope line="1649"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1657">
                Given a Java2D &lt;code&gt;PathIterator&lt;/code&gt; instance,
                  this method translates that into a Window&apos;s path
                  in the printer device context.                
            </javadoc>
            <method name="convertToWPath" type="void" line="1662">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                </params>
                <comment line="1669">
                    Map the PathIterator&apos;s fill rule into the Window&apos;s
                     polygon fill rule.                    
                </comment>
                <comment line="1694">
                    Convert the quad path to a bezier.                    
                </comment>
                <declaration name="segment" type="float[]" line="1664"/>
                <declaration name="segmentType" type="int" line="1665"/>
                <declaration name="wPrinterJob" type="WPrinterJob" line="1667"/>
                <declaration name="polyFillRule" type="int" line="1672"/>
                <scope line="1673"/>
                <scope line="1675"/>
                <scope line="1682">
                    <declaration name="lastX" type="int" line="1697"/>
                    <declaration name="lastY" type="int" line="1698"/>
                    <declaration name="c1x" type="float" line="1699"/>
                    <declaration name="c1y" type="float" line="1700"/>
                    <declaration name="c2x" type="float" line="1701"/>
                    <declaration name="c2y" type="float" line="1702"/>
                </scope>
            </method>
        </class>
    </source>