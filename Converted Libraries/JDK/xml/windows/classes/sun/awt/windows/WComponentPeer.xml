<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.windows">
        <import package="java.awt"/>
        <import package="java.awt.peer"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="sun.awt.RepaintArea"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.awt.image.ToolkitImage"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ImageProducer"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.event.PaintEvent"/>
        <import package="java.awt.event.InvocationEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.event.FocusEvent"/>
        <import package="java.awt.event.MouseEvent"/>
        <import package="java.awt.event.MouseWheelEvent"/>
        <import package="java.awt.event.InputEvent"/>
        <import package="sun.awt.Win32GraphicsConfig"/>
        <import package="sun.awt.Win32GraphicsEnvironment"/>
        <import package="sun.java2d.InvalidPipeException"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.ScreenUpdateManager"/>
        <import package="sun.java2d.d3d.D3DSurfaceData"/>
        <import package="sun.java2d.opengl.OGLSurfaceData"/>
        <import package="sun.java2d.pipe.Region"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.awt.PaintEventDispatcher"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.event.IgnorePaintEvent"/>
        <import package="java.awt.dnd.DropTarget"/>
        <import package="java.awt.dnd.peer.DropTargetPeer"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="WComponentPeer" line="64">
            <extends class="WObjectPeer"/>
            <comment line="77">
                ComponentPeer implementation                
            </comment>
            <comment line="92">
                foreground, background and color are cached to avoid calling back                
            </comment>
            <comment line="93">
                into the Component.                
            </comment>
            <comment line="101">
                DropTarget support                
            </comment>
            <comment line="104">
                native pointer                
            </comment>
            <comment line="115">
                                
            </comment>
            <comment line="118">
                                
            </comment>
            <comment line="134">
                                
            </comment>
            <comment line="147">
                                
            </comment>
            <comment line="174">
                Called from native code (on Toolkit thread) in order to
                 dynamically layout the Container during resizing                
            </comment>
            <comment line="216">
                Paints any portion of the component that needs updating
                 before the call returns (similar to the Win32 API UpdateWindow)                
            </comment>
            <comment line="302">
                returns true if the event has been handled and shouldn&apos;t be propagated                
            </comment>
            <comment line="303">
                though handleEvent method chain - e.g. WTextFieldPeer returns true                
            </comment>
            <comment line="304">
                on handling &apos;\n&apos; to prevent it from being passed to native code                
            </comment>
            <comment line="377">
                Do nothing for heavyweight implementation                
            </comment>
            <comment line="388">
                Return the GraphicsConfiguration associated with this peer, either
                 the locally stored winGraphicsConfig, or that of the target Component.                
            </comment>
            <comment line="512">
                This will return null for Components not yet added to a Container                
            </comment>
            <comment line="523">
                This will return null for Components not yet added to a Container                
            </comment>
            <comment line="535">
                Returns null for Components not yet added to a Container                
            </comment>
            <comment line="550">
                fallback default font object                
            </comment>
            <comment line="651">
                TODO: consider moving it to KeyboardFocusManagerPeerImpl                
            </comment>
            <comment line="732">
                Object overrides                
            </comment>
            <comment line="738">
                Toolkit &amp; peer internals                
            </comment>
            <comment line="794">
                Callbacks for window-system events to the frame                
            </comment>
            <comment line="796">
                Invoke a update() method call on the target                
            </comment>
            <comment line="801">
                Invoke a paint() method call on the target, after clearing the                
            </comment>
            <comment line="802">
                damaged area.                
            </comment>
            <comment line="811">
                Invoke a paint() method call on the target, without clearing the
                 damaged area.  This is normally called by a native control after
                 it has painted itself.
                
                 NOTE: This is called on the privileged toolkit thread. Do not
                       call directly into user code using this thread!                
            </comment>
            <comment line="832">
                Post an event. Queue it for execution by the callback thread.                
            </comment>
            <comment line="842">
                Routines to support deferred window positioning.                
            </comment>
            <comment line="917">
                Returns true if we are inside begin/endLayout and                
            </comment>
            <comment line="918">
                are waiting for native painting                
            </comment>
            <comment line="978">
                override and return false on components that DO NOT require                
            </comment>
            <comment line="1050">
                REMIND: Temp workaround for issues with using HW acceleration                
            </comment>
            <comment line="1051">
                in the browser on Vista when DWM is enabled.                
            </comment>
            <comment line="1052">
                @return true if the toplevel container is not an EmbeddedFrame or                
            </comment>
            <comment line="1053">
                if this EmbeddedFrame is acceleration capable, false otherwise                
            </comment>
            <implements interface="ComponentPeer"/>
            <implements interface="DropTargetPeer"/>
            <declaration name="hwnd" type="long" line="67"/>
            <javadoc line="67">
                Handle to native window                
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="72"/>
            <declaration name="shapeLog" type="PlatformLogger" line="73"/>
            <declaration name="focusLog" type="PlatformLogger" line="74"/>
            <declaration name="surfaceData" type="SurfaceData" line="77"/>
            <declaration name="paintArea" type="RepaintArea" line="79"/>
            <declaration name="winGraphicsConfig" type="Win32GraphicsConfig" line="81"/>
            <declaration name="isLayouting" type="boolean" line="83"/>
            <declaration name="paintPending" type="boolean" line="84"/>
            <declaration name="oldWidth" type="int" line="85"/>
            <declaration name="oldHeight" type="int" line="86"/>
            <declaration name="numBackBuffers" type="int" line="87"/>
            <declaration name="backBuffer" type="VolatileImage" line="88"/>
            <declaration name="backBufferCaps" type="BufferCapabilities" line="89"/>
            <declaration name="foreground" type="Color" line="93"/>
            <declaration name="background" type="Color" line="94"/>
            <declaration name="font" type="Font" line="95"/>
            <method name="isObscured" type="boolean" line="97"/>
            <method name="canDetermineObscurity" type="boolean" line="98"/>
            <declaration name="nDropTargets" type="int" line="102"/>
            <declaration name="nativeDropTargetContext" type="long" line="103"/>
            <method name="pShow" type="void" line="105"/>
            <method name="hide" type="void" line="106"/>
            <method name="enable" type="void" line="107"/>
            <method name="disable" type="void" line="108"/>
            <method name="getHWnd" type="long" line="110"/>
            <method name="getLocationOnScreen" type="Point" line="115"/>
            <method name="setVisible" type="void" line="118">
                <params>
                    <param name="b" type="boolean"/>
                </params>
                <scope line="119"/>
                <scope line="121"/>
            </method>
            <method name="show" type="void" line="126">
                <declaration name="s" type="Dimension" line="127"/>
            </method>
            <method name="setEnabled" type="void" line="134">
                <params>
                    <param name="b" type="boolean"/>
                </params>
                <scope line="135"/>
                <scope line="137"/>
            </method>
            <declaration name="serialNum" type="int" line="142"/>
            <method name="reshapeNoCheck" type="void" line="144"/>
            <method name="setBounds" type="void" line="147">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="op" type="int"/>
                </params>
                <comment line="148">
                    Should set paintPending before reahape to prevent                    
                </comment>
                <comment line="149">
                    thread race between paint events                    
                </comment>
                <comment line="150">
                    Native components do redraw after resize                    
                </comment>
                <comment line="159">
                    Only recreate surfaceData if this setBounds is called                    
                </comment>
                <comment line="160">
                    for a resize; a simple move should not trigger a recreation                    
                </comment>
                <comment line="164">
                    REMIND : what do we do if our surface creation failed?                    
                </comment>
                <scope line="153"/>
                <scope line="155"/>
                <scope line="158">
                    <scope line="161"/>
                    <scope line="163"/>
                </scope>
            </method>
            <method name="dynamicallyLayoutContainer" type="void" line="177">
                <comment line="178">
                    If we got the WM_SIZING, this must be a Container, right?                    
                </comment>
                <comment line="179">
                    In fact, it must be the top-level Container.                    
                </comment>
                <comment line="190">
                    Discarding old paint events doesn&apos;t seem to be necessary.                    
                </comment>
                <comment line="197">
                    When OGL or D3D is enabled, it is necessary to                    
                </comment>
                <comment line="198">
                    replace the SurfaceData for each dynamic layout                    
                </comment>
                <comment line="199">
                    request so that the viewport stays in sync                    
                </comment>
                <comment line="200">
                    with the window bounds.                    
                </comment>
                <comment line="204">
                    REMIND: this is unlikely to occur for OGL, but                    
                </comment>
                <comment line="205">
                    what do we do if surface creation fails?                    
                </comment>
                <comment line="209">
                    Forcing a paint here doesn&apos;t seem to be necessary.                    
                </comment>
                <comment line="210">
                    paintDamagedAreaImmediately();                    
                </comment>
                <scope line="180">
                    <declaration name="parent" type="Container" line="181"/>
                    <scope line="182"/>
                </scope>
                <declaration name="cont" type="Container" line="186"/>
                <anonymous_class line="188">
                    <method name="run" type="void" line="189">
                        <comment line="190">
                            Discarding old paint events doesn&apos;t seem to be necessary.                            
                        </comment>
                        <comment line="197">
                            When OGL or D3D is enabled, it is necessary to                            
                        </comment>
                        <comment line="198">
                            replace the SurfaceData for each dynamic layout                            
                        </comment>
                        <comment line="199">
                            request so that the viewport stays in sync                            
                        </comment>
                        <comment line="200">
                            with the window bounds.                            
                        </comment>
                        <comment line="204">
                            REMIND: this is unlikely to occur for OGL, but                            
                        </comment>
                        <comment line="205">
                            what do we do if surface creation fails?                            
                        </comment>
                        <comment line="209">
                            Forcing a paint here doesn&apos;t seem to be necessary.                            
                        </comment>
                        <comment line="210">
                            paintDamagedAreaImmediately();                            
                        </comment>
                        <scope line="196">
                            <scope line="201"/>
                            <scope line="203"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <method name="paintDamagedAreaImmediately" type="void" line="219">
                <comment line="220">
                    force Windows to send any pending WM_PAINT events so                    
                </comment>
                <comment line="221">
                    the damage area is updated on the Java side                    
                </comment>
                <comment line="223">
                    make sure paint events are transferred to main event queue                    
                </comment>
                <comment line="224">
                    for coalescing                    
                </comment>
                <comment line="226">
                    paint the damaged area                    
                </comment>
            </method>
            <method name="updateWindow" type="void" line="230"/>
            <method name="paint" type="void" line="232">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <method name="repaint" type="void" line="236">
                <params>
                    <param name="tm" type="long"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <declaration name="BANDING_DIVISOR" type="double" line="239"/>
            <method name="createPrintedPixels" type="int[]" line="240"/>
            <method name="print" type="void" line="243">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="247">
                    To conserve memory usage, we will band the image.                    
                </comment>
                <declaration name="comp" type="Component" line="245"/>
                <declaration name="totalW" type="int" line="249"/>
                <declaration name="totalH" type="int" line="250"/>
                <declaration name="hInc" type="int" line="252"/>
                <scope line="253"/>
                <scope line="257">
                    <declaration name="endY" type="int" line="258"/>
                    <scope line="259"/>
                    <declaration name="h" type="int" line="262"/>
                    <declaration name="bgColor" type="Color" line="264"/>
                    <declaration name="pix" type="int[]" line="265"/>
                    <scope line="267">
                        <declaration name="bim" type="BufferedImage" line="268"/>
                    </scope>
                </scope>
            </method>
            <method name="coalescePaintEvent" type="void" line="279">
                <params>
                    <param name="e" type="PaintEvent"/>
                </params>
                <declaration name="r" type="Rectangle" line="280"/>
                <scope line="281"/>
                <scope line="285"/>
            </method>
            <method name="reshape" type="void" line="299"/>
            <method name="handleJavaKeyEvent" type="boolean" line="304">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <method name="handleJavaMouseEvent" type="void" line="306">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="309">
                    Note that Swing requests focus in its own mouse event handler.                    
                </comment>
                <scope line="313"/>
            </method>
            <method name="nativeHandleEvent" type="void" line="321"/>
            <method name="handleEvent" type="void" line="323">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="340">
                    Got native painting                    
                </comment>
                <comment line="342">
                    Fallthrough to next statement                    
                </comment>
                <comment line="344">
                    Skip all painting while layouting and all UPDATEs                    
                </comment>
                <comment line="345">
                    while waiting for native paint                    
                </comment>
                <comment line="357">
                    Call the native code                    
                </comment>
                <declaration name="id" type="int" line="324"/>
                <scope line="328">
                    <scope line="329"/>
                    <scope line="331">
                        <scope line="332"/>
                    </scope>
                </scope>
                <scope line="346"/>
            </method>
            <method name="handleJavaFocusEvent" type="void" line="361">
                <params>
                    <param name="fe" type="FocusEvent"/>
                </params>
            </method>
            <method name="setFocus" type="void" line="366"/>
            <method name="getMinimumSize" type="Dimension" line="368"/>
            <method name="getPreferredSize" type="Dimension" line="372"/>
            <method name="layout" type="void" line="377"/>
            <method name="getBounds" type="Rectangle" line="379"/>
            <method name="isFocusable" type="boolean" line="383"/>
            <method name="getGraphicsConfiguration" type="GraphicsConfiguration" line="391">
                <comment line="396">
                    we don&apos;t need a treelock here, since                    
                </comment>
                <comment line="397">
                    Component.getGraphicsConfiguration() gets it itself.                    
                </comment>
                <scope line="392"/>
                <scope line="395"/>
            </method>
            <method name="getSurfaceData" type="SurfaceData" line="402"/>
            <javadoc line="406">
                Creates new surfaceData object and invalidates the previous
                  surfaceData object.
                  Replacing the surface data should never lock on any resources which are
                  required by other threads which may have them and may require
                  the tree-lock.
                  This is a degenerate version of replaceSurfaceData(numBackBuffers), so
                  just call that version with our current numBackBuffers.                
            </javadoc>
            <method name="replaceSurfaceData" type="void" line="415"/>
            <method name="createScreenSurface" type="void" line="420">
                <params>
                    <param name="isResize" type="boolean"/>
                </params>
                <declaration name="gc" type="Win32GraphicsConfig" line="421"/>
                <declaration name="mgr" type="ScreenUpdateManager" line="422"/>
            </method>
            <javadoc line="428">
                Multi-buffer version of replaceSurfaceData.  This version is called
                  by createBuffers(), which needs to acquire the same locks in the same
                  order, but also needs to perform additional functions inside the
                  locks.                
            </javadoc>
            <method name="replaceSurfaceData" type="void" line="436">
                <params>
                    <param name="newNumBackBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
                <comment line="455">
                    set the caps first, they&apos;re used when creating the bb                    
                </comment>
                <comment line="466">
                    it would be better to do this before we create new ones,                    
                </comment>
                <comment line="467">
                    but then we&apos;d run into deadlock issues                    
                </comment>
                <comment line="470">
                    null out the old data to make it collected faster                    
                </comment>
                <comment line="475">
                    null out the old data to make it collected faster                    
                </comment>
                <declaration name="oldData" type="SurfaceData" line="437"/>
                <declaration name="oldBB" type="VolatileImage" line="438"/>
                <scope line="439">
                    <scope line="440">
                        <scope line="441"/>
                        <declaration name="mgr" type="ScreenUpdateManager" line="445"/>
                        <scope line="449"/>
                        <scope line="454">
                            <declaration name="gc" type="Win32GraphicsConfig" line="457"/>
                        </scope>
                        <scope line="460"/>
                    </scope>
                </scope>
                <scope line="468"/>
                <scope line="473"/>
            </method>
            <method name="replaceSurfaceDataLater" type="void" line="480">
                <comment line="483">
                    Shouldn&apos;t do anything if object is disposed in meanwhile                    
                </comment>
                <comment line="484">
                    No need for sync as disposeAction in Window is performed                    
                </comment>
                <comment line="485">
                    on EDT                    
                </comment>
                <comment line="490">
                    REMIND : what do we do if our surface creation failed?                    
                </comment>
                <comment line="495">
                    Fix 6255371.                    
                </comment>
                <anonymous_class line="481">
                    <method name="run" type="void" line="482">
                        <comment line="483">
                            Shouldn&apos;t do anything if object is disposed in meanwhile                            
                        </comment>
                        <comment line="484">
                            No need for sync as disposeAction in Window is performed                            
                        </comment>
                        <comment line="485">
                            on EDT                            
                        </comment>
                        <comment line="490">
                            REMIND : what do we do if our surface creation failed?                            
                        </comment>
                        <scope line="486">
                            <scope line="487"/>
                            <scope line="489"/>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="r" type="Runnable" line="481"/>
                <scope line="496"/>
            </method>
            <method name="updateGraphicsData" type="boolean" line="501">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <comment line="506">
                    REMIND : what do we do if our surface creation failed?                    
                </comment>
                <scope line="503"/>
                <scope line="505"/>
            </method>
            <method name="getColorModel" type="ColorModel" line="512">
                <declaration name="gc" type="GraphicsConfiguration" line="513"/>
                <scope line="514"/>
                <scope line="517"/>
            </method>
            <method name="getDeviceColorModel" type="ColorModel" line="523">
                <declaration name="gc" type="Win32GraphicsConfig" line="524"/>
                <scope line="526"/>
                <scope line="529"/>
            </method>
            <method name="getColorModel" type="ColorModel" line="535">
                <params>
                    <param name="transparency" type="int"/>
                </params>
                <comment line="536">
                    return WToolkit.config.getColorModel(transparency);                    
                </comment>
                <declaration name="gc" type="GraphicsConfiguration" line="537"/>
                <scope line="538"/>
                <scope line="541"/>
            </method>
            <method name="getToolkit" type="java.awt.Toolkit" line="545"/>
            <declaration name="defaultFont" type="Font" line="550"/>
            <method name="getGraphics" type="Graphics" line="552">
                <comment line="562">
                    getTranslucentGraphics() returns non-null value for non-opaque windows only                    
                </comment>
                <comment line="564">
                    Non-opaque windows do not support heavyweight children.                    
                </comment>
                <comment line="565">
                    Redirect all painting to the Window&apos;s Graphics instead.                    
                </comment>
                <comment line="566">
                    The caller is responsible for calling the                    
                </comment>
                <comment line="567">
                    WindowPeer.updateWindow() after painting has finished.                    
                </comment>
                <comment line="583">
                                        
                </comment>
                <scope line="553"/>
                <declaration name="target" type="Component" line="557"/>
                <declaration name="window" type="Window" line="558"/>
                <scope line="559">
                    <declaration name="g" type="Graphics" line="560"/>
                    <scope line="563">
                        <declaration name="x" type="int" line="568"/>
                        <scope line="569"/>
                    </scope>
                </scope>
                <declaration name="surfaceData" type="SurfaceData" line="581"/>
                <scope line="582">
                    <declaration name="bgColor" type="Color" line="584"/>
                    <scope line="585"/>
                    <declaration name="fgColor" type="Color" line="588"/>
                    <scope line="589"/>
                    <declaration name="font" type="Font" line="592"/>
                    <scope line="593"/>
                    <declaration name="mgr" type="ScreenUpdateManager" line="596"/>
                </scope>
            </method>
            <method name="getFontMetrics" type="FontMetrics" line="603">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="_dispose" type="void" line="607"/>
            <method name="disposeImpl" type="void" line="608">
                <comment line="613">
                    remove from updater before calling targetDisposedPeer                    
                </comment>
                <declaration name="oldData" type="SurfaceData" line="609"/>
            </method>
            <method name="setForeground" type="void" line="618">
                <params>
                    <param name="c" type="Color"/>
                </params>
            </method>
            <method name="setBackground" type="void" line="623">
                <params>
                    <param name="c" type="Color"/>
                </params>
            </method>
            <javadoc line="628">
                This method is intentionally not synchronized as it is called while
                  holding other locks.                
                <see>
                    sun.java2d.d3d.D3DScreenUpdateManager#validate(D3DWindowSurfaceData)                    
                </see>
            </javadoc>
            <method name="getBackgroundNoSync" type="Color" line="634"/>
            <method name="_setForeground" type="void" line="638"/>
            <method name="_setBackground" type="void" line="639"/>
            <method name="setFont" type="void" line="641">
                <params>
                    <param name="f" type="Font"/>
                </params>
            </method>
            <method name="_setFont" type="void" line="645"/>
            <method name="updateCursorImmediately" type="void" line="646"/>
            <method name="requestFocus" type="boolean" line="654">
                <params>
                    <param name="lightweightChild" type="Component"/>
                    <param name="temporary" type="boolean"/>
                    <param name="focusedWindowChangeAllowed" type="boolean"/>
                    <param name="time" type="long"/>
                    <param name="cause" type="CausedFocusEvent.Cause"/>
                </params>
                <comment line="685">
                    If parent window can be made focused and has been made focused(synchronously)                    
                </comment>
                <comment line="686">
                    then we can proceed with children, otherwise we retreat.                    
                </comment>
                <comment line="697">
                    Either lightweight or excessive request - all events are generated.                    
                </comment>
                <scope line="658"/>
                <declaration name="result" type="int" line="662"/>
                <scope line="671"/>
                <declaration name="parentWindow" type="Window" line="674"/>
                <scope line="675"/>
                <declaration name="wpeer" type="WWindowPeer" line="678"/>
                <scope line="679"/>
                <declaration name="res" type="boolean" line="682"/>
                <scope line="687"/>
            </method>
            <method name="rejectFocusRequestHelper" type="boolean" line="703">
                <params>
                    <param name="logMsg" type="String"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="709">
                <params>
                    <param name="producer" type="ImageProducer"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="713">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="gc" type="Win32GraphicsConfig" line="714"/>
            </method>
            <method name="createVolatileImage" type="VolatileImage" line="719">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <method name="prepareImage" type="boolean" line="723">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
            </method>
            <method name="checkImage" type="int" line="727">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
            </method>
            <method name="toString" type="String" line="733"/>
            <declaration name="updateX1" type="int" line="739"/>
            <method name="WComponentPeer" type="constructor" line="741">
                <params>
                    <param name="target" type="Component"/>
                </params>
                <comment line="747">
                    fix for 5088782: check if window object is created successfully                    
                </comment>
                <comment line="752">
                    Initialize enable/disable state, turn on callbacks                    
                </comment>
                <declaration name="parent" type="Container" line="744"/>
                <declaration name="parentPeer" type="WComponentPeer" line="745"/>
            </method>
            <method name="create" type="void" line="754"/>
            <method name="checkCreation" type="void" line="757">
                <scope line="759">
                    <scope line="761"/>
                    <scope line="765"/>
                </scope>
            </method>
            <method name="start" type="void" line="771"/>
            <method name="initialize" type="void" line="773">
                <comment line="775">
                    the wnd starts hidden                    
                </comment>
                <comment line="781">
                    Set background color in C++, to avoid inheriting a parent&apos;s color.                    
                </comment>
                <scope line="774"/>
                <declaration name="fg" type="Color" line="777"/>
                <scope line="778"/>
                <declaration name="f" type="Font" line="782"/>
                <scope line="783"/>
                <scope line="786"/>
                <declaration name="r" type="Rectangle" line="789"/>
            </method>
            <method name="handleRepaint" type="void" line="796">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="797">
                    Repaints are posted from updateClient now...                    
                </comment>
            </method>
            <method name="handleExpose" type="void" line="802">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="803">
                    Bug ID 4081126 &amp; 4129709 - can&apos;t do the clearRect() here,                    
                </comment>
                <comment line="804">
                    since it interferes with the java thread working in the                    
                </comment>
                <comment line="805">
                    same window on multi-processor NT machines.                    
                </comment>
            </method>
            <method name="handlePaint" type="void" line="817">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <method name="postPaintIfNecessary" type="void" line="821">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="822">
                    <declaration name="event" type="PaintEvent" line="823"/>
                    <scope line="825"/>
                </scope>
            </method>
            <method name="postEvent" type="void" line="834">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
            </method>
            <method name="preprocessPostEvent" type="void" line="839">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
            </method>
            <method name="beginLayout" type="void" line="842">
                <comment line="843">
                    Skip all painting till endLayout                    
                </comment>
            </method>
            <method name="endLayout" type="void" line="847">
                <comment line="850">
                    if not waiting for native painting repaint damaged area                    
                </comment>
                <scope line="849"/>
            </method>
            <method name="beginValidate" type="void" line="857"/>
            <method name="endValidate" type="void" line="858"/>
            <javadoc line="860">
                DEPRECATED                
            </javadoc>
            <method name="minimumSize" type="Dimension" line="863"/>
            <javadoc line="867">
                DEPRECATED                
            </javadoc>
            <method name="preferredSize" type="Dimension" line="870"/>
            <javadoc line="874">
                register a DropTarget with this native peer                
            </javadoc>
            <method name="addDropTarget" type="void" line="878">
                <params>
                    <param name="dt" type="DropTarget"/>
                </params>
                <scope line="879"/>
            </method>
            <javadoc line="885">
                unregister a DropTarget with this native peer                
            </javadoc>
            <method name="removeDropTarget" type="void" line="889">
                <params>
                    <param name="dt" type="DropTarget"/>
                </params>
                <scope line="891"/>
            </method>
            <method name="addNativeDropTarget" type="long" line="897"/>
            <javadoc line="897">
                add the native peer&apos;s AwtDropTarget COM object                
                <return>
                    reference to AwtDropTarget object                    
                </return>
            </javadoc>
            <method name="removeNativeDropTarget" type="void" line="904"/>
            <javadoc line="904">
                remove the native peer&apos;s AwtDropTarget COM object                
            </javadoc>
            <method name="nativeHandlesWheelScrolling" type="boolean" line="909"/>
            <method name="handlesWheelScrolling" type="boolean" line="911">
                <comment line="912">
                    should this be cached?                    
                </comment>
            </method>
            <method name="isPaintPending" type="boolean" line="918"/>
            <javadoc line="922">
                The following multibuffering-related methods delegate to our
                  associated GraphicsConfig (Win or WGL) to handle the appropriate
                  native windowing system specific actions.                
            </javadoc>
            <method name="createBuffers" type="void" line="931">
                <params>
                    <param name="numBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
                <comment line="936">
                    Re-create the primary surface with the new number of back buffers                    
                </comment>
                <declaration name="gc" type="Win32GraphicsConfig" line="932"/>
                <scope line="937"/>
                <scope line="939"/>
            </method>
            <method name="destroyBuffers" type="void" line="945"/>
            <method name="flip" type="void" line="952">
                <params>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <declaration name="backBuffer" type="VolatileImage" line="953"/>
                <scope line="954"/>
                <declaration name="gc" type="Win32GraphicsConfig" line="957"/>
            </method>
            <method name="getBackBuffer" type="Image" line="963">
                <declaration name="backBuffer" type="Image" line="964"/>
                <scope line="965"/>
            </method>
            <method name="getBackBufferCaps" type="BufferCapabilities" line="970"/>
            <method name="getBackBuffersNum" type="int" line="973"/>
            <method name="shouldClearRectBeforePaint" type="boolean" line="979"/>
            <method name="pSetParent" type="void" line="983"/>
            <javadoc line="985">
                @see java.awt.peer.ComponentPeer#reparent                
            </javadoc>
            <method name="reparent" type="void" line="988">
                <params>
                    <param name="newNativeParent" type="ContainerPeer"/>
                </params>
            </method>
            <javadoc line="992">
                @see java.awt.peer.ComponentPeer#isReparentSupported                
            </javadoc>
            <method name="isReparentSupported" type="boolean" line="995"/>
            <method name="setBoundsOperation" type="void" line="999">
                <params>
                    <param name="operation" type="int"/>
                </params>
            </method>
            <declaration name="isAccelCapable" type="boolean" line="1002"/>
            <javadoc line="1004">
                Returns whether this component is capable of being hw accelerated.
                  More specifically, whether rendering to this component or a
                  BufferStrategy&apos;s back-buffer for this component can be hw accelerated.
                  Conditions which could prevent hw acceleration include the toplevel
                  window containing this component being{@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENTPERPIXEL_TRANSLUCENT}.
                  Another condition is if Xor paint mode was detected when rendering
                  to an on-screen accelerated surface associated with this peer.
                  in this case both on- and off-screen acceleration for this peer is
                  disabled.                
                <return>
                    {@code true} if this component is capable of being hw
                      accelerated, {@code false} otherwise                    
                </return>
                <see>
                    GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT                    
                </see>
            </javadoc>
            <method name="isAccelCapable" type="boolean" line="1023">
                <comment line="1032">
                    D3D/OGL and translucent windows interacted poorly in Windows XP;                    
                </comment>
                <comment line="1033">
                    these problems are no longer present in Vista                    
                </comment>
                <scope line="1026"/>
                <declaration name="isTranslucent" type="boolean" line="1030"/>
            </method>
            <javadoc line="1037">
                Disables acceleration for this peer.                
            </javadoc>
            <method name="disableAcceleration" type="void" line="1040"/>
            <method name="setRectangularShape" type="void" line="1045"/>
            <method name="isContainingTopLevelAccelCapable" type="boolean" line="1053">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="1054"/>
                <scope line="1057"/>
            </method>
            <javadoc line="1063">
                Applies the shape to the native component window.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="applyShape" type="void" line="1067">
                <params>
                    <param name="shape" type="Region"/>
                </params>
                <scope line="1068"/>
                <scope line="1075"/>
                <scope line="1078"/>
            </method>
            <javadoc line="1083">
                Lowers this component at the bottom of the above component. If the above parameter
                  is null then the method places this component at the top of the Z-order.                
            </javadoc>
            <method name="setZOrder" type="void" line="1087">
                <params>
                    <param name="above" type="ComponentPeer"/>
                </params>
                <declaration name="aboveHWND" type="long" line="1088"/>
            </method>
            <method name="setZOrder" type="void" line="1093"/>
        </class>
    </source>