<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.d3d">
        <import package="java.awt.AlphaComposite"/>
        <import package="java.awt.BufferCapabilities"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.SampleModel"/>
        <import package="java.awt.image.SinglePixelPackedSampleModel"/>
        <import package="sun.awt.SunHints"/>
        <import package="sun.awt.image.DataBufferNative"/>
        <import package="sun.awt.image.PixelConverter"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.awt.image.WritableRasterNative"/>
        <import package="sun.awt.windows.WComponentPeer"/>
        <import package="sun.java2d.pipe.hw.AccelSurface"/>
        <import package="sun.java2d.InvalidPipeException"/>
        <import package="sun.java2d.SunGraphics2D"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.GraphicsPrimitive"/>
        <import package="sun.java2d.loops.MaskFill"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.pipe.ParallelogramPipe"/>
        <import package="sun.java2d.pipe.PixelToParallelogramConverter"/>
        <import package="sun.java2d.pipe.RenderBuffer"/>
        <import package="sun.java2d.pipe.TextPipe"/>
        <import package="sun.java2d.pipe.BufferedOpCodes"/>
        <import package="sun.java2d.d3d.D3DContext.D3DContextCaps"/>
        <import package="sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType"/>
        <import package="sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType"/>
        <import package="java.awt.BufferCapabilities.FlipContents"/>
        <import package="java.awt.Window"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.java2d.ScreenUpdateManager"/>
        <import package="sun.java2d.StateTracker"/>
        <import package="sun.java2d.SurfaceDataProxy"/>
        <import package="sun.java2d.pipe.hw.ExtendedBufferCapabilities"/>
        <class name="D3DSurfaceData" line="47">
            <extends class="SurfaceData"/>
            <implements interface="AccelSurface"/>
            <javadoc line="47">
                This class describes a D3D &quot;surface&quot;, that is, a region of pixels
                  managed via D3D.  An D3DSurfaceData can be tagged with one of three
                  different SurfaceType objects for the purpose of registering loops, etc.
                  This diagram shows the hierarchy of D3D SurfaceTypes:
                  Any
                  /     \
                  D3DSurface     D3DTexture
                  |
                  D3DSurfaceRTT
                  D3DSurface
                  This kind of surface can be rendered to using D3D APIs.  It is also
                  possible to copy a D3DSurface to another D3DSurface (or to itself).
                  D3DTexture
                  This kind of surface cannot be rendered to using D3D (in the same sense
                  as in D3DSurface).  However, it is possible to upload a region of pixels
                  to a D3DTexture object via Lock/UnlockRect().  One can also copy a
                  surface of type D3DTexture to a D3DSurface by binding the texture
                  to a quad and then rendering it to the destination surface (this process
                  is known as &quot;texture mapping&quot;).
                  D3DSurfaceRTT
                  This kind of surface can be thought of as a sort of hybrid between
                  D3DSurface and D3DTexture, in that one can render to this kind of
                  surface as if it were of type D3DSurface, but the process of copying
                  this kind of surface to another is more like a D3DTexture.  (Note that
                  &quot;RTT&quot; stands for &quot;render-to-texture&quot;.)
                  In addition to these SurfaceType variants, we have also defined some
                  constants that describe in more detail the type of underlying D3D
                  surface.  This table helps explain the relationships between those
                  &quot;type&quot; constants and their corresponding SurfaceType:
                  D3D Type          Corresponding SurfaceType
                  --------          -------------------------
                  RT_PLAIN          D3DSurface
                  TEXTURE           D3DTexture
                  FLIP_BACKBUFFER   D3DSurface
                  RT_TEXTURE        D3DSurfaceRTT                
            </javadoc>
            <declaration name="D3D_DEVICE_RESOURCE" type="int" line="85"/>
            <javadoc line="85">
                To be used with getNativeResource() only.                
                <see>
                    #getNativeResource()                    
                </see>
            </javadoc>
            <declaration name="ST_INT_ARGB" type="int" line="90"/>
            <declaration name="ST_INT_ARGB_PRE" type="int" line="91"/>
            <declaration name="ST_INT_ARGB_BM" type="int" line="92"/>
            <declaration name="ST_INT_RGB" type="int" line="93"/>
            <declaration name="ST_INT_BGR" type="int" line="94"/>
            <declaration name="ST_USHORT_565_RGB" type="int" line="95"/>
            <declaration name="ST_USHORT_555_RGB" type="int" line="96"/>
            <declaration name="ST_BYTE_INDEXED" type="int" line="97"/>
            <declaration name="ST_BYTE_INDEXED_BM" type="int" line="98"/>
            <declaration name="ST_3BYTE_BGR" type="int" line="99"/>
            <declaration name="SWAP_DISCARD" type="int" line="100"/>
            <javadoc line="100">
                Equals to D3DSWAPEFFECT_DISCARD                
            </javadoc>
            <declaration name="SWAP_FLIP" type="int" line="104"/>
            <javadoc line="104">
                Equals to D3DSWAPEFFECT_FLIP                
            </javadoc>
            <declaration name="SWAP_COPY" type="int" line="108"/>
            <javadoc line="108">
                Equals to D3DSWAPEFFECT_COPY                
            </javadoc>
            <declaration name="DESC_D3D_SURFACE" type="String" line="112"/>
            <declaration name="DESC_D3D_SURFACE_RTT" type="String" line="113"/>
            <declaration name="DESC_D3D_TEXTURE" type="String" line="114"/>
            <declaration name="D3DSurface" type="SurfaceType" line="115"/>
            <declaration name="D3DSurfaceRTT" type="SurfaceType" line="116"/>
            <declaration name="D3DTexture" type="SurfaceType" line="117"/>
            <declaration name="type" type="int" line="118"/>
            <declaration name="width" type="int" line="119"/>
            <declaration name="nativeWidth" type="int" line="120"/>
            <declaration name="peer" type="WComponentPeer" line="121"/>
            <declaration name="offscreenImage" type="Image" line="122"/>
            <declaration name="graphicsDevice" type="D3DGraphicsDevice" line="123"/>
            <declaration name="swapEffect" type="int" line="124"/>
            <declaration name="syncType" type="VSyncType" line="125"/>
            <declaration name="backBuffersNum" type="int" line="126"/>
            <declaration name="wrn" type="WritableRasterNative" line="127"/>
            <declaration name="d3dRenderPipe" type="D3DRenderer" line="128"/>
            <declaration name="d3dTxRenderPipe" type="PixelToParallelogramConverter" line="129"/>
            <declaration name="d3dAAPgramPipe" type="ParallelogramPipe" line="130"/>
            <declaration name="d3dTextPipe" type="D3DTextRenderer" line="131"/>
            <declaration name="d3dImagePipe" type="D3DDrawImage" line="132"/>
            <method name="initTexture" type="boolean" line="133"/>
            <method name="initFlipBackbuffer" type="boolean" line="134"/>
            <method name="initRTSurface" type="boolean" line="135"/>
            <method name="initOps" type="void" line="136"/>
            <scope line="137">
                <declaration name="rq" type="D3DRenderQueue" line="138"/>
                <scope line="142"/>
            </scope>
            <method name="D3DSurfaceData" type="constructor" line="152">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                    <param name="gc" type="D3DGraphicsConfig"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="image" type="Image"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="numBackBuffers" type="int"/>
                    <param name="swapEffect" type="int"/>
                    <param name="vSyncType" type="VSyncType"/>
                    <param name="type" type="int"/>
                </params>
                <scope line="164"/>
                <scope line="167"/>
            </method>
            <method name="makeProxyFor" type="SurfaceDataProxy" line="172">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                </params>
            </method>
            <javadoc line="175">
                Creates a SurfaceData object representing the back buffer of a
                  double-buffered on-screen Window.                
            </javadoc>
            <method name="createData" type="D3DSurfaceData" line="179">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                    <param name="image" type="Image"/>
                </params>
                <declaration name="gc" type="D3DGraphicsConfig" line="180"/>
                <scope line="181"/>
                <declaration name="caps" type="BufferCapabilities" line="184"/>
                <declaration name="vSyncType" type="VSyncType" line="185"/>
                <scope line="186"/>
                <declaration name="r" type="Rectangle" line="189"/>
                <declaration name="flip" type="BufferCapabilities.FlipContents" line="190"/>
                <declaration name="swapEffect" type="int" line="191"/>
                <scope line="192"/>
                <scope line="195"/>
                <scope line="198"/>
            </method>
            <javadoc line="203">
                Returns a WINDOW type of surface - a
                  swap chain which serves as an on-screen surface,
                  handled by the D3DScreenUpdateManager.
                  Note that the native surface is not initialized
                  when the surface is created to avoid using excessive
                  resources, and the surface is placed into the lost
                  state. It will be restored prior to any rendering
                  to it.                
                <param>
                    peer peer for which the onscreen surface is to be created                    
                </param>
                <return>
                    a D3DWindowSurfaceData (flip chain) surface                    
                </return>
            </javadoc>
            <method name="createData" type="D3DSurfaceData" line="215">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                </params>
                <declaration name="gc" type="D3DGraphicsConfig" line="216"/>
                <scope line="217"/>
            </method>
            <javadoc line="222">
                Creates a SurfaceData object representing an off-screen buffer (either
                  a plain surface or Texture).                
            </javadoc>
            <method name="createData" type="D3DSurfaceData" line="226">
                <params>
                    <param name="gc" type="D3DGraphicsConfig"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="image" type="Image"/>
                    <param name="type" type="int"/>
                </params>
                <scope line="227">
                    <declaration name="isOpaque" type="boolean" line="228"/>
                    <declaration name="cap" type="int" line="229"/>
                    <scope line="230"/>
                </scope>
                <declaration name="ret" type="D3DSurfaceData" line="234"/>
                <scope line="235"/>
                <scope line="238">
                    <scope line="239">
                        <scope line="240"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="248">
                Returns the appropriate SurfaceType corresponding to the given D3D
                  surface type constant (e.g. TEXTURE -&gt; D3DTexture).                
            </javadoc>
            <method name="getCustomSurfaceType" type="SurfaceType" line="252">
                <params>
                    <param name="d3dType" type="int"/>
                </params>
            </method>
            <method name="initSurfaceNow" type="boolean" line="262">
                <declaration name="isOpaque" type="boolean" line="263"/>
            </method>
            <javadoc line="278">
                Initializes the appropriate D3D offscreen surface based on the value
                  of the type parameter.  If the surface creation fails for any reason,
                  an OutOfMemoryError will be thrown.                
            </javadoc>
            <method name="initSurface" type="void" line="283">
                <scope line="284"/>
                <class name="Status" line="287">
                    <declaration name="success" type="boolean" line="288"/>
                </class>
                <declaration name="status" type="Status" line="291"/>
                <declaration name="rq" type="D3DRenderQueue" line="292"/>
                <scope line="294">
                    <anonymous_class line="295">
                        <method name="run" type="void" line="296"/>
                    </anonymous_class>
                    <scope line="301"/>
                </scope>
                <scope line="305"/>
            </method>
            <javadoc line="309">
                Returns the D3DContext for the GraphicsConfig associated with this
                  surface.                
            </javadoc>
            <method name="getContext" type="D3DContext" line="313"/>
            <javadoc line="316">
                Returns one of the surface type constants defined above.                
            </javadoc>
            <method name="getType" type="int" line="319"/>
            <method name="dbGetPixelNative" type="int" line="322"/>
            <method name="dbSetPixelNative" type="void" line="323"/>
            <class name="D3DDataBufferNative" line="324">
                <extends class="DataBufferNative"/>
                <declaration name="pixel" type="int" line="325"/>
                <method name="D3DDataBufferNative" type="constructor" line="326">
                    <params>
                        <param name="sData" type="SurfaceData"/>
                        <param name="type" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <method name="getElem" type="int" line="329">
                    <params>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="sData" type="SurfaceData"/>
                    </params>
                    <scope line="330"/>
                    <declaration name="retPixel" type="int" line="333"/>
                    <declaration name="rq" type="D3DRenderQueue" line="334"/>
                    <scope line="336">
                        <anonymous_class line="337">
                            <method name="run" type="void" line="338"/>
                        </anonymous_class>
                    </scope>
                    <scope line="344"/>
                </method>
                <method name="setElem" type="void" line="350">
                    <params>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="pixel" type="int"/>
                        <param name="sData" type="SurfaceData"/>
                    </params>
                    <scope line="351"/>
                    <declaration name="rq" type="D3DRenderQueue" line="354"/>
                    <scope line="356">
                        <anonymous_class line="357">
                            <method name="run" type="void" line="358"/>
                        </anonymous_class>
                    </scope>
                    <scope line="365"/>
                </method>
            </class>
            <method name="getRaster" type="Raster" line="370">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="371">
                    <declaration name="dcm" type="DirectColorModel" line="372"/>
                    <declaration name="smHw" type="SampleModel" line="373"/>
                    <declaration name="dataType" type="int" line="374"/>
                    <declaration name="scanStride" type="int" line="375"/>
                    <scope line="376"/>
                    <scope line="379"/>
                    <declaration name="dbn" type="DataBuffer" line="383"/>
                </scope>
            </method>
            <javadoc line="388">
                For now, we can only render LCD text if:
                  - the pixel shaders are available, and
                  - blending is disabled, and
                  - the source color is opaque
                  - and the destination is opaque                
            </javadoc>
            <method name="canRenderLCDText" type="boolean" line="395">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
            </method>
            <javadoc line="398">
                If acceleration should no longer be used for this surface.
                  This implementation flags to the manager that it should no
                  longer attempt to re-create a D3DSurface.                
            </javadoc>
            <method name="disableAccelerationForSurface" type="void" line="403">
                <scope line="404">
                    <declaration name="sm" type="SurfaceManager" line="405"/>
                    <scope line="406"/>
                </scope>
            </method>
            <method name="validatePipe" type="void" line="412">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <declaration name="textpipe" type="TextPipe" line="413"/>
                <declaration name="validated" type="boolean" line="414"/>
                <scope line="415"/>
                <scope line="421"/>
                <scope line="424"/>
                <declaration name="txPipe" type="PixelToParallelogramConverter" line="429"/>
                <declaration name="nonTxPipe" type="D3DRenderer" line="430"/>
                <scope line="431">
                    <scope line="432">
                        <scope line="433"/>
                    </scope>
                    <scope line="438">
                        <scope line="439"/>
                    </scope>
                </scope>
                <scope line="445">
                    <scope line="446">
                        <scope line="447">
                            <scope line="448"/>
                            <declaration name="aaConverter" type="PixelToParallelogramConverter" line="452"/>
                        </scope>
                        <scope line="457"/>
                    </scope>
                </scope>
                <scope line="463">
                    <scope line="464"/>
                    <scope line="468"/>
                    <scope line="472"/>
                </scope>
                <scope line="478">
                    <scope line="479"/>
                </scope>
            </method>
            <method name="getMaskFill" type="MaskFill" line="486">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <scope line="487">
                    <scope line="488"/>
                </scope>
            </method>
            <method name="copyArea" type="boolean" line="494">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                </params>
                <scope line="495"/>
            </method>
            <method name="flush" type="void" line="503">
                <declaration name="rq" type="D3DRenderQueue" line="504"/>
                <scope line="506">
                    <declaration name="buf" type="RenderBuffer" line="507"/>
                </scope>
                <scope line="513"/>
            </method>
            <javadoc line="517">
                Disposes the native resources associated with the given D3DSurfaceData
                  (referenced by the pData parameter).  This method is invoked from
                  the native Dispose() method from the Disposer thread when the
                  Java-level D3DSurfaceData object is about to go away.                
            </javadoc>
            <method name="dispose" type="void" line="523">
                <params>
                    <param name="pData" type="long"/>
                </params>
                <declaration name="rq" type="D3DRenderQueue" line="524"/>
                <scope line="526">
                    <declaration name="buf" type="RenderBuffer" line="527"/>
                </scope>
                <scope line="533"/>
            </method>
            <method name="swapBuffers" type="void" line="537">
                <params>
                    <param name="sd" type="D3DSurfaceData"/>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                </params>
                <declaration name="pData" type="long" line="538"/>
                <declaration name="rq" type="D3DRenderQueue" line="539"/>
                <scope line="540">
                    <scope line="541">
                        <declaration name="target" type="Component" line="542"/>
                        <anonymous_class line="543">
                            <method name="run" type="void" line="544"/>
                        </anonymous_class>
                    </scope>
                </scope>
                <scope line="552"/>
                <scope line="555">
                    <declaration name="buf" type="RenderBuffer" line="556"/>
                </scope>
                <scope line="566"/>
            </method>
            <javadoc line="570">
                Returns destination Image associated with this SurfaceData.                
            </javadoc>
            <method name="getDestination" type="Object" line="573"/>
            <method name="getBounds" type="Rectangle" line="576">
                <scope line="577">
                    <declaration name="r" type="Rectangle" line="578"/>
                </scope>
                <scope line="582"/>
            </method>
            <method name="getNativeBounds" type="Rectangle" line="586">
                <declaration name="rq" type="D3DRenderQueue" line="587"/>
                <scope line="589"/>
                <scope line="592"/>
            </method>
            <method name="getDeviceConfiguration" type="GraphicsConfiguration" line="596"/>
            <method name="getReplacement" type="SurfaceData" line="599"/>
            <method name="getGC" type="D3DGraphicsConfig" line="602">
                <params>
                    <param name="peer" type="WComponentPeer"/>
                </params>
                <declaration name="gc" type="GraphicsConfiguration" line="603"/>
                <scope line="604"/>
                <scope line="607">
                    <declaration name="env" type="GraphicsEnvironment" line="608"/>
                    <declaration name="gd" type="GraphicsDevice" line="609"/>
                </scope>
            </method>
            <javadoc line="614">
                Attempts to restore the surface by initializing the native data                
            </javadoc>
            <method name="restoreSurface" type="void" line="617"/>
            <method name="getPeer" type="WComponentPeer" line="620"/>
            <javadoc line="623">
                We need to let the surface manager know that the surface is lost so
                  that for example BufferStrategy.contentsLost() returns correct result.
                  Normally the status of contentsLost is set in validate(), but in some
                  cases (like Swing&apos;s buffer per window) we intentionally don&apos;t call
                  validate from the toolkit thread but only check for the BS status.                
            </javadoc>
            <method name="setSurfaceLost" type="void" line="630">
                <params>
                    <param name="lost" type="boolean"/>
                </params>
                <scope line="632">
                    <declaration name="sm" type="SurfaceManager" line="633"/>
                </scope>
            </method>
            <method name="getNativeResourceNative" type="long" line="637"/>
            <javadoc line="638">
                Returns a pointer to the native resource of specified {@code resType}associated with this surface.
                  Specifically, for {@code D3DSurfaceData} this method returns pointers of
                  the following:
                  &lt;pre&gt;
                  TEXTURE              - (IDirect3DTexture9)
                  RT_TEXTURE, RT_PLAIN - (IDirect3DSurface9)
                  FLIP_BACKBUFFER      - (IDirect3DSwapChain9)
                  D3D_DEVICE_RESOURCE  - (IDirect3DDevice9)
                  &lt;/pre&gt;
                  Multiple resources may be available for some types (i.e. for render to
                  texture one could retrieve both a destination surface by specifying
                  RT_TEXTURE, and a texture by using TEXTURE).
                  Note: the pointer returned by this method is only valid on the rendering
                  thread.                
                <return>
                    pointer to the native resource of specified type or 0L if
                      such resource doesn't exist or can not be retrieved.                    
                </return>
                <see>
                    sun.java2d.pipe.hw.AccelSurface#getNativeResource                    
                </see>
            </javadoc>
            <method name="getNativeResource" type="long" line="657">
                <params>
                    <param name="resType" type="int"/>
                </params>
            </method>
            <class name="D3DWindowSurfaceData" line="660">
                <extends class="D3DSurfaceData"/>
                <javadoc line="660">
                    Class representing an on-screen d3d surface. Since d3d can&apos;t
                      render to the screen directly, it is implemented as a swap chain,
                      controlled by D3DScreenUpdateManager.                    
                    <see>
                        D3DScreenUpdateManager                        
                    </see>
                </javadoc>
                <declaration name="dirtyTracker" type="StateTracker" line="667"/>
                <method name="D3DWindowSurfaceData" type="constructor" line="668">
                    <params>
                        <param name="peer" type="WComponentPeer"/>
                        <param name="gc" type="D3DGraphicsConfig"/>
                    </params>
                </method>
                <javadoc line="672">
                    {@inheritDoc}Overridden to use ScreenUpdateManager to obtain the replacement
                      surface.                    
                    <see>
                        sun.java2d.ScreenUpdateManager#getReplacementScreenSurface                        
                    </see>
                </javadoc>
                <method name="getReplacement" type="SurfaceData" line="677">
                    <declaration name="mgr" type="ScreenUpdateManager" line="678"/>
                </method>
                <javadoc line="681">
                    Returns destination Component associated with this SurfaceData.                    
                </javadoc>
                <method name="getDestination" type="Object" line="684"/>
                <method name="disableAccelerationForSurface" type="void" line="687"/>
                <method name="restoreSurface" type="void" line="694">
                    <scope line="695"/>
                    <declaration name="fsw" type="Window" line="698"/>
                    <scope line="699"/>
                    <declaration name="rq" type="D3DRenderQueue" line="704"/>
                    <scope line="706"/>
                    <scope line="709"/>
                </method>
                <method name="isDirty" type="boolean" line="713"/>
                <method name="markClean" type="void" line="716"/>
            </class>
            <method name="updateWindowAccelImpl" type="boolean" line="720"/>
            <javadoc line="720">
                Updates the layered window with the contents of the surface.                
                <param>
                    pd3dsd pointer to the D3DSDOps structure                    
                </param>
                <param>
                    pData pointer to the AwtWindow peer data                    
                </param>
                <param>
                    w width of the window                    
                </param>
                <param>
                    h height of the window                    
                </param>
                <see>
                    sun.awt.windows.TranslucentWindowPainter                    
                </see>
            </javadoc>
        </class>
    </source>