<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.d3d">
        <import package="java.awt.Component"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="sun.awt.Win32GraphicsConfig"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.awt.image.VolatileSurfaceManager"/>
        <import package="sun.awt.windows.WComponentPeer"/>
        <import package="sun.java2d.InvalidPipeException"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.pipe.hw.AccelSurface"/>
        <import package="sun.java2d.d3d.D3DContext.D3DContextCaps"/>
        <import package="sun.java2d.windows.GDIWindowSurfaceData"/>
        <class name="D3DVolatileSurfaceManager" line="44">
            <extends class="VolatileSurfaceManager"/>
            <declaration name="accelerationEnabled" type="boolean" line="47"/>
            <declaration name="restoreCountdown" type="int" line="48"/>
            <method name="D3DVolatileSurfaceManager" type="constructor" line="50">
                <params>
                    <param name="vImg" type="SunVolatileImage"/>
                    <param name="context" type="Object"/>
                </params>
                <comment line="53">
                    We will attempt to accelerate this image only under the
                     following conditions:
                       - the image is opaque OR
                       - the image is translucent AND
                           - the GraphicsConfig supports the FBO extension OR
                           - the GraphicsConfig has a stored alpha channel                    
                </comment>
                <declaration name="transparency" type="int" line="61"/>
                <declaration name="gd" type="D3DGraphicsDevice" line="62"/>
            </method>
            <method name="isAccelerationEnabled" type="boolean" line="71"/>
            <method name="setAccelerationEnabled" type="void" line="74">
                <params>
                    <param name="accelerationEnabled" type="boolean"/>
                </params>
            </method>
            <javadoc line="78">
                Create a pbuffer-based SurfaceData object (or init the backbuffer
                  of an existing window if this is a double buffered GraphicsConfig).                
            </javadoc>
            <method name="initAcceleratedSurface" type="SurfaceData" line="82">
                <comment line="95">
                    peer must be non-null in this case                    
                </comment>
                <comment line="102">
                    if acceleration type is forced (type != UNDEFINED) then                    
                </comment>
                <comment line="103">
                    use the forced type, otherwise use RT_TEXTURE                    
                </comment>
                <declaration name="sData" type="SurfaceData" line="83"/>
                <declaration name="comp" type="Component" line="84"/>
                <declaration name="peer" type="WComponentPeer" line="85"/>
                <scope line="88">
                    <declaration name="forceback" type="boolean" line="89"/>
                    <scope line="90"/>
                    <scope line="94"/>
                    <scope line="97">
                        <declaration name="gc" type="D3DGraphicsConfig" line="98"/>
                        <declaration name="cm" type="ColorModel" line="100"/>
                        <declaration name="type" type="int" line="101"/>
                        <scope line="104"/>
                    </scope>
                </scope>
                <scope line="113"/>
                <scope line="115"/>
                <scope line="117"/>
            </method>
            <method name="isConfigValid" type="boolean" line="124">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <javadoc line="128">
                Set the number of iterations for restoreAcceleratedSurface to fail
                  before attempting to restore the accelerated surface.                
                <see>
                    #restoreAcceleratedSurface                    
                </see>
                <see>
                    #handleVItoScreenOp                    
                </see>
            </javadoc>
            <method name="setRestoreCountdown" type="void" line="135">
                <params>
                    <param name="count" type="int"/>
                </params>
            </method>
            <javadoc line="139">
                Note that we create a new surface instead of restoring
                  an old one. This will help with D3DContext revalidation.                
            </javadoc>
            <method name="restoreAcceleratedSurface" type="void" line="144">
                <comment line="159">
                    REMIND: alternatively, we could try this:                    
                </comment>
                <comment line="160">
                    ((D3DSurfaceData)sdAccel).restoreSurface();                    
                </comment>
                <scope line="145">
                    <scope line="146"/>
                </scope>
                <declaration name="sData" type="SurfaceData" line="154"/>
                <scope line="155"/>
                <scope line="157"/>
            </method>
            <javadoc line="164">
                We&apos;re asked to restore contents by the accelerated surface, which means
                  that it had been lost.                
            </javadoc>
            <method name="restoreContents" type="SurfaceData" line="169"/>
            <javadoc line="174">
                If the destination surface&apos;s peer can potentially handle accelerated
                  on-screen rendering then it is likely that the condition which resulted
                  in VI to Screen operation is temporary, so this method sets the
                  restore countdown in hope that the on-screen accelerated rendering will
                  resume. In the meantime the backup surface of the VISM will be used.
                  The countdown is needed because otherwise we may never break out
                  of &quot;do { vi.validate()..} while(vi.lost)&quot; loop since validate() could
                  restore the source surface every time and it will get lost again on the
                  next copy attempt, and we would never get a chance to use the backup
                  surface. By using the countdown we allow the backup surface to be used
                  while the screen surface gets sorted out, or if it for some reason can
                  never be restored.
                  If the destination surface&apos;s peer could never do accelerated onscreen
                  rendering then the acceleration for the SurfaceManager associated with
                  the source surface is disabled forever.                
            </javadoc>
            <method name="handleVItoScreenOp" type="void" line="193">
                <params>
                    <param name="src" type="SurfaceData"/>
                    <param name="dst" type="SurfaceData"/>
                </params>
                <comment line="211">
                    10 is only chosen to be greater than the number of                    
                </comment>
                <comment line="212">
                    times a sane person would call validate() inside                    
                </comment>
                <comment line="213">
                    a validation loop, and to reduce thrashing between                    
                </comment>
                <comment line="214">
                    accelerated and backup surfaces                    
                </comment>
                <scope line="196">
                    <declaration name="d3dsd" type="D3DSurfaceData" line="197"/>
                    <declaration name="mgr" type="SurfaceManager" line="198"/>
                    <scope line="200">
                        <declaration name="vsm" type="D3DVolatileSurfaceManager" line="201"/>
                        <scope line="202">
                            <declaration name="wsd" type="GDIWindowSurfaceData" line="205"/>
                            <declaration name="p" type="WComponentPeer" line="206"/>
                            <scope line="210"/>
                            <scope line="216"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="initContents" type="void" line="225">
                <scope line="226"/>
            </method>
        </class>
    </source>