<?xml version="1.0" encoding="UTF-8"?>
    <source package="">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="java.nio.channels"/>
        <import package="javax.net.ssl"/>
        <import package="javax.net.ssl.SSLEngineResult"/>
        <class name="ChannelIOSecure" line="38">
            <extends class="ChannelIO"/>
            <comment line="103">
                All IO goes through these buffers.
                 &lt;P&gt;
                 It might be nice to use a cache of ByteBuffers so we&apos;re
                 not allocdealloc&apos;ing ByteBuffer&apos;s for each new SSLEngine.
                 &lt;P&gt;
                 We use our superclass&apos; requestBB for our application input buffer.
                 Outbound application data is supplied to us by our callers.                
            </comment>
            <comment line="115">
                An empty ByteBuffer for use when one isn&apos;t available, say
                 as a source buffer during initial handshake wraps or for close
                 operations.                
            </comment>
            <comment line="122">
                The FileChannel we&apos;re currently transferTo&apos;ing (reading).                
            </comment>
            <comment line="127">
                During our initial handshake, keep track of the next
                 SSLEngine operation that needs to occur:
                
                     NEED_WRAPNEED_UNWRAP
                
                 Once the initial handshake has completed, we can short circuit
                 handshake checks with initialHSComplete.                
            </comment>
            <comment line="139">
                We have received the shutdown request by our caller, and have
                 closed our outbound side.                
            </comment>
            <comment line="145">
                Constructor for a secure ChannelIO variant.                
            </comment>
            <comment line="172">
                Static factory method for creating a secure ChannelIO object.
                 &lt;P&gt;
                 We need to allocate different sized application data buffers
                 based on whether we&apos;re secure or not.  We can&apos;t determine
                 this until our sslEngine is created.                
            </comment>
            <comment line="193">
                Calls up to the superclass to adjust the buffer size
                 by an appropriate increment.                
            </comment>
            <comment line="201">
                Adjust the inbount network buffer to an appropriate size.                
            </comment>
            <comment line="211">
                Writes bb to the SocketChannel.
                 &lt;P&gt;
                 Returns true when the ByteBuffer has no remaining data.                
            </comment>
            <comment line="221">
                Perform any handshaking processing.
                 &lt;P&gt;
                 This variant is for Servers without SelectionKeys (e.g.
                 blocking).                
            </comment>
            <comment line="231">
                Perform any handshaking processing.
                 &lt;P&gt;
                 If a SelectionKey is passed, register for selectable
                 operations.
                 &lt;P&gt;
                 In the blocking case, our caller will keep calling us until
                 we finish the handshake.  Our readswrites will block as expected.
                 &lt;P&gt;
                 In the non-blocking case, we just received the selection notification
                 that this channel is ready for whatever the operation is, so give
                 it a try.
                 &lt;P&gt;
                 return:
                          true when handshake is done.
                          false while handshake is in progress                
            </comment>
            <comment line="397">
                Do all the outstanding handshake tasks in the current Thread.                
            </comment>
            <comment line="414">
                Read the channel for more information, then unwrap the
                 (hopefully application) data we get.
                 &lt;P&gt;
                 If we run out of data, we&apos;ll return to our caller (possibly using
                 a Selector) to get notification that more is available.
                 &lt;P&gt;
                 Each call to this method will perform at most one underlying read().                
            </comment>
            <comment line="480">
                Try to write out as much as possible from the src buffer.                
            </comment>
            <comment line="492">
                Try to flush out any existing outbound data, then try to wrap
                 anything new contained in the src buffer.
                 &lt;P&gt;
                 Return the number of bytes actually consumed from the buffer,
                 but the data may actually be still sitting in the output buffer,
                 waiting to be flushed.                
            </comment>
            <comment line="542">
                Perform a FileChannel.TransferTo on the socket channel.
                 &lt;P&gt;
                 We have to copy the data into an intermediary app ByteBuffer
                 first, then send it through the SSLEngine.
                 &lt;P&gt;
                 We return the number of bytes actually read out of the
                 filechannel.  However, the data may actually be stuck
                 in the fileChannelBB or the outNetBB.  The caller
                 is responsible for making sure to call dataFlush()
                 before shutting down.                
            </comment>
            <comment line="579">
                Flush any remaining data.
                 &lt;P&gt;
                 Return true when the fileChannelBB and outNetBB are empty.                
            </comment>
            <comment line="597">
                Begin the shutdown process.
                 &lt;P&gt;
                 Close out the SSLEngine if not already done so, then
                 wrap our outgoing close_notify message and try to send it on.
                 &lt;P&gt;
                 Return true when we&apos;re done passing the shutdown messsages.                
            </comment>
            <comment line="639">
                close() is not overridden                
            </comment>
            <javadoc line="38">
                A helper class which performs I/O using the SSLEngine API.
                  &lt;P&gt;
                  Each connection has a SocketChannel and a SSLEngine that is
                  used through the lifetime of the Channel.  We allocate byte buffers
                  for use as the outbound and inbound network buffers.
                  &lt;PRE&gt;
                  Application Data
                  src      requestBB
                  |           ^
                  |     |     |
                  v     |     |
                  +----+-----|-----+----+
                  |          |          |
                  |       SSL|Engine    |
                  wrap()  |          |          |  unwrap()
                  | OUTBOUND | INBOUND  |
                  |          |          |
                  +----+-----|-----+----+
                  |     |     ^
                  |     |     |
                  v           |
                  outNetBB     inNetBB
                  Net data
                  &lt;/PRE&gt;
                  These buffers handle all of the intermediary data for the SSL
                  connection.  To make things easy, we&apos;ll require outNetBB be
                  completely flushed before trying to wrap any more data, but we
                  could certainly remove that restriction by using larger buffers.
                  &lt;P&gt;
                  There are many, many ways to handle compute and I/O strategies.
                  What follows is a relatively simple one.  The reader is encouraged
                  to develop the strategy that best fits the application.
                  &lt;P&gt;
                  In most of the non-blocking operations in this class, we let the
                  Selector tell us when we&apos;re ready to attempt an I/O operation (by the
                  application repeatedly calling our methods).  Another option would be
                  to attempt the operation and return from the method when no forward
                  progress can be made.
                  &lt;P&gt;
                  There&apos;s lots of room for enhancements and improvement in this example.
                  &lt;P&gt;
                  We&apos;re checking for SSL/TLS end-of-stream truncation attacks via
                  sslEngine.closeInbound().  When you reach the end of a input stream
                  via a read() returning -1 or an IOException, we call
                  sslEngine.closeInbound() to signal to the sslEngine that no more
                  input will be available.  If the peer&apos;s close_notify message has not
                  yet been received, this could indicate a trucation attack, in which
                  an attacker is trying to prematurely close the connection.   The
                  closeInbound() will throw an exception if this condition were
                  present.                
                <author>
                    Brad R. Wetmore                    
                </author>
                <author>
                    Mark Reinhold                    
                </author>
            </javadoc>
            <declaration name="sslEngine" type="SSLEngine" line="97"/>
            <declaration name="appBBSize" type="int" line="99"/>
            <declaration name="netBBSize" type="int" line="100"/>
            <declaration name="inNetBB" type="ByteBuffer" line="111"/>
            <declaration name="outNetBB" type="ByteBuffer" line="112"/>
            <declaration name="hsBB" type="ByteBuffer" line="119"/>
            <declaration name="fileChannelBB" type="ByteBuffer" line="124"/>
            <declaration name="initialHSStatus" type="HandshakeStatus" line="135"/>
            <declaration name="initialHSComplete" type="boolean" line="136"/>
            <declaration name="shutdown" type="boolean" line="142"/>
            <method name="ChannelIOSecure" type="constructor" line="148">
                <params>
                    <param name="sc" type="SocketChannel"/>
                    <param name="blocking" type="boolean"/>
                    <param name="sslc" type="SSLContext"/>
                </params>
                <comment line="152">
                    We&apos;re a server, so no need to use hostport variant.
                    
                     The first call for a server is a NEED_UNWRAP.                    
                </comment>
                <comment line="162">
                    Create a buffer using the normal expected packet size we&apos;ll
                     be getting.  This may change, depending on the peer&apos;s
                     SSL implementation.                    
                </comment>
            </method>
            <method name="getInstance" type="ChannelIOSecure" line="179">
                <params>
                    <param name="sc" type="SocketChannel"/>
                    <param name="blocking" type="boolean"/>
                    <param name="sslc" type="SSLContext"/>
                </params>
                <comment line="184">
                    Create a buffer using the normal expected application size we&apos;ll
                     be getting.  This may change, depending on the peer&apos;s
                     SSL implementation.                    
                </comment>
                <declaration name="cio" type="ChannelIOSecure" line="181"/>
            </method>
            <method name="resizeRequestBB" type="void" line="196"/>
            <method name="resizeResponseBB" type="void" line="203">
                <declaration name="bb" type="ByteBuffer" line="204"/>
            </method>
            <method name="tryFlush" type="boolean" line="215">
                <params>
                    <param name="bb" type="ByteBuffer"/>
                </params>
            </method>
            <method name="doHandshake" type="boolean" line="226"/>
            <method name="doHandshake" type="boolean" line="247">
                <params>
                    <param name="sk" type="SelectionKey"/>
                </params>
                <comment line="256">
                    Flush out the outgoing buffer, if there&apos;s anything left in
                     it.                    
                </comment>
                <comment line="266">
                    See if we need to switch from write to read mode.                    
                </comment>
                <comment line="270">
                    Is this the last buffer?                    
                </comment>
                <comment line="275">
                    Fall-through to reregister need for a Read.                    
                </comment>
                <comment line="298">
                    expected room for unwrap                    
                </comment>
                <comment line="325">
                    Resize buffer if needed.                    
                </comment>
                <comment line="331">
                    Need to go reread the Channel for more data.                    
                </comment>
                <comment line="340">
                    Reset the application buffer size.                    
                </comment>
                <comment line="345">
                    CLOSED:                    
                </comment>
                <comment line="349">
                    &quot;needIO&quot; block.                    
                </comment>
                <comment line="351">
                    Just transitioned from read to write.                    
                </comment>
                <comment line="358">
                    Fall through and fill the write buffers.                    
                </comment>
                <comment line="361">
                    The flush above guarantees the out buffer to be empty                    
                </comment>
                <comment line="383">
                    BUFFER_OVERFLOW/BUFFER_UNDERFLOW/CLOSED:                    
                </comment>
                <comment line="389">
                    NOT_HANDSHAKING/NEED_TASK/FINISHED                    
                </comment>
                <comment line="392">
                    switch                    
                </comment>
                <declaration name="result" type="SSLEngineResult" line="249"/>
                <scope line="251"/>
                <scope line="259">
                    <scope line="261"/>
                    <scope line="277"/>
                </scope>
                <scope line="290"/>
                <scope line="296">
                    <scope line="326"/>
                    <scope line="333"/>
                </scope>
                <scope line="353"/>
                <scope line="372"/>
                <scope line="376"/>
            </method>
            <method name="doTasks" type="SSLEngineResult.HandshakeStatus" line="399">
                <comment line="404">
                    We could run this in a separate thread, but
                     do in the current for now.                    
                </comment>
                <declaration name="runnable" type="Runnable" line="401"/>
                <scope line="407"/>
            </method>
            <method name="read" type="int" line="422">
                <comment line="433">
                    probably throws exception                    
                </comment>
                <comment line="438">
                    expected room for unwrap                    
                </comment>
                <comment line="443">
                    Could check here for a renegotation, but we&apos;re only
                     doing a simple readwrite, and won&apos;t have enough state
                     transitions to do a complete handshake, so ignore that
                     possibility.                    
                </comment>
                <comment line="452">
                    Reset the application buffer size.                    
                </comment>
                <comment line="457">
                    Resize buffer if needed.                    
                </comment>
                <comment line="462">
                    break, next read will support larger buffer.                    
                </comment>
                <declaration name="result" type="SSLEngineResult" line="423"/>
                <scope line="425"/>
                <declaration name="pos" type="int" line="429"/>
                <scope line="431"/>
                <scope line="436">
                    <scope line="458"/>
                    <scope line="464"/>
                </scope>
            </method>
            <method name="write" type="int" line="482">
                <params>
                    <param name="src" type="ByteBuffer"/>
                </params>
                <scope line="484"/>
            </method>
            <method name="doWrite" type="int" line="499">
                <params>
                    <param name="src" type="ByteBuffer"/>
                </params>
                <comment line="507">
                    The data buffer is empty, we can reuse the entire buffer.                    
                </comment>
                <comment line="530">
                    Try to flush the data, regardless of whether or not
                     it&apos;s been selected.  Odds of a write buffer being full
                     is less than a read buffer being empty.                    
                </comment>
                <declaration name="retValue" type="int" line="500"/>
                <scope line="502"/>
                <declaration name="result" type="SSLEngineResult" line="511"/>
                <scope line="519"/>
                <scope line="534"/>
            </method>
            <method name="transferTo" type="long" line="553">
                <params>
                    <param name="fc" type="FileChannel"/>
                    <param name="pos" type="long"/>
                    <param name="len" type="long"/>
                </params>
                <comment line="569">
                    We ignore the return value here, we return the
                     number of bytes actually consumed from the the file.
                     We&apos;ll flush the output buffer before we start shutting down.                    
                </comment>
                <scope line="555"/>
                <scope line="559"/>
                <declaration name="fileRead" type="int" line="565"/>
            </method>
            <method name="dataFlush" type="boolean" line="583">
                <declaration name="fileFlushed" type="boolean" line="584"/>
                <scope line="586"/>
                <scope line="589"/>
            </method>
            <method name="shutdown" type="boolean" line="604">
                <comment line="616">
                    By RFC 2616, we can &quot;fire and forget&quot; our close_notify
                     message, so that&apos;s what we&apos;ll do here.                    
                </comment>
                <comment line="627">
                    We won&apos;t wait for a select here, but if this doesn&apos;t work,
                     we&apos;ll cycle back through on the next select.                    
                </comment>
                <scope line="606"/>
                <scope line="611"/>
                <declaration name="result" type="SSLEngineResult" line="620"/>
                <scope line="621"/>
                <scope line="630"/>
            </method>
        </class>
    </source>