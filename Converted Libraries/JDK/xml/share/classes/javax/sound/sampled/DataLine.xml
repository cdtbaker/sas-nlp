<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.sound.sampled">
        <interface name="DataLine">
            <implements interface="Line"/>
            <javadoc line="2">
                &lt;code&gt;DataLine&lt;/code&gt; adds media-related functionality to its
                  superinterface, &lt;code&gt;{@link Line}&lt;/code&gt;.  This functionality includes
                  transport-control methods that start, stop, drain, and flush
                  the audio data that passes through the line.  A data line can also
                  report the current position, volume, and audio format of the media.
                  Data lines are used for output of audio by means of the
                  subinterfaces &lt;code&gt;{@link SourceDataLine}&lt;/code&gt; or
                  &lt;code&gt;{@link Clip}&lt;/code&gt;, which allow an application program to write data.  Similarly,
                  audio input is handled by the subinterface &lt;code&gt;{@link TargetDataLine}&lt;/code&gt;,
                  which allows data to be read.
                  &lt;p&gt;
                  A data line has an internal buffer in which
                  the incoming or outgoing audio data is queued.  The
                  &lt;code&gt;{@link #drain()}&lt;/code&gt; method blocks until this internal buffer
                  becomes empty, usually because all queued data has been processed.  The
                  &lt;code&gt;{@link #flush()}&lt;/code&gt; method discards any available queued data
                  from the internal buffer.
                  &lt;p&gt;
                  A data line produces &lt;code&gt;{@link LineEvent.Type#START START}&lt;/code&gt; and
                  &lt;code&gt;{@link LineEvent.Type#STOP STOP}&lt;/code&gt; events whenever
                  it begins or ceases active presentation or capture of data.  These events
                  can be generated in response to specific requests, or as a result of
                  less direct state changes.  For example, if &lt;code&gt;{@link #start()}&lt;/code&gt; is called
                  on an inactive data line, and data is available for capture or playback, a
                  &lt;code&gt;START&lt;/code&gt; event will be generated shortly, when data playback
                  or capture actually begins.  Or, if the flow of data to an active data
                  line is constricted so that a gap occurs in the presentation of data,
                  a &lt;code&gt;STOP&lt;/code&gt; event is generated.
                  &lt;p&gt;
                  Mixers often support synchronized control of multiple data lines.
                  Synchronization can be established through the Mixer interface&apos;s
                  &lt;code&gt;{@link Mixer#synchronize synchronize}&lt;/code&gt; method.
                  See the description of the &lt;code&gt;{@link Mixer Mixer}&lt;/code&gt; interface
                  for a more complete description.                
                <author>
                    Kara Kytle                    
                </author>
                <see>
                    LineEvent                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="drain" type="void" line="42"/>
            <javadoc line="42">
                Drains queued data from the line by continuing data I/O until the
                  data line&apos;s internal buffer has been emptied.
                  This method blocks until the draining is complete.  Because this is a
                  blocking method, it should be used with care.  If &lt;code&gt;drain()&lt;/code&gt;
                  is invoked on a stopped line that has data in its queue, the method will
                  block until the line is running and the data queue becomes empty.  If
                  &lt;code&gt;drain()&lt;/code&gt; is invoked by one thread, and another continues to
                  fill the data queue, the operation will not complete.
                  This method always returns when the data line is closed.                
                <see>
                    #flush()                    
                </see>
            </javadoc>
            <method name="flush" type="void" line="55"/>
            <javadoc line="55">
                Flushes queued data from the line.  The flushed data is discarded.
                  In some cases, not all queued data can be discarded.  For example, a
                  mixer can flush data from the buffer for a specific input line, but any
                  unplayed data already in the output buffer (the result of the mix) will
                  still be played.  You can invoke this method after pausing a line (the
                  normal case) if you want to skip the &quot;stale&quot; data when you restart
                  playback or capture. (It is legal to flush a line that is not stopped,
                  but doing so on an active line is likely to cause a discontinuity in the
                  data, resulting in a perceptible click.)                
                <see>
                    #stop()                    
                </see>
                <see>
                    #drain()                    
                </see>
            </javadoc>
            <method name="start" type="void" line="69"/>
            <javadoc line="69">
                Allows a line to engage in data I/O.  If invoked on a line
                  that is already running, this method does nothing.  Unless the data in
                  the buffer has been flushed, the line resumes I/O starting
                  with the first frame that was unprocessed at the time the line was
                  stopped. When audio capture or playback starts, a
                  &lt;code&gt;{@link LineEvent.Type#START START}&lt;/code&gt; event is generated.                
                <see>
                    #stop()                    
                </see>
                <see>
                    #isRunning()                    
                </see>
                <see>
                    LineEvent                    
                </see>
            </javadoc>
            <method name="stop" type="void" line="81"/>
            <javadoc line="81">
                Stops the line.  A stopped line should cease I/O activity.
                  If the line is open and running, however, it should retain the resources required
                  to resume activity.  A stopped line should retain any audio data in its buffer
                  instead of discarding it, so that upon resumption the I/O can continue where it left off,
                  if possible.  (This doesn&apos;t guarantee that there will never be discontinuities beyond the
                  current buffer, of course; if the stopped condition continues
                  for too long, input or output samples might be dropped.)  If desired, the retained data can be
                  discarded by invoking the &lt;code&gt;flush&lt;/code&gt; method.
                  When audio capture or playback stops, a &lt;code&gt;{@link LineEvent.Type#STOP STOP}&lt;/code&gt; event is generated.                
                <see>
                    #start()                    
                </see>
                <see>
                    #isRunning()                    
                </see>
                <see>
                    #flush()                    
                </see>
                <see>
                    LineEvent                    
                </see>
            </javadoc>
            <method name="isRunning" type="boolean" line="97"/>
            <javadoc line="97">
                Indicates whether the line is running.  The default is &lt;code&gt;false&lt;/code&gt;.
                  An open line begins running when the first data is presented in response to an
                  invocation of the &lt;code&gt;start&lt;/code&gt; method, and continues
                  until presentation ceases in response to a call to &lt;code&gt;stop&lt;/code&gt; or
                  because playback completes.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the line is running, otherwise &lt;code&gt;false&lt;/code&gt;                    
                </return>
                <see>
                    #start()                    
                </see>
                <see>
                    #stop()                    
                </see>
            </javadoc>
            <method name="isActive" type="boolean" line="108"/>
            <javadoc line="108">
                Indicates whether the line is engaging in active I/O (such as playback
                  or capture).  When an inactive line becomes active, it sends a
                  &lt;code&gt;{@link LineEvent.Type#START START}&lt;/code&gt; event to its listeners.  Similarly, when
                  an active line becomes inactive, it sends a
                  &lt;code&gt;{@link LineEvent.Type#STOP STOP}&lt;/code&gt; event.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the line is actively capturing or rendering
                      sound, otherwise &lt;code&gt;false&lt;/code&gt;                    
                </return>
                <see>
                    #isOpen                    
                </see>
                <see>
                    #addLineListener                    
                </see>
                <see>
                    #removeLineListener                    
                </see>
                <see>
                    LineEvent                    
                </see>
                <see>
                    LineListener                    
                </see>
            </javadoc>
            <method name="getFormat" type="AudioFormat" line="123"/>
            <javadoc line="123">
                Obtains the current format (encoding, sample rate, number of channels,
                  etc.) of the data line&apos;s audio data.
                  &lt;p&gt;If the line is not open and has never been opened, it returns
                  the default format. The default format is an implementation
                  specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt;
                  object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;,
                  specifies at least one fully qualified audio format, the
                  last one will be used as the default format. Opening the
                  line with a specific audio format (e.g.{@link SourceDataLine#open(AudioFormat)}) will override the
                  default format.                
                <return>
                    current audio data format                    
                </return>
                <see>
                    AudioFormat                    
                </see>
            </javadoc>
            <method name="getBufferSize" type="int" line="138"/>
            <javadoc line="138">
                Obtains the maximum number of bytes of data that will fit in the data line&apos;s
                  internal buffer.  For a source data line, this is the size of the buffer to
                  which data can be written.  For a target data line, it is the size of
                  the buffer from which data can be read.  Note that
                  the units used are bytes, but will always correspond to an integral
                  number of sample frames of audio data.                
                <return>
                    the size of the buffer in bytes                    
                </return>
            </javadoc>
            <method name="available" type="int" line="148"/>
            <javadoc line="148">
                Obtains the number of bytes of data currently available to the
                  application for processing in the data line&apos;s internal buffer.  For a
                  source data line, this is the amount of data that can be written to the
                  buffer without blocking.  For a target data line, this is the amount of data
                  available to be read by the application.  For a clip, this value is always
                  0 because the audio data is loaded into the buffer when the clip is opened,
                  and persists without modification until the clip is closed.
                  &lt;p&gt;
                  Note that the units used are bytes, but will always
                  correspond to an integral number of sample frames of audio data.
                  &lt;p&gt;
                  An application is guaranteed that a read or
                  write operation of up to the number of bytes returned from
                  &lt;code&gt;available()&lt;/code&gt; will not block; however, there is no guarantee
                  that attempts to read or write more data will block.                
                <return>
                    the amount of data available, in bytes                    
                </return>
            </javadoc>
            <method name="getFramePosition" type="int" line="167"/>
            <javadoc line="167">
                Obtains the current position in the audio data, in sample frames.
                  The frame position measures the number of sample
                  frames captured by, or rendered from, the line since it was opened.
                  This return value will wrap around after 2^31 frames. It is recommended
                  to use &lt;code&gt;getLongFramePosition&lt;/code&gt; instead.                
                <return>
                    the number of frames already processed since the line was opened                    
                </return>
                <see>
                    #getLongFramePosition()                    
                </see>
            </javadoc>
            <method name="getLongFramePosition" type="long" line="177"/>
            <javadoc line="177">
                Obtains the current position in the audio data, in sample frames.
                  The frame position measures the number of sample
                  frames captured by, or rendered from, the line since it was opened.                
                <return>
                    the number of frames already processed since the line was opened                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getMicrosecondPosition" type="long" line="185"/>
            <javadoc line="185">
                Obtains the current position in the audio data, in microseconds.
                  The microsecond position measures the time corresponding to the number
                  of sample frames captured by, or rendered from, the line since it was opened.
                  The level of precision is not guaranteed.  For example, an implementation
                  might calculate the microsecond position from the current frame position
                  and the audio sample frame rate.  The precision in microseconds would
                  then be limited to the number of microseconds per sample frame.                
                <return>
                    the number of microseconds of data processed since the line was opened                    
                </return>
            </javadoc>
            <method name="getLevel" type="float" line="196"/>
            <javadoc line="196">
                Obtains the current volume level for the line.  This level is a measure
                  of the signal&apos;s current amplitude, and should not be confused with the
                  current setting of a gain control. The range is from 0.0 (silence) to
                  1.0 (maximum possible amplitude for the sound waveform).  The units
                  measure linear amplitude, not decibels.                
                <return>
                    the current amplitude of the signal in this line, or
                      &lt;code&gt;{@link AudioSystem#NOT_SPECIFIED}&lt;/code&gt;                    
                </return>
            </javadoc>
            <class name="Info" line="206">
                <extends class="Line.Info"/>
                <javadoc line="206">
                    Besides the class information inherited from its superclass,
                      &lt;code&gt;DataLine.Info&lt;/code&gt; provides additional information specific to data lines.
                      This information includes:
                      &lt;ul&gt;
                      &lt;li&gt; the audio formats supported by the data line
                      &lt;li&gt; the minimum and maximum sizes of its internal buffer
                      &lt;/ul&gt;
                      Because a &lt;code&gt;Line.Info&lt;/code&gt; knows the class of the line its describes, a
                      &lt;code&gt;DataLine.Info&lt;/code&gt; object can describe &lt;code&gt;DataLine&lt;/code&gt;
                      subinterfaces such as &lt;code&gt;{@link SourceDataLine}&lt;/code&gt;,
                      &lt;code&gt;{@link TargetDataLine}&lt;/code&gt;, and &lt;code&gt;{@link Clip}&lt;/code&gt;.
                      You can query a mixer for lines of any of these types, passing an appropriate
                      instance of &lt;code&gt;DataLine.Info&lt;/code&gt; as the argument to a method such as
                      &lt;code&gt;{@link Mixer#getLine Mixer.getLine(Line.Info)}&lt;/code&gt;.                    
                    <see>
                        Line.Info                        
                    </see>
                    <author>
                        Kara Kytle                        
                    </author>
                    <since>
                        1.3                        
                    </since>
                </javadoc>
                <declaration name="formats" type="AudioFormat[]" line="226"/>
                <declaration name="minBufferSize" type="int" line="227"/>
                <declaration name="maxBufferSize" type="int" line="228"/>
                <javadoc line="229">
                    Constructs a data line&apos;s info object from the specified information,
                      which includes a set of supported audio formats and a range for the buffer size.
                      This constructor is typically used by mixer implementations
                      when returning information about a supported line.                    
                    <param>
                        lineClass the class of the data line described by the info object                        
                    </param>
                    <param>
                        formats set of formats supported                        
                    </param>
                    <param>
                        minBufferSize minimum buffer size supported by the data line, in bytes                        
                    </param>
                    <param>
                        maxBufferSize maximum buffer size supported by the data line, in bytes                        
                    </param>
                </javadoc>
                <method name="Info" type="constructor" line="239">
                    <params>
                        <param name="lineClass" type="Class&lt;?&gt;"/>
                        <param name="formats" type="AudioFormat[]"/>
                        <param name="minBufferSize" type="int"/>
                        <param name="maxBufferSize" type="int"/>
                    </params>
                    <scope line="241"/>
                    <scope line="244"/>
                </method>
                <javadoc line="250">
                    Constructs a data line&apos;s info object from the specified information,
                      which includes a single audio format and a desired buffer size.
                      This constructor is typically used by an application to
                      describe a desired line.                    
                    <param>
                        lineClass the class of the data line described by the info object                        
                    </param>
                    <param>
                        format desired format                        
                    </param>
                    <param>
                        bufferSize desired buffer size in bytes                        
                    </param>
                </javadoc>
                <method name="Info" type="constructor" line="259">
                    <params>
                        <param name="lineClass" type="Class&lt;?&gt;"/>
                        <param name="format" type="AudioFormat"/>
                        <param name="bufferSize" type="int"/>
                    </params>
                    <scope line="261"/>
                    <scope line="264">
                        <declaration name="formats" type="AudioFormat[]" line="265"/>
                    </scope>
                </method>
                <javadoc line="271">
                    Constructs a data line&apos;s info object from the specified information,
                      which includes a single audio format.
                      This constructor is typically used by an application to
                      describe a desired line.                    
                    <param>
                        lineClass the class of the data line described by the info object                        
                    </param>
                    <param>
                        format desired format                        
                    </param>
                </javadoc>
                <method name="Info" type="constructor" line="279">
                    <params>
                        <param name="lineClass" type="Class&lt;?&gt;"/>
                        <param name="format" type="AudioFormat"/>
                    </params>
                </method>
                <javadoc line="282">
                    Obtains a set of audio formats supported by the data line.
                      Note that &lt;code&gt;isFormatSupported(AudioFormat)&lt;/code&gt; might return
                      &lt;code&gt;true&lt;/code&gt; for certain additional formats that are missing from
                      the set returned by &lt;code&gt;getFormats()&lt;/code&gt;.  The reverse is not
                      the case: &lt;code&gt;isFormatSupported(AudioFormat)&lt;/code&gt; is guaranteed to return
                      &lt;code&gt;true&lt;/code&gt; for all formats returned by &lt;code&gt;getFormats()&lt;/code&gt;.
                      Some fields in the AudioFormat instances can be set to{@link javax.sound.sampled.AudioSystem#NOT_SPECIFIED NOT_SPECIFIED}if that field does not apply to the format,
                      or if the format supports a wide range of values for that field.
                      For example, a multi-channel device supporting up to
                      64 channels, could set the channel field in the
                      &lt;code&gt;AudioFormat&lt;/code&gt; instances returned by this
                      method to &lt;code&gt;NOT_SPECIFIED&lt;/code&gt;.                    
                    <return>
                        a set of supported audio formats.                        
                    </return>
                    <see>
                        #isFormatSupported(AudioFormat)                        
                    </see>
                </javadoc>
                <method name="getFormats" type="AudioFormat[]" line="298">
                    <declaration name="returnedArray" type="AudioFormat[]" line="299"/>
                </method>
                <javadoc line="303">
                    Indicates whether this data line supports a particular audio format.
                      The default implementation of this method simply returns &lt;code&gt;true&lt;/code&gt; if
                      the specified format matches any of the supported formats.                    
                    <param>
                        format the audio format for which support is queried.                        
                    </param>
                    <return>
                        &lt;code&gt;true&lt;/code&gt; if the format is supported, otherwise &lt;code&gt;false&lt;/code&gt;                        
                    </return>
                    <see>
                        #getFormats                        
                    </see>
                    <see>
                        AudioFormat#matches                        
                    </see>
                </javadoc>
                <method name="isFormatSupported" type="boolean" line="312">
                    <params>
                        <param name="format" type="AudioFormat"/>
                    </params>
                    <scope line="313">
                        <scope line="314"/>
                    </scope>
                </method>
                <javadoc line="320">
                    Obtains the minimum buffer size supported by the data line.                    
                    <return>
                        minimum buffer size in bytes, or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;                        
                    </return>
                </javadoc>
                <method name="getMinBufferSize" type="int" line="324"/>
                <javadoc line="327">
                    Obtains the maximum buffer size supported by the data line.                    
                    <return>
                        maximum buffer size in bytes, or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;                        
                    </return>
                </javadoc>
                <method name="getMaxBufferSize" type="int" line="331"/>
                <javadoc line="334">
                    Determines whether the specified info object matches this one.
                      To match, the superclass match requirements must be met.  In
                      addition, this object&apos;s minimum buffer size must be at least as
                      large as that of the object specified, its maximum buffer size must
                      be at most as large as that of the object specified, and all of its
                      formats must match formats supported by the object specified.                    
                    <return>
                        &lt;code&gt;true&lt;/code&gt; if this object matches the one specified,
                          otherwise &lt;code&gt;false&lt;/code&gt;.                        
                    </return>
                </javadoc>
                <method name="matches" type="boolean" line="344">
                    <params>
                        <param name="info" type="Line.Info"/>
                    </params>
                    <scope line="345"/>
                    <declaration name="dataLineInfo" type="Info" line="348"/>
                    <scope line="349">
                        <scope line="350"/>
                    </scope>
                    <scope line="354">
                        <scope line="355"/>
                    </scope>
                    <declaration name="localFormats" type="AudioFormat[]" line="359"/>
                    <scope line="360">
                        <scope line="361">
                            <scope line="362">
                                <scope line="363"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="371">
                    Obtains a textual description of the data line info.                    
                    <return>
                        a string description                        
                    </return>
                </javadoc>
                <method name="toString" type="String" line="375">
                    <declaration name="buf" type="StringBuffer" line="376"/>
                    <scope line="377"/>
                    <scope line="380"/>
                    <scope line="383"/>
                    <scope line="386"/>
                    <scope line="389"/>
                </method>
            </class>
        </interface>
    </source>