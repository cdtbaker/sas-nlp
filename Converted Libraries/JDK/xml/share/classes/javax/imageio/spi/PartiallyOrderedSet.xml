<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.imageio.spi">
        <import package="java.util.AbstractSet"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <class name="PartiallyOrderedSet" line="35">
            <extends class="AbstractSet"/>
            <comment line="57">
                The topological sort (roughly) follows the algorithm described in                
            </comment>
            <comment line="58">
                Horowitz and Sahni, _Fundamentals of Data Structures_ (1976),                
            </comment>
            <comment line="59">
                p. 315.                
            </comment>
            <comment line="61">
                Maps Objects to DigraphNodes that contain them                
            </comment>
            <comment line="64">
                The set of Objects                
            </comment>
            <comment line="173">
                DigraphNode -&gt; Integer                
            </comment>
            <javadoc line="35">
                A set of &lt;code&gt;Object&lt;/code&gt;s with pairwise orderings between them.
                  The &lt;code&gt;iterator&lt;/code&gt; method provides the elements in
                  topologically sorted order.  Elements participating in a cycle
                  are not returned.
                  Unlike the &lt;code&gt;SortedSet&lt;/code&gt; and &lt;code&gt;SortedMap&lt;/code&gt;
                  interfaces, which require their elements to implement the
                  &lt;code&gt;Comparable&lt;/code&gt; interface, this class receives ordering
                  information via its &lt;code&gt;setOrdering&lt;/code&gt; and
                  &lt;code&gt;unsetPreference&lt;/code&gt; methods.  This difference is due to
                  the fact that the relevant ordering between elements is unlikely to
                  be inherent in the elements themselves; rather, it is set
                  dynamically accoring to application policy.  For example, in a
                  service provider registry situation, an application might allow the
                  user to set a preference order for service provider objects
                  supplied by a trusted vendor over those supplied by another.                
            </javadoc>
            <declaration name="poNodes" type="Map" line="61"/>
            <declaration name="nodes" type="Set" line="64"/>
            <javadoc line="66">
                Constructs a &lt;code&gt;PartiallyOrderedSet&lt;/code&gt;.                
            </javadoc>
            <method name="PartiallyOrderedSet" type="constructor" line="69"/>
            <method name="size" type="int" line="71"/>
            <method name="contains" type="boolean" line="75">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
            <javadoc line="79">
                Returns an iterator over the elements contained in this
                  collection, with an ordering that respects the orderings set
                  by the &lt;code&gt;setOrdering&lt;/code&gt; method.                
            </javadoc>
            <method name="iterator" type="Iterator" line="84"/>
            <javadoc line="88">
                Adds an &lt;code&gt;Object&lt;/code&gt; to this
                  &lt;code&gt;PartiallyOrderedSet&lt;/code&gt;.                
            </javadoc>
            <method name="add" type="boolean" line="92">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="93"/>
                <declaration name="node" type="DigraphNode" line="97"/>
            </method>
            <javadoc line="102">
                Removes an &lt;code&gt;Object&lt;/code&gt; from this
                  &lt;code&gt;PartiallyOrderedSet&lt;/code&gt;.                
            </javadoc>
            <method name="remove" type="boolean" line="106">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="node" type="DigraphNode" line="107"/>
                <scope line="108"/>
            </method>
            <method name="clear" type="void" line="117"/>
            <javadoc line="121">
                Sets an ordering between two nodes.  When an iterator is
                  requested, the first node will appear earlier in the
                  sequence than the second node.  If a prior ordering existed
                  between the nodes in the opposite order, it is removed.                
                <return>
                    <code>true</code> if no prior ordering existed
                      between the nodes, <code>false</code>otherwise.                    
                </return>
            </javadoc>
            <method name="setOrdering" type="boolean" line="130">
                <params>
                    <param name="first" type="Object"/>
                    <param name="second" type="Object"/>
                </params>
                <declaration name="firstPONode" type="DigraphNode" line="131"/>
                <declaration name="secondPONode" type="DigraphNode" line="133"/>
            </method>
            <javadoc line="140">
                Removes any ordering between two nodes.                
                <return>
                    true if a prior prefence existed between the nodes.                    
                </return>
            </javadoc>
            <method name="unsetOrdering" type="boolean" line="145">
                <params>
                    <param name="first" type="Object"/>
                    <param name="second" type="Object"/>
                </params>
                <declaration name="firstPONode" type="DigraphNode" line="146"/>
                <declaration name="secondPONode" type="DigraphNode" line="148"/>
            </method>
            <javadoc line="155">
                Returns &lt;code&gt;true&lt;/code&gt; if an ordering exists between two
                  nodes.                
            </javadoc>
            <method name="hasOrdering" type="boolean" line="159">
                <params>
                    <param name="preferred" type="Object"/>
                    <param name="other" type="Object"/>
                </params>
                <declaration name="preferredPONode" type="DigraphNode" line="160"/>
                <declaration name="otherPONode" type="DigraphNode" line="162"/>
            </method>
        </class>
        <class name="PartialOrderIterator" line="169">
            <comment line="57">
                The topological sort (roughly) follows the algorithm described in                
            </comment>
            <comment line="58">
                Horowitz and Sahni, _Fundamentals of Data Structures_ (1976),                
            </comment>
            <comment line="59">
                p. 315.                
            </comment>
            <comment line="61">
                Maps Objects to DigraphNodes that contain them                
            </comment>
            <comment line="64">
                The set of Objects                
            </comment>
            <comment line="173">
                DigraphNode -&gt; Integer                
            </comment>
            <implements interface="Iterator"/>
            <declaration name="zeroList" type="LinkedList" line="171"/>
            <declaration name="inDegrees" type="Map" line="172"/>
            <method name="PartialOrderIterator" type="constructor" line="174">
                <params>
                    <param name="iter" type="Iterator"/>
                </params>
                <comment line="175">
                    Initialize scratch in-degree values, zero list                    
                </comment>
                <comment line="181">
                    Add nodes with zero in-degree to the zero list                    
                </comment>
                <scope line="176">
                    <declaration name="node" type="DigraphNode" line="177"/>
                    <declaration name="inDegree" type="int" line="178"/>
                    <scope line="182"/>
                </scope>
            </method>
            <method name="hasNext" type="boolean" line="188"/>
            <method name="next" type="Object" line="192">
                <comment line="195">
                    For each out node of the output node, decrement its in-degree                    
                </comment>
                <comment line="202">
                    If the in-degree has fallen to 0, place the node on the list                    
                </comment>
                <declaration name="first" type="DigraphNode" line="193"/>
                <declaration name="outNodes" type="Iterator" line="196"/>
                <scope line="197">
                    <declaration name="node" type="DigraphNode" line="198"/>
                    <declaration name="inDegree" type="int" line="199"/>
                    <scope line="203"/>
                </scope>
            </method>
            <method name="remove" type="void" line="211"/>
        </class>
    </source>