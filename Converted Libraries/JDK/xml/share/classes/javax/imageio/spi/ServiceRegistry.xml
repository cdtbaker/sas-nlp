<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.imageio.spi">
        <import package="java.io.File"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.Set"/>
        <import package="java.util.ServiceLoader"/>
        <class name="ServiceRegistry" line="11">
            <javadoc line="11">
                A registry for service provider instances.
                  &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known set of interfaces and (usually
                  abstract) classes.  A &lt;i&gt;service provider&lt;/i&gt; is a specific
                  implementation of a service.  The classes in a provider typically
                  implement the interface or subclass the class defined by the
                  service itself.
                  &lt;p&gt; Service providers are stored in one or more &lt;i&gt;categories&lt;/i&gt;,
                  each of which is defined by a class of interface (described by a
                  &lt;code&gt;Class&lt;/code&gt; object) that all of its members must implement.
                  The set of categories may be changed dynamically.
                  &lt;p&gt; Only a single instance of a given leaf class (that is, the
                  actual class returned by &lt;code&gt;getClass()&lt;/code&gt;, as opposed to any
                  inherited classes or interfaces) may be registered.  That is,
                  suppose that the
                  &lt;code&gt;com.mycompany.mypkg.GreenServiceProvider&lt;/code&gt; class
                  implements the &lt;code&gt;com.mycompany.mypkg.MyService&lt;/code&gt;
                  interface.  If a &lt;code&gt;GreenServiceProvider&lt;/code&gt; instance is
                  registered, it will be stored in the category defined by the
                  &lt;code&gt;MyService&lt;/code&gt; class.  If a new instance of
                  &lt;code&gt;GreenServiceProvider&lt;/code&gt; is registered, it will replace
                  the previous instance.  In practice, service provider objects are
                  usually singletons so this behavior is appropriate.
                  &lt;p&gt; To declare a service provider, a &lt;code&gt;services&lt;/code&gt;
                  subdirectory is placed within the &lt;code&gt;META-INF&lt;/code&gt; directory
                  that is present in every JAR file.  This directory contains a file
                  for each service provider interface that has one or more
                  implementation classes present in the JAR file.  For example, if
                  the JAR file contained a class named
                  &lt;code&gt;com.mycompany.mypkg.MyServiceImpl&lt;/code&gt; which implements the
                  &lt;code&gt;javax.someapi.SomeService&lt;/code&gt; interface, the JAR file
                  would contain a file named: &lt;pre&gt;
                  META-INF/services/javax.someapi.SomeService &lt;/pre&gt;
                  containing the line:
                  &lt;pre&gt;
                  com.mycompany.mypkg.MyService
                  &lt;/pre&gt;
                  &lt;p&gt; The service provider classes should be to be lightweight and
                  quick to load.  Implementations of these interfaces should avoid
                  complex dependencies on other classes and on native code. The usual
                  pattern for more complex services is to register a lightweight
                  proxy for the heavyweight service.
                  &lt;p&gt; An application may customize the contents of a registry as it
                  sees fit, so long as it has the appropriate runtime permission.
                  &lt;p&gt; For more details on declaring service providers, and the JAR
                  format in general, see the &lt;a
                  href=&quot;../../../../technotes/guides/jar/jar.html&quot;&gt;
                  JAR File Specification&lt;/a&gt;.                
                <see>
                    RegisterableService                    
                </see>
            </javadoc>
            <declaration name="categoryMap" type="Map" line="62"/>
            <javadoc line="63">
                Constructs a &lt;code&gt;ServiceRegistry&lt;/code&gt; instance with a
                  set of categories taken from the &lt;code&gt;categories&lt;/code&gt;
                  argument.                
                <param>
                    categories an <code>Iterator</code> containing
                      <code>Class</code> objects to be used to define categories.                    
                </param>
                <exception>
                    IllegalArgumentException if
                      <code>categories</code> is <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="ServiceRegistry" type="constructor" line="72">
                <params>
                    <param name="categories" type="Iterator<Class<?>>"/>
                </params>
                <scope line="73"/>
                <scope line="76">
                    <declaration name="category" type="Class" line="77"/>
                    <declaration name="reg" type="SubRegistry" line="78"/>
                </scope>
            </method>
            <javadoc line="82">
                Searches for implementations of a particular service class
                  using the given class loader.
                  &lt;p&gt; This method transforms the name of the given service class
                  into a provider-configuration filename as described in the
                  class comment and then uses the &lt;code&gt;getResources&lt;/code&gt;
                  method of the given class loader to find all available files
                  with that name.  These files are then read and parsed to
                  produce a list of provider-class names.  The iterator that is
                  returned uses the given class loader to look up and then
                  instantiate each element of the list.
                  &lt;p&gt; Because it is possible for extensions to be installed into
                  a running Java virtual machine, this method may return
                  different results each time it is invoked.                
                <param>
                    providerClass a <code>Class</code>object indicating the
                      class or interface of the service providers being detected.                    
                </param>
                <param>
                    loader the class loader to be used to load
                      provider-configuration files and instantiate provider classes,
                      or <code>null</code> if the system class loader (or, failing that
                      the bootstrap class loader) is to be used.                    
                </param>
                <return>
                    An <code>Iterator</code> that yields provider objects
                      for the given service, in some arbitrary order.  The iterator
                      will throw an <code>Error</code> if a provider-configuration
                      file violates the specified format or if a provider class
                      cannot be found and instantiated.                    
                </return>
                <exception>
                    IllegalArgumentException if
                      <code>providerClass</code> is <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="lookupProviders" type="Iterator<T>" line="110">
                <params>
                    <param name="providerClass" type="Class<T>"/>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <scope line="111"/>
            </method>
            <javadoc line="116">
                Locates and incrementally instantiates the available providers
                  of a given service using the context class loader.  This
                  convenience method is equivalent to:
                  &lt;pre&gt;
                  ClassLoader cl = Thread.currentThread().getContextClassLoader();
                  return Service.providers(service, cl);
                  &lt;/pre&gt;                
                <param>
                    providerClass a <code>Class</code>object indicating the
                      class or interface of the service providers being detected.                    
                </param>
                <return>
                    An <code>Iterator</code> that yields provider objects
                      for the given service, in some arbitrary order.  The iterator
                      will throw an <code>Error</code> if a provider-configuration
                      file violates the specified format or if a provider class
                      cannot be found and instantiated.                    
                </return>
                <exception>
                    IllegalArgumentException if
                      <code>providerClass</code> is <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="lookupProviders" type="Iterator<T>" line="134">
                <params>
                    <param name="providerClass" type="Class<T>"/>
                </params>
                <scope line="135"/>
            </method>
            <javadoc line="140">
                Returns an &lt;code&gt;Iterator&lt;/code&gt; of &lt;code&gt;Class&lt;/code&gt; objects
                  indicating the current set of categories.  The iterator will be
                  empty if no categories exist.                
                <return>
                    an <code>Iterator</code> containing
                      <code>Class</code>objects.                    
                </return>
            </javadoc>
            <method name="getCategories" type="Iterator<Class<?>>" line="147">
                <declaration name="keySet" type="Set" line="148"/>
            </method>
            <javadoc line="151">
                Returns an Iterator containing the subregistries to which the
                  provider belongs.                
            </javadoc>
            <method name="getSubRegistries" type="Iterator" line="155">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <declaration name="l" type="List" line="156"/>
                <declaration name="iter" type="Iterator" line="157"/>
                <scope line="158">
                    <declaration name="c" type="Class" line="159"/>
                    <scope line="160"/>
                </scope>
            </method>
            <javadoc line="166">
                Adds a service provider object to the registry.  The provider
                  is associated with the given category.
                  &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
                  &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
                  &lt;code&gt;onRegistration&lt;/code&gt; method will be called.  Its
                  &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
                  it is deregistered from a category, for example if a
                  category is removed or the registry is garbage collected.                
                <param>
                    provider the service provide object to be registered.                    
                </param>
                <param>
                    category the category under which to register the
                      provider.                    
                </param>
                <return>
                    true if no provider of the same class was previously
                      registered in the same category category.                    
                </return>
                <exception>
                    IllegalArgumentException if <code>provider</code> is
                      <code>null</code>.                    
                </exception>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
                <exception>
                    ClassCastException if provider does not implement
                      the <code>Class</code> defined by <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="registerServiceProvider" type="boolean" line="187">
                <params>
                    <param name="provider" type="T"/>
                    <param name="category" type="Class<T>"/>
                </params>
                <scope line="188"/>
                <declaration name="reg" type="SubRegistry" line="191"/>
                <scope line="192"/>
                <scope line="195"/>
            </method>
            <javadoc line="200">
                Adds a service provider object to the registry.  The provider
                  is associated within each category present in the registry
                  whose &lt;code&gt;Class&lt;/code&gt; it implements.
                  &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
                  &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
                  &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each
                  category it is registered under.  Its
                  &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
                  it is deregistered from a category or when the registry is
                  finalized.                
                <param>
                    provider the service provider object to be registered.                    
                </param>
                <exception>
                    IllegalArgumentException if
                      <code>provider</code> is <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="registerServiceProvider" type="void" line="215">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <scope line="216"/>
                <declaration name="regs" type="Iterator" line="219"/>
                <scope line="220">
                    <declaration name="reg" type="SubRegistry" line="221"/>
                </scope>
            </method>
            <javadoc line="225">
                Adds a set of service provider objects, taken from an
                  &lt;code&gt;Iterator&lt;/code&gt; to the registry.  Each provider is
                  associated within each category present in the registry whose
                  &lt;code&gt;Class&lt;/code&gt; it implements.
                  &lt;p&gt; For each entry of &lt;code&gt;providers&lt;/code&gt; that implements
                  the &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
                  &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each
                  category it is registered under.  Its
                  &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time
                  it is deregistered from a category or when the registry is
                  finalized.                
                <param>
                    providers an Iterator containing service provider
                      objects to be registered.                    
                </param>
                <exception>
                    IllegalArgumentException if <code>providers</code>
                      is <code>null</code> or contains a <code>null</code> entry.                    
                </exception>
            </javadoc>
            <method name="registerServiceProviders" type="void" line="242">
                <params>
                    <param name="providers" type="Iterator<?>"/>
                </params>
                <scope line="243"/>
                <scope line="246"/>
            </method>
            <javadoc line="250">
                Removes a service provider object from the given category.  If
                  the provider was not previously registered, nothing happens and
                  &lt;code&gt;false&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;true&lt;/code&gt;
                  is returned.  If an object of the same class as
                  &lt;code&gt;provider&lt;/code&gt; but not equal (using &lt;code&gt;==&lt;/code&gt;) to
                  &lt;code&gt;provider&lt;/code&gt; is registered, it will not be
                  deregistered.
                  &lt;p&gt; If &lt;code&gt;provider&lt;/code&gt; implements the
                  &lt;code&gt;RegisterableService&lt;/code&gt; interface, its
                  &lt;code&gt;onDeregistration&lt;/code&gt; method will be called.                
                <param>
                    provider the service provider object to be deregistered.                    
                </param>
                <param>
                    category the category from which to deregister the
                      provider.                    
                </param>
                <return>
                    <code>true</code> if the provider was previously
                      registered in the same category category,
                      <code>false</code> otherwise.                    
                </return>
                <exception>
                    IllegalArgumentException if <code>provider</code> is
                      <code>null</code>.                    
                </exception>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
                <exception>
                    ClassCastException if provider does not implement
                      the class defined by <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="deregisterServiceProvider" type="boolean" line="274">
                <params>
                    <param name="provider" type="T"/>
                    <param name="category" type="Class<T>"/>
                </params>
                <scope line="275"/>
                <declaration name="reg" type="SubRegistry" line="278"/>
                <scope line="279"/>
                <scope line="282"/>
            </method>
            <javadoc line="287">
                Removes a service provider object from all categories that
                  contain it.                
                <param>
                    provider the service provider object to be deregistered.                    
                </param>
                <exception>
                    IllegalArgumentException if <code>provider</code> is
                      <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="deregisterServiceProvider" type="void" line="294">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <scope line="295"/>
                <declaration name="regs" type="Iterator" line="298"/>
                <scope line="299">
                    <declaration name="reg" type="SubRegistry" line="300"/>
                </scope>
            </method>
            <javadoc line="304">
                Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;provider&lt;/code&gt; is currently
                  registered.                
                <param>
                    provider the service provider object to be queried.                    
                </param>
                <return>
                    <code>true</code> if the given provider has been
                      registered.                    
                </return>
                <exception>
                    IllegalArgumentException if <code>provider</code> is
                      <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="contains" type="boolean" line="313">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <scope line="314"/>
                <declaration name="regs" type="Iterator" line="317"/>
                <scope line="318">
                    <declaration name="reg" type="SubRegistry" line="319"/>
                    <scope line="320"/>
                </scope>
            </method>
            <javadoc line="326">
                Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all registered
                  service providers in the given category.  If
                  &lt;code&gt;useOrdering&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the iterator
                  will return all of the server provider objects in an arbitrary
                  order.  Otherwise, the ordering will respect any pairwise
                  orderings that have been set.  If the graph of pairwise
                  orderings contains cycles, any providers that belong to a cycle
                  will not be returned.                
                <param>
                    category the category to be retrieved from.                    
                </param>
                <param>
                    useOrdering <code>true</code> if pairwise orderings
                      should be taken account in ordering the returned objects.                    
                </param>
                <return>
                    an <code>Iterator</code> containing service provider
                      objects from the given category, possibly in order.                    
                </return>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="getServiceProviders" type="Iterator<T>" line="343">
                <params>
                    <param name="category" type="Class<T>"/>
                    <param name="useOrdering" type="boolean"/>
                </params>
                <declaration name="reg" type="SubRegistry" line="344"/>
                <scope line="345"/>
            </method>
            <interface name="Filter">
                <javadoc line="350">
                    A simple filter interface used by
                      &lt;code&gt;ServiceRegistry.getServiceProviders&lt;/code&gt; to select
                      providers matching an arbitrary criterion.  Classes that
                      implement this interface should be defined in order to make use
                      of the &lt;code&gt;getServiceProviders&lt;/code&gt; method of
                      &lt;code&gt;ServiceRegistry&lt;/code&gt; that takes a &lt;code&gt;Filter&lt;/code&gt;.                    
                    <see>
                        ServiceRegistry#getServiceProviders(Class,ServiceRegistry.Filter,boolean)                        
                    </see>
                </javadoc>
                <method name="filter" type="boolean" line="360"/>
                <javadoc line="360">
                    Returns &lt;code&gt;true&lt;/code&gt; if the given
                      &lt;code&gt;provider&lt;/code&gt; object matches the criterion defined
                      by this &lt;code&gt;Filter&lt;/code&gt;.                    
                    <param>
                        provider a service provider <code>Object</code>.                        
                    </param>
                    <return>
                        true if the provider matches the criterion.                        
                    </return>
                </javadoc>
            </interface>
            <javadoc line="369">
                Returns an &lt;code&gt;Iterator&lt;/code&gt; containing service provider
                  objects within a given category that satisfy a criterion
                  imposed by the supplied &lt;code&gt;ServiceRegistry.Filter&lt;/code&gt;
                  object&apos;s &lt;code&gt;filter&lt;/code&gt; method.
                  &lt;p&gt; The &lt;code&gt;useOrdering&lt;/code&gt; argument controls the
                  ordering of the results using the same rules as
                  &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt;.                
                <param>
                    category the category to be retrieved from.                    
                </param>
                <param>
                    filter an instance of <code>ServiceRegistry.Filter</code>
                      whose <code>filter</code> method will be invoked.                    
                </param>
                <param>
                    useOrdering <code>true</code> if pairwise orderings
                      should be taken account in ordering the returned objects.                    
                </param>
                <return>
                    an <code>Iterator</code> containing service provider
                      objects from the given category, possibly in order.                    
                </return>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="getServiceProviders" type="Iterator<T>" line="387">
                <params>
                    <param name="category" type="Class<T>"/>
                    <param name="filter" type="Filter"/>
                    <param name="useOrdering" type="boolean"/>
                </params>
                <declaration name="reg" type="SubRegistry" line="388"/>
                <scope line="389"/>
                <declaration name="iter" type="Iterator" line="392"/>
            </method>
            <javadoc line="395">
                Returns the currently registered service provider object that
                  is of the given class type.  At most one object of a given
                  class is allowed to be registered at any given time.  If no
                  registered object has the desired class type, &lt;code&gt;null&lt;/code&gt;
                  is returned.                
                <param>
                    providerClass the <code>Class</code> of the desired
                      service provider object.                    
                </param>
                <return>
                    a currently registered service provider object with the
                      desired <code>Class</code>type, or <code>null</code> is none is
                      present.                    
                </return>
                <exception>
                    IllegalArgumentException if <code>providerClass</code> is
                      <code>null</code>.                    
                </exception>
            </javadoc>
            <method name="getServiceProviderByClass" type="T" line="409">
                <params>
                    <param name="providerClass" type="Class<T>"/>
                </params>
                <scope line="410"/>
                <declaration name="iter" type="Iterator" line="413"/>
                <scope line="414">
                    <declaration name="c" type="Class" line="415"/>
                    <scope line="416">
                        <declaration name="reg" type="SubRegistry" line="417"/>
                        <declaration name="provider" type="T" line="418"/>
                        <scope line="419"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="426">
                Sets a pairwise ordering between two service provider objects
                  within a given category.  If one or both objects are not
                  currently registered within the given category, or if the
                  desired ordering is already set, nothing happens and
                  &lt;code&gt;false&lt;/code&gt; is returned.  If the providers previously
                  were ordered in the reverse direction, that ordering is
                  removed.
                  &lt;p&gt; The ordering will be used by the
                  &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their
                  &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.                
                <param>
                    category a <code>Class</code> object indicating the
                      category under which the preference is to be established.                    
                </param>
                <param>
                    firstProvider the preferred provider.                    
                </param>
                <param>
                    secondProvider the provider to which
                      <code>firstProvider</code> is preferred.                    
                </param>
                <return>
                    <code>true</code> if a previously unset ordering
                      was established.                    
                </return>
                <exception>
                    IllegalArgumentException if either provider is
                      <code>null</code> or they are the same object.                    
                </exception>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="setOrdering" type="boolean" line="449">
                <params>
                    <param name="category" type="Class<T>"/>
                    <param name="firstProvider" type="T"/>
                    <param name="secondProvider" type="T"/>
                </params>
                <scope line="450"/>
                <scope line="453"/>
                <declaration name="reg" type="SubRegistry" line="456"/>
                <scope line="457"/>
                <scope line="460"/>
            </method>
            <javadoc line="465">
                Sets a pairwise ordering between two service provider objects
                  within a given category.  If one or both objects are not
                  currently registered within the given category, or if no
                  ordering is currently set between them, nothing happens
                  and &lt;code&gt;false&lt;/code&gt; is returned.
                  &lt;p&gt; The ordering will be used by the
                  &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their
                  &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.                
                <param>
                    category a <code>Class</code> object indicating the
                      category under which the preference is to be disestablished.                    
                </param>
                <param>
                    firstProvider the formerly preferred provider.                    
                </param>
                <param>
                    secondProvider the provider to which
                      <code>firstProvider</code> was formerly preferred.                    
                </param>
                <return>
                    <code>true</code> if a previously set ordering was
                      disestablished.                    
                </return>
                <exception>
                    IllegalArgumentException if either provider is
                      <code>null</code> or they are the same object.                    
                </exception>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="unsetOrdering" type="boolean" line="486">
                <params>
                    <param name="category" type="Class<T>"/>
                    <param name="firstProvider" type="T"/>
                    <param name="secondProvider" type="T"/>
                </params>
                <scope line="487"/>
                <scope line="490"/>
                <declaration name="reg" type="SubRegistry" line="493"/>
                <scope line="494"/>
                <scope line="497"/>
            </method>
            <javadoc line="502">
                Deregisters all service provider object currently registered
                  under the given category.                
                <param>
                    category the category to be emptied.                    
                </param>
                <exception>
                    IllegalArgumentException if there is no category
                      corresponding to <code>category</code>.                    
                </exception>
            </javadoc>
            <method name="deregisterAll" type="void" line="509">
                <params>
                    <param name="category" type="Class<?>"/>
                </params>
                <declaration name="reg" type="SubRegistry" line="510"/>
                <scope line="511"/>
            </method>
            <javadoc line="516">
                Deregisters all currently registered service providers from all
                  categories.                
            </javadoc>
            <method name="deregisterAll" type="void" line="520">
                <declaration name="iter" type="Iterator" line="521"/>
                <scope line="522">
                    <declaration name="reg" type="SubRegistry" line="523"/>
                </scope>
            </method>
            <javadoc line="527">
                Finalizes this object prior to garbage collection.  The
                  &lt;code&gt;deregisterAll&lt;/code&gt; method is called to deregister all
                  currently registered service providers.  This method should not
                  be called from application code.                
                <exception>
                    Throwable if an error occurs during superclass
                      finalization.                    
                </exception>
            </javadoc>
            <method name="finalize" type="void" line="535"/>
        </class>
        <class name="SubRegistry" line="540">
            <javadoc line="540">
                A portion of a registry dealing with a single superclass or
                  interface.                
            </javadoc>
            <declaration name="registry" type="ServiceRegistry" line="545"/>
            <declaration name="category" type="Class" line="546"/>
            <declaration name="poset" type="PartiallyOrderedSet" line="547"/>
            <declaration name="map" type="Map&lt;Class&lt;?&gt;,Object&gt;" line="548"/>
            <method name="SubRegistry" type="constructor" line="549">
                <params>
                    <param name="registry" type="ServiceRegistry"/>
                    <param name="category" type="Class"/>
                </params>
            </method>
            <method name="registerServiceProvider" type="boolean" line="553">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <declaration name="oprovider" type="Object" line="554"/>
                <declaration name="present" type="boolean" line="555"/>
                <scope line="556"/>
                <scope line="561">
                    <declaration name="rs" type="RegisterableService" line="562"/>
                </scope>
            </method>
            <javadoc line="567">
                If the provider was not previously registered, do nothing.                
                <return>
                    true if the provider was previously registered.                    
                </return>
            </javadoc>
            <method name="deregisterServiceProvider" type="boolean" line="571">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <declaration name="oprovider" type="Object" line="572"/>
                <scope line="573">
                    <scope line="576">
                        <declaration name="rs" type="RegisterableService" line="577"/>
                    </scope>
                </scope>
            </method>
            <method name="contains" type="boolean" line="584">
                <params>
                    <param name="provider" type="Object"/>
                </params>
                <declaration name="oprovider" type="Object" line="585"/>
            </method>
            <method name="setOrdering" type="boolean" line="588">
                <params>
                    <param name="firstProvider" type="Object"/>
                    <param name="secondProvider" type="Object"/>
                </params>
            </method>
            <method name="unsetOrdering" type="boolean" line="591">
                <params>
                    <param name="firstProvider" type="Object"/>
                    <param name="secondProvider" type="Object"/>
                </params>
            </method>
            <method name="getServiceProviders" type="Iterator" line="594">
                <params>
                    <param name="useOrdering" type="boolean"/>
                </params>
                <scope line="595"/>
                <scope line="598"/>
            </method>
            <method name="getServiceProviderByClass" type="T" line="602">
                <params>
                    <param name="providerClass" type="Class<T>"/>
                </params>
            </method>
            <method name="clear" type="void" line="605">
                <declaration name="iter" type="Iterator" line="606"/>
                <scope line="607">
                    <declaration name="provider" type="Object" line="608"/>
                    <scope line="610">
                        <declaration name="rs" type="RegisterableService" line="611"/>
                    </scope>
                </scope>
            </method>
            <method name="finalize" type="void" line="617"/>
        </class>
        <class name="FilterIterator" line="621">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <implements interface="Iterator">
                <type_params>
                    <type_param name="T"/>
                </type_params>
            </implements>
            <javadoc line="621">
                A class for wrapping &lt;code&gt;Iterators&lt;/code&gt; with a filter function.
                  This provides an iterator for a subset without duplication.                
            </javadoc>
            <declaration name="iter" type="Iterator&lt;T&gt;" line="626"/>
            <declaration name="filter" type="ServiceRegistry.Filter" line="627"/>
            <declaration name="next" type="T" line="628"/>
            <method name="FilterIterator" type="constructor" line="629">
                <params>
                    <param name="iter" type="Iterator<T>"/>
                    <param name="filter" type="ServiceRegistry.Filter"/>
                </params>
            </method>
            <method name="advance" type="void" line="634">
                <scope line="635">
                    <declaration name="elt" type="T" line="636"/>
                    <scope line="637"/>
                </scope>
            </method>
            <method name="hasNext" type="boolean" line="644"/>
            <method name="next" type="T" line="647">
                <scope line="648"/>
                <declaration name="o" type="T" line="651"/>
            </method>
            <method name="remove" type="void" line="655"/>
        </class>
    </source>