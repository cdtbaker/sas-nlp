<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.sql.rowset.spi">
        <import package="java.util.logging"/>
        <import package="java.util"/>
        <import package="java.sql"/>
        <import package="javax.sql"/>
        <import package="java.io.FileInputStream"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.FileNotFoundException"/>
        <import package="javax.naming"/>
        <class name="SyncFactory" line="41">
            <comment line="876">
                public javax.sql.RowSetInternal getRowSetInternal() {
                try
                {
                return SyncFactory.getInstance(className).getRowSetInternal();
                } catch(SyncFactoryException sfEx) {
                
                }
                }                
            </comment>
            <javadoc line="41">
                The Service Provider Interface (SPI) mechanism that generates &lt;code&gt;SyncProvider&lt;/code&gt;
                  instances to be used by disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.
                  The &lt;code&gt;SyncProvider&lt;/code&gt; instances in turn provide the
                  &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt; object the &lt;code&gt;RowSet&lt;/code&gt; object
                  needs to populate itself with data and the
                  &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; object it needs to
                  propagate changes to its
                  data back to the underlying data source.
                  &lt;P&gt;
                  Because the methods in the &lt;code&gt;SyncFactory&lt;/code&gt; class are all static,
                  there is only one &lt;code&gt;SyncFactory&lt;/code&gt; object
                  per Java VM at any one time. This ensures that there is a single source from which a
                  &lt;code&gt;RowSet&lt;/code&gt; implementation can obtain its &lt;code&gt;SyncProvider&lt;/code&gt;
                  implementation.
                  &lt;p&gt;
                  &lt;h3&gt;1.0 Overview&lt;/h3&gt;
                  The &lt;code&gt;SyncFactory&lt;/code&gt; class provides an internal registry of available
                  synchronization provider implementations (&lt;code&gt;SyncProvider&lt;/code&gt; objects).
                  This registry may be queried to determine which
                  synchronization providers are available.
                  The following line of code gets an enumeration of the providers currently registered.
                  &lt;PRE&gt;
                  java.util.Enumeration e = SyncFactory.getRegisteredProviders();
                  &lt;/PRE&gt;
                  All standard &lt;code&gt;RowSet&lt;/code&gt; implementations must provide at least two providers:
                  &lt;UL&gt;
                  &lt;LI&gt;an optimistic provider for use with a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation
                  or an implementation derived from it
                  &lt;LI&gt;an XML provider, which is used for reading and writing XML, such as with
                  &lt;code&gt;WebRowSet&lt;/code&gt; objects
                  &lt;/UL&gt;
                  Note that the JDBC RowSet Implementations include the &lt;code&gt;SyncProvider&lt;/code&gt;
                  implemtations &lt;code&gt;RIOptimisticProvider&lt;/code&gt; and &lt;code&gt;RIXmlProvider&lt;/code&gt;,
                  which satisfy this requirement.
                  &lt;P&gt;
                  The &lt;code&gt;SyncFactory&lt;/code&gt; class provides accessor methods to assist
                  applications in determining which synchronization providers are currently
                  registered with the &lt;code&gt;SyncFactory&lt;/code&gt;.
                  &lt;p&gt;
                  Other methods let &lt;code&gt;RowSet&lt;/code&gt; persistence providers be
                  registered or de-registered with the factory mechanism. This
                  allows additional synchronization provider implementations to be made
                  available to &lt;code&gt;RowSet&lt;/code&gt; objects at run time.
                  &lt;p&gt;
                  Applications can apply a degree of filtering to determine the level of
                  synchronization that a &lt;code&gt;SyncProvider&lt;/code&gt; implementation offers.
                  The following criteria determine whether a provider is
                  made available to a &lt;code&gt;RowSet&lt;/code&gt; object:
                  &lt;ol&gt;
                  &lt;li&gt;If a particular provider is specified by a &lt;code&gt;RowSet&lt;/code&gt; object, and
                  the &lt;code&gt;SyncFactory&lt;/code&gt; does not contain a reference to this provider,
                  a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown stating that the synchronization
                  provider could not be found.
                  &lt;p&gt;
                  &lt;li&gt;If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified
                  provider and the specified provider has been properly registered, the
                  requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt;
                  is thrown.
                  &lt;p&gt;
                  &lt;li&gt;If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a
                  &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional
                  &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference
                  implementation providers are supplied.
                  &lt;/ol&gt;
                  &lt;h3&gt;2.0 Registering &lt;code&gt;SyncProvider&lt;/code&gt; Implementations&lt;/h3&gt;
                  &lt;p&gt;
                  Both vendors and developers can register &lt;code&gt;SyncProvider&lt;/code&gt;
                  implementations using one of the following mechanisms.
                  &lt;ul&gt;
                  &lt;LI&gt;&lt;B&gt;Using the command line&lt;/B&gt;&lt;BR&gt;
                  The name of the provider is supplied on the command line, which will add
                  the provider to the system properties.
                  For example:
                  &lt;PRE&gt;
                  -Drowset.provider.classname=com.fred.providers.HighAvailabilityProvider
                  &lt;/PRE&gt;
                  &lt;li&gt;&lt;b&gt;Using the Standard Properties File&lt;/b&gt;&lt;BR&gt;
                  The reference implementation is targeted
                  to ship with J2SE 1.5, which will include an additional resource file
                  that may be edited by hand. Here is an example of the properties file
                  included in the reference implementation:
                  &lt;PRE&gt;
                  #Default JDBC RowSet sync providers listing
                  #
                  # Optimistic synchronization provider
                  rowset.provider.classname.0=com.sun.rowset.providers.RIOptimisticProvider
                  rowset.provider.vendor.0=Oracle Corporation
                  rowset.provider.version.0=1.0
                  # XML Provider using standard XML schema
                  rowset.provider.classname.1=com.sun.rowset.providers.RIXMLProvider
                  rowset.provider.vendor.1=Oracle Corporation
                  rowset.provider.version.1=1.0
                  &lt;/PRE&gt;
                  The &lt;code&gt;SyncFactory&lt;/code&gt; checks this file and registers the
                  &lt;code&gt;SyncProvider&lt;/code&gt; implementations that it contains. A
                  developer or vendor can add other implementations to this file.
                  For example, here is a possible addition:
                  &lt;PRE&gt;
                  rowset.provider.classname.2=com.fred.providers.HighAvailabilityProvider
                  rowset.provider.vendor.2=Fred, Inc.
                  rowset.provider.version.2=1.0
                  &lt;/PRE&gt;
                  &lt;p&gt;
                  &lt;li&gt;&lt;b&gt;Using a JNDI Context&lt;/b&gt;&lt;BR&gt;
                  Available providers can be registered on a JNDI
                  context, and the &lt;code&gt;SyncFactory&lt;/code&gt; will attempt to load
                  &lt;code&gt;SyncProvider&lt;/code&gt; implementations from that JNDI context.
                  For example, the following code fragment registers a provider implementation
                  on a JNDI context.  This is something a deployer would normally do. In this
                  example, &lt;code&gt;MyProvider&lt;/code&gt; is being registered on a CosNaming
                  namespace, which is the namespace used by J2EE resources.
                  &lt;PRE&gt;
                  import javax.naming.;
                  Hashtable svrEnv = new  Hashtable();
                  srvEnv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;CosNaming&quot;);
                  Context ctx = new InitialContext(svrEnv);
                  com.fred.providers.MyProvider = new MyProvider();
                  ctx.rebind(&quot;providers/MyProvider&quot;, syncProvider);
                  &lt;/PRE&gt;
                  &lt;/ul&gt;
                  Next, an application will register the JNDI context with the
                  &lt;code&gt;SyncFactory&lt;/code&gt; instance.  This allows the &lt;code&gt;SyncFactory&lt;/code&gt;
                  to browse within the JNDI context looking for &lt;code&gt;SyncProvider&lt;/code&gt;
                  implementations.
                  &lt;PRE&gt;
                  Hashtable appEnv = new Hashtable();
                  appEnv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;CosNaming&quot;);
                  appEnv.put(Context.PROVIDER_URL, &quot;iiop://hostname/providers&quot;);
                  Context ctx = new InitialContext(appEnv);
                  SyncFactory.registerJNDIContext(ctx);
                  &lt;/PRE&gt;
                  If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt;
                  object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches
                  for it in the system properties, then it looks in the resource files, and
                  finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt;
                  instance verifies that the requested provider is a valid extension of the
                  &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the
                  &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new
                  &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with
                  &lt;i&gt;env&lt;/i&gt;, which contains the binding to &lt;code&gt;MyProvider&lt;/code&gt;.
                  &lt;PRE&gt;
                  Hashtable env = new Hashtable();
                  env.put(SyncFactory.ROWSET_SYNC_PROVIDER, &quot;com.fred.providers.MyProvider&quot;);
                  CachedRowSet crs = new com.sun.rowset.CachedRowSetImpl(env);
                  &lt;/PRE&gt;
                  Further details on these mechanisms are available in the
                  &lt;code&gt;javax.sql.rowset.spi&lt;/code&gt; package specification.                
                <author>
                    Jonathan Bruce                    
                </author>
                <see>
                    javax.sql.rowset.spi.SyncProvider                    
                </see>
                <see>
                    javax.sql.rowset.spi.SyncFactoryException                    
                </see>
            </javadoc>
            <javadoc line="201">
                Creates a new &lt;code&gt;SyncFactory&lt;/code&gt; object, which is the singleton
                  instance.
                  Having a private constructor guarantees that no more than
                  one &lt;code&gt;SyncProvider&lt;/code&gt; object can exist at a time.                
            </javadoc>
            <method name="SyncFactory" type="constructor" line="207"/>
            <declaration name="ROWSET_SYNC_PROVIDER" type="String" line="210"/>
            <javadoc line="210">
                The standard property-id for a synchronization provider implementation
                  name.                
            </javadoc>
            <declaration name="ROWSET_SYNC_VENDOR" type="String" line="216"/>
            <javadoc line="216">
                The standard property-id for a synchronization provider implementation
                  vendor name.                
            </javadoc>
            <declaration name="ROWSET_SYNC_PROVIDER_VERSION" type="String" line="222"/>
            <javadoc line="222">
                The standard property-id for a synchronization provider implementation
                  version tag.                
            </javadoc>
            <declaration name="ROWSET_PROPERTIES" type="String" line="228"/>
            <javadoc line="228">
                The standard resource file name.                
            </javadoc>
            <declaration name="default_provider" type="String" line="232"/>
            <javadoc line="232">
                The RI Optimistic Provider.                
            </javadoc>
            <declaration name="SET_SYNCFACTORY_PERMISSION" type="SQLPermission" line="237"/>
            <javadoc line="237">
                Permission required to invoke setJNDIContext and setLogger                
            </javadoc>
            <declaration name="ic" type="Context" line="242"/>
            <javadoc line="242">
                The initial JNDI context where &lt;code&gt;SyncProvider&lt;/code&gt; implementations can
                  be stored and from which they can be invoked.                
            </javadoc>
            <declaration name="rsLogger" type="Logger" line="247"/>
            <javadoc line="247">
                The &lt;code&gt;Logger&lt;/code&gt; object to be used by the &lt;code&gt;SyncFactory&lt;/code&gt;.                
            </javadoc>
            <declaration name="rsLevel" type="Level" line="251"/>
            <javadoc line="251">
                                
            </javadoc>
            <declaration name="implementations" type="Hashtable" line="255"/>
            <javadoc line="255">
                The registry of available &lt;code&gt;SyncProvider&lt;/code&gt; implementations.
                  See section 2.0 of the class comment for &lt;code&gt;SyncFactory&lt;/code&gt; for an
                  explanation of how a provider can be added to this registry.                
            </javadoc>
            <declaration name="logSync" type="Object" line="261"/>
            <javadoc line="261">
                Internal sync object used to maintain the SPI as a singleton                
            </javadoc>
            <declaration name="logWriter" type="java.io.PrintWriter" line="265"/>
            <javadoc line="265">
                Internal PrintWriter field for logging facility                
            </javadoc>
            <javadoc line="270">
                Adds the the given synchronization provider to the factory register. Guidelines
                  are provided in the &lt;code&gt;SyncProvider&lt;/code&gt; specification for the
                  required naming conventions for &lt;code&gt;SyncProvider&lt;/code&gt;
                  implementations.
                  &lt;p&gt;
                  Synchronization providers bound to a JNDI context can be
                  registered by binding a SyncProvider instance to a JNDI namespace.
                  &lt;ul&gt;
                  &lt;pre&gt;
                  SyncProvider p = new MySyncProvider();
                  InitialContext ic = new InitialContext();
                  ic.bind (&quot;jdbc/rowset/MySyncProvider&quot;, p);
                  &lt;/pre&gt;
                  &lt;/ul&gt;
                  Furthermore, an initial JNDI context should be set with the
                  &lt;code&gt;SyncFactory&lt;/code&gt; using the &lt;code&gt;setJNDIContext&lt;/code&gt; method.
                  The &lt;code&gt;SyncFactory&lt;/code&gt; leverages this context to search for
                  available &lt;code&gt;SyncProvider&lt;/code&gt; objects bound to the JNDI
                  context and its child nodes.                
                <param>
                    providerID A <code>String</code> object with the unique ID of the
                      synchronization provider being registered                    
                </param>
                <throws>
                    SyncFactoryException if an attempt is made to supply an empty
                      or null provider name                    
                </throws>
                <see>
                    #setJNDIContext                    
                </see>
            </javadoc>
            <method name="registerProvider" type="void" line="298">
                <params>
                    <param name="providerID" type="String"/>
                </params>
                <declaration name="impl" type="ProviderImpl" line="300"/>
            </method>
            <javadoc line="307">
                Returns the &lt;code&gt;SyncFactory&lt;/code&gt; singleton.                
                <return>
                    the <code>SyncFactory</code> instance                    
                </return>
            </javadoc>
            <method name="getSyncFactory" type="SyncFactory" line="312">
                <comment line="314">
                    Using Initialization on Demand Holder idiom as
                     Effective Java 2nd Edition,ITEM 71, indicates it is more performant
                     than the Double-Check Locking idiom.                    
                </comment>
            </method>
            <javadoc line="321">
                Removes the designated currently registered synchronization provider from the
                  Factory SPI register.                
                <param>
                    providerID The unique-id of the synchronization provider                    
                </param>
                <throws>
                    SyncFactoryException If an attempt is made to
                      unregister a SyncProvider implementation that was not registered.                    
                </throws>
            </javadoc>
            <method name="unregisterProvider" type="void" line="330">
                <params>
                    <param name="providerID" type="String"/>
                </params>
                <scope line="332"/>
            </method>
            <declaration name="colon" type="String" line="336"/>
            <declaration name="strFileSep" type="String" line="337"/>
            <method name="initMapIfNecessary" type="void" line="339">
                <comment line="342">
                    Local implementation class names and keys from Properties
                     file, translate names into Class objects using Class.forName
                     and store mappings                    
                </comment>
                <comment line="352">
                    check if user is supplying his Synchronisation Provider
                     Implementation if not using Oracle&apos;s implementation.
                     properties.load(new FileInputStream(ROWSET_PROPERTIES));                    
                </comment>
                <comment line="356">
                    The rowset.properties needs to be in jdk/jre/lib when
                     integrated with jdk.
                     else it should be picked from -D option from command line.                    
                </comment>
                <comment line="360">
                    -Drowset.properties will add to standard properties. Similar
                     keys will over-write                    
                </comment>
                <comment line="363">
                    Dependent on application                    
                </comment>
                <comment line="368">
                    Load user&apos;s implementation of SyncProvider
                     here. -Drowset.properties=/abc/def/pqr.txt                    
                </comment>
                <comment line="377">
                    Always available                    
                </comment>
                <comment line="398">
                    removed else, has properties should sum together                    
                </comment>
                <comment line="406">
                    Now deal with -Drowset.provider.classname
                     load additional properties from -D command line                    
                </comment>
                <declaration name="properties" type="Properties" line="344"/>
                <scope line="346">
                    <scope line="349">
                        <declaration name="strRowsetProperties" type="String" line="365"/>
                        <scope line="366">
                            <scope line="370"/>
                        </scope>
                        <declaration name="cl" type="ClassLoader" line="383"/>
                        <scope line="387">
                            <scope line="388"/>
                        </scope>
                    </scope>
                    <scope line="399"/>
                    <scope line="401"/>
                    <declaration name="providerImpls" type="String" line="410"/>
                    <scope line="412">
                        <declaration name="i" type="int" line="413"/>
                        <scope line="414">
                            <declaration name="tokenizer" type="StringTokenizer" line="415"/>
                            <scope line="416"/>
                        </scope>
                        <scope line="420"/>
                    </scope>
                </scope>
            </method>
            <declaration name="debug" type="boolean" line="428"/>
            <javadoc line="428">
                The internal debug switch.                
            </javadoc>
            <declaration name="providerImplIndex" type="int" line="432"/>
            <javadoc line="432">
                Internal registry count for the number of providers contained in the
                  registry.                
            </javadoc>
            <javadoc line="438">
                Internal handler for all standard property parsing. Parses standard
                  ROWSET properties and stores lazy references into the the internal registry.                
            </javadoc>
            <method name="parseProperties" type="void" line="442">
                <params>
                    <param name="p" type="Properties"/>
                </params>
                <comment line="461">
                    no property index has been set.                    
                </comment>
                <comment line="464">
                    property index has been set.                    
                </comment>
                <declaration name="impl" type="ProviderImpl" line="444"/>
                <declaration name="key" type="String" line="445"/>
                <declaration name="propertyNames" type="String[]" line="446"/>
                <scope line="448">
                    <declaration name="str" type="String" line="450"/>
                    <declaration name="w" type="int" line="452"/>
                    <scope line="454">
                        <scope line="459"/>
                        <scope line="462"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="476">
                Used by the parseProperties methods to disassemble each property tuple.                
            </javadoc>
            <method name="getPropertyNames" type="String[]" line="479">
                <params>
                    <param name="append" type="boolean"/>
                </params>
            </method>
            <javadoc line="483">
                Disassembles each property and its associated value. Also handles
                  overloaded property names that contain indexes.                
            </javadoc>
            <method name="getPropertyNames" type="String[]" line="488">
                <params>
                    <param name="append" type="boolean"/>
                    <param name="propertyIndex" type="String"/>
                </params>
                <declaration name="dot" type="String" line="489"/>
                <declaration name="propertyNames" type="String[]" line="490"/>
                <scope line="494">
                    <scope line="495"/>
                </scope>
                <scope line="501"/>
            </method>
            <javadoc line="506">
                Internal debug method that outputs the registry contents.                
            </javadoc>
            <method name="showImpl" type="void" line="509">
                <params>
                    <param name="impl" type="ProviderImpl"/>
                </params>
            </method>
            <javadoc line="517">
                Returns the &lt;code&gt;SyncProvider&lt;/code&gt; instance identified by &lt;i&gt;providerID&lt;/i&gt;.                
                <param>
                    providerID the unique identifier of the provider                    
                </param>
                <return>
                    a <code>SyncProvider</code> implementation                    
                </return>
                <throws>
                    SyncFactoryException If the SyncProvider cannot be found,
                      the providerID is {@code null}, or
                      some error was encountered when trying to invoke this provider.                    
                </throws>
            </javadoc>
            <method name="getInstance" type="SyncProvider" line="527">
                <params>
                    <param name="providerID" type="String"/>
                </params>
                <comment line="534">
                    populate HashTable                    
                </comment>
                <comment line="535">
                    check JNDI context for any additional bindings                    
                </comment>
                <comment line="540">
                    Requested SyncProvider is unavailable. Return default provider.                    
                </comment>
                <comment line="544">
                    Attempt to invoke classname from registered SyncProvider list                    
                </comment>
                <comment line="549">
                    The SyncProvider implementation of the user will be in
                     the classpath. We need to find the ClassLoader which loads
                     this SyncFactory and try to laod the SyncProvider class from
                     there.                    
                </comment>
                <scope line="529"/>
                <declaration name="impl" type="ProviderImpl" line="536"/>
                <scope line="538"/>
                <declaration name="c" type="Class" line="544"/>
                <scope line="545">
                    <declaration name="cl" type="ClassLoader" line="546"/>
                    <scope line="556"/>
                    <scope line="558"/>
                </scope>
                <scope line="562"/>
                <scope line="564"/>
                <scope line="566"/>
            </method>
            <javadoc line="571">
                Returns an Enumeration of currently registered synchronization
                  providers.  A &lt;code&gt;RowSet&lt;/code&gt; implementation may use any provider in
                  the enumeration as its &lt;code&gt;SyncProvider&lt;/code&gt; object.
                  &lt;p&gt;
                  At a minimum, the reference synchronization provider allowing
                  RowSet content data to be stored using a JDBC driver should be
                  possible.                
                <return>
                    Enumeration  A enumeration of available synchronization
                      providers that are registered with this Factory                    
                </return>
            </javadoc>
            <method name="getRegisteredProviders" type="Enumeration<SyncProvider>" line="584">
                <comment line="587">
                    return a collection of classnames
                     of type SyncProvider                    
                </comment>
            </method>
            <javadoc line="591">
                Sets the logging object to be used by the &lt;code&gt;SyncProvider&lt;/code&gt;
                  implementation provided by the &lt;code&gt;SyncFactory&lt;/code&gt;. All
                  &lt;code&gt;SyncProvider&lt;/code&gt; implementations can log their events to
                  this object and the application can retrieve a handle to this
                  object using the &lt;code&gt;getLogger&lt;/code&gt; method.
                  &lt;p&gt;
                  This method checks to see that there is an {@code SQLPermission}object  which grants the permission {@code setSyncFactory}before allowing the method to succeed.  If a{@code SecurityManager} exists and its{@code checkPermission} method denies calling {@code setLogger},
                  this method throws a{@code java.lang.SecurityException}.                
                <param>
                    logger A Logger object instance                    
                </param>
                <throws>
                    java.lang.SecurityException if a security manager exists and its{@code checkPermission} method denies calling {@code setLogger}                    
                </throws>
                <throws>
                    NullPointerException if the logger is null                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
            </javadoc>
            <method name="setLogger" type="void" line="612">
                <params>
                    <param name="logger" type="Logger"/>
                </params>
                <declaration name="sec" type="SecurityManager" line="614"/>
                <scope line="615"/>
                <scope line="619"/>
            </method>
            <javadoc line="625">
                Sets the logging object that is used by &lt;code&gt;SyncProvider&lt;/code&gt;
                  implementations provided by the &lt;code&gt;SyncFactory&lt;/code&gt; SPI. All
                  &lt;code&gt;SyncProvider&lt;/code&gt; implementations can log their events
                  to this object and the application can retrieve a handle to this
                  object using the &lt;code&gt;getLogger&lt;/code&gt; method.
                  &lt;p&gt;
                  This method checks to see that there is an {@code SQLPermission}object  which grants the permission {@code setSyncFactory}before allowing the method to succeed.  If a{@code SecurityManager} exists and its{@code checkPermission} method denies calling {@code setLogger},
                  this method throws a{@code java.lang.SecurityException}.                
                <param>
                    logger a Logger object instance                    
                </param>
                <param>
                    level a Level object instance indicating the degree of logging
                      required                    
                </param>
                <throws>
                    java.lang.SecurityException if a security manager exists and its{@code checkPermission} method denies calling {@code setLogger}                    
                </throws>
                <throws>
                    java.util.logging.LoggingPermission if a security manager exists and its{@code checkPermission} method denies calling {@code setLevel}                    
                </throws>
                <throws>
                    NullPointerException if the logger is null                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    LoggingPermission                    
                </see>
            </javadoc>
            <method name="setLogger" type="void" line="651">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="level" type="Level"/>
                </params>
                <comment line="653">
                    singleton                    
                </comment>
                <declaration name="sec" type="SecurityManager" line="653"/>
                <scope line="654"/>
                <scope line="658"/>
            </method>
            <javadoc line="665">
                Returns the logging object for applications to retrieve
                  synchronization events posted by SyncProvider implementations.                
                <throws>
                    SyncFactoryException if no logging object has been set.                    
                </throws>
            </javadoc>
            <method name="getLogger" type="Logger" line="671">
                <comment line="675">
                    only one logger per session                    
                </comment>
                <declaration name="result" type="Logger" line="673"/>
                <scope line="675"/>
            </method>
            <javadoc line="682">
                Sets the initial JNDI context from which SyncProvider implementations
                  can be retrieved from a JNDI namespace
                  &lt;p&gt;
                  This method checks to see that there is an {@code SQLPermission}object  which grants the permission {@code setSyncFactory}before allowing the method to succeed.  If a{@code SecurityManager} exists and its{@code checkPermission} method denies calling {@code setJNDIContext},
                  this method throws a{@code java.lang.SecurityException}.                
                <param>
                    ctx a valid JNDI context                    
                </param>
                <throws>
                    SyncFactoryException if the supplied JNDI context is null                    
                </throws>
                <throws>
                    java.lang.SecurityException if a security manager exists and its{@code checkPermission} method denies calling {@code setJNDIContext}                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
            </javadoc>
            <method name="setJNDIContext" type="void" line="701">
                <params>
                    <param name="ctx" type="javax.naming.Context"/>
                </params>
                <declaration name="sec" type="SecurityManager" line="702"/>
                <scope line="703"/>
                <scope line="706"/>
            </method>
            <javadoc line="712">
                Controls JNDI context initialization.                
                <throws>
                    SyncFactoryException if an error occurs parsing the JNDI context                    
                </throws>
            </javadoc>
            <method name="initJNDIContext" type="void" line="717">
                <comment line="723">
                    touch JNDI namespace once.                    
                </comment>
                <scope line="719">
                    <scope line="720"/>
                    <scope line="723"/>
                    <scope line="726"/>
                </scope>
            </method>
            <declaration name="lazyJNDICtxRefresh" type="boolean" line="732"/>
            <javadoc line="732">
                Internal switch indicating whether the JNDI namespace should be re-read.                
            </javadoc>
            <javadoc line="737">
                Parses the set JNDI Context and passes bindings to the enumerateBindings
                  method when complete.                
            </javadoc>
            <method name="parseJNDIContext" type="Properties" line="741">
                <comment line="747">
                    Hunt one level below context for available SyncProvider objects                    
                </comment>
                <declaration name="bindings" type="NamingEnumeration" line="743"/>
                <declaration name="properties" type="Properties" line="744"/>
            </method>
            <javadoc line="752">
                Scans each binding on JNDI context and determines if any binding is an
                  instance of SyncProvider, if so, add this to the registry and continue to
                  scan the current context using a re-entrant call to this method until all
                  bindings have been enumerated.                
            </javadoc>
            <method name="enumerateBindings" type="void" line="759">
                <params>
                    <param name="bindings" type="NamingEnumeration"/>
                    <param name="properties" type="Properties"/>
                </params>
                <comment line="762">
                    move to parameters ?                    
                </comment>
                <comment line="774">
                    skip directories/sub-contexts                    
                </comment>
                <comment line="784">
                    reset                    
                </comment>
                <comment line="790">
                    Re-entrant call into method                    
                </comment>
                <declaration name="syncProviderObj" type="boolean" line="761"/>
                <scope line="763">
                    <declaration name="bd" type="Binding" line="764"/>
                    <declaration name="elementObj" type="Object" line="765"/>
                    <declaration name="element" type="String" line="766"/>
                    <scope line="767">
                        <scope line="772">
                            <scope line="774"/>
                        </scope>
                        <scope line="779">
                            <declaration name="sync" type="SyncProvider" line="780"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="787"/>
            </method>
            <class name="SyncFactoryHolder" line="794">
                <javadoc line="794">
                    Lazy initialization Holder class used by {@code getSyncFactory}                    
                </javadoc>
                <declaration name="factory" type="SyncFactory" line="798"/>
            </class>
        </class>
        <class name="ProviderImpl" line="802">
            <extends class="SyncProvider"/>
            <comment line="876">
                public javax.sql.RowSetInternal getRowSetInternal() {
                try
                {
                return SyncFactory.getInstance(className).getRowSetInternal();
                } catch(SyncFactoryException sfEx) {
                
                }
                }                
            </comment>
            <javadoc line="802">
                Internal class that defines the lazy reference construct for each registered
                  SyncProvider implementation.                
            </javadoc>
            <declaration name="className" type="String" line="808"/>
            <declaration name="vendorName" type="String" line="809"/>
            <declaration name="ver" type="String" line="810"/>
            <declaration name="index" type="int" line="811"/>
            <method name="setClassname" type="void" line="813">
                <params>
                    <param name="classname" type="String"/>
                </params>
            </method>
            <method name="getClassname" type="String" line="817"/>
            <method name="setVendor" type="void" line="821">
                <params>
                    <param name="vendor" type="String"/>
                </params>
            </method>
            <method name="getVendor" type="String" line="825"/>
            <method name="setVersion" type="void" line="829">
                <params>
                    <param name="providerVer" type="String"/>
                </params>
            </method>
            <method name="getVersion" type="String" line="833"/>
            <method name="setIndex" type="void" line="837">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="getIndex" type="int" line="841"/>
            <method name="getDataSourceLock" type="int" line="845">
                <declaration name="dsLock" type="int" line="847"/>
                <scope line="848"/>
                <scope line="850"/>
            </method>
            <method name="getProviderGrade" type="int" line="858">
                <comment line="866">
                                        
                </comment>
                <declaration name="grade" type="int" line="860"/>
                <scope line="862"/>
                <scope line="864"/>
            </method>
            <method name="getProviderID" type="String" line="871"/>
            <method name="getRowSetReader" type="javax.sql.RowSetReader" line="885">
                <comment line="893">
                                        
                </comment>
                <declaration name="rsReader" type="RowSetReader" line="887"/>
                <scope line="889"/>
                <scope line="891"/>
            </method>
            <method name="getRowSetWriter" type="javax.sql.RowSetWriter" line="899">
                <comment line="906">
                                        
                </comment>
                <declaration name="rsWriter" type="RowSetWriter" line="901"/>
                <scope line="902"/>
                <scope line="904"/>
            </method>
            <method name="setDataSourceLock" type="void" line="912">
                <params>
                    <param name="param" type="int"/>
                </params>
                <scope line="914"/>
                <scope line="916"/>
            </method>
            <method name="supportsUpdatableView" type="int" line="922">
                <comment line="930">
                                        
                </comment>
                <declaration name="view" type="int" line="924"/>
                <scope line="926"/>
                <scope line="928"/>
            </method>
        </class>
    </source>