<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.net.ssl">
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.ReadOnlyBufferException"/>
        <class name="SSLEngine" line="32">
            <javadoc line="32">
                A class which enables secure communications using protocols such as
                  the Secure Sockets Layer (SSL) or
                  &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt; IETF RFC 2246 &quot;Transport
                  Layer Security&quot; (TLS) &lt;/A&gt; protocols, but is transport independent.
                  &lt;P&gt;
                  The secure communications modes include: &lt;UL&gt;
                  &lt;LI&gt; &lt;em&gt;Integrity Protection&lt;/em&gt;.  SSL/TLS protects against
                  modification of messages by an active wiretapper.
                  &lt;LI&gt; &lt;em&gt;Authentication&lt;/em&gt;.  In most modes, SSL/TLS provides
                  peer authentication.  Servers are usually authenticated, and
                  clients may be authenticated as requested by servers.
                  &lt;LI&gt; &lt;em&gt;Confidentiality (Privacy Protection)&lt;/em&gt;.  In most
                  modes, SSL/TLS encrypts data being sent between client and
                  server.  This protects the confidentiality of data, so that
                  passive wiretappers won&apos;t see sensitive data such as financial
                  information or personal information of many kinds.
                  &lt;/UL&gt;
                  These kinds of protection are specified by a &quot;cipher suite&quot;, which
                  is a combination of cryptographic algorithms used by a given SSL
                  connection.  During the negotiation process, the two endpoints must
                  agree on a cipher suite that is available in both environments.  If
                  there is no such suite in common, no SSL connection can be
                  established, and no data can be exchanged.
                  &lt;P&gt;
                  The cipher suite used is established by a negotiation process called
                  &quot;handshaking&quot;.  The goal of this process is to create or rejoin a
                  &quot;session&quot;, which may protect many connections over time.  After
                  handshaking has completed, you can access session attributes by
                  using the {@link #getSession()} method.
                  &lt;P&gt;
                  The &lt;code&gt;SSLSocket&lt;/code&gt; class provides much of the same security
                  functionality, but all of the inbound and outbound data is
                  automatically transported using the underlying {@link java.net.Socket Socket}, which by design uses a blocking model.
                  While this is appropriate for many applications, this model does not
                  provide the scalability required by large servers.
                  &lt;P&gt;
                  The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it
                  operates on inbound and outbound byte streams, independent of the
                  transport mechanism.  It is the responsibility of the
                  &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to
                  the peer.  By separating the SSL/TLS abstraction from the I/O
                  transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a
                  wide variety of I/O types, such as {@link java.nio.channels.spi.AbstractSelectableChannel#configureBlocking(boolean)non-blocking I/O (polling)}, {@link java.nio.channels.Selectorselectable non-blocking I/O}, {@link java.net.Socket Socket} and the
                  traditional Input/OutputStreams, local {@link java.nio.ByteBufferByteBuffers} or byte arrays, &lt;A
                  HREF=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous
                  I/O models &lt;/A&gt;, and so on.
                  &lt;P&gt;
                  At a high level, the &lt;code&gt;SSLEngine&lt;/code&gt; appears thus:
                  &lt;pre&gt;
                  app data
                  |           ^
                  |     |     |
                  v     |     |
                  +----+-----|-----+----+
                  |          |          |
                  |       SSL|Engine    |
                  wrap()  |          |          |  unwrap()
                  | OUTBOUND | INBOUND  |
                  |          |          |
                  +----+-----|-----+----+
                  |     |     ^
                  |     |     |
                  v           |
                  net data
                  &lt;/pre&gt;
                  Application data (also known as plaintext or cleartext) is data which
                  is produced or consumed by an application.  Its counterpart is
                  network data, which consists of either handshaking and/or ciphertext
                  (encrypted) data, and destined to be transported via an I/O
                  mechanism.  Inbound data is data which has been received from the
                  peer, and outbound data is destined for the peer.
                  &lt;P&gt;
                  (In the context of an &lt;code&gt;SSLEngine&lt;/code&gt;, the term &quot;handshake
                  data&quot; is taken to mean any data exchanged to establish and control a
                  secure connection.  Handshake data includes the SSL/TLS messages
                  &quot;alert&quot;, &quot;change_cipher_spec,&quot; and &quot;handshake.&quot;)
                  &lt;P&gt;
                  There are five distinct phases to an &lt;code&gt;SSLEngine&lt;/code&gt;.
                  &lt;OL&gt;
                  &lt;li&gt; Creation - The &lt;code&gt;SSLEngine&lt;/code&gt; has been created and
                  initialized, but has not yet been used.  During this phase, an
                  application may set any &lt;code&gt;SSLEngine&lt;/code&gt;-specific settings
                  (enabled cipher suites, whether the &lt;code&gt;SSLEngine&lt;/code&gt; should
                  handshake in client or server mode, and so on).  Once
                  handshaking has begun, though, any new settings (except
                  client/server mode, see below) will be used for
                  the next handshake.
                  &lt;li&gt; Initial Handshake - The initial handshake is a procedure by
                  which the two peers exchange communication parameters until an
                  SSLSession is established.  Application data can not be sent during
                  this phase.
                  &lt;li&gt; Application Data - Once the communication parameters have
                  been established and the handshake is complete, application data
                  may flow through the &lt;code&gt;SSLEngine&lt;/code&gt;.  Outbound
                  application messages are encrypted and integrity protected,
                  and inbound messages reverse the process.
                  &lt;li&gt;  Rehandshaking - Either side may request a renegotiation of
                  the session at any time during the Application Data phase.  New
                  handshaking data can be intermixed among the application data.
                  Before starting the rehandshake phase, the application may
                  reset the SSL/TLS communication parameters such as the list of
                  enabled ciphersuites and whether to use client authentication,
                  but can not change between client/server modes.  As before, once
                  handshaking has begun, any new &lt;code&gt;SSLEngine&lt;/code&gt;
                  configuration settings will not be used until the next
                  handshake.
                  &lt;li&gt;  Closure - When the connection is no longer needed, the
                  application should close the &lt;code&gt;SSLEngine&lt;/code&gt; and should
                  send/receive any remaining messages to the peer before
                  closing the underlying transport mechanism.  Once an engine is
                  closed, it is not reusable:  a new &lt;code&gt;SSLEngine&lt;/code&gt; must
                  be created.
                  &lt;/OL&gt;
                  An &lt;code&gt;SSLEngine&lt;/code&gt; is created by calling {@link SSLContext#createSSLEngine()} from an initialized
                  &lt;code&gt;SSLContext&lt;/code&gt;.  Any configuration
                  parameters should be set before making the first call to
                  &lt;code&gt;wrap()&lt;/code&gt;, &lt;code&gt;unwrap()&lt;/code&gt;, or
                  &lt;code&gt;beginHandshake()&lt;/code&gt;.  These methods all trigger the
                  initial handshake.
                  &lt;P&gt;
                  Data moves through the engine by calling {@link #wrap(ByteBuffer,ByteBuffer) wrap()} or {@link #unwrap(ByteBuffer,ByteBuffer)unwrap()} on outbound or inbound data, respectively.  Depending on
                  the state of the &lt;code&gt;SSLEngine&lt;/code&gt;, a &lt;code&gt;wrap()&lt;/code&gt; call
                  may consume application data from the source buffer and may produce
                  network data in the destination buffer.  The outbound data
                  may contain application and/or handshake data.  A call to
                  &lt;code&gt;unwrap()&lt;/code&gt; will examine the source buffer and may
                  advance the handshake if the data is handshaking information, or
                  may place application data in the destination buffer if the data
                  is application.  The state of the underlying SSL/TLS algorithm
                  will determine when data is consumed and produced.
                  &lt;P&gt;
                  Calls to &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;unwrap()&lt;/code&gt; return an
                  &lt;code&gt;SSLEngineResult&lt;/code&gt; which indicates the status of the
                  operation, and (optionally) how to interact with the engine to make
                  progress.
                  &lt;P&gt;
                  The &lt;code&gt;SSLEngine&lt;/code&gt; produces/consumes complete SSL/TLS
                  packets only, and does not store application data internally between
                  calls to &lt;code&gt;wrap()/unwrap()&lt;/code&gt;.  Thus input and output
                  &lt;code&gt;ByteBuffer&lt;/code&gt;s must be sized appropriately to hold the
                  maximum record that can be produced.  Calls to {@link SSLSession#getPacketBufferSize()} and {@link SSLSession#getApplicationBufferSize()} should be used to determine
                  the appropriate buffer sizes.  The size of the outbound application
                  data buffer generally does not matter.  If buffer conditions do not
                  allow for the proper consumption/production of data, the application
                  must determine (via {@link SSLEngineResult}) and correct the
                  problem, and then try the call again.
                  &lt;P&gt;
                  For example, &lt;code&gt;unwrap()&lt;/code&gt; will return a {@link SSLEngineResult.Status#BUFFER_OVERFLOW} result if the engine
                  determines that there is not enough destination buffer space available.
                  Applications should call {@link SSLSession#getApplicationBufferSize()}and compare that value with the space available in the destination buffer,
                  enlarging the buffer if necessary.  Similarly, if &lt;code&gt;unwrap()&lt;/code&gt;
                  were to return a {@link SSLEngineResult.Status#BUFFER_UNDERFLOW}, the
                  application should call {@link SSLSession#getPacketBufferSize()} to ensure
                  that the source buffer has enough room to hold a record (enlarging if
                  necessary), and then obtain more inbound data.
                  &lt;pre&gt;
                  SSLEngineResult r = engine.unwrap(src, dst);
                  switch (r.getStatus()) {
                  BUFFER_OVERFLOW:
                  // Could attempt to drain the dst buffer of any already obtained
                  // data, but we&apos;ll just increase it to the size needed.
                  int appSize = engine.getSession().getApplicationBufferSize();
                  ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());
                  dst.flip();
                  b.put(dst);
                  dst = b;
                  // retry the operation.
                  break;
                  BUFFER_UNDERFLOW:
                  int netSize = engine.getSession().getPacketBufferSize();
                  // Resize buffer if needed.
                  if (netSize &gt; dst.capacity()) {
                  ByteBuffer b = ByteBuffer.allocate(netSize);
                  src.flip();
                  b.put(src);
                  src = b;
                  }
                  // Obtain more inbound network data for src,
                  // then retry the operation.
                  break;
                  // other cases: CLOSED, OK.
                  }
                  &lt;/pre&gt;
                  &lt;P&gt;
                  Unlike &lt;code&gt;SSLSocket&lt;/code&gt;, all methods of SSLEngine are
                  non-blocking.  &lt;code&gt;SSLEngine&lt;/code&gt; implementations may
                  require the results of tasks that may take an extended period of
                  time to complete, or may even block.  For example, a TrustManager
                  may need to connect to a remote certificate validation service,
                  or a KeyManager might need to prompt a user to determine which
                  certificate to use as part of client authentication.  Additionally,
                  creating cryptographic signatures and verifying them can be slow,
                  seemingly blocking.
                  &lt;P&gt;
                  For any operation which may potentially block, the
                  &lt;code&gt;SSLEngine&lt;/code&gt; will create a {@link java.lang.Runnable}delegated task.  When &lt;code&gt;SSLEngineResult&lt;/code&gt; indicates that a
                  delegated task result is needed, the application must call {@link #getDelegatedTask()} to obtain an outstanding delegated task and
                  call its {@link java.lang.Runnable#run() run()} method (possibly using
                  a different thread depending on the compute strategy).  The
                  application should continue obtaining delegated tasks until no more
                  exist, and try the original operation again.
                  &lt;P&gt;
                  At the end of a communication session, applications should properly
                  close the SSL/TLS link.  The SSL/TLS protocols have closure handshake
                  messages, and these messages should be communicated to the peer
                  before releasing the &lt;code&gt;SSLEngine&lt;/code&gt; and closing the
                  underlying transport mechanism.  A close can be initiated by one of:
                  an SSLException, an inbound closure handshake message, or one of the
                  close methods.  In all cases, closure handshake messages are
                  generated by the engine, and &lt;code&gt;wrap()&lt;/code&gt; should be repeatedly
                  called until the resulting &lt;code&gt;SSLEngineResult&lt;/code&gt;&apos;s status
                  returns &quot;CLOSED&quot;, or {@link #isOutboundDone()} returns true.  All
                  data obtained from the &lt;code&gt;wrap()&lt;/code&gt; method should be sent to the
                  peer.
                  &lt;P&gt;{@link #closeOutbound()} is used to signal the engine that the
                  application will not be sending any more data.
                  &lt;P&gt;
                  A peer will signal its intent to close by sending its own closure
                  handshake message.  After this message has been received and
                  processed by the local &lt;code&gt;SSLEngine&lt;/code&gt;&apos;s &lt;code&gt;unwrap()&lt;/code&gt;
                  call, the application can detect the close by calling
                  &lt;code&gt;unwrap()&lt;/code&gt; and looking for a &lt;code&gt;SSLEngineResult&lt;/code&gt;
                  with status &quot;CLOSED&quot;, or if {@link #isInboundDone()} returns true.
                  If for some reason the peer closes the communication link without
                  sending the proper SSL/TLS closure message, the application can
                  detect the end-of-stream and can signal the engine via {@link #closeInbound()} that there will no more inbound messages to
                  process.  Some applications might choose to require orderly shutdown
                  messages from a peer, in which case they can check that the closure
                  was generated by a handshake message and not by an end-of-stream
                  condition.
                  &lt;P&gt;
                  There are two groups of cipher suites which you will need to know
                  about when managing cipher suites:
                  &lt;UL&gt;
                  &lt;LI&gt; &lt;em&gt;Supported&lt;/em&gt; cipher suites:  all the suites which are
                  supported by the SSL implementation.  This list is reported
                  using {@link #getSupportedCipherSuites()}.
                  &lt;LI&gt; &lt;em&gt;Enabled&lt;/em&gt; cipher suites, which may be fewer than
                  the full set of supported suites.  This group is set using the{@link #setEnabledCipherSuites(String[])} method, and
                  queried using the {@link #getEnabledCipherSuites()} method.
                  Initially, a default set of cipher suites will be enabled on a
                  new engine that represents the minimum suggested
                  configuration.
                  &lt;/UL&gt;
                  Implementation defaults require that only cipher suites which
                  authenticate servers and provide confidentiality be enabled by
                  default.  Only if both sides explicitly agree to unauthenticated
                  and/or non-private (unencrypted) communications will such a
                  cipher suite be selected.
                  &lt;P&gt;
                  Each SSL/TLS connection must have one client and one server, thus
                  each endpoint must decide which role to assume.  This choice determines
                  who begins the handshaking process as well as which type of messages
                  should be sent by each party.  The method {@link #setUseClientMode(boolean)} configures the mode.  Once the initial
                  handshaking has started, an &lt;code&gt;SSLEngine&lt;/code&gt; can not switch
                  between client and server modes, even when performing renegotiations.
                  &lt;P&gt;
                  Applications might choose to process delegated tasks in different
                  threads.  When an &lt;code&gt;SSLEngine&lt;/code&gt;
                  is created, the current {@link java.security.AccessControlContext}is saved.  All future delegated tasks will be processed using this
                  context:  that is, all access control decisions will be made using the
                  context captured at engine creation.
                  &lt;P&gt;
                  &lt;HR&gt;
                  &lt;B&gt;Concurrency Notes&lt;/B&gt;:
                  There are two concurrency issues to be aware of:
                  &lt;OL&gt;
                  &lt;li&gt;The &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;unwrap()&lt;/code&gt; methods
                  may execute concurrently of each other.
                  &lt;li&gt; The SSL/TLS protocols employ ordered packets.
                  Applications must take care to ensure that generated packets
                  are delivered in sequence.  If packets arrive
                  out-of-order, unexpected or fatal results may occur.
                  &lt;P&gt;
                  For example:
                  &lt;P&gt;
                  &lt;pre&gt;
                  synchronized (outboundLock) {
                  sslEngine.wrap(src, dst);
                  outboundQueue.put(dst);
                  }
                  &lt;/pre&gt;
                  As a corollary, two threads must not attempt to call the same method
                  (either &lt;code&gt;wrap()&lt;/code&gt; or &lt;code&gt;unwrap()&lt;/code&gt;) concurrently,
                  because there is no way to guarantee the eventual packet ordering.
                  &lt;/OL&gt;                
                <see>
                    SSLContext                    
                </see>
                <see>
                    SSLSocket                    
                </see>
                <see>
                    SSLServerSocket                    
                </see>
                <see>
                    SSLSession                    
                </see>
                <see>
                    java.net.Socket                    
                </see>
                <since>
                    1.5                    
                </since>
                <author>
                    Brad R. Wetmore                    
                </author>
            </javadoc>
            <declaration name="peerHost" type="String" line="373"/>
            <declaration name="peerPort" type="int" line="374"/>
            <javadoc line="376">
                Constructor for an &lt;code&gt;SSLEngine&lt;/code&gt; providing no hints
                  for an internal session reuse strategy.                
                <see>
                    SSLContext#createSSLEngine()                    
                </see>
                <see>
                    SSLSessionContext                    
                </see>
            </javadoc>
            <method name="SSLEngine" type="constructor" line="383"/>
            <javadoc line="386">
                Constructor for an &lt;code&gt;SSLEngine&lt;/code&gt;.
                  &lt;P&gt;
                  &lt;code&gt;SSLEngine&lt;/code&gt; implementations may use the
                  &lt;code&gt;peerHost&lt;/code&gt; and &lt;code&gt;peerPort&lt;/code&gt; parameters as hints
                  for their internal session reuse strategy.
                  &lt;P&gt;
                  Some cipher suites (such as Kerberos) require remote hostname
                  information. Implementations of this class should use this
                  constructor to use Kerberos.
                  &lt;P&gt;
                  The parameters are not authenticated by the
                  &lt;code&gt;SSLEngine&lt;/code&gt;.                
                <param>
                    peerHost the name of the peer host                    
                </param>
                <param>
                    peerPort the port number of the peer                    
                </param>
                <see>
                    SSLContext#createSSLEngine(String,int)                    
                </see>
                <see>
                    SSLSessionContext                    
                </see>
            </javadoc>
            <method name="SSLEngine" type="constructor" line="405">
                <params>
                    <param name="peerHost" type="String"/>
                    <param name="peerPort" type="int"/>
                </params>
            </method>
            <javadoc line="410">
                Returns the host name of the peer.
                  &lt;P&gt;
                  Note that the value is not authenticated, and should not be
                  relied upon.                
                <return>
                    the host name of the peer, or null if nothing is
                      available.                    
                </return>
            </javadoc>
            <method name="getPeerHost" type="String" line="419"/>
            <javadoc line="423">
                Returns the port number of the peer.
                  &lt;P&gt;
                  Note that the value is not authenticated, and should not be
                  relied upon.                
                <return>
                    the port number of the peer, or -1 if nothing is
                      available.                    
                </return>
            </javadoc>
            <method name="getPeerPort" type="int" line="432"/>
            <javadoc line="436">
                Attempts to encode a buffer of plaintext application data into
                  SSL/TLS network data.
                  &lt;P&gt;
                  An invocation of this method behaves in exactly the same manner
                  as the invocation:
                  &lt;blockquote&gt;&lt;pre&gt;{@link #wrap(ByteBuffer[],int,int,ByteBuffer)}engine.wrap(new ByteBuffer [] 
                  src }, 0, 1, dst);}
                  &lt;/pre&lt;/blockquote&gt;                
                <param>
                    srca &lt;code&gt;ByteBuffer&lt;/code&gt; containing outbound application data                    
                </param>
                <param>
                    dsta &lt;code&gt;ByteBuffer&lt;/code&gt; to hold outbound network data                    
                </param>
                <return>
                    an &lt;code&gt;SSLEngineResult&lt;/code&gt; describing the result
                      of this operation.                    
                </return>
                <throws>
                    SSLExceptionA problem was encountered while processing the
                      data that caused the &lt;code&gt;SSLEngine&lt;/code&gt; to abort.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    ReadOnlyBufferExceptionif the &lt;code&gt;dst&lt;/code&gt; buffer is read-only.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;dst&lt;/code&gt;
                      is null.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    #wrap(ByteBuffer[],int,int,ByteBuffer)                    
                </see>
            </javadoc>
            <method name="wrap" type="SSLEngineResult" line="468">
                <params>
                    <param name="src" type="ByteBuffer"/>
                    <param name="dst" type="ByteBuffer"/>
                </params>
            </method>
            <javadoc line="472">
                Attempts to encode plaintext bytes from a sequence of data
                  buffers into SSL/TLS network data.
                  &lt;P&gt;
                  An invocation of this method behaves in exactly the same manner
                  as the invocation:
                  &lt;blockquote&gt;&lt;pre&gt;{@link #wrap(ByteBuffer[],int,int,ByteBuffer)engine.wrap(srcs, 0, srcs.length, dst);}&lt;/pre&lt;/blockquote&gt;                
                <param>
                    srcsan array of &lt;code&gt;ByteBuffers&lt;/code&gt; containing the
                      outbound application data                    
                </param>
                <param>
                    dsta &lt;code&gt;ByteBuffer&lt;/code&gt; to hold outbound network data                    
                </param>
                <return>
                    an &lt;code&gt;SSLEngineResult&lt;/code&gt; describing the result
                      of this operation.                    
                </return>
                <throws>
                    SSLExceptionA problem was encountered while processing the
                      data that caused the &lt;code&gt;SSLEngine&lt;/code&gt; to abort.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    ReadOnlyBufferExceptionif the &lt;code&gt;dst&lt;/code&gt; buffer is read-only.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif either &lt;code&gt;srcs&lt;/code&gt; or &lt;code&gt;dst&lt;/code&gt;
                      is null, or if any element in &lt;code&gt;srcs&lt;/code&gt; is null.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    #wrap(ByteBuffer[],int,int,ByteBuffer)                    
                </see>
            </javadoc>
            <method name="wrap" type="SSLEngineResult" line="505">
                <params>
                    <param name="srcs" type="ByteBuffer[]"/>
                    <param name="dst" type="ByteBuffer"/>
                </params>
                <scope line="506"/>
            </method>
            <method name="wrap" type="SSLEngineResult" line="513"/>
            <javadoc line="513">
                Attempts to encode plaintext bytes from a subsequence of data
                  buffers into SSL/TLS network data.  This &lt;i&gt;&quot;gathering&quot;&lt;/i&gt;
                  operation encodes, in a single invocation, a sequence of bytes
                  from one or more of a given sequence of buffers.  Gathering
                  wraps are often useful when implementing network protocols or
                  file formats that, for example, group data into segments
                  consisting of one or more fixed-length headers followed by a
                  variable-length body.  See{@link java.nio.channels.GatheringByteChannel} for more
                  information on gathering, and {@link java.nio.channels.GatheringByteChannel#write(ByteBuffer[],int,int)} for more information on the subsequence
                  behavior.
                  &lt;P&gt;
                  Depending on the state of the SSLEngine, this method may produce
                  network data without consuming any application data (for example,
                  it may generate handshake data.)
                  &lt;P&gt;
                  The application is responsible for reliably transporting the
                  network data to the peer, and for ensuring that data created by
                  multiple calls to wrap() is transported in the same order in which
                  it was generated.  The application must properly synchronize
                  multiple calls to this method.
                  &lt;P&gt;
                  If this &lt;code&gt;SSLEngine&lt;/code&gt; has not yet started its initial
                  handshake, this method will automatically start the handshake.
                  &lt;P&gt;
                  This method will attempt to produce one SSL/TLS packet, and will
                  consume as much source data as possible, but will never consume
                  more than the sum of the bytes remaining in each buffer.  Each
                  &lt;code&gt;ByteBuffer&lt;/code&gt;&apos;s position is updated to reflect the
                  amount of data consumed or produced.  The limits remain the
                  same.
                  &lt;P&gt;
                  The underlying memory used by the &lt;code&gt;srcs&lt;/code&gt; and
                  &lt;code&gt;dst ByteBuffer&lt;/code&gt;s must not be the same.
                  &lt;P&gt;
                  See the class description for more information on engine closure.                
                <param>
                    srcsan array of &lt;code&gt;ByteBuffers&lt;/code&gt; containing the
                      outbound application data                    
                </param>
                <param>
                    offsetThe offset within the buffer array of the first buffer from
                      which bytes are to be retrieved; it must be non-negative
                      and no larger than &lt;code&gt;srcs.length&lt;/code&gt;                    
                </param>
                <param>
                    lengthThe maximum number of buffers to be accessed; it must be
                      non-negative and no larger than
                      &lt;code&gt;srcs.length&lt;/code&gt;&amp;nbsp;-&amp;nbsp;&lt;code&gt;offset&lt;/code&gt;                    
                </param>
                <param>
                    dsta &lt;code&gt;ByteBuffer&lt;/code&gt; to hold outbound network data                    
                </param>
                <return>
                    an &lt;code&gt;SSLEngineResult&lt;/code&gt; describing the result
                      of this operation.                    
                </return>
                <throws>
                    SSLExceptionA problem was encountered while processing the
                      data that caused the &lt;code&gt;SSLEngine&lt;/code&gt; to abort.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    IndexOutOfBoundsExceptionif the preconditions on the &lt;code&gt;offset&lt;/code&gt; and
                      &lt;code&gt;length&lt;/code&gt; parameters do not hold.                    
                </throws>
                <throws>
                    ReadOnlyBufferExceptionif the &lt;code&gt;dst&lt;/code&gt; buffer is read-only.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif either &lt;code&gt;srcs&lt;/code&gt; or &lt;code&gt;dst&lt;/code&gt;
                      is null, or if any element in the &lt;code&gt;srcs&lt;/code&gt;
                      subsequence specified is null.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    java.nio.channels.GatheringByteChannel                    
                </see>
                <see>
                    java.nio.channels.GatheringByteChannel#write(ByteBuffer[],int,int)                    
                </see>
            </javadoc>
            <javadoc line="591">
                Attempts to decode SSL/TLS network data into a plaintext
                  application data buffer.
                  &lt;P&gt;
                  An invocation of this method behaves in exactly the same manner
                  as the invocation:
                  &lt;blockquote&gt;&lt;pre&gt;{@link #unwrap(ByteBuffer,ByteBuffer[],int,int)}engine.unwrap(src, new ByteBuffer [] 
                  dst }, 0, 1);}
                  &lt;/pre&lt;/blockquote&gt;                
                <param>
                    srca &lt;code&gt;ByteBuffer&lt;/code&gt; containing inbound network data.                    
                </param>
                <param>
                    dsta &lt;code&gt;ByteBuffer&lt;/code&gt; to hold inbound application data.                    
                </param>
                <return>
                    an &lt;code&gt;SSLEngineResult&lt;/code&gt; describing the result
                      of this operation.                    
                </return>
                <throws>
                    SSLExceptionA problem was encountered while processing the
                      data that caused the &lt;code&gt;SSLEngine&lt;/code&gt; to abort.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    ReadOnlyBufferExceptionif the &lt;code&gt;dst&lt;/code&gt; buffer is read-only.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;dst&lt;/code&gt;
                      is null.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    #unwrap(ByteBuffer,ByteBuffer[],int,int)                    
                </see>
            </javadoc>
            <method name="unwrap" type="SSLEngineResult" line="623">
                <params>
                    <param name="src" type="ByteBuffer"/>
                    <param name="dst" type="ByteBuffer"/>
                </params>
            </method>
            <javadoc line="627">
                Attempts to decode SSL/TLS network data into a sequence of plaintext
                  application data buffers.
                  &lt;P&gt;
                  An invocation of this method behaves in exactly the same manner
                  as the invocation:
                  &lt;blockquote&gt;&lt;pre&gt;{@link #unwrap(ByteBuffer,ByteBuffer[],int,int)engine.unwrap(src, dsts, 0, dsts.length);}&lt;/pre&lt;/blockquote&gt;                
                <param>
                    srca &lt;code&gt;ByteBuffer&lt;/code&gt; containing inbound network data.                    
                </param>
                <param>
                    dstsan array of &lt;code&gt;ByteBuffer&lt;/code&gt;s to hold inbound
                      application data.                    
                </param>
                <return>
                    an &lt;code&gt;SSLEngineResult&lt;/code&gt; describing the result
                      of this operation.                    
                </return>
                <throws>
                    SSLExceptionA problem was encountered while processing the
                      data that caused the &lt;code&gt;SSLEngine&lt;/code&gt; to abort.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    ReadOnlyBufferExceptionif any of the &lt;code&gt;dst&lt;/code&gt; buffers are read-only.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;dsts&lt;/code&gt;
                      is null, or if any element in &lt;code&gt;dsts&lt;/code&gt; is null.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    #unwrap(ByteBuffer,ByteBuffer[],int,int)                    
                </see>
            </javadoc>
            <method name="unwrap" type="SSLEngineResult" line="660">
                <params>
                    <param name="src" type="ByteBuffer"/>
                    <param name="dsts" type="ByteBuffer[]"/>
                </params>
                <scope line="661"/>
            </method>
            <method name="unwrap" type="SSLEngineResult" line="667"/>
            <javadoc line="667">
                Attempts to decode SSL/TLS network data into a subsequence of
                  plaintext application data buffers.  This &lt;i&gt;&quot;scattering&quot;&lt;/i&gt;
                  operation decodes, in a single invocation, a sequence of bytes
                  into one or more of a given sequence of buffers.  Scattering
                  unwraps are often useful when implementing network protocols or
                  file formats that, for example, group data into segments
                  consisting of one or more fixed-length headers followed by a
                  variable-length body.  See{@link java.nio.channels.ScatteringByteChannel} for more
                  information on scattering, and {@link java.nio.channels.ScatteringByteChannel#read(ByteBuffer[],int,int)} for more information on the subsequence
                  behavior.
                  &lt;P&gt;
                  Depending on the state of the SSLEngine, this method may consume
                  network data without producing any application data (for example,
                  it may consume handshake data.)
                  &lt;P&gt;
                  The application is responsible for reliably obtaining the network
                  data from the peer, and for invoking unwrap() on the data in the
                  order it was received.  The application must properly synchronize
                  multiple calls to this method.
                  &lt;P&gt;
                  If this &lt;code&gt;SSLEngine&lt;/code&gt; has not yet started its initial
                  handshake, this method will automatically start the handshake.
                  &lt;P&gt;
                  This method will attempt to consume one complete SSL/TLS network
                  packet, but will never consume more than the sum of the bytes
                  remaining in the buffers.  Each &lt;code&gt;ByteBuffer&lt;/code&gt;&apos;s
                  position is updated to reflect the amount of data consumed or
                  produced.  The limits remain the same.
                  &lt;P&gt;
                  The underlying memory used by the &lt;code&gt;src&lt;/code&gt; and
                  &lt;code&gt;dsts ByteBuffer&lt;/code&gt;s must not be the same.
                  &lt;P&gt;
                  The inbound network buffer may be modified as a result of this
                  call:  therefore if the network data packet is required for some
                  secondary purpose, the data should be duplicated before calling this
                  method.  Note:  the network data will not be useful to a second
                  SSLEngine, as each SSLEngine contains unique random state which
                  influences the SSL/TLS messages.
                  &lt;P&gt;
                  See the class description for more information on engine closure.                
                <param>
                    srca &lt;code&gt;ByteBuffer&lt;/code&gt; containing inbound network data.                    
                </param>
                <param>
                    dstsan array of &lt;code&gt;ByteBuffer&lt;/code&gt;s to hold inbound
                      application data.                    
                </param>
                <param>
                    offsetThe offset within the buffer array of the first buffer from
                      which bytes are to be transferred; it must be non-negative
                      and no larger than &lt;code&gt;dsts.length&lt;/code&gt;.                    
                </param>
                <param>
                    lengthThe maximum number of buffers to be accessed; it must be
                      non-negative and no larger than
                      &lt;code&gt;dsts.length&lt;/code&gt;&amp;nbsp;-&amp;nbsp;&lt;code&gt;offset&lt;/code&gt;.                    
                </param>
                <return>
                    an &lt;code&gt;SSLEngineResult&lt;/code&gt; describing the result
                      of this operation.                    
                </return>
                <throws>
                    SSLExceptionA problem was encountered while processing the
                      data that caused the &lt;code&gt;SSLEngine&lt;/code&gt; to abort.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    IndexOutOfBoundsExceptionIf the preconditions on the &lt;code&gt;offset&lt;/code&gt; and
                      &lt;code&gt;length&lt;/code&gt; parameters do not hold.                    
                </throws>
                <throws>
                    ReadOnlyBufferExceptionif any of the &lt;code&gt;dst&lt;/code&gt; buffers are read-only.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;dsts&lt;/code&gt;
                      is null, or if any element in the &lt;code&gt;dsts&lt;/code&gt;
                      subsequence specified is null.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    java.nio.channels.ScatteringByteChannel                    
                </see>
                <see>
                    java.nio.channels.ScatteringByteChannel#read(ByteBuffer[],int,int)                    
                </see>
            </javadoc>
            <method name="getDelegatedTask" type="Runnable" line="751"/>
            <javadoc line="751">
                Returns a delegated &lt;code&gt;Runnable&lt;/code&gt; task for
                  this &lt;code&gt;SSLEngine&lt;/code&gt;.
                  &lt;P&gt;
                  &lt;code&gt;SSLEngine&lt;/code&gt; operations may require the results of
                  operations that block, or may take an extended period of time to
                  complete.  This method is used to obtain an outstanding {@link java.lang.Runnable} operation (task).  Each task must be assigned
                  a thread (possibly the current) to perform the {@link java.lang.Runnable#run() run} operation.  Once the
                  &lt;code&gt;run&lt;/code&gt; method returns, the &lt;code&gt;Runnable&lt;/code&gt; object
                  is no longer needed and may be discarded.
                  &lt;P&gt;
                  Delegated tasks run in the &lt;code&gt;AccessControlContext&lt;/code&gt;
                  in place when this object was created.
                  &lt;P&gt;
                  A call to this method will return each outstanding task
                  exactly once.
                  &lt;P&gt;
                  Multiple delegated tasks can be run in parallel.                
                <return>
                    a delegated &lt;code&gt;Runnable&lt;/code&gt; task, or null
                      if none are available.                    
                </return>
            </javadoc>
            <method name="closeInbound" type="void" line="778"/>
            <javadoc line="778">
                Signals that no more inbound network data will be sent
                  to this &lt;code&gt;SSLEngine&lt;/code&gt;.
                  &lt;P&gt;
                  If the application initiated the closing process by calling{@link #closeOutbound()}, under some circumstances it is not
                  required that the initiator wait for the peer&apos;s corresponding
                  close message.  (See section 7.2.1 of the TLS specification (&lt;A
                  HREF=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/A&gt;) for more
                  information on waiting for closure alerts.)  In such cases, this
                  method need not be called.
                  &lt;P&gt;
                  But if the application did not initiate the closure process, or
                  if the circumstances above do not apply, this method should be
                  called whenever the end of the SSL/TLS data stream is reached.
                  This ensures closure of the inbound side, and checks that the
                  peer followed the SSL/TLS close procedure properly, thus
                  detecting possible truncation attacks.
                  &lt;P&gt;
                  This method is idempotent:  if the inbound side has already
                  been closed, this method does not do anything.
                  &lt;P&gt;{@link #wrap(ByteBuffer,ByteBuffer) wrap()} should be
                  called to flush any remaining handshake data.                
                <throws>
                    SSLExceptionif this engine has not received the proper SSL/TLS close
                      notification message from the peer.                    
                </throws>
                <see>
                    #isInboundDone()                    
                </see>
                <see>
                    #isOutboundDone()                    
                </see>
            </javadoc>
            <method name="isInboundDone" type="boolean" line="813"/>
            <javadoc line="813">
                Returns whether {@link #unwrap(ByteBuffer,ByteBuffer)} will
                  accept any more inbound data messages.                
                <return>
                    true if the &lt;code&gt;SSLEngine&lt;/code&gt; will not
                      consume anymore network data (and by implication,
                      will not produce any more application data.)                    
                </return>
                <see>
                    #closeInbound()                    
                </see>
            </javadoc>
            <method name="closeOutbound" type="void" line="825"/>
            <javadoc line="825">
                Signals that no more outbound application data will be sent
                  on this &lt;code&gt;SSLEngine&lt;/code&gt;.
                  &lt;P&gt;
                  This method is idempotent:  if the outbound side has already
                  been closed, this method does not do anything.
                  &lt;P&gt;{@link #wrap(ByteBuffer,ByteBuffer)} should be
                  called to flush any remaining handshake data.                
                <see>
                    #isOutboundDone()                    
                </see>
            </javadoc>
            <method name="isOutboundDone" type="boolean" line="840"/>
            <javadoc line="840">
                Returns whether {@link #wrap(ByteBuffer,ByteBuffer)} will
                  produce any more outbound data messages.
                  &lt;P&gt;
                  Note that during the closure phase, a &lt;code&gt;SSLEngine&lt;/code&gt; may
                  generate handshake closure data that must be sent to the peer.
                  &lt;code&gt;wrap()&lt;/code&gt; must be called to generate this data.  When
                  this method returns true, no more outbound data will be created.                
                <return>
                    true if the &lt;code&gt;SSLEngine&lt;/code&gt; will not produce
                      any more network data                    
                </return>
                <see>
                    #closeOutbound()                    
                </see>
                <see>
                    #closeInbound()                    
                </see>
            </javadoc>
            <method name="getSupportedCipherSuites" type="String[]" line="858"/>
            <javadoc line="858">
                Returns the names of the cipher suites which could be enabled for use
                  on this engine.  Normally, only a subset of these will actually
                  be enabled by default, since this list may include cipher suites which
                  do not meet quality of service requirements for those defaults.  Such
                  cipher suites might be useful in specialized applications.                
                <return>
                    an array of cipher suite names                    
                </return>
                <see>
                    #getEnabledCipherSuites()                    
                </see>
                <see>
                    #setEnabledCipherSuites(String[])                    
                </see>
            </javadoc>
            <method name="getEnabledCipherSuites" type="String[]" line="872"/>
            <javadoc line="872">
                Returns the names of the SSL cipher suites which are currently
                  enabled for use on this engine.  When an SSLEngine is first
                  created, all enabled cipher suites support a minimum quality of
                  service.  Thus, in some environments this value might be empty.
                  &lt;P&gt;
                  Even if a suite has been enabled, it might never be used.  (For
                  example, the peer does not support it, the requisite
                  certificates/private keys for the suite are not available, or an
                  anonymous suite is enabled but authentication is required.)                
                <return>
                    an array of cipher suite names                    
                </return>
                <see>
                    #getSupportedCipherSuites()                    
                </see>
                <see>
                    #setEnabledCipherSuites(String[])                    
                </see>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="890"/>
            <javadoc line="890">
                Sets the cipher suites enabled for use on this engine.
                  &lt;P&gt;
                  Each cipher suite in the &lt;code&gt;suites&lt;/code&gt; parameter must have
                  been listed by getSupportedCipherSuites(), or the method will
                  fail.  Following a successful call to this method, only suites
                  listed in the &lt;code&gt;suites&lt;/code&gt; parameter are enabled for use.
                  &lt;P&gt;
                  See {@link #getEnabledCipherSuites()} for more information
                  on why a specific cipher suite may never be used on a engine.                
                <param>
                    suites Names of all the cipher suites to enable                    
                </param>
                <throws>
                    IllegalArgumentException when one or more of the ciphers
                      named by the parameter is not supported, or when the
                      parameter is null.                    
                </throws>
                <see>
                    #getSupportedCipherSuites()                    
                </see>
                <see>
                    #getEnabledCipherSuites()                    
                </see>
            </javadoc>
            <method name="getSupportedProtocols" type="String[]" line="911"/>
            <javadoc line="911">
                Returns the names of the protocols which could be enabled for use
                  with this &lt;code&gt;SSLEngine&lt;/code&gt;.                
                <return>
                    an array of protocols supported                    
                </return>
            </javadoc>
            <method name="getEnabledProtocols" type="String[]" line="920"/>
            <javadoc line="920">
                Returns the names of the protocol versions which are currently
                  enabled for use with this &lt;code&gt;SSLEngine&lt;/code&gt;.                
                <return>
                    an array of protocols                    
                </return>
                <see>
                    #setEnabledProtocols(String[])                    
                </see>
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="930"/>
            <javadoc line="930">
                Set the protocol versions enabled for use on this engine.
                  &lt;P&gt;
                  The protocols must have been listed by getSupportedProtocols()
                  as being supported.  Following a successful call to this method,
                  only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter
                  are enabled for use.                
                <param>
                    protocols Names of all the protocols to enable.                    
                </param>
                <throws>
                    IllegalArgumentException when one or more of
                      the protocols named by the parameter is not supported or
                      when the protocols parameter is null.                    
                </throws>
                <see>
                    #getEnabledProtocols()                    
                </see>
            </javadoc>
            <method name="getSession" type="SSLSession" line="947"/>
            <javadoc line="947">
                Returns the &lt;code&gt;SSLSession&lt;/code&gt; in use in this
                  &lt;code&gt;SSLEngine&lt;/code&gt;.
                  &lt;P&gt;
                  These can be long lived, and frequently correspond to an entire
                  login session for some user.  The session specifies a particular
                  cipher suite which is being actively used by all connections in
                  that session, as well as the identities of the session&apos;s client
                  and server.
                  &lt;P&gt;
                  Unlike {@link SSLSocket#getSession()}this method does not block until handshaking is complete.
                  &lt;P&gt;
                  Until the initial handshake has completed, this method returns
                  a session object which reports an invalid cipher suite of
                  &quot;SSL_NULL_WITH_NULL_NULL&quot;.                
                <return>
                    the &lt;code&gt;SSLSession&lt;/code&gt; for this &lt;code&gt;SSLEngine&lt;/code&gt;                    
                </return>
                <see>
                    SSLSession                    
                </see>
            </javadoc>
            <javadoc line="970">
                Returns the {@code SSLSession} being constructed during a SSL/TLS
                  handshake.
                  &lt;p&gt;
                  TLS protocols may negotiate parameters that are needed when using
                  an instance of this class, but before the {@code SSLSession} has
                  been completely initialized and made available via {@code getSession}.
                  For example, the list of valid signature algorithms may restrict
                  the type of certificates that can used during TrustManager
                  decisions, or the maximum TLS fragment packet sizes can be
                  resized to better support the network environment.
                  &lt;p&gt;
                  This method provides early access to the {@code SSLSession} being
                  constructed.  Depending on how far the handshake has progressed,
                  some data may not yet be available for use.  For example, if a
                  remote server will be sending a Certificate chain, but that chain
                  has yet not been processed, the {@code getPeerCertificates}method of {@code SSLSession} will throw a
                  SSLPeerUnverifiedException.  Once that chain has been processed,{@code getPeerCertificates} will return the proper value.                
                <see>
                    SSLSocket                    
                </see>
                <see>
                    SSLSession                    
                </see>
                <see>
                    ExtendedSSLSession                    
                </see>
                <see>
                    X509ExtendedKeyManager                    
                </see>
                <see>
                    X509ExtendedTrustManager                    
                </see>
                <return>
                    null if this instance is not currently handshaking, or
                      if the current handshake has not progressed far enough to
                      create a basic SSLSession.  Otherwise, this method returns the{@code SSLSession} currently being negotiated.                    
                </return>
                <throws>
                    UnsupportedOperationException if the underlying provider
                      does not implement the operation.                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getHandshakeSession" type="SSLSession" line="1006"/>
            <method name="beginHandshake" type="void" line="1011"/>
            <javadoc line="1011">
                Initiates handshaking (initial or renegotiation) on this SSLEngine.
                  &lt;P&gt;
                  This method is not needed for the initial handshake, as the
                  &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;unwrap()&lt;/code&gt; methods will
                  implicitly call this method if handshaking has not already begun.
                  &lt;P&gt;
                  Note that the peer may also request a session renegotiation with
                  this &lt;code&gt;SSLEngine&lt;/code&gt; by sending the appropriate
                  session renegotiate handshake message.
                  &lt;P&gt;
                  Unlike the {@link SSLSocket#startHandshake()SSLSocket#startHandshake()} method, this method does not block
                  until handshaking is completed.
                  &lt;P&gt;
                  To force a complete SSL/TLS session renegotiation, the current
                  session should be invalidated prior to calling this method.
                  &lt;P&gt;
                  Some protocols may not support multiple handshakes on an existing
                  engine and may throw an &lt;code&gt;SSLException&lt;/code&gt;.                
                <throws>
                    SSLExceptionif a problem was encountered while signaling the
                      &lt;code&gt;SSLEngine&lt;/code&gt; to begin a new handshake.
                      See the class description for more information on
                      engine closure.                    
                </throws>
                <throws>
                    IllegalStateException if the client/server mode
                      has not yet been set.                    
                </throws>
                <see>
                    SSLSession#invalidate()                    
                </see>
            </javadoc>
            <method name="getHandshakeStatus" type="SSLEngineResult.HandshakeStatus" line="1044"/>
            <javadoc line="1044">
                Returns the current handshake status for this &lt;code&gt;SSLEngine&lt;/code&gt;.                
                <return>
                    the current &lt;code&gt;SSLEngineResult.HandshakeStatus&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="setUseClientMode" type="void" line="1052"/>
            <javadoc line="1052">
                Configures the engine to use client (or server) mode when
                  handshaking.
                  &lt;P&gt;
                  This method must be called before any handshaking occurs.
                  Once handshaking has begun, the mode can not be reset for the
                  life of this engine.
                  &lt;P&gt;
                  Servers normally authenticate themselves, and clients
                  are not required to do so.                
                <param>
                    mode true if the engine should start its handshaking
                      in &quot;client&quot; mode                    
                </param>
                <throws>
                    IllegalArgumentException if a mode change is attempted
                      after the initial handshake has begun.                    
                </throws>
                <see>
                    #getUseClientMode()                    
                </see>
            </javadoc>
            <method name="getUseClientMode" type="boolean" line="1072"/>
            <javadoc line="1072">
                Returns true if the engine is set to use client mode when
                  handshaking.                
                <return>
                    true if the engine should do handshaking
                      in &quot;client&quot; mode                    
                </return>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="setNeedClientAuth" type="void" line="1083"/>
            <javadoc line="1083">
                Configures the engine to &lt;i&gt;require&lt;/i&gt; client authentication.  This
                  option is only useful for engines in the server mode.
                  &lt;P&gt;
                  An engine&apos;s client authentication setting is one of the following:
                  &lt;ul&gt;
                  &lt;li&gt; client authentication required
                  &lt;li&gt; client authentication requested
                  &lt;li&gt; no client authentication desired
                  &lt;/ul&gt;
                  &lt;P&gt;
                  Unlike {@link #setWantClientAuth(boolean)}, if this option is set and
                  the client chooses not to provide authentication information
                  about itself, &lt;i&gt;the negotiations will stop and the engine will
                  begin its closure procedure&lt;/i&gt;.
                  &lt;P&gt;
                  Calling this method overrides any previous setting made by
                  this method or {@link #setWantClientAuth(boolean)}.                
                <param>
                    need set to true if client authentication is required,
                      or false if no client authentication is desired.                    
                </param>
                <see>
                    #getNeedClientAuth()                    
                </see>
                <see>
                    #setWantClientAuth(boolean)                    
                </see>
                <see>
                    #getWantClientAuth()                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="getNeedClientAuth" type="boolean" line="1112"/>
            <javadoc line="1112">
                Returns true if the engine will &lt;i&gt;require&lt;/i&gt; client authentication.
                  This option is only useful to engines in the server mode.                
                <return>
                    true if client authentication is required,
                      or false if no client authentication is desired.                    
                </return>
                <see>
                    #setNeedClientAuth(boolean)                    
                </see>
                <see>
                    #setWantClientAuth(boolean)                    
                </see>
                <see>
                    #getWantClientAuth()                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="setWantClientAuth" type="void" line="1126"/>
            <javadoc line="1126">
                Configures the engine to &lt;i&gt;request&lt;/i&gt; client authentication.
                  This option is only useful for engines in the server mode.
                  &lt;P&gt;
                  An engine&apos;s client authentication setting is one of the following:
                  &lt;ul&gt;
                  &lt;li&gt; client authentication required
                  &lt;li&gt; client authentication requested
                  &lt;li&gt; no client authentication desired
                  &lt;/ul&gt;
                  &lt;P&gt;
                  Unlike {@link #setNeedClientAuth(boolean)}, if this option is set and
                  the client chooses not to provide authentication information
                  about itself, &lt;i&gt;the negotiations will continue&lt;/i&gt;.
                  &lt;P&gt;
                  Calling this method overrides any previous setting made by
                  this method or {@link #setNeedClientAuth(boolean)}.                
                <param>
                    want set to true if client authentication is requested,
                      or false if no client authentication is desired.                    
                </param>
                <see>
                    #getWantClientAuth()                    
                </see>
                <see>
                    #setNeedClientAuth(boolean)                    
                </see>
                <see>
                    #getNeedClientAuth()                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="getWantClientAuth" type="boolean" line="1154"/>
            <javadoc line="1154">
                Returns true if the engine will &lt;i&gt;request&lt;/i&gt; client authentication.
                  This option is only useful for engines in the server mode.                
                <return>
                    true if client authentication is requested,
                      or false if no client authentication is desired.                    
                </return>
                <see>
                    #setNeedClientAuth(boolean)                    
                </see>
                <see>
                    #getNeedClientAuth()                    
                </see>
                <see>
                    #setWantClientAuth(boolean)                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="1168"/>
            <javadoc line="1168">
                Controls whether new SSL sessions may be established by this engine.
                  If session creations are not allowed, and there are no
                  existing sessions to resume, there will be no successful
                  handshaking.                
                <param>
                    flag true indicates that sessions may be created; this
                      is the default.  false indicates that an existing session
                      must be resumed                    
                </param>
                <see>
                    #getEnableSessionCreation()                    
                </see>
            </javadoc>
            <method name="getEnableSessionCreation" type="boolean" line="1182"/>
            <javadoc line="1182">
                Returns true if new SSL sessions may be established by this engine.                
                <return>
                    true indicates that sessions may be created; this
                      is the default.  false indicates that an existing session
                      must be resumed                    
                </return>
                <see>
                    #setEnableSessionCreation(boolean)                    
                </see>
            </javadoc>
            <javadoc line="1192">
                Returns the SSLParameters in effect for this SSLEngine.
                  The ciphersuites and protocols of the returned SSLParameters
                  are always non-null.                
                <return>
                    the SSLParameters in effect for this SSLEngine.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getSSLParameters" type="SSLParameters" line="1200">
                <declaration name="params" type="SSLParameters" line="1201"/>
                <scope line="1204"/>
                <scope line="1206"/>
            </method>
            <javadoc line="1212">
                Applies SSLParameters to this engine.
                  &lt;p&gt;This means:
                  &lt;ul&gt;
                  &lt;li&gt;if &lt;code&gt;params.getCipherSuites()&lt;/code&gt; is non-null,
                  &lt;code&gt;setEnabledCipherSuites()&lt;/code&gt; is called with that value
                  &lt;li&gt;if &lt;code&gt;params.getProtocols()&lt;/code&gt; is non-null,
                  &lt;code&gt;setEnabledProtocols()&lt;/code&gt; is called with that value
                  &lt;li&gt;if &lt;code&gt;params.getNeedClientAuth()&lt;/code&gt; or
                  &lt;code&gt;params.getWantClientAuth()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;,
                  &lt;code&gt;setNeedClientAuth(true)&lt;/code&gt; and
                  &lt;code&gt;setWantClientAuth(true)&lt;/code&gt; are called, respectively;
                  otherwise &lt;code&gt;setWantClientAuth(false)&lt;/code&gt; is called.
                  &lt;/ul&gt;                
                <param>
                    params the parameters                    
                </param>
                <throws>
                    IllegalArgumentException if the setEnabledCipherSuites() or
                      the setEnabledProtocols() call fails                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setSSLParameters" type="void" line="1233">
                <params>
                    <param name="params" type="SSLParameters"/>
                </params>
                <declaration name="s" type="String[]" line="1234"/>
                <scope line="1236"/>
                <scope line="1240"/>
                <scope line="1243"/>
                <scope line="1245"/>
                <scope line="1247"/>
            </method>
        </class>
    </source>