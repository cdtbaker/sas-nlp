<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.net.ssl">
        <import package="java.io.IOException"/>
        <import package="java.net"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Vector"/>
        <class name="SSLSocket" line="35">
            <extends class="Socket"/>
            <javadoc line="35">
                This class extends &lt;code&gt;Socket&lt;/code&gt;s and provides secure
                  socket using protocols such as the &quot;Secure
                  Sockets Layer&quot; (SSL) or IETF &quot;Transport Layer Security&quot; (TLS) protocols.
                  &lt;P&gt;
                  Such sockets are normal stream sockets, but they
                  add a layer of security protections over the underlying network transport
                  protocol, such as TCP.  Those protections include: &lt;UL&gt;
                  &lt;LI&gt; &lt;em&gt;Integrity Protection&lt;/em&gt;.  SSL protects against
                  modification of messages by an active wiretapper.
                  &lt;LI&gt; &lt;em&gt;Authentication&lt;/em&gt;.  In most modes, SSL provides
                  peer authentication.  Servers are usually authenticated,
                  and clients may be authenticated as requested by servers.
                  &lt;LI&gt; &lt;em&gt;Confidentiality (Privacy Protection)&lt;/em&gt;.  In most
                  modes, SSL encrypts data being sent between client and server.
                  This protects the confidentiality of data, so that passive
                  wiretappers won&apos;t see sensitive data such as financial
                  information or personal information of many kinds.
                  &lt;/UL&gt;
                  &lt;P&gt;These kinds of protection are specified by a &quot;cipher suite&quot;, which
                  is a combination of cryptographic algorithms used by a given SSL connection.
                  During the negotiation process, the two endpoints must agree on
                  a ciphersuite that is available in both environments.
                  If there is no such suite in common, no SSL connection can
                  be established, and no data can be exchanged.
                  &lt;P&gt; The cipher suite used is established by a negotiation process
                  called &quot;handshaking&quot;.  The goal of this
                  process is to create or rejoin a &quot;session&quot;, which may protect many
                  connections over time.  After handshaking has completed, you can access
                  session attributes by using the &lt;em&gt;getSession&lt;/em&gt; method.
                  The initial handshake on this connection can be initiated in
                  one of three ways: &lt;UL&gt;
                  &lt;LI&gt; calling &lt;code&gt;startHandshake&lt;/code&gt; which explicitly
                  begins handshakes, or
                  &lt;LI&gt; any attempt to read or write application data on
                  this socket causes an implicit handshake, or
                  &lt;LI&gt; a call to &lt;code&gt;getSession&lt;/code&gt; tries to set up a session
                  if there is no currently valid session, and
                  an implicit handshake is done.
                  &lt;/UL&gt;
                  &lt;P&gt;If handshaking fails for any reason, the &lt;code&gt;SSLSocket&lt;/code&gt;
                  is closed, and no futher communications can be done.
                  &lt;P&gt;There are two groups of cipher suites which you will need to know
                  about when managing cipher suites: &lt;UL&gt;
                  &lt;LI&gt; &lt;em&gt;Supported&lt;/em&gt; cipher suites:  all the suites which are
                  supported by the SSL implementation.  This list is reported
                  using &lt;em&gt;getSupportedCipherSuites&lt;/em&gt;.
                  &lt;LI&gt; &lt;em&gt;Enabled&lt;/em&gt; cipher suites, which may be fewer
                  than the full set of supported suites.  This group is
                  set using the &lt;em&gt;setEnabledCipherSuites&lt;/em&gt; method, and
                  queried using the &lt;em&gt;getEnabledCipherSuites&lt;/em&gt; method.
                  Initially, a default set of cipher suites will be enabled on
                  a new socket that represents the minimum suggested configuration.
                  &lt;/UL&gt;
                  &lt;P&gt; Implementation defaults require that only cipher
                  suites which authenticate servers and provide confidentiality
                  be enabled by default.
                  Only if both sides explicitly agree to unauthenticated and/or
                  non-private (unencrypted) communications will such a ciphersuite be
                  selected.
                  &lt;P&gt;When &lt;code&gt;SSLSocket&lt;/code&gt;s are first created, no handshaking
                  is done so that applications may first set their communication
                  preferences:  what cipher suites to use, whether the socket should be
                  in client or server mode, etc.
                  However, security is always provided by the time that application data
                  is sent over the connection.
                  &lt;P&gt; You may register to receive event notification of handshake
                  completion.  This involves
                  the use of two additional classes.  &lt;em&gt;HandshakeCompletedEvent&lt;/em&gt;
                  objects are passed to &lt;em&gt;HandshakeCompletedListener&lt;/em&gt; instances,
                  which are registered by users of this API.
                  &lt;code&gt;SSLSocket&lt;/code&gt;s are created by &lt;code&gt;SSLSocketFactory&lt;/code&gt;s,
                  or by &lt;code&gt;accept&lt;/code&gt;ing a connection from a
                  &lt;code&gt;SSLServerSocket&lt;/code&gt;.
                  &lt;P&gt;A SSL socket must choose to operate in the client or server mode.
                  This will determine who begins the handshaking process, as well
                  as which messages should be sent by each party.  Each
                  connection must have one client and one server, or handshaking
                  will not progress properly.  Once the initial handshaking has started, a
                  socket can not switch between client and server modes, even when
                  performing renegotiations.                
                <see>
                    java.net.Socket                    
                </see>
                <see>
                    SSLServerSocket                    
                </see>
                <see>
                    SSLSocketFactory                    
                </see>
                <since>
                    1.4                    
                </since>
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <javadoc line="143">
                Used only by subclasses.
                  Constructs an uninitialized, unconnected TCP socket.                
            </javadoc>
            <method name="SSLSocket" type="constructor" line="148"/>
            <javadoc line="151">
                Used only by subclasses.
                  Constructs a TCP connection to a named host at a specified port.
                  This acts as the SSL client.
                  &lt;p&gt;
                  If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt;
                  method is called with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    host name of the host with which to connect, or
                      <code>null</code> for the loopback address.                    
                </param>
                <param>
                    port number of the server's port                    
                </param>
                <throws>
                    IOException if an I/O error occurs when creating the socket                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </throws>
                <throws>
                    UnknownHostException if the host is not known                    
                </throws>
                <throws>
                    IllegalArgumentException if the port parameter is outside the
                      specified range of valid port values, which is between 0 and
                      65535, inclusive.                    
                </throws>
                <see>
                    SecurityManager#checkConnect                    
                </see>
            </javadoc>
            <method name="SSLSocket" type="constructor" line="174">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="177">
                Used only by subclasses.
                  Constructs a TCP connection to a server at a specified address
                  and port.  This acts as the SSL client.
                  &lt;p&gt;
                  If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt;
                  method is called with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    address the server's host                    
                </param>
                <param>
                    port its port                    
                </param>
                <throws>
                    IOException if an I/O error occurs when creating the socket                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </throws>
                <throws>
                    IllegalArgumentException if the port parameter is outside the
                      specified range of valid port values, which is between 0 and
                      65535, inclusive.                    
                </throws>
                <throws>
                    NullPointerException if <code>address</code> is null.                    
                </throws>
                <see>
                    SecurityManager#checkConnect                    
                </see>
            </javadoc>
            <method name="SSLSocket" type="constructor" line="199">
                <params>
                    <param name="address" type="InetAddress"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="202">
                Used only by subclasses.
                  Constructs an SSL connection to a named host at a specified port,
                  binding the client side of the connection a given address and port.
                  This acts as the SSL client.
                  &lt;p&gt;
                  If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt;
                  method is called with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    host name of the host with which to connect, or
                      <code>null</code> for the loopback address.                    
                </param>
                <param>
                    port number of the server's port                    
                </param>
                <param>
                    clientAddress the client's address the socket is bound to, or
                      <code>null</code> for the <code>anyLocal</code> address.                    
                </param>
                <param>
                    clientPort the client's port the socket is bound to, or
                      <code>zero</code> for a system selected free port.                    
                </param>
                <throws>
                    IOException if an I/O error occurs when creating the socket                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </throws>
                <throws>
                    UnknownHostException if the host is not known                    
                </throws>
                <throws>
                    IllegalArgumentException if the port parameter or clientPort
                      parameter is outside the specified range of valid port values,
                      which is between 0 and 65535, inclusive.                    
                </throws>
                <see>
                    SecurityManager#checkConnect                    
                </see>
            </javadoc>
            <method name="SSLSocket" type="constructor" line="231">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="clientAddress" type="InetAddress"/>
                    <param name="clientPort" type="int"/>
                </params>
            </method>
            <javadoc line="234">
                Used only by subclasses.
                  Constructs an SSL connection to a server at a specified address
                  and TCP port, binding the client side of the connection a given
                  address and port.  This acts as the SSL client.
                  &lt;p&gt;
                  If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt;
                  method is called with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    address the server's host                    
                </param>
                <param>
                    port its port                    
                </param>
                <param>
                    clientAddress the client's address the socket is bound to, or
                      <code>null</code> for the <code>anyLocal</code> address.                    
                </param>
                <param>
                    clientPort the client's port the socket is bound to, or
                      <code>zero</code> for a system selected free port.                    
                </param>
                <throws>
                    IOException if an I/O error occurs when creating the socket                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </throws>
                <throws>
                    IllegalArgumentException if the port parameter or clientPort
                      parameter is outside the specified range of valid port values,
                      which is between 0 and 65535, inclusive.                    
                </throws>
                <throws>
                    NullPointerException if <code>address</code> is null.                    
                </throws>
                <see>
                    SecurityManager#checkConnect                    
                </see>
            </javadoc>
            <method name="SSLSocket" type="constructor" line="262">
                <params>
                    <param name="address" type="InetAddress"/>
                    <param name="port" type="int"/>
                    <param name="clientAddress" type="InetAddress"/>
                    <param name="clientPort" type="int"/>
                </params>
            </method>
            <method name="getSupportedCipherSuites" type="String[]" line="265"/>
            <javadoc line="265">
                Returns the names of the cipher suites which could be enabled for use
                  on this connection.  Normally, only a subset of these will actually
                  be enabled by default, since this list may include cipher suites which
                  do not meet quality of service requirements for those defaults.  Such
                  cipher suites might be useful in specialized applications.                
                <return>
                    an array of cipher suite names                    
                </return>
                <see>
                    #getEnabledCipherSuites()                    
                </see>
                <see>
                    #setEnabledCipherSuites(String[])                    
                </see>
            </javadoc>
            <method name="getEnabledCipherSuites" type="String[]" line="279"/>
            <javadoc line="279">
                Returns the names of the SSL cipher suites which are currently
                  enabled for use on this connection.  When an SSLSocket is first
                  created, all enabled cipher suites support a minimum quality of
                  service.  Thus, in some environments this value might be empty.
                  &lt;P&gt;
                  Even if a suite has been enabled, it might never be used.  (For
                  example, the peer does not support it, the requisite certificates
                  (and private keys) for the suite are not available, or an
                  anonymous suite is enabled but authentication is required.                
                <return>
                    an array of cipher suite names                    
                </return>
                <see>
                    #getSupportedCipherSuites()                    
                </see>
                <see>
                    #setEnabledCipherSuites(String[])                    
                </see>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="297"/>
            <javadoc line="297">
                Sets the cipher suites enabled for use on this connection.
                  &lt;P&gt;
                  Each cipher suite in the &lt;code&gt;suites&lt;/code&gt; parameter must have
                  been listed by getSupportedCipherSuites(), or the method will
                  fail.  Following a successful call to this method, only suites
                  listed in the &lt;code&gt;suites&lt;/code&gt; parameter are enabled for use.
                  &lt;P&gt;
                  See {@link #getEnabledCipherSuites()} for more information
                  on why a specific ciphersuite may never be used on a connection.                
                <param>
                    suites Names of all the cipher suites to enable                    
                </param>
                <throws>
                    IllegalArgumentException when one or more of the ciphers
                      named by the parameter is not supported, or when the
                      parameter is null.                    
                </throws>
                <see>
                    #getSupportedCipherSuites()                    
                </see>
                <see>
                    #getEnabledCipherSuites()                    
                </see>
            </javadoc>
            <method name="getSupportedProtocols" type="String[]" line="318"/>
            <javadoc line="318">
                Returns the names of the protocols which could be enabled for use
                  on an SSL connection.                
                <return>
                    an array of protocols supported                    
                </return>
            </javadoc>
            <method name="getEnabledProtocols" type="String[]" line="327"/>
            <javadoc line="327">
                Returns the names of the protocol versions which are currently
                  enabled for use on this connection.                
                <see>
                    #setEnabledProtocols(String[])                    
                </see>
                <return>
                    an array of protocols                    
                </return>
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="336"/>
            <javadoc line="336">
                Sets the protocol versions enabled for use on this connection.
                  &lt;P&gt;
                  The protocols must have been listed by
                  &lt;code&gt;getSupportedProtocols()&lt;/code&gt; as being supported.
                  Following a successful call to this method, only protocols listed
                  in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.                
                <param>
                    protocols Names of all the protocols to enable.                    
                </param>
                <throws>
                    IllegalArgumentException when one or more of
                      the protocols named by the parameter is not supported or
                      when the protocols parameter is null.                    
                </throws>
                <see>
                    #getEnabledProtocols()                    
                </see>
            </javadoc>
            <method name="getSession" type="SSLSession" line="353"/>
            <javadoc line="353">
                Returns the SSL Session in use by this connection.  These can
                  be long lived, and frequently correspond to an entire login session
                  for some user.  The session specifies a particular cipher suite
                  which is being actively used by all connections in that session,
                  as well as the identities of the session&apos;s client and server.
                  &lt;P&gt;
                  This method will initiate the initial handshake if
                  necessary and then block until the handshake has been
                  established.
                  &lt;P&gt;
                  If an error occurs during the initial handshake, this method
                  returns an invalid session object which reports an invalid
                  cipher suite of &quot;SSL_NULL_WITH_NULL_NULL&quot;.                
                <return>
                    the <code>SSLSession</code>                    
                </return>
            </javadoc>
            <javadoc line="373">
                Returns the {@code SSLSession} being constructed during a SSL/TLS
                  handshake.
                  &lt;p&gt;
                  TLS protocols may negotiate parameters that are needed when using
                  an instance of this class, but before the {@code SSLSession} has
                  been completely initialized and made available via {@code getSession}.
                  For example, the list of valid signature algorithms may restrict
                  the type of certificates that can used during TrustManager
                  decisions, or the maximum TLS fragment packet sizes can be
                  resized to better support the network environment.
                  &lt;p&gt;
                  This method provides early access to the {@code SSLSession} being
                  constructed.  Depending on how far the handshake has progressed,
                  some data may not yet be available for use.  For example, if a
                  remote server will be sending a Certificate chain, but that chain
                  has yet not been processed, the {@code getPeerCertificates}method of {@code SSLSession} will throw a
                  SSLPeerUnverifiedException.  Once that chain has been processed,{@code getPeerCertificates} will return the proper value.
                  &lt;p&gt;
                  Unlike {@link #getSession()}, this method does not initiate the
                  initial handshake and does not block until handshaking is
                  complete.                
                <see>
                    SSLEngine                    
                </see>
                <see>
                    SSLSession                    
                </see>
                <see>
                    ExtendedSSLSession                    
                </see>
                <see>
                    X509ExtendedKeyManager                    
                </see>
                <see>
                    X509ExtendedTrustManager                    
                </see>
                <return>
                    null if this instance is not currently handshaking, or
                      if the current handshake has not progressed far enough to
                      create a basic SSLSession.  Otherwise, this method returns the{@code SSLSession} currently being negotiated.                    
                </return>
                <throws>
                    UnsupportedOperationException if the underlying provider
                      does not implement the operation.                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getHandshakeSession" type="SSLSession" line="413"/>
            <method name="addHandshakeCompletedListener" type="void" line="418"/>
            <javadoc line="418">
                Registers an event listener to receive notifications that an
                  SSL handshake has completed on this connection.                
                <param>
                    listener the HandShake Completed event listener                    
                </param>
                <see>
                    #startHandshake()                    
                </see>
                <see>
                    #removeHandshakeCompletedListener(HandshakeCompletedListener)                    
                </see>
                <throws>
                    IllegalArgumentException if the argument is null.                    
                </throws>
            </javadoc>
            <method name="removeHandshakeCompletedListener" type="void" line="431"/>
            <javadoc line="431">
                Removes a previously registered handshake completion listener.                
                <param>
                    listener the HandShake Completed event listener                    
                </param>
                <throws>
                    IllegalArgumentException if the listener is not registered,
                      or the argument is null.                    
                </throws>
                <see>
                    #addHandshakeCompletedListener(HandshakeCompletedListener)                    
                </see>
            </javadoc>
            <method name="startHandshake" type="void" line="443"/>
            <javadoc line="443">
                Starts an SSL handshake on this connection.  Common reasons include
                  a need to use new encryption keys, to change cipher suites, or to
                  initiate a new session.  To force complete reauthentication, the
                  current session could be invalidated before starting this handshake.
                  &lt;P&gt; If data has already been sent on the connection, it continues
                  to flow during this handshake.  When the handshake completes, this
                  will be signaled with an event.
                  This method is synchronous for the initial handshake on a connection
                  and returns when the negotiated handshake is complete. Some
                  protocols may not support multiple handshakes on an existing socket
                  and may throw an IOException.                
                <throws>
                    IOException on a network level error                    
                </throws>
                <see>
                    #addHandshakeCompletedListener(HandshakeCompletedListener)                    
                </see>
            </javadoc>
            <method name="setUseClientMode" type="void" line="464"/>
            <javadoc line="464">
                Configures the socket to use client (or server) mode when
                  handshaking.
                  &lt;P&gt;
                  This method must be called before any handshaking occurs.
                  Once handshaking has begun, the mode can not be reset for the
                  life of this socket.
                  &lt;P&gt;
                  Servers normally authenticate themselves, and clients
                  are not required to do so.                
                <param>
                    mode true if the socket should start its handshaking
                      in "client" mode                    
                </param>
                <throws>
                    IllegalArgumentException if a mode change is attempted
                      after the initial handshake has begun.                    
                </throws>
                <see>
                    #getUseClientMode()                    
                </see>
            </javadoc>
            <method name="getUseClientMode" type="boolean" line="484"/>
            <javadoc line="484">
                Returns true if the socket is set to use client mode when
                  handshaking.                
                <return>
                    true if the socket should do handshaking
                      in "client" mode                    
                </return>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="setNeedClientAuth" type="void" line="495"/>
            <javadoc line="495">
                Configures the socket to &lt;i&gt;require&lt;/i&gt; client authentication.  This
                  option is only useful for sockets in the server mode.
                  &lt;P&gt;
                  A socket&apos;s client authentication setting is one of the following:
                  &lt;ul&gt;
                  &lt;li&gt; client authentication required
                  &lt;li&gt; client authentication requested
                  &lt;li&gt; no client authentication desired
                  &lt;/ul&gt;
                  &lt;P&gt;
                  Unlike {@link #setWantClientAuth(boolean)}, if this option is set and
                  the client chooses not to provide authentication information
                  about itself, &lt;i&gt;the negotiations will stop and the connection
                  will be dropped&lt;/i&gt;.
                  &lt;P&gt;
                  Calling this method overrides any previous setting made by
                  this method or {@link #setWantClientAuth(boolean)}.                
                <param>
                    need set to true if client authentication is required,
                      or false if no client authentication is desired.                    
                </param>
                <see>
                    #getNeedClientAuth()                    
                </see>
                <see>
                    #setWantClientAuth(boolean)                    
                </see>
                <see>
                    #getWantClientAuth()                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="getNeedClientAuth" type="boolean" line="524"/>
            <javadoc line="524">
                Returns true if the socket will &lt;i&gt;require&lt;/i&gt; client authentication.
                  This option is only useful to sockets in the server mode.                
                <return>
                    true if client authentication is required,
                      or false if no client authentication is desired.                    
                </return>
                <see>
                    #setNeedClientAuth(boolean)                    
                </see>
                <see>
                    #setWantClientAuth(boolean)                    
                </see>
                <see>
                    #getWantClientAuth()                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="setWantClientAuth" type="void" line="538"/>
            <javadoc line="538">
                Configures the socket to &lt;i&gt;request&lt;/i&gt; client authentication.
                  This option is only useful for sockets in the server mode.
                  &lt;P&gt;
                  A socket&apos;s client authentication setting is one of the following:
                  &lt;ul&gt;
                  &lt;li&gt; client authentication required
                  &lt;li&gt; client authentication requested
                  &lt;li&gt; no client authentication desired
                  &lt;/ul&gt;
                  &lt;P&gt;
                  Unlike {@link #setNeedClientAuth(boolean)}, if this option is set and
                  the client chooses not to provide authentication information
                  about itself, &lt;i&gt;the negotiations will continue&lt;/i&gt;.
                  &lt;P&gt;
                  Calling this method overrides any previous setting made by
                  this method or {@link #setNeedClientAuth(boolean)}.                
                <param>
                    want set to true if client authentication is requested,
                      or false if no client authentication is desired.                    
                </param>
                <see>
                    #getWantClientAuth()                    
                </see>
                <see>
                    #setNeedClientAuth(boolean)                    
                </see>
                <see>
                    #getNeedClientAuth()                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="getWantClientAuth" type="boolean" line="566"/>
            <javadoc line="566">
                Returns true if the socket will &lt;i&gt;request&lt;/i&gt; client authentication.
                  This option is only useful for sockets in the server mode.                
                <return>
                    true if client authentication is requested,
                      or false if no client authentication is desired.                    
                </return>
                <see>
                    #setNeedClientAuth(boolean)                    
                </see>
                <see>
                    #getNeedClientAuth()                    
                </see>
                <see>
                    #setWantClientAuth(boolean)                    
                </see>
                <see>
                    #setUseClientMode(boolean)                    
                </see>
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="580"/>
            <javadoc line="580">
                Controls whether new SSL sessions may be established by this socket.
                  If session creations are not allowed, and there are no
                  existing sessions to resume, there will be no successful
                  handshaking.                
                <param>
                    flag true indicates that sessions may be created; this
                      is the default.  false indicates that an existing session
                      must be resumed                    
                </param>
                <see>
                    #getEnableSessionCreation()                    
                </see>
            </javadoc>
            <method name="getEnableSessionCreation" type="boolean" line="594"/>
            <javadoc line="594">
                Returns true if new SSL sessions may be established by this socket.                
                <return>
                    true indicates that sessions may be created; this
                      is the default.  false indicates that an existing session
                      must be resumed                    
                </return>
                <see>
                    #setEnableSessionCreation(boolean)                    
                </see>
            </javadoc>
            <javadoc line="604">
                Returns the SSLParameters in effect for this SSLSocket.
                  The ciphersuites and protocols of the returned SSLParameters
                  are always non-null.                
                <return>
                    the SSLParameters in effect for this SSLSocket.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getSSLParameters" type="SSLParameters" line="612">
                <declaration name="params" type="SSLParameters" line="613"/>
                <scope line="616"/>
                <scope line="618"/>
            </method>
            <javadoc line="624">
                Applies SSLParameters to this socket.
                  &lt;p&gt;This means:
                  &lt;ul&gt;
                  &lt;li&gt;if &lt;code&gt;params.getCipherSuites()&lt;/code&gt; is non-null,
                  &lt;code&gt;setEnabledCipherSuites()&lt;/code&gt; is called with that value
                  &lt;li&gt;if &lt;code&gt;params.getProtocols()&lt;/code&gt; is non-null,
                  &lt;code&gt;setEnabledProtocols()&lt;/code&gt; is called with that value
                  &lt;li&gt;if &lt;code&gt;params.getNeedClientAuth()&lt;/code&gt; or
                  &lt;code&gt;params.getWantClientAuth()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;,
                  &lt;code&gt;setNeedClientAuth(true)&lt;/code&gt; and
                  &lt;code&gt;setWantClientAuth(true)&lt;/code&gt; are called, respectively;
                  otherwise &lt;code&gt;setWantClientAuth(false)&lt;/code&gt; is called.
                  &lt;/ul&gt;                
                <param>
                    params the parameters                    
                </param>
                <throws>
                    IllegalArgumentException if the setEnabledCipherSuites() or
                      the setEnabledProtocols() call fails                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setSSLParameters" type="void" line="645">
                <params>
                    <param name="params" type="SSLParameters"/>
                </params>
                <declaration name="s" type="String[]" line="646"/>
                <scope line="648"/>
                <scope line="652"/>
                <scope line="655"/>
                <scope line="657"/>
                <scope line="659"/>
            </method>
        </class>
    </source>