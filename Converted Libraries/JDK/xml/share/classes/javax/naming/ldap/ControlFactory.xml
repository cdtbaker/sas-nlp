<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.naming.ldap">
        <import package="javax.naming.NamingException"/>
        <import package="javax.naming.Context"/>
        <import package="java.util.Hashtable"/>
        <import package="com.sun.naming.internal.FactoryEnumeration"/>
        <import package="com.sun.naming.internal.ResourceManager"/>
        <class name="ControlFactory" line="37">
            <comment line="55">
                Creates a new instance of a control factory.                
            </comment>
            <javadoc line="37">
                This abstract class represents a factory for creating LDAPv3 controls.
                  LDAPv3 controls are defined in
                  &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251&lt;/A&gt;.
                  &lt;p&gt;
                  When a service provider receives a response control, it uses control
                  factories to return the specific/appropriate control class implementation.                
                <author>
                    Rosanna Lee                    
                </author>
                <author>
                    Scott Seligman                    
                </author>
                <author>
                    Vincent Ryan                    
                </author>
                <see>
                    Control                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="ControlFactory" type="constructor" line="57"/>
            <method name="getControlInstance" type="Control" line="60"/>
            <javadoc line="60">
                Creates a control using this control factory.
                  &lt;p&gt;
                  The factory is used by the service provider to return controls
                  that it reads from the LDAP protocol as specialized control classes.
                  Without this mechanism, the provider would be returning
                  controls that only contained data in BER encoded format.
                  &lt;p&gt;
                  Typically, &lt;tt&gt;ctl&lt;/tt&gt; is a &quot;basic&quot; control containing
                  BER encoded data. The factory is used to create a specialized
                  control implementation, usually by decoding the BER encoded data,
                  that provides methods to access that data in a type-safe and friendly
                  manner.
                  &lt;p&gt;
                  For example, a factory might use the BER encoded data in
                  basic control and return an instance of a VirtualListReplyControl.
                  &lt;p&gt;
                  If this factory cannot create a control using the argument supplied,
                  it should return null.
                  A factory should only throw an exception if it is sure that
                  it is the only intended factory and that no other control factories
                  should be tried. This might happen, for example, if the BER data
                  in the control does not match what is expected of a control with
                  the given OID. Since this method throws &lt;tt&gt;NamingException&lt;/tt&gt;,
                  any other internally generated exception that should be propagated
                  must be wrapped inside a &lt;tt&gt;NamingException&lt;/tt&gt;.                
                <param>
                    ctl A non-null control.                    
                </param>
                <return>
                    A possibly null Control.                    
                </return>
                <exception>
                    NamingException If <tt>ctl</tt> contains invalid data that prevents it
                      from being used to create a control. A factory should only throw
                      an exception if it knows how to produce the control (identified by the OID)
                      but is unable to because of, for example invalid BER data.                    
                </exception>
            </javadoc>
            <javadoc line="97">
                Creates a control using known control factories.
                  &lt;p&gt;
                  The following rule is used to create the control:
                  &lt;ul&gt;
                  &lt;li&gt; Use the control factories specified in
                  the &lt;tt&gt;LdapContext.CONTROL_FACTORIES&lt;/tt&gt; property of the
                  environment, and of the provider resource file associated with
                  &lt;tt&gt;ctx&lt;/tt&gt;, in that order.
                  The value of this property is a colon-separated list of factory
                  class names that are tried in order, and the first one that succeeds
                  in creating the control is the one used.
                  If none of the factories can be loaded,
                  return &lt;code&gt;ctl&lt;/code&gt;.
                  If an exception is encountered while creating the control, the
                  exception is passed up to the caller.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  Note that a control factory
                  must be public and must have a public constructor that accepts no arguments.
                  &lt;p&gt;                
                <param>
                    ctl The non-null control object containing the OID and BER data.                    
                </param>
                <param>
                    ctx The possibly null context in which the control is being created.
                      If null, no such information is available.                    
                </param>
                <param>
                    env The possibly null environment of the context. This is used
                      to find the value of the <tt>LdapContext.CONTROL_FACTORIES</tt> property.                    
                </param>
                <return>
                    A control object created using <code>ctl</code>; or
                      <code>ctl</code> if a control object cannot be created using
                      the algorithm described above.                    
                </return>
                <exception>
                    NamingException if a naming exception was encountered
                      while attempting to create the control object.
                      If one of the factories accessed throws an
                      exception, it is propagated up to the caller.
                      If an error was encountered while loading
                      and instantiating the factory and object classes, the exception
                      is wrapped inside a <tt>NamingException</tt> and then rethrown.                    
                </exception>
            </javadoc>
            <method name="getControlInstance" type="Control" line="136">
                <params>
                    <param name="ctl" type="Control"/>
                    <param name="ctx" type="Context"/>
                    <param name="env" type="Hashtable<?,?>"/>
                </params>
                <comment line="138">
                    Get object factories list from environment properties or                    
                </comment>
                <comment line="139">
                    provider resource file.                    
                </comment>
                <comment line="147">
                    Try each factory until one succeeds                    
                </comment>
                <declaration name="factories" type="FactoryEnumeration" line="140"/>
                <scope line="143"/>
                <declaration name="answer" type="Control" line="148"/>
                <declaration name="factory" type="ControlFactory" line="149"/>
                <scope line="150"/>
            </method>
        </class>
    </source>