<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.naming">
        <import package="java.util.Enumeration"/>
        <import package="java.util.Properties"/>
        <class name="CompositeName" line="31">
            <comment line="594">
                %%% Test code for serialization.
                public static void main(String[] args) throws Exception {
                CompositeName c = new CompositeName(&quot;aaabbb&quot;);
                java.io.FileOutputStream f1 = new java.io.FileOutputStream(&quot;tmpser&quot;);
                java.io.ObjectOutputStream s1 = new java.io.ObjectOutputStream(f1);
                s1.writeObject(c);
                s1.close();
                java.io.FileInputStream f2 = new java.io.FileInputStream(&quot;tmpser&quot;);
                java.io.ObjectInputStream s2 = new java.io.ObjectInputStream(f2);
                c = (CompositeName)s2.readObject();
                
                System.out.println(&quot;Size: &quot; + c.size());
                System.out.println(&quot;Size: &quot; + c.snit);
                }                
            </comment>
            <comment line="611">
                %%% Testing code
                public static void main(String[] args) {
                try {
                for (int i = 0; i &lt; args.length; i++) {
                Name name;
                Enumeration e;
                System.out.println(&quot;Given name: &quot; + args[i]);
                name = new CompositeName(args[i]);
                e = name.getComponents();
                while (e.hasMoreElements()) {
                System.out.println(&quot;Element: &quot; + e.nextElement());
                }
                System.out.println(&quot;Constructed name: &quot; + name.toString());
                }
                } catch (Exception ne) {
                ne.printStackTrace();
                }
                }                
            </comment>
            <implements interface="Name"/>
            <javadoc line="31">
                This class represents a composite name -- a sequence of
                  component names spanning multiple namespaces.
                  Each component is a string name from the namespace of a
                  naming system. If the component comes from a hierarchical
                  namespace, that component can be further parsed into
                  its atomic parts by using the CompoundName class.
                  &lt;p&gt;
                  The components of a composite name are numbered.  The indexes of a
                  composite name with N components range from 0 up to, but not including, N.
                  This range may be written as [0,N).
                  The most significant component is at index 0.
                  An empty composite name has no components.
                  &lt;p&gt;
                  &lt;h4&gt;JNDI Composite Name Syntax&lt;/h4&gt;
                  JNDI defines a standard string representation for composite names. This
                  representation is the concatenation of the components of a composite name
                  from left to right using the component separator (a forward
                  slash character (/)) to separate each component.
                  The JNDI syntax defines the following meta characters:
                  &lt;ul&gt;
                  &lt;li&gt;escape (backward slash \),
                  &lt;li&gt;quote characters  (single (&apos;) and double quotes (&quot;)), and
                  &lt;li&gt;component separator (forward slash character (/)).
                  &lt;/ul&gt;
                  Any occurrence of a leading quote, an escape preceding any meta character,
                  an escape at the end of a component, or a component separator character
                  in an unquoted component must be preceded by an escape character when
                  that component is being composed into a composite name string.
                  Alternatively, to avoid adding escape characters as described,
                  the entire component can be quoted using matching single quotes
                  or matching double quotes. A single quote occurring within a double-quoted
                  component is not considered a meta character (and need not be escaped),
                  and vice versa.
                  &lt;p&gt;
                  When two composite names are compared, the case of the characters
                  is significant.
                  &lt;p&gt;
                  A leading component separator (the composite name string begins with
                  a separator) denotes a leading empty component (a component consisting
                  of an empty string).
                  A trailing component separator (the composite name string ends with
                  a separator) denotes a trailing empty component.
                  Adjacent component separators denote an empty component.
                  &lt;p&gt;
                  &lt;h4&gt;Composite Name Examples&lt;/h4&gt;
                  This table shows examples of some composite names. Each row shows
                  the string form of a composite name and its corresponding structural form
                  (&lt;tt&gt;CompositeName&lt;/tt&gt;).
                  &lt;p&gt;
                  &lt;table border=&quot;1&quot; cellpadding=3 width=&quot;70%&quot; summary=&quot;examples showing string form of composite name and its corresponding structural form (CompositeName)&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;String Name&lt;/th&gt;
                  &lt;th&gt;CompositeName&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;&quot;
                  &lt;/td&gt;
                  &lt;td&gt;{} (the empty name == new CompositeName(&quot;&quot;) == new CompositeName())
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;x&quot;
                  &lt;/td&gt;
                  &lt;td&gt;{&quot;x&quot;}
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;x/y&quot;
                  &lt;/td&gt;
                  &lt;td&gt;{&quot;x&quot;, &quot;y&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&quot;x/&quot;&lt;/td&gt;
                  &lt;td&gt;{&quot;x&quot;, &quot;&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&quot;/x&quot;&lt;/td&gt;
                  &lt;td&gt;{&quot;&quot;, &quot;x&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&quot;/&quot;&lt;/td&gt;
                  &lt;td&gt;{&quot;&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&quot;//&quot;&lt;/td&gt;
                  &lt;td&gt;{&quot;&quot;, &quot;&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&quot;/x/&quot;&lt;/td&gt;
                  &lt;td&gt;{&quot;&quot;, &quot;x&quot;, &quot;&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&quot;x//y&quot;&lt;/td&gt;
                  &lt;td&gt;{&quot;x&quot;, &quot;&quot;, &quot;y&quot;}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt;
                  &lt;h4&gt;Composition Examples&lt;/h4&gt;
                  Here are some composition examples.  The right column shows composing
                  string composite names while the left column shows composing the
                  corresponding &lt;tt&gt;CompositeName&lt;/tt&gt;s.  Notice that composing the
                  string forms of two composite names simply involves concatenating
                  their string forms together.
                  &lt;p&gt; &lt;table border=&quot;1&quot; cellpadding=3 width=&quot;70%&quot; summary=&quot;composition examples showing string names and composite names&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;String Names&lt;/th&gt;
                  &lt;th&gt;CompositeNames&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;x/y&quot;           + &quot;/&quot;   = x/y/
                  &lt;/td&gt;
                  &lt;td&gt;
                  {&quot;x&quot;, &quot;y&quot;}      + {&quot;&quot;}  = {&quot;x&quot;, &quot;y&quot;, &quot;&quot;}
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;&quot;              + &quot;x&quot;   = &quot;x&quot;
                  &lt;/td&gt;
                  &lt;td&gt;
                  {}              + {&quot;x&quot;} = {&quot;x&quot;}
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;/&quot;             + &quot;x&quot;   = &quot;/x&quot;
                  &lt;/td&gt;
                  &lt;td&gt;
                  {&quot;&quot;}            + {&quot;x&quot;} = {&quot;&quot;, &quot;x&quot;}
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;
                  &quot;x&quot;   + &quot;&quot;      + &quot;&quot;    = &quot;x&quot;
                  &lt;/td&gt;
                  &lt;td&gt;
                  {&quot;x&quot;} + {}      + {}    = {&quot;x&quot;}
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt;
                  &lt;h4&gt;Multithreaded Access&lt;/h4&gt;
                  A &lt;tt&gt;CompositeName&lt;/tt&gt; instance is not synchronized against concurrent
                  multithreaded access. Multiple threads trying to access and modify a
                  &lt;tt&gt;CompositeName&lt;/tt&gt; should lock the object.                
                <author>
                    Rosanna Lee                    
                </author>
                <author>
                    Scott Seligman                    
                </author>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="impl" type="NameImpl" line="205"/>
            <javadoc line="206">
                Constructs a new composite name instance using the components
                  specified by &apos;comps&apos;. This protected method is intended to be
                  to be used by subclasses of CompositeName when they override
                  methods such as clone(), getPrefix(), getSuffix().                
                <param>
                    comps A non-null enumeration containing the components for the new
                      composite name. Each element is of class String.
                      The enumeration will be consumed to extract its
                      elements.                    
                </param>
            </javadoc>
            <method name="CompositeName" type="constructor" line="217">
                <params>
                    <param name="comps" type="Enumeration<String>"/>
                </params>
                <comment line="219">
                    null means use default syntax                    
                </comment>
            </method>
            <javadoc line="221">
                Constructs a new composite name instance by parsing the string n
                  using the composite name syntax (left-to-right, slash separated).
                  The composite name syntax is described in detail in the class
                  description.                
                <param>
                    n       The non-null string to parse.                    
                </param>
                <exception>
                    InvalidNameException If n has invalid composite name syntax.                    
                </exception>
            </javadoc>
            <method name="CompositeName" type="constructor" line="230">
                <params>
                    <param name="n" type="String"/>
                </params>
                <comment line="232">
                    null means use default syntax                    
                </comment>
            </method>
            <javadoc line="234">
                Constructs a new empty composite name. Such a name returns true
                  when &lt;code&gt;isEmpty()&lt;/code&gt; is invoked on it.                
            </javadoc>
            <method name="CompositeName" type="constructor" line="238">
                <comment line="240">
                    null means use default syntax                    
                </comment>
            </method>
            <javadoc line="242">
                Generates the string representation of this composite name.
                  The string representation consists of enumerating in order
                  each component of the composite name and separating
                  each component by a forward slash character. Quoting and
                  escape characters are applied where necessary according to
                  the JNDI syntax, which is described in the class description.
                  An empty component is represented by an empty string.
                  The string representation thus generated can be passed to
                  the CompositeName constructor to create a new equivalent
                  composite name.                
                <return>
                    A non-null string representation of this composite name.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="257"/>
            <javadoc line="261">
                Determines whether two composite names are equal.
                  If obj is null or not a composite name, false is returned.
                  Two composite names are equal if each component in one is equal
                  to the corresponding component in the other. This implies
                  both have the same number of components, and each component&apos;s
                  equals() test against the corresponding component in the other name
                  returns true.                
                <param>
                    obj     The possibly null object to compare against.                    
                </param>
                <return>
                    true if obj is equal to this composite name, false otherwise.                    
                </return>
                <see>
                    #hashCode                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="274">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="280">
                Computes the hash code of this composite name.
                  The hash code is the sum of the hash codes of individual components
                  of this composite name.                
                <return>
                    An int representing the hash code of this name.                    
                </return>
                <see>
                    #equals                    
                </see>
            </javadoc>
            <method name="hashCode" type="int" line="288"/>
            <javadoc line="293">
                Compares this CompositeName with the specified Object for order.
                  Returns a
                  negative integer, zero, or a positive integer as this Name is less
                  than, equal to, or greater than the given Object.
                  &lt;p&gt;
                  If obj is null or not an instance of CompositeName, ClassCastException
                  is thrown.
                  &lt;p&gt;
                  See equals() for what it means for two composite names to be equal.
                  If two composite names are equal, 0 is returned.
                  &lt;p&gt;
                  Ordering of composite names follows the lexicographical rules for
                  string comparison, with the extension that this applies to all
                  the components in the composite name. The effect is as if all the
                  components were lined up in their specified ordered and the
                  lexicographical rules applied over the two line-ups.
                  If this composite name is &quot;lexicographically&quot; lesser than obj,
                  a negative number is returned.
                  If this composite name is &quot;lexicographically&quot; greater than obj,
                  a positive number is returned.                
                <param>
                    obj The non-null object to compare against.                    
                </param>
                <return>
                    a negative integer, zero, or a positive integer as this Name
                      is less than, equal to, or greater than the given Object.                    
                </return>
                <exception>
                    ClassCastException if obj is not a CompositeName.                    
                </exception>
            </javadoc>
            <method name="compareTo" type="int" line="320">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="321"/>
            </method>
            <javadoc line="327">
                Generates a copy of this composite name.
                  Changes to the components of this composite name won&apos;t
                  affect the new copy and vice versa.                
                <return>
                    A non-null copy of this composite name.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="334"/>
            <javadoc line="338">
                Retrieves the number of components in this composite name.                
                <return>
                    The nonnegative number of components in this composite name.                    
                </return>
            </javadoc>
            <method name="size" type="int" line="343"/>
            <javadoc line="347">
                Determines whether this composite name is empty. A composite name
                  is empty if it has zero components.                
                <return>
                    true if this composite name is empty, false otherwise.                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="353"/>
            <javadoc line="357">
                Retrieves the components of this composite name as an enumeration
                  of strings.
                  The effects of updates to this composite name on this enumeration
                  is undefined.                
                <return>
                    A non-null enumeration of the components of
                      this composite name. Each element of the enumeration is of
                      class String.                    
                </return>
            </javadoc>
            <method name="getAll" type="Enumeration<String>" line="367"/>
            <javadoc line="371">
                Retrieves a component of this composite name.                
                <param>
                    posn    The 0-based index of the component to retrieve.
                      Must be in the range [0,size()).                    
                </param>
                <return>
                    The non-null component at index posn.                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsException if posn is outside the
                      specified range.                    
                </exception>
            </javadoc>
            <method name="get" type="String" line="380">
                <params>
                    <param name="posn" type="int"/>
                </params>
            </method>
            <javadoc line="384">
                Creates a composite name whose components consist of a prefix of the
                  components in this composite name. Subsequent changes to
                  this composite name does not affect the name that is returned.                
                <param>
                    posn    The 0-based index of the component at which to stop.
                      Must be in the range [0,size()].                    
                </param>
                <return>
                    A composite name consisting of the components at indexes in
                      the range [0,posn).                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsExceptionIf posn is outside the specified range.                    
                </exception>
            </javadoc>
            <method name="getPrefix" type="Name" line="396">
                <params>
                    <param name="posn" type="int"/>
                </params>
                <declaration name="comps" type="Enumeration" line="397"/>
            </method>
            <javadoc line="401">
                Creates a composite name whose components consist of a suffix of the
                  components in this composite name. Subsequent changes to
                  this composite name does not affect the name that is returned.                
                <param>
                    posn    The 0-based index of the component at which to start.
                      Must be in the range [0,size()].                    
                </param>
                <return>
                    A composite name consisting of the components at indexes in
                      the range [posn,size()).  If posn is equal to
                      size(), an empty composite name is returned.                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsExceptionIf posn is outside the specified range.                    
                </exception>
            </javadoc>
            <method name="getSuffix" type="Name" line="414">
                <params>
                    <param name="posn" type="int"/>
                </params>
                <declaration name="comps" type="Enumeration" line="415"/>
            </method>
            <javadoc line="419">
                Determines whether a composite name is a prefix of this composite name.
                  A composite name &apos;n&apos; is a prefix if it is equal to
                  getPrefix(n.size())--in other words, this composite name
                  starts with &apos;n&apos;. If &apos;n&apos; is null or not a composite name, false is returned.                
                <param>
                    n       The possibly null name to check.                    
                </param>
                <return>
                    true if n is a CompositeName and
                      is a prefix of this composite name, false otherwise.                    
                </return>
            </javadoc>
            <method name="startsWith" type="boolean" line="429">
                <params>
                    <param name="n" type="Name"/>
                </params>
                <scope line="430"/>
                <scope line="432"/>
            </method>
            <javadoc line="437">
                Determines whether a composite name is a suffix of this composite name.
                  A composite name &apos;n&apos; is a suffix if it it is equal to
                  getSuffix(size()-n.size())--in other words, this
                  composite name ends with &apos;n&apos;.
                  If n is null or not a composite name, false is returned.                
                <param>
                    n       The possibly null name to check.                    
                </param>
                <return>
                    true if n is a CompositeName and
                      is a suffix of this composite name, false otherwise.                    
                </return>
            </javadoc>
            <method name="endsWith" type="boolean" line="448">
                <params>
                    <param name="n" type="Name"/>
                </params>
                <scope line="449"/>
                <scope line="451"/>
            </method>
            <javadoc line="456">
                Adds the components of a composite name -- in order -- to the end of
                  this composite name.                
                <param>
                    suffix   The non-null components to add.                    
                </param>
                <return>
                    The updated CompositeName, not a new one. Cannot be null.                    
                </return>
                <exception>
                    InvalidNameException If suffix is not a composite name.                    
                </exception>
            </javadoc>
            <method name="addAll" type="Name" line="466">
                <params>
                    <param name="suffix" type="Name"/>
                </params>
                <scope line="467"/>
                <scope line="470"/>
            </method>
            <javadoc line="476">
                Adds the components of a composite name -- in order -- at a specified
                  position within this composite name.
                  Components of this composite name at or after the index of the first
                  new component are shifted up (away from index 0)
                  to accommodate the new components.                
                <param>
                    n        The non-null components to add.                    
                </param>
                <param>
                    posn     The index in this name at which to add the new
                      components.  Must be in the range [0,size()].                    
                </param>
                <return>
                    The updated CompositeName, not a new one. Cannot be null.                    
                </return>
                <exception>
                    InvalidNameException If n is not a composite name.                    
                </exception>
                <exception>
                    ArrayIndexOutOfBoundsExceptionIf posn is outside the specified range.                    
                </exception>
            </javadoc>
            <method name="addAll" type="Name" line="493">
                <params>
                    <param name="posn" type="int"/>
                    <param name="n" type="Name"/>
                </params>
                <scope line="494"/>
                <scope line="497"/>
            </method>
            <javadoc line="503">
                Adds a single component to the end of this composite name.                
                <param>
                    comp     The non-null component to add.                    
                </param>
                <return>
                    The updated CompositeName, not a new one. Cannot be null.                    
                </return>
                <exception>
                    InvalidNameException If adding comp at end of the name
                      would violate the name&apos;s syntax.                    
                </exception>
            </javadoc>
            <method name="add" type="Name" line="511">
                <params>
                    <param name="comp" type="String"/>
                </params>
            </method>
            <javadoc line="516">
                Adds a single component at a specified position within this
                  composite name.
                  Components of this composite name at or after the index of the new
                  component are shifted up by one (away from index 0) to accommodate
                  the new component.                
                <param>
                    comp    The non-null component to add.                    
                </param>
                <param>
                    posn    The index at which to add the new component.
                      Must be in the range [0,size()].                    
                </param>
                <return>
                    The updated CompositeName, not a new one. Cannot be null.                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsExceptionIf posn is outside the specified range.                    
                </exception>
                <exception>
                    InvalidNameException If adding comp at the specified position
                      would violate the name&apos;s syntax.                    
                </exception>
            </javadoc>
            <method name="add" type="Name" line="534">
                <params>
                    <param name="posn" type="int"/>
                    <param name="comp" type="String"/>
                </params>
            </method>
            <javadoc line="539">
                Deletes a component from this composite name.
                  The component of this composite name at position &apos;posn&apos; is removed,
                  and components at indices greater than &apos;posn&apos;
                  are shifted down (towards index 0) by one.                
                <param>
                    posn    The index of the component to delete.
                      Must be in the range [0,size()).                    
                </param>
                <return>
                    The component removed (a String).                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsExceptionIf posn is outside the specified range (includes case where
                      composite name is empty).                    
                </exception>
                <exception>
                    InvalidNameException If deleting the component
                      would violate the name&apos;s syntax.                    
                </exception>
            </javadoc>
            <method name="remove" type="Object" line="554">
                <params>
                    <param name="posn" type="int"/>
                </params>
            </method>
            <javadoc line="558">
                Overridden to avoid implementation dependency.                
                <serialData>
                    The number of components (an &lt;tt&gt;int&lt;/tt&gt;) followed by
                      the individual components (each a &lt;tt&gt;String&lt;/tt&gt;).                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="564">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <declaration name="comps" type="Enumeration" line="566"/>
                <scope line="567"/>
            </method>
            <javadoc line="572">
                Overridden to avoid implementation dependency.                
            </javadoc>
            <method name="readObject" type="void" line="576">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="578">
                    null means use default syntax                    
                </comment>
                <comment line="579">
                    number of components                    
                </comment>
                <declaration name="n" type="int" line="578"/>
                <scope line="579">
                    <scope line="580"/>
                </scope>
                <scope line="583"/>
            </method>
            <declaration name="serialVersionUID" type="long" line="588"/>
            <javadoc line="588">
                Use serialVersionUID from JNDI 1.1.1 for interoperability                
            </javadoc>
        </class>
    </source>