<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.print.attribute">
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.ObjectStreamException"/>
        <import package="java.io.Serializable"/>
        <class name="EnumSyntax" line="33">
            <comment line="218">
                Hidden operations to be implemented in a subclass.                
            </comment>
            <implements interface="Serializable"/>
            <implements interface="Cloneable"/>
            <javadoc line="33">
                Class EnumSyntax is an abstract base class providing the common
                  implementation of all &quot;type safe enumeration&quot; objects. An enumeration class
                  (which extends class EnumSyntax) provides a group of enumeration values
                  (objects) that are singleton instances of the enumeration class; for example:
                  &lt;PRE&gt;
                  public class Bach extends EnumSyntax {
                  public static final Bach JOHANN_SEBASTIAN     = new Bach(0);
                  public static final Bach WILHELM_FRIEDEMANN   = new Bach(1);
                  public static final Bach CARL_PHILIP_EMMANUEL = new Bach(2);
                  public static final Bach JOHANN_CHRISTIAN     = new Bach(3);
                  public static final Bach P_D_Q                = new Bach(4);
                  private static final String[] stringTable = {
                  &quot;Johann Sebastian Bach&quot;,
                  &quot;Wilhelm Friedemann Bach&quot;,
                  &quot;Carl Philip Emmanuel Bach&quot;,
                  &quot;Johann Christian Bach&quot;,
                  &quot;P.D.Q. Bach&quot;
                  };
                  protected String[] getStringTable() {
                  return stringTable;
                  }
                  private static final Bach[] enumValueTable = {
                  JOHANN_SEBASTIAN,
                  WILHELM_FRIEDEMANN,
                  CARL_PHILIP_EMMANUEL,
                  JOHANN_CHRISTIAN,
                  P_D_Q
                  };
                  protected EnumSyntax[] getEnumValueTable() {
                  return enumValueTable;
                  }
                  }
                  &lt;/PRE&gt;
                  You can then write code that uses the &lt;CODE&gt;==&lt;/CODE&gt; and &lt;CODE&gt;!=&lt;/CODE&gt;
                  operators to test enumeration values; for example:
                  &lt;PRE&gt;
                  Bach theComposer;
                  . . .
                  if (theComposer == Bach.JOHANN_SEBASTIAN) {
                  System.out.println (&quot;The greatest composer of all time!&quot;);
                  }
                  &lt;/PRE&gt;
                  The &lt;CODE&gt;equals()&lt;/CODE&gt; method for an enumeration class just does a test
                  for identical objects (&lt;CODE&gt;==&lt;/CODE&gt;).
                  &lt;P&gt;
                  You can convert an enumeration value to a string by calling {@link #toString() &lt;CODE&gt;toString()&lt;/CODE&gt;}. The string is obtained from a table
                  supplied by the enumeration class.
                  &lt;P&gt;
                  Under the hood, an enumeration value is just an integer, a different integer
                  for each enumeration value within an enumeration class. You can get an
                  enumeration value&apos;s integer value by calling {@link #getValue()&lt;CODE&gt;getValue()&lt;/CODE&gt;}. An enumeration value&apos;s integer value is established
                  when it is constructed (see {@link #EnumSyntax(int)&lt;CODE&gt;EnumSyntax(int)&lt;/CODE&gt;}). Since the constructor is protected, the only
                  possible enumeration values are the singleton objects declared in the
                  enumeration class; additional enumeration values cannot be created at run
                  time.
                  &lt;P&gt;
                  You can define a subclass of an enumeration class that extends it with
                  additional enumeration values. The subclass&apos;s enumeration values&apos; integer
                  values need not be distinct from the superclass&apos;s enumeration values&apos; integer
                  values; the &lt;CODE&gt;==&lt;/CODE&gt;, &lt;CODE&gt;!=&lt;/CODE&gt;, &lt;CODE&gt;equals()&lt;/CODE&gt;, and
                  &lt;CODE&gt;toString()&lt;/CODE&gt; methods will still work properly even if the subclass
                  uses some of the same integer values as the superclass. However, the
                  application in which the enumeration class and subclass are used may need to
                  have distinct integer values in the superclass and subclass.
                  &lt;P&gt;                
                <author>
                    David Mendenhall                    
                </author>
                <author>
                    Alan Kaminsky                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="112"/>
            <declaration name="value" type="int" line="114"/>
            <javadoc line="114">
                This enumeration value&apos;s integer value.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="120">
                Construct a new enumeration value with the given integer value.                
                <param>
                    value  Integer value.                    
                </param>
            </javadoc>
            <method name="EnumSyntax" type="constructor" line="125">
                <params>
                    <param name="value" type="int"/>
                </params>
            </method>
            <javadoc line="129">
                Returns this enumeration value&apos;s integer value.                
                <return>
                    the value                    
                </return>
            </javadoc>
            <method name="getValue" type="int" line="133"/>
            <javadoc line="137">
                Returns a clone of this enumeration value, which to preserve the
                  semantics of enumeration values is the same object as this enumeration
                  value.                
            </javadoc>
            <method name="clone" type="Object" line="142"/>
            <javadoc line="146">
                Returns a hash code value for this enumeration value. The hash code is
                  just this enumeration value&apos;s integer value.                
            </javadoc>
            <method name="hashCode" type="int" line="150"/>
            <javadoc line="154">
                Returns a string value corresponding to this enumeration value.                
            </javadoc>
            <method name="toString" type="String" line="157">
                <declaration name="theTable" type="String[]" line="159"/>
                <declaration name="theIndex" type="int" line="160"/>
            </method>
            <javadoc line="167">
                During object input, convert this deserialized enumeration instance to
                  the proper enumeration value defined in the enumeration attribute class.                
                <return>
                    The enumeration singleton value stored at index
                      &lt;I&gt;i&lt;/I&gt;-&lt;I&gt;L&lt;/I&gt; in the enumeration value table returned by{@link #getEnumValueTable() &lt;CODE&gt;getEnumValueTable()&lt;/CODE&gt;},
                      where &lt;I&gt;i&lt;/I&gt; is this enumeration value&apos;s integer value and
                      &lt;I&gt;L&lt;/I&gt; is the value returned by {@link #getOffset()&lt;CODE&gt;getOffset()&lt;/CODE&gt;}.                    
                </return>
                <throws>
                    ObjectStreamException if the stream can&apos;t be deserialised                    
                </throws>
                <throws>
                    InvalidObjectExceptionThrown if the enumeration value table is null, this enumeration
                      value&apos;s integer value does not correspond to an element in the
                      enumeration value table, or the corresponding element in the
                      enumeration value table is null. (Note: {@link java.io.InvalidObjectException InvalidObjectException} is a subclass
                      of {@link java.io.ObjectStreamException ObjectStreamException}, which
                      &lt;CODE&gt;readResolve()&lt;/CODE&gt; is declared to throw.)                    
                </throws>
            </javadoc>
            <method name="readResolve" type="Object" line="188">
                <declaration name="theTable" type="EnumSyntax[]" line="190"/>
                <scope line="192"/>
                <declaration name="theOffset" type="int" line="198"/>
                <declaration name="theIndex" type="int" line="199"/>
                <scope line="201"/>
                <declaration name="result" type="EnumSyntax" line="208"/>
                <scope line="209"/>
            </method>
            <javadoc line="219">
                Returns the string table for this enumeration value&apos;s enumeration class.
                  The enumeration class&apos;s integer values are assumed to lie in the range
                  &lt;I&gt;L&lt;/I&gt;..&lt;I&gt;L&lt;/I&gt;+&lt;I&gt;N&lt;/I&gt;-1, where &lt;I&gt;L&lt;/I&gt; is the value returned by{@link #getOffset() &lt;CODE&gt;getOffset()&lt;/CODE&gt;} and &lt;I&gt;N&lt;/I&gt; is the length
                  of the string table. The element in the string table at index
                  &lt;I&gt;i&lt;/I&gt;-&lt;I&gt;L&lt;/I&gt; is the value returned by {@link #toString()&lt;CODE&gt;toString()&lt;/CODE&gt;} for the enumeration value whose integer value
                  is &lt;I&gt;i&lt;/I&gt;. If an integer within the above range is not used by any
                  enumeration value, leave the corresponding table element null.
                  &lt;P&gt;
                  The default implementation returns null. If the enumeration class (a
                  subclass of class EnumSyntax) does not override this method to return a
                  non-null string table, and the subclass does not override the {@link #toString() &lt;CODE&gt;toString()&lt;/CODE&gt;} method, the base class {@link #toString() &lt;CODE&gt;toString()&lt;/CODE&gt;} method will return just a string
                  representation of this enumeration value&apos;s integer value.                
                <return>
                    the string table                    
                </return>
            </javadoc>
            <method name="getStringTable" type="String[]" line="238"/>
            <javadoc line="242">
                Returns the enumeration value table for this enumeration value&apos;s
                  enumeration class. The enumeration class&apos;s integer values are assumed to
                  lie in the range &lt;I&gt;L&lt;/I&gt;..&lt;I&gt;L&lt;/I&gt;+&lt;I&gt;N&lt;/I&gt;-1, where &lt;I&gt;L&lt;/I&gt; is the
                  value returned by {@link #getOffset() &lt;CODE&gt;getOffset()&lt;/CODE&gt;} and
                  &lt;I&gt;N&lt;/I&gt; is the length of the enumeration value table. The element in the
                  enumeration value table at index &lt;I&gt;i&lt;/I&gt;-&lt;I&gt;L&lt;/I&gt; is the enumeration
                  value object whose integer value is &lt;I&gt;i&lt;/I&gt;; the {@link #readResolve()&lt;CODE&gt;readResolve()&lt;/CODE&gt;} method needs this to preserve singleton
                  semantics during deserialization of an enumeration instance. If an
                  integer within the above range is not used by any enumeration value,
                  leave the corresponding table element null.
                  &lt;P&gt;
                  The default implementation returns null. If the enumeration class (a
                  subclass of class EnumSyntax) does not override this method to return
                  a non-null enumeration value table, and the subclass does not override
                  the {@link #readResolve() &lt;CODE&gt;readResolve()&lt;/CODE&gt;} method, the base
                  class {@link #readResolve() &lt;CODE&gt;readResolve()&lt;/CODE&gt;} method will throw
                  an exception whenever an enumeration instance is deserialized from an
                  object input stream.                
                <return>
                    the value table                    
                </return>
            </javadoc>
            <method name="getEnumValueTable" type="EnumSyntax[]" line="264"/>
            <javadoc line="268">
                Returns the lowest integer value used by this enumeration value&apos;s
                  enumeration class.
                  &lt;P&gt;
                  The default implementation returns 0. If the enumeration class (a
                  subclass of class EnumSyntax) uses integer values starting at other than
                  0, override this method in the subclass.                
                <return>
                    the offset of the lowest enumeration value.                    
                </return>
            </javadoc>
            <method name="getOffset" type="int" line="277"/>
        </class>
    </source>