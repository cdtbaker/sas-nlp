<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management">
        <interface name="ValueExp">
            <implements interface="java.io.Serializable"/>
            <comment line="37">
                We considered generifying this interface as ValueExp&lt;T&gt;, where T is
                the Java type that this expression generates.  This allows some additional
                checking in the various methods of the Query class, but in practice
                not much.  Typically you have something like
                Query.lt(Query.attr(&quot;A&quot;), Query.value(5)).  We can arrange for Query.value
                to have type ValueExp&lt;Integer&gt; (or maybe ValueExp&lt;Long&gt; or ValueExp&lt;Number&gt;)
                but for Query.attr we can&apos;t do better than ValueExp&lt;?&gt; or plain ValueExp.
                So even though we could define Query.lt as:
                QueryExp &lt;T&gt; lt(ValueExp&lt;T&gt; v1, ValueExp&lt;T&gt; v2)
                and thus prevent comparing a
                number against a string, in practice the first ValueExp will almost always
                be a Query.attr so this check serves no purpose.  You would have to
                write Query.&lt;Number&gt;attr(&quot;A&quot;), for example, which would be awful.  And,
                if you wrote Query.&lt;Integer&gt;attr(&quot;A&quot;) you would then discover that you
                couldn&apos;t compare it against Query.value(5) if the latter is defined as
                ValueExp&lt;Number&gt;, or against Query.value(5L) if it is defined as
                ValueExp&lt;Integer&gt;.
                
                Worse, for Query.in we would like to define:
                QueryExp &lt;T&gt; in(ValueExp&lt;T&gt; val, ValueExp&lt;T&gt;[] valueList)
                but this is unusable because you cannot write
                &quot;new ValueExp&lt;Integer&gt;[] {...}&quot; (the compiler forbids it).
                
                The few mistakes you might catch with this generification certainly
                wouldn&apos;t justify the hassle of modifying user code to get the checks
                to be made and the &quot;unchecked&quot; warnings that would arise if it
                wasn&apos;t so modified.
                
                We could reconsider this if the Query methods were augmented, for example
                with:
                AttributeValueExp&lt;Number&gt; numberAttr(String name);
                AttributeValueExp&lt;String&gt; stringAttr(String name);
                AttributeValueExp&lt;Boolean&gt; booleanAttr(String name);
                QueryExp &lt;T&gt; in(ValueExp&lt;T&gt; val, Set&lt;ValueExp&lt;T&gt;&gt; valueSet).
                But it&apos;s not really clear what numberAttr should do if it finds that the
                attribute is not in fact a Number.                
            </comment>
            <javadoc line="29">
                Represents values that can be passed as arguments to
                  relational expressions. Strings, numbers, attributes are valid values
                  and should be represented by implementations of &lt;CODE&gt;ValueExp&lt;/CODE&gt;.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="apply" type="ValueExp" line="76"/>
            <javadoc line="76">
                Applies the ValueExp on a MBean.                
                <param>
                    name The name of the MBean on which the ValueExp will be applied.                    
                </param>
                <return>
                    The &lt;CODE&gt;ValueExp&lt;/CODE&gt;.                    
                </return>
                <exception>
                    BadStringOperationException                    
                </exception>
                <exception>
                    BadBinaryOpValueExpException                    
                </exception>
                <exception>
                    BadAttributeValueExpException                    
                </exception>
                <exception>
                    InvalidApplicationException                    
                </exception>
            </javadoc>
            <method name="setMBeanServer" type="void" line="92"/>
            <javadoc line="92">
                Sets the MBean server on which the query is to be performed.                
                <param>
                    s The MBean server on which the query is to be performed.                    
                </param>
                <deprecated>
                    This method is not needed because a
                      &lt;code&gt;ValueExp&lt;/code&gt; can access the MBean server in which it
                      is being evaluated by using {@link QueryEval#getMBeanServer()}.                    
                </deprecated>
            </javadoc>
        </interface>
    </source>