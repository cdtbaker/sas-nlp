<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management.openmbean">
        <import package="com.sun.jmx.mbeanserver.MXBeanLookup"/>
        <import package="com.sun.jmx.mbeanserver.MXBeanMapping"/>
        <import package="com.sun.jmx.mbeanserver.MXBeanMappingFactory"/>
        <import package="com.sun.jmx.mbeanserver.DefaultMXBeanMappingFactory"/>
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Proxy"/>
        <class name="CompositeDataInvocationHandler" line="36">
            <comment line="208">
                This method is called when equals(Object) is
                 called on our proxy and hence forwarded to us.  For example, if we
                 are a proxy for an interface like this:
                 public interface GetString {
                     public String string();
                 }
                 then we must compare equal to another CompositeDataInvocationHandler
                 proxy for the same interface and where string() returns the same value.
                
                 You might think that we should also compare equal to another
                 object that implements GetString directly rather than using
                 Proxy, provided that its string() returns the same result as
                 ours, and in fact an earlier version of this class did that (by
                 converting the other object into a CompositeData and comparing
                 that with ours).  But in fact that doesn&apos;t make a great deal of
                 sense because there&apos;s absolutely no guarantee that the
                 resulting equals would be reflexive (otherObject.equals(this)
                 might be false even if this.equals(otherObject) is true), and,
                 especially, there&apos;s no way we could generate a hashCode() that
                 would be equal to otherObject.hashCode() when
                 this.equals(otherObject), because we don&apos;t know how
                 otherObject.hashCode() is computed.                
            </comment>
            <implements interface="InvocationHandler"/>
            <javadoc line="36">
                &lt;p&gt;An {@link InvocationHandler} that forwards getter methods to a{@link CompositeData}.  If you have an interface that contains
                  only getter methods (such as {@code String getName()} or{@code boolean isActive()}) then you can use this class in
                  conjunction with the {@link Proxy} class to produce an implementation
                  of the interface where each getter returns the value of the
                  corresponding item in a {@code CompositeData}.&lt;/p&gt;
                  &lt;p&gt;For example, suppose you have an interface like this:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  public interface NamedNumber {
                  public int getNumber();
                  public String getName();
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  and a {@code CompositeData} constructed like this:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  CompositeData cd =
                  new {@link CompositeDataSupport}(
                  someCompositeType,
                  new String[] {&quot;number&quot;, &quot;name&quot;},
                  new Object[] {&lt;b&gt;5&lt;/b&gt;, &quot;five&quot;}
                  );
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  then you can construct an object implementing {@code NamedNumber}and backed by the object {@code cd} like this:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  InvocationHandler handler =
                  new CompositeDataInvocationHandler(cd);
                  NamedNumber nn = (NamedNumber)
                  Proxy.newProxyInstance(NamedNumber.class.getClassLoader(),
                  new Class[] {NamedNumber.class},
                  handler);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  A call to {@code nn.getNumber()} will then return &lt;b&gt;5&lt;/b&gt;.&lt;/p&gt;
                  &lt;p&gt;If the first letter of the property defined by a getter is a
                  capital, then this handler will look first for an item in the{@code CompositeData} beginning with a capital, then, if that is
                  not found, for an item beginning with the corresponding lowercase
                  letter or code point.  For a getter called {@code getNumber()}, the
                  handler will first look for an item called {@code Number}, then for{@code number}.  If the getter is called {@code getnumber()}, then
                  the item must be called {@code number}.&lt;/p&gt;
                  &lt;p&gt;If the method given to {@link #invoke invoke} is the method{@code boolean equals(Object)} inherited from {@code Object}, then
                  it will return true if and only if the argument is a {@code Proxy}whose {@code InvocationHandler} is also a {@codeCompositeDataInvocationHandler} and whose backing {@codeCompositeData} is equal (not necessarily identical) to this
                  object&apos;s.  If the method given to {@code invoke} is the method{@code int hashCode()} inherited from {@code Object}, then it will
                  return a value that is consistent with this definition of {@codeequals}: if two objects are equal according to {@code equals}, then
                  they will have the same {@code hashCode}.&lt;/p&gt;                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <javadoc line="109">
                &lt;p&gt;Construct a handler backed by the given {@codeCompositeData}.&lt;/p&gt;                
                <param>
                    compositeData the {@code CompositeData} that will supply
                      information to getters.                    
                </param>
                <throws>
                    IllegalArgumentException if {@code compositeData}is null.                    
                </throws>
            </javadoc>
            <method name="CompositeDataInvocationHandler" type="constructor" line="119">
                <params>
                    <param name="compositeData" type="CompositeData"/>
                </params>
            </method>
            <javadoc line="123">
                &lt;p&gt;Construct a handler backed by the given {@codeCompositeData}.&lt;/p&gt;                
                <param>
                    mbsc the {@code MBeanServerConnection} related to this{@code CompositeData}.  This is only relevant if a method in
                      the interface for which this is an invocation handler returns
                      a type that is an MXBean interface.  Otherwise, it can be null.                    
                </param>
                <param>
                    compositeData the {@code CompositeData} that will supply
                      information to getters.                    
                </param>
                <throws>
                    IllegalArgumentException if {@code compositeData}is null.                    
                </throws>
            </javadoc>
            <method name="CompositeDataInvocationHandler" type="constructor" line="139">
                <params>
                    <param name="compositeData" type="CompositeData"/>
                    <param name="lookup" type="MXBeanLookup"/>
                </params>
            </method>
            <javadoc line="146">
                Return the {@code CompositeData} that was supplied to the
                  constructor.                
                <return>
                    the {@code CompositeData} that this handler is backed
                      by.  This is never null.                    
                </return>
            </javadoc>
            <method name="getCompositeData" type="CompositeData" line="152"/>
            <method name="invoke" type="Object" line="158">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="method" type="Method"/>
                    <param name="args" type="Object[]"/>
                </params>
                <comment line="162">
                    Handle the methods from java.lang.Object                    
                </comment>
                <comment line="172">
                    Either someone is calling invoke by hand, or
                    it is a non-final method from Object overriden
                    by the generated Proxy.  At the time of writing,
                    the only non-final methods in Object that are not
                    handled above are finalize and clone, and these                    
                </comment>
                <declaration name="methodName" type="String" line="159"/>
                <scope line="162">
                    <scope line="170"/>
                </scope>
                <declaration name="propertyName" type="String" line="181"/>
                <scope line="182"/>
                <declaration name="openValue" type="Object" line="186"/>
                <scope line="189">
                    <declaration name="decap" type="String" line="190"/>
                    <scope line="193">
                        <declaration name="msg" type="String" line="194"/>
                    </scope>
                </scope>
                <declaration name="mapping" type="MXBeanMapping" line="201"/>
            </method>
            <method name="equals" type="boolean" line="230">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="other" type="Object"/>
                </params>
                <declaration name="proxyClass" type="Class&lt;?&gt;" line="234"/>
                <declaration name="otherClass" type="Class&lt;?&gt;" line="235"/>
                <declaration name="otherih" type="InvocationHandler" line="238"/>
                <declaration name="othercdih" type="CompositeDataInvocationHandler" line="241"/>
            </method>
            <declaration name="compositeData" type="CompositeData" line="246"/>
            <declaration name="lookup" type="MXBeanLookup" line="247"/>
        </class>
    </source>