<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management.openmbean">
        <import package="com.sun.jmx.mbeanserver.MXBeanLookup"/>
        <import package="com.sun.jmx.mbeanserver.MXBeanMapping"/>
        <import package="com.sun.jmx.mbeanserver.MXBeanMappingFactory"/>
        <import package="com.sun.jmx.mbeanserver.DefaultMXBeanMappingFactory"/>
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Proxy"/>
        <class name="CompositeDataInvocationHandler" line="9">
            <implements interface="InvocationHandler"/>
            <javadoc line="9">
                &lt;p&gt;An {@link InvocationHandler} that forwards getter methods to a{@link CompositeData}.  If you have an interface that contains
                  only getter methods (such as {@code String getName()} or{@code boolean isActive()}) then you can use this class in
                  conjunction with the {@link Proxy} class to produce an implementation
                  of the interface where each getter returns the value of the
                  corresponding item in a {@code CompositeData}.&lt;/p&gt;
                  &lt;p&gt;For example, suppose you have an interface like this:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  public interface NamedNumber {
                  public int getNumber();
                  public String getName();
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  and a {@code CompositeData} constructed like this:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  CompositeData cd =
                  new {@link CompositeDataSupport}(
                  someCompositeType,
                  new String[] {&quot;number&quot;, &quot;name&quot;},
                  new Object[] {&lt;b&gt;5&lt;/b&gt;, &quot;five&quot;}
                  );
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  then you can construct an object implementing {@code NamedNumber}and backed by the object {@code cd} like this:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  InvocationHandler handler =
                  new CompositeDataInvocationHandler(cd);
                  NamedNumber nn = (NamedNumber)
                  Proxy.newProxyInstance(NamedNumber.class.getClassLoader(),
                  new Class[] {NamedNumber.class},
                  handler);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  A call to {@code nn.getNumber()} will then return &lt;b&gt;5&lt;/b&gt;.&lt;/p&gt;
                  &lt;p&gt;If the first letter of the property defined by a getter is a
                  capital, then this handler will look first for an item in the{@code CompositeData} beginning with a capital, then, if that is
                  not found, for an item beginning with the corresponding lowercase
                  letter or code point.  For a getter called {@code getNumber()}, the
                  handler will first look for an item called {@code Number}, then for{@code number}.  If the getter is called {@code getnumber()}, then
                  the item must be called {@code number}.&lt;/p&gt;
                  &lt;p&gt;If the method given to {@link #invoke invoke} is the method{@code boolean equals(Object)} inherited from {@code Object}, then
                  it will return true if and only if the argument is a {@code Proxy}whose {@code InvocationHandler} is also a {@codeCompositeDataInvocationHandler} and whose backing {@codeCompositeData} is equal (not necessarily identical) to this
                  object&apos;s.  If the method given to {@code invoke} is the method{@code int hashCode()} inherited from {@code Object}, then it will
                  return a value that is consistent with this definition of {@codeequals}: if two objects are equal according to {@code equals}, then
                  they will have the same {@code hashCode}.&lt;/p&gt;                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <javadoc line="61">
                &lt;p&gt;Construct a handler backed by the given {@codeCompositeData}.&lt;/p&gt;                
                <param>
                    compositeData the {@code CompositeData} that will supply
                      information to getters.                    
                </param>
                <throws>
                    IllegalArgumentException if {@code compositeData}is null.                    
                </throws>
            </javadoc>
            <method name="CompositeDataInvocationHandler" type="constructor" line="67">
                <params>
                    <param name="compositeData" type="CompositeData"/>
                </params>
            </method>
            <javadoc line="70">
                &lt;p&gt;Construct a handler backed by the given {@codeCompositeData}.&lt;/p&gt;                
                <param>
                    mbsc the {@code MBeanServerConnection} related to this{@code CompositeData}.  This is only relevant if a method in
                      the interface for which this is an invocation handler returns
                      a type that is an MXBean interface.  Otherwise, it can be null.                    
                </param>
                <param>
                    compositeData the {@code CompositeData} that will supply
                      information to getters.                    
                </param>
                <throws>
                    IllegalArgumentException if {@code compositeData}is null.                    
                </throws>
            </javadoc>
            <method name="CompositeDataInvocationHandler" type="constructor" line="79">
                <params>
                    <param name="compositeData" type="CompositeData"/>
                    <param name="lookup" type="MXBeanLookup"/>
                </params>
            </method>
            <javadoc line="84">
                Return the {@code CompositeData} that was supplied to the
                  constructor.                
                <return>
                    the {@code CompositeData} that this handler is backed
                      by.  This is never null.                    
                </return>
            </javadoc>
            <method name="getCompositeData" type="CompositeData" line="90"/>
            <method name="invoke" type="Object" line="94">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="method" type="Method"/>
                    <param name="args" type="Object[]"/>
                </params>
                <declaration name="methodName" type="String" line="95"/>
                <scope line="96">
                    <scope line="100"/>
                </scope>
                <declaration name="propertyName" type="String" line="104"/>
                <scope line="105"/>
                <declaration name="openValue" type="Object" line="108"/>
                <scope line="110">
                    <declaration name="decap" type="String" line="111"/>
                    <scope line="113">
                        <declaration name="msg" type="String" line="114"/>
                    </scope>
                </scope>
                <declaration name="mapping" type="MXBeanMapping" line="118"/>
            </method>
            <method name="equals" type="boolean" line="121">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="other" type="Object"/>
                </params>
                <declaration name="proxyClass" type="Class&lt;?&gt;" line="123"/>
                <declaration name="otherClass" type="Class&lt;?&gt;" line="124"/>
                <declaration name="otherih" type="InvocationHandler" line="126"/>
                <declaration name="othercdih" type="CompositeDataInvocationHandler" line="128"/>
            </method>
            <declaration name="compositeData" type="CompositeData" line="131"/>
            <declaration name="lookup" type="MXBeanLookup" line="132"/>
        </class>
    </source>