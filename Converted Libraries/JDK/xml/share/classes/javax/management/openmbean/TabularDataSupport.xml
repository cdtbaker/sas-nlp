<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management.openmbean">
        <import package="com.sun.jmx.mbeanserver.GetPropertyAction"/>
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.Serializable"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.LinkedHashMap"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <class name="TabularDataSupport" line="53">
            <comment line="60">
                It would make much more sense to implement
                Map&lt;List&lt;?&gt;,CompositeData&gt; here, but unfortunately we cannot for
                compatibility reasons.  If we did that, then we would have to
                define e.g.
                CompositeData remove(Object)
                instead of
                Object remove(Object).
                
                That would mean that if any existing code subclassed
                TabularDataSupport and overrode
                Object remove(Object),
                it would (a) no longer compile and (b) not actually override
                CompositeData remove(Object)
                in binaries compiled before the change.                
            </comment>
            <comment line="80">
                                
            </comment>
            <comment line="102">
                                
            </comment>
            <comment line="167">
                                
            </comment>
            <comment line="210">
                                
            </comment>
            <comment line="322">
                                
            </comment>
            <comment line="413">
                                
            </comment>
            <comment line="542">
                                
            </comment>
            <comment line="566">
                                
            </comment>
            <comment line="656">
                                
            </comment>
            <comment line="796">
                                
            </comment>
            <implements interface="TabularData"/>
            <implements interface="Map">
                <type_params>
                    <type_param name="Object"/>
                    <type_param name="Object"/>
                </type_params>
            </implements>
            <implements interface="Cloneable"/>
            <implements interface="Serializable"/>
            <javadoc line="53">
                The &lt;tt&gt;TabularDataSupport&lt;/tt&gt; class is the &lt;i&gt;open data&lt;/i&gt; class which implements the &lt;tt&gt;TabularData&lt;/tt&gt;
                  and the &lt;tt&gt;Map&lt;/tt&gt; interfaces, and which is internally based on a hash map data structure.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="80"/>
            <declaration name="dataMap" type="Map&lt;Object,CompositeData&gt;" line="83"/>
            <javadoc line="83">
                @serial This tabular data instance&apos;s contents: a {@link HashMap}                
            </javadoc>
            <declaration name="tabularType" type="TabularType" line="89"/>
            <javadoc line="89">
                @serial This tabular data instance&apos;s tabular type                
            </javadoc>
            <declaration name="indexNamesArray" type="String[]" line="94"/>
            <javadoc line="94">
                The array of item names that define the index used for rows (convenience field)                
            </javadoc>
            <javadoc line="104">
                Creates an empty &lt;tt&gt;TabularDataSupport&lt;/tt&gt; instance whose open-type is &lt;var&gt;tabularType&lt;/var&gt;,
                  and whose underlying &lt;tt&gt;HashMap&lt;/tt&gt; has a default initial capacity (101) and default load factor (0.75).
                  &lt;p&gt;
                  This constructor simply calls &lt;tt&gt;this(tabularType, 101, 0.75f);&lt;/tt&gt;                
                <param>
                    tabularType               the &lt;i&gt;tabular type&lt;/i&gt; describing this &lt;tt&gt;TabularData&lt;/tt&gt; instance;
                      cannot be null.                    
                </param>
                <throws>
                    IllegalArgumentException  if the tabular type is null.                    
                </throws>
            </javadoc>
            <method name="TabularDataSupport" type="constructor" line="115">
                <params>
                    <param name="tabularType" type="TabularType"/>
                </params>
            </method>
            <javadoc line="120">
                Creates an empty &lt;tt&gt;TabularDataSupport&lt;/tt&gt; instance whose open-type is &lt;var&gt;tabularType&lt;/var&gt;,
                  and whose underlying &lt;tt&gt;HashMap&lt;/tt&gt; has the specified initial capacity and load factor.                
                <param>
                    tabularType               the &lt;i&gt;tabular type&lt;/i&gt; describing this &lt;tt&gt;TabularData&lt;/tt&gt; instance;
                      cannot be null.                    
                </param>
                <param>
                    initialCapacity   the initial capacity of the HashMap.                    
                </param>
                <param>
                    loadFactor        the load factor of the HashMap                    
                </param>
                <throws>
                    IllegalArgumentException  if the initial capacity is less than zero,
                      or the load factor is nonpositive,
                      or the tabular type is null.                    
                </throws>
            </javadoc>
            <method name="TabularDataSupport" type="constructor" line="135">
                <params>
                    <param name="tabularType" type="TabularType"/>
                    <param name="initialCapacity" type="int"/>
                    <param name="loadFactor" type="float"/>
                </params>
                <comment line="138">
                    Check tabularType is not null                    
                </comment>
                <comment line="144">
                    Initialize this.tabularType (and indexNamesArray for convenience)                    
                </comment>
                <comment line="150">
                    Since LinkedHashMap was introduced in SE 1.4, it&apos;s conceivable even
                     if very unlikely that we might be the server of a 1.3 client.  In
                     that case you&apos;ll need to set this property.  See CR 6334663.                    
                </comment>
                <comment line="157">
                    Construct the empty contents HashMap                    
                </comment>
                <scope line="139"/>
                <declaration name="tmpNames" type="List&lt;String&gt;" line="146"/>
                <declaration name="useHashMapProp" type="String" line="152"/>
                <declaration name="useHashMap" type="boolean" line="154"/>
            </method>
            <javadoc line="169">
                Returns the &lt;i&gt;tabular type&lt;/i&gt; describing this &lt;tt&gt;TabularData&lt;/tt&gt; instance.                
            </javadoc>
            <method name="getTabularType" type="TabularType" line="172"/>
            <javadoc line="177">
                Calculates the index that would be used in this &lt;tt&gt;TabularData&lt;/tt&gt; instance to refer to the specified
                  composite data &lt;var&gt;value&lt;/var&gt; parameter if it were added to this instance.
                  This method checks for the type validity of the specified &lt;var&gt;value&lt;/var&gt;,
                  but does not check if the calculated index is already used to refer to a value in this &lt;tt&gt;TabularData&lt;/tt&gt; instance.                
                <param>
                    value                      the composite data value whose index in this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance is to be calculated;
                      must be of the same composite type as this instance&apos;s row type;
                      must not be null.                    
                </param>
                <return>
                    the index that the specified &lt;var&gt;value&lt;/var&gt; would have in this &lt;tt&gt;TabularData&lt;/tt&gt; instance.                    
                </return>
                <throws>
                    NullPointerException       if &lt;var&gt;value&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt;.                    
                </throws>
                <throws>
                    InvalidOpenTypeException   if &lt;var&gt;value&lt;/var&gt; does not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                      row type definition.                    
                </throws>
            </javadoc>
            <method name="calculateIndex" type="Object[]" line="195">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
                <comment line="198">
                    Check value is valid                    
                </comment>
                <comment line="202">
                    Return its calculated index                    
                </comment>
            </method>
            <javadoc line="212">
                Returns &lt;tt&gt;true&lt;/tt&gt; if and only if this &lt;tt&gt;TabularData&lt;/tt&gt; instance contains a &lt;tt&gt;CompositeData&lt;/tt&gt; value
                  (ie a row) whose index is the specified &lt;var&gt;key&lt;/var&gt;. If &lt;var&gt;key&lt;/var&gt; cannot be cast to a one dimension array
                  of Object instances, this method simply returns &lt;tt&gt;false&lt;/tt&gt;; otherwise it returns the the result of the call to
                  &lt;tt&gt;this.containsKey((Object[]) key)&lt;/tt&gt;.                
                <param>
                    key  the index value whose presence in this &lt;tt&gt;TabularData&lt;/tt&gt; instance is to be tested.                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this &lt;tt&gt;TabularData&lt;/tt&gt; indexes a row value with the specified key.                    
                </return>
            </javadoc>
            <method name="containsKey" type="boolean" line="222">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <comment line="225">
                    if key is not an array of Object instances, return false                    
                </comment>
                <declaration name="k" type="Object[]" line="226"/>
                <scope line="227"/>
                <scope line="229"/>
            </method>
            <javadoc line="236">
                Returns &lt;tt&gt;true&lt;/tt&gt; if and only if this &lt;tt&gt;TabularData&lt;/tt&gt; instance contains a &lt;tt&gt;CompositeData&lt;/tt&gt; value
                  (ie a row) whose index is the specified &lt;var&gt;key&lt;/var&gt;. If &lt;var&gt;key&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt; or does not conform to
                  this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s &lt;tt&gt;TabularType&lt;/tt&gt; definition, this method simply returns &lt;tt&gt;false&lt;/tt&gt;.                
                <param>
                    key  the index value whose presence in this &lt;tt&gt;TabularData&lt;/tt&gt; instance is to be tested.                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this &lt;tt&gt;TabularData&lt;/tt&gt; indexes a row value with the specified key.                    
                </return>
            </javadoc>
            <method name="containsKey" type="boolean" line="245">
                <params>
                    <param name="key" type="Object[]"/>
                </params>
            </method>
            <javadoc line="250">
                Returns &lt;tt&gt;true&lt;/tt&gt; if and only if this &lt;tt&gt;TabularData&lt;/tt&gt; instance contains the specified
                  &lt;tt&gt;CompositeData&lt;/tt&gt; value. If &lt;var&gt;value&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt; or does not conform to
                  this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s row type definition, this method simply returns &lt;tt&gt;false&lt;/tt&gt;.                
                <param>
                    value  the row value whose presence in this &lt;tt&gt;TabularData&lt;/tt&gt; instance is to be tested.                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this &lt;tt&gt;TabularData&lt;/tt&gt; instance contains the specified row value.                    
                </return>
            </javadoc>
            <method name="containsValue" type="boolean" line="259">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
            </method>
            <javadoc line="264">
                Returns &lt;tt&gt;true&lt;/tt&gt; if and only if this &lt;tt&gt;TabularData&lt;/tt&gt; instance contains the specified
                  value.                
                <param>
                    value  the row value whose presence in this &lt;tt&gt;TabularData&lt;/tt&gt; instance is to be tested.                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this &lt;tt&gt;TabularData&lt;/tt&gt; instance contains the specified row value.                    
                </return>
            </javadoc>
            <method name="containsValue" type="boolean" line="272">
                <params>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="277">
                This method simply calls &lt;tt&gt;get((Object[]) key)&lt;/tt&gt;.                
                <throws>
                    NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    ClassCastException    if the &lt;var&gt;key&lt;/var&gt; is not of the type &lt;tt&gt;Object[]&lt;/tt&gt;                    
                </throws>
                <throws>
                    InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                      &lt;tt&gt;TabularType&lt;/tt&gt; definition                    
                </throws>
            </javadoc>
            <method name="get" type="Object" line="285">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="290">
                Returns the &lt;tt&gt;CompositeData&lt;/tt&gt; value whose index is
                  &lt;var&gt;key&lt;/var&gt;, or &lt;tt&gt;null&lt;/tt&gt; if there is no value mapping
                  to &lt;var&gt;key&lt;/var&gt;, in this &lt;tt&gt;TabularData&lt;/tt&gt; instance.                
                <param>
                    key the index of the value to get in this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance;  must be valid with this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s row type definition;  must not
                      be null.                    
                </param>
                <return>
                    the value corresponding to &lt;var&gt;key&lt;/var&gt;.                    
                </return>
                <throws>
                    NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                      &lt;tt&gt;TabularType&lt;/tt&gt; type definition.                    
                </throws>
            </javadoc>
            <method name="get" type="CompositeData" line="306">
                <params>
                    <param name="key" type="Object[]"/>
                </params>
                <comment line="309">
                    Check key is not null and valid with tabularType
                     (throws NullPointerException, InvalidKeyException)                    
                </comment>
                <comment line="314">
                    Return the mapping stored in the parent HashMap                    
                </comment>
            </method>
            <javadoc line="324">
                This method simply calls &lt;tt&gt;put((CompositeData) value)&lt;/tt&gt; and
                  therefore ignores its &lt;var&gt;key&lt;/var&gt; parameter which can be &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    key an ignored parameter.                    
                </param>
                <param>
                    value the {@link CompositeData} to put.                    
                </param>
                <return>
                    the value which is put                    
                </return>
                <throws>
                    NullPointerException  if the &lt;var&gt;value&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    ClassCastException if the &lt;var&gt;value&lt;/var&gt; is not of
                      the type &lt;tt&gt;CompositeData&lt;/tt&gt;                    
                </throws>
                <throws>
                    InvalidOpenTypeException if the &lt;var&gt;value&lt;/var&gt; does
                      not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                      &lt;tt&gt;TabularType&lt;/tt&gt; definition                    
                </throws>
                <throws>
                    KeyAlreadyExistsException if the key for the
                      &lt;var&gt;value&lt;/var&gt; parameter, calculated according to this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s &lt;tt&gt;TabularType&lt;/tt&gt; definition
                      already maps to an existing value                    
                </throws>
            </javadoc>
            <method name="put" type="Object" line="344">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <comment line="347">
                    should be return internalPut(...); (5090566)                    
                </comment>
            </method>
            <method name="put" type="void" line="349">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
            </method>
            <method name="internalPut" type="CompositeData" line="353">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
                <comment line="355">
                    Check value is not null, value&apos;s type is the same as this instance&apos;s row type,
                     and calculate the value&apos;s index according to this instance&apos;s tabularType and
                     check it is not already used for a mapping in the parent HashMap                    
                </comment>
                <comment line="361">
                    store the (key, value) mapping in the dataMap HashMap                    
                </comment>
                <declaration name="index" type="List&lt;?&gt;" line="358"/>
            </method>
            <javadoc line="365">
                This method simply calls &lt;tt&gt;remove((Object[]) key)&lt;/tt&gt;.                
                <param>
                    key an &lt;tt&gt;Object[]&lt;/tt&gt; representing the key to remove.                    
                </param>
                <return>
                    previous value associated with specified key, or &lt;tt&gt;null&lt;/tt&gt;
                      if there was no mapping for key.                    
                </return>
                <throws>
                    NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    ClassCastException    if the &lt;var&gt;key&lt;/var&gt; is not of the type &lt;tt&gt;Object[]&lt;/tt&gt;                    
                </throws>
                <throws>
                    InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                      &lt;tt&gt;TabularType&lt;/tt&gt; definition                    
                </throws>
            </javadoc>
            <method name="remove" type="Object" line="378">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="383">
                Removes the &lt;tt&gt;CompositeData&lt;/tt&gt; value whose index is &lt;var&gt;key&lt;/var&gt; from this &lt;tt&gt;TabularData&lt;/tt&gt; instance,
                  and returns the removed value, or returns &lt;tt&gt;null&lt;/tt&gt; if there is no value whose index is &lt;var&gt;key&lt;/var&gt;.                
                <param>
                    key  the index of the value to get in this &lt;tt&gt;TabularData&lt;/tt&gt; instance;
                      must be valid with this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s row type definition;
                      must not be null.                    
                </param>
                <return>
                    previous value associated with specified key, or &lt;tt&gt;null&lt;/tt&gt;
                      if there was no mapping for key.                    
                </return>
                <throws>
                    NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                      &lt;tt&gt;TabularType&lt;/tt&gt; definition                    
                </throws>
            </javadoc>
            <method name="remove" type="CompositeData" line="398">
                <params>
                    <param name="key" type="Object[]"/>
                </params>
                <comment line="401">
                    Check key is not null and valid with tabularType
                     (throws NullPointerException, InvalidKeyException)                    
                </comment>
                <comment line="406">
                    Removes the (key, value) mapping in the parent HashMap                    
                </comment>
            </method>
            <javadoc line="415">
                Add all the values contained in the specified map &lt;var&gt;t&lt;/var&gt;
                  to this &lt;tt&gt;TabularData&lt;/tt&gt; instance.  This method converts
                  the collection of values contained in this map into an array of
                  &lt;tt&gt;CompositeData&lt;/tt&gt; values, if possible, and then call the
                  method &lt;tt&gt;putAll(CompositeData[])&lt;/tt&gt;. Note that the keys
                  used in the specified map &lt;var&gt;t&lt;/var&gt; are ignored. This method
                  allows, for example to add the content of another
                  &lt;tt&gt;TabularData&lt;/tt&gt; instance with the same row type (but
                  possibly different index names) into this instance.                
                <param>
                    t the map whose values are to be added as new rows to
                      this &lt;tt&gt;TabularData&lt;/tt&gt; instance; if &lt;var&gt;t&lt;/var&gt; is
                      &lt;tt&gt;null&lt;/tt&gt; or empty, this method returns without doing
                      anything.                    
                </param>
                <throws>
                    NullPointerException if a value in &lt;var&gt;t&lt;/var&gt; is
                      &lt;tt&gt;null&lt;/tt&gt;.                    
                </throws>
                <throws>
                    ClassCastException if a value in &lt;var&gt;t&lt;/var&gt; is not an
                      instance of &lt;tt&gt;CompositeData&lt;/tt&gt;.                    
                </throws>
                <throws>
                    InvalidOpenTypeException if a value in &lt;var&gt;t&lt;/var&gt;
                      does not conform to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s row
                      type definition.                    
                </throws>
                <throws>
                    KeyAlreadyExistsException if the index for a value in
                      &lt;var&gt;t&lt;/var&gt;, calculated according to this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s &lt;tt&gt;TabularType&lt;/tt&gt; definition
                      already maps to an existing value in this instance, or two
                      values in &lt;var&gt;t&lt;/var&gt; have the same index.                    
                </throws>
            </javadoc>
            <method name="putAll" type="void" line="444">
                <params>
                    <param name="t" type="Map<?,?>"/>
                </params>
                <comment line="447">
                    if t is null or empty, just return                    
                </comment>
                <comment line="453">
                    Convert the values in t into an array of &lt;tt&gt;CompositeData&lt;/tt&gt;                    
                </comment>
                <comment line="463">
                    Add the array of values                    
                </comment>
                <scope line="448"/>
                <declaration name="values" type="CompositeData[]" line="454"/>
                <scope line="455"/>
                <scope line="458"/>
            </method>
            <javadoc line="467">
                Add all the elements in &lt;var&gt;values&lt;/var&gt; to this
                  &lt;tt&gt;TabularData&lt;/tt&gt; instance.  If any element in
                  &lt;var&gt;values&lt;/var&gt; does not satisfy the constraints defined in{@link #put(CompositeData) &lt;tt&gt;put&lt;/tt&gt;}, or if any two
                  elements in &lt;var&gt;values&lt;/var&gt; have the same index calculated
                  according to this &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s
                  &lt;tt&gt;TabularType&lt;/tt&gt; definition, then an exception describing
                  the failure is thrown and no element of &lt;var&gt;values&lt;/var&gt; is
                  added, thus leaving this &lt;tt&gt;TabularData&lt;/tt&gt; instance
                  unchanged.                
                <param>
                    values the array of composite data values to be added as
                      new rows to this &lt;tt&gt;TabularData&lt;/tt&gt; instance; if
                      &lt;var&gt;values&lt;/var&gt; is &lt;tt&gt;null&lt;/tt&gt; or empty, this method
                      returns without doing anything.                    
                </param>
                <throws>
                    NullPointerException if an element of &lt;var&gt;values&lt;/var&gt;
                      is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    InvalidOpenTypeException if an element of
                      &lt;var&gt;values&lt;/var&gt; does not conform to this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s row type definition (ie its
                      &lt;tt&gt;TabularType&lt;/tt&gt; definition)                    
                </throws>
                <throws>
                    KeyAlreadyExistsException if the index for an element
                      of &lt;var&gt;values&lt;/var&gt;, calculated according to this
                      &lt;tt&gt;TabularData&lt;/tt&gt; instance&apos;s &lt;tt&gt;TabularType&lt;/tt&gt; definition
                      already maps to an existing value in this instance, or two
                      elements of &lt;var&gt;values&lt;/var&gt; have the same index                    
                </throws>
            </javadoc>
            <method name="putAll" type="void" line="496">
                <params>
                    <param name="values" type="CompositeData[]"/>
                </params>
                <comment line="499">
                    if values is null or empty, just return                    
                </comment>
                <comment line="505">
                    create the list of indexes corresponding to each value                    
                </comment>
                <comment line="509">
                    Check all elements in values and build index list                    
                </comment>
                <comment line="513">
                    check value and calculate index                    
                </comment>
                <comment line="515">
                    check index is different of those previously calculated                    
                </comment>
                <comment line="521">
                    add to index list                    
                </comment>
                <comment line="525">
                    store all (index, value) mappings in the dataMap HashMap                    
                </comment>
                <scope line="500"/>
                <declaration name="indexes" type="List&lt;List&lt;?&gt;&gt;" line="505"/>
                <declaration name="index" type="List&lt;?&gt;" line="510"/>
                <scope line="511">
                    <scope line="515"/>
                </scope>
                <scope line="526"/>
            </method>
            <javadoc line="531">
                Removes all rows from this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance.                
            </javadoc>
            <method name="clear" type="void" line="534"/>
            <javadoc line="543">
                Returns the number of rows in this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance.                
                <return>
                    the number of rows in this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance.                    
                </return>
            </javadoc>
            <method name="size" type="int" line="548"/>
            <javadoc line="553">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance contains no rows.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance contains no rows.                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="558"/>
            <javadoc line="567">
                Returns a set view of the keys contained in the underlying map of this{@code TabularDataSupport} instance used to index the rows.
                  Each key contained in this {@code Set} is an unmodifiable {@code List&lt;?&gt;}so the returned set view is a {@code Set&lt;List&lt;?&gt;&gt;} but is declared as a{@code Set&lt;Object&gt;} for compatibility reasons.
                  The set is backed by the underlying map of this{@code TabularDataSupport} instance, so changes to the{@code TabularDataSupport} instance are reflected in the
                  set, and vice-versa.
                  The set supports element removal, which removes the corresponding
                  row from this {@code TabularDataSupport} instance, via the{@link Iterator#remove}, {@link Set#remove}, {@link Set#removeAll},{@link Set#retainAll}, and {@link Set#clear} operations. It does
                  not support the {@link Set#add} or {@link Set#addAll} operations.                
                <return>
                    a set view ({@code Set&lt;List&lt;?&gt;&gt;}) of the keys used to index
                      the rows of this {@code TabularDataSupport} instance.                    
                </return>
            </javadoc>
            <method name="keySet" type="Set<Object>" line="587"/>
            <javadoc line="592">
                Returns a collection view of the rows contained in this{@code TabularDataSupport} instance. The returned {@code Collection}is a {@code Collection&lt;CompositeData&gt;} but is declared as a{@code Collection&lt;Object&gt;} for compatibility reasons.
                  The returned collection can be used to iterate over the values.
                  The collection is backed by the underlying map, so changes to the{@code TabularDataSupport} instance are reflected in the collection,
                  and vice-versa.
                  The collection supports element removal, which removes the corresponding
                  index to row mapping from this {@code TabularDataSupport} instance, via
                  the {@link Iterator#remove}, {@link Collection#remove},{@link Collection#removeAll}, {@link Collection#retainAll},
                  and {@link Collection#clear} operations. It does not support
                  the {@link Collection#add} or {@link Collection#addAll} operations.                
                <return>
                    a collection view ({@code Collection&lt;CompositeData&gt;}) of
                      the values contained in this {@code TabularDataSupport} instance.                    
                </return>
            </javadoc>
            <method name="values" type="Collection<Object>" line="613">
                <comment line="613">
                    historical confusion about the return type                    
                </comment>
            </method>
            <javadoc line="619">
                Returns a collection view of the index to row mappings
                  contained in this {@code TabularDataSupport} instance.
                  Each element in the returned collection is
                  a {@code Map.Entry&lt;List&lt;?&gt;,CompositeData&gt;} but
                  is declared as a {@code Map.Entry&lt;Object,Object&gt;}for compatibility reasons. Each of the map entry
                  keys is an unmodifiable {@code List&lt;?&gt;}.
                  The collection is backed by the underlying map of this{@code TabularDataSupport} instance, so changes to the{@code TabularDataSupport} instance are reflected in
                  the collection, and vice-versa.
                  The collection supports element removal, which removes
                  the corresponding mapping from the map, via the{@link Iterator#remove}, {@link Collection#remove},{@link Collection#removeAll}, {@link Collection#retainAll},
                  and {@link Collection#clear} operations. It does not support
                  the {@link Collection#add} or {@link Collection#addAll}operations.
                  &lt;p&gt;
                  &lt;b&gt;IMPORTANT NOTICE&lt;/b&gt;: Do not use the {@code setValue} method of the{@code Map.Entry} elements contained in the returned collection view.
                  Doing so would corrupt the index to row mappings contained in this{@code TabularDataSupport} instance.                
                <return>
                    a collection view ({@code Set&lt;Map.Entry&lt;List&lt;?&gt;,CompositeData&gt;&gt;})
                      of the mappings contained in this map.                    
                </return>
                <see>
                    java.util.Map.Entry                    
                </see>
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<Object,Object>>" line="649">
                <comment line="649">
                    historical confusion about the return type                    
                </comment>
            </method>
            <javadoc line="658">
                Returns a clone of this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance:
                  the clone is obtained by calling &lt;tt&gt;super.clone()&lt;/tt&gt;, and then cloning the underlying map.
                  Only a shallow clone of the underlying map is made, i.e. no cloning of the indexes and row values is made as they are immutable.                
            </javadoc>
            <method name="clone" type="Object" line="667">
                <comment line="664">
                    We cannot use covariance here and return TabularDataSupport
                    because this would fail with existing code that subclassed
                    TabularDataSupport and overrode Object clone().  It would not                    
                </comment>
                <scope line="668">
                    <declaration name="c" type="TabularDataSupport" line="669"/>
                </scope>
                <scope line="673"/>
            </method>
            <javadoc line="679">
                Compares the specified &lt;var&gt;obj&lt;/var&gt; parameter with this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance for equality.
                  &lt;p&gt;
                  Returns &lt;tt&gt;true&lt;/tt&gt; if and only if all of the following statements are true:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;var&gt;obj&lt;/var&gt; is non null,&lt;/li&gt;
                  &lt;li&gt;&lt;var&gt;obj&lt;/var&gt; also implements the &lt;code&gt;TabularData&lt;/code&gt; interface,&lt;/li&gt;
                  &lt;li&gt;their tabular types are equal&lt;/li&gt;
                  &lt;li&gt;their contents (ie all CompositeData values) are equal.&lt;/li&gt;
                  &lt;/ul&gt;
                  This ensures that this &lt;tt&gt;equals&lt;/tt&gt; method works properly for &lt;var&gt;obj&lt;/var&gt; parameters which are
                  different implementations of the &lt;code&gt;TabularData&lt;/code&gt; interface.
                  &lt;br&gt;&amp;nbsp;                
                <param>
                    obj  the object to be compared for equality with this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance;                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the specified object is equal to this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="696">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="699">
                    if obj is null, return false                    
                </comment>
                <comment line="705">
                    if obj is not a TabularData, return false                    
                </comment>
                <comment line="714">
                    Now, really test for equality between this TabularData implementation and the other:                    
                </comment>
                <comment line="717">
                    their tabularType should be equal                    
                </comment>
                <comment line="722">
                    their contents should be equal:
                     . same size
                     . values in this instance are in the other (we know there are no duplicate elements possible)
                     (row values comparison is enough, because keys are calculated according to tabularType)                    
                </comment>
                <comment line="736">
                    All tests for equality were successfull                    
                </comment>
                <scope line="700"/>
                <declaration name="other" type="TabularData" line="706"/>
                <scope line="707"/>
                <scope line="709"/>
                <scope line="717"/>
                <scope line="726"/>
                <scope line="729">
                    <scope line="730"/>
                </scope>
            </method>
            <javadoc line="740">
                Returns the hash code value for this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance.
                  &lt;p&gt;
                  The hash code of a &lt;code&gt;TabularDataSupport&lt;/code&gt; instance is the sum of the hash codes
                  of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons
                  (ie: its &lt;i&gt;tabular type&lt;/i&gt; and its content, where the content is defined as all the CompositeData values).
                  &lt;p&gt;
                  This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt;
                  for any two &lt;code&gt;TabularDataSupport&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;,
                  as required by the general contract of the method{@link Object#hashCode() Object.hashCode()}.
                  &lt;p&gt;
                  However, note that another instance of a class implementing the &lt;code&gt;TabularData&lt;/code&gt; interface
                  may be equal to this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance as defined by {@link #equals},
                  but may have a different hash code if it is calculated differently.                
                <return>
                    the hash code value for this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="758">
                <declaration name="result" type="int" line="760"/>
            </method>
            <javadoc line="770">
                Returns a string representation of this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance.
                  &lt;p&gt;
                  The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;),
                  the string representation of the tabular type of this instance, and the string representation of the contents
                  (ie list the key=value mappings as returned by a call to
                  &lt;tt&gt;dataMap.&lt;/tt&gt;{@link java.util.HashMap#toString() toString()}).                
                <return>
                    a string representation of this &lt;code&gt;TabularDataSupport&lt;/code&gt; instance                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="780"/>
            <javadoc line="798">
                Returns the index for value, assuming value is valid for this &lt;tt&gt;TabularData&lt;/tt&gt; instance
                  (ie value is not null, and its composite type is equal to row type).
                  The index is a List, and not an array, so that an index.equals(otherIndex) call will actually compare contents,
                  not just the objects references as is done for an array object.
                  The returned List is unmodifiable so that once a row has been put into the dataMap, its index cannot be modified,
                  for example by a user that would attempt to modify an index contained in the Set returned by keySet().                
            </javadoc>
            <method name="internalCalculateIndex" type="List<?>" line="808">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
            </method>
            <javadoc line="813">
                Checks if the specified key is valid for this &lt;tt&gt;TabularData&lt;/tt&gt; instance.                
                <throws>
                    NullPointerException                    
                </throws>
                <throws>
                    InvalidOpenTypeException                    
                </throws>
            </javadoc>
            <method name="checkKeyType" type="void" line="819">
                <params>
                    <param name="key" type="Object[]"/>
                </params>
                <comment line="822">
                    Check key is neither null nor empty                    
                </comment>
                <comment line="828">
                                        
                </comment>
                <comment line="830">
                    key[] should have the size expected for an index                    
                </comment>
                <comment line="838">
                    each element in key[] should be a value for its corresponding open type specified in rowType                    
                </comment>
                <scope line="823"/>
                <scope line="831"/>
                <declaration name="keyElementType" type="OpenType&lt;?&gt;" line="839"/>
                <scope line="840">
                    <scope line="842"/>
                </scope>
            </method>
            <javadoc line="850">
                Checks the specified value&apos;s type is valid for this &lt;tt&gt;TabularData&lt;/tt&gt; instance
                  (ie value is not null, and its composite type is equal to row type).                
                <throws>
                    NullPointerException                    
                </throws>
                <throws>
                    InvalidOpenTypeException                    
                </throws>
            </javadoc>
            <method name="checkValueType" type="void" line="857">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
                <comment line="860">
                    Check value is not null                    
                </comment>
                <comment line="866">
                    if value&apos;s type is not the same as this instance&apos;s row type, throw InvalidOpenTypeException                    
                </comment>
                <scope line="861"/>
                <scope line="867"/>
            </method>
            <javadoc line="874">
                Checks if the specified value can be put (ie added) in this &lt;tt&gt;TabularData&lt;/tt&gt; instance
                  (ie value is not null, its composite type is equal to row type, and its index is not already used),
                  and returns the index calculated for this value.
                  The index is a List, and not an array, so that an index.equals(otherIndex) call will actually compare contents,
                  not just the objects references as is done for an array object.                
                <throws>
                    NullPointerException                    
                </throws>
                <throws>
                    InvalidOpenTypeException                    
                </throws>
                <throws>
                    KeyAlreadyExistsException                    
                </throws>
            </javadoc>
            <method name="checkValueAndIndex" type="List<?>" line="886">
                <params>
                    <param name="value" type="CompositeData"/>
                </params>
                <comment line="889">
                    Check value is valid                    
                </comment>
                <comment line="893">
                    Calculate value&apos;s index according to this instance&apos;s tabularType
                     and check it is not already used for a mapping in the parent HashMap                    
                </comment>
                <comment line="903">
                    The check is OK, so return the index                    
                </comment>
                <declaration name="index" type="List&lt;?&gt;" line="895"/>
                <scope line="897"/>
            </method>
            <javadoc line="907">
                Deserializes a {@link TabularDataSupport} from an {@link ObjectInputStream}.                
            </javadoc>
            <method name="readObject" type="void" line="911">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <declaration name="tmpNames" type="List&lt;String&gt;" line="913"/>
            </method>
        </class>
    </source>