<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management">
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="java.io.InvalidObjectException"/>
        <import package="java.lang.reflect.Array"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.Map"/>
        <import package="java.util.SortedMap"/>
        <import package="java.util.TreeMap"/>
        <class name="ImmutableDescriptor" line="37">
            <implements interface="Descriptor"/>
            <javadoc line="37">
                An immutable descriptor.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="42"/>
            <declaration name="names" type="String[]" line="44"/>
            <javadoc line="44">
                The names of the fields in this ImmutableDescriptor with their
                  original case.  The names must be in alphabetical order as determined
                  by {@link String#CASE_INSENSITIVE_ORDER}.                
            </javadoc>
            <declaration name="values" type="Object[]" line="50"/>
            <javadoc line="50">
                The values of the fields in this ImmutableDescriptor.  The
                  elements in this array match the corresponding elements in the{@code names} array.                
            </javadoc>
            <declaration name="hashCode" type="int" line="57"/>
            <declaration name="EMPTY_DESCRIPTOR" type="ImmutableDescriptor" line="59"/>
            <javadoc line="59">
                An empty descriptor.                
            </javadoc>
            <javadoc line="65">
                Construct a descriptor containing the given fields and values.                
                <throws>
                    IllegalArgumentException if either array is null, or
                      if the arrays have different sizes, or
                      if a field name is null or empty, or if the same field name
                      appears more than once.                    
                </throws>
            </javadoc>
            <method name="ImmutableDescriptor" type="constructor" line="73">
                <params>
                    <param name="fieldNames" type="String[]"/>
                    <param name="fieldValues" type="Object[]"/>
                </params>
            </method>
            <javadoc line="77">
                Construct a descriptor containing the given fields.  Each String
                  must be of the form {@code fieldName=fieldValue}.  The field name
                  ends at the first {@code =} character; for example if the String
                  is {@code a=b=c} then the field name is {@code a} and its value
                  is {@code b=c}.                
                <throws>
                    IllegalArgumentException if the parameter is null, or
                      if a field name is empty, or if the same field name appears
                      more than once, or if one of the strings does not contain
                      an {@code =} character.                    
                </throws>
            </javadoc>
            <method name="ImmutableDescriptor" type="constructor" line="89">
                <params>
                    <param name="fields" type="String"/>
                </params>
            </method>
            <javadoc line="93">
                &lt;p&gt;Construct a descriptor where the names and values of the fields
                  are the keys and values of the given Map.&lt;/p&gt;                
                <throws>
                    IllegalArgumentException if the parameter is null, or
                      if a field name is null or empty, or if the same field name appears
                      more than once (which can happen because field names are not case
                      sensitive).                    
                </throws>
            </javadoc>
            <method name="ImmutableDescriptor" type="constructor" line="102">
                <params>
                    <param name="fields" type="Map<String,?>"/>
                </params>
                <declaration name="map" type="SortedMap&lt;String,Object&gt;" line="105"/>
                <scope line="107">
                    <declaration name="name" type="String" line="108"/>
                </scope>
                <declaration name="size" type="int" line="115"/>
            </method>
            <javadoc line="120">
                This method can replace a deserialized instance of this
                  class with another instance.  For example, it might replace
                  a deserialized empty ImmutableDescriptor with{@link #EMPTY_DESCRIPTOR}.                
                <return>
                    the replacement object, which may be {@code this}.                    
                </return>
                <throws>
                    InvalidObjectException if the read object has invalid fields.                    
                </throws>
            </javadoc>
            <method name="readResolve" type="Object" line="130">
                <comment line="140">
                    also catches illegal null name                    
                </comment>
                <declaration name="bad" type="boolean" line="132"/>
                <scope line="135">
                    <declaration name="compare" type="Comparator&lt;String&gt;" line="138"/>
                    <declaration name="lastName" type="String" line="139"/>
                    <scope line="140">
                        <scope line="142"/>
                    </scope>
                </scope>
            </method>
            <method name="makeMap" type="SortedMap<String,?>" line="156">
                <params>
                    <param name="fieldNames" type="String[]"/>
                    <param name="fieldValues" type="Object[]"/>
                </params>
                <declaration name="map" type="SortedMap&lt;String,Object&gt;" line="161"/>
                <scope line="163">
                    <declaration name="name" type="String" line="164"/>
                    <declaration name="old" type="Object" line="167"/>
                    <scope line="168"/>
                </scope>
            </method>
            <method name="makeMap" type="SortedMap<String,?>" line="176">
                <params>
                    <param name="fields" type="String[]"/>
                </params>
                <comment line="190">
                    makeMap will catch the case where the name is empty                    
                </comment>
                <declaration name="fieldNames" type="String[]" line="179"/>
                <declaration name="fieldValues" type="String[]" line="180"/>
                <scope line="181">
                    <declaration name="field" type="String" line="182"/>
                    <declaration name="eq" type="int" line="183"/>
                    <scope line="184"/>
                </scope>
            </method>
            <javadoc line="195">
                &lt;p&gt;Return an {@code ImmutableDescriptor} whose contents are the union of
                  the given descriptors.  Every field name that appears in any of
                  the descriptors will appear in the result with the
                  value that it has when the method is called.  Subsequent changes
                  to any of the descriptors do not affect the ImmutableDescriptor
                  returned here.&lt;/p&gt;
                  &lt;p&gt;In the simplest case, there is only one descriptor and the
                  returned {@code ImmutableDescriptor} is a copy of its fields at the
                  time this method is called:&lt;/p&gt;
                  &lt;pre&gt;
                  Descriptor d = something();
                  ImmutableDescriptor copy = ImmutableDescriptor.union(d);
                  &lt;/pre&gt;                
                <param>
                    descriptors the descriptors to be combined.  Any of the
                      descriptors can be null, in which case it is skipped.                    
                </param>
                <return>
                    an {@code ImmutableDescriptor} that is the union of the given
                      descriptors.  The returned object may be identical to one of the
                      input descriptors if it is an ImmutableDescriptor that contains all of
                      the required fields.                    
                </return>
                <throws>
                    IllegalArgumentException if two Descriptors contain the
                      same field name with different associated values.  Primitive array
                      values are considered the same if they are of the same type with
                      the same elements.  Object array values are considered the same if{@link Arrays#deepEquals(Object[],Object[])} returns true.                    
                </throws>
            </javadoc>
            <method name="union" type="ImmutableDescriptor" line="226">
                <params>
                    <param name="descriptors" type="Descriptor"/>
                </params>
                <comment line="228">
                    Optimize the case where exactly one Descriptor is non-Empty
                     and it is immutable - we can just return it.                    
                </comment>
                <declaration name="index" type="int" line="229"/>
                <declaration name="map" type="Map&lt;String,Object&gt;" line="236"/>
                <declaration name="biggestImmutable" type="ImmutableDescriptor" line="238"/>
                <scope line="239">
                    <scope line="240">
                        <declaration name="names" type="String[]" line="241"/>
                        <scope line="242">
                            <declaration name="id" type="ImmutableDescriptor" line="243"/>
                        </scope>
                        <scope line="250">
                            <declaration name="v" type="Object" line="251"/>
                            <declaration name="old" type="Object" line="252"/>
                            <scope line="253">
                                <declaration name="equal" type="boolean" line="254"/>
                                <scope line="255"/>
                                <scope line="260">
                                    <declaration name="msg" type="String" line="261"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="isEmpty" type="boolean" line="275">
                <params>
                    <param name="d" type="Descriptor"/>
                </params>
            </method>
            <method name="findNonEmpty" type="int" line="284">
                <params>
                    <param name="ds" type="Descriptor[]"/>
                    <param name="start" type="int"/>
                </params>
                <scope line="285"/>
            </method>
            <method name="fieldIndex" type="int" line="292">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="getFieldValue" type="Object" line="296">
                <params>
                    <param name="fieldName" type="String"/>
                </params>
                <comment line="307">
                    clone the primitive array, could use an 8-way if/else here                    
                </comment>
                <declaration name="i" type="int" line="298"/>
                <declaration name="v" type="Object" line="301"/>
                <declaration name="len" type="int" line="307"/>
                <declaration name="a" type="Object" line="308"/>
            </method>
            <method name="getFields" type="String[]" line="313">
                <declaration name="result" type="String[]" line="314"/>
                <scope line="315">
                    <declaration name="value" type="Object" line="316"/>
                </scope>
            </method>
            <method name="getFieldValues" type="Object[]" line="326">
                <params>
                    <param name="fieldNames" type="String"/>
                </params>
                <declaration name="result" type="Object[]" line="329"/>
                <scope line="330">
                    <declaration name="name" type="String" line="331"/>
                </scope>
            </method>
            <method name="getFieldNames" type="String[]" line="338"/>
            <javadoc line="342">
                Compares this descriptor to the given object.  The objects are equal if
                  the given object is also a Descriptor, and if the two Descriptors have
                  the same field names (possibly differing in case) and the same
                  associated values.  The respective values for a field in the two
                  Descriptors are equal if the following conditions hold:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;If one value is null then the other must be too.&lt;/li&gt;
                  &lt;li&gt;If one value is a primitive array then the other must be a primitive
                  array of the same type with the same elements.&lt;/li&gt;
                  &lt;li&gt;If one value is an object array then the other must be too and{@link Arrays#deepEquals(Object[],Object[])} must return true.&lt;/li&gt;
                  &lt;li&gt;Otherwise {@link Object#equals(Object)} must return true.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    o the object to compare with.                    
                </param>
                <return>
                    {@code true} if the objects are the same; {@code false}otherwise.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="367">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <comment line="365">
                    Note: this Javadoc is copied from javax.management.Descriptor
                           due to 6369229.                    
                </comment>
                <declaration name="onames" type="String[]" line="372"/>
                <scope line="373"/>
                <scope line="375"/>
                <scope line="381"/>
                <declaration name="ovalues" type="Object[]" line="385"/>
            </method>
            <javadoc line="393">
                &lt;p&gt;Returns the hash code value for this descriptor.  The hash
                  code is computed as the sum of the hash codes for each field in
                  the descriptor.  The hash code of a field with name {@code n}and value {@code v} is {@code n.toLowerCase().hashCode() ^ h}.
                  Here {@code h} is the hash code of {@code v}, computed as
                  follows:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;If {@code v} is null then {@code h} is 0.&lt;/li&gt;
                  &lt;li&gt;If {@code v} is a primitive array then {@code h} is computed using
                  the appropriate overloading of {@code java.util.Arrays.hashCode}.&lt;/li&gt;
                  &lt;li&gt;If {@code v} is an object array then {@code h} is computed using{@link Arrays#deepHashCode(Object[])}.&lt;/li&gt;
                  &lt;li&gt;Otherwise {@code h} is {@code v.hashCode()}.&lt;/li&gt;
                  &lt;/ul&gt;                
                <return>
                    A hash code value for this object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="416">
                <comment line="414">
                    Note: this Javadoc is copied from javax.management.Descriptor
                           due to 6369229.                    
                </comment>
                <scope line="417"/>
            </method>
            <method name="toString" type="String" line="424">
                <comment line="434">
                    remove [...]                    
                </comment>
                <declaration name="sb" type="StringBuilder" line="425"/>
                <scope line="426">
                    <declaration name="v" type="Object" line="430"/>
                    <scope line="431">
                        <declaration name="s" type="String" line="432"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="441">
                Returns true if all of the fields have legal values given their
                  names.  This method always returns true, but a subclass can
                  override it to return false when appropriate.                
                <return>
                    true if the values are legal.                    
                </return>
                <exception>
                    RuntimeOperationsException if the validity checking fails.
                      The method returns false if the descriptor is not valid, but throws
                      this exception if the attempt to determine validity fails.                    
                </exception>
            </javadoc>
            <method name="isValid" type="boolean" line="452"/>
            <javadoc line="456">
                &lt;p&gt;Returns a descriptor which is equal to this descriptor.
                  Changes to the returned descriptor will have no effect on this
                  descriptor, and vice versa.&lt;/p&gt;
                  &lt;p&gt;This method returns the object on which it is called.
                  A subclass can override it
                  to return another object provided the contract is respected.                
                <exception>
                    RuntimeOperationsException for illegal value for field Names
                      or field Values.
                      If the descriptor construction fails for any reason, this exception will
                      be thrown.                    
                </exception>
            </javadoc>
            <method name="clone" type="Descriptor" line="471"/>
            <javadoc line="475">
                This operation is unsupported since this class is immutable.  If
                  this call would change a mutable descriptor with the same contents,
                  then a {@link RuntimeOperationsException} wrapping an{@link UnsupportedOperationException} is thrown.  Otherwise,
                  the behavior is the same as it would be for a mutable descriptor:
                  either an exception is thrown because of illegal parameters, or
                  there is no effect.                
            </javadoc>
            <method name="setFields" type="void" line="485">
                <params>
                    <param name="fieldNames" type="String[]"/>
                    <param name="fieldValues" type="Object[]"/>
                </params>
            </method>
            <javadoc line="496">
                This operation is unsupported since this class is immutable.  If
                  this call would change a mutable descriptor with the same contents,
                  then a {@link RuntimeOperationsException} wrapping an{@link UnsupportedOperationException} is thrown.  Otherwise,
                  the behavior is the same as it would be for a mutable descriptor:
                  either an exception is thrown because of illegal parameters, or
                  there is no effect.                
            </javadoc>
            <method name="setField" type="void" line="506">
                <params>
                    <param name="fieldName" type="String"/>
                    <param name="fieldValue" type="Object"/>
                </params>
                <declaration name="i" type="int" line="508"/>
                <declaration name="value" type="Object" line="511"/>
            </method>
            <javadoc line="518">
                Removes a field from the descriptor.                
                <param>
                    fieldName String name of the field to be removed.
                      If the field name is illegal or the field is not found,
                      no exception is thrown.                    
                </param>
                <exception>
                    RuntimeOperationsException if a field of the given name
                      exists and the descriptor is immutable.  The wrapped exception will
                      be an {@link UnsupportedOperationException}.                    
                </exception>
            </javadoc>
            <method name="removeField" type="void" line="529">
                <params>
                    <param name="fieldName" type="String"/>
                </params>
            </method>
            <method name="nonNullDescriptor" type="Descriptor" line="534">
                <params>
                    <param name="d" type="Descriptor"/>
                </params>
            </method>
            <method name="checkIllegalFieldName" type="void" line="541">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="unsupported" type="void" line="546">
                <declaration name="uoe" type="UnsupportedOperationException" line="547"/>
            </method>
            <method name="illegal" type="void" line="552">
                <params>
                    <param name="message" type="String"/>
                </params>
                <declaration name="iae" type="IllegalArgumentException" line="553"/>
            </method>
        </class>
    </source>