<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management.remote.rmi">
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="com.sun.jmx.remote.internal.ClientCommunicatorAdmin"/>
        <import package="com.sun.jmx.remote.internal.ClientListenerInfo"/>
        <import package="com.sun.jmx.remote.internal.ClientNotifForwarder"/>
        <import package="com.sun.jmx.remote.internal.ProxyRef"/>
        <import package="com.sun.jmx.remote.internal.IIOPHelper"/>
        <import package="com.sun.jmx.remote.util.ClassLogger"/>
        <import package="com.sun.jmx.remote.util.EnvHelp"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.NotSerializableException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectStreamClass"/>
        <import package="java.io.Serializable"/>
        <import package="java.io.WriteAbortedException"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.net.MalformedURLException"/>
        <import package="java.rmi.MarshalException"/>
        <import package="java.rmi.MarshalledObject"/>
        <import package="java.rmi.NoSuchObjectException"/>
        <import package="java.rmi.Remote"/>
        <import package="java.rmi.ServerException"/>
        <import package="java.rmi.UnmarshalException"/>
        <import package="java.rmi.server.RMIClientSocketFactory"/>
        <import package="java.rmi.server.RemoteObject"/>
        <import package="java.rmi.server.RemoteObjectInvocationHandler"/>
        <import package="java.rmi.server.RemoteRef"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.ProtectionDomain"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Map"/>
        <import package="java.util.Properties"/>
        <import package="java.util.Set"/>
        <import package="java.util.WeakHashMap"/>
        <import package="javax.management.Attribute"/>
        <import package="javax.management.AttributeList"/>
        <import package="javax.management.AttributeNotFoundException"/>
        <import package="javax.management.InstanceAlreadyExistsException"/>
        <import package="javax.management.InstanceNotFoundException"/>
        <import package="javax.management.IntrospectionException"/>
        <import package="javax.management.InvalidAttributeValueException"/>
        <import package="javax.management.ListenerNotFoundException"/>
        <import package="javax.management.MBeanException"/>
        <import package="javax.management.MBeanInfo"/>
        <import package="javax.management.MBeanRegistrationException"/>
        <import package="javax.management.MBeanServerConnection"/>
        <import package="javax.management.MBeanServerDelegate"/>
        <import package="javax.management.MBeanServerNotification"/>
        <import package="javax.management.NotCompliantMBeanException"/>
        <import package="javax.management.Notification"/>
        <import package="javax.management.NotificationBroadcasterSupport"/>
        <import package="javax.management.NotificationFilter"/>
        <import package="javax.management.NotificationFilterSupport"/>
        <import package="javax.management.NotificationListener"/>
        <import package="javax.management.ObjectInstance"/>
        <import package="javax.management.ObjectName"/>
        <import package="javax.management.QueryExp"/>
        <import package="javax.management.ReflectionException"/>
        <import package="javax.management.remote.JMXConnectionNotification"/>
        <import package="javax.management.remote.JMXConnector"/>
        <import package="javax.management.remote.JMXConnectorFactory"/>
        <import package="javax.management.remote.JMXServiceURL"/>
        <import package="javax.management.remote.NotificationResult"/>
        <import package="javax.management.remote.JMXAddressable"/>
        <import package="javax.naming.InitialContext"/>
        <import package="javax.naming.NamingException"/>
        <import package="javax.rmi.ssl.SslRMIClientSocketFactory"/>
        <import package="javax.security.auth.Subject"/>
        <import package="sun.rmi.server.UnicastRef2"/>
        <import package="sun.rmi.transport.LiveRef"/>
        <class name="RMIConnector" line="109">
            <comment line="239">
                --------------------------------------------------------------------
                 implements JMXConnector interface
                --------------------------------------------------------------------                
            </comment>
            <comment line="444">
                allows to do close after setting the flag &quot;terminated&quot; to true.
                 It is necessary to avoid a deadlock, see 6296324                
            </comment>
            <comment line="547">
                added for re-connection                
            </comment>
            <comment line="575">
                added for re-connection                
            </comment>
            <comment line="618">
                --------------------------------------------------------------------
                 Implementation of MBeanServerConnection
                --------------------------------------------------------------------                
            </comment>
            <comment line="1324">
                --------------------------------------------------------------------                
            </comment>
            <comment line="1661">
                --------------------------------------------------------------------
                 Private stuff - Serialization
                --------------------------------------------------------------------                
            </comment>
            <comment line="1821">
                Initialization of transient variables.                
            </comment>
            <comment line="1830">
                --------------------------------------------------------------------
                 Private stuff - Check if stub can be trusted.
                --------------------------------------------------------------------                
            </comment>
            <comment line="1875">
                --------------------------------------------------------------------
                 Private stuff - RMIServer creation
                --------------------------------------------------------------------                
            </comment>
            <comment line="2001">
                The following section of code avoids a class loading problem
                with RMI.  The problem is that an RMI stub, when deserializing
                a remote method return value or exception, will first of all
                consult the first non-bootstrap class loader it finds in the
                call stack.  This can lead to behavior that is not portable
                between implementations of the JMX Remote API.  Notably, an
                implementation on J2SE 1.4 will find the RMI stub&apos;s loader on
                the stack.  But in J2SE 5, this stub is loaded by the
                bootstrap loader, so RMI will find the loader of the user code
                that called an MBeanServerConnection method.
                
                To avoid this problem, we take advantage of what the RMI stub
                is doing internally.  Each remote call will end up calling
                ref.invoke(...), where ref is the RemoteRef parameter given to
                the RMI stub&apos;s constructor.  It is within this call that the
                deserialization will happen.  So we fabricate our own RemoteRef
                that delegates everything to the &quot;real&quot; one but that is loaded
                by a class loader that knows no other classes.  The class
                loader NoCallStackClassLoader does this: the RemoteRef is an
                instance of the class named by proxyRefClassName, which is
                fabricated by the class loader using byte code that is defined
                by the string below.
                
                The call stack when the deserialization happens is thus this:
                MBeanServerConnection.getAttribute (or whatever)
                -&gt; RMIConnectionImpl_Stub.getAttribute
                -&gt; ProxyRef.invoke(...getAttribute...)
                -&gt; UnicastRef.invoke(...getAttribute...)
                -&gt; internal RMI stuff
                
                Here UnicastRef is the RemoteRef created when the stub was
                deserialized (which is of some RMI internal class).  It and the
                &quot;internal RMI stuff&quot; are loaded by the bootstrap loader, so are
                transparent to the stack search.  The first non-bootstrap
                loader found is our ProxyRefLoader, as required.
                
                In a future version of this code as integrated into J2SE 5,
                this workaround could be replaced by direct access to the
                internals of RMI.  For now, we use the same code base for J2SE
                and for the standalone Reference Implementation.
                
                The byte code below encodes the following class, compiled using
                J2SE 1.4.2 with the -g:none option.
                
                package com.sun.jmx.remote.internal;
                
                import java.lang.reflect.Method;
                import java.rmi.Remote;
                import java.rmi.server.RemoteRef;
                import com.sun.jmx.remote.internal.ProxyRef;
                
                public class PRef extends ProxyRef {
                public PRef(RemoteRef ref) {
                super(ref);
                }
                
                public Object invoke(Remote obj, Method method,
                Object[] params, long opnum)
                throws Exception {
                return ref.invoke(obj, method, params, opnum);
                }
                }                
            </comment>
            <comment line="2153">
                The following code performs a similar trick for RMIIIOP to the
                one described above for RMIJRMP.  Unlike JRMP, though, we
                can&apos;t easily insert an object between the RMIConnection stub
                and the RMIIIOP deserialization code, as explained below.
                
                A method in an RMIIIOP stub does the following.  It makes an
                org.omg.CORBA_2_3.portable.OutputStream for each request, and
                writes the parameters to it.  Then it calls
                _invoke(OutputStream) which it inherits from CORBA&apos;s
                ObjectImpl.  That returns an
                org.omg.CORBA_2_3.portable.InputStream.  The return value is
                read from this InputStream.  So the stack during
                deserialization looks like this:
                
                MBeanServerConnection.getAttribute (or whatever)
                -&gt; _RMIConnection_Stub.getAttribute
                -&gt; Util.readAny (a CORBA method)
                -&gt; InputStream.read_any
                -&gt; internal CORBA stuff
                
                What we would have liked to have done would be the same thing
                as for RMIJRMP.  We create a &quot;ProxyDelegate&quot; that is an
                org.omg.CORBA.portable.Delegate that simply forwards every
                operation to the real original Delegate from the RMIConnection
                stub, except that the InputStream returned by _invoke is
                wrapped by a &quot;ProxyInputStream&quot; that is loaded by our
                NoCallStackClassLoader.
                
                Unfortunately, this doesn&apos;t work, at least with Sun&apos;s J2SE
                1.4.2, because the CORBA code is not designed to allow you to
                change Delegates arbitrarily.  You get a ClassCastException
                from code that expects the Delegate to implement an internal
                interface.
                
                So instead we do the following.  We create a subclass of the
                stub that overrides the _invoke method so as to wrap the
                returned InputStream in a ProxyInputStream.  We create a
                subclass of ProxyInputStream using the NoCallStackClassLoader
                and override its read_any and read_value(Class) methods.
                (These are the only methods called during deserialization of
                MBeanServerConnection return values.)  We extract the Delegate
                from the original stub and insert it into our subclass stub,
                and away we go.  The state of a stub consists solely of its
                Delegate.
                
                We also need to catch ApplicationException, which will encode
                any exceptions declared in the throws clause of the called
                method.  Its InputStream needs to be wrapped in a
                ProxyInputSteam too.
                
                We override _releaseReply in the stub subclass so that it
                replaces a ProxyInputStream argument with the original
                InputStream.  This avoids problems if the implementation of
                _releaseReply ends up casting this InputStream to an
                implementation-specific interface (which in Sun&apos;s J2SE 5 it
                does).
                
                It is not strictly necessary for the stub subclass to be loaded
                by a NoCallStackClassLoader, since the call-stack search stops
                at the ProxyInputStream subclass.  However, it is convenient
                for two reasons.  One is that it means that the
                ProxyInputStream subclass can be accessed directly, without
                using reflection.  The other is that it avoids build problems,
                since usually stubs are created after other classes are
                compiled, so we can&apos;t access them from this class without,
                again, using reflection.
                
                The strings below encode the following two Java classes,
                compiled using javac -g:none.
                
                package com.sun.jmx.remote.protocol.iiop;
                
                import org.omg.stub.javax.management.remote.rmi._RMIConnection_Stub;
                
                import org.omg.CORBA.portable.ApplicationException;
                import org.omg.CORBA.portable.InputStream;
                import org.omg.CORBA.portable.OutputStream;
                import org.omg.CORBA.portable.RemarshalException;
                
                public class ProxyStub extends _RMIConnection_Stub {
                public InputStream _invoke(OutputStream out)
                throws ApplicationException, RemarshalException {
                try {
                return new PInputStream(super._invoke(out));
                } catch (ApplicationException e) {
                InputStream pis = new PInputStream(e.getInputStream());
                throw new ApplicationException(e.getId(), pis);
                }
                }
                
                public void _releaseReply(InputStream in) {
                if (in != null)
                in = ((PInputStream)in).getProxiedInputStream();
                super._releaseReply(in);
                }
                }
                
                package com.sun.jmx.remote.protocol.iiop;
                
                public class PInputStream extends ProxyInputStream {
                public PInputStream(org.omg.CORBA.portable.InputStream in) {
                super(in);
                }
                
                public org.omg.CORBA.Any read_any() {
                return in.read_any();
                }
                
                public java.io.Serializable read_value(Class clz) {
                return narrow().read_value(clz);
                }
                }                
            </comment>
            <comment line="2477">
                --------------------------------------------------------------------
                 Private stuff - Find / Set default class loader
                --------------------------------------------------------------------                
            </comment>
            <comment line="2502">
                --------------------------------------------------------------------
                 Private variables
                --------------------------------------------------------------------                
            </comment>
            <comment line="2529">
                ---------------------------------------------------------
                 WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
                 ---------------------------------------------------------
                 Any transient variable which needs to be initialized should
                 be initialized in the method initTransient()                
            </comment>
            <comment line="2544">
                = new RMINotifClient(new Integer(0));                
            </comment>
            <comment line="2549">
                = false;                
            </comment>
            <comment line="2551">
                = false;                
            </comment>
            <comment line="2565">
                TRACES &amp; DEBUG
                ---------------                
            </comment>
            <implements interface="JMXConnector"/>
            <implements interface="Serializable"/>
            <implements interface="JMXAddressable"/>
            <javadoc line="109">
                &lt;p&gt;A connection to a remote RMI connector.  Usually, such
                  connections are made using {@link javax.management.remote.JMXConnectorFactory JMXConnectorFactory}.
                  However, specialized applications can use this class directly, for
                  example with an {@link RMIServer} stub obtained without going
                  through JNDI.&lt;/p&gt;                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="logger" type="ClassLogger" line="121"/>
            <declaration name="serialVersionUID" type="long" line="124"/>
            <method name="RMIConnector" type="constructor" line="127">
                <params>
                    <param name="rmiServer" type="RMIServer"/>
                    <param name="address" type="JMXServiceURL"/>
                    <param name="environment" type="Map<String,?>"/>
                </params>
                <scope line="135"/>
                <scope line="137"/>
            </method>
            <javadoc line="143">
                &lt;p&gt;Constructs an &lt;code&gt;RMIConnector&lt;/code&gt; that will connect
                  the RMI connector server with the given address.&lt;/p&gt;
                  &lt;p&gt;The address can refer directly to the connector server,
                  using one of the following syntaxes:&lt;/p&gt;
                  &lt;pre&gt;
                  service:jmx:rmi://&lt;em&gt;[host[:port]]&lt;/em&gt;/stub/&lt;em&gt;encoded-stub&lt;/em&gt;
                  service:jmx:iiop://&lt;em&gt;[host[:port]]&lt;/em&gt;/ior/&lt;em&gt;encoded-IOR&lt;/em&gt;
                  &lt;/pre&gt;
                  &lt;p&gt;(Here, the square brackets &lt;code&gt;[]&lt;/code&gt; are not part of the
                  address but indicate that the host and port are optional.)&lt;/p&gt;
                  &lt;p&gt;The address can instead indicate where to find an RMI stub
                  through JNDI, using one of the following syntaxes:&lt;/p&gt;
                  &lt;pre&gt;
                  service:jmx:rmi://&lt;em&gt;[host[:port]]&lt;/em&gt;/jndi/&lt;em&gt;jndi-name&lt;/em&gt;
                  service:jmx:iiop://&lt;em&gt;[host[:port]]&lt;/em&gt;/jndi/&lt;em&gt;jndi-name&lt;/em&gt;
                  &lt;/pre&gt;
                  &lt;p&gt;An implementation may also recognize additional address
                  syntaxes, for example:&lt;/p&gt;
                  &lt;pre&gt;
                  service:jmx:iiop://&lt;em&gt;[host[:port]]&lt;/em&gt;/stub/&lt;em&gt;encoded-stub&lt;/em&gt;
                  &lt;/pre&gt;                
                <param>
                    url the address of the RMI connector server.                    
                </param>
                <param>
                    environment additional attributes specifying how to make
                      the connection.  For JNDI-based addresses, these attributes can
                      usefully include JNDI attributes recognized by {@link InitialContext#InitialContext(Hashtable) InitialContext}.  This
                      parameter can be null, which is equivalent to an empty Map.                    
                </param>
                <exception>
                    IllegalArgumentException if <code>url</code>
                      is null.                    
                </exception>
            </javadoc>
            <method name="RMIConnector" type="constructor" line="184">
                <params>
                    <param name="url" type="JMXServiceURL"/>
                    <param name="environment" type="Map<String,?>"/>
                </params>
            </method>
            <javadoc line="188">
                &lt;p&gt;Constructs an &lt;code&gt;RMIConnector&lt;/code&gt; using the given RMI stub.                
                <param>
                    rmiServer an RMI stub representing the RMI connector server.                    
                </param>
                <param>
                    environment additional attributes specifying how to make
                      the connection.  This parameter can be null, which is
                      equivalent to an empty Map.                    
                </param>
                <exception>
                    IllegalArgumentException if <code>rmiServer</code>
                      is null.                    
                </exception>
            </javadoc>
            <method name="RMIConnector" type="constructor" line="199">
                <params>
                    <param name="rmiServer" type="RMIServer"/>
                    <param name="environment" type="Map<String,?>"/>
                </params>
            </method>
            <javadoc line="203">
                &lt;p&gt;Returns a string representation of this object.  In general,
                  the &lt;code&gt;toString&lt;/code&gt; method returns a string that
                  &quot;textually represents&quot; this object. The result should be a
                  concise but informative representation that is easy for a
                  person to read.&lt;/p&gt;                
                <return>
                    a String representation of this object.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="213">
                <declaration name="b" type="StringBuilder" line="214"/>
                <scope line="216"/>
                <scope line="219"/>
            </method>
            <javadoc line="226">
                &lt;p&gt;The address of this connector.&lt;/p&gt;                
                <return>
                    the address of this connector, or null if it
                      does not have one.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getAddress" type="JMXServiceURL" line="234"/>
            <method name="connect" type="void" line="241"/>
            <method name="connect" type="void" line="246">
                <params>
                    <param name="environment" type="Map<String,?>"/>
                </params>
                <comment line="273">
                    Get RMIServer stub from directory or URL encoding if needed.                    
                </comment>
                <comment line="278">
                    Check for secure RMIServer stub if the corresponding
                     client-side environment property is set to &quot;true&quot;.                    
                </comment>
                <comment line="286">
                    Connect IIOP Stub if needed.                    
                </comment>
                <comment line="291">
                    Calling newClient on the RMIServer stub.                    
                </comment>
                <comment line="314">
                    Always use one of:
                       ClassLoader provided in Map at connect time,
                       or contextClassLoader at connect time.                    
                </comment>
                <comment line="332">
                    The connectionId variable is used in doStart(), when
                     reconnecting, to identify the &quot;old&quot; connection.                    
                </comment>
                <declaration name="tracing" type="boolean" line="247"/>
                <declaration name="idstr" type="String" line="248"/>
                <scope line="250"/>
                <scope line="254"/>
                <scope line="259">
                    <declaration name="usemap" type="Map&lt;String,Object&gt;" line="262"/>
                    <scope line="267"/>
                    <declaration name="stub" type="RMIServer" line="274"/>
                    <declaration name="checkStub" type="boolean" line="280"/>
                    <declaration name="credentials" type="Object" line="293"/>
                    <scope line="295"/>
                    <scope line="297">
                        <scope line="298">
                            <declaration name="pro" type="String" line="299"/>
                            <declaration name="path" type="String" line="300"/>
                            <scope line="303">
                                <declaration name="mfe" type="MalformedURLException" line="304"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="checkPeriod" type="long" line="326"/>
                    <declaration name="connectedNotif" type="Notification" line="336"/>
                </scope>
                <scope line="346"/>
                <scope line="350"/>
                <scope line="354">
                    <declaration name="msg" type="String" line="355"/>
                </scope>
            </method>
            <method name="getConnectionId" type="String" line="361">
                <comment line="371">
                    we do a remote call to have an IOException if the connection is broken.
                     see the bug 4939578                    
                </comment>
                <scope line="362"/>
            </method>
            <method name="getMBeanServerConnection" type="MBeanServerConnection" line="376"/>
            <method name="getMBeanServerConnection" type="MBeanServerConnection" line="382">
                <params>
                    <param name="delegationSubject" type="Subject"/>
                </params>
                <scope line="384"/>
                <scope line="389"/>
                <declaration name="rmbsc" type="MBeanServerConnection" line="396"/>
                <scope line="397"/>
            </method>
            <method name="addConnectionNotificationListener" type="void" line="409">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
            </method>
            <method name="removeConnectionNotificationListener" type="void" line="418">
                <params>
                    <param name="listener" type="NotificationListener"/>
                </params>
            </method>
            <method name="removeConnectionNotificationListener" type="void" line="428">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
            </method>
            <method name="sendNotification" type="void" line="435">
                <params>
                    <param name="n" type="Notification"/>
                </params>
            </method>
            <method name="close" type="void" line="439"/>
            <method name="close" type="void" line="445">
                <params>
                    <param name="intern" type="boolean"/>
                </params>
                <comment line="452">
                    Return if already cleanly closed.                    
                </comment>
                <comment line="465">
                    Already closed, but not cleanly. Attempt again.                    
                </comment>
                <comment line="504">
                    OK, the server maybe closed itself.                    
                </comment>
                <comment line="513">
                    Clean up MBeanServerConnection table                    
                </comment>
                <comment line="517">
                    Send notification of closure.  We don&apos;t do this if the user
                     never called connect() on the connector, because there&apos;s no                    
                </comment>
                <comment line="532">
                    throw exception if needed                    
                </comment>
                <declaration name="tracing" type="boolean" line="446"/>
                <declaration name="debug" type="boolean" line="447"/>
                <declaration name="idstr" type="String" line="448"/>
                <scope line="450">
                    <scope line="453">
                        <scope line="454"/>
                    </scope>
                    <scope line="458"/>
                </scope>
                <scope line="463">
                    <scope line="466"/>
                </scope>
                <declaration name="savedConnectionId" type="String" line="472"/>
                <scope line="473"/>
                <scope line="481"/>
                <scope line="485">
                    <scope line="486"/>
                    <scope line="490"/>
                </scope>
                <scope line="498">
                    <scope line="499"/>
                    <scope line="502"/>
                    <scope line="504"/>
                </scope>
                <scope line="520">
                    <declaration name="closedNotif" type="Notification" line="521"/>
                </scope>
                <scope line="533">
                    <declaration name="x" type="IOException" line="540"/>
                </scope>
            </method>
            <method name="addListenerWithSubject" type="Integer" line="551">
                <params>
                    <param name="name" type="ObjectName"/>
                    <param name="filter" type="MarshalledObject<NotificationFilter>"/>
                    <param name="delegationSubject" type="Subject"/>
                    <param name="reconnect" type="boolean"/>
                </params>
                <declaration name="debug" type="boolean" line="553"/>
                <declaration name="names" type="ObjectName[]" line="558"/>
                <declaration name="filters" type="MarshalledObject&lt;NotificationFilter&gt;[]" line="559"/>
                <declaration name="delegationSubjects" type="Subject[]" line="561"/>
                <declaration name="listenerIDs" type="Integer[]" line="565"/>
            </method>
            <method name="addListenersWithSubjects" type="Integer[]" line="579">
                <params>
                    <param name="names" type="ObjectName[]"/>
                    <param name="filters" type="MarshalledObject<NotificationFilter>[]"/>
                    <param name="delegationSubjects" type="Subject[]"/>
                    <param name="reconnect" type="boolean"/>
                </params>
                <comment line="595">
                    maybe reconnect                    
                </comment>
                <comment line="606">
                    send a failed notif if necessary                    
                </comment>
                <declaration name="debug" type="boolean" line="581"/>
                <declaration name="old" type="ClassLoader" line="586"/>
                <declaration name="listenerIDs" type="Integer[]" line="587"/>
                <scope line="589"/>
                <scope line="593">
                    <scope line="595"/>
                    <scope line="601"/>
                </scope>
                <scope line="604"/>
                <scope line="607"/>
            </method>
            <class name="RemoteMBeanServerConnection" line="620">
                <comment line="1215">
                    Specific Notification Handle ----------------------------------                    
                </comment>
                <implements interface="MBeanServerConnection"/>
                <declaration name="delegationSubject" type="Subject" line="621"/>
                <method name="RemoteMBeanServerConnection" type="constructor" line="623"/>
                <method name="RemoteMBeanServerConnection" type="constructor" line="627">
                    <params>
                        <param name="delegationSubject" type="Subject"/>
                    </params>
                </method>
                <method name="createMBean" type="ObjectInstance" line="638">
                    <params>
                        <param name="className" type="String"/>
                        <param name="name" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="644"/>
                    <scope line="645"/>
                    <scope line="649"/>
                    <scope line="655"/>
                </method>
                <method name="createMBean" type="ObjectInstance" line="669">
                    <params>
                        <param name="className" type="String"/>
                        <param name="name" type="ObjectName"/>
                        <param name="loaderName" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="677"/>
                    <scope line="678"/>
                    <scope line="684"/>
                    <scope line="692"/>
                </method>
                <method name="createMBean" type="ObjectInstance" line="706">
                    <params>
                        <param name="className" type="String"/>
                        <param name="name" type="ObjectName"/>
                        <param name="params" type="Object"/>
                        <param name="signature" type="String"/>
                    </params>
                    <declaration name="sParams" type="MarshalledObject&lt;Object[]&gt;" line="714"/>
                    <declaration name="old" type="ClassLoader" line="716"/>
                    <scope line="717"/>
                    <scope line="723"/>
                    <scope line="731"/>
                </method>
                <method name="createMBean" type="ObjectInstance" line="747">
                    <params>
                        <param name="className" type="String"/>
                        <param name="name" type="ObjectName"/>
                        <param name="loaderName" type="ObjectName"/>
                        <param name="params" type="Object"/>
                        <param name="signature" type="String"/>
                    </params>
                    <declaration name="sParams" type="MarshalledObject&lt;Object[]&gt;" line="754"/>
                    <declaration name="old" type="ClassLoader" line="756"/>
                    <scope line="757"/>
                    <scope line="764"/>
                    <scope line="773"/>
                </method>
                <method name="unregisterMBean" type="void" line="781">
                    <params>
                        <param name="name" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="785"/>
                    <scope line="786"/>
                    <scope line="788"/>
                    <scope line="792"/>
                </method>
                <method name="getObjectInstance" type="ObjectInstance" line="799">
                    <params>
                        <param name="name" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="803"/>
                    <scope line="804"/>
                    <scope line="806"/>
                    <scope line="810"/>
                </method>
                <method name="queryMBeans" type="Set<ObjectInstance>" line="817">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="query" type="QueryExp"/>
                    </params>
                    <declaration name="sQuery" type="MarshalledObject&lt;QueryExp&gt;" line="821"/>
                    <declaration name="old" type="ClassLoader" line="823"/>
                    <scope line="824"/>
                    <scope line="826"/>
                    <scope line="830"/>
                </method>
                <method name="queryNames" type="Set<ObjectName>" line="837">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="query" type="QueryExp"/>
                    </params>
                    <declaration name="sQuery" type="MarshalledObject&lt;QueryExp&gt;" line="841"/>
                    <declaration name="old" type="ClassLoader" line="843"/>
                    <scope line="844"/>
                    <scope line="846"/>
                    <scope line="850"/>
                </method>
                <method name="isRegistered" type="boolean" line="856">
                    <params>
                        <param name="name" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="860"/>
                    <scope line="861"/>
                    <scope line="863"/>
                    <scope line="867"/>
                </method>
                <method name="getMBeanCount" type="Integer" line="873">
                    <declaration name="old" type="ClassLoader" line="876"/>
                    <scope line="877"/>
                    <scope line="879"/>
                    <scope line="883"/>
                </method>
                <method name="getAttribute" type="Object" line="894">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="attribute" type="String"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="899"/>
                    <scope line="900"/>
                    <scope line="904"/>
                    <scope line="910"/>
                </method>
                <method name="getAttributes" type="AttributeList" line="919">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="attributes" type="String[]"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="924"/>
                    <scope line="925"/>
                    <scope line="930"/>
                    <scope line="936"/>
                </method>
                <method name="setAttribute" type="void" line="949">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="attribute" type="Attribute"/>
                    </params>
                    <declaration name="sAttribute" type="MarshalledObject&lt;Attribute&gt;" line="955"/>
                    <declaration name="old" type="ClassLoader" line="957"/>
                    <scope line="958"/>
                    <scope line="960"/>
                    <scope line="964"/>
                </method>
                <method name="setAttributes" type="AttributeList" line="973">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="attributes" type="AttributeList"/>
                    </params>
                    <declaration name="sAttributes" type="MarshalledObject&lt;AttributeList&gt;" line="979"/>
                    <declaration name="old" type="ClassLoader" line="981"/>
                    <scope line="982"/>
                    <scope line="986"/>
                    <scope line="992"/>
                </method>
                <method name="invoke" type="Object" line="1005">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="operationName" type="String"/>
                        <param name="params" type="Object"/>
                        <param name="signature" type="String"/>
                    </params>
                    <declaration name="sParams" type="MarshalledObject&lt;Object[]&gt;" line="1013"/>
                    <declaration name="old" type="ClassLoader" line="1015"/>
                    <scope line="1016"/>
                    <scope line="1022"/>
                    <scope line="1030"/>
                </method>
                <method name="getDefaultDomain" type="String" line="1037">
                    <declaration name="old" type="ClassLoader" line="1040"/>
                    <scope line="1041"/>
                    <scope line="1043"/>
                    <scope line="1047"/>
                </method>
                <method name="getDomains" type="String[]" line="1052">
                    <declaration name="old" type="ClassLoader" line="1055"/>
                    <scope line="1056"/>
                    <scope line="1058"/>
                    <scope line="1062"/>
                </method>
                <method name="getMBeanInfo" type="MBeanInfo" line="1071">
                    <params>
                        <param name="name" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="1074"/>
                    <scope line="1075"/>
                    <scope line="1077"/>
                    <scope line="1081"/>
                </method>
                <method name="isInstanceOf" type="boolean" line="1090">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="className" type="String"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="1095"/>
                    <scope line="1096"/>
                    <scope line="1100"/>
                    <scope line="1106"/>
                </method>
                <method name="addNotificationListener" type="void" line="1116">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="listener" type="ObjectName"/>
                        <param name="filter" type="NotificationFilter"/>
                        <param name="handback" type="Object"/>
                    </params>
                    <declaration name="sFilter" type="MarshalledObject&lt;NotificationFilter&gt;" line="1124"/>
                    <declaration name="sHandback" type="MarshalledObject&lt;Object&gt;" line="1126"/>
                    <declaration name="old" type="ClassLoader" line="1128"/>
                    <scope line="1129"/>
                    <scope line="1135"/>
                    <scope line="1143"/>
                </method>
                <method name="removeNotificationListener" type="void" line="1152">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="listener" type="ObjectName"/>
                    </params>
                    <declaration name="old" type="ClassLoader" line="1159"/>
                    <scope line="1160"/>
                    <scope line="1164"/>
                    <scope line="1170"/>
                </method>
                <method name="removeNotificationListener" type="void" line="1181">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="listener" type="ObjectName"/>
                        <param name="filter" type="NotificationFilter"/>
                        <param name="handback" type="Object"/>
                    </params>
                    <declaration name="sFilter" type="MarshalledObject&lt;NotificationFilter&gt;" line="1190"/>
                    <declaration name="sHandback" type="MarshalledObject&lt;Object&gt;" line="1192"/>
                    <declaration name="old" type="ClassLoader" line="1194"/>
                    <scope line="1195"/>
                    <scope line="1201"/>
                    <scope line="1209"/>
                </method>
                <method name="addNotificationListener" type="void" line="1221">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="listener" type="NotificationListener"/>
                        <param name="filter" type="NotificationFilter"/>
                        <param name="handback" type="Object"/>
                    </params>
                    <declaration name="debug" type="boolean" line="1223"/>
                    <declaration name="listenerID" type="Integer" line="1234"/>
                </method>
                <method name="removeNotificationListener" type="void" line="1247">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="listener" type="NotificationListener"/>
                    </params>
                    <declaration name="debug" type="boolean" line="1249"/>
                    <declaration name="ret" type="Integer[]" line="1256"/>
                    <declaration name="old" type="ClassLoader" line="1262"/>
                    <scope line="1264"/>
                    <scope line="1268"/>
                    <scope line="1274"/>
                </method>
                <method name="removeNotificationListener" type="void" line="1286">
                    <params>
                        <param name="name" type="ObjectName"/>
                        <param name="listener" type="NotificationListener"/>
                        <param name="filter" type="NotificationFilter"/>
                        <param name="handback" type="Object"/>
                    </params>
                    <declaration name="debug" type="boolean" line="1287"/>
                    <declaration name="ret" type="Integer" line="1298"/>
                    <declaration name="old" type="ClassLoader" line="1305"/>
                    <scope line="1306"/>
                    <scope line="1310"/>
                    <scope line="1316"/>
                </method>
            </class>
            <class name="RMINotifClient" line="1324">
                <extends class="ClientNotifForwarder"/>
                <comment line="1215">
                    Specific Notification Handle ----------------------------------                    
                </comment>
                <method name="RMINotifClient" type="constructor" line="1325">
                    <params>
                        <param name="cl" type="ClassLoader"/>
                        <param name="env" type="Map<String,?>"/>
                    </params>
                </method>
                <method name="fetchNotifs" type="NotificationResult" line="1332">
                    <params>
                        <param name="clientSequenceNumber" type="long"/>
                        <param name="maxNotifications" type="int"/>
                        <param name="timeout" type="long"/>
                    </params>
                    <comment line="1336">
                        used for a successful re-connection                        
                    </comment>
                    <comment line="1344">
                        inform of IOException                        
                    </comment>
                    <comment line="1348">
                        The connection should be re-established.                        
                    </comment>
                    <comment line="1351">
                        No more fetch, the Exception will be re-thrown.                        
                    </comment>
                    <comment line="1353">
                        never reached                        
                    </comment>
                    <comment line="1354">
                        never reached                        
                    </comment>
                    <comment line="1357">
                        specially treating for an UnmarshalException                        
                    </comment>
                    <comment line="1364">
                        In Sun&apos;s RMI implementation, if a method return
                        contains an unserializable object, then we get
                        UnmarshalException wrapping WriteAbortedException
                        wrapping NotSerializableException.  In that case we
                        extract the NotSerializableException so that our
                        caller can realize it should try to skip past the
                        notification that presumably caused it.  It&apos;s not
                        certain that every other RMI implementation will
                        generate this exact exception sequence.  If not, we
                        will not detect that the problem is due to an
                        unserializable object, and we will stop trying to
                        receive notifications from the server.  It&apos;s not                        
                    </comment>
                    <comment line="1384">
                        IIOP will throw MarshalException wrapping a NotSerializableException
                         when a server fails to serialize a response.                        
                    </comment>
                    <comment line="1392">
                        Not serialization problem, simply re-throw the orginal exception                        
                    </comment>
                    <declaration name="org" type="IOException" line="1333"/>
                    <scope line="1335">
                        <scope line="1336"/>
                        <scope line="1340">
                            <scope line="1344"/>
                            <scope line="1349"/>
                        </scope>
                    </scope>
                    <scope line="1357">
                        <declaration name="ume" type="UnmarshalException" line="1358"/>
                        <scope line="1376">
                            <declaration name="wae" type="WriteAbortedException" line="1377"/>
                        </scope>
                    </scope>
                    <scope line="1382">
                        <declaration name="me" type="MarshalException" line="1385"/>
                        <scope line="1386"/>
                    </scope>
                </method>
                <method name="addListenerForMBeanRemovedNotif" type="Integer" line="1396">
                    <declaration name="clientFilter" type="NotificationFilterSupport" line="1397"/>
                    <declaration name="sFilter" type="MarshalledObject&lt;NotificationFilter&gt;" line="1401"/>
                    <declaration name="listenerIDs" type="Integer[]" line="1404"/>
                    <declaration name="names" type="ObjectName[]" line="1405"/>
                    <declaration name="filters" type="MarshalledObject&lt;NotificationFilter&gt;[]" line="1407"/>
                    <declaration name="subjects" type="Subject[]" line="1409"/>
                    <scope line="1410"/>
                    <scope line="1416"/>
                </method>
                <method name="removeListenerForMBeanRemovedNotif" type="void" line="1429">
                    <params>
                        <param name="id" type="Integer"/>
                    </params>
                    <scope line="1430"/>
                    <scope line="1435"/>
                </method>
                <method name="lostNotifs" type="void" line="1446">
                    <params>
                        <param name="message" type="String"/>
                        <param name="number" type="long"/>
                    </params>
                    <declaration name="notifType" type="String" line="1447"/>
                    <declaration name="n" type="JMXConnectionNotification" line="1449"/>
                </method>
            </class>
            <class name="RMIClientCommunicatorAdmin" line="1460">
                <extends class="ClientCommunicatorAdmin"/>
                <comment line="1215">
                    Specific Notification Handle ----------------------------------                    
                </comment>
                <method name="RMIClientCommunicatorAdmin" type="constructor" line="1461">
                    <params>
                        <param name="period" type="long"/>
                    </params>
                </method>
                <method name="gotIOException" type="void" line="1466">
                    <params>
                        <param name="ioe" type="IOException"/>
                    </params>
                    <comment line="1469">
                        need to restart                        
                    </comment>
                    <comment line="1475">
                        check if the connection is broken                        
                    </comment>
                    <comment line="1490">
                        we should close the connection,
                         but send a failed notif at first                        
                    </comment>
                    <comment line="1506">
                        OK.
                         We are closing                        
                    </comment>
                    <comment line="1512">
                        forward the exception                        
                    </comment>
                    <comment line="1514">
                        Need to unwrap the exception.
                        Some user-thrown exception at server side will be wrapped by
                        rmi into a ServerException.
                        For example, a RMIConnnectorServer will wrap a
                        ClassNotFoundException into a UnmarshalException, and rmi
                        will throw a ServerException at client side which wraps this
                        UnmarshalException.
                        No failed notif here.                        
                    </comment>
                    <scope line="1467"/>
                    <scope line="1475"/>
                    <scope line="1477">
                        <declaration name="toClose" type="boolean" line="1478"/>
                        <scope line="1480">
                            <scope line="1481"/>
                        </scope>
                        <scope line="1488">
                            <declaration name="failedNotif" type="Notification" line="1491"/>
                            <scope line="1502"/>
                            <scope line="1504"/>
                        </scope>
                    </scope>
                    <scope line="1512">
                        <declaration name="tt" type="Throwable" line="1522"/>
                        <scope line="1524"/>
                        <scope line="1526"/>
                    </scope>
                </method>
                <method name="reconnectNotificationListeners" type="void" line="1534">
                    <params>
                        <param name="old" type="ClientListenerInfo[]"/>
                    </params>
                    <comment line="1574">
                        OK, we will do one by one                        
                    </comment>
                    <declaration name="len" type="int" line="1535"/>
                    <declaration name="i" type="int" line="1536"/>
                    <declaration name="clis" type="ClientListenerInfo[]" line="1538"/>
                    <declaration name="subjects" type="Subject[]" line="1540"/>
                    <declaration name="names" type="ObjectName[]" line="1541"/>
                    <declaration name="listeners" type="NotificationListener[]" line="1542"/>
                    <declaration name="filters" type="NotificationFilter[]" line="1543"/>
                    <declaration name="mFilters" type="MarshalledObject&lt;NotificationFilter&gt;[]" line="1544"/>
                    <declaration name="handbacks" type="Object[]" line="1546"/>
                    <scope line="1548"/>
                    <scope line="1557">
                        <declaration name="ids" type="Integer[]" line="1558"/>
                        <scope line="1560"/>
                    </scope>
                    <scope line="1572"/>
                    <declaration name="j" type="int" line="1576"/>
                    <scope line="1577">
                        <scope line="1578">
                            <declaration name="id" type="Integer" line="1579"/>
                        </scope>
                        <scope line="1590"/>
                    </scope>
                    <scope line="1597">
                        <declaration name="tmp" type="ClientListenerInfo[]" line="1598"/>
                    </scope>
                </method>
                <method name="checkConnection" type="void" line="1606"/>
                <method name="doStart" type="void" line="1614">
                    <comment line="1616">
                        Get RMIServer stub from directory or URL encoding if needed.                        
                    </comment>
                    <comment line="1625">
                        Connect IIOP Stub if needed.                        
                    </comment>
                    <comment line="1628">
                        Calling newClient on the RMIServer stub.                        
                    </comment>
                    <comment line="1632">
                        notif issues                        
                    </comment>
                    <declaration name="stub" type="RMIServer" line="1616"/>
                    <scope line="1617"/>
                    <scope line="1620"/>
                    <declaration name="credentials" type="Object" line="1628"/>
                    <declaration name="old" type="ClientListenerInfo[]" line="1632"/>
                    <declaration name="reconnectedNotif" type="Notification" line="1638"/>
                </method>
                <method name="doStop" type="void" line="1649">
                    <scope line="1650"/>
                    <scope line="1652"/>
                </method>
            </class>
            <javadoc line="1663">
                &lt;p&gt;In order to be usable, an IIOP stub must be connected to an ORB.
                  The stub is automatically connected to the ORB if:
                  &lt;ul&gt;
                  &lt;li&gt; It was returned by the COS naming&lt;/li&gt;
                  &lt;li&gt; Its server counterpart has been registered in COS naming
                  through JNDI.&lt;/li&gt;
                  &lt;/ul&gt;
                  Otherwise, it is not connected. A stub which is deserialized
                  from Jini is not connected. A stub which is obtained from a
                  non registered RMIIIOPServerImpl is not a connected.&lt;br&gt;
                  A stub which is not connected can&apos;t be serialized, and thus
                  can&apos;t be registered in Jini. A stub which is not connected can&apos;t
                  be used to invoke methods on the server.
                  &lt;p&gt;
                  In order to palliate this, this method will connect the
                  given stub if it is not yet connected. If the given
                  &lt;var&gt;RMIServer&lt;/var&gt; is not an instance of{@link javax.rmi.CORBA.Stub javax.rmi.CORBA.Stub}, then the
                  method do nothing and simply returns that stub. Otherwise,
                  this method will attempt to connect the stub to an ORB as
                  follows:
                  &lt;ul&gt;
                  &lt;p&gt;This method looks in the provided &lt;var&gt;environment&lt;/var&gt; for
                  the &quot;java.naming.corba.orb&quot; property. If it is found, the
                  referenced object (an {@link org.omg.CORBA.ORB ORB}) is used to
                  connect the stub. Otherwise, a new org.omg.CORBA.ORB is created
                  by calling {@link org.omg.CORBA.ORB#init(String[],Properties)org.omg.CORBA.ORB.init((String[])null,(Properties)null)}&lt;p&gt;The new created ORB is kept in a static{@link WeakReference} and can be reused for connecting other
                  stubs. However, no reference is ever kept on the ORB provided
                  in the &lt;var&gt;environment&lt;/var&gt; map, if any.
                  &lt;/ul&gt;                
                <param>
                    rmiServer A RMI Server Stub.                    
                </param>
                <param>
                    environment An environment map, possibly containing an ORB.                    
                </param>
                <return>
                    the given stub.                    
                </return>
                <exception>
                    IllegalArgumentException if the
                      <tt>java.naming.corba.orb</tt> property is specified and
                      does not point to an {@link org.omg.CORBA.ORB ORB}.                    
                </exception>
                <exception>
                    IOException if the connection to the ORB failed.                    
                </exception>
            </javadoc>
            <method name="connectStub" type="RMIServer" line="1708">
                <params>
                    <param name="rmiServer" type="RMIServer"/>
                    <param name="environment" type="Map<String,?>"/>
                </params>
                <comment line="1714">
                    BAD_OPERATION                    
                </comment>
                <scope line="1709">
                    <scope line="1710"/>
                    <scope line="1712"/>
                </scope>
            </method>
            <javadoc line="1720">
                Get the ORB specified by &lt;var&gt;environment&lt;/var&gt;, or create a
                  new one.
                  &lt;p&gt;This method looks in the provided &lt;var&gt;environment&lt;/var&gt; for
                  the &quot;java.naming.corba.orb&quot; property. If it is found, the
                  referenced object (an {@link org.omg.CORBA.ORB ORB}) is
                  returned. Otherwise, a new org.omg.CORBA.ORB is created
                  by calling {@link org.omg.CORBA.ORB#init(String[],java.util.Properties)org.omg.CORBA.ORB.init((String[])null,(Properties)null)}&lt;p&gt;The new created ORB is kept in a static{@link WeakReference} and can be reused for connecting other
                  stubs. However, no reference is ever kept on the ORB provided
                  in the &lt;var&gt;environment&lt;/var&gt; map, if any.                
                <param>
                    environment An environment map, possibly containing an ORB.                    
                </param>
                <return>
                    An ORB.                    
                </return>
                <exception>
                    IllegalArgumentException if the
                      <tt>java.naming.corba.orb</tt> property is specified and
                      does not point to an {@link org.omg.CORBA.ORB ORB}.                    
                </exception>
                <exception>
                    IOException if the ORB initialization failed.                    
                </exception>
            </javadoc>
            <method name="resolveOrb" type="Object" line="1742">
                <params>
                    <param name="environment" type="Map<String,?>"/>
                </params>
                <scope line="1743">
                    <declaration name="orb" type="Object" line="1744"/>
                </scope>
                <declaration name="orb" type="Object" line="1750"/>
                <declaration name="newOrb" type="Object" line="1754"/>
            </method>
            <javadoc line="1760">
                Read RMIConnector fields from an {@link java.io.ObjectInputStreamObjectInputStream}.
                  Calls &lt;code&gt;s.defaultReadObject()&lt;/code&gt; and then initializes
                  all transient variables that need initializing.                
                <param>
                    s The ObjectInputStream to read from.                    
                </param>
                <exception>
                    InvalidObjectException if none of <var>rmiServer</var> stub
                      or <var>jmxServiceURL</var> are set.                    
                </exception>
                <see>
                    #RMIConnector(JMXServiceURL,Map)                    
                </see>
                <see>
                    #RMIConnector(RMIServer,Map)                    
                </see>
            </javadoc>
            <method name="readObject" type="void" line="1772">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
            </method>
            <javadoc line="1781">
                Writes the RMIConnector fields to an {@link java.io.ObjectOutputStreamObjectOutputStream}.
                  &lt;p&gt;Connects the underlying RMIServer stub to an ORB, if needed,
                  before serializing it. This is done using the environment
                  map that was provided to the constructor, if any, and as documented
                  in {@link javax.management.remote.rmi}.&lt;/p&gt;
                  &lt;p&gt;This method then calls &lt;code&gt;s.defaultWriteObject()&lt;/code&gt;.
                  Usually, &lt;var&gt;rmiServer&lt;/var&gt; is null if this object
                  was constructed with a JMXServiceURL, and &lt;var&gt;jmxServiceURL&lt;/var&gt;
                  is null if this object is constructed with a RMIServer stub.
                  &lt;p&gt;Note that the environment Map is not serialized, since the objects
                  it contains are assumed to be contextual and relevant only
                  with respect to the local environment (class loader, ORB, etc...).&lt;/p&gt;
                  &lt;p&gt;After an RMIConnector is deserialized, it is assumed that the
                  user will call {@link #connect(Map)}, providing a new Map that
                  can contain values which are contextually relevant to the new
                  local environment.&lt;/p&gt;
                  &lt;p&gt;Since connection to the ORB is needed prior to serializing, and
                  since the ORB to connect to is one of those contextual parameters,
                  it is not recommended to re-serialize a just de-serialized object -
                  as the de-serialized object has no map. Thus, when an RMIConnector
                  object is needed for serialization or transmission to a remote
                  application, it is recommended to obtain a new RMIConnector stub
                  by calling {@link RMIConnectorServer#toJMXConnector(Map)}.&lt;/p&gt;                
                <param>
                    s The ObjectOutputStream to write to.                    
                </param>
                <exception>
                    InvalidObjectException if none of <var>rmiServer</var> stub
                      or <var>jmxServiceURL</var> are set.                    
                </exception>
                <see>
                    #RMIConnector(JMXServiceURL,Map)                    
                </see>
                <see>
                    #RMIConnector(RMIServer,Map)                    
                </see>
            </javadoc>
            <method name="writeObject" type="void" line="1813">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
            </method>
            <method name="initTransients" type="void" line="1821"/>
            <method name="checkStub" type="void" line="1834">
                <params>
                    <param name="stub" type="Remote"/>
                    <param name="stubClass" type="Class<?>"/>
                </params>
                <comment line="1837">
                    Check remote stub is from the expected class.                    
                </comment>
                <comment line="1855">
                    Check RemoteRef in stub is from the expected class
                     &quot;sun.rmi.server.UnicastRef2&quot;.                    
                </comment>
                <comment line="1864">
                    Check RMIClientSocketFactory in stub is from the expected class
                     &quot;javax.rmi.ssl.SslRMIClientSocketFactory&quot;.                    
                </comment>
                <scope line="1838">
                    <scope line="1839"/>
                    <scope line="1842">
                        <declaration name="handler" type="InvocationHandler" line="1843"/>
                    </scope>
                </scope>
                <declaration name="ref" type="RemoteRef" line="1857"/>
                <declaration name="liveRef" type="LiveRef" line="1866"/>
                <declaration name="csf" type="RMIClientSocketFactory" line="1867"/>
            </method>
            <method name="findRMIServer" type="RMIServer" line="1880">
                <params>
                    <param name="directoryURL" type="JMXServiceURL"/>
                    <param name="environment" type="Map<String,Object>"/>
                </params>
                <comment line="1884">
                    Make sure java.naming.corba.orb is in the Map.                    
                </comment>
                <declaration name="isIiop" type="boolean" line="1881"/>
                <scope line="1882"/>
                <declaration name="path" type="String" line="1887"/>
                <declaration name="end" type="int" line="1888"/>
                <scope line="1894"/>
                <scope line="1898">
                    <declaration name="msg" type="String" line="1899"/>
                </scope>
            </method>
            <javadoc line="1905">
                Lookup the RMIServer stub in a directory.                
                <param>
                    jndiURL A JNDI URL indicating the location of the Stub
                      (see {@link javax.management.remote.rmi}), e.g.:
                      <ul><li><tt>rmi://registry-host:port/rmi-stub-name</tt></li>
                      <li>or <tt>iiop://cosnaming-host:port/iiop-stub-name</tt></li>
                      <li>or <tt>ldap://ldap-host:port/java-container-dn</tt></li>
                      </ul>                    
                </param>
                <param>
                    env the environment Map passed to the connector.                    
                </param>
                <param>
                    isIiop true if the stub is expected to be an IIOP stub.                    
                </param>
                <return>
                    The retrieved RMIServer stub.                    
                </return>
                <exception>
                    NamingException if the stub couldn't be found.                    
                </exception>
            </javadoc>
            <method name="findRMIServerJNDI" type="RMIServer" line="1920">
                <params>
                    <param name="jndiURL" type="String"/>
                    <param name="env" type="Map<String,?>"/>
                    <param name="isIiop" type="boolean"/>
                </params>
                <declaration name="ctx" type="InitialContext" line="1922"/>
                <declaration name="objref" type="Object" line="1924"/>
            </method>
            <method name="narrowJRMPServer" type="RMIServer" line="1933">
                <params>
                    <param name="objref" type="Object"/>
                </params>
            </method>
            <method name="narrowIIOPServer" type="RMIServer" line="1938">
                <params>
                    <param name="objref" type="Object"/>
                </params>
                <scope line="1939"/>
                <scope line="1941"/>
            </method>
            <method name="findRMIServerIIOP" type="RMIServer" line="1950">
                <params>
                    <param name="ior" type="String"/>
                    <param name="env" type="Map<String,?>"/>
                    <param name="isIiop" type="boolean"/>
                </params>
                <comment line="1952">
                    could forbid &quot;rmi:&quot; URL here -- but do we need to?                    
                </comment>
                <declaration name="orb" type="Object" line="1952"/>
                <declaration name="stub" type="Object" line="1953"/>
            </method>
            <method name="findRMIServerJRMP" type="RMIServer" line="1958">
                <params>
                    <param name="base64" type="String"/>
                    <param name="env" type="Map<String,?>"/>
                    <param name="isIiop" type="boolean"/>
                </params>
                <comment line="1960">
                    could forbid &quot;iiop:&quot; URL here -- but do we need to?                    
                </comment>
                <declaration name="serialized" type="byte[]" line="1960"/>
                <scope line="1961"/>
                <scope line="1963"/>
                <declaration name="bin" type="ByteArrayInputStream" line="1967"/>
                <declaration name="loader" type="ClassLoader" line="1969"/>
                <declaration name="oin" type="ObjectInputStream" line="1970"/>
                <declaration name="stub" type="Object" line="1974"/>
                <scope line="1975"/>
                <scope line="1977"/>
            </method>
            <class name="ObjectInputStreamWithLoader" line="1983">
                <extends class="ObjectInputStream"/>
                <comment line="1215">
                    Specific Notification Handle ----------------------------------                    
                </comment>
                <method name="ObjectInputStreamWithLoader" type="constructor" line="1986">
                    <params>
                        <param name="in" type="InputStream"/>
                        <param name="cl" type="ClassLoader"/>
                    </params>
                </method>
                <method name="resolveClass" type="Class<?>" line="1993">
                    <params>
                        <param name="classDesc" type="ObjectStreamClass"/>
                    </params>
                </method>
                <declaration name="loader" type="ClassLoader" line="1997"/>
            </class>
            <declaration name="rmiServerImplStubClassName" type="String" line="2065"/>
            <declaration name="rmiServerImplStubClass" type="Class&lt;?&gt;" line="2067"/>
            <declaration name="rmiConnectionImplStubClassName" type="String" line="2068"/>
            <declaration name="rmiConnectionImplStubClass" type="Class&lt;?&gt;" line="2070"/>
            <declaration name="pRefClassName" type="String" line="2071"/>
            <declaration name="proxyRefConstructor" type="Constructor&lt;?&gt;" line="2073"/>
            <scope line="2074">
                <declaration name="pRefByteCodeString" type="String" line="2075"/>
                <declaration name="pRefByteCode" type="byte[]" line="2087"/>
                <anonymous_class line="2090">
                    <method name="run" type="Constructor<?>" line="2091">
                        <declaration name="thisClass" type="Class" line="2092"/>
                        <declaration name="thisLoader" type="ClassLoader" line="2093"/>
                        <declaration name="thisProtectionDomain" type="ProtectionDomain" line="2094"/>
                        <declaration name="otherClassNames" type="String[]" line="2096"/>
                        <declaration name="cl" type="ClassLoader" line="2097"/>
                        <declaration name="c" type="Class&lt;?&gt;" line="2103"/>
                    </method>
                </anonymous_class>
                <declaration name="action" type="PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;" line="2089"/>
                <declaration name="serverStubClass" type="Class&lt;?&gt;" line="2108"/>
                <scope line="2109"/>
                <scope line="2111"/>
                <declaration name="stubClass" type="Class&lt;?&gt;" line="2120"/>
                <declaration name="constr" type="Constructor&lt;?&gt;" line="2121"/>
                <scope line="2122"/>
                <scope line="2125"/>
            </scope>
            <method name="shadowJrmpStub" type="RMIConnection" line="2140">
                <params>
                    <param name="stub" type="RemoteObject"/>
                </params>
                <declaration name="ref" type="RemoteRef" line="2141"/>
                <declaration name="proxyRef" type="RemoteRef" line="2142"/>
                <declaration name="rmiConnectionImplStubConstructor" type="Constructor&lt;?&gt;" line="2144"/>
                <declaration name="args" type="Object[]" line="2146"/>
                <declaration name="proxyStub" type="RMIConnection" line="2147"/>
            </method>
            <declaration name="iiopConnectionStubClassName" type="String" line="2268"/>
            <declaration name="proxyStubClassName" type="String" line="2270"/>
            <declaration name="ProxyInputStreamClassName" type="String" line="2272"/>
            <declaration name="pInputStreamClassName" type="String" line="2274"/>
            <declaration name="proxyStubClass" type="Class&lt;?&gt;" line="2276"/>
            <scope line="2277">
                <declaration name="proxyStubByteCodeString" type="String" line="2278"/>
                <declaration name="pInputStreamByteCodeString" type="String" line="2301"/>
                <declaration name="proxyStubByteCode" type="byte[]" line="2317"/>
                <declaration name="pInputStreamByteCode" type="byte[]" line="2319"/>
                <declaration name="classNames" type="String[]" line="2321"/>
                <declaration name="byteCodes" type="byte[][]" line="2322"/>
                <declaration name="otherClassNames" type="String[]" line="2323"/>
                <scope line="2327">
                    <anonymous_class line="2329">
                        <method name="run" type="Class<?>" line="2330">
                            <declaration name="thisClass" type="Class" line="2331"/>
                            <declaration name="thisLoader" type="ClassLoader" line="2332"/>
                            <declaration name="thisProtectionDomain" type="ProtectionDomain" line="2333"/>
                            <declaration name="cl" type="ClassLoader" line="2335"/>
                        </method>
                    </anonymous_class>
                    <declaration name="action" type="PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;" line="2328"/>
                    <declaration name="stubClass" type="Class&lt;?&gt;" line="2344"/>
                    <scope line="2345"/>
                    <scope line="2347"/>
                </scope>
                <scope line="2354"/>
            </scope>
            <method name="shadowIiopStub" type="RMIConnection" line="2360">
                <params>
                    <param name="stub" type="Object"/>
                </params>
                <declaration name="proxyStub" type="Object" line="2361"/>
            </method>
            <method name="getConnection" type="RMIConnection" line="2369">
                <params>
                    <param name="server" type="RMIServer"/>
                    <param name="credentials" type="Object"/>
                    <param name="checkStub" type="boolean"/>
                </params>
                <comment line="2388">
                    so just return the original stub, which will work for all
                     but the most exotic class loading situations                    
                </comment>
                <declaration name="c" type="RMIConnection" line="2370"/>
                <scope line="2372"/>
                <scope line="2381"/>
            </method>
            <method name="base64ToByteArray" type="byte[]" line="2393">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="2412">
                    Translate all full groups from base64 to byte array elements                    
                </comment>
                <comment line="2424">
                    Translate partial group, if present                    
                </comment>
                <comment line="2435">
                    assert inCursor == s.length()-missingBytesInLastGroup;
                     assert outCursor == result.length;                    
                </comment>
                <declaration name="sLen" type="int" line="2394"/>
                <declaration name="numGroups" type="int" line="2395"/>
                <declaration name="missingBytesInLastGroup" type="int" line="2399"/>
                <declaration name="numFullGroups" type="int" line="2400"/>
                <scope line="2401">
                    <scope line="2402"/>
                </scope>
                <declaration name="result" type="byte[]" line="2409"/>
                <declaration name="inCursor" type="int" line="2412"/>
                <scope line="2413">
                    <declaration name="ch0" type="int" line="2414"/>
                    <declaration name="ch1" type="int" line="2415"/>
                    <declaration name="ch2" type="int" line="2416"/>
                    <declaration name="ch3" type="int" line="2417"/>
                </scope>
                <scope line="2424">
                    <declaration name="ch0" type="int" line="2425"/>
                    <declaration name="ch1" type="int" line="2426"/>
                    <scope line="2429">
                        <declaration name="ch2" type="int" line="2430"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2439">
                Translates the specified character, which is assumed to be in the
                  &quot;Base 64 Alphabet&quot; into its equivalent 6-bit positive integer.                
                <throws>
                    IllegalArgumentException if
                      c is not in the Base64 Alphabet.                    
                </throws>
            </javadoc>
            <method name="base64toInt" type="int" line="2446">
                <params>
                    <param name="c" type="char"/>
                </params>
                <declaration name="result" type="int" line="2447"/>
            </method>
            <declaration name="base64ToInt" type="byte" line="2459"/>
            <javadoc line="2459">
                This array is a lookup table that translates unicode characters
                  drawn from the &quot;Base64 Alphabet&quot; (as specified in Table 1 of RFC 2045)
                  into their 6-bit positive integer equivalents.  Characters that
                  are not in the Base64 alphabet but fall within the bounds of the
                  array are translated to -1.                
            </javadoc>
            <method name="pushDefaultClassLoader" type="ClassLoader" line="2479">
                <declaration name="t" type="Thread" line="2480"/>
                <declaration name="old" type="ClassLoader" line="2481"/>
                <anonymous_class line="2483">
                    <method name="run" type="Void" line="2484"/>
                </anonymous_class>
            </method>
            <method name="popDefaultClassLoader" type="void" line="2492">
                <params>
                    <param name="old" type="ClassLoader"/>
                </params>
                <anonymous_class line="2493">
                    <method name="run" type="Void" line="2494"/>
                </anonymous_class>
            </method>
            <declaration name="rmiServer" type="RMIServer" line="2504"/>
            <javadoc line="2504">
                @serial The RMIServer stub of the RMI JMX Connector server to
                  which this client connector is (or will be) connected. This
                  field can be null when &lt;var&gt;jmxServiceURL&lt;/var&gt; is not
                  null. This includes the case where &lt;var&gt;jmxServiceURL&lt;/var&gt;
                  contains a serialized RMIServer stub. If both
                  &lt;var&gt;rmiServer&lt;/var&gt; and &lt;var&gt;jmxServiceURL&lt;/var&gt; are null then
                  serialization will fail.                
                <see>
                    #RMIConnector(RMIServer,Map)                    
                </see>
            </javadoc>
            <declaration name="jmxServiceURL" type="JMXServiceURL" line="2517"/>
            <javadoc line="2517">
                @serial The JMXServiceURL of the RMI JMX Connector server to
                  which this client connector will be connected. This field can
                  be null when &lt;var&gt;rmiServer&lt;/var&gt; is not null. If both
                  &lt;var&gt;rmiServer&lt;/var&gt; and &lt;var&gt;jmxServiceURL&lt;/var&gt; are null then
                  serialization will fail.                
                <see>
                    #RMIConnector(JMXServiceURL,Map)                    
                </see>
            </javadoc>
            <declaration name="env" type="Map&lt;String,Object&gt;" line="2533"/>
            <declaration name="defaultClassLoader" type="ClassLoader" line="2534"/>
            <declaration name="connection" type="RMIConnection" line="2535"/>
            <declaration name="connectionId" type="String" line="2536"/>
            <declaration name="clientNotifSeqNo" type="long" line="2538"/>
            <declaration name="rmbscMap" type="WeakHashMap&lt;Subject,MBeanServerConnection&gt;" line="2540"/>
            <declaration name="rmiNotifClient" type="RMINotifClient" line="2542"/>
            <declaration name="clientNotifCounter" type="long" line="2545"/>
            <declaration name="connected" type="boolean" line="2547"/>
            <declaration name="terminated" type="boolean" line="2549"/>
            <declaration name="closeException" type="Exception" line="2552"/>
            <declaration name="connectionBroadcaster" type="NotificationBroadcasterSupport" line="2554"/>
            <declaration name="communicatorAdmin" type="ClientCommunicatorAdmin" line="2556"/>
            <declaration name="orb" type="WeakReference&lt;Object&gt;" line="2558"/>
            <javadoc line="2558">
                A static WeakReference to an {@link org.omg.CORBA.ORB ORB} to
                  connect unconnected stubs.                
            </javadoc>
            <method name="objects" type="String" line="2566">
                <params>
                    <param name="objs" type="Object[]"/>
                </params>
            </method>
            <method name="strings" type="String" line="2573">
                <params>
                    <param name="strs" type="String[]"/>
                </params>
            </method>
        </class>
    </source>