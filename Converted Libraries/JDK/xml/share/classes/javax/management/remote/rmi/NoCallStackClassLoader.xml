<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management.remote.rmi">
        <import package="java.security.ProtectionDomain"/>
        <class name="NoCallStackClassLoader" line="30">
            <extends class="ClassLoader"/>
            <comment line="118">
                This method is called at most once per name.  Define the name
                 if it is one of the classes whose byte code we have, or
                 delegate the load if it is one of the referenced classes.                
            </comment>
            <javadoc line="30">
                &lt;p&gt;A class loader that only knows how to define a limited number
                  of classes, and load a limited number of other classes through
                  delegation to another loader.  It is used to get around a problem
                  with Serialization, in particular as used by RMI (including
                  RMI/IIOP).  The JMX Remote API defines exactly what class loader
                  must be used to deserialize arguments on the server, and return
                  values on the client.  We communicate this class loader to RMI by
                  setting it as the context class loader.  RMI uses the context
                  class loader to load classes as it deserializes, which is what we
                  want.  However, before consulting the context class loader, it
                  looks up the call stack for a class with a non-null class loader,
                  and uses that if it finds one.  So, in the standalone version of
                  javax.management.remote, if the class you&apos;re looking for is known
                  to the loader of jmxremote.jar (typically the system class loader)
                  then that loader will load it.  This contradicts the class-loading
                  semantics required.
                  &lt;p&gt;We get around the problem by ensuring that the search up the
                  call stack will find a non-null class loader that doesn&apos;t load any
                  classes of interest, namely this one.  So even though this loader
                  is indeed consulted during deserialization, it never finds the
                  class being deserialized.  RMI then proceeds to use the context
                  class loader, as we require.
                  &lt;p&gt;This loader is constructed with the name and byte-code of one
                  or more classes that it defines, and a class-loader to which it
                  will delegate certain other classes required by that byte-code.
                  We construct the byte-code somewhat painstakingly, by compiling
                  the Java code directly, converting into a string, copying that
                  string into the class that needs this loader, and using the
                  stringToBytes method to convert it into the byte array.  We
                  compile with -g:none because there&apos;s not much point in having
                  line-number information and the like in these directly-encoded
                  classes.
                  &lt;p&gt;The referencedClassNames should contain the names of all
                  classes that are referenced by the classes defined by this loader.
                  It is not necessary to include standard J2SE classes, however.
                  Here, a class is referenced if it is the superclass or a
                  superinterface of a defined class, or if it is the type of a
                  field, parameter, or return value.  A class is not referenced if
                  it only appears in the throws clause of a method or constructor.
                  Of course, referencedClassNames should not contain any classes
                  that the user might want to deserialize, because the whole point
                  of this loader is that it does not find such classes.                
            </javadoc>
            <javadoc line="79">
                Simplified constructor when this loader only defines one class.                
            </javadoc>
            <method name="NoCallStackClassLoader" type="constructor" line="84">
                <params>
                    <param name="className" type="String"/>
                    <param name="byteCode" type="byte[]"/>
                    <param name="referencedClassNames" type="String[]"/>
                    <param name="referencedClassLoader" type="ClassLoader"/>
                    <param name="protectionDomain" type="ProtectionDomain"/>
                </params>
            </method>
            <method name="NoCallStackClassLoader" type="constructor" line="93">
                <params>
                    <param name="classNames" type="String[]"/>
                    <param name="byteCodes" type="byte[][]"/>
                    <param name="referencedClassNames" type="String[]"/>
                    <param name="referencedClassLoader" type="ClassLoader"/>
                    <param name="protectionDomain" type="ProtectionDomain"/>
                </params>
                <comment line="97">
                                        
                </comment>
                <scope line="101"/>
                <scope line="105"/>
            </method>
            <method name="findClass" type="Class<?>" line="122">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="131">
                    If the referencedClassLoader is null, it is the bootstrap
                     class loader, and there&apos;s no point in delegating to it
                     because it&apos;s already our parent class loader.                    
                </comment>
                <scope line="123">
                    <scope line="124"/>
                </scope>
                <scope line="134">
                    <scope line="135"/>
                </scope>
            </method>
            <declaration name="classNames" type="String[]" line="144"/>
            <declaration name="byteCodes" type="byte[][]" line="145"/>
            <declaration name="referencedClassNames" type="String[]" line="146"/>
            <declaration name="referencedClassLoader" type="ClassLoader" line="147"/>
            <declaration name="protectionDomain" type="ProtectionDomain" line="148"/>
            <javadoc line="150">
                &lt;p&gt;Construct a &lt;code&gt;byte[]&lt;/code&gt; using the characters of the
                  given &lt;code&gt;String&lt;/code&gt;.  Only the low-order byte of each
                  character is used.  This method is useful to reduce the
                  footprint of classes that include big byte arrays (e.g. the
                  byte code of other classes), because a string takes up much
                  less space in a class file than the byte code to initialize a
                  &lt;code&gt;byte[]&lt;/code&gt; with the same number of bytes.&lt;/p&gt;
                  &lt;p&gt;We use just one byte per character even though characters
                  contain two bytes.  The resultant output length is much the
                  same: using one byte per character is shorter because it has
                  more characters in the optimal 1-127 range but longer because
                  it has more zero bytes (which are frequent, and are encoded as
                  two bytes in classfile UTF-8).  But one byte per character has
                  two key advantages: (1) you can see the string constants, which
                  is reassuring, (2) you don&apos;t need to know whether the class
                  file length is odd.&lt;/p&gt;
                  &lt;p&gt;This method differs from {@link String#getBytes()} in that
                  it does not use any encoding.  So it is guaranteed that each
                  byte of the result is numerically identical (mod 256) to the
                  corresponding character of the input.                
            </javadoc>
            <method name="stringToBytes" type="byte[]" line="174">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="slen" type="int" line="175"/>
                <declaration name="bytes" type="byte[]" line="176"/>
            </method>
        </class>
    </source>